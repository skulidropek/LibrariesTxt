[ObsoleteAttribute]
public interface Automatonymous.Activity {
}
[ObsoleteAttribute("Deprecated, use IStateMachineActivity<TSaga> instead", "True")]
public interface Automatonymous.Activity`1 {
}
[ObsoleteAttribute("Deprecated, use IStateMachineActivity<TSaga, TMessage> instead", "True")]
public interface Automatonymous.Activity`2 {
}
[ObsoleteAttribute("Deprecated, use IBehavior instead")]
public interface Automatonymous.Behavior`1 {
}
[ObsoleteAttribute("Deprecated, use IBehavior instead")]
public interface Automatonymous.Behavior`2 {
}
[ObsoleteAttribute("Deprecated, use IEventObserver instead")]
public interface Automatonymous.EventObserver`1 {
}
[ObsoleteAttribute("Deprecated, use IStateObserver instead")]
public interface Automatonymous.StateObserver`1 {
}
public class MassTransit.ActiveJob : object {
    [CompilerGeneratedAttribute]
private Guid <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Deadline>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstanceAddress>k__BackingField;
    public Guid JobId { get; public set; }
    public DateTime Deadline { get; public set; }
    public Uri InstanceAddress { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_JobId();
    [CompilerGeneratedAttribute]
public void set_JobId(Guid value);
    [CompilerGeneratedAttribute]
public DateTime get_Deadline();
    [CompilerGeneratedAttribute]
public void set_Deadline(DateTime value);
    [CompilerGeneratedAttribute]
public Uri get_InstanceAddress();
    [CompilerGeneratedAttribute]
public void set_InstanceAddress(Uri value);
    public sealed virtual bool Equals(ActiveJob other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class MassTransit.ActivityObserverConfigurationExtensions : object {
    [ExtensionAttribute]
public static ConnectHandle ConnectActivityObserver(IBusFactoryConfigurator configurator, IActivityObserver observer);
    [ExtensionAttribute]
public static ConnectHandle ConnectActivityObserver(IReceiveEndpointConfigurator configurator, IActivityObserver observer);
}
public class MassTransit.Agents.ActivePipeContext`1 : object {
    private Task`1<TContext> _context;
    private PipeContextHandle`1<TContext> _contextHandle;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> MassTransit.PipeContextHandle<TContext>.Context { get; }
    public ActivePipeContext`1(PipeContextHandle`1<TContext> contextHandle, Task`1<TContext> context);
    public ActivePipeContext`1(PipeContextHandle`1<TContext> contextHandle, TContext context);
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> MassTransit.PipeContextHandle<TContext>.get_Context();
    [AsyncStateMachineAttribute("MassTransit.Agents.ActivePipeContext`1/<MassTransit-Agents-ActivePipeContextHandle<TContext>-Faulted>d__8")]
private sealed virtual override Task MassTransit.Agents.ActivePipeContextHandle<TContext>.Faulted(Exception exception);
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.Agents.ActivePipeContextAgent`1 : Agent {
    private static string _caption;
    private ActivePipeContextHandle`1<TContext> _contextHandle;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> MassTransit.PipeContextHandle<TContext>.Context { get; }
    public ActivePipeContextAgent`1(ActivePipeContextHandle`1<TContext> context);
    private static ActivePipeContextAgent`1();
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> MassTransit.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override Task MassTransit.Agents.ActivePipeContextHandle<TContext>.Faulted(Exception exception);
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    [AsyncStateMachineAttribute("MassTransit.Agents.ActivePipeContextAgent`1/<StopAgent>d__9")]
protected virtual Task StopAgent(StopContext context);
    public virtual string ToString();
}
public interface MassTransit.Agents.ActivePipeContextHandle`1 {
    public abstract virtual Task Faulted(Exception exception);
}
public class MassTransit.Agents.AsyncPipeContextAgent`1 : object {
    private IPipeContextAgent`1<TContext> _agent;
    private TaskCompletionSource`1<TContext> _context;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> MassTransit.PipeContextHandle<TContext>.Context { get; }
    private Task MassTransit.IAgent.Ready { get; }
    private Task MassTransit.IAgent.Completed { get; }
    private CancellationToken MassTransit.IAgent.Stopping { get; }
    private CancellationToken MassTransit.IAgent.Stopped { get; }
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> MassTransit.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private sealed virtual override Task MassTransit.IAgent.get_Ready();
    private sealed virtual override Task MassTransit.IAgent.get_Completed();
    private sealed virtual override CancellationToken MassTransit.IAgent.get_Stopping();
    private sealed virtual override CancellationToken MassTransit.IAgent.get_Stopped();
    private sealed virtual override Task MassTransit.IAgent.Stop(StopContext context);
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.Created(TContext context);
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.CreateCanceled();
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.CreateFaulted(Exception exception);
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.Faulted(Exception exception);
    public virtual string ToString();
}
public class MassTransit.Agents.AsyncPipeContextFilter`1 : object {
    private IAsyncPipeContextAgent`1<TContext> _agent;
    public AsyncPipeContextFilter`1(IAsyncPipeContextAgent`1<TContext> agent);
    [AsyncStateMachineAttribute("MassTransit.Agents.AsyncPipeContextFilter`1/<Send>d__2")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Agents.AsyncPipeContextHandle`1 : object {
    private TaskCompletionSource`1<TContext> _context;
    private TaskCompletionSource`1<DateTime> _inactive;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> MassTransit.PipeContextHandle<TContext>.Context { get; }
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> MassTransit.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.Created(TContext context);
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.CreateCanceled();
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.CreateFaulted(Exception exception);
    private sealed virtual override Task MassTransit.IAsyncPipeContextHandle<TContext>.Faulted(Exception exception);
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
}
public class MassTransit.Agents.AsyncPipeContextPipe`1 : object {
    private IAsyncPipeContextAgent`1<TContext> _agent;
    private IPipe`1<TContext> _pipe;
    public AsyncPipeContextPipe`1(IAsyncPipeContextAgent`1<TContext> agent, IPipe`1<TContext> pipe);
    [AsyncStateMachineAttribute("MassTransit.Agents.AsyncPipeContextPipe`1/<Send>d__3")]
public sealed virtual Task Send(TContext context);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Agents.ConstantPipeContextHandle`1 : object {
    private TContext _context;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Task`1<TContext> <Context>k__BackingField;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    public Task`1<TContext> Context { get; }
    public ConstantPipeContextHandle`1(TContext context);
    [AsyncStateMachineAttribute("MassTransit.Agents.ConstantPipeContextHandle`1/<System-IAsyncDisposable-DisposeAsync>d__3")]
private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<TContext> get_Context();
}
public interface MassTransit.Agents.IActivePipeContextAgent`1 {
}
public interface MassTransit.Agents.IAsyncPipeContextAgent`1 {
}
public interface MassTransit.Agents.IPipeContextAgent`1 {
}
public interface MassTransit.Agents.IPipeContextFactory`1 {
    public abstract virtual IPipeContextAgent`1<TContext> CreateContext(ISupervisor supervisor);
    public abstract virtual IActivePipeContextAgent`1<TContext> CreateActiveContext(ISupervisor supervisor, PipeContextHandle`1<TContext> context, CancellationToken cancellationToken);
}
public class MassTransit.Agents.PipeContextAgent`1 : Agent {
    private Task`1<TContext> _context;
    private TaskCompletionSource`1<DateTime> _inactive;
    private bool MassTransit.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> MassTransit.PipeContextHandle<TContext>.Context { get; }
    public PipeContextAgent`1(TContext context);
    public PipeContextAgent`1(Task`1<TContext> context);
    private sealed virtual override bool MassTransit.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> MassTransit.PipeContextHandle<TContext>.get_Context();
    [AsyncStateMachineAttribute("MassTransit.Agents.PipeContextAgent`1/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("MassTransit.Agents.PipeContextAgent`1/<StopAgent>d__9")]
protected virtual Task StopAgent(StopContext context);
}
public class MassTransit.Agents.PipeContextSupervisor`1 : Supervisor {
    private ISupervisor _activeSupervisor;
    private IPipeContextFactory`1<TContext> _contextFactory;
    private object _contextLock;
    private PipeContextHandle`1<TContext> _context;
    protected bool HasContext { get; }
    public PipeContextSupervisor`1(IPipeContextFactory`1<TContext> contextFactory);
    protected bool get_HasContext();
    [AsyncStateMachineAttribute("MassTransit.Agents.PipeContextSupervisor`1/<Send>d__7")]
public sealed virtual Task Send(IPipe`1<TContext> pipe, CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Agents.PipeContextSupervisor`1/<StopSupervisor>d__9")]
protected virtual Task StopSupervisor(StopSupervisorContext context);
    [AsyncStateMachineAttribute("MassTransit.Agents.PipeContextSupervisor`1/<ActiveAndActualAgentsCompleted>d__10")]
private Task ActiveAndActualAgentsCompleted(StopSupervisorContext context);
    private IActivePipeContextAgent`1<TContext> CreateActiveContext(CancellationToken cancellationToken);
    private PipeContextHandle`1<TContext> GetContext();
}
public class MassTransit.AsyncBusHandle : object {
    private IBusDepot _depot;
    private ILogger`1<MassTransitBus> _logger;
    private IOptions`1<MassTransitHostOptions> _options;
    private Task _startTask;
    private CancellationTokenSource _tokenSource;
    private bool _stopped;
    public AsyncBusHandle(IBusDepot depot, ILogger`1<MassTransitBus> logger, IOptions`1<MassTransitHostOptions> options);
    [AsyncStateMachineAttribute("MassTransit.AsyncBusHandle/<DisposeAsync>d__7")]
public sealed virtual ValueTask DisposeAsync();
}
public interface MassTransit.Audit.IConsumeMetadataFactory {
    public abstract virtual MessageAuditMetadata CreateAuditMetadata(ConsumeContext`1<T> context);
}
public interface MassTransit.Audit.IMessageAuditStore {
    public abstract virtual Task StoreMessage(T message, MessageAuditMetadata metadata);
}
public interface MassTransit.Audit.ISendMetadataFactory {
    public abstract virtual MessageAuditMetadata CreateAuditMetadata(SendContext`1<T> context);
    public abstract virtual MessageAuditMetadata CreateAuditMetadata(PublishContext`1<T> context);
}
public class MassTransit.Audit.MessageAuditMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <InitiatorId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SentTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FaultAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContextType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Custom>k__BackingField;
    public Nullable`1<Guid> MessageId { get; public set; }
    public Nullable`1<Guid> ConversationId { get; public set; }
    public Nullable`1<Guid> CorrelationId { get; public set; }
    public Nullable`1<Guid> InitiatorId { get; public set; }
    public Nullable`1<Guid> RequestId { get; public set; }
    public Nullable`1<DateTime> SentTime { get; public set; }
    public string SourceAddress { get; public set; }
    public string DestinationAddress { get; public set; }
    public string InputAddress { get; public set; }
    public string ResponseAddress { get; public set; }
    public string FaultAddress { get; public set; }
    public string ContextType { get; public set; }
    public Dictionary`2<string, string> Headers { get; public set; }
    public Dictionary`2<string, string> Custom { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ConversationId();
    [CompilerGeneratedAttribute]
public void set_ConversationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_InitiatorId();
    [CompilerGeneratedAttribute]
public void set_InitiatorId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_SentTime();
    [CompilerGeneratedAttribute]
public void set_SentTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_SourceAddress();
    [CompilerGeneratedAttribute]
public void set_SourceAddress(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationAddress();
    [CompilerGeneratedAttribute]
public void set_DestinationAddress(string value);
    [CompilerGeneratedAttribute]
public string get_InputAddress();
    [CompilerGeneratedAttribute]
public void set_InputAddress(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseAddress();
    [CompilerGeneratedAttribute]
public void set_ResponseAddress(string value);
    [CompilerGeneratedAttribute]
public string get_FaultAddress();
    [CompilerGeneratedAttribute]
public void set_FaultAddress(string value);
    [CompilerGeneratedAttribute]
public string get_ContextType();
    [CompilerGeneratedAttribute]
public void set_ContextType(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Custom();
    [CompilerGeneratedAttribute]
public void set_Custom(Dictionary`2<string, string> value);
}
public class MassTransit.Audit.MetadataFactories.DefaultConsumeMetadataFactory : object {
    private sealed virtual override MessageAuditMetadata MassTransit.Audit.IConsumeMetadataFactory.CreateAuditMetadata(ConsumeContext`1<T> context);
    private static MessageAuditMetadata CreateMetadata(ConsumeContext context, string contextType);
}
public class MassTransit.Audit.MetadataFactories.DefaultSendMetadataFactory : object {
    private sealed virtual override MessageAuditMetadata MassTransit.Audit.ISendMetadataFactory.CreateAuditMetadata(SendContext`1<T> context);
    private sealed virtual override MessageAuditMetadata MassTransit.Audit.ISendMetadataFactory.CreateAuditMetadata(PublishContext`1<T> context);
    private static MessageAuditMetadata CreateMetadata(SendContext context, string contextType);
}
public class MassTransit.Audit.Observers.AuditConsumeObserver : object {
    private CompositeFilter`1<ConsumeContext> _filter;
    private IConsumeMetadataFactory _metadataFactory;
    private IMessageAuditStore _store;
    public AuditConsumeObserver(IMessageAuditStore store, IConsumeMetadataFactory metadataFactory, CompositeFilter`1<ConsumeContext> filter);
    private sealed virtual override Task MassTransit.IConsumeObserver.PreConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.PostConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.ConsumeFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Audit.Observers.AuditPublishObserver : object {
    private CompositeFilter`1<SendContext> _filter;
    private ISendMetadataFactory _metadataFactory;
    private IMessageAuditStore _store;
    public AuditPublishObserver(IMessageAuditStore store, ISendMetadataFactory metadataFactory, CompositeFilter`1<SendContext> filter);
    private sealed virtual override Task MassTransit.IPublishObserver.PrePublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PostPublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PublishFault(PublishContext`1<T> context, Exception exception);
}
public class MassTransit.Audit.Observers.AuditSendObserver : object {
    private CompositeFilter`1<SendContext> _filter;
    private ISendMetadataFactory _metadataFactory;
    private IMessageAuditStore _store;
    public AuditSendObserver(IMessageAuditStore store, ISendMetadataFactory metadataFactory, CompositeFilter`1<SendContext> filter);
    private sealed virtual override Task MassTransit.ISendObserver.PreSend(SendContext`1<T> context);
    private sealed virtual override Task MassTransit.ISendObserver.PostSend(SendContext`1<T> context);
    private sealed virtual override Task MassTransit.ISendObserver.SendFault(SendContext`1<T> context, Exception exception);
}
[ExtensionAttribute]
public static class MassTransit.AuditConfigurationExtensions : object {
    [ExtensionAttribute]
public static ConnectHandle ConnectSendAuditObservers(T connector, IMessageAuditStore store, Action`1<IMessageFilterConfigurator> configureFilter, ISendMetadataFactory metadataFactory);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumeAuditObserver(IConsumeObserverConnector connector, IMessageAuditStore store, Action`1<IMessageFilterConfigurator> configureFilter, IConsumeMetadataFactory metadataFactory);
}
[ExtensionAttribute]
public static class MassTransit.BatchConsumerExtensions : object {
    [ExtensionAttribute]
public static void Batch(IReceiveEndpointConfigurator configurator, Action`1<IBatchConfigurator`1<TMessage>> configure);
    [ExtensionAttribute]
public static void Consumer(IBatchConfigurator`1<TMessage> configurator, Func`1<TConsumer> consumerFactoryMethod);
    [ExtensionAttribute]
public static void Consumer(IBatchConfigurator`1<TMessage> configurator, IConsumerFactory`1<TConsumer> consumerFactory);
}
public class MassTransit.Batching.BatchCollector`1 : object {
    private TaskExecutor _collector;
    private IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> _consumerPipe;
    private TaskExecutor _dispatcher;
    private BatchOptions _options;
    private BatchConsumer`1<TMessage> _currentConsumer;
    public BatchCollector`1(BatchOptions options, IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> consumerPipe);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task`1<BatchConsumer`1<TMessage>> Collect(ConsumeContext`1<TMessage> context);
    public sealed virtual Task Complete(ConsumeContext`1<TMessage> context, BatchConsumer`1<TMessage> consumer);
    public sealed virtual void Probe(ProbeContext context);
    private Task Remove(BatchConsumer`1<TMessage> consumer);
    [AsyncStateMachineAttribute("MassTransit.Batching.BatchCollector`1/<Add>d__11")]
private Task`1<BatchConsumer`1<TMessage>> Add(ConsumeContext`1<TMessage> context, Activity currentActivity);
}
public class MassTransit.Batching.BatchCollector`2 : object {
    private TaskExecutor _collector;
    private IDictionary`2<TKey, BatchConsumer`1<TMessage>> _collectors;
    private IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> _consumerPipe;
    private TaskExecutor _dispatcher;
    private IGroupKeyProvider`2<TMessage, TKey> _keyProvider;
    private BatchOptions _options;
    private BatchConsumer`1<TMessage> _currentConsumer;
    public BatchCollector`2(BatchOptions options, IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> consumerPipe, IGroupKeyProvider`2<TMessage, TKey> keyProvider);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task`1<BatchConsumer`1<TMessage>> Collect(ConsumeContext`1<TMessage> context);
    public sealed virtual Task Complete(ConsumeContext`1<TMessage> context, BatchConsumer`1<TMessage> consumer);
    public sealed virtual void Probe(ProbeContext context);
    private Task Remove(ConsumeContext`1<TMessage> context, BatchConsumer`1<TMessage> consumer);
    [AsyncStateMachineAttribute("MassTransit.Batching.BatchCollector`2/<Add>d__13")]
private Task`1<BatchConsumer`1<TMessage>> Add(ConsumeContext`1<TMessage> context, Activity currentActivity);
}
public class MassTransit.Batching.BatchConsumer`1 : object {
    private TaskCompletionSource`1<DateTime> _completed;
    private IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> _consumerPipe;
    private TaskExecutor _dispatcher;
    private TaskExecutor _executor;
    private DateTime _firstMessage;
    private Dictionary`2<Guid, BatchEntry<TMessage>> _messages;
    private BatchOptions _options;
    private Timer _timer;
    private Activity _currentActivity;
    private DateTime _lastMessage;
    private ILogContext _logContext;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    public bool IsCompleted { get; private set; }
    public BatchConsumer`1(BatchOptions options, TaskExecutor executor, TaskExecutor dispatcher, IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> consumerPipe);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [AsyncStateMachineAttribute("MassTransit.Batching.BatchConsumer`1/<Consume>d__16")]
public sealed virtual Task Consume(ConsumeContext`1<TMessage> context);
    private void TimeLimitExpired(object state);
    public Task Add(ConsumeContext`1<TMessage> context, Activity currentActivity);
    private void RemoveCanceledMessage(Guid messageId);
    private bool IsReadyToDeliver(ConsumeContext context);
    public Task ForceComplete();
    [AsyncStateMachineAttribute("MassTransit.Batching.BatchConsumer`1/<Deliver>d__22")]
private Task Deliver(ConsumeContext context, IReadOnlyList`1<ConsumeContext`1<TMessage>> messages, BatchCompletionMode batchCompletionMode);
    private List`1<ConsumeContext`1<TMessage>> GetMessageBatchInOrder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <TimeLimitExpired>b__17_0();
    [CompilerGeneratedAttribute]
private Task <TimeLimitExpired>b__17_1();
}
public class MassTransit.Batching.BatchConsumerFactory`1 : object {
    private IBatchCollector`1<TMessage> _collector;
    private BatchOptions _options;
    public BatchConsumerFactory`1(BatchOptions options, IBatchCollector`1<TMessage> collector);
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("MassTransit.Batching.BatchConsumerFactory`1/<Send>d__4`1")]
public virtual Task Send(ConsumeContext`1<T> context, IPipe`1<ConsumerConsumeContext`2<BatchConsumer`1<TMessage>, T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.Batching.IBatchCollector`1 {
    public abstract virtual Task`1<BatchConsumer`1<TMessage>> Collect(ConsumeContext`1<TMessage> context);
    public abstract virtual Task Complete(ConsumeContext`1<TMessage> context, BatchConsumer`1<TMessage> consumer);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Batching.MessageBatch`1 : object {
    private IReadOnlyList`1<ConsumeContext`1<TMessage>> _messages;
    [CompilerGeneratedAttribute]
private BatchCompletionMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FirstMessageReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastMessageReceived>k__BackingField;
    public BatchCompletionMode Mode { get; public set; }
    public DateTime FirstMessageReceived { get; public set; }
    public DateTime LastMessageReceived { get; public set; }
    public ConsumeContext`1<TMessage> Item { get; }
    public int Length { get; }
    public MessageBatch`1(DateTime firstMessageReceived, DateTime lastMessageReceived, BatchCompletionMode mode, IReadOnlyList`1<ConsumeContext`1<TMessage>> messages);
    [CompilerGeneratedAttribute]
public sealed virtual BatchCompletionMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(BatchCompletionMode value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_FirstMessageReceived();
    [CompilerGeneratedAttribute]
public void set_FirstMessageReceived(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_LastMessageReceived();
    [CompilerGeneratedAttribute]
public void set_LastMessageReceived(DateTime value);
    public sealed virtual ConsumeContext`1<TMessage> get_Item(int index);
    public sealed virtual int get_Length();
    public sealed virtual IEnumerator`1<ConsumeContext`1<TMessage>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class MassTransit.BindConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseBind(IPipeConfigurator`1<TLeft> configurator, Action`1<IBindConfigurator`1<TLeft>> configure);
}
public class MassTransit.BuildItineraryCallback`1 : MulticastDelegate {
    public BuildItineraryCallback`1(object object, IntPtr method);
    public virtual Task Invoke(BehaviorContext`2<FutureState, TInput> context, IItineraryBuilder builder);
    public virtual IAsyncResult BeginInvoke(BehaviorContext`2<FutureState, TInput> context, IItineraryBuilder builder, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public static class MassTransit.Bus : object {
    [CompilerGeneratedAttribute]
private static IBusFactorySelector <Factory>k__BackingField;
    public static IBusFactorySelector Factory { get; }
    private static Bus();
    [CompilerGeneratedAttribute]
public static IBusFactorySelector get_Factory();
}
[ExtensionAttribute]
public static class MassTransit.BusControlExtensions : object {
    [ExtensionAttribute]
public static void Stop(IBusControl busControl);
    [ExtensionAttribute]
public static void Start(IBusControl busControl);
    [ExtensionAttribute]
public static void Stop(IBusControl bus, TimeSpan stopTimeout);
    [ExtensionAttribute]
public static void Start(IBusControl bus, TimeSpan startTimeout);
    [AsyncStateMachineAttribute("MassTransit.BusControlExtensions/<StartAsync>d__4")]
[ExtensionAttribute]
public static Task`1<BusHandle> StartAsync(IBusControl bus, TimeSpan startTimeout);
    [AsyncStateMachineAttribute("MassTransit.BusControlExtensions/<StopAsync>d__5")]
[ExtensionAttribute]
public static Task StopAsync(IBusControl bus, TimeSpan stopTimeout);
    [AsyncStateMachineAttribute("MassTransit.BusControlExtensions/<DeployAsync>d__6")]
[ExtensionAttribute]
public static Task DeployAsync(IBusControl bus, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.BusFactoryExtensions : object {
    [ExtensionAttribute]
public static IBusControl Build(IBusFactory factory, IBusConfiguration busConfiguration, IEnumerable`1<ISpecification> dependencies);
    [ExtensionAttribute]
public static IBusControl Build(IBusFactory factory, IBusConfiguration busConfiguration);
    private static IBusControl Build(IBusFactory factory, IBusConfiguration busConfiguration, IEnumerable`1<ValidationResult> validationResult);
}
[ExtensionAttribute]
public static class MassTransit.BusHandleExtensions : object {
    [ExtensionAttribute]
public static void Stop(BusHandle handle);
    [ExtensionAttribute]
public static void Stop(BusHandle handle, TimeSpan stopTimeout);
    [AsyncStateMachineAttribute("MassTransit.BusHandleExtensions/<StopAsync>d__2")]
[ExtensionAttribute]
public static Task StopAsync(BusHandle handle, TimeSpan stopTimeout);
}
public class MassTransit.Caching.CacheSettings : object {
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinAge>k__BackingField;
    [CompilerGeneratedAttribute]
private CurrentTimeProvider <NowProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeSlots>k__BackingField;
    public int Capacity { get; public set; }
    public TimeSpan MaxAge { get; public set; }
    public TimeSpan MinAge { get; public set; }
    public CurrentTimeProvider NowProvider { get; public set; }
    public int BucketCount { get; public set; }
    public int TimeSlots { get; public set; }
    public CacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge, CurrentTimeProvider nowProvider);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    [CompilerGeneratedAttribute]
public void set_Capacity(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MinAge();
    [CompilerGeneratedAttribute]
public void set_MinAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public CurrentTimeProvider get_NowProvider();
    [CompilerGeneratedAttribute]
public void set_NowProvider(CurrentTimeProvider value);
    [CompilerGeneratedAttribute]
public int get_BucketCount();
    [CompilerGeneratedAttribute]
public void set_BucketCount(int value);
    [CompilerGeneratedAttribute]
public int get_TimeSlots();
    [CompilerGeneratedAttribute]
public void set_TimeSlots(int value);
    private static DateTime CurrentTime();
}
public class MassTransit.Caching.CurrentTimeProvider : MulticastDelegate {
    public CurrentTimeProvider(object object, IntPtr method);
    public virtual DateTime Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
public class MassTransit.Caching.GreenCache`1 : object {
    private IDictionary`2<string, ICacheIndex`1<TValue>> _indices;
    private INodeTracker`1<TValue> _nodeTracker;
    public CacheStatistics Statistics { get; }
    public GreenCache`1(CacheSettings settings);
    public CacheStatistics get_Statistics();
    public sealed virtual IIndex`2<TKey, TValue> AddIndex(string name, KeyProvider`2<TKey, TValue> keyProvider, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public sealed virtual IIndex`2<TKey, TValue> GetIndex(string name);
    public sealed virtual void Add(TValue value);
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<Task`1<TValue>> GetAll();
    public sealed virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
}
public interface MassTransit.Caching.ICache`1 {
    public abstract virtual IIndex`2<TKey, TValue> AddIndex(string name, KeyProvider`2<TKey, TValue> keyProvider, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public abstract virtual IIndex`2<TKey, TValue> GetIndex(string name);
    public abstract virtual void Add(TValue value);
    public abstract virtual IEnumerable`1<Task`1<TValue>> GetAll();
    public abstract virtual void Clear();
}
public interface MassTransit.Caching.ICacheValueObserver`1 {
    public abstract virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public abstract virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public abstract virtual void CacheCleared();
}
public interface MassTransit.Caching.IConnectCacheValueObserver`1 {
    public abstract virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
}
public interface MassTransit.Caching.IIndex`2 {
    public abstract virtual Task`1<TValue> Get(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public abstract virtual bool Remove(TKey key);
}
public interface MassTransit.Caching.INode`1 {
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual bool get_HasValue();
    public abstract virtual bool get_IsValid();
    public abstract virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
}
public interface MassTransit.Caching.INotifyValueUsed {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Used(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Used(Action value);
}
public class MassTransit.Caching.Internals.Bucket`1 : object {
    private INodeTracker`1<TValue> _tracker;
    private int _count;
    private IBucketNode`1<TValue> _head;
    private DateTime _startTime;
    private Nullable`1<DateTime> _stopTime;
    public IBucketNode`1<TValue> Head { get; }
    public int Count { get; }
    public Bucket`1(INodeTracker`1<TValue> tracker);
    public IBucketNode`1<TValue> get_Head();
    public int get_Count();
    public bool HasExpired(DateTime expirationTime);
    public bool IsOldEnough(DateTime agedTime);
    public void Clear();
    public void Stop(DateTime now);
    public void Start(DateTime now);
    public void Push(IBucketNode`1<TValue> node);
    public void Used(IBucketNode`1<TValue> node);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Caching.Internals.BucketCollection`1 : object {
    private Bucket`1[] _buckets;
    public Bucket`1<TValue> Item { get; }
    public int Count { get; }
    public BucketCollection`1(INodeTracker`1<TValue> nodeTracker, int capacity);
    public Bucket`1<TValue> get_Item(int index);
    public int get_Count();
    public void Empty();
}
public class MassTransit.Caching.Internals.BucketNode`1 : object {
    private Bucket`1<TValue> _bucket;
    private IBucketNode`1<TValue> _next;
    private Task`1<TValue> _value;
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public Bucket`1<TValue> Bucket { get; }
    public IBucketNode`1<TValue> Next { get; }
    public BucketNode`1(TValue value);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsValid();
    public sealed virtual Bucket`1<TValue> get_Bucket();
    public sealed virtual IBucketNode`1<TValue> get_Next();
    public sealed virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
    public sealed virtual void SetBucket(Bucket`1<TValue> bucket, IBucketNode`1<TValue> next);
    public sealed virtual void AssignToBucket(Bucket`1<TValue> bucket);
    public sealed virtual void Evict();
    public sealed virtual IBucketNode`1<TValue> Pop();
    private void Used();
}
public class MassTransit.Caching.Internals.CacheStatistics : object {
    private int _count;
    private int _createFaults;
    private long _hits;
    private long _misses;
    private int _totalCount;
    [CompilerGeneratedAttribute]
private TimeSpan <ValidityCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinAge>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldestBucketIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentBucketIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public TimeSpan ValidityCheckInterval { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinAge { get; }
    public int BucketSize { get; }
    public int BucketCount { get; }
    public int OldestBucketIndex { get; private set; }
    public int CurrentBucketIndex { get; private set; }
    public int Capacity { get; }
    public int Count { get; }
    public int TotalCount { get; }
    public long Misses { get; }
    public long Hits { get; }
    public int CreateFaults { get; }
    public CacheStatistics(int capacity, int bucketCount, int bucketSize, TimeSpan minAge, TimeSpan maxAge, TimeSpan validityCheckInterval);
    [CompilerGeneratedAttribute]
public TimeSpan get_ValidityCheckInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public TimeSpan get_MinAge();
    [CompilerGeneratedAttribute]
public int get_BucketSize();
    [CompilerGeneratedAttribute]
public int get_BucketCount();
    [CompilerGeneratedAttribute]
public int get_OldestBucketIndex();
    [CompilerGeneratedAttribute]
private void set_OldestBucketIndex(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentBucketIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentBucketIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public int get_Count();
    public int get_TotalCount();
    public long get_Misses();
    public long get_Hits();
    public int get_CreateFaults();
    public void Reset();
    internal void ValueAdded();
    internal void ValueRemoved();
    internal void Miss();
    internal void Hit();
    public virtual string ToString();
    internal void SetBucketIndices(int oldestBucketIndex, int currentBucketIndex);
    public void CreateFaulted();
}
internal class MassTransit.Caching.Internals.CacheValueObservable`1 : object {
    private Dictionary`2<long, ICacheValueObserver`1<TValue>> _connections;
    private ICacheValueObserver`1[] _connected;
    private long _nextId;
    public sealed virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public sealed virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public sealed virtual void CacheCleared();
    public ConnectHandle Connect(ICacheValueObserver`1<TValue> connection);
    public void ForEach(Action`1<ICacheValueObserver`1<TValue>> callback);
    private void Disconnect(long id);
}
public class MassTransit.Caching.Internals.FactoryNode`1 : object {
    private INodeValueFactory`1<TValue> _nodeValueFactory;
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public FactoryNode`1(INodeValueFactory`1<TValue> nodeValueFactory);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsValid();
    public sealed virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
}
public interface MassTransit.Caching.Internals.IBucketNode`1 {
    public Bucket`1<TValue> Bucket { get; }
    public IBucketNode`1<TValue> Next { get; }
    public abstract virtual Bucket`1<TValue> get_Bucket();
    public abstract virtual IBucketNode`1<TValue> get_Next();
    public abstract virtual void SetBucket(Bucket`1<TValue> bucket, IBucketNode`1<TValue> next);
    public abstract virtual void AssignToBucket(Bucket`1<TValue> bucket);
    public abstract virtual void Evict();
    public abstract virtual IBucketNode`1<TValue> Pop();
}
public interface MassTransit.Caching.Internals.ICacheIndex`1 {
    public Type KeyType { get; }
    public abstract virtual Type get_KeyType();
    public abstract virtual void Clear();
    public abstract virtual Task`1<bool> Add(INode`1<TValue> node);
    public abstract virtual bool TryGetExistingNode(TValue value, INode`1& node);
}
public class MassTransit.Caching.Internals.Index`2 : object {
    private KeyProvider`2<TKey, TValue> _keyProvider;
    private object _lock;
    private INodeTracker`1<TValue> _nodeTracker;
    private Dictionary`2<TKey, WeakReference`1<INode`1<TValue>>> _index;
    private Type MassTransit.Caching.Internals.ICacheIndex<TValue>.KeyType { get; }
    public Index`2(INodeTracker`1<TValue> nodeTracker, KeyProvider`2<TKey, TValue> keyProvider);
    private sealed virtual override Type MassTransit.Caching.Internals.ICacheIndex<TValue>.get_KeyType();
    public sealed virtual void Clear();
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.Index`2/<Add>d__8")]
public sealed virtual Task`1<bool> Add(INode`1<TValue> node);
    public sealed virtual bool TryGetExistingNode(TValue value, INode`1& node);
    public sealed virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public sealed virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public sealed virtual void CacheCleared();
    public sealed virtual Task`1<TValue> Get(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public sealed virtual bool Remove(TKey key);
    private bool TryGetExistingNode(TKey key, INode`1& existingNode);
    private void Rebuild();
    [CompilerGeneratedAttribute]
private TKey <Rebuild>b__16_0(INode`1<TValue> node);
}
public interface MassTransit.Caching.Internals.INodeTracker`1 {
    public CacheStatistics Statistics { get; }
    public abstract virtual CacheStatistics get_Statistics();
    public abstract virtual void Add(INodeValueFactory`1<TValue> nodeValueFactory);
    public abstract virtual void Add(TValue value);
    public abstract virtual void Rebucket(IBucketNode`1<TValue> node);
    public abstract virtual void Remove(INode`1<TValue> existingNode);
    public abstract virtual IEnumerable`1<INode`1<TValue>> GetAll();
    public abstract virtual void Clear();
}
public interface MassTransit.Caching.Internals.INodeValueFactory`1 {
    public Task`1<TValue> Value { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual void Add(IPendingValue`1<TValue> pendingValue);
    public abstract virtual Task`1<TValue> CreateValue();
}
public class MassTransit.Caching.Internals.NodeTracker`1 : object {
    private static double MaxAgeUpperLimit;
    private int _bucketCount;
    private int _bucketSize;
    private object _lock;
    private TimeSpan _maxAge;
    private TimeSpan _minAge;
    private CurrentTimeProvider _nowProvider;
    private CacheValueObservable`1<TValue> _observers;
    private TimeSpan _validityCheckInterval;
    private BucketCollection`1<TValue> _buckets;
    private DateTime _cacheResetTime;
    private bool _cleanupScheduled;
    private Bucket`1<TValue> _currentBucket;
    private int _currentBucketIndex;
    private DateTime _nextValidityCheck;
    private int _oldestBucketIndex;
    [CompilerGeneratedAttribute]
private CacheStatistics <Statistics>k__BackingField;
    private int OldestBucketIndex { get; private set; }
    private int CurrentBucketIndex { get; private set; }
    private bool AreLowOnBuckets { get; }
    private bool IsCurrentBucketOldest { get; }
    public CacheStatistics Statistics { get; }
    public NodeTracker`1(CacheSettings settings);
    private int get_OldestBucketIndex();
    private void set_OldestBucketIndex(int value);
    private int get_CurrentBucketIndex();
    private void set_CurrentBucketIndex(int value);
    private bool get_AreLowOnBuckets();
    private bool get_IsCurrentBucketOldest();
    [CompilerGeneratedAttribute]
public sealed virtual CacheStatistics get_Statistics();
    public sealed virtual void Add(INodeValueFactory`1<TValue> nodeValueFactory);
    public sealed virtual void Add(TValue value);
    public sealed virtual void Remove(INode`1<TValue> node);
    [IteratorStateMachineAttribute("MassTransit.Caching.Internals.NodeTracker`1/<GetAll>d__33")]
public sealed virtual IEnumerable`1<INode`1<TValue>> GetAll();
    public sealed virtual void Clear();
    public sealed virtual void Rebucket(IBucketNode`1<TValue> node);
    public sealed virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
    private bool IsCleanupRequired(DateTime now);
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.NodeTracker`1/<AddNode>d__38")]
private Task AddNode(INodeValueFactory`1<TValue> nodeValueFactory);
    private void AddValue(TValue value);
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.NodeTracker`1/<RemoveNode>d__40")]
private Task RemoveNode(INode`1<TValue> node);
    private void OpenBucket(int index);
    private void CheckCacheStatus();
    private void Cleanup(DateTime now);
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.NodeTracker`1/<EvictNode>d__44")]
private Task EvictNode(IBucketNode`1<TValue> node);
}
public class MassTransit.Caching.Internals.NodeValueFactory`1 : object {
    private BlockingCollection`1<IPendingValue`1<TValue>> _pendingCollection;
    private int _timeout;
    private TaskCompletionSource`1<TValue> _value;
    public Task`1<TValue> Value { get; }
    public NodeValueFactory`1(IPendingValue`1<TValue> initialPendingValue, int timeoutInMilliseconds);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual void Add(IPendingValue`1<TValue> pendingValue);
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.NodeValueFactory`1/<CreateValue>d__7")]
public sealed virtual Task`1<TValue> CreateValue();
    private void CompletePendingValues();
}
public class MassTransit.Caching.Internals.PendingValue`2 : object {
    private MissingValueFactory`2<TKey, TValue> _factory;
    private TKey _key;
    private TaskCompletionSource`1<TValue> _source;
    public Task`1<TValue> Value { get; }
    public PendingValue`2(TKey key, MissingValueFactory`2<TKey, TValue> factory);
    public Task`1<TValue> get_Value();
    [AsyncStateMachineAttribute("MassTransit.Caching.Internals.PendingValue`2/<CreateValue>d__6")]
public sealed virtual Task`1<TValue> CreateValue();
    public sealed virtual void SetValue(Task`1<TValue> value);
    private static Task`1<TValue> DefaultMissingValueFactory(TKey key);
}
public interface MassTransit.Caching.IPendingValue`1 {
    public abstract virtual void SetValue(Task`1<TValue> value);
    public abstract virtual Task`1<TValue> CreateValue();
}
public class MassTransit.Caching.KeyProvider`2 : MulticastDelegate {
    public KeyProvider`2(object object, IntPtr method);
    public virtual TKey Invoke(TValue value);
    public virtual IAsyncResult BeginInvoke(TValue value, AsyncCallback callback, object object);
    public virtual TKey EndInvoke(IAsyncResult result);
}
public class MassTransit.Caching.MissingValueFactory`2 : MulticastDelegate {
    public MissingValueFactory`2(object object, IntPtr method);
    public virtual Task`1<TValue> Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual Task`1<TValue> EndInvoke(IAsyncResult result);
}
public class MassTransit.Caching.TestCacheSettings : CacheSettings {
    private TestTimeProvider _provider;
    public DateTime CurrentTime { get; public set; }
    public TestCacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge);
    private TestCacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge, TestTimeProvider provider);
    public DateTime get_CurrentTime();
    public void set_CurrentTime(DateTime value);
}
[ExtensionAttribute]
public static class MassTransit.CircuitBreakerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseCircuitBreaker(IPipeConfigurator`1<T> configurator, Action`1<ICircuitBreakerConfigurator`1<T>> configure);
}
[ExtensionAttribute]
public static class MassTransit.ClientFactoryExtensions : object {
    [ExtensionAttribute]
public static IRequestClient`1<TRequest> CreateRequestClient(IBus bus, Uri destinationAddress, RequestTimeout timeout);
    [ExtensionAttribute]
public static IRequestClient`1<TRequest> CreateRequestClient(IBus bus, RequestTimeout timeout);
    [ExtensionAttribute]
public static IRequestClient`1<TRequest> CreateRequestClient(ConsumeContext consumeContext, IBus bus, Uri destinationAddress, RequestTimeout timeout);
    [ExtensionAttribute]
public static IRequestClient`1<TRequest> CreateRequestClient(ConsumeContext consumeContext, IBus bus, RequestTimeout timeout);
    [ExtensionAttribute]
public static IClientFactory CreateClientFactory(IBus bus, RequestTimeout timeout);
    [ExtensionAttribute]
public static IClientFactory CreateClientFactory(ReceiveEndpointReady receiveEndpoint, RequestTimeout timeout);
    [AsyncStateMachineAttribute("MassTransit.ClientFactoryExtensions/<CreateClientFactory>d__6")]
[ExtensionAttribute]
public static Task`1<IClientFactory> CreateClientFactory(HostReceiveEndpointHandle receiveEndpointHandle, RequestTimeout timeout);
    [ExtensionAttribute]
public static Task`1<IClientFactory> CreateClientFactory(IReceiveConnector connector, RequestTimeout timeout);
    [ExtensionAttribute]
public static Task`1<IClientFactory> ConnectClientFactory(IReceiveConnector connector, RequestTimeout timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Clients.BusClientFactoryContext : object {
    private IBus _bus;
    [CompilerGeneratedAttribute]
private RequestTimeout <DefaultTimeout>k__BackingField;
    public Uri ResponseAddress { get; }
    public RequestTimeout DefaultTimeout { get; }
    public BusClientFactoryContext(IBus bus, RequestTimeout defaultTimeout);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(ConsumeContext consumeContext);
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(Uri destinationAddress, ConsumeContext consumeContext);
    [CompilerGeneratedAttribute]
public sealed virtual RequestTimeout get_DefaultTimeout();
}
public class MassTransit.Clients.ClientFactory : object {
    [CompilerGeneratedAttribute]
private ClientFactoryContext <Context>k__BackingField;
    public ClientFactoryContext Context { get; }
    public ClientFactory(ClientFactoryContext context);
    public sealed virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
public sealed virtual ClientFactoryContext get_Context();
    public sealed virtual RequestHandle`1<T> CreateRequest(T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, Uri destinationAddress, RequestTimeout timeout);
}
public class MassTransit.Clients.ClientRequestHandle`1 : object {
    private List`1<string> _accept;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private ClientFactoryContext _context;
    private TaskCompletionSource`1<TRequest> _message;
    private IBuildPipeConfigurator`1<SendContext`1<TRequest>> _pipeConfigurator;
    private TaskCompletionSource`1<bool> _readyToSend;
    private Dictionary`2<Type, HandlerConnectHandle> _responseHandlers;
    private Task _send;
    private TaskCompletionSource`1<SendContext`1<TRequest>> _sendContext;
    private SendRequestCallback<TRequest> _sendRequestCallback;
    private TaskScheduler _taskScheduler;
    private int _faultedOrCanceled;
    private CancellationTokenRegistration _registration;
    private Timer _timeoutTimer;
    private RequestTimeout _timeToLive;
    [CompilerGeneratedAttribute]
private Guid <RequestId>k__BackingField;
    public Guid RequestId { get; }
    unknown RequestTimeout TimeToLive {public set; }
    private Task`1<TRequest> MassTransit.RequestHandle<TRequest>.Message { get; }
    public ClientRequestHandle`1(ClientFactoryContext context, SendRequestCallback<TRequest> sendRequestCallback, CancellationToken cancellationToken, RequestTimeout timeout, Nullable`1<Guid> requestId, TaskScheduler taskScheduler);
    [AsyncStateMachineAttribute("MassTransit.Clients.ClientRequestHandle`1/<MassTransit-IPipe<MassTransit-SendContext<TRequest>>-Send>d__18")]
private sealed virtual override Task MassTransit.IPipe<MassTransit.SendContext<TRequest>>.Send(SendContext`1<TRequest> context);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_RequestId();
    public sealed virtual void set_TimeToLive(RequestTimeout value);
    public sealed virtual void Cancel();
    private sealed virtual override void MassTransit.IPipeConfigurator<MassTransit.SendContext<TRequest>>.AddPipeSpecification(IPipeSpecification`1<SendContext`1<TRequest>> specification);
    private sealed virtual override Task`1<Response`1<T>> MassTransit.RequestHandle.GetResponse(bool readyToSend);
    public sealed virtual void Dispose();
    private sealed virtual override Task`1<TRequest> MassTransit.RequestHandle<TRequest>.get_Message();
    private void AcceptResponse();
    [AsyncStateMachineAttribute("MassTransit.Clients.ClientRequestHandle`1/<SendRequest>d__32")]
private Task SendRequest();
    private Task`1<Response`1<T>> Response(MessageHandler`1<T> handler, Action`1<IHandlerConfigurator`1<T>> configure);
    private void HandleFault();
    private Task FaultHandler(ConsumeContext`1<Fault`1<TRequest>> context);
    private void Fail(Fault message);
    private void Fail(Exception exception);
    private void CancelAndDispose();
    private void TimeoutExpired(object state);
    private void DisposeTimer();
    [CompilerGeneratedAttribute]
private Task <HandleFault>g__MessageHandler|34_0(ConsumeContext`1<Fault`1<TRequest>> context);
}
public class MassTransit.Clients.FaultHandlerConnectHandle : object {
    private ConnectHandle _handle;
    public FaultHandlerConnectHandle(ConnectHandle handle);
    public sealed virtual void Dispose();
    public sealed virtual void Disconnect();
    public sealed virtual void TrySetException(Exception exception);
    public sealed virtual void TrySetCanceled(CancellationToken cancellationToken);
}
public interface MassTransit.Clients.HandlerConnectHandle {
    public abstract virtual void TrySetException(Exception exception);
    public abstract virtual void TrySetCanceled(CancellationToken cancellationToken);
}
public interface MassTransit.Clients.HandlerConnectHandle`1 {
    public Task`1<Response`1<T>> Task { get; }
    public abstract virtual Task`1<Response`1<T>> get_Task();
}
public class MassTransit.Clients.HostReceiveEndpointClientFactoryContext : ReceiveEndpointClientFactoryContext {
    private HostReceiveEndpointHandle _receiveEndpointHandle;
    public HostReceiveEndpointClientFactoryContext(HostReceiveEndpointHandle receiveEndpointHandle, ReceiveEndpointReady receiveEndpointReady, RequestTimeout defaultTimeout);
    [AsyncStateMachineAttribute("MassTransit.Clients.HostReceiveEndpointClientFactoryContext/<DisposeAsync>d__2")]
public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.Clients.MessageResponse`1 : object {
    private MessageContext _context;
    [CompilerGeneratedAttribute]
private TResult <Message>k__BackingField;
    private Nullable`1<Guid> MassTransit.MessageContext.MessageId { get; }
    private Nullable`1<Guid> MassTransit.MessageContext.RequestId { get; }
    private Nullable`1<Guid> MassTransit.MessageContext.CorrelationId { get; }
    private Nullable`1<Guid> MassTransit.MessageContext.ConversationId { get; }
    private Nullable`1<Guid> MassTransit.MessageContext.InitiatorId { get; }
    private Nullable`1<DateTime> MassTransit.MessageContext.ExpirationTime { get; }
    private Uri MassTransit.MessageContext.SourceAddress { get; }
    private Uri MassTransit.MessageContext.DestinationAddress { get; }
    private Uri MassTransit.MessageContext.ResponseAddress { get; }
    private Uri MassTransit.MessageContext.FaultAddress { get; }
    private Nullable`1<DateTime> MassTransit.MessageContext.SentTime { get; }
    private Headers MassTransit.MessageContext.Headers { get; }
    private HostInfo MassTransit.MessageContext.Host { get; }
    public TResult Message { get; }
    private object MassTransit.Response.Message { get; }
    public MessageResponse`1(ConsumeContext`1<TResult> context);
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_MessageId();
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_RequestId();
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_CorrelationId();
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_ConversationId();
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_InitiatorId();
    private sealed virtual override Nullable`1<DateTime> MassTransit.MessageContext.get_ExpirationTime();
    private sealed virtual override Uri MassTransit.MessageContext.get_SourceAddress();
    private sealed virtual override Uri MassTransit.MessageContext.get_DestinationAddress();
    private sealed virtual override Uri MassTransit.MessageContext.get_ResponseAddress();
    private sealed virtual override Uri MassTransit.MessageContext.get_FaultAddress();
    private sealed virtual override Nullable`1<DateTime> MassTransit.MessageContext.get_SentTime();
    private sealed virtual override Headers MassTransit.MessageContext.get_Headers();
    private sealed virtual override HostInfo MassTransit.MessageContext.get_Host();
    [CompilerGeneratedAttribute]
public sealed virtual TResult get_Message();
    private sealed virtual override object MassTransit.Response.get_Message();
}
public class MassTransit.Clients.PublishRequestSendEndpoint`1 : RequestSendEndpoint`1<TRequest> {
    private IPublishEndpointProvider _provider;
    public PublishRequestSendEndpoint`1(IPublishEndpointProvider provider, ConsumeContext consumeContext);
    [AsyncStateMachineAttribute("MassTransit.Clients.PublishRequestSendEndpoint`1/<GetSendEndpoint>d__2")]
protected virtual Task`1<ISendEndpoint> GetSendEndpoint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Clients.ReceiveEndpointClientFactoryContext : object {
    private IReceiveEndpoint _receiveEndpoint;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestTimeout <DefaultTimeout>k__BackingField;
    public Uri ResponseAddress { get; }
    public RequestTimeout DefaultTimeout { get; }
    public ReceiveEndpointClientFactoryContext(ReceiveEndpointReady receiveEndpointReady, RequestTimeout defaultTimeout);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ResponseAddress();
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(ConsumeContext consumeContext);
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(Uri destinationAddress, ConsumeContext consumeContext);
    [CompilerGeneratedAttribute]
public sealed virtual RequestTimeout get_DefaultTimeout();
}
public class MassTransit.Clients.RequestClient`1 : object {
    private ClientFactoryContext _context;
    private IRequestSendEndpoint`1<TRequest> _requestSendEndpoint;
    private RequestTimeout _timeout;
    public RequestClient`1(ClientFactoryContext context, IRequestSendEndpoint`1<TRequest> requestSendEndpoint, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<TRequest> Create(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<TRequest> Create(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    [AsyncStateMachineAttribute("MassTransit.Clients.RequestClient`1/<GetResponseInternal>d__18`1")]
private Task`1<Response`1<T>> GetResponseInternal(SendRequestCallback<TRequest> request, CancellationToken cancellationToken, RequestTimeout timeout, RequestPipeConfiguratorCallback`1<TRequest> callback);
    [AsyncStateMachineAttribute("MassTransit.Clients.RequestClient`1/<GetResponseInternal>d__19`2")]
private Task`1<Response`2<T1, T2>> GetResponseInternal(SendRequestCallback<TRequest> request, CancellationToken cancellationToken, RequestTimeout timeout, RequestPipeConfiguratorCallback`1<TRequest> callback);
    [AsyncStateMachineAttribute("MassTransit.Clients.RequestClient`1/<GetResponseInternal>d__20`3")]
private Task`1<Response`3<T1, T2, T3>> GetResponseInternal(SendRequestCallback<TRequest> request, CancellationToken cancellationToken, RequestTimeout timeout, RequestPipeConfiguratorCallback`1<TRequest> callback);
}
public abstract class MassTransit.Clients.RequestSendEndpoint`1 : object {
    private ConsumeContext _consumeContext;
    protected RequestSendEndpoint`1(ConsumeContext consumeContext);
    [AsyncStateMachineAttribute("MassTransit.Clients.RequestSendEndpoint`1/<Send>d__2")]
public sealed virtual Task`1<TRequest> Send(Guid requestId, object values, IPipe`1<SendContext`1<TRequest>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Clients.RequestSendEndpoint`1/<Send>d__3")]
public sealed virtual Task Send(Guid requestId, TRequest message, IPipe`1<SendContext`1<TRequest>> pipe, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ISendEndpoint> GetSendEndpoint();
}
public class MassTransit.Clients.ResponseHandlerConfigurator`1 : object {
    private TaskCompletionSource`1<ConsumeContext`1<TResponse>> _completed;
    private MessageHandler`1<TResponse> _handler;
    private IBuildPipeConfigurator`1<ConsumeContext`1<TResponse>> _pipeConfigurator;
    private Task _requestTask;
    private TaskScheduler _taskScheduler;
    public ResponseHandlerConfigurator`1(TaskScheduler taskScheduler, MessageHandler`1<TResponse> handler, Task requestTask);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TResponse>> specification);
    public sealed virtual ConnectHandle ConnectHandlerConfigurationObserver(IHandlerConfigurationObserver observer);
    public HandlerConnectHandle`1<TResponse> Connect(IRequestPipeConnector connector, Guid requestId);
    [AsyncStateMachineAttribute("MassTransit.Clients.ResponseHandlerConfigurator`1/<AsyncMessageHandler>d__9")]
private Task AsyncMessageHandler(ConsumeContext`1<TResponse> context);
    private Task MessageHandler(ConsumeContext`1<TResponse> context);
}
public class MassTransit.Clients.ResponseHandlerConnectHandle`1 : object {
    private TaskCompletionSource`1<ConsumeContext`1<TResponse>> _completed;
    private ConnectHandle _handle;
    private Task _requestTask;
    [CompilerGeneratedAttribute]
private Task`1<Response`1<TResponse>> <Task>k__BackingField;
    public Task`1<Response`1<TResponse>> Task { get; }
    public ResponseHandlerConnectHandle`1(ConnectHandle handle, TaskCompletionSource`1<ConsumeContext`1<TResponse>> completed, Task requestTask);
    public sealed virtual void Dispose();
    public sealed virtual void Disconnect();
    public sealed virtual void TrySetException(Exception exception);
    public sealed virtual void TrySetCanceled(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Response`1<TResponse>> get_Task();
    [AsyncStateMachineAttribute("MassTransit.Clients.ResponseHandlerConnectHandle`1/<GetTask>d__11")]
private Task`1<Response`1<TResponse>> GetTask();
}
public class MassTransit.Clients.ScopedClientFactory : object {
    private IClientFactory _clientFactory;
    private ConsumeContext _consumeContext;
    public ScopedClientFactory(IClientFactory clientFactory, ConsumeContext consumeContext);
    public sealed virtual RequestHandle`1<T> CreateRequest(T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(Uri destinationAddress, RequestTimeout timeout);
}
public class MassTransit.Clients.SendRequestSendEndpoint`1 : RequestSendEndpoint`1<TRequest> {
    private Uri _destinationAddress;
    private ISendEndpointProvider _provider;
    public SendRequestSendEndpoint`1(ISendEndpointProvider provider, Uri destinationAddress, ConsumeContext consumeContext);
    [AsyncStateMachineAttribute("MassTransit.Clients.SendRequestSendEndpoint`1/<GetSendEndpoint>d__3")]
protected virtual Task`1<ISendEndpoint> GetSendEndpoint();
}
public class MassTransit.Components.RequestState : object {
    [CompilerGeneratedAttribute]
private int <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <FaultAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SagaCorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SagaAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    public int CurrentState { get; public set; }
    public Nullable`1<Guid> ConversationId { get; public set; }
    public Uri ResponseAddress { get; public set; }
    public Uri FaultAddress { get; public set; }
    public Nullable`1<DateTime> ExpirationTime { get; public set; }
    public Guid SagaCorrelationId { get; public set; }
    public Uri SagaAddress { get; public set; }
    public int Version { get; public set; }
    public Guid CorrelationId { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ConversationId();
    [CompilerGeneratedAttribute]
public void set_ConversationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Uri get_ResponseAddress();
    [CompilerGeneratedAttribute]
public void set_ResponseAddress(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_FaultAddress();
    [CompilerGeneratedAttribute]
public void set_FaultAddress(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Guid get_SagaCorrelationId();
    [CompilerGeneratedAttribute]
public void set_SagaCorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public Uri get_SagaAddress();
    [CompilerGeneratedAttribute]
public void set_SagaAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Version(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(Guid value);
}
public class MassTransit.Components.RequestStateMachine : MassTransitStateMachine`1<RequestState> {
    [CompilerGeneratedAttribute]
private State <Pending>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RequestStarted> <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RequestCompleted> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RequestFaulted> <Faulted>k__BackingField;
    private static IRequestStateMachineMissingInstanceConfigurator _missingInstanceConfigurator;
    public State Pending { get; }
    public Event`1<RequestStarted> Started { get; }
    public Event`1<RequestCompleted> Completed { get; }
    public Event`1<RequestFaulted> Faulted { get; }
    [CompilerGeneratedAttribute]
public State get_Pending();
    [CompilerGeneratedAttribute]
public Event`1<RequestStarted> get_Started();
    [CompilerGeneratedAttribute]
public Event`1<RequestCompleted> get_Completed();
    [CompilerGeneratedAttribute]
public Event`1<RequestFaulted> get_Faulted();
    private static void InitializeInstance(BehaviorContext`2<RequestState, RequestStarted> context);
    public static void RedeliverOnMissingInstance(Action`1<IMissingInstanceRedeliveryConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.ConcurrencyLimitConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseConcurrencyLimit(IPipeConfigurator`1<T> configurator, int concurrencyLimit, IPipeRouter router);
    [ExtensionAttribute]
public static void UseConcurrencyLimit(IConsumePipeConfigurator configurator, int concurrentMessageLimit);
    [ExtensionAttribute]
public static void UseConcurrencyLimit(IConsumePipeConfigurator configurator, int concurrentMessageLimit, IReceiveEndpointConfigurator managementEndpointConfigurator, string id);
}
[ExtensionAttribute]
public static class MassTransit.ConcurrentMessageLimitExtensions : object {
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IConsumerConfigurator`1<TConsumer> configurator, int concurrentMessageLimit);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IConsumerConfigurator`1<TConsumer> configurator, int concurrentMessageLimit, IReceiveEndpointConfigurator managementEndpointConfigurator, string id);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(ISagaConfigurator`1<TSaga> configurator, int concurrentMessageLimit);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(ISagaConfigurator`1<TSaga> configurator, int concurrentMessageLimit, IReceiveEndpointConfigurator managementEndpointConfigurator, string id);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IHandlerConfigurator`1<TMessage> configurator, int concurrentMessageLimit);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IHandlerConfigurator`1<TMessage> configurator, int concurrentMessageLimit, IReceiveEndpointConfigurator managementEndpointConfigurator, string id);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IPipeConfigurator`1<ConsumeContext`1<TMessage>> configurator, int concurrentMessageLimit);
    [ExtensionAttribute]
public static void UseConcurrentMessageLimit(IPipeConfigurator`1<ConsumeContext`1<TMessage>> configurator, int concurrentMessageLimit, IReceiveEndpointConfigurator managementEndpointConfigurator, string id);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.ActivityPipeConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void AddPipeSpecification(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator, IPipeSpecification`1<ExecuteActivityContext`1<TArguments>> specification);
    [ExtensionAttribute]
public static void AddPipeSpecification(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator, IPipeSpecification`1<CompensateActivityContext`1<TLog>> specification);
}
public class MassTransit.Configuration.AsyncConsumerConvention : object {
    private sealed virtual override IConsumerMessageConvention MassTransit.Configuration.IConsumerConvention.GetConsumerMessageConvention();
}
public class MassTransit.Configuration.AsyncConsumerMessageConvention`1 : object {
    [IteratorStateMachineAttribute("MassTransit.Configuration.AsyncConsumerMessageConvention`1/<GetMessageTypes>d__0")]
public sealed virtual IEnumerable`1<IMessageInterfaceType> GetMessageTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Configuration.BaseHostConfiguration`2 : object {
    private ConsumeObservable _consumeObservers;
    private EndpointConfigurationObservable _endpointObservable;
    private PublishObservable _publishObservers;
    private ReceiveObservable _receiveObservers;
    private SendObservable _sendObservers;
    private IList`1<TConfiguration> _endpoints;
    [NullableAttribute("2")]
private ILogContext _logContext;
    [CompilerGeneratedAttribute]
private IBusConfiguration <BusConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeployTopologyOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeployPublishTopology>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogContext <ReceiveLogContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogContext <SendLogContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ConsumerStopTimeout>k__BackingField;
    protected IEndpointConfigurationObserver Observers { get; }
    public IBusConfiguration BusConfiguration { get; }
    public Uri HostAddress { get; }
    public bool DeployTopologyOnly { get; public set; }
    public bool DeployPublishTopology { get; public set; }
    public ISendObserver SendObservers { get; }
    [NullableAttribute("2")]
public ILogContext LogContext { get; public set; }
    [NullableAttribute("2")]
public ILogContext ReceiveLogContext { get; private set; }
    [NullableAttribute("2")]
public ILogContext SendLogContext { get; private set; }
    public IBusTopology Topology { get; }
    public IRetryPolicy ReceiveTransportRetryPolicy { get; }
    public IRetryPolicy SendTransportRetryPolicy { get; }
    public Nullable`1<TimeSpan> ConsumerStopTimeout { get; public set; }
    protected BaseHostConfiguration`2(IBusConfiguration busConfiguration);
    protected IEndpointConfigurationObserver get_Observers();
    [CompilerGeneratedAttribute]
public sealed virtual IBusConfiguration get_BusConfiguration();
    public abstract virtual Uri get_HostAddress();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeployTopologyOnly();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeployTopologyOnly(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeployPublishTopology();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeployPublishTopology(bool value);
    public sealed virtual ISendObserver get_SendObservers();
    [NullableContextAttribute("2")]
public sealed virtual ILogContext get_LogContext();
    [NullableContextAttribute("2")]
public sealed virtual void set_LogContext(ILogContext value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ILogContext get_ReceiveLogContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ReceiveLogContext(ILogContext value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ILogContext get_SendLogContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SendLogContext(ILogContext value);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveEndpointContext(ReceiveEndpointContext context);
    public virtual IEnumerable`1<ValidationResult> Validate();
    public abstract virtual IBusTopology get_Topology();
    public abstract virtual IRetryPolicy get_ReceiveTransportRetryPolicy();
    public virtual IRetryPolicy get_SendTransportRetryPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_ConsumerStopTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConsumerStopTimeout(Nullable`1<TimeSpan> value);
    public abstract virtual IReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IReceiveEndpointConfigurator> configure);
    public abstract virtual IHost Build();
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual void ReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public abstract virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<TConfigurator> configureEndpoint);
    public abstract virtual void ReceiveEndpoint(string queueName, Action`1<TConfigurator> configureEndpoint);
    protected void ApplyEndpointDefinition(IReceiveEndpointConfigurator configurator, IEndpointDefinition definition);
    protected IEnumerable`1<TConfiguration> GetConfiguredEndpoints();
    protected void Add(TConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.BatchConfigurator`1 : object {
    private IReceiveEndpointConfigurator _configurator;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchTimeLimitStart <TimeLimitStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConcurrencyLimit>k__BackingField;
    private TimeSpan TimeLimit { get; public set; }
    private BatchTimeLimitStart TimeLimitStart { get; public set; }
    private int MessageLimit { get; public set; }
    private int ConcurrencyLimit { get; public set; }
    public BatchConfigurator`1(IReceiveEndpointConfigurator configurator);
    [CompilerGeneratedAttribute]
private TimeSpan get_TimeLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeLimit(TimeSpan value);
    [CompilerGeneratedAttribute]
private BatchTimeLimitStart get_TimeLimitStart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeLimitStart(BatchTimeLimitStart value);
    [CompilerGeneratedAttribute]
private int get_MessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageLimit(int value);
    [CompilerGeneratedAttribute]
private int get_ConcurrencyLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrencyLimit(int value);
    public sealed virtual void Consumer(IConsumerFactory`1<TConsumer> consumerFactory, Action`1<IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>>> configure);
    [CompilerGeneratedAttribute]
private void <Consumer>b__18_0(BatchOptions options);
}
public class MassTransit.Configuration.BatchConsumerConvention : object {
    private sealed virtual override IConsumerMessageConvention MassTransit.Configuration.IConsumerConvention.GetConsumerMessageConvention();
}
public class MassTransit.Configuration.BatchConsumerInterfaceType : object {
    private Lazy`1<IMessageConnectorFactory> _consumeConnectorFactory;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type MessageType { get; }
    public BatchConsumerInterfaceType(Type batchMessageType, Type messageType, Type consumerType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageConnector`1<T> GetConsumerConnector();
    public sealed virtual IInstanceMessageConnector`1<T> GetInstanceConnector();
}
public class MassTransit.Configuration.BatchConsumerMessageConnector`2 : object {
    public Type MessageType { get; }
    public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageSpecification`1<TConsumer> CreateConsumerMessageSpecification();
    public sealed virtual ConnectHandle ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
}
public class MassTransit.Configuration.BatchConsumerMessageConvention`1 : object {
    [IteratorStateMachineAttribute("MassTransit.Configuration.BatchConsumerMessageConvention`1/<GetMessageTypes>d__0")]
public sealed virtual IEnumerable`1<IMessageInterfaceType> GetMessageTypes();
}
public class MassTransit.Configuration.BatchConsumerMessageSpecification`2 : object {
    private IBuildPipeConfigurator`1<ConsumerConsumeContext`2<TConsumer, Batch`1<TMessage>>> _batchConfigurator;
    private IBuildPipeConfigurator`1<ConsumeContext`1<Batch`1<TMessage>>> _batchMessagePipeConfigurator;
    private ConsumerMessageSpecification`2<TConsumer, TMessage> _consumerSpecification;
    private ConsumerConfigurationObservable _observers;
    public Type MessageType { get; }
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`2<TConsumer, TMessage>> specification);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<TMessage>> configure);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual Type get_MessageType();
    public sealed virtual bool TryGetMessageSpecification(IConsumerMessageSpecification`2& specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`2<TConsumer, Batch`1<TMessage>>> specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<Batch`1<TMessage>>> specification);
    public sealed virtual IPipe`1<ConsumerConsumeContext`2<TConsumer, Batch`1<TMessage>>> Build(IFilter`1<ConsumerConsumeContext`2<TConsumer, Batch`1<TMessage>>> consumeFilter);
    public sealed virtual IPipe`1<ConsumeContext`1<Batch`1<TMessage>>> BuildMessagePipe(Action`1<IPipeConfigurator`1<ConsumeContext`1<Batch`1<TMessage>>>> configure);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<Batch`1<TMessage>>> configure);
}
public class MassTransit.Configuration.BatchMessageConnectorFactory`2 : object {
    private BatchConsumerMessageConnector`2<TConsumer, TMessage> _consumerConnector;
    public sealed virtual IConsumerMessageConnector`1<T> CreateConsumerConnector();
    public sealed virtual IInstanceMessageConnector`1<T> CreateInstanceConnector();
}
public class MassTransit.Configuration.BehaviorContextRetryConfigurator : ExceptionSpecification {
    private RetryObservable _observers;
    [CompilerGeneratedAttribute]
private RetryPolicyFactory <PolicyFactory>k__BackingField;
    public RetryPolicyFactory PolicyFactory { get; private set; }
    [CompilerGeneratedAttribute]
public RetryPolicyFactory get_PolicyFactory();
    [CompilerGeneratedAttribute]
private void set_PolicyFactory(RetryPolicyFactory value);
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    public sealed virtual ConnectHandle ConnectRetryObserver(IRetryObserver observer);
    public IRetryPolicy GetRetryPolicy();
}
public class MassTransit.Configuration.BindConfigurator`1 : object {
    private IPipeConfigurator`1<TLeft> _configurator;
    public BindConfigurator`1(IPipeConfigurator`1<TLeft> configurator);
    private sealed virtual override void MassTransit.IBindConfigurator<TLeft>.Source(IPipeContextSource`2<T, TLeft> source, Action`1<IBindConfigurator`2<TLeft, T>> configureTarget);
}
public class MassTransit.Configuration.BindPipeSpecification`2 : object {
    private IPipeConfigurator`1<TLeft> _contextPipeConfigurator;
    private IBuildPipeConfigurator`1<BindContext`2<TLeft, TRight>> _pipeConfigurator;
    private IPipeContextSource`2<TRight, TLeft> _source;
    private IPipeConfigurator`1<TLeft> MassTransit.IBindConfigurator<TLeft,TRight>.ContextPipe { get; }
    public BindPipeSpecification`2(IPipeContextSource`2<TRight, TLeft> source);
    private sealed virtual override IPipeConfigurator`1<TLeft> MassTransit.IBindConfigurator<TLeft,TRight>.get_ContextPipe();
    private sealed virtual override void MassTransit.IPipeConfigurator<MassTransit.BindContext<TLeft,TRight>>.AddPipeSpecification(IPipeSpecification`1<BindContext`2<TLeft, TRight>> specification);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<TLeft>.Apply(IPipeBuilder`1<TLeft> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.BindPipeSpecification`2/<MassTransit-ISpecification-Validate>d__8")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
}
public abstract class MassTransit.Configuration.BusFactoryConfigurator : object {
    private IBusConfiguration _busConfiguration;
    public IMessageTopologyConfigurator MessageTopology { get; }
    public IConsumeTopologyConfigurator ConsumeTopology { get; }
    public ISendTopologyConfigurator SendTopology { get; }
    public IPublishTopologyConfigurator PublishTopology { get; }
    unknown bool DeployTopologyOnly {public set; }
    unknown bool DeployPublishTopology {public set; }
    unknown Nullable`1<int> ConcurrentMessageLimit {public set; }
    unknown int PrefetchCount {public set; }
    unknown ContentType DefaultContentType {public set; }
    unknown ContentType SerializerContentType {public set; }
    unknown bool AutoStart {public set; }
    protected BusFactoryConfigurator(IBusConfiguration busConfiguration);
    public sealed virtual IMessageTopologyConfigurator get_MessageTopology();
    public sealed virtual IConsumeTopologyConfigurator get_ConsumeTopology();
    public sealed virtual ISendTopologyConfigurator get_SendTopology();
    public sealed virtual IPublishTopologyConfigurator get_PublishTopology();
    public sealed virtual void set_DeployTopologyOnly(bool value);
    public sealed virtual void set_DeployPublishTopology(bool value);
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void set_PrefetchCount(int value);
    public sealed virtual void set_DefaultContentType(ContentType value);
    public sealed virtual void set_SerializerContentType(ContentType value);
    public sealed virtual ConnectHandle ConnectBusObserver(IBusObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public virtual void set_AutoStart(bool value);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    public sealed virtual void AddPrePipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<T>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectSagaConfigurationObserver(ISagaConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectHandlerConfigurationObserver(IHandlerConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectActivityConfigurationObserver(IActivityConfigurationObserver observer);
    public sealed virtual void ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    public sealed virtual void ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    public sealed virtual void SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    public sealed virtual void SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    public sealed virtual void HandlerConfigured(IHandlerConfigurator`1<TMessage> configurator);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual void ConfigurePublish(Action`1<IPublishPipeConfigurator> callback);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual void ConfigureSend(Action`1<ISendPipeConfigurator> callback);
    public sealed virtual void Message(Action`1<IMessageTopologyConfigurator`1<T>> configureTopology);
    public sealed virtual void Send(Action`1<IMessageSendTopologyConfigurator`1<T>> configureTopology);
    public sealed virtual void Publish(Action`1<IMessagePublishTopologyConfigurator`1<T>> configureTopology);
    public virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void AddSerializer(ISerializerFactory factory, bool isSerializer);
    public sealed virtual void AddDeserializer(ISerializerFactory factory, bool isDefault);
    public sealed virtual void ClearSerialization();
}
internal class MassTransit.Configuration.BusFactorySelector : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.BusRegistrationContext : RegistrationContext {
    [NullableAttribute("2")]
private IConfigureReceiveEndpoint _configureReceiveEndpoints;
    public IEndpointNameFormatter EndpointNameFormatter { get; }
    public BusRegistrationContext(IServiceProvider provider, IContainerSelector selector, ISetScopedConsumeContext setScopedConsumeContext);
    public sealed virtual IEndpointNameFormatter get_EndpointNameFormatter();
    public sealed virtual void ConfigureEndpoints(IReceiveConfigurator`1<T> configurator, IEndpointNameFormatter endpointNameFormatter);
    public sealed virtual void ConfigureEndpoints(IReceiveConfigurator`1<T> configurator, IEndpointNameFormatter endpointNameFormatter, Action`1<IRegistrationFilterConfigurator> configureFilter);
    public sealed virtual IConfigureReceiveEndpoint GetConfigureReceiveEndpoints();
    private void ConfigureTheEndpoints(IEnumerable`1<Endpoint> endpoints, IEndpointNameFormatter endpointNameFormatter, Func`2<string, IEndpointDefinition> getEndpointDefinitionByName, IReceiveConfigurator`1<T> configurator, IReceiveConfigurator`1<T> instanceConfigurator);
    private static void NoFilter(IRegistrationFilterConfigurator configurator);
}
public class MassTransit.Configuration.CircuitBreakerPipeSpecification`1 : ExceptionSpecification {
    private Settings<T> _settings;
    unknown TimeSpan TrackingPeriod {public set; }
    unknown int TripThreshold {public set; }
    unknown int ActiveThreshold {public set; }
    unknown TimeSpan ResetInterval {public set; }
    unknown IPipeRouter Router {public set; }
    public sealed virtual void set_TrackingPeriod(TimeSpan value);
    public sealed virtual void set_TripThreshold(int value);
    public sealed virtual void set_ActiveThreshold(int value);
    public sealed virtual void set_ResetInterval(TimeSpan value);
    public sealed virtual void set_Router(IPipeRouter value);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.CircuitBreakerPipeSpecification`1/<Validate>d__13")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [IteratorStateMachineAttribute("MassTransit.Configuration.CircuitBreakerPipeSpecification`1/<IntervalTimeout>d__14")]
private IEnumerable`1<TimeSpan> IntervalTimeout(TimeSpan interval);
}
public class MassTransit.Configuration.CombinedEndpointDefinition : object {
    private IReadOnlyList`1<IEndpointDefinition> _definitions;
    [CompilerGeneratedAttribute]
private bool <ConfigureConsumeTopology>k__BackingField;
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public bool ConfigureConsumeTopology { get; }
    internal CombinedEndpointDefinition(IReadOnlyList`1<IEndpointDefinition> definitions);
    public sealed virtual bool get_IsTemporary();
    public sealed virtual Nullable`1<int> get_PrefetchCount();
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConfigureConsumeTopology();
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
    public sealed virtual void Configure(T configurator);
}
public class MassTransit.Configuration.CompensateActivityHostConfigurator`2 : object {
    private ICompensateActivityFactory`2<TActivity, TLog> _activityFactory;
    private IBuildPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> _activityPipeConfigurator;
    private IBuildPipeConfigurator`1<CompensateContext`1<TLog>> _compensatePipeConfigurator;
    private ActivityConfigurationObservable _configurationObservers;
    private ActivityObservable _observers;
    private RoutingSlipConfigurator _routingSlipConfigurator;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public CompensateActivityHostConfigurator`2(ICompensateActivityFactory`2<TActivity, TLog> activityFactory, IActivityConfigurationObserver observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<CompensateActivityContext`2<TActivity, TLog>> specification);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void Log(Action`1<ICompensateLogConfigurator`1<TLog>> configure);
    public sealed virtual void ActivityLog(Action`1<ICompensateActivityLogConfigurator`1<TLog>> configure);
    public sealed virtual void RoutingSlip(Action`1<IRoutingSlipConfigurator> configure);
    public sealed virtual ConnectHandle ConnectActivityObserver(IActivityObserver observer);
    [IteratorStateMachineAttribute("MassTransit.Configuration.CompensateActivityHostConfigurator`2/<Validate>d__16")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Validate>b__16_0(IActivityConfigurationObserver observer);
}
public class MassTransit.Configuration.CompensateActivityLogConfigurator`2 : object {
    private IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> _configurator;
    public CompensateActivityLogConfigurator`2(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<CompensateActivityContext`1<TLog>> specification);
}
public class MassTransit.Configuration.CompensateContextRedeliveryPipeSpecification`1 : ExceptionSpecification {
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    [CompilerGeneratedAttribute]
private bool <ReplaceMessageId>k__BackingField;
    public bool ReplaceMessageId { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<CompensateContext`1<TLog>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.CompensateContextRedeliveryPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
    [CompilerGeneratedAttribute]
public bool get_ReplaceMessageId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReplaceMessageId(bool value);
    private static RetryCompensateContext`1<TLog> Factory(CompensateContext`1<TLog> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.CompensateContextRetryPipeSpecification`1 : ExceptionSpecification {
    private CancellationToken _cancellationToken;
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public CompensateContextRetryPipeSpecification`1(CancellationToken cancellationToken);
    public sealed virtual void Apply(IPipeBuilder`1<CompensateContext`1<TLog>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.CompensateContextRetryPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
    private static RetryCompensateContext`1<TLog> Factory(CompensateContext`1<TLog> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.CompensateContextTimeoutSpecification`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public TimeSpan Timeout { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<CompensateContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.CompensateContextTimeoutSpecification`1/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timeout(TimeSpan value);
    private static TimeoutCompensateContext`1<TArguments> Factory(CompensateContext`1<TArguments> context, CancellationToken cancellationToken);
}
public class MassTransit.Configuration.CompensateLogConfigurator`1 : object {
    private IPipeConfigurator`1<CompensateContext`1<TLog>> _configurator;
    public CompensateLogConfigurator`1(IPipeConfigurator`1<CompensateContext`1<TLog>> configurator);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<CompensateContext`1<TLog>> specification);
}
public class MassTransit.Configuration.CompositeFilter`1 : object {
    private CompositePredicate`1<T> _excludes;
    private CompositePredicate`1<T> _includes;
    public CompositePredicate`1<T> Includes { get; public set; }
    public CompositePredicate`1<T> Excludes { get; public set; }
    public CompositePredicate`1<T> get_Includes();
    public void set_Includes(CompositePredicate`1<T> value);
    public CompositePredicate`1<T> get_Excludes();
    public void set_Excludes(CompositePredicate`1<T> value);
    public bool Matches(T target);
}
public class MassTransit.Configuration.CompositePredicate`1 : object {
    private List`1<Func`2<T, bool>> _list;
    private Func`2<T, bool> _matchesAll;
    private Func`2<T, bool> _matchesAny;
    private Func`2<T, bool> _matchesNone;
    public void Add(Func`2<T, bool> filter);
    public static CompositePredicate`1<T> op_Addition(CompositePredicate`1<T> invokes, Func`2<T, bool> filter);
    public bool MatchesAll(T target);
    public bool MatchesAny(T target);
    public bool MatchesNone(T target);
    public bool DoesNotMatcheAny(T target);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_0(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_1(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_2(T x);
}
public class MassTransit.Configuration.ConcurrencyLimitConfigurationObserver : ConfigurationObserver {
    [CompilerGeneratedAttribute]
private IConcurrencyLimiter <Limiter>k__BackingField;
    public IConcurrencyLimiter Limiter { get; }
    public ConcurrencyLimitConfigurationObserver(IConsumePipeConfigurator configurator, int concurrentMessageLimit, string id);
    [CompilerGeneratedAttribute]
public IConcurrencyLimiter get_Limiter();
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.ConcurrencyLimitConsumePipeSpecification`1 : object {
    private IConcurrencyLimiter _limiter;
    public ConcurrencyLimitConsumePipeSpecification`1(IConcurrencyLimiter limiter);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConcurrencyLimitConsumePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConcurrencyLimitConsumerConfigurationObserver`1 : object {
    private IConsumerConfigurator`1<TConsumer> _configurator;
    [CompilerGeneratedAttribute]
private IConcurrencyLimiter <Limiter>k__BackingField;
    public IConcurrencyLimiter Limiter { get; }
    public ConcurrencyLimitConsumerConfigurationObserver`1(IConsumerConfigurator`1<TConsumer> configurator, int concurrentMessageLimit, string id);
    [CompilerGeneratedAttribute]
public IConcurrencyLimiter get_Limiter();
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.ConcurrencyLimitHandlerConfigurationObserver : object {
    [CompilerGeneratedAttribute]
private IConcurrencyLimiter <Limiter>k__BackingField;
    public IConcurrencyLimiter Limiter { get; }
    public ConcurrencyLimitHandlerConfigurationObserver(int concurrentMessageLimit, string id);
    [CompilerGeneratedAttribute]
public IConcurrencyLimiter get_Limiter();
    public sealed virtual void HandlerConfigured(IHandlerConfigurator`1<T> configurator);
}
public class MassTransit.Configuration.ConcurrencyLimitPipeSpecification`1 : object {
    private int _concurrencyLimit;
    private IPipeRouter _router;
    public ConcurrencyLimitPipeSpecification`1(int concurrencyLimit, IPipeRouter router);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConcurrencyLimitPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConcurrencyLimitSagaConfigurationObserver`1 : object {
    private ISagaConfigurator`1<TSaga> _configurator;
    [CompilerGeneratedAttribute]
private IConcurrencyLimiter <Limiter>k__BackingField;
    public IConcurrencyLimiter Limiter { get; }
    public ConcurrencyLimitSagaConfigurationObserver`1(ISagaConfigurator`1<TSaga> configurator, int concurrentMessageLimit, string id);
    [CompilerGeneratedAttribute]
public IConcurrencyLimiter get_Limiter();
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.ConfigurationObserver : Connectable`1<IMessageConfigurationObserver> {
    private IConsumePipeConfigurator _configurator;
    private HashSet`1<Type> _messageTypes;
    protected ConfigurationObserver(IConsumePipeConfigurator configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<TMessage> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    private void NotifyObserver();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <NotifyObserver>b__13_0(IMessageConfigurationObserver observer);
}
public class MassTransit.Configuration.ConfiguratorPipeConnectorSpecification`1 : object {
    private IBuildPipeConfigurator`1<TContext> _configurator;
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<TContext> specification);
    public sealed virtual void Connect(IPipeConnector connector);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConfigureReceiveEndpointDelegate : object {
    private ConfigureEndpointsCallback _callback;
    public ConfigureReceiveEndpointDelegate(ConfigureEndpointsCallback callback);
    public sealed virtual void Configure(string name, IReceiveEndpointConfigurator configurator);
}
public class MassTransit.Configuration.ConfigureReceiveEndpointDelegateProvider : object {
    private ConfigureEndpointsProviderCallback _callback;
    private IRegistrationContext _context;
    public ConfigureReceiveEndpointDelegateProvider(IRegistrationContext context, ConfigureEndpointsProviderCallback callback);
    public sealed virtual void Configure(string name, IReceiveEndpointConfigurator configurator);
}
public class MassTransit.Configuration.ConnectReceiveEndpointObserverBusObserver`1 : object {
    private IServiceProvider _provider;
    public ConnectReceiveEndpointObserverBusObserver`1(IServiceProvider provider);
    public sealed virtual void PostCreate(IBus bus);
    public sealed virtual void CreateFaulted(Exception exception);
    public sealed virtual Task PreStart(IBus bus);
    public sealed virtual Task PostStart(IBus bus, Task`1<BusReady> busReady);
    public sealed virtual Task StartFaulted(IBus bus, Exception exception);
    public sealed virtual Task PreStop(IBus bus);
    public sealed virtual Task PostStop(IBus bus);
    public sealed virtual Task StopFaulted(IBus bus, Exception exception);
}
public class MassTransit.Configuration.ConstructorSagaInstanceFactory`1 : object {
    [CompilerGeneratedAttribute]
private SagaInstanceFactoryMethod`1<TSaga> <FactoryMethod>k__BackingField;
    public SagaInstanceFactoryMethod`1<TSaga> FactoryMethod { get; }
    [CompilerGeneratedAttribute]
public SagaInstanceFactoryMethod`1<TSaga> get_FactoryMethod();
}
public class MassTransit.Configuration.ConsumeContextRescuePipeSpecification : ExceptionSpecification {
    private IPipe`1<ExceptionConsumeContext> _rescuePipe;
    public ConsumeContextRescuePipeSpecification(IPipe`1<ExceptionConsumeContext> rescuePipe);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumeContextRescuePipeSpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConsumeContextRescuePipeSpecification`1 : ExceptionSpecification {
    private IPipe`1<ExceptionConsumeContext`1<T>> _rescuePipe;
    public ConsumeContextRescuePipeSpecification`1(IPipe`1<ExceptionConsumeContext`1<T>> rescuePipe);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumeContextRescuePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConsumeContextRetryPipeSpecification : ExceptionSpecification {
    private CancellationToken _cancellationToken;
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public ConsumeContextRetryPipeSpecification(CancellationToken cancellationToken);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumeContextRetryPipeSpecification/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
}
public class MassTransit.Configuration.ConsumeContextRetryPipeSpecification`2 : ExceptionSpecification {
    private CancellationToken _cancellationToken;
    private Func`4<TFilter, IRetryPolicy, RetryContext, TContext> _contextFactory;
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public ConsumeContextRetryPipeSpecification`2(Func`4<TFilter, IRetryPolicy, RetryContext, TContext> contextFactory, CancellationToken cancellationToken);
    public sealed virtual void Apply(IPipeBuilder`1<TFilter> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumeContextRetryPipeSpecification`2/<Validate>d__6")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
}
public class MassTransit.Configuration.ConsumeMessageConnectorFactory`2 : object {
    private ConsumerMessageConnector`2<TConsumer, TMessage> _consumerConnector;
    private InstanceMessageConnector`2<TConsumer, TMessage> _instanceConnector;
    public sealed virtual IConsumerMessageConnector`1<T> CreateConsumerConnector();
    private sealed virtual override IInstanceMessageConnector`1<T> MassTransit.Configuration.IMessageConnectorFactory.CreateInstanceConnector();
}
public class MassTransit.Configuration.ConsumeMessageFilterConfigurator : object {
    [CompilerGeneratedAttribute]
private CompositeFilter`1<ConsumeContext> <Filter>k__BackingField;
    public CompositeFilter`1<ConsumeContext> Filter { get; }
    [CompilerGeneratedAttribute]
public CompositeFilter`1<ConsumeContext> get_Filter();
    public sealed virtual void Include(Type[] messageTypes);
    public sealed virtual void Include(Func`2<Type, bool> filter);
    public sealed virtual void Include();
    public sealed virtual void Include(Func`2<T, bool> filter);
    public sealed virtual void Exclude(Type[] messageTypes);
    public sealed virtual void Exclude(Func`2<Type, bool> filter);
    public sealed virtual void Exclude();
    public sealed virtual void Exclude(Func`2<T, bool> filter);
    private static bool Match(ConsumeContext context, Type[] messageTypes);
    private static bool Match(ConsumeContext context);
    private static bool Match(ConsumeContext context, Func`2<T, bool> filter);
}
public class MassTransit.Configuration.ConsumePipeConfiguration : object {
    [CompilerGeneratedAttribute]
private IConsumePipeSpecification <Specification>k__BackingField;
    public IConsumePipeSpecification Specification { get; }
    public IConsumePipeConfigurator Configurator { get; }
    public ConsumePipeConfiguration(IConsumeTopology consumeTopology);
    public ConsumePipeConfiguration(IConsumePipeSpecification parentSpecification);
    [CompilerGeneratedAttribute]
public sealed virtual IConsumePipeSpecification get_Specification();
    public sealed virtual IConsumePipeConfigurator get_Configurator();
}
public class MassTransit.Configuration.ConsumePipeSpecification : object {
    private ActivityConfigurationObservable _activityObservers;
    private List`1<IConsumePipeConfigurator> _consumePipeConfigurators;
    private ConsumerConfigurationObservable _consumerObservers;
    private HandlerConfigurationObservable _handlerObservers;
    private object _lock;
    private IDictionary`2<Type, IMessageConsumePipeSpecification> _messageSpecifications;
    private ConsumePipeSpecificationObservable _observers;
    private List`1<IPipeSpecification`1<ConsumeContext>> _prePipeSpecifications;
    private SagaConfigurationObservable _sagaObservers;
    private List`1<IPipeSpecification`1<ConsumeContext>> _specifications;
    [CompilerGeneratedAttribute]
private bool <AutoStart>k__BackingField;
    public bool AutoStart { get; public set; }
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectSagaConfigurationObserver(ISagaConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectHandlerConfigurationObserver(IHandlerConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectActivityConfigurationObserver(IActivityConfigurationObserver observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<T>> specification);
    public sealed virtual void AddPrePipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    [CompilerGeneratedAttribute]
public bool get_AutoStart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AutoStart(bool value);
    public sealed virtual void ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    public sealed virtual void ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    public sealed virtual void SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    public sealed virtual void SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    public sealed virtual void HandlerConfigured(IHandlerConfigurator`1<TMessage> configurator);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumePipeSpecification/<Validate>d__31")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual IMessageConsumePipeSpecification`1<T> GetMessageSpecification();
    public sealed virtual ConnectHandle ConnectConsumePipeSpecificationObserver(IConsumePipeSpecificationObserver observer);
    public sealed virtual IConsumePipe BuildConsumePipe();
    public sealed virtual IConsumePipeSpecification CreateConsumePipeSpecification();
    private IMessageConsumePipeSpecification CreateMessageSpecification(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.ConsumerConfigurator`1 : object {
    private IConsumerFactory`1<TConsumer> _consumerFactory;
    private IConsumerSpecification`1<TConsumer> _specification;
    unknown Nullable`1<int> ConcurrentMessageLimit {public set; }
    public ConsumerConfigurator`1(IConsumerFactory`1<TConsumer> consumerFactory, IConsumerConfigurationObserver observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<T>> configure);
    public sealed virtual void ConsumerMessage(Action`1<IConsumerMessageConfigurator`2<TConsumer, T>> configure);
    public sealed virtual T Options(Action`1<T> configure);
    public sealed virtual T Options(T options, Action`1<T> configure);
    public sealed virtual bool TryGetOptions(T& options);
    public sealed virtual IEnumerable`1<T> SelectOptions();
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
}
public class MassTransit.Configuration.ConsumerConnector`1 : object {
    private List`1<IConsumerMessageConnector`1<T>> _connectors;
    public IEnumerable`1<IConsumerMessageConnector> Connectors { get; }
    public IEnumerable`1<IConsumerMessageConnector> get_Connectors();
    private sealed virtual override ConnectHandle MassTransit.Configuration.IConsumerConnector.ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
    private sealed virtual override IConsumerSpecification`1<TConsumer> MassTransit.Configuration.IConsumerConnector.CreateConsumerSpecification();
    private static IEnumerable`1<IConsumerMessageConnector`1<T>> Consumes();
}
public static class MassTransit.Configuration.ConsumerConnectorCache : object {
    private static CachedConnector GetOrAdd(Type type);
    public static ConnectHandle Connect(IConsumePipeConnector consumePipe, Type consumerType, Func`2<Type, object> objectFactory);
}
public class MassTransit.Configuration.ConsumerConnectorCache`1 : object {
    private Lazy`1<ConsumerConnector`1<TConsumer>> _connector;
    public static IConsumerConnector Connector { get; }
    private IConsumerConnector MassTransit.Configuration.IConsumerConnectorCache.Connector { get; }
    public static IConsumerConnector get_Connector();
    private sealed virtual override IConsumerConnector MassTransit.Configuration.IConsumerConnectorCache.get_Connector();
}
public class MassTransit.Configuration.ConsumerConsumeContextRescuePipeSpecification`1 : ExceptionSpecification {
    private IPipe`1<ExceptionConsumerConsumeContext`1<T>> _rescuePipe;
    public ConsumerConsumeContextRescuePipeSpecification`1(IPipe`1<ExceptionConsumerConsumeContext`1<T>> rescuePipe);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerConsumeContextRescuePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public static class MassTransit.Configuration.ConsumerConventionCache : object {
    private static ConsumerConventionCache();
    public static bool TryAdd(T convention);
    public static bool Remove();
    public static IEnumerable`1<IConsumerMessageConvention> GetConventions();
}
[ExtensionAttribute]
public static class MassTransit.Configuration.ConsumerFactoryConfiguratorExtensions : object {
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerFactoryConfiguratorExtensions/<ValidateConsumer>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValidationResult> ValidateConsumer(ISpecification configurator);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerFactoryConfiguratorExtensions/<Validate>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValidationResult> Validate(IConsumerFactory`1<TConsumer> consumerFactory);
    private static bool HasProtectedDefaultConstructor(Type type);
}
public class MassTransit.Configuration.ConsumerFilterSpecification`2 : object {
    private IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _filter;
    public ConsumerFilterSpecification`2(IFilter`1<ConsumerConsumeContext`1<TConsumer>> filter);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`2<TConsumer, TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerFilterSpecification`2/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConsumerInterfaceType : object {
    private Lazy`1<IMessageConnectorFactory> _consumeConnectorFactory;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type MessageType { get; }
    public ConsumerInterfaceType(Type messageType, Type consumerType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageConnector`1<T> GetConsumerConnector();
    public sealed virtual IInstanceMessageConnector`1<T> GetInstanceConnector();
}
public class MassTransit.Configuration.ConsumerMessageConnector`2 : object {
    private static ConnectPipeOptions NotConfigureConsumeTopology;
    private IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _consumeFilter;
    [CompilerGeneratedAttribute]
private bool <ConfigureConsumeTopology>k__BackingField;
    private bool ConfigureConsumeTopology { get; }
    public Type MessageType { get; }
    public ConsumerMessageConnector`2(IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> consumeFilter);
    [CompilerGeneratedAttribute]
private bool get_ConfigureConsumeTopology();
    public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageSpecification`1<TConsumer> CreateConsumerMessageSpecification();
    public sealed virtual ConnectHandle ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
}
public class MassTransit.Configuration.ConsumerMessageSpecification`2 : object {
    private IBuildPipeConfigurator`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _configurator;
    private IBuildPipeConfigurator`1<ConsumeContext`1<TMessage>> _messagePipeConfigurator;
    private ConsumerConfigurationObservable _observers;
    public Type MessageType { get; }
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual Type get_MessageType();
    public sealed virtual bool TryGetMessageSpecification(IConsumerMessageSpecification`2& specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`2<TConsumer, TMessage>> specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> Build(IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> consumeFilter);
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> BuildMessagePipe(Action`1<IPipeConfigurator`1<ConsumeContext`1<TMessage>>> configure);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<TMessage>> configure);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Validate>b__4_0(IConsumerConfigurationObserver observer);
}
public class MassTransit.Configuration.ConsumerMessageSplitFilterSpecification`2 : object {
    private IPipeSpecification`1<ConsumeContext`1<TMessage>> _specification;
    public ConsumerMessageSplitFilterSpecification`2(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`2<TConsumer, TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerMessageSplitFilterSpecification`2/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConsumerMetadataCache`1 : object {
    private IMessageInterfaceType[] _consumerTypes;
    public static IMessageInterfaceType[] ConsumerTypes { get; }
    private IMessageInterfaceType[] MassTransit.Configuration.IConsumerMetadataCache<T>.ConsumerTypes { get; }
    public static IMessageInterfaceType[] get_ConsumerTypes();
    private sealed virtual override IMessageInterfaceType[] MassTransit.Configuration.IConsumerMetadataCache<T>.get_ConsumerTypes();
}
public class MassTransit.Configuration.ConsumerPipeSpecificationProxy`2 : object {
    private IPipeSpecification`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _specification;
    public ConsumerPipeSpecificationProxy`2(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public ConsumerPipeSpecificationProxy`2(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`2<TConsumer, TMessage>> builder);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.ConsumerSpecification`1 : OptionsSet {
    private ConnectHandle[] _handles;
    private IReadOnlyDictionary`2<Type, IConsumerMessageSpecification`1<TConsumer>> _messageTypes;
    private ConsumerConfigurationObservable _observers;
    [NullableAttribute("2")]
private IConcurrencyLimiter _concurrencyLimiter;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public ConsumerSpecification`1(IEnumerable`1<IConsumerMessageSpecification`1<TConsumer>> messageSpecifications);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<T>> configure);
    public sealed virtual void ConsumerMessage(Action`1<IConsumerMessageConfigurator`2<TConsumer, T>> configure);
    public sealed virtual IConsumerMessageSpecification`2<TConsumer, T> GetMessageSpecification();
    public sealed virtual void ConfigureMessagePipe(IPipeConfigurator`1<ConsumeContext`1<T>> pipeConfigurator);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerSpecification`1/<Validate>d__13")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ConnectHandle <.ctor>b__4_1(IConsumerMessageSpecification`1<TConsumer> x);
    [CompilerGeneratedAttribute]
private void <Validate>b__13_0(IConsumerConfigurationObserver observer);
}
public class MassTransit.Configuration.ConsumerSplitFilterSpecification`2 : object {
    private IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> _specification;
    public ConsumerSplitFilterSpecification`2(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`2<TConsumer, TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ConsumerSplitFilterSpecification`2/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ConsumeTransformSpecification`1 : TransformSpecification`1<TMessage> {
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.ConsumeContext<TMessage>>.Apply(IPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
}
public class MassTransit.Configuration.ContextFilterPipeSpecification`1 : object {
    private Func`2<TContext, Task`1<bool>> _filter;
    public ContextFilterPipeSpecification`1(Func`2<TContext, Task`1<bool>> filter);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ContextFilterPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.CorrelatedByCorrelationIdSelector`1 : object {
    public sealed virtual bool TryGetSetCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public class MassTransit.Configuration.CorrelatedByEventCorrelationBuilder`2 : object {
    private MassTransitEventCorrelationConfigurator<TInstance, TData> _configurator;
    public CorrelatedByEventCorrelationBuilder`2(SagaStateMachine`1<TInstance> machine, Event`1<TData> event);
    public sealed virtual EventCorrelation Build();
}
public class MassTransit.Configuration.CorrelatedByFaultEventCorrelationBuilder`2 : object {
    private MassTransitEventCorrelationConfigurator<TInstance, Fault`1<TData>> _configurator;
    public CorrelatedByFaultEventCorrelationBuilder`2(SagaStateMachine`1<TInstance> machine, Event`1<Fault`1<TData>> event);
    public sealed virtual EventCorrelation Build();
}
public class MassTransit.Configuration.CorrelationIdMessageSendTopologyConvention`1 : object {
    private List`1<ICorrelationIdSelector`1<TMessage>> _selectors;
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention.TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention<TMessage>.TryGetMessageSendTopology(IMessageSendTopology`1& messageSendTopology);
    public sealed virtual void SetCorrelationId(IMessageCorrelationId`1<TMessage> messageCorrelationId);
    public sealed virtual bool TryGetMessageCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public class MassTransit.Configuration.CorrelationIdSendTopologyConvention : object {
    private ITopologyConventionCache`1<IMessageSendTopologyConvention> _cache;
    public sealed virtual bool TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
}
public class MassTransit.Configuration.DeadLetterPipeSpecification : object {
    private IPipe`1<ReceiveContext> _deadLetterPipe;
    public DeadLetterPipeSpecification(IPipe`1<ReceiveContext> deadLetterPipe);
    public sealed virtual void Apply(IPipeBuilder`1<ReceiveContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.DeadLetterPipeSpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.DefaultActivityDefinition`3 : ActivityDefinition`3<TActivity, TArguments, TLog> {
}
public class MassTransit.Configuration.DefaultConsumerDefinition`1 : ConsumerDefinition`1<TConsumer> {
}
public abstract class MassTransit.Configuration.DefaultEndpointDefinition : object {
    [CompilerGeneratedAttribute]
private bool <IsTemporary>k__BackingField;
    public bool ConfigureConsumeTopology { get; }
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    protected DefaultEndpointDefinition(bool isTemporary);
    public virtual bool get_ConfigureConsumeTopology();
    public abstract virtual string GetEndpointName(IEndpointNameFormatter formatter);
    [CompilerGeneratedAttribute]
public virtual bool get_IsTemporary();
    public virtual Nullable`1<int> get_PrefetchCount();
    public virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual void Configure(T configurator);
}
public class MassTransit.Configuration.DefaultExecuteActivityDefinition`2 : ExecuteActivityDefinition`2<TActivity, TArguments> {
}
public class MassTransit.Configuration.DefaultSagaDefinition`1 : SagaDefinition`1<TSaga> {
}
public class MassTransit.Configuration.DefaultSagaFactory`2 : object {
    public sealed virtual TSaga Create(ConsumeContext`1<TMessage> context);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Configuration.DelayedMessageSchedulerSpecification : object {
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.DelayedMessageSchedulerSpecification/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.DelayedRedeliveryConfigurationObserver : ScheduledRedeliveryConfigurationObserver {
    public DelayedRedeliveryConfigurationObserver(IConsumePipeConfigurator configurator, Action`1<IRedeliveryConfigurator> configure);
    protected virtual IRedeliveryPipeSpecification AddRedeliveryPipeSpecification(IConsumePipeConfigurator configurator);
    public void Method7();
    public void Method8();
    public void Method9();
}
public class MassTransit.Configuration.DelayedRedeliveryConsumerConfigurationObserver`1 : object {
    private IConsumerConfigurator`1<TConsumer> _configurator;
    private Action`1<IRedeliveryConfigurator> _configure;
    public DelayedRedeliveryConsumerConfigurationObserver`1(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IRedeliveryConfigurator> configure);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.DelayedRedeliveryHandlerConfigurationObserver : object {
    private Action`1<IRedeliveryConfigurator> _configure;
    public DelayedRedeliveryHandlerConfigurationObserver(Action`1<IRedeliveryConfigurator> configure);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<T> configurator);
}
public class MassTransit.Configuration.DelayedRedeliveryPipeSpecification`1 : object {
    [CompilerGeneratedAttribute]
private RedeliveryOptions <Options>k__BackingField;
    public RedeliveryOptions Options { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.DelayedRedeliveryPipeSpecification`1/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public sealed virtual RedeliveryOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Options(RedeliveryOptions value);
}
public class MassTransit.Configuration.DelayedRedeliverySagaConfigurationObserver`1 : object {
    private ISagaConfigurator`1<TSaga> _configurator;
    private Action`1<IRedeliveryConfigurator> _configure;
    public DelayedRedeliverySagaConfigurationObserver`1(ISagaConfigurator`1<TSaga> configurator, Action`1<IRedeliveryConfigurator> configure);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.DelegateEndpointDefinition : object {
    private IDefinition _definition;
    private IEndpointDefinition _endpointDefinition;
    private string _endpointName;
    public bool ConfigureConsumeTopology { get; }
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public DelegateEndpointDefinition(string endpointName, IDefinition definition, IEndpointDefinition endpointDefinition);
    public sealed virtual bool get_ConfigureConsumeTopology();
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
    public sealed virtual void Configure(T configurator);
    public sealed virtual bool get_IsTemporary();
    public sealed virtual Nullable`1<int> get_PrefetchCount();
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionActivityRegistrationExtensions : object {
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection, Type activityDefinitionType);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection, IContainerRegistrar registrar, Type activityDefinitionType);
    [ExtensionAttribute]
public static IActivityRegistration RegisterActivity(IServiceCollection collection, IContainerRegistrar registrar, Type activityType, Type activityDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionConsumerRegistrationExtensions : object {
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection, Type consumerDefinitionType);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection, IContainerRegistrar registrar, Type consumerDefinitionType);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterConsumer(IServiceCollection collection, IContainerRegistrar registrar, Type consumerType, Type consumerDefinitionType);
}
public class MassTransit.Configuration.DependencyInjectionContainerRegistrar : object {
    protected IServiceCollection Collection;
    public DependencyInjectionContainerRegistrar(IServiceCollection collection);
    public sealed virtual void RegisterRequestClient(RequestTimeout timeout);
    public sealed virtual void RegisterRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual void RegisterScopedClientFactory();
    public virtual void RegisterEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    public sealed virtual T GetOrAdd(Type type, Func`2<Type, T> missingRegistrationFactory);
    public virtual IEnumerable`1<T> GetRegistrations();
    public sealed virtual bool TryGetValue(IServiceProvider provider, Type type, T& value);
    public virtual IEnumerable`1<T> GetRegistrations(IServiceProvider provider);
    public sealed virtual IConfigureReceiveEndpoint GetConfigureReceiveEndpoints(IServiceProvider provider);
    public virtual IEndpointNameFormatter GetEndpointNameFormatter(IServiceProvider provider);
    protected virtual IConfigureReceiveEndpoint[] GetBusConfigureReceiveEndpoints(IServiceProvider provider);
    private bool TryGetValue(Type type, T& value);
    protected virtual void AddRegistration(T value);
    protected virtual IScopedClientFactory GetScopedBusContext(IServiceProvider provider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IScopedClientFactory <RegisterScopedClientFactory>b__4_0(IServiceProvider provider);
}
public class MassTransit.Configuration.DependencyInjectionContainerRegistrar`1 : DependencyInjectionContainerRegistrar {
    public DependencyInjectionContainerRegistrar`1(IServiceCollection collection);
    public virtual IEnumerable`1<T> GetRegistrations();
    public virtual IEnumerable`1<T> GetRegistrations(IServiceProvider provider);
    protected virtual void AddRegistration(T value);
    public virtual void RegisterEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    protected virtual IScopedClientFactory GetScopedBusContext(IServiceProvider provider);
    protected virtual IConfigureReceiveEndpoint[] GetBusConfigureReceiveEndpoints(IServiceProvider provider);
    public virtual IEndpointNameFormatter GetEndpointNameFormatter(IServiceProvider provider);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionEndpointRegistrationExtensions : object {
    [ExtensionAttribute]
public static IEndpointRegistration RegisterEndpoint(IServiceCollection collection, IRegistration registration, IEndpointSettings`1<IEndpointDefinition`1<T>> settings);
    [ExtensionAttribute]
public static IEndpointRegistration RegisterEndpoint(IServiceCollection collection, IContainerRegistrar registrar, IRegistration registration, IEndpointSettings`1<IEndpointDefinition`1<T>> settings);
    [ExtensionAttribute]
public static IEndpointRegistration RegisterEndpoint(IServiceCollection collection, Type endpointDefinitionType);
    [ExtensionAttribute]
public static IEndpointRegistration RegisterEndpoint(IServiceCollection collection, IContainerRegistrar registrar, Type endpointDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionExecuteActivityRegistrationExtensions : object {
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection, Type activityDefinitionType);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection, IContainerRegistrar registrar, Type activityDefinitionType);
    [ExtensionAttribute]
public static IExecuteActivityRegistration RegisterExecuteActivity(IServiceCollection collection, IContainerRegistrar registrar, Type activityType, Type activityDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionFutureRegistrationExtensions : object {
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection, Type futureDefinitionType);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection, IContainerRegistrar registrar, Type futureDefinitionType);
    [ExtensionAttribute]
public static IFutureRegistration RegisterFuture(IServiceCollection collection, IContainerRegistrar registrar, Type futureType, Type futureDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionHandlerRegistrationExtensions : object {
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`2<ConsumeContext`1<T>, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`2<ConsumeContext`1<T>, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`2<T, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`2<T, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`2<ConsumeContext`1<T>, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`2<ConsumeContext`1<T>, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`2<T, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`2<T, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`3<ConsumeContext`1<T>, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`3<ConsumeContext`1<T>, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`3<T, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`3<T, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`3<ConsumeContext`1<T>, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`3<ConsumeContext`1<T>, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`3<T, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`3<T, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`4<ConsumeContext`1<T>, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`4<ConsumeContext`1<T>, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`4<T, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`4<T, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`4<ConsumeContext`1<T>, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`4<ConsumeContext`1<T>, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`4<T, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`4<T, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`5<T, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`5<T, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, Func`5<T, T1, T2, T3, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistration RegisterHandler(IServiceCollection collection, IContainerRegistrar registrar, Func`5<T, T1, T2, T3, Task`1<TResponse>> handler);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionJobServiceRegistrationExtensions : object {
    [ExtensionAttribute]
public static IJobServiceRegistration RegisterJobService(IServiceCollection collection, IContainerRegistrar registrar);
}
public class MassTransit.Configuration.DependencyInjectionMediatorContainerRegistrar : DependencyInjectionContainerRegistrar {
    public DependencyInjectionMediatorContainerRegistrar(IServiceCollection collection);
    public virtual IEnumerable`1<T> GetRegistrations();
    public virtual IEnumerable`1<T> GetRegistrations(IServiceProvider provider);
    protected virtual void AddRegistration(T value);
    protected virtual IScopedClientFactory GetScopedBusContext(IServiceProvider provider);
}
public class MassTransit.Configuration.DependencyInjectionRiderContainerRegistrar`1 : DependencyInjectionContainerRegistrar {
    public DependencyInjectionRiderContainerRegistrar`1(IServiceCollection collection);
    public virtual IEnumerable`1<T> GetRegistrations();
    public virtual IEnumerable`1<T> GetRegistrations(IServiceProvider provider);
    protected virtual void AddRegistration(T value);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionSagaRegistrationExtensions : object {
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, Type sagaDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, IContainerRegistrar registrar, Type sagaDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, IContainerRegistrar registrar, Type sagaType, Type sagaDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.DependencyInjectionSagaStateMachineRegistrationExtensions : object {
    [ExtensionAttribute]
public static ISagaRegistration RegisterSagaStateMachine(IServiceCollection collection);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSagaStateMachine(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSaga(IServiceCollection collection, IContainerRegistrar registrar);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSagaStateMachine(IServiceCollection collection, Type sagaDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSagaStateMachine(IServiceCollection collection, IContainerRegistrar registrar, Type sagaDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistration RegisterSagaStateMachine(IServiceCollection collection, IContainerRegistrar registrar, Type sagaType, Type sagaDefinitionType);
}
public class MassTransit.Configuration.DispatchPipeSpecification`1 : object {
    private IPipeContextConverterFactory`1<TInput> _pipeContextConverterFactory;
    private List`1<IPipeConnectorSpecification> _specifications;
    public DispatchPipeSpecification`1(IPipeContextConverterFactory`1<TInput> pipeContextConverterFactory);
    public sealed virtual void Pipe(Action`1<IPipeConfigurator`1<T>> configurePipe);
    public sealed virtual void Apply(IPipeBuilder`1<TInput> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.DispatchPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.EndpointConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <IsBusEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IConsumePipeConfiguration <Consume>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendPipeConfiguration <Send>k__BackingField;
    [CompilerGeneratedAttribute]
private IPublishPipeConfiguration <Publish>k__BackingField;
    [CompilerGeneratedAttribute]
private IReceivePipeConfiguration <Receive>k__BackingField;
    [CompilerGeneratedAttribute]
private ITopologyConfiguration <Topology>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationConfiguration <Serialization>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransportConfiguration <Transport>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public int PrefetchCount { get; public set; }
    unknown ContentType DefaultContentType {public set; }
    unknown ContentType SerializerContentType {public set; }
    public bool IsBusEndpoint { get; }
    unknown bool AutoStart {public set; }
    public IConsumePipeConfiguration Consume { get; }
    public ISendPipeConfiguration Send { get; }
    public IPublishPipeConfiguration Publish { get; }
    public IReceivePipeConfiguration Receive { get; }
    public ITopologyConfiguration Topology { get; }
    public ISerializationConfiguration Serialization { get; }
    public ITransportConfiguration Transport { get; }
    protected EndpointConfiguration(ITopologyConfiguration topology);
    protected EndpointConfiguration(IEndpointConfiguration parentConfiguration, ITopologyConfiguration topology, bool isBusEndpoint);
    protected EndpointConfiguration(IEndpointConfiguration endpointConfiguration);
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual int get_PrefetchCount();
    public sealed virtual void set_PrefetchCount(int value);
    public sealed virtual void set_DefaultContentType(ContentType value);
    public sealed virtual void set_SerializerContentType(ContentType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBusEndpoint();
    public sealed virtual void set_AutoStart(bool value);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<T>> specification);
    public sealed virtual void AddPrePipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    public sealed virtual ConnectHandle ConnectSagaConfigurationObserver(ISagaConfigurationObserver observer);
    public sealed virtual void SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    public sealed virtual void SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    public sealed virtual ConnectHandle ConnectHandlerConfigurationObserver(IHandlerConfigurationObserver observer);
    public sealed virtual void HandlerConfigured(IHandlerConfigurator`1<TMessage> configurator);
    public sealed virtual ConnectHandle ConnectActivityConfigurationObserver(IActivityConfigurationObserver observer);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public sealed virtual void ConfigurePublish(Action`1<IPublishPipeConfigurator> callback);
    public sealed virtual void ConfigureSend(Action`1<ISendPipeConfigurator> callback);
    public sealed virtual void ConfigureReceive(Action`1<IReceivePipeConfigurator> callback);
    public sealed virtual void ConfigureDeadLetter(Action`1<IPipeConfigurator`1<ReceiveContext>> callback);
    public sealed virtual void ConfigureError(Action`1<IPipeConfigurator`1<ExceptionReceiveContext>> callback);
    public sealed virtual void ConfigureTransport(Action`1<ITransportConfigurator> callback);
    public virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public sealed virtual IConsumePipeConfiguration get_Consume();
    [CompilerGeneratedAttribute]
public sealed virtual ISendPipeConfiguration get_Send();
    [CompilerGeneratedAttribute]
public sealed virtual IPublishPipeConfiguration get_Publish();
    [CompilerGeneratedAttribute]
public sealed virtual IReceivePipeConfiguration get_Receive();
    [CompilerGeneratedAttribute]
public sealed virtual ITopologyConfiguration get_Topology();
    [CompilerGeneratedAttribute]
public sealed virtual ISerializationConfiguration get_Serialization();
    [CompilerGeneratedAttribute]
public sealed virtual ITransportConfiguration get_Transport();
    public sealed virtual void AddSerializer(ISerializerFactory factory, bool isSerializer);
    public sealed virtual void AddDeserializer(ISerializerFactory factory, bool isDefault);
    public sealed virtual void ClearSerialization();
}
[ExtensionAttribute]
public static class MassTransit.Configuration.EndpointDefinitionExtensions : object {
    [ExtensionAttribute]
public static IEndpointDefinition Combine(IEnumerable`1<IEndpointDefinition> definitions);
}
public class MassTransit.Configuration.EventMissingInstanceConfigurator`2 : object {
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> Discard();
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> Fault();
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> ExecuteAsync(Func`2<ConsumeContext`1<TMessage>, Task> callback);
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> Execute(Action`1<ConsumeContext`1<TMessage>> callback);
}
public class MassTransit.Configuration.ExecuteActivityArgumentsConfigurator`2 : object {
    private IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> _configurator;
    public ExecuteActivityArgumentsConfigurator`2(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ExecuteActivityContext`1<TArguments>> specification);
}
public class MassTransit.Configuration.ExecuteActivityHostConfigurator`2 : object {
    private IExecuteActivityFactory`2<TActivity, TArguments> _activityFactory;
    private IBuildPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> _activityPipeConfigurator;
    private Uri _compensateAddress;
    private ActivityConfigurationObservable _configurationObservers;
    private IBuildPipeConfigurator`1<ExecuteContext`1<TArguments>> _executePipeConfigurator;
    private ActivityObservable _observers;
    private RoutingSlipConfigurator _routingSlipConfigurator;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public ExecuteActivityHostConfigurator`2(IExecuteActivityFactory`2<TActivity, TArguments> activityFactory, IActivityConfigurationObserver observer);
    public ExecuteActivityHostConfigurator`2(IExecuteActivityFactory`2<TActivity, TArguments> activityFactory, Uri compensateAddress, IActivityConfigurationObserver observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ExecuteActivityContext`2<TActivity, TArguments>> specification);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void Arguments(Action`1<IExecuteArgumentsConfigurator`1<TArguments>> configure);
    public sealed virtual void ActivityArguments(Action`1<IExecuteActivityArgumentsConfigurator`1<TArguments>> configure);
    public sealed virtual void RoutingSlip(Action`1<IRoutingSlipConfigurator> configure);
    public sealed virtual ConnectHandle ConnectActivityObserver(IActivityObserver observer);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ExecuteActivityHostConfigurator`2/<Validate>d__18")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Validate>b__18_0(IActivityConfigurationObserver observer);
}
public class MassTransit.Configuration.ExecuteArgumentsConfigurator`1 : object {
    private IPipeConfigurator`1<ExecuteContext`1<TArguments>> _configurator;
    public ExecuteArgumentsConfigurator`1(IPipeConfigurator`1<ExecuteContext`1<TArguments>> configurator);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ExecuteContext`1<TArguments>> specification);
}
public class MassTransit.Configuration.ExecuteContextRedeliveryPipeSpecification`1 : ExceptionSpecification {
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    [CompilerGeneratedAttribute]
private bool <ReplaceMessageId>k__BackingField;
    public bool ReplaceMessageId { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<ExecuteContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ExecuteContextRedeliveryPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
    [CompilerGeneratedAttribute]
public bool get_ReplaceMessageId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReplaceMessageId(bool value);
    private static RetryExecuteContext`1<TArguments> Factory(ExecuteContext`1<TArguments> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.ExecuteContextRetryPipeSpecification`1 : ExceptionSpecification {
    private CancellationToken _cancellationToken;
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public ExecuteContextRetryPipeSpecification`1(CancellationToken cancellationToken);
    public sealed virtual void Apply(IPipeBuilder`1<ExecuteContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ExecuteContextRetryPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle MassTransit.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
    private static RetryExecuteContext`1<TArguments> Factory(ExecuteContext`1<TArguments> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.ExecuteContextTimeoutSpecification`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public TimeSpan Timeout { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<ExecuteContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ExecuteContextTimeoutSpecification`1/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timeout(TimeSpan value);
    private static TimeoutExecuteContext`1<TArguments> Factory(ExecuteContext`1<TArguments> context, CancellationToken cancellationToken);
}
public class MassTransit.Configuration.ForkPipeSpecification`1 : object {
    private IPipe`1<TContext> _pipe;
    public ForkPipeSpecification`1(IPipe`1<TContext> pipe);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ForkPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.FutureFaultConfigurator`1 : object {
    private FutureFault`1<TFault> _fault;
    public FutureFaultConfigurator`1(FutureFault`1<TFault> fault);
    public sealed virtual void SetFaultedUsingFactory(EventMessageFactory`2<FutureState, TFault> factoryMethod);
    public sealed virtual void SetFaultedUsingFactory(AsyncEventMessageFactory`2<FutureState, TFault> factoryMethod);
    public sealed virtual void SetFaultedUsingInitializer(InitializerValueProvider valueProvider);
}
public class MassTransit.Configuration.FutureFaultConfigurator`3 : object {
    private FutureFault`3<TCommand, TFault, TInput> _fault;
    public FutureFaultConfigurator`3(FutureFault`3<TCommand, TFault, TInput> fault);
    public sealed virtual void SetFaultedUsingFactory(EventMessageFactory`3<FutureState, TInput, TFault> factoryMethod);
    public sealed virtual void SetFaultedUsingFactory(AsyncEventMessageFactory`3<FutureState, TInput, TFault> factoryMethod);
    public sealed virtual void SetFaultedUsingInitializer(InitializerValueProvider`1<TInput> valueProvider);
}
public class MassTransit.Configuration.FutureRequestConfigurator`5 : object {
    private IFutureStateMachineConfigurator _configurator;
    private FutureFault`3<TCommand, TFault, Fault`1<TRequest>> _fault;
    private FutureRequest`2<TInput, TRequest> _request;
    [CompilerGeneratedAttribute]
private Event`1<Fault`1<TRequest>> <Faulted>k__BackingField;
    public PendingFutureIdProvider`1<TRequest> PendingRequestIdProvider { get; private set; }
    public Event`1<Fault`1<TRequest>> Faulted { get; }
    unknown Uri RequestAddress {public set; }
    public FutureRequestConfigurator`5(IFutureStateMachineConfigurator configurator, Event`1<Fault`1<TRequest>> faulted);
    public PendingFutureIdProvider`1<TRequest> get_PendingRequestIdProvider();
    private void set_PendingRequestIdProvider(PendingFutureIdProvider`1<TRequest> value);
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<Fault`1<TRequest>> get_Faulted();
    public sealed virtual FutureResponseHandle`5<TCommand, TResult, TFault, TRequest, TResponse> OnResponseReceived(Action`1<IFutureResponseConfigurator`2<TResult, TResponse>> configure);
    public sealed virtual void set_RequestAddress(Uri value);
    public sealed virtual void SetRequestAddressProvider(RequestAddressProvider`1<TInput> provider);
    public sealed virtual void UsingRequestFactory(EventMessageFactory`3<FutureState, TInput, TRequest> factoryMethod);
    public sealed virtual void UsingRequestFactory(AsyncEventMessageFactory`3<FutureState, TInput, TRequest> factoryMethod);
    public sealed virtual void UsingRequestInitializer(InitializerValueProvider`1<TInput> valueProvider);
    public sealed virtual void TrackPendingRequest(PendingFutureIdProvider`1<TRequest> provider);
    public sealed virtual void OnRequestFaulted(Action`1<IFutureFaultConfigurator`2<TFault, Fault`1<TRequest>>> configure);
    public sealed virtual void WhenFaulted(Func`2<EventActivityBinder`2<FutureState, Fault`1<TRequest>>, EventActivityBinder`2<FutureState, Fault`1<TRequest>>> configure);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public Task Send(BehaviorContext`2<FutureState, TInput> context);
    public Task Send(BehaviorContext`2<FutureState, TCommand> context, TInput data);
    public Task SendRange(BehaviorContext`2<FutureState, TCommand> context, IEnumerable`1<TInput> inputs);
    public Task SetFaulted(BehaviorContext`2<FutureState, Fault`1<TRequest>> context);
}
public class MassTransit.Configuration.FutureResponseConfigurator`5 : object {
    private IFutureStateMachineConfigurator _configurator;
    private FutureRequestHandle`4<TCommand, TResult, TFault, TRequest> _request;
    private FutureResult`3<TCommand, TResult, TResponse> _result;
    [CompilerGeneratedAttribute]
private PendingFutureIdProvider`1<TResponse> <PendingResponseIdProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<TResponse> <Completed>k__BackingField;
    public PendingFutureIdProvider`1<TResponse> PendingResponseIdProvider { get; private set; }
    public Event`1<TResponse> Completed { get; }
    public Event`1<Fault`1<TRequest>> Faulted { get; }
    public FutureResponseConfigurator`5(IFutureStateMachineConfigurator configurator, FutureRequestHandle`4<TCommand, TResult, TFault, TRequest> request);
    [CompilerGeneratedAttribute]
public PendingFutureIdProvider`1<TResponse> get_PendingResponseIdProvider();
    [CompilerGeneratedAttribute]
private void set_PendingResponseIdProvider(PendingFutureIdProvider`1<TResponse> value);
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<TResponse> get_Completed();
    public sealed virtual Event`1<Fault`1<TRequest>> get_Faulted();
    public sealed virtual FutureResponseHandle`5<TCommand, TResult, TFault, TRequest, T> OnResponseReceived(Action`1<IFutureResponseConfigurator`2<TResult, T>> configure);
    public sealed virtual void CompletePendingRequest(PendingFutureIdProvider`1<TResponse> provider);
    public sealed virtual void WhenReceived(Func`2<EventActivityBinder`2<FutureState, TResponse>, EventActivityBinder`2<FutureState, TResponse>> configure);
    public sealed virtual void SetCompletedUsingFactory(EventMessageFactory`3<FutureState, TResponse, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingFactory(AsyncEventMessageFactory`3<FutureState, TResponse, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingInitializer(InitializerValueProvider`1<TResponse> valueProvider);
    [IteratorStateMachineAttribute("MassTransit.Configuration.FutureResponseConfigurator`5/<Validate>d__19")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public Task SetResult(BehaviorContext`2<FutureState, TResponse> context);
    private IFutureResultConfigurator`2<TResult, TResponse> GetResultConfigurator();
}
public class MassTransit.Configuration.FutureResultConfigurator`2 : object {
    private FutureResult`2<TCommand, TResult> _result;
    public FutureResultConfigurator`2(FutureResult`2<TCommand, TResult> result);
    public sealed virtual void SetCompletedUsingFactory(EventMessageFactory`2<FutureState, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingFactory(AsyncEventMessageFactory`2<FutureState, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingInitializer(InitializerValueProvider valueProvider);
}
public class MassTransit.Configuration.FutureResultConfigurator`3 : object {
    private FutureResult`3<TCommand, TResult, TInput> _result;
    public FutureResultConfigurator`3(FutureResult`3<TCommand, TResult, TInput> result);
    public sealed virtual void SetCompletedUsingFactory(EventMessageFactory`3<FutureState, TInput, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingFactory(AsyncEventMessageFactory`3<FutureState, TInput, TResult> factoryMethod);
    public sealed virtual void SetCompletedUsingInitializer(InitializerValueProvider`1<TInput> valueProvider);
}
public class MassTransit.Configuration.FutureRoutingSlipConfigurator`4 : object {
    private IFutureStateMachineConfigurator _configurator;
    private IRoutingSlipExecutor`1<TInput> _executor;
    private FutureFault`3<TCommand, TFault, RoutingSlipFaulted> _fault;
    private FutureResult`3<TCommand, TResult, RoutingSlipCompleted> _result;
    [CompilerGeneratedAttribute]
private PendingFutureIdProvider`1<RoutingSlipCompleted> <CompletedIdProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PendingFutureIdProvider`1<RoutingSlipFaulted> <FaultedIdProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RoutingSlipCompleted> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RoutingSlipFaulted> <Faulted>k__BackingField;
    public PendingFutureIdProvider`1<RoutingSlipCompleted> CompletedIdProvider { get; private set; }
    public PendingFutureIdProvider`1<RoutingSlipFaulted> FaultedIdProvider { get; private set; }
    public Event`1<RoutingSlipCompleted> Completed { get; }
    public Event`1<RoutingSlipFaulted> Faulted { get; }
    public FutureRoutingSlipConfigurator`4(IFutureStateMachineConfigurator configurator, Event`1<RoutingSlipCompleted> routingSlipCompleted, Event`1<RoutingSlipFaulted> routingSlipFaulted);
    [CompilerGeneratedAttribute]
public PendingFutureIdProvider`1<RoutingSlipCompleted> get_CompletedIdProvider();
    [CompilerGeneratedAttribute]
private void set_CompletedIdProvider(PendingFutureIdProvider`1<RoutingSlipCompleted> value);
    [CompilerGeneratedAttribute]
public PendingFutureIdProvider`1<RoutingSlipFaulted> get_FaultedIdProvider();
    [CompilerGeneratedAttribute]
private void set_FaultedIdProvider(PendingFutureIdProvider`1<RoutingSlipFaulted> value);
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<RoutingSlipCompleted> get_Completed();
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<RoutingSlipFaulted> get_Faulted();
    public sealed virtual void OnRoutingSlipCompleted(Action`1<IFutureResultConfigurator`2<TResult, RoutingSlipCompleted>> configure);
    public sealed virtual void OnRoutingSlipFaulted(Action`1<IFutureFaultConfigurator`2<TFault, RoutingSlipFaulted>> configure);
    public sealed virtual void WhenRoutingSlipCompleted(Func`2<EventActivityBinder`2<FutureState, RoutingSlipCompleted>, EventActivityBinder`2<FutureState, RoutingSlipCompleted>> configure);
    public sealed virtual void WhenRoutingSlipFaulted(Func`2<EventActivityBinder`2<FutureState, RoutingSlipFaulted>, EventActivityBinder`2<FutureState, RoutingSlipFaulted>> configure);
    public sealed virtual void TrackPendingRoutingSlip();
    public sealed virtual void BuildItinerary(BuildItineraryCallback`1<TInput> buildItinerary);
    public sealed virtual void BuildUsingItineraryPlanner();
    [IteratorStateMachineAttribute("MassTransit.Configuration.FutureRoutingSlipConfigurator`4/<Validate>d__26")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private static object RoutingSlipFaultedValueProvider(BehaviorContext`2<FutureState, RoutingSlipFaulted> context);
    public bool HasResult(FutureResult`3& result);
    public bool HasFault(FutureFault`3& fault);
    public Task Execute(BehaviorContext`2<FutureState, TInput> context);
    private static Guid GetTrackingNumber(RoutingSlipCompleted message);
    private static Guid GetTrackingNumber(RoutingSlipFaulted message);
}
public class MassTransit.Configuration.HandlerConfigurator`1 : object {
    private IPipeSpecification`1<ConsumeContext`1<TMessage>> _handlerConfigurator;
    private HandlerConfigurationObservable _observers;
    private IBuildPipeConfigurator`1<ConsumeContext`1<TMessage>> _pipeConfigurator;
    public HandlerConfigurator`1(MessageHandler`1<TMessage> handler, IHandlerConfigurationObserver observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual ConnectHandle ConnectHandlerConfigurationObserver(IHandlerConfigurationObserver observer);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Configure>b__7_0(IHandlerConfigurationObserver observer);
}
public class MassTransit.Configuration.HandlerConnector`1 : object {
    public sealed virtual ConnectHandle ConnectHandler(IConsumePipeConnector consumePipe, MessageHandler`1<TMessage> handler, IBuildPipeConfigurator`1<ConsumeContext`1<TMessage>> configurator);
    public sealed virtual ConnectHandle ConnectRequestHandler(IRequestPipeConnector consumePipe, Guid requestId, MessageHandler`1<TMessage> handler, IBuildPipeConfigurator`1<ConsumeContext`1<TMessage>> configurator);
}
public class MassTransit.Configuration.HandlerConnectorCache`1 : object {
    private HandlerConnector`1<TMessage> _connector;
    public static IHandlerConnector`1<TMessage> Connector { get; }
    private IHandlerConnector`1<TMessage> MassTransit.Configuration.IHandlerConnectorCache<TMessage>.Connector { get; }
    public static IHandlerConnector`1<TMessage> get_Connector();
    private sealed virtual override IHandlerConnector`1<TMessage> MassTransit.Configuration.IHandlerConnectorCache<TMessage>.get_Connector();
}
public class MassTransit.Configuration.HandlerPipeSpecification`1 : object {
    private MessageHandler`1<T> _handler;
    public HandlerPipeSpecification`1(MessageHandler`1<T> handler);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.ConsumeContext<T>>.Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.HandlerPipeSpecification`1/<MassTransit-ISpecification-Validate>d__3")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
}
public class MassTransit.Configuration.HasValueTypeSagaQueryPropertySelector`2 : object {
    private Func`2<ConsumeContext`1<TData>, Nullable`1<TProperty>> _selector;
    public HasValueTypeSagaQueryPropertySelector`2(Func`2<ConsumeContext`1<TData>, Nullable`1<TProperty>> selector);
    public sealed virtual bool TryGetProperty(ConsumeContext`1<TData> context, Nullable`1& property);
}
public interface MassTransit.Configuration.IActivityRegistration {
    public abstract virtual void AddConfigureAction(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<T, TArguments>> configure);
    public abstract virtual void AddConfigureAction(Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<T, TLog>> configure);
    public abstract virtual void Configure(IReceiveEndpointConfigurator executeEndpointConfigurator, IReceiveEndpointConfigurator compensateEndpointConfigurator, IRegistrationContext context);
    public abstract virtual IActivityDefinition GetDefinition(IRegistrationContext context);
    public abstract virtual void ConfigureCompensate(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public abstract virtual void ConfigureExecute(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Uri compensateAddress);
}
public interface MassTransit.Configuration.IBusConfiguration {
    public IHostConfiguration HostConfiguration { get; }
    public IEndpointConfiguration BusEndpointConfiguration { get; }
    public IBusObserver BusObservers { get; }
    public abstract virtual IHostConfiguration get_HostConfiguration();
    public abstract virtual IEndpointConfiguration get_BusEndpointConfiguration();
    public abstract virtual IBusObserver get_BusObservers();
}
public interface MassTransit.Configuration.IBusInstanceSpecification {
    public abstract virtual void Configure(IBusInstance busInstance);
}
public interface MassTransit.Configuration.ICompensateTransformSpecification`1 {
}
public interface MassTransit.Configuration.IConsumePipeConfiguration {
    public IConsumePipeSpecification Specification { get; }
    public IConsumePipeConfigurator Configurator { get; }
    public abstract virtual IConsumePipeSpecification get_Specification();
    public abstract virtual IConsumePipeConfigurator get_Configurator();
}
public interface MassTransit.Configuration.IConsumerConnector {
    public abstract virtual IConsumerSpecification`1<TConsumer> CreateConsumerSpecification();
    public abstract virtual ConnectHandle ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
}
public interface MassTransit.Configuration.IConsumerConnectorCache {
    public IConsumerConnector Connector { get; }
    public abstract virtual IConsumerConnector get_Connector();
}
public interface MassTransit.Configuration.IConsumerConvention {
    public abstract virtual IConsumerMessageConvention GetConsumerMessageConvention();
}
public interface MassTransit.Configuration.IConsumerMessageConnector {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
}
public interface MassTransit.Configuration.IConsumerMessageConnector`1 {
    public abstract virtual IConsumerMessageSpecification`1<TConsumer> CreateConsumerMessageSpecification();
    public abstract virtual ConnectHandle ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
}
public interface MassTransit.Configuration.IConsumerMessageConvention {
    public abstract virtual IEnumerable`1<IMessageInterfaceType> GetMessageTypes();
}
public interface MassTransit.Configuration.IConsumerMessageSpecification`1 {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
    public abstract virtual bool TryGetMessageSpecification(IConsumerMessageSpecification`2& specification);
}
public interface MassTransit.Configuration.IConsumerMessageSpecification`2 {
    public abstract virtual IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> Build(IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> consumeFilter);
    public abstract virtual IPipe`1<ConsumeContext`1<TMessage>> BuildMessagePipe(Action`1<IPipeConfigurator`1<ConsumeContext`1<TMessage>>> configure);
}
public interface MassTransit.Configuration.IConsumerMetadataCache`1 {
    public IMessageInterfaceType[] ConsumerTypes { get; }
    public abstract virtual IMessageInterfaceType[] get_ConsumerTypes();
}
public interface MassTransit.Configuration.IConsumerRegistration {
    public abstract virtual void AddConfigureAction(Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public abstract virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public abstract virtual IConsumerDefinition GetDefinition(IRegistrationContext context);
    public abstract virtual IConsumerRegistrationConfigurator GetConsumerRegistrationConfigurator(IRegistrationConfigurator registrationConfigurator);
}
public interface MassTransit.Configuration.IConsumerSpecification`1 {
    public abstract virtual IConsumerMessageSpecification`2<TConsumer, T> GetMessageSpecification();
    public abstract virtual void ConfigureMessagePipe(IPipeConfigurator`1<ConsumeContext`1<T>> pipeConfigurator);
}
public interface MassTransit.Configuration.IConsumeTransformSpecification`1 {
}
public interface MassTransit.Configuration.IContainerRegistrar {
    public abstract virtual void RegisterRequestClient(RequestTimeout timeout);
    public abstract virtual void RegisterRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public abstract virtual void RegisterScopedClientFactory();
    public abstract virtual void RegisterEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    public abstract virtual T GetOrAdd(Type type, Func`2<Type, T> missingRegistrationFactory);
    public abstract virtual IEnumerable`1<T> GetRegistrations();
}
public interface MassTransit.Configuration.IContainerSelector {
    public abstract virtual bool TryGetValue(IServiceProvider provider, Type type, T& value);
    public abstract virtual IEnumerable`1<T> GetRegistrations(IServiceProvider provider);
    public abstract virtual IConfigureReceiveEndpoint GetConfigureReceiveEndpoints(IServiceProvider provider);
    public abstract virtual IEndpointNameFormatter GetEndpointNameFormatter(IServiceProvider provider);
}
public interface MassTransit.Configuration.IConventionTypeFactory`1 {
    public abstract virtual TValue Create();
}
public interface MassTransit.Configuration.ICorrelationIdMessageSendTopologyConvention`1 {
    public abstract virtual void SetCorrelationId(IMessageCorrelationId`1<TMessage> messageCorrelationId);
    public abstract virtual bool TryGetMessageCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public interface MassTransit.Configuration.ICorrelationIdSelector`1 {
    public abstract virtual bool TryGetSetCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public interface MassTransit.Configuration.IEndpointConfiguration {
    public bool IsBusEndpoint { get; }
    public IConsumePipeConfiguration Consume { get; }
    public ISendPipeConfiguration Send { get; }
    public IPublishPipeConfiguration Publish { get; }
    public IReceivePipeConfiguration Receive { get; }
    public ITopologyConfiguration Topology { get; }
    public ISerializationConfiguration Serialization { get; }
    public ITransportConfiguration Transport { get; }
    public abstract virtual bool get_IsBusEndpoint();
    public abstract virtual IConsumePipeConfiguration get_Consume();
    public abstract virtual ISendPipeConfiguration get_Send();
    public abstract virtual IPublishPipeConfiguration get_Publish();
    public abstract virtual IReceivePipeConfiguration get_Receive();
    public abstract virtual ITopologyConfiguration get_Topology();
    public abstract virtual ISerializationConfiguration get_Serialization();
    public abstract virtual ITransportConfiguration get_Transport();
}
public interface MassTransit.Configuration.IEndpointRegistration {
    public abstract virtual IEndpointDefinition GetDefinition(IServiceProvider provider);
}
public interface MassTransit.Configuration.IEventCorrelationBuilder {
    public abstract virtual EventCorrelation Build();
}
public interface MassTransit.Configuration.IExecuteActivityRegistration {
    public abstract virtual void AddConfigureAction(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<T, TArguments>> configure);
    public abstract virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public abstract virtual IExecuteActivityDefinition GetDefinition(IRegistrationContext context);
}
public interface MassTransit.Configuration.IExecuteTransformSpecification`1 {
}
public interface MassTransit.Configuration.IFutureRegistration {
    public abstract virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public abstract virtual IFutureDefinition GetDefinition(IRegistrationContext context);
}
public interface MassTransit.Configuration.IHandlerConnector`1 {
    public abstract virtual ConnectHandle ConnectHandler(IConsumePipeConnector consumePipe, MessageHandler`1<T> handler, IBuildPipeConfigurator`1<ConsumeContext`1<T>> configurator);
    public abstract virtual ConnectHandle ConnectRequestHandler(IRequestPipeConnector consumePipe, Guid requestId, MessageHandler`1<T> handler, IBuildPipeConfigurator`1<ConsumeContext`1<T>> configurator);
}
public interface MassTransit.Configuration.IHandlerConnectorCache`1 {
    public IHandlerConnector`1<T> Connector { get; }
    public abstract virtual IHandlerConnector`1<T> get_Connector();
}
[NullableContextAttribute("1")]
public interface MassTransit.Configuration.IHealthCheckOptions {
    [NullableAttribute("2")]
public string Name { get; }
    [ObsoleteAttribute("Use MinimalFailureStatus instead.", "True")]
public Nullable`1<HealthStatus> FailureStatus { get; }
    public Nullable`1<HealthStatus> MinimalFailureStatus { get; }
    public HashSet`1<string> Tags { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
    public abstract virtual Nullable`1<HealthStatus> get_FailureStatus();
    public abstract virtual Nullable`1<HealthStatus> get_MinimalFailureStatus();
    public abstract virtual HashSet`1<string> get_Tags();
}
[NullableContextAttribute("1")]
public interface MassTransit.Configuration.IHostConfiguration {
    public IBusConfiguration BusConfiguration { get; }
    public Uri HostAddress { get; }
    public bool DeployTopologyOnly { get; public set; }
    public bool DeployPublishTopology { get; public set; }
    public ISendObserver SendObservers { get; }
    [NullableAttribute("2")]
public ILogContext LogContext { get; public set; }
    [NullableAttribute("2")]
public ILogContext ReceiveLogContext { get; }
    [NullableAttribute("2")]
public ILogContext SendLogContext { get; }
    public IBusTopology Topology { get; }
    public IRetryPolicy ReceiveTransportRetryPolicy { get; }
    public IRetryPolicy SendTransportRetryPolicy { get; }
    public Nullable`1<TimeSpan> ConsumerStopTimeout { get; public set; }
    public abstract virtual IBusConfiguration get_BusConfiguration();
    public abstract virtual Uri get_HostAddress();
    public abstract virtual bool get_DeployTopologyOnly();
    public abstract virtual void set_DeployTopologyOnly(bool value);
    public abstract virtual bool get_DeployPublishTopology();
    public abstract virtual void set_DeployPublishTopology(bool value);
    public abstract virtual ISendObserver get_SendObservers();
    [NullableContextAttribute("2")]
public abstract virtual ILogContext get_LogContext();
    [NullableContextAttribute("2")]
public abstract virtual void set_LogContext(ILogContext value);
    [NullableContextAttribute("2")]
public abstract virtual ILogContext get_ReceiveLogContext();
    [NullableContextAttribute("2")]
public abstract virtual ILogContext get_SendLogContext();
    public abstract virtual IBusTopology get_Topology();
    public abstract virtual IRetryPolicy get_ReceiveTransportRetryPolicy();
    public abstract virtual IRetryPolicy get_SendTransportRetryPolicy();
    public abstract virtual Nullable`1<TimeSpan> get_ConsumerStopTimeout();
    public abstract virtual void set_ConsumerStopTimeout(Nullable`1<TimeSpan> value);
    public abstract virtual IReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IReceiveEndpointConfigurator> configure);
    public abstract virtual ConnectHandle ConnectReceiveEndpointContext(ReceiveEndpointContext context);
    public abstract virtual IHost Build();
}
public interface MassTransit.Configuration.IInstanceConnector {
    public abstract virtual IConsumerSpecification`1<TConsumer> CreateConsumerSpecification();
    public abstract virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, object instance);
    public abstract virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, TInstance instance, IConsumerSpecification`1<TInstance> specification);
}
public interface MassTransit.Configuration.IInstanceConnectorCache`1 {
    public IInstanceConnector Connector { get; }
    public abstract virtual IInstanceConnector get_Connector();
}
public interface MassTransit.Configuration.IInstanceMessageConnector {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
}
public interface MassTransit.Configuration.IInstanceMessageConnector`1 {
    public abstract virtual IConsumerMessageSpecification`1<TInstance> CreateConsumerMessageSpecification();
    public abstract virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, TInstance instance, IConsumerSpecification`1<TInstance> specification);
}
public interface MassTransit.Configuration.IJobServiceRegistration {
    public IEndpointRegistrationConfigurator EndpointRegistrationConfigurator { get; }
    public IEndpointDefinition EndpointDefinition { get; }
    public abstract virtual IEndpointRegistrationConfigurator get_EndpointRegistrationConfigurator();
    public abstract virtual IEndpointDefinition get_EndpointDefinition();
    public abstract virtual void AddConfigureAction(Action`1<JobConsumerOptions> configure);
    public abstract virtual void AddReceiveEndpointDependency(IReceiveEndpointConfigurator dependency);
    public abstract virtual void Configure(IServiceInstanceConfigurator instanceConfigurator, IRegistrationContext context);
}
public interface MassTransit.Configuration.IMessageConnectorFactory {
    public abstract virtual IConsumerMessageConnector`1<T> CreateConsumerConnector();
    public abstract virtual IInstanceMessageConnector`1<T> CreateInstanceConnector();
}
public interface MassTransit.Configuration.IMessageDataRepositorySelector {
    public IBusFactoryConfigurator Configurator { get; }
    public abstract virtual IBusFactoryConfigurator get_Configurator();
}
public interface MassTransit.Configuration.IMessageFabricConsumeTopologyBuilder {
    public string Exchange { get; public set; }
    public string Queue { get; public set; }
    public abstract virtual string get_Exchange();
    public abstract virtual void set_Exchange(string value);
    public abstract virtual string get_Queue();
    public abstract virtual void set_Queue(string value);
}
public interface MassTransit.Configuration.IMessageFabricPublishTopologyBuilder {
    public string ExchangeName { get; public set; }
    public ExchangeType ExchangeType { get; public set; }
    public abstract virtual string get_ExchangeName();
    public abstract virtual void set_ExchangeName(string value);
    public abstract virtual ExchangeType get_ExchangeType();
    public abstract virtual void set_ExchangeType(ExchangeType value);
    public abstract virtual IMessageFabricPublishTopologyBuilder CreateImplementedBuilder();
}
public interface MassTransit.Configuration.IMessageFabricTopologyBuilder {
    public abstract virtual void ExchangeBind(string source, string destination, string routingKey);
    public abstract virtual void QueueBind(string source, string destination);
    public abstract virtual void ExchangeDeclare(string name, ExchangeType exchangeType);
    public abstract virtual void QueueDeclare(string name);
}
public interface MassTransit.Configuration.IMessageInterfaceType {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
    public abstract virtual IConsumerMessageConnector`1<T> GetConsumerConnector();
    public abstract virtual IInstanceMessageConnector`1<T> GetInstanceConnector();
}
public class MassTransit.Configuration.InitiatedByOrOrchestratesSagaConnectorFactory`2 : object {
    private ISagaMessageConnector`1<TSaga> _connector;
    private sealed virtual override ISagaMessageConnector`1<T> MassTransit.Configuration.ISagaConnectorFactory.CreateMessageConnector();
}
public class MassTransit.Configuration.InitiatedBySagaConnectorFactory`2 : object {
    private ISagaMessageConnector`1<TSaga> _connector;
    private sealed virtual override ISagaMessageConnector`1<T> MassTransit.Configuration.ISagaConnectorFactory.CreateMessageConnector();
}
public class MassTransit.Configuration.InlineFilterPipeSpecification`1 : object {
    private InlineFilterMethod`1<TContext> _filterMethod;
    public InlineFilterPipeSpecification`1(InlineFilterMethod`1<TContext> filterMethod);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.InlineFilterPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.InMemoryCompensateContextOutboxSpecification`1 : object {
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private bool <ConcurrentMessageDelivery>k__BackingField;
    public bool ConcurrentMessageDelivery { get; public set; }
    public InMemoryCompensateContextOutboxSpecification`1(IRegistrationContext context);
    public InMemoryCompensateContextOutboxSpecification`1(ISetScopedConsumeContext setter);
    [CompilerGeneratedAttribute]
public bool get_ConcurrentMessageDelivery();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageDelivery(bool value);
    public sealed virtual void Apply(IPipeBuilder`1<CompensateContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.InMemoryCompensateContextOutboxSpecification`1/<Validate>d__8")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private static InMemoryOutboxCompensateContext`1<TArguments> Factory(CompensateContext`1<TArguments> context);
}
public class MassTransit.Configuration.InMemoryExecuteContextOutboxSpecification`1 : object {
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private bool <ConcurrentMessageDelivery>k__BackingField;
    public bool ConcurrentMessageDelivery { get; public set; }
    public InMemoryExecuteContextOutboxSpecification`1(IRegistrationContext context);
    public InMemoryExecuteContextOutboxSpecification`1(ISetScopedConsumeContext setter);
    [CompilerGeneratedAttribute]
public bool get_ConcurrentMessageDelivery();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageDelivery(bool value);
    public sealed virtual void Apply(IPipeBuilder`1<ExecuteContext`1<TArguments>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.InMemoryExecuteContextOutboxSpecification`1/<Validate>d__8")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private static InMemoryOutboxExecuteContext`1<TArguments> Factory(ExecuteContext`1<TArguments> context);
}
public class MassTransit.Configuration.InMemoryOutboxConfigurationObserver : ConfigurationObserver {
    private Action`1<IOutboxConfigurator> _configure;
    private ISetScopedConsumeContext _setter;
    public InMemoryOutboxConfigurationObserver(IRegistrationContext context, IConsumePipeConfigurator configurator, Action`1<IOutboxConfigurator> configure);
    public InMemoryOutboxConfigurationObserver(ISetScopedConsumeContext setter, IConsumePipeConfigurator configurator, Action`1<IOutboxConfigurator> configure);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.InMemoryOutboxConsumerConfigurationObserver`1 : object {
    private IConsumerConfigurator`1<TConsumer> _configurator;
    private Action`1<IOutboxConfigurator> _configure;
    private ISetScopedConsumeContext _setter;
    public InMemoryOutboxConsumerConfigurationObserver`1(IRegistrationContext context, IConsumerConfigurator`1<TConsumer> configurator, Action`1<IOutboxConfigurator> configure);
    public InMemoryOutboxConsumerConfigurationObserver`1(ISetScopedConsumeContext setter, IConsumerConfigurator`1<TConsumer> configurator, Action`1<IOutboxConfigurator> configure);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.InMemoryOutboxHandlerConfigurationObserver : object {
    private Action`1<IOutboxConfigurator> _configure;
    private ISetScopedConsumeContext _setter;
    public InMemoryOutboxHandlerConfigurationObserver(IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    public InMemoryOutboxHandlerConfigurationObserver(ISetScopedConsumeContext setter, Action`1<IOutboxConfigurator> configure);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<T> configurator);
}
public class MassTransit.Configuration.InMemoryOutboxSagaConfigurationObserver`1 : object {
    private ISagaConfigurator`1<TSaga> _configurator;
    private Action`1<IOutboxConfigurator> _configure;
    private ISetScopedConsumeContext _setter;
    public InMemoryOutboxSagaConfigurationObserver`1(IRegistrationContext context, ISagaConfigurator`1<TSaga> configurator, Action`1<IOutboxConfigurator> configure);
    public InMemoryOutboxSagaConfigurationObserver`1(ISetScopedConsumeContext setter, ISagaConfigurator`1<TSaga> configurator, Action`1<IOutboxConfigurator> configure);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.InMemoryOutboxSpecification`1 : object {
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private bool <ConcurrentMessageDelivery>k__BackingField;
    public bool ConcurrentMessageDelivery { get; public set; }
    public InMemoryOutboxSpecification`1(IRegistrationContext context);
    public InMemoryOutboxSpecification`1(ISetScopedConsumeContext setter);
    [CompilerGeneratedAttribute]
public bool get_ConcurrentMessageDelivery();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageDelivery(bool value);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.InMemoryOutboxSpecification`1/<Validate>d__8")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private static InMemoryOutboxConsumeContext`1<T> Factory(ConsumeContext`1<T> context);
}
public class MassTransit.Configuration.InMemorySagaRepositoryRegistrationProvider : object {
    public sealed virtual void Configure(ISagaRegistrationConfigurator`1<TSaga> configurator);
}
public class MassTransit.Configuration.InMemoryTestHarnessRegistrationBusFactory : object {
    private string _virtualHost;
    public InMemoryTestHarnessRegistrationBusFactory(string virtualHost);
    public sealed virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
}
public class MassTransit.Configuration.InstanceConfigurator : object {
    [NullableAttribute("1")]
private object _instance;
    [NullableContextAttribute("1")]
public InstanceConfigurator(object instance);
    [NullableContextAttribute("1")]
public sealed virtual void Configure(IReceiveEndpointBuilder builder);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MassTransit.Configuration.InstanceConfigurator/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.InstanceConfigurator`1 : object {
    private TInstance _instance;
    private IConsumerSpecification`1<TInstance> _specification;
    unknown Nullable`1<int> ConcurrentMessageLimit {public set; }
    public InstanceConfigurator`1(TInstance instance, IConsumerConfigurationObserver observer);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<T>> configure);
    public sealed virtual void ConsumerMessage(Action`1<IConsumerMessageConfigurator`2<TInstance, T>> configure);
    public sealed virtual T Options(Action`1<T> configure);
    public sealed virtual T Options(T options, Action`1<T> configure);
    public sealed virtual bool TryGetOptions(T& options);
    public sealed virtual IEnumerable`1<T> SelectOptions();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TInstance>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
}
public class MassTransit.Configuration.InstanceConnector`1 : object {
    private List`1<IInstanceMessageConnector`1<TConsumer>> _connectors;
    public sealed virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, T instance, IConsumerSpecification`1<T> specification);
    public sealed virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, object instance);
    public sealed virtual IConsumerSpecification`1<T> CreateConsumerSpecification();
    private static IEnumerable`1<IInstanceMessageConnector`1<TConsumer>> Consumes();
}
public static class MassTransit.Configuration.InstanceConnectorCache : object {
    public static IInstanceConnector GetInstanceConnector();
    public static IInstanceConnector GetInstanceConnector(Type type);
}
public class MassTransit.Configuration.InstanceConnectorCache`1 : object {
    private Lazy`1<InstanceConnector`1<T>> _connector;
    public static IInstanceConnector Connector { get; }
    private IInstanceConnector MassTransit.Configuration.IInstanceConnectorCache<T>.Connector { get; }
    public static IInstanceConnector get_Connector();
    private sealed virtual override IInstanceConnector MassTransit.Configuration.IInstanceConnectorCache<T>.get_Connector();
}
public class MassTransit.Configuration.InstanceEndpointDefinition : object {
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    private string InstanceName { get; }
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public bool ConfigureConsumeTopology { get; }
    [CompilerGeneratedAttribute]
private string get_InstanceName();
    public sealed virtual bool get_IsTemporary();
    public sealed virtual Nullable`1<int> get_PrefetchCount();
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual bool get_ConfigureConsumeTopology();
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
    public sealed virtual void Configure(T configurator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.InstanceJobServiceSettings : object {
    private List`1<Action`1<IReceiveEndpointConfigurator>> _configureActions;
    private JobConsumerOptions _options;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <InstanceAddress>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IReceiveEndpointConfigurator <InstanceEndpointConfigurator>k__BackingField;
    [CompilerGeneratedAttribute]
private IJobService <JobService>k__BackingField;
    public TimeSpan HeartbeatInterval { get; }
    [NullableAttribute("2")]
public Uri InstanceAddress { get; public set; }
    [NullableAttribute("2")]
public IReceiveEndpointConfigurator InstanceEndpointConfigurator { get; public set; }
    public IJobService JobService { get; }
    public InstanceJobServiceSettings(IOptions`1<JobConsumerOptions> options);
    public InstanceJobServiceSettings(JobConsumerOptions options);
    public sealed virtual TimeSpan get_HeartbeatInterval();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Uri get_InstanceAddress();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_InstanceAddress(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IReceiveEndpointConfigurator get_InstanceEndpointConfigurator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_InstanceEndpointConfigurator(IReceiveEndpointConfigurator value);
    [CompilerGeneratedAttribute]
public sealed virtual IJobService get_JobService();
    public void AddConfigureAction(Action`1<IReceiveEndpointConfigurator> configure);
    public void ApplyConfiguration(T configurator);
}
public class MassTransit.Configuration.InstanceMessageConnector`2 : object {
    private IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _consumeFilter;
    private Type MassTransit.Configuration.IInstanceMessageConnector.MessageType { get; }
    public InstanceMessageConnector`2(IFilter`1<ConsumerConsumeContext`2<TConsumer, TMessage>> consumeFilter);
    private sealed virtual override Type MassTransit.Configuration.IInstanceMessageConnector.get_MessageType();
    public sealed virtual ConnectHandle ConnectInstance(IConsumePipeConnector pipeConnector, TConsumer instance, IConsumerSpecification`1<TConsumer> specification);
    public sealed virtual IConsumerMessageSpecification`1<TConsumer> CreateConsumerMessageSpecification();
}
public class MassTransit.Configuration.InterceptPipeSpecification`1 : object {
    private IPipe`1<TContext> _pipe;
    public InterceptPipeSpecification`1(IPipe`1<TContext> pipe);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.InterceptPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public interface MassTransit.Configuration.IObserverConnector`1 {
    public abstract virtual ConnectHandle ConnectObserver(IConsumePipeConnector consumePipe, IObserver`1<ConsumeContext`1<TMessage>> observer, IFilter`1[] filters);
    public abstract virtual ConnectHandle ConnectRequestObserver(IRequestPipeConnector consumePipe, Guid requestId, IObserver`1<ConsumeContext`1<TMessage>> observer, IFilter`1[] filters);
}
public interface MassTransit.Configuration.IObserverConnectorCache`1 {
    public IObserverConnector`1<T> Connector { get; }
    public abstract virtual IObserverConnector`1<T> get_Connector();
}
public interface MassTransit.Configuration.IPartitionKeyMessageSendTopologyConvention`1 {
    public abstract virtual void SetFormatter(IPartitionKeyFormatter formatter);
    public abstract virtual void SetFormatter(IMessagePartitionKeyFormatter`1<TMessage> formatter);
}
public interface MassTransit.Configuration.IPartitionKeySendTopologyConvention {
}
public interface MassTransit.Configuration.IPublishPipeConfiguration {
    public IPublishPipeSpecification Specification { get; }
    public IPublishPipeConfigurator Configurator { get; }
    public abstract virtual IPublishPipeSpecification get_Specification();
    public abstract virtual IPublishPipeConfigurator get_Configurator();
    public abstract virtual IPublishPipe CreatePipe();
}
public interface MassTransit.Configuration.IReceiveEndpointConfiguration {
    public IConsumePipe ConsumePipe { get; }
    public Uri HostAddress { get; }
    public Uri InputAddress { get; }
    public bool ConfigureConsumeTopology { get; }
    public bool PublishFaults { get; }
    public int PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public ReceiveEndpointObservable EndpointObservers { get; }
    public ReceiveObservable ReceiveObservers { get; }
    public ReceiveTransportObservable TransportObservers { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; }
    public Task DependenciesReady { get; }
    public Task DependentsCompleted { get; }
    public abstract virtual IConsumePipe get_ConsumePipe();
    public abstract virtual Uri get_HostAddress();
    public abstract virtual Uri get_InputAddress();
    public abstract virtual bool get_ConfigureConsumeTopology();
    public abstract virtual bool get_PublishFaults();
    public abstract virtual int get_PrefetchCount();
    public abstract virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public abstract virtual ReceiveEndpointObservable get_EndpointObservers();
    public abstract virtual ReceiveObservable get_ReceiveObservers();
    public abstract virtual ReceiveTransportObservable get_TransportObservers();
    public abstract virtual IReceiveEndpoint get_ReceiveEndpoint();
    public abstract virtual Task get_DependenciesReady();
    public abstract virtual Task get_DependentsCompleted();
    public abstract virtual IReceivePipe CreateReceivePipe();
    public abstract virtual ReceiveEndpointContext CreateReceiveEndpointContext();
}
public interface MassTransit.Configuration.IReceivePipeConfiguration {
    public ISpecification Specification { get; }
    public IReceivePipeConfigurator Configurator { get; }
    public IBuildPipeConfigurator`1<ReceiveContext> DeadLetterConfigurator { get; }
    public IBuildPipeConfigurator`1<ExceptionReceiveContext> ErrorConfigurator { get; }
    public abstract virtual ISpecification get_Specification();
    public abstract virtual IReceivePipeConfigurator get_Configurator();
    public abstract virtual IBuildPipeConfigurator`1<ReceiveContext> get_DeadLetterConfigurator();
    public abstract virtual IBuildPipeConfigurator`1<ExceptionReceiveContext> get_ErrorConfigurator();
    public abstract virtual IReceivePipe CreatePipe(IConsumePipe consumePipe, ISerialization serializers);
}
public interface MassTransit.Configuration.IRedeliveryPipeSpecification {
    public RedeliveryOptions Options { get; public set; }
    public abstract virtual RedeliveryOptions get_Options();
    public abstract virtual void set_Options(RedeliveryOptions value);
}
public interface MassTransit.Configuration.IRegistration {
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IncludeInConfigureEndpoints();
    public abstract virtual void set_IncludeInConfigureEndpoints(bool value);
}
public interface MassTransit.Configuration.IRegistrationCache`1 {
    public IEnumerable`1<T> Values { get; }
    public abstract virtual IEnumerable`1<T> get_Values();
}
public interface MassTransit.Configuration.IRoutingKeyMessageSendTopologyConvention`1 {
    public abstract virtual void SetFormatter(IRoutingKeyFormatter formatter);
    public abstract virtual void SetFormatter(IMessageRoutingKeyFormatter`1<TMessage> formatter);
}
public interface MassTransit.Configuration.IRoutingKeySendTopologyConvention {
}
public interface MassTransit.Configuration.ISagaConnector {
    public abstract virtual ISagaSpecification`1<T> CreateSagaSpecification();
    public abstract virtual ConnectHandle ConnectSaga(IConsumePipeConnector consumePipe, ISagaRepository`1<T> repository, ISagaSpecification`1<T> specification);
}
public interface MassTransit.Configuration.ISagaConnectorCache {
    public ISagaConnector Connector { get; }
    public abstract virtual ISagaConnector get_Connector();
}
public interface MassTransit.Configuration.ISagaConnectorFactory {
    public abstract virtual ISagaMessageConnector`1<T> CreateMessageConnector();
}
public interface MassTransit.Configuration.ISagaMessageConnector {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
}
public interface MassTransit.Configuration.ISagaMessageConnector`1 {
    public abstract virtual ISagaMessageSpecification`1<TSaga> CreateSagaMessageSpecification();
    public abstract virtual ConnectHandle ConnectSaga(IConsumePipeConnector consumePipe, ISagaRepository`1<TSaga> repository, ISagaSpecification`1<TSaga> specification);
}
public interface MassTransit.Configuration.ISagaMessageSpecification`1 {
    public Type MessageType { get; }
    public abstract virtual Type get_MessageType();
    public abstract virtual ISagaMessageSpecification`2<TSaga, T> GetMessageSpecification();
}
public interface MassTransit.Configuration.ISagaMessageSpecification`2 {
    public abstract virtual IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> BuildConsumerPipe(IFilter`1<SagaConsumeContext`2<TSaga, TMessage>> consumeFilter);
    public abstract virtual IPipe`1<ConsumeContext`1<TMessage>> BuildMessagePipe(Action`1<IPipeConfigurator`1<ConsumeContext`1<TMessage>>> configure);
}
public interface MassTransit.Configuration.ISagaMetadataCache`1 {
    public SagaInterfaceType[] InitiatedByTypes { get; }
    public SagaInterfaceType[] OrchestratesTypes { get; }
    public SagaInterfaceType[] ObservesTypes { get; }
    public SagaInterfaceType[] InitiatedByOrOrchestratesTypes { get; }
    public SagaInstanceFactoryMethod`1<TSaga> FactoryMethod { get; }
    public abstract virtual SagaInterfaceType[] get_InitiatedByTypes();
    public abstract virtual SagaInterfaceType[] get_OrchestratesTypes();
    public abstract virtual SagaInterfaceType[] get_ObservesTypes();
    public abstract virtual SagaInterfaceType[] get_InitiatedByOrOrchestratesTypes();
    public abstract virtual SagaInstanceFactoryMethod`1<TSaga> get_FactoryMethod();
}
public interface MassTransit.Configuration.ISagaQueryPropertySelector`2 {
    public abstract virtual bool TryGetProperty(ConsumeContext`1<TData> context, TProperty& property);
}
public interface MassTransit.Configuration.ISagaRegistration {
    public abstract virtual void AddConfigureAction(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public abstract virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public abstract virtual ISagaDefinition GetDefinition(IRegistrationContext context);
}
public interface MassTransit.Configuration.ISagaRepositoryDecoratorRegistration`1 {
    public TimeSpan TestTimeout { get; }
    public ReceivedMessageList Consumed { get; }
    public SagaList`1<TSaga> Created { get; }
    public SagaList`1<TSaga> Sagas { get; }
    public abstract virtual TimeSpan get_TestTimeout();
    public abstract virtual ReceivedMessageList get_Consumed();
    public abstract virtual SagaList`1<TSaga> get_Created();
    public abstract virtual SagaList`1<TSaga> get_Sagas();
    public abstract virtual ISagaRepository`1<TSaga> DecorateSagaRepository(ISagaRepository`1<TSaga> repository);
}
public interface MassTransit.Configuration.ISagaRepositoryRegistrationProvider {
    public abstract virtual void Configure(ISagaRegistrationConfigurator`1<TSaga> configurator);
}
public interface MassTransit.Configuration.ISagaSpecification`1 {
    public abstract virtual ISagaMessageSpecification`2<TSaga, T> GetMessageSpecification();
    public abstract virtual void ConfigureMessagePipe(IPipeConfigurator`1<ConsumeContext`1<T>> pipeConfigurator);
}
public interface MassTransit.Configuration.ISendPipeConfiguration {
    public ISendPipeSpecification Specification { get; }
    public ISendPipeConfigurator Configurator { get; }
    public abstract virtual ISendPipeSpecification get_Specification();
    public abstract virtual ISendPipeConfigurator get_Configurator();
    public abstract virtual ISendPipe CreatePipe();
}
public interface MassTransit.Configuration.ISendTransformSpecification`1 {
}
public interface MassTransit.Configuration.ISerializationConfiguration {
    unknown ContentType DefaultContentType {public set; }
    unknown ContentType SerializerContentType {public set; }
    public abstract virtual void set_DefaultContentType(ContentType value);
    public abstract virtual void set_SerializerContentType(ContentType value);
    public abstract virtual void AddSerializer(ISerializerFactory factory, bool isSerializer);
    public abstract virtual void AddDeserializer(ISerializerFactory factory, bool isDefault);
    public abstract virtual void Clear();
    public abstract virtual ISerializationConfiguration CreateSerializationConfiguration();
    public abstract virtual ISerialization CreateSerializerCollection();
}
public interface MassTransit.Configuration.ISetSerializerMessageSendTopologyConvention`1 {
    public abstract virtual void SetSerializer(ContentType contentType);
}
public interface MassTransit.Configuration.IStateMachineInterfaceType {
    public abstract virtual ISagaMessageConnector`1<T> GetConnector();
}
public interface MassTransit.Configuration.ITopologyConfiguration {
    public IMessageTopologyConfigurator Message { get; }
    public ISendTopologyConfigurator Send { get; }
    public IPublishTopologyConfigurator Publish { get; }
    public IConsumeTopologyConfigurator Consume { get; }
    public abstract virtual IMessageTopologyConfigurator get_Message();
    public abstract virtual ISendTopologyConfigurator get_Send();
    public abstract virtual IPublishTopologyConfigurator get_Publish();
    public abstract virtual IConsumeTopologyConfigurator get_Consume();
}
public interface MassTransit.Configuration.ITopologyConventionCache`1 {
    public abstract virtual TResult GetOrAdd();
}
public interface MassTransit.Configuration.ITransportConfiguration {
    public ITransportConfigurator Configurator { get; }
    public int PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public abstract virtual ITransportConfigurator get_Configurator();
    public abstract virtual int get_PrefetchCount();
    public abstract virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public abstract virtual int GetConcurrentMessageLimit();
}
public class MassTransit.Configuration.JobAttemptSagaDefinition : SagaDefinition`1<JobAttemptSaga> {
    private JobSagaOptions _options;
    private JobSagaSettingsConfigurator _setOptions;
    public JobAttemptSagaDefinition(IOptions`1<JobSagaOptions> options);
    protected virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, ISagaConfigurator`1<JobAttemptSaga> sagaConfigurator, IRegistrationContext context);
}
public class MassTransit.Configuration.JobConsumerConvention : object {
    private sealed virtual override IConsumerMessageConvention MassTransit.Configuration.IConsumerConvention.GetConsumerMessageConvention();
}
public class MassTransit.Configuration.JobConsumerMessageConnector`2 : object {
    private IConsumerConnector _finalizeJobConsumerConnector;
    private IConsumerConnector _startJobConsumerConnector;
    private IConsumerConnector _submitJobConsumerConnector;
    public Type MessageType { get; }
    public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageSpecification`1<TConsumer> CreateConsumerMessageSpecification();
    public sealed virtual ConnectHandle ConnectConsumer(IConsumePipeConnector consumePipe, IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
    private static IPipe`1<ConsumeContext`1<TJob>> CreateJobPipe(IConsumerFactory`1<TConsumer> consumerFactory, IConsumerSpecification`1<TConsumer> specification);
    private ConnectHandle ConnectSubmitJobConsumer(IConsumePipeConnector consumePipe, IConsumerSpecification`1<SubmitJobConsumer`1<TJob>> specification, JobOptions`1<TJob> options, Guid jobTypeId);
    private ConnectHandle ConnectStartJobConsumer(IConsumePipeConnector consumePipe, IConsumerSpecification`1<StartJobConsumer`1<TJob>> specification, JobOptions`1<TJob> options, Guid jobTypeId, IJobService jobService, IPipe`1<ConsumeContext`1<TJob>> pipe);
    private ConnectHandle ConnectFinalizeJobConsumer(IConsumePipeConnector consumePipe, IConsumerSpecification`1<FinalizeJobConsumer`1<TJob>> specification, Guid jobTypeId);
    private static void ConfigureInstanceStartJobConsumer(IReceiveEndpointConfigurator configurator, JobOptions`1<TJob> options, Guid jobTypeId, IJobService jobService, IPipe`1<ConsumeContext`1<TJob>> pipe);
}
public class MassTransit.Configuration.JobConsumerMessageConvention`1 : object {
    [IteratorStateMachineAttribute("MassTransit.Configuration.JobConsumerMessageConvention`1/<GetMessageTypes>d__0")]
public sealed virtual IEnumerable`1<IMessageInterfaceType> GetMessageTypes();
}
public class MassTransit.Configuration.JobConsumerMessageSpecification`2 : object {
    private ConsumerMessageSpecification`2<TConsumer, TJob> _consumerSpecification;
    [CompilerGeneratedAttribute]
private IConsumerSpecification`1<SubmitJobConsumer`1<TJob>> <SubmitJobSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IConsumerSpecification`1<StartJobConsumer`1<TJob>> <StartJobSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IConsumerSpecification`1<FinalizeJobConsumer`1<TJob>> <FinalizeJobSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IConsumerSpecification`1<SuperviseJobConsumer> <SuperviseJobSpecification>k__BackingField;
    public IConsumerSpecification`1<SubmitJobConsumer`1<TJob>> SubmitJobSpecification { get; }
    public IConsumerSpecification`1<StartJobConsumer`1<TJob>> StartJobSpecification { get; }
    public IConsumerSpecification`1<FinalizeJobConsumer`1<TJob>> FinalizeJobSpecification { get; }
    public IConsumerSpecification`1<SuperviseJobConsumer> SuperviseJobSpecification { get; }
    public Type MessageType { get; }
    [CompilerGeneratedAttribute]
public IConsumerSpecification`1<SubmitJobConsumer`1<TJob>> get_SubmitJobSpecification();
    [CompilerGeneratedAttribute]
public IConsumerSpecification`1<StartJobConsumer`1<TJob>> get_StartJobSpecification();
    [CompilerGeneratedAttribute]
public IConsumerSpecification`1<FinalizeJobConsumer`1<TJob>> get_FinalizeJobSpecification();
    [CompilerGeneratedAttribute]
public IConsumerSpecification`1<SuperviseJobConsumer> get_SuperviseJobSpecification();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`2<TConsumer, TJob>> specification);
    public sealed virtual void Message(Action`1<IConsumerMessageConfigurator`1<TJob>> configure);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual Type get_MessageType();
    public sealed virtual bool TryGetMessageSpecification(IConsumerMessageSpecification`2& specification);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TJob>> specification);
    public sealed virtual IPipe`1<ConsumerConsumeContext`2<TConsumer, TJob>> Build(IFilter`1<ConsumerConsumeContext`2<TConsumer, TJob>> consumeFilter);
    public sealed virtual IPipe`1<ConsumeContext`1<TJob>> BuildMessagePipe(Action`1<IPipeConfigurator`1<ConsumeContext`1<TJob>>> configure);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumerConsumeContext`1<TConsumer>> specification);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
}
public class MassTransit.Configuration.JobInterfaceType : object {
    private Lazy`1<IMessageConnectorFactory> _consumeConnectorFactory;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type MessageType { get; }
    public JobInterfaceType(Type messageType, Type consumerType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MessageType();
    public sealed virtual IConsumerMessageConnector`1<T> GetConsumerConnector();
    public sealed virtual IInstanceMessageConnector`1<T> GetInstanceConnector();
}
public class MassTransit.Configuration.JobMessageConnectorFactory`2 : object {
    private IConsumerMessageConnector`1<TConsumer> _jobConsumerConnector;
    public sealed virtual IConsumerMessageConnector`1<T> CreateConsumerConnector();
    private sealed virtual override IInstanceMessageConnector`1<T> MassTransit.Configuration.IMessageConnectorFactory.CreateInstanceConnector();
}
public class MassTransit.Configuration.JobSagaDefinition : SagaDefinition`1<JobSaga> {
    private JobSagaOptions _options;
    private JobSagaSettingsConfigurator _setOptions;
    public JobSagaDefinition(IOptions`1<JobSagaOptions> options);
    protected virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, ISagaConfigurator`1<JobSaga> sagaConfigurator, IRegistrationContext context);
}
public interface MassTransit.Configuration.JobSagaSettings {
    public Uri JobAttemptSagaEndpointAddress { get; }
    public Uri JobSagaEndpointAddress { get; }
    public Uri JobTypeSagaEndpointAddress { get; }
    public TimeSpan StatusCheckInterval { get; }
    public int SuspectJobRetryCount { get; }
    public Nullable`1<TimeSpan> SuspectJobRetryDelay { get; }
    public TimeSpan SlotWaitTime { get; }
    public TimeSpan HeartbeatTimeout { get; }
    public bool FinalizeCompleted { get; }
    public abstract virtual Uri get_JobAttemptSagaEndpointAddress();
    public abstract virtual Uri get_JobSagaEndpointAddress();
    public abstract virtual Uri get_JobTypeSagaEndpointAddress();
    public abstract virtual TimeSpan get_StatusCheckInterval();
    public abstract virtual int get_SuspectJobRetryCount();
    public abstract virtual Nullable`1<TimeSpan> get_SuspectJobRetryDelay();
    public abstract virtual TimeSpan get_SlotWaitTime();
    public abstract virtual TimeSpan get_HeartbeatTimeout();
    public abstract virtual bool get_FinalizeCompleted();
}
public interface MassTransit.Configuration.JobSagaSettingsConfigurator {
    unknown Uri JobAttemptSagaEndpointAddress {public set; }
    unknown Uri JobSagaEndpointAddress {public set; }
    unknown Uri JobTypeSagaEndpointAddress {public set; }
    public abstract virtual void set_JobAttemptSagaEndpointAddress(Uri value);
    public abstract virtual void set_JobSagaEndpointAddress(Uri value);
    public abstract virtual void set_JobTypeSagaEndpointAddress(Uri value);
}
public class MassTransit.Configuration.JobServiceConfigurator`1 : object {
    private IReceiveConfigurator`1<TReceiveEndpointConfigurator> _busConfigurator;
    private JobServiceOptions _options;
    private bool _endpointsConfigured;
    private ISagaRepository`1<JobAttemptSaga> _jobAttemptRepository;
    private IReceiveEndpointConfigurator _jobAttemptSagaEndpointConfigurator;
    private ISagaRepository`1<JobSaga> _jobRepository;
    private IReceiveEndpointConfigurator _jobSagaEndpointConfigurator;
    private ISagaRepository`1<JobTypeSaga> _jobTypeRepository;
    private IReceiveEndpointConfigurator _jobTypeSagaEndpointConfigurator;
    unknown ISagaRepository`1<JobTypeSaga> Repository {public set; }
    unknown ISagaRepository`1<JobSaga> JobRepository {public set; }
    unknown ISagaRepository`1<JobAttemptSaga> JobAttemptRepository {public set; }
    unknown string JobServiceStateEndpointName {public set; }
    unknown string JobServiceJobStateEndpointName {public set; }
    unknown string JobServiceJobAttemptStateEndpointName {public set; }
    unknown TimeSpan SlotWaitTime {public set; }
    unknown TimeSpan StatusCheckInterval {public set; }
    unknown int SuspectJobRetryCount {public set; }
    unknown TimeSpan SuspectJobRetryDelay {public set; }
    unknown Nullable`1<int> SagaPartitionCount {public set; }
    unknown bool FinalizeCompleted {public set; }
    public JobServiceConfigurator`1(IServiceInstanceConfigurator`1<TReceiveEndpointConfigurator> instanceConfigurator, JobServiceOptions options);
    public sealed virtual void set_Repository(ISagaRepository`1<JobTypeSaga> value);
    public sealed virtual void set_JobRepository(ISagaRepository`1<JobSaga> value);
    public sealed virtual void set_JobAttemptRepository(ISagaRepository`1<JobAttemptSaga> value);
    public sealed virtual void set_JobServiceStateEndpointName(string value);
    public sealed virtual void set_JobServiceJobStateEndpointName(string value);
    public sealed virtual void set_JobServiceJobAttemptStateEndpointName(string value);
    public sealed virtual void set_SlotWaitTime(TimeSpan value);
    public sealed virtual void set_StatusCheckInterval(TimeSpan value);
    public sealed virtual void set_SuspectJobRetryCount(int value);
    public sealed virtual void set_SuspectJobRetryDelay(TimeSpan value);
    public sealed virtual void set_SagaPartitionCount(Nullable`1<int> value);
    public sealed virtual void set_FinalizeCompleted(bool value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public void OnConfigureEndpoint(Action`1<IReceiveEndpointConfigurator> callback);
    public void ConfigureJobServiceEndpoints(IRegistrationContext context);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(IReceiveEndpointConfigurator cfg);
}
public class MassTransit.Configuration.JobServiceConsumerConfigurationObserver : object {
    private IReceiveEndpointConfigurator _configurator;
    private Action`1<IReceiveEndpointConfigurator> _configureEndpoint;
    private Dictionary`2<Type, IConsumeConfigurator> _consumerConfigurators;
    private JobServiceSettings _settings;
    private bool _endpointConfigured;
    public JobServiceConsumerConfigurationObserver(IReceiveEndpointConfigurator configurator, JobServiceSettings settings, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    public sealed virtual void ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.JobServiceEndpointConfigurationObserver : object {
    private Action`1<IReceiveEndpointConfigurator> _configureEndpoint;
    private JobServiceSettings _settings;
    public JobServiceEndpointConfigurationObserver(JobServiceSettings settings, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void EndpointConfigured(T configurator);
}
public class MassTransit.Configuration.JobServiceEndpointDefinition : object {
    private InstanceJobServiceSettings _jobServiceSettings;
    private IEndpointSettings`1<IEndpointDefinition`1<JobService>> _settings;
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    private string InstanceName { get; }
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public bool ConfigureConsumeTopology { get; }
    public JobServiceEndpointDefinition(IEndpointSettings`1<IEndpointDefinition`1<JobService>> settings, InstanceJobServiceSettings jobServiceSettings);
    [CompilerGeneratedAttribute]
private string get_InstanceName();
    public sealed virtual bool get_IsTemporary();
    public sealed virtual Nullable`1<int> get_PrefetchCount();
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual bool get_ConfigureConsumeTopology();
    public sealed virtual void Configure(T configurator);
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
}
public class MassTransit.Configuration.JobTypeSagaDefinition : SagaDefinition`1<JobTypeSaga> {
    private JobSagaOptions _options;
    private JobSagaSettingsConfigurator _setOptions;
    public JobTypeSagaDefinition(IOptions`1<JobSagaOptions> options);
    protected virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, ISagaConfigurator`1<JobTypeSaga> sagaConfigurator, IRegistrationContext context);
}
public class MassTransit.Configuration.LatestPipeSpecification`1 : object {
    private LatestFilterCreated`1<T> _created;
    unknown LatestFilterCreated`1<T> MassTransit.ILatestConfigurator<T>.Created {private set; }
    private sealed virtual override void MassTransit.ILatestConfigurator<T>.set_Created(LatestFilterCreated`1<T> value);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<T>.Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.LatestPipeSpecification`1/<MassTransit-ISpecification-Validate>d__4")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
}
public class MassTransit.Configuration.MassTransitHealthCheckOptions`1 : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HealthStatus> <FailureStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HealthStatus> <MinimalFailureStatus>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <Tags>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    [ObsoleteAttribute("Use MinimalFailureStatus instead.", "True")]
public Nullable`1<HealthStatus> FailureStatus { get; public set; }
    public Nullable`1<HealthStatus> MinimalFailureStatus { get; public set; }
    [NullableAttribute("1")]
public HashSet`1<string> Tags { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<HealthStatus> get_FailureStatus();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailureStatus(Nullable`1<HealthStatus> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<HealthStatus> get_MinimalFailureStatus();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MinimalFailureStatus(Nullable`1<HealthStatus> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_Tags();
}
public class MassTransit.Configuration.MediatorConfiguration : ReceivePipeDispatcherConfiguration {
    private IHostConfiguration _hostConfiguration;
    public MediatorConfiguration(IHostConfiguration hostConfiguration, IReceiveEndpointConfiguration endpointConfiguration);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
}
public class MassTransit.Configuration.MediatorRegistrationContext : object {
    private RegistrationContext _registration;
    public MediatorRegistrationContext(RegistrationContext registration);
    public sealed virtual object GetService(Type serviceType);
    public sealed virtual void ConfigureConsumer(Type consumerType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureConsumer(IReceiveEndpointConfigurator configurator, Action`1<IConsumerConfigurator`1<T>> configure);
    public sealed virtual void ConfigureConsumers(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(Type sagaType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    public sealed virtual void ConfigureSagas(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureExecuteActivity(Type activityType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureActivity(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureActivityExecute(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, Uri compensateAddress);
    public sealed virtual void ConfigureActivityCompensate(Type activityType, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureFuture(Type futureType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureFuture(IReceiveEndpointConfigurator configurator);
    public sealed virtual IDisposable PushContext(IServiceScope scope, ConsumeContext context);
}
public class MassTransit.Configuration.MessageConsumePipeSpecification`1 : object {
    private List`1<IPipeSpecification`1<ConsumeContext>> _baseSpecifications;
    private List`1<ISpecificationPipeSpecification`1<ConsumeContext`1<TMessage>>> _parentMessageSpecifications;
    private List`1<IPipeSpecification`1<ConsumeContext`1<TMessage>>> _specifications;
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext> specification);
    private sealed virtual override IMessageConsumePipeSpecification`1<T> MassTransit.Configuration.IMessageConsumePipeSpecification.GetMessageSpecification();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Apply(ISpecificationPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> BuildMessagePipe(IPipe`1<ConsumeContext`1<TMessage>> pipe);
    public sealed virtual void AddParentMessageSpecification(ISpecificationPipeSpecification`1<ConsumeContext`1<TMessage>> parentSpecification);
    private static ConsumeContext FilterContext(ConsumeContext`1<TMessage> context);
    private static ConsumeContext`1<TMessage> MergeContext(ConsumeContext`1<TMessage> input, ConsumeContext context);
}
internal class MassTransit.Configuration.MessageDataRepositorySelector : object {
    [CompilerGeneratedAttribute]
private IBusFactoryConfigurator <Configurator>k__BackingField;
    public IBusFactoryConfigurator Configurator { get; }
    public MessageDataRepositorySelector(IBusFactoryConfigurator configurator);
    [CompilerGeneratedAttribute]
public sealed virtual IBusFactoryConfigurator get_Configurator();
}
public class MassTransit.Configuration.MessageObserverConnector`1 : object {
    public sealed virtual ConnectHandle ConnectObserver(IConsumePipeConnector consumePipe, IObserver`1<ConsumeContext`1<TMessage>> observer, IFilter`1[] filters);
    public sealed virtual ConnectHandle ConnectRequestObserver(IRequestPipeConnector consumePipe, Guid requestId, IObserver`1<ConsumeContext`1<TMessage>> observer, IFilter`1[] filters);
}
public class MassTransit.Configuration.MessageRetryConfigurationObserver : ConfigurationObserver {
    private CancellationToken _cancellationToken;
    private Action`1<IRetryConfigurator> _configure;
    public MessageRetryConfigurationObserver(IConsumePipeConfigurator receiveEndpointConfigurator, CancellationToken cancellationToken, Action`1<IRetryConfigurator> configure);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    private static RetryConsumeContext`1<TMessage> Factory(ConsumeContext`1<TMessage> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.MessageRetryConsumerConfigurationObserver`1 : object {
    private CancellationToken _cancellationToken;
    private IConsumerConfigurator`1<TConsumer> _configurator;
    private Action`1<IRetryConfigurator> _configure;
    public MessageRetryConsumerConfigurationObserver`1(IConsumerConfigurator`1<TConsumer> configurator, CancellationToken cancellationToken, Action`1<IRetryConfigurator> configure);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
    public void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    private static RetryConsumeContext`1<TMessage> Factory(ConsumeContext`1<TMessage> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.MessageRetryHandlerConfigurationObserver : object {
    private CancellationToken _cancellationToken;
    private Action`1<IRetryConfigurator> _configure;
    public MessageRetryHandlerConfigurationObserver(CancellationToken cancellationToken, Action`1<IRetryConfigurator> configure);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<T> configurator);
    private static RetryConsumeContext`1<T> Factory(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.MessageRetrySagaConfigurationObserver`1 : object {
    private CancellationToken _cancellationToken;
    private ISagaConfigurator`1<TSaga> _configurator;
    private Action`1<IRetryConfigurator> _configure;
    public MessageRetrySagaConfigurationObserver`1(ISagaConfigurator`1<TSaga> configurator, CancellationToken cancellationToken, Action`1<IRetryConfigurator> configure);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
    private static RetryConsumeContext`1<TMessage> Factory(ConsumeContext`1<TMessage> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
public class MassTransit.Configuration.MessageSchedulerPipeSpecification : object {
    private Uri _schedulerAddress;
    public MessageSchedulerPipeSpecification(Uri schedulerAddress);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.MessageSchedulerPipeSpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.MessageScopeConfigurationObserver : ConfigurationObserver {
    private IServiceProvider _serviceProvider;
    private ISetScopedConsumeContext _setScopedConsumeContext;
    public MessageScopeConfigurationObserver(IConsumePipeConfigurator receiveEndpointConfigurator, IServiceProvider serviceProvider);
    public MessageScopeConfigurationObserver(IConsumePipeConfigurator receiveEndpointConfigurator, IServiceProvider serviceProvider, ISetScopedConsumeContext setScopedConsumeContext);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.MessageTypeFilterConfigurator : object {
    [CompilerGeneratedAttribute]
private CompositeFilter`1<Type> <Filter>k__BackingField;
    public CompositeFilter`1<Type> Filter { get; }
    [CompilerGeneratedAttribute]
public CompositeFilter`1<Type> get_Filter();
    public sealed virtual void Include(Type[] messageTypes);
    public sealed virtual void Include(Func`2<Type, bool> filter);
    public sealed virtual void Include();
    public sealed virtual void Exclude(Type[] messageTypes);
    public sealed virtual void Exclude(Func`2<Type, bool> filter);
    public sealed virtual void Exclude();
    private static bool Match(Type type, Type[] messageTypes);
    private static bool Match(Type type);
}
public class MassTransit.Configuration.MissingInstanceRedeliveryConfigurator`2 : ExceptionSpecification {
    private IMissingInstanceConfigurator`2<TSaga, TMessage> _configurator;
    private IPipe`1<ConsumeContext`1<TMessage>> _finalPipe;
    private RetryPolicyFactory _policyFactory;
    [CompilerGeneratedAttribute]
private bool <ReplaceMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseMessageScheduler>k__BackingField;
    public bool ReplaceMessageId { get; public set; }
    public bool UseMessageScheduler { get; public set; }
    public MissingInstanceRedeliveryConfigurator`2(IMissingInstanceConfigurator`2<TSaga, TMessage> configurator);
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    public sealed virtual void OnRedeliveryLimitReached(Func`2<IMissingInstanceConfigurator`2<TSaga, TMessage>, IPipe`1<ConsumeContext`1<TMessage>>> configure);
    public sealed virtual ConnectHandle ConnectRetryObserver(IRetryObserver observer);
    [CompilerGeneratedAttribute]
public bool get_ReplaceMessageId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReplaceMessageId(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseMessageScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseMessageScheduler(bool value);
    [IteratorStateMachineAttribute("MassTransit.Configuration.MissingInstanceRedeliveryConfigurator`2/<Validate>d__15")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public IPipe`1<ConsumeContext`1<TMessage>> Build();
}
public class MassTransit.Configuration.NamedEndpointDefinition : DefaultEndpointDefinition {
    private string _endpointName;
    public NamedEndpointDefinition(string endpointName);
    public virtual string GetEndpointName(IEndpointNameFormatter formatter);
}
public class MassTransit.Configuration.NotDefaultValueTypeSagaQueryPropertySelector`2 : object {
    private Func`2<ConsumeContext`1<TData>, TProperty> _selector;
    public NotDefaultValueTypeSagaQueryPropertySelector`2(Func`2<ConsumeContext`1<TData>, TProperty> selector);
    public sealed virtual bool TryGetProperty(ConsumeContext`1<TData> context, TProperty& property);
}
public class MassTransit.Configuration.ObserverConfigurator`1 : object {
    private IPipeSpecification`1<ConsumeContext`1<TMessage>> _handlerConfigurator;
    private IBuildPipeConfigurator`1<ConsumeContext`1<TMessage>> _pipeConfigurator;
    public ObserverConfigurator`1(IObserver`1<ConsumeContext`1<TMessage>> observer);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<TMessage>> specification);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
}
public class MassTransit.Configuration.ObserverConnectorCache`1 : object {
    private Lazy`1<MessageObserverConnector`1<TMessage>> _connector;
    public static IObserverConnector`1<TMessage> Connector { get; }
    private IObserverConnector`1<TMessage> MassTransit.Configuration.IObserverConnectorCache<TMessage>.Connector { get; }
    public static IObserverConnector`1<TMessage> get_Connector();
    private sealed virtual override IObserverConnector`1<TMessage> MassTransit.Configuration.IObserverConnectorCache<TMessage>.get_Connector();
}
public class MassTransit.Configuration.ObserverPipeSpecification`1 : object {
    private IObserver`1<ConsumeContext`1<T>> _observer;
    public ObserverPipeSpecification`1(IObserver`1<ConsumeContext`1<T>> observer);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.ConsumeContext<T>>.Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ObserverPipeSpecification`1/<MassTransit-ISpecification-Validate>d__3")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
}
public class MassTransit.Configuration.ObservesSagaConnectorFactory`2 : object {
    private ISagaMessageConnector`1<TSaga> _connector;
    private sealed virtual override ISagaMessageConnector`1<T> MassTransit.Configuration.ISagaConnectorFactory.CreateMessageConnector();
    private static Expression`1<Func`3<TSaga, TMessage, bool>> GetFilterExpression();
}
public class MassTransit.Configuration.OrchestratesSagaConnectorFactory`2 : object {
    private ISagaMessageConnector`1<TSaga> _connector;
    private sealed virtual override ISagaMessageConnector`1<T> MassTransit.Configuration.ISagaConnectorFactory.CreateMessageConnector();
}
public class MassTransit.Configuration.OutboxConsumePipeSpecificationObserver`1 : object {
    private IReceiveEndpointConfigurator _configurator;
    private IServiceProvider _serviceProvider;
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private int <MessageDeliveryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MessageDeliveryTimeout>k__BackingField;
    public int MessageDeliveryLimit { get; public set; }
    public TimeSpan MessageDeliveryTimeout { get; public set; }
    public OutboxConsumePipeSpecificationObserver`1(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public OutboxConsumePipeSpecificationObserver`1(IReceiveEndpointConfigurator configurator, IServiceProvider serviceProvider, ISetScopedConsumeContext setter);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public sealed virtual void ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    public sealed virtual void ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    [CompilerGeneratedAttribute]
public int get_MessageDeliveryLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageDeliveryLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MessageDeliveryTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageDeliveryTimeout(TimeSpan value);
    public sealed virtual void SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    public sealed virtual void SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    private void AddScopedFilter(IPipeConfigurator`1<ConsumeContext`1<TMessage>> messageConfigurator);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ActivityConfigured>b__5_0(IRoutingSlipConfigurator e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ExecuteActivityConfigured>b__6_0(IRoutingSlipConfigurator e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CompensateActivityConfigured>b__7_0(IRoutingSlipConfigurator e);
}
public class MassTransit.Configuration.ParentPublishPipeSpecificationObserver : object {
    private IPublishPipeSpecification _specification;
    public ParentPublishPipeSpecificationObserver(IPublishPipeSpecification specification);
    public sealed virtual void MessageSpecificationCreated(IMessagePublishPipeSpecification`1<T> specification);
}
public class MassTransit.Configuration.ParentSendPipeSpecificationObserver : object {
    private ISendPipeSpecification _specification;
    public ParentSendPipeSpecificationObserver(ISendPipeSpecification specification);
    public sealed virtual void MessageSpecificationCreated(IMessageSendPipeSpecification`1<T> specification);
}
public class MassTransit.Configuration.PartitionConsumerSpecification`1 : object {
    private PartitionKeyProvider`1<ConsumerConsumeContext`1<TConsumer>> _keyProvider;
    private IPartitioner _partitioner;
    public PartitionConsumerSpecification`1(IPartitioner partitioner, PartitionKeyProvider`1<ConsumerConsumeContext`1<TConsumer>> keyProvider);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumerConsumeContext`1<TConsumer>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.PartitionConsumerSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.PartitionerPipeSpecification`1 : object {
    private PartitionKeyProvider`1<T> _keyProvider;
    private int _partitionCount;
    private IPartitioner _partitioner;
    public PartitionerPipeSpecification`1(PartitionKeyProvider`1<T> keyProvider, int partitionCount);
    public PartitionerPipeSpecification`1(PartitionKeyProvider`1<T> keyProvider, IPartitioner partitioner);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.PartitionerPipeSpecification`1/<Validate>d__6")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.PartitionKeyMessageSendTopologyConvention`1 : object {
    private IMessagePartitionKeyFormatter`1<TMessage> _formatter;
    public PartitionKeyMessageSendTopologyConvention`1(IPartitionKeyFormatter formatter);
    public sealed virtual bool TryGetMessageSendTopology(IMessageSendTopology`1& messageSendTopology);
    public sealed virtual bool TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
    public sealed virtual void SetFormatter(IPartitionKeyFormatter formatter);
    public sealed virtual void SetFormatter(IMessagePartitionKeyFormatter`1<TMessage> formatter);
}
public class MassTransit.Configuration.PartitionKeySendTopologyConvention : object {
    private ITopologyConventionCache`1<IMessageSendTopologyConvention> _cache;
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention.TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
}
public class MassTransit.Configuration.PartitionMessageConfigurationObserver : ConfigurationObserver {
    private IPartitioner _partitioner;
    public PartitionMessageConfigurationObserver(IConsumePipeConfigurator configurator, IPartitioner partitioner);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.PartitionMessageSpecification`1 : object {
    private IPartitioner _partitioner;
    private PartitionKeyProvider`1<ConsumeContext`1<T>> _keyProvider;
    public PartitionMessageSpecification`1(IPartitioner partitioner);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.PartitionMessageSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.PartitionSagaSpecification`1 : object {
    private PartitionKeyProvider`1<SagaConsumeContext`1<TSaga>> _keyProvider;
    private IPartitioner _partitioner;
    public PartitionSagaSpecification`1(IPartitioner partitioner, PartitionKeyProvider`1<SagaConsumeContext`1<TSaga>> keyProvider);
    public sealed virtual void Apply(IPipeBuilder`1<SagaConsumeContext`1<TSaga>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.PartitionSagaSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.PropertyCorrelationIdSelector`1 : object {
    private string _propertyName;
    public PropertyCorrelationIdSelector`1(string propertyName);
    public sealed virtual bool TryGetSetCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public class MassTransit.Configuration.PropertySagaInstanceFactory`1 : object {
    [CompilerGeneratedAttribute]
private SagaInstanceFactoryMethod`1<TSaga> <FactoryMethod>k__BackingField;
    public SagaInstanceFactoryMethod`1<TSaga> FactoryMethod { get; }
    [CompilerGeneratedAttribute]
public SagaInstanceFactoryMethod`1<TSaga> get_FactoryMethod();
}
public class MassTransit.Configuration.PublishMessageSchedulerPipeSpecification : object {
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.PublishMessageSchedulerPipeSpecification/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.PublishPipeConfiguration : object {
    private PublishPipeSpecification _specification;
    public IPublishPipeSpecification Specification { get; }
    public IPublishPipeConfigurator Configurator { get; }
    public PublishPipeConfiguration(IPublishTopology publishTopology);
    public PublishPipeConfiguration(IPublishPipeSpecification parentSpecification);
    public sealed virtual IPublishPipeSpecification get_Specification();
    public sealed virtual IPublishPipeConfigurator get_Configurator();
    public sealed virtual IPublishPipe CreatePipe();
}
public class MassTransit.Configuration.RateLimitPipeSpecification`1 : object {
    private TimeSpan _interval;
    private int _rateLimit;
    private IPipeRouter _router;
    public RateLimitPipeSpecification`1(int rateLimit, TimeSpan interval, IPipeRouter router);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.RateLimitPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ReceiveContextRescuePipeSpecification : ExceptionSpecification {
    private IPipe`1<ExceptionReceiveContext> _rescuePipe;
    public ReceiveContextRescuePipeSpecification(IPipe`1<ExceptionReceiveContext> rescuePipe);
    public sealed virtual void Apply(IPipeBuilder`1<ReceiveContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ReceiveContextRescuePipeSpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.ReceiveEndpointBuilder : object {
    private IReceiveEndpointConfiguration _configuration;
    public ReceiveEndpointBuilder(IReceiveEndpointConfiguration configuration);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
}
public abstract class MassTransit.Configuration.ReceiveEndpointConfiguration : EndpointConfiguration {
    private Lazy`1<IConsumePipe> _consumePipe;
    private HashSet`1<IReceiveEndpointDependency> _dependencies;
    private HashSet`1<IReceiveEndpointDependent> _dependents;
    private List`1<string> _lateConfigurationKeys;
    private List`1<IReceiveEndpointSpecification> _specifications;
    private IReceiveEndpoint _receiveEndpoint;
    [CompilerGeneratedAttribute]
private ReceiveEndpointObservable <EndpointObservers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceiveObservable <ReceiveObservers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceiveTransportObservable <TransportObservers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConfigureConsumeTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublishFaults>k__BackingField;
    public ReceiveEndpointObservable EndpointObservers { get; }
    public ReceiveObservable ReceiveObservers { get; }
    public ReceiveTransportObservable TransportObservers { get; }
    public bool ConfigureConsumeTopology { get; public set; }
    public bool PublishFaults { get; public set; }
    public IConsumePipe ConsumePipe { get; }
    public Uri HostAddress { get; }
    public Uri InputAddress { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; protected set; }
    public Task DependenciesReady { get; }
    public Task DependentsCompleted { get; }
    protected ReceiveEndpointConfiguration(IHostConfiguration hostConfiguration, IEndpointConfiguration endpointConfiguration);
    [CompilerGeneratedAttribute]
public sealed virtual ReceiveEndpointObservable get_EndpointObservers();
    [CompilerGeneratedAttribute]
public sealed virtual ReceiveObservable get_ReceiveObservers();
    [CompilerGeneratedAttribute]
public sealed virtual ReceiveTransportObservable get_TransportObservers();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConfigureConsumeTopology();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConfigureConsumeTopology(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PublishFaults();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PublishFaults(bool value);
    public sealed virtual ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual void AddDependent(IReceiveEndpointDependent dependent);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ReceiveEndpointConfiguration/<Validate>d__26")]
public virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual IConsumePipe get_ConsumePipe();
    public abstract virtual Uri get_HostAddress();
    public abstract virtual Uri get_InputAddress();
    public virtual IReceiveEndpoint get_ReceiveEndpoint();
    protected virtual void set_ReceiveEndpoint(IReceiveEndpoint value);
    public virtual IReceivePipe CreateReceivePipe();
    public abstract virtual ReceiveEndpointContext CreateReceiveEndpointContext();
    public sealed virtual Task get_DependenciesReady();
    public sealed virtual Task get_DependentsCompleted();
    public sealed virtual void ConfigureMessageTopology(bool enabled);
    public sealed virtual void ConfigureMessageTopology(Type messageType, bool enabled);
    public sealed virtual void AddDependency(IReceiveEndpointDependency dependency);
    protected void ApplySpecifications(IReceiveEndpointBuilder builder);
    public sealed virtual void AddEndpointSpecification(IReceiveEndpointSpecification specification);
    protected virtual IConsumePipe CreateConsumePipe();
    protected void Changed(string key);
    protected virtual bool IsAlreadyConfigured();
    [CompilerGeneratedAttribute]
private IConsumePipe <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private ValidationResult <Validate>b__26_1(string x);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationResult> <>n__0();
}
public class MassTransit.Configuration.ReceivePipeConfiguration : object {
    private IBuildPipeConfigurator`1<ReceiveContext> _configurator;
    private bool _created;
    [CompilerGeneratedAttribute]
private IBuildPipeConfigurator`1<ReceiveContext> <DeadLetterConfigurator>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildPipeConfigurator`1<ExceptionReceiveContext> <ErrorConfigurator>k__BackingField;
    public ISpecification Specification { get; }
    public IReceivePipeConfigurator Configurator { get; }
    public IBuildPipeConfigurator`1<ReceiveContext> DeadLetterConfigurator { get; }
    public IBuildPipeConfigurator`1<ExceptionReceiveContext> ErrorConfigurator { get; }
    public sealed virtual ISpecification get_Specification();
    public sealed virtual IReceivePipeConfigurator get_Configurator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuildPipeConfigurator`1<ReceiveContext> get_DeadLetterConfigurator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuildPipeConfigurator`1<ExceptionReceiveContext> get_ErrorConfigurator();
    public sealed virtual IReceivePipe CreatePipe(IConsumePipe consumePipe, ISerialization serializers);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ReceiveContext> specification);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private IPipe`1<ReceiveContext> CreateDeadLetterPipe();
    private IPipe`1<ExceptionReceiveContext> CreateErrorPipe();
}
public class MassTransit.Configuration.ReceivePipeDispatcherConfiguration : ReceiverConfiguration {
    private IReceiveEndpointConfiguration _endpointConfiguration;
    private IHostConfiguration _hostConfiguration;
    public ReceivePipeDispatcherConfiguration(IHostConfiguration hostConfiguration, IReceiveEndpointConfiguration endpointConfiguration);
    public sealed virtual ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public IReceivePipeDispatcher Build();
}
public class MassTransit.Configuration.ReceiverConfiguration : EndpointConfiguration {
    private IReceiveEndpointConfiguration _configuration;
    protected List`1<IReceiveEndpointSpecification> Specifications;
    public Uri InputAddress { get; }
    unknown bool ConfigureConsumeTopology {public set; }
    unknown bool PublishFaults {public set; }
    protected ReceiverConfiguration(IReceiveEndpointConfiguration endpointConfiguration);
    public sealed virtual Uri get_InputAddress();
    public sealed virtual void set_ConfigureConsumeTopology(bool value);
    public sealed virtual void set_PublishFaults(bool value);
    public sealed virtual void AddDependency(IReceiveEndpointDependency dependent);
    private sealed virtual override ConnectHandle MassTransit.IReceiveEndpointObserverConnector.ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual void AddDependent(IReceiveEndpointDependent dependent);
    public sealed virtual void ConfigureMessageTopology(bool enabled);
    public sealed virtual void ConfigureMessageTopology(Type messageType, bool enabled);
    public sealed virtual void AddEndpointSpecification(IReceiveEndpointSpecification specification);
    public virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.RedeliverRequestStateMachineSpecification : object {
    private Action`1<IMissingInstanceRedeliveryConfigurator> _configure;
    public RedeliverRequestStateMachineSpecification(Action`1<IMissingInstanceRedeliveryConfigurator> configure);
    public sealed virtual IPipe`1<ConsumeContext`1<TMessage>> Apply(IMissingInstanceConfigurator`2<TInstance, TMessage> configurator);
    [CompilerGeneratedAttribute]
private void <Apply>b__2_0(IMissingInstanceRedeliveryConfigurator`2<TInstance, TMessage> r);
}
public class MassTransit.Configuration.RedeliveryRetryPipeSpecification`1 : ExceptionSpecification {
    private RetryObservable _observers;
    private IRedeliveryPipeSpecification _redeliveryPipeSpecification;
    private RetryPolicyFactory _policyFactory;
    unknown bool ReplaceMessageId {public set; }
    public RedeliveryRetryPipeSpecification`1(IRedeliveryPipeSpecification redeliveryPipeSpecification);
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.RedeliveryRetryPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    public sealed virtual ConnectHandle ConnectRetryObserver(IRetryObserver observer);
    public sealed virtual void set_ReplaceMessageId(bool value);
    private static RetryConsumeContext`1<TMessage> Factory(ConsumeContext`1<TMessage> context, IRetryPolicy retryPolicy, RetryContext retryContext);
}
[DefaultMemberAttribute("Item")]
public abstract class MassTransit.Configuration.RegistrationConfigurator : object {
    private IServiceCollection _collection;
    private bool _configured;
    private ISagaRepositoryRegistrationProvider _sagaRepositoryRegistrationProvider;
    [CompilerGeneratedAttribute]
private IContainerRegistrar <Registrar>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestTimeout <DefaultRequestTimeout>k__BackingField;
    public IContainerRegistrar Registrar { get; }
    protected RequestTimeout DefaultRequestTimeout { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ServiceDescriptor Item { get; public set; }
    protected RegistrationConfigurator(IServiceCollection collection, IContainerRegistrar registrar);
    [CompilerGeneratedAttribute]
public sealed virtual IContainerRegistrar get_Registrar();
    [CompilerGeneratedAttribute]
protected RequestTimeout get_DefaultRequestTimeout();
    [CompilerGeneratedAttribute]
private void set_DefaultRequestTimeout(RequestTimeout value);
    public sealed virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public sealed virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Type consumerDefinitionType, Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSaga(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSaga(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public sealed virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Type executeActivityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public sealed virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public sealed virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Type activityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public sealed virtual IFutureRegistrationConfigurator`1<TFuture> AddFuture(Type futureDefinitionType);
    public sealed virtual void AddEndpoint(Type definitionType);
    public sealed virtual void AddEndpoint(IRegistration registration, IEndpointSettings`1<IEndpointDefinition`1<T>> settings);
    public sealed virtual void AddRequestClient(RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Type requestType, RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Type requestType, Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual void SetDefaultRequestTimeout(RequestTimeout timeout);
    public sealed virtual void SetDefaultRequestTimeout(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public sealed virtual void SetEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaRepository();
    public sealed virtual void SetSagaRepositoryProvider(ISagaRepositoryRegistrationProvider provider);
    public sealed virtual IEnumerator`1<ServiceDescriptor> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(ServiceDescriptor item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ServiceDescriptor item);
    public sealed virtual void CopyTo(ServiceDescriptor[] array, int arrayIndex);
    public sealed virtual bool Remove(ServiceDescriptor item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(ServiceDescriptor item);
    public sealed virtual void Insert(int index, ServiceDescriptor item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ServiceDescriptor get_Item(int index);
    public sealed virtual void set_Item(int index, ServiceDescriptor value);
    private RequestTimeout GetRequestTimeout(RequestTimeout timeout);
    public void Complete();
    protected RegistrationContext CreateRegistration(IServiceProvider provider, ISetScopedConsumeContext setScopedConsumeContext);
    protected void ThrowIfAlreadyConfigured(string methodName);
    protected static void ConfigureLogContext(IServiceProvider provider);
}
public class MassTransit.Configuration.RegistrationContext : object {
    private IServiceProvider _provider;
    private ISetScopedConsumeContext _setScopedConsumeContext;
    [CompilerGeneratedAttribute]
private IContainerSelector <Selector>k__BackingField;
    protected IContainerSelector Selector { get; }
    public RegistrationContext(IServiceProvider provider, IContainerSelector selector, ISetScopedConsumeContext setScopedConsumeContext);
    [CompilerGeneratedAttribute]
protected IContainerSelector get_Selector();
    public sealed virtual void ConfigureConsumer(Type consumerType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureConsumer(IReceiveEndpointConfigurator configurator, Action`1<IConsumerConfigurator`1<T>> configure);
    public sealed virtual void ConfigureConsumers(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(Type sagaType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    public sealed virtual void ConfigureSagas(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureExecuteActivity(Type activityType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureActivity(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureActivityExecute(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, Uri compensateAddress);
    public sealed virtual void ConfigureActivityCompensate(Type activityType, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureFuture(Type futureType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureFuture(IReceiveEndpointConfigurator configurator);
    public sealed virtual object GetService(Type serviceType);
    public sealed virtual IDisposable PushContext(IServiceScope scope, ConsumeContext context);
}
[ExtensionAttribute]
public static class MassTransit.Configuration.RegistrationServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static void RegisterSagaRepository(IServiceCollection collection);
    [ExtensionAttribute]
public static void RegisterQuerySagaRepository(IServiceCollection collection);
    [ExtensionAttribute]
public static void RegisterLoadSagaRepository(IServiceCollection collection);
    [ExtensionAttribute]
internal static void RemoveSagaRepositories(IServiceCollection collection);
}
public class MassTransit.Configuration.RescuePipeSpecification`2 : ExceptionSpecification {
    private IPipeConfigurator`1<TContext> _contextPipeConfigurator;
    private IBuildPipeConfigurator`1<TRescue> _pipeConfigurator;
    private RescueContextFactory`2<TContext, TRescue> _rescueContextFactory;
    private IPipeConfigurator`1<TContext> MassTransit.IRescueConfigurator<TContext,TRescue>.ContextPipe { get; }
    public RescuePipeSpecification`2(RescueContextFactory`2<TContext, TRescue> rescueContextFactory);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.RescuePipeSpecification`2/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private sealed virtual override IPipeConfigurator`1<TContext> MassTransit.IRescueConfigurator<TContext,TRescue>.get_ContextPipe();
    private sealed virtual override void MassTransit.IPipeConfigurator<TRescue>.AddPipeSpecification(IPipeSpecification`1<TRescue> specification);
}
public class MassTransit.Configuration.RetryPipeSpecification`1 : ExceptionSpecification {
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.RetryPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    public sealed virtual ConnectHandle ConnectRetryObserver(IRetryObserver observer);
}
internal abstract class MassTransit.Configuration.Rider : object {
}
public class MassTransit.Configuration.RiderRegistrationContext : object {
    private RegistrationContext _registration;
    private IContainerSelector _selector;
    public RiderRegistrationContext(RegistrationContext registration, IContainerSelector selector);
    public sealed virtual IEnumerable`1<T> GetRegistrations();
    public sealed virtual object GetService(Type serviceType);
    public sealed virtual void ConfigureConsumer(Type consumerType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureConsumer(IReceiveEndpointConfigurator configurator, Action`1<IConsumerConfigurator`1<T>> configure);
    public sealed virtual void ConfigureConsumers(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(Type sagaType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureSaga(IReceiveEndpointConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    public sealed virtual void ConfigureSagas(IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureExecuteActivity(Type activityType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureActivity(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureActivityExecute(Type activityType, IReceiveEndpointConfigurator executeEndpointConfigurator, Uri compensateAddress);
    public sealed virtual void ConfigureActivityCompensate(Type activityType, IReceiveEndpointConfigurator compensateEndpointConfigurator);
    public sealed virtual void ConfigureFuture(Type futureType, IReceiveEndpointConfigurator configurator);
    public sealed virtual void ConfigureFuture(IReceiveEndpointConfigurator configurator);
    public sealed virtual IDisposable PushContext(IServiceScope scope, ConsumeContext context);
}
public class MassTransit.Configuration.RoutingKeyMessageSendTopologyConvention`1 : object {
    private IMessageRoutingKeyFormatter`1<TMessage> _formatter;
    public RoutingKeyMessageSendTopologyConvention`1(IRoutingKeyFormatter formatter);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention<TMessage>.TryGetMessageSendTopology(IMessageSendTopology`1& messageSendTopology);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention.TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
    public sealed virtual void SetFormatter(IRoutingKeyFormatter formatter);
    public sealed virtual void SetFormatter(IMessageRoutingKeyFormatter`1<TMessage> formatter);
}
public class MassTransit.Configuration.RoutingKeySendTopologyConvention : object {
    private ITopologyConventionCache`1<IMessageSendTopologyConvention> _cache;
    public sealed virtual bool TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
}
public class MassTransit.Configuration.RoutingSlipConfigurator : object {
    private IBuildPipeConfigurator`1<ConsumeContext`1<RoutingSlip>> _configurator;
    public sealed virtual IPipe`1<ConsumeContext`1<RoutingSlip>> Build();
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ConsumeContext`1<RoutingSlip>> specification);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.SagaConfigurator`1 : object {
    private ISagaRepository`1<TSaga> _sagaRepository;
    private ISagaSpecification`1<TSaga> _specification;
    unknown Nullable`1<int> ConcurrentMessageLimit {public set; }
    public SagaConfigurator`1(ISagaRepository`1<TSaga> sagaRepository, ISagaConfigurationObserver observer);
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void Message(Action`1<ISagaMessageConfigurator`1<T>> configure);
    public sealed virtual void SagaMessage(Action`1<ISagaMessageConfigurator`2<TSaga, T>> configure);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<SagaConsumeContext`1<TSaga>> specification);
    public sealed virtual ConnectHandle ConnectSagaConfigurationObserver(ISagaConfigurationObserver observer);
    public sealed virtual T Options(Action`1<T> configure);
    public sealed virtual T Options(T options, Action`1<T> configure);
    public sealed virtual bool TryGetOptions(T& options);
    public sealed virtual IEnumerable`1<T> SelectOptions();
}
public class MassTransit.Configuration.SagaConnector`1 : object {
    private List`1<ISagaMessageConnector`1<TSaga>> _connectors;
    public IEnumerable`1<ISagaMessageConnector> Connectors { get; }
    public IEnumerable`1<ISagaMessageConnector> get_Connectors();
    private sealed virtual override ISagaSpecification`1<T> MassTransit.Configuration.ISagaConnector.CreateSagaSpecification();
    private sealed virtual override ConnectHandle MassTransit.Configuration.ISagaConnector.ConnectSaga(IConsumePipeConnector consumePipe, ISagaRepository`1<T> repository, ISagaSpecification`1<T> specification);
    private static IEnumerable`1<ISagaMessageConnector`1<TSaga>> Initiates();
    private static IEnumerable`1<ISagaMessageConnector`1<TSaga>> Orchestrates();
    private static IEnumerable`1<ISagaMessageConnector`1<TSaga>> Observes();
    private static IEnumerable`1<ISagaMessageConnector`1<TSaga>> InitiatesOrOrchestrates();
}
public class MassTransit.Configuration.SagaConnector`2 : object {
}
public class MassTransit.Configuration.SagaConnectorCache`1 : object {
    private Lazy`1<SagaConnector`1<TSaga>> _connector;
    public static ISagaConnector Connector { get; }
    private ISagaConnector MassTransit.Configuration.ISagaConnectorCache.Connector { get; }
    public static ISagaConnector get_Connector();
    private sealed virtual override ISagaConnector MassTransit.Configuration.ISagaConnectorCache.get_Connector();
}
public class MassTransit.Configuration.SagaConsumeContextRescuePipeSpecification`1 : ExceptionSpecification {
    private IPipe`1<ExceptionSagaConsumeContext`1<T>> _rescuePipe;
    public SagaConsumeContextRescuePipeSpecification`1(IPipe`1<ExceptionSagaConsumeContext`1<T>> rescuePipe);
    public sealed virtual void Apply(IPipeBuilder`1<SagaConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.SagaConsumeContextRescuePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.SagaFilterSpecification`2 : object {
    private IFilter`1<SagaConsumeContext`1<TSaga>> _filter;
    public SagaFilterSpecification`2(IFilter`1<SagaConsumeContext`1<TSaga>> filter);
    public sealed virtual void Apply(IPipeBuilder`1<SagaConsumeContext`2<TSaga, TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.SagaFilterSpecification`2/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.Configuration.SagaInterfaceType : object {
    private Lazy`1<ISagaConnectorFactory> _initiatedByConnectorFactory;
    private Lazy`1<ISagaConnectorFactory> _initiatedByOrOrchestratesConnectorFactory;
    private Lazy`1<ISagaConnectorFactory> _observesConnectorFactory;
    private Lazy`1<ISagaConnectorFactory> _orchestratesConnectorFactory;
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type InterfaceType { get; private set; }
    public Type MessageType { get; private set; }
    public SagaInterfaceType(Type interfaceType, Type messageType, Type sagaType);
    [CompilerGeneratedAttribute]
public Type get_InterfaceType();
    [CompilerGeneratedAttribute]
private void set_InterfaceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
private void set_MessageType(Type value);
    public ISagaMessageConnector`1<T> GetInitiatedByConnector();
    public ISagaMessageConnector`1<T> GetOrchestratesConnector();
    public ISagaMessageConnector`1<T> GetObservesConnector();
    public ISagaMessageConnector`1<T> GetInitiatedByOrOrchestratesConnector();
}
public class MassTransit.Configuration.SagaMetadataCache`1 : object {
    private SagaInstanceFactoryMethod`1<TSaga> _factoryMethod;
    public static SagaInterfaceType[] InitiatedByTypes { get; }
    public static SagaInterfaceType[] OrchestratesTypes { get; }
    public static SagaInterfaceType[] ObservesTypes { get; }
    public static SagaInterfaceType[] InitiatedByOrOrchestratesTypes { get; }
    public static SagaInstanceFactoryMethod`1<TSaga> FactoryMethod { get; }
    private SagaInstanceFactoryMethod`1<TSaga> MassTransit.Configuration.ISagaMetadataCache<TSaga>.FactoryMethod { get; }
    private SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.InitiatedByTypes { get; }
    private SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.OrchestratesTypes { get; }
    private SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.ObservesTypes { get; }
    private SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.InitiatedByOrOrchestratesTypes { get; }
    public static SagaInterfaceType[] get_InitiatedByTypes();
    public static SagaInterfaceType[] get_OrchestratesTypes();
    public static SagaInterfaceType[] get_ObservesTypes();
    public static SagaInterfaceType[] get_InitiatedByOrOrchestratesTypes();
    public static SagaInstanceFactoryMethod`1<TSaga> get_FactoryMethod();
    private sealed virtual override SagaInstanceFactoryMethod`1<TSaga> MassTransit.Configuration.ISagaMetadataCache<TSaga>.get_FactoryMethod();
    private sealed virtual override SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.get_InitiatedByTypes();
    private sealed virtual override SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.get_OrchestratesTypes();
    private sealed virtual override SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.get_ObservesTypes();
    private sealed virtual override SagaInterfaceType[] MassTransit.Configuration.ISagaMetadataCache<TSaga>.get_InitiatedByOrOrchestratesTypes();
    private void GetActivatorSagaInstanceFactoryMethod();
    [AsyncStateMachineAttribute("MassTransit.Configuration.SagaMetadataCache`1/<GenerateFactoryMethodAsynchronously>d__23")]
private Task GenerateFactoryMethodAsynchronously();
    [AsyncStateMachineAttribute("MassTransit.Configuration.SagaMetadataCache`1/<GeneratePropertyFactoryMethodAsynchronously>d__24")]
private Task GeneratePropertyFactoryMethodAsynchronously();
    private static IEnumerable`1<SagaInterfaceType> GetInitiatingTypes();
    private static IEnumerable`1<SagaInterfaceType> GetOrchestratingTypes();
    private static IEnumerable`1<SagaInterfaceType> GetObservingTypes();
    private static IEnumerable`1<SagaInterfaceType> GetInitiatingOrOrchestratingTypes();
}
public class MassTransit.Configuration.SagaQueryPropertySelector`2 : object {
    private Func`2<ConsumeContext`1<TData>, TProperty> _selector;
    public SagaQueryPropertySelector`2(Func`2<ConsumeContext`1<TData>, TProperty> selector);
    public sealed virtual bool TryGetProperty(ConsumeContext`1<TData> context, TProperty& property);
}
public class MassTransit.Configuration.SagaRepositoryRegistrationProvider : object {
    public virtual void Configure(ISagaRegistrationConfigurator`1<TSaga> configurator);
}
public class MassTransit.Configuration.SagaSpecification`1 : OptionsSet {
    private ConnectHandle[] _handles;
    private IReadOnlyDictionary`2<Type, ISagaMessageSpecification`1<TSaga>> _messageTypes;
    protected SagaConfigurationObservable Observers;
    private IConcurrencyLimiter _concurrencyLimiter;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public SagaSpecification`1(IEnumerable`1<ISagaMessageSpecification`1<TSaga>> messageSpecifications);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual void Message(Action`1<ISagaMessageConfigurator`1<T>> configure);
    public sealed virtual void SagaMessage(Action`1<ISagaMessageConfigurator`2<TSaga, T>> configure);
    public sealed virtual ISagaMessageSpecification`2<TSaga, T> GetMessageSpecification();
    public sealed virtual void ConfigureMessagePipe(IPipeConfigurator`1<ConsumeContext`1<T>> pipeConfigurator);
    [IteratorStateMachineAttribute("MassTransit.Configuration.SagaSpecification`1/<Validate>d__13")]
public virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<SagaConsumeContext`1<TSaga>> specification);
    public sealed virtual ConnectHandle ConnectSagaConfigurationObserver(ISagaConfigurationObserver observer);
    [CompilerGeneratedAttribute]
private ConnectHandle <.ctor>b__4_1(ISagaMessageSpecification`1<TSaga> x);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Validate>b__13_0(ISagaConfigurationObserver observer);
}
public class MassTransit.Configuration.ScheduledRedeliveryConfigurationObserver : ConfigurationObserver {
    private IConsumePipeConfigurator _configurator;
    private Action`1<IRedeliveryConfigurator> _configure;
    public ScheduledRedeliveryConfigurationObserver(IConsumePipeConfigurator configurator, Action`1<IRedeliveryConfigurator> configure);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    protected virtual IRedeliveryPipeSpecification AddRedeliveryPipeSpecification(IConsumePipeConfigurator configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.ScheduledRedeliveryConsumerConfigurationObserver`1 : object {
    private IConsumerConfigurator`1<TConsumer> _configurator;
    private Action`1<IRetryConfigurator> _configure;
    public ScheduledRedeliveryConsumerConfigurationObserver`1(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IRetryConfigurator> configure);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.ScheduledRedeliveryHandlerConfigurationObserver : object {
    private Action`1<IRetryConfigurator> _configure;
    public ScheduledRedeliveryHandlerConfigurationObserver(Action`1<IRetryConfigurator> configure);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<T> configurator);
}
public class MassTransit.Configuration.ScheduledRedeliveryPipeSpecification`1 : object {
    [CompilerGeneratedAttribute]
private RedeliveryOptions <Options>k__BackingField;
    public RedeliveryOptions Options { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.ScheduledRedeliveryPipeSpecification`1/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public sealed virtual RedeliveryOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Options(RedeliveryOptions value);
}
public class MassTransit.Configuration.ScheduledRedeliverySagaConfigurationObserver`1 : object {
    private ISagaConfigurator`1<TSaga> _configurator;
    private Action`1<IRetryConfigurator> _configure;
    public ScheduledRedeliverySagaConfigurationObserver`1(ISagaConfigurator`1<TSaga> configurator, Action`1<IRetryConfigurator> configure);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.ScopedCompensateActivityPipeSpecificationObserver : object {
    private IRegistrationContext _context;
    private Type _filterType;
    private CompositeFilter`1<Type> _messageTypeFilter;
    public ScopedCompensateActivityPipeSpecificationObserver(Type filterType, IRegistrationContext context, CompositeFilter`1<Type> messageTypeFilter);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
}
public class MassTransit.Configuration.ScopedConsumePipeSpecificationObserver : object {
    private IRegistrationContext _context;
    private Type _filterType;
    private CompositeFilter`1<Type> _messageTypeFilter;
    public ScopedConsumePipeSpecificationObserver(Type filterType, IRegistrationContext context, CompositeFilter`1<Type> messageTypeFilter);
    public sealed virtual void ConsumerConfigured(IConsumerConfigurator`1<TConsumer> configurator);
    public sealed virtual void ConsumerMessageConfigured(IConsumerMessageConfigurator`2<TConsumer, TMessage> configurator);
    public sealed virtual void SagaConfigured(ISagaConfigurator`1<TSaga> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    public sealed virtual void SagaMessageConfigured(ISagaMessageConfigurator`2<TSaga, TMessage> configurator);
    private void AddScopedFilter(IPipeConfigurator`1<ConsumeContext`1<TMessage>> messageConfigurator);
}
public class MassTransit.Configuration.ScopedExecuteActivityPipeSpecificationObserver : object {
    private IRegistrationContext _context;
    private Type _filterType;
    private CompositeFilter`1<Type> _messageTypeFilter;
    public ScopedExecuteActivityPipeSpecificationObserver(Type filterType, IRegistrationContext context, CompositeFilter`1<Type> messageTypeFilter);
    public sealed virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public sealed virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public sealed virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
}
public class MassTransit.Configuration.ScopedFilterSpecificationObserver : object {
    private Type _filterType;
    private CompositeFilter`1<Type> _messageTypeFilter;
    private IServiceProvider _provider;
    public ScopedFilterSpecificationObserver(Type filterType, IServiceProvider provider, CompositeFilter`1<Type> messageTypeFilter);
    public sealed virtual void MessageSpecificationCreated(IMessagePublishPipeSpecification`1<T> specification);
    public sealed virtual void MessageSpecificationCreated(IMessageSendPipeSpecification`1<T> specification);
    private void AddScopedFilter(IPipeConfigurator`1<TContext> configurator);
}
public class MassTransit.Configuration.SendMessageFilterConfigurator : object {
    [CompilerGeneratedAttribute]
private CompositeFilter`1<SendContext> <Filter>k__BackingField;
    public CompositeFilter`1<SendContext> Filter { get; }
    [CompilerGeneratedAttribute]
public CompositeFilter`1<SendContext> get_Filter();
    private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Include(Type[] messageTypes);
    private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Include(Func`2<Type, bool> filter);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Include();
    private sealed virtual override void MassTransit.IMessageFilterConfigurator.Include(Func`2<T, bool> filter);
    private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Exclude(Type[] messageTypes);
    private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Exclude(Func`2<Type, bool> filter);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IMessageTypeFilterConfigurator.Exclude();
    private sealed virtual override void MassTransit.IMessageFilterConfigurator.Exclude(Func`2<T, bool> filter);
    private static bool Match(SendContext context, Type[] messageTypes);
    private static bool Match(SendContext context);
    private static bool Match(SendContext context, Func`2<T, bool> filter);
}
public class MassTransit.Configuration.SendPipeConfiguration : object {
    private SendPipeSpecification _specification;
    public ISendPipeSpecification Specification { get; }
    public ISendPipeConfigurator Configurator { get; }
    public SendPipeConfiguration(ISendTopology sendTopology);
    public SendPipeConfiguration(ISendPipeSpecification parentSpecification);
    public sealed virtual ISendPipeSpecification get_Specification();
    public sealed virtual ISendPipeConfigurator get_Configurator();
    public sealed virtual ISendPipe CreatePipe();
}
public class MassTransit.Configuration.SendTransformSpecification`1 : TransformSpecification`1<TMessage> {
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.SendContext<TMessage>>.Apply(IPipeBuilder`1<SendContext`1<TMessage>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.SerializationConfiguration : object {
    private Lazy`1<ISerialization> _collection;
    private IDictionary`2<string, ISerializerFactory> _deserializers;
    private IDictionary`2<string, ISerializerFactory> _serializers;
    [NullableAttribute("2")]
private ContentType _defaultContentType;
    [NullableAttribute("2")]
private ContentType _serializerContentType;
    [NullableAttribute("2")]
private SerializationConfiguration _source;
    unknown ContentType DefaultContentType {public set; }
    unknown ContentType SerializerContentType {public set; }
    private SerializationConfiguration(SerializationConfiguration source);
    public sealed virtual void set_DefaultContentType(ContentType value);
    public sealed virtual void set_SerializerContentType(ContentType value);
    public sealed virtual void Clear();
    public sealed virtual void AddSerializer(ISerializerFactory factory, bool isSerializer);
    public sealed virtual void AddDeserializer(ISerializerFactory factory, bool isDefault);
    public sealed virtual ISerializationConfiguration CreateSerializationConfiguration();
    public sealed virtual ISerialization CreateSerializerCollection();
    [IteratorStateMachineAttribute("MassTransit.Configuration.SerializationConfiguration/<Validate>d__17")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private ISerialization CreateCollection();
    private void AddSystemTextJson();
    [CompilerGeneratedAttribute]
private ISerialization <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private ISerialization <.ctor>b__7_0();
}
public class MassTransit.Configuration.ServiceCollectionBusConfigurator : RegistrationConfigurator {
    public ServiceCollectionBusConfigurator(IServiceCollection collection);
    protected ServiceCollectionBusConfigurator(IServiceCollection collection, IContainerRegistrar registrar);
    [ObsoleteAttribute("Use 'Using[TransportName]' instead. Visit https://masstransit.io/obsolete for details.", "True")]
public virtual void AddBus(Func`2<IBusRegistrationContext, IBusControl> busFactory);
    public virtual void SetBusFactory(T busFactory);
    public virtual void AddRider(Action`1<IRiderRegistrationConfigurator> configure);
    public virtual void AddConfigureEndpointsCallback(ConfigureEndpointsCallback callback);
    public virtual void AddConfigureEndpointsCallback(ConfigureEndpointsProviderCallback callback);
    private static IBusInstance CreateBus(T busFactory, IServiceProvider provider);
    private static void AddMassTransitComponents(IServiceCollection collection);
    [CompilerGeneratedAttribute]
private IBusRegistrationContext <.ctor>g__CreateRegistrationContext|0_0(IServiceProvider provider);
    [CompilerGeneratedAttribute]
internal static Bind`2<IBus, IScopedConsumeContextProvider> <.ctor>g__CreateScopeProvider|0_1(IServiceProvider provider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Bind`2<IBus, IBusRegistrationContext> <.ctor>b__0_3(IServiceProvider provider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Bind`2<IBus, IClientFactory> <.ctor>b__0_6(IServiceProvider provider);
}
public class MassTransit.Configuration.ServiceCollectionBusConfigurator`2 : ServiceCollectionBusConfigurator {
    public ServiceCollectionBusConfigurator`2(IServiceCollection collection);
    [ObsoleteAttribute("This method is deprecated, please use 'Using[TransportName]' instead", "True")]
public virtual void AddBus(Func`2<IBusRegistrationContext, IBusControl> busFactory);
    public virtual void SetBusFactory(T busFactory);
    public virtual void AddRider(Action`1<IRiderRegistrationConfigurator> configure);
    public sealed virtual void AddRider(Action`1<IRiderRegistrationConfigurator`1<TBus>> configure);
    public virtual void AddConfigureEndpointsCallback(ConfigureEndpointsCallback callback);
    public virtual void AddConfigureEndpointsCallback(ConfigureEndpointsProviderCallback callback);
    private static IBusInstance`1<TBus> CreateBus(T busFactory, IServiceProvider provider);
    [CompilerGeneratedAttribute]
private IBusRegistrationContext <.ctor>g__CreateRegistrationContext|0_0(IServiceProvider provider);
    [CompilerGeneratedAttribute]
internal static Bind`2<TBus, IScopedConsumeContextProvider> <.ctor>g__CreateScopeProvider|0_1(IServiceProvider provider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Bind`2<TBus, IClientFactory> <.ctor>b__0_3(IServiceProvider provider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Bind`2<TBus, IBusRegistrationContext> <.ctor>b__0_7(IServiceProvider provider);
}
public class MassTransit.Configuration.ServiceCollectionMediatorConfigurator : RegistrationConfigurator {
    private Action`2<IMediatorRegistrationContext, IMediatorConfigurator> _configure;
    public ServiceCollectionMediatorConfigurator(IServiceCollection collection);
    public sealed virtual void ConfigureMediator(Action`2<IMediatorRegistrationContext, IMediatorConfigurator> configure);
    private static void AddMassTransitComponents(IServiceCollection collection);
    private IMediator MediatorFactory(IServiceProvider provider);
    [CompilerGeneratedAttribute]
private IMediatorRegistrationContext <.ctor>g__CreateRegistrationContext|1_0(IServiceProvider provider);
    [CompilerGeneratedAttribute]
internal static Bind`2<IMediator, IScopedConsumeContextProvider> <AddMassTransitComponents>g__CreateScopeProvider|3_2(IServiceProvider provider);
}
public class MassTransit.Configuration.ServiceCollectionRiderConfigurator : RegistrationConfigurator {
    public ServiceCollectionRiderConfigurator(IServiceCollection collection, IContainerRegistrar registrar);
    public virtual void TryAddScoped(Func`3<TRider, IServiceProvider, TService> factory);
    public virtual void SetRiderFactory(IRegistrationRiderFactory`1<TRider> riderFactory);
    protected void ThrowIfAlreadyConfigured(Type serviceType);
    [CompilerGeneratedAttribute]
internal static Bind`3<IBus, TRider, IScopedConsumeContextProvider> <SetRiderFactory>g__CreateScopeProvider|2_1(IServiceProvider provider);
}
public class MassTransit.Configuration.ServiceCollectionRiderConfigurator`1 : ServiceCollectionRiderConfigurator {
    public ServiceCollectionRiderConfigurator`1(IServiceCollection collection, IContainerRegistrar registrar);
    public virtual void TryAddScoped(Func`3<TRider, IServiceProvider, TService> factory);
    public virtual void SetRiderFactory(IRegistrationRiderFactory`1<TRider> riderFactory);
    [CompilerGeneratedAttribute]
internal static Bind`3<TBus, TRider, IScopedConsumeContextProvider> <SetRiderFactory>g__CreateScopeProvider|2_1(IServiceProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Configuration.ServiceInstanceConfigurator`1 : object {
    private ServiceInstanceOptions _options;
    [CompilerGeneratedAttribute]
private IReceiveConfigurator`1<TEndpointConfigurator> <BusConfigurator>k__BackingField;
    [CompilerGeneratedAttribute]
private TEndpointConfigurator <InstanceEndpointConfigurator>k__BackingField;
    public Uri InstanceAddress { get; }
    private IReceiveConfigurator MassTransit.IServiceInstanceConfigurator.BusConfigurator { get; }
    private IReceiveEndpointConfigurator MassTransit.IServiceInstanceConfigurator.InstanceEndpointConfigurator { get; }
    public IReceiveConfigurator`1<TEndpointConfigurator> BusConfigurator { get; }
    public TEndpointConfigurator InstanceEndpointConfigurator { get; }
    public IEndpointNameFormatter EndpointNameFormatter { get; }
    public ServiceInstanceConfigurator`1(IReceiveConfigurator`1<TEndpointConfigurator> configurator, ServiceInstanceOptions options, TEndpointConfigurator instanceEndpointConfigurator);
    public sealed virtual Uri get_InstanceAddress();
    private sealed virtual override IReceiveConfigurator MassTransit.IServiceInstanceConfigurator.get_BusConfigurator();
    private sealed virtual override IReceiveEndpointConfigurator MassTransit.IServiceInstanceConfigurator.get_InstanceEndpointConfigurator();
    [CompilerGeneratedAttribute]
public sealed virtual IReceiveConfigurator`1<TEndpointConfigurator> get_BusConfigurator();
    [CompilerGeneratedAttribute]
public sealed virtual TEndpointConfigurator get_InstanceEndpointConfigurator();
    public sealed virtual void AddSpecification(ISpecification specification);
    public sealed virtual IEndpointNameFormatter get_EndpointNameFormatter();
    public sealed virtual T Options(Action`1<T> configure);
    public sealed virtual T Options(T options, Action`1<T> configure);
    public sealed virtual bool TryGetOptions(T& options);
    public sealed virtual IEnumerable`1<T> SelectOptions();
    private sealed virtual override void MassTransit.IReceiveConfigurator.ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<TEndpointConfigurator> configureEndpoint);
    private sealed virtual override void MassTransit.IReceiveConfigurator.ReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void ReceiveEndpoint(string queueName, Action`1<TEndpointConfigurator> configureEndpoint);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
}
public class MassTransit.Configuration.SetCorrelationIdSelector`1 : object {
    private IMessageCorrelationId`1<T> _messageCorrelationId;
    public SetCorrelationIdSelector`1(IMessageCorrelationId`1<T> messageCorrelationId);
    public sealed virtual bool TryGetSetCorrelationId(IMessageCorrelationId`1& messageCorrelationId);
}
public class MassTransit.Configuration.SetPartitionKeyMessageSendTopology`1 : object {
    private IFilter`1<SendContext`1<TMessage>> _filter;
    public SetPartitionKeyMessageSendTopology`1(IMessagePartitionKeyFormatter`1<TMessage> partitionKeyFormatter);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<SendContext`1<TMessage>> builder);
}
public class MassTransit.Configuration.SetRoutingKeyMessageSendTopology`1 : object {
    private IFilter`1<SendContext`1<TMessage>> _filter;
    public SetRoutingKeyMessageSendTopology`1(IMessageRoutingKeyFormatter`1<TMessage> routingKeyFormatter);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<SendContext`1<TMessage>> builder);
}
public class MassTransit.Configuration.SetSerializerMessageSendTopologyConvention`1 : object {
    private ContentType _contentType;
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention.TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention<TMessage>.TryGetMessageSendTopology(IMessageSendTopology`1& messageSendTopology);
    public sealed virtual void SetSerializer(ContentType contentType);
}
internal class MassTransit.Configuration.StateMachineEventActivitiesBuilder`1 : object {
    private List`1<EventActivities`1<TInstance>> _activities;
    private Action`1<EventActivities`1[]> _committer;
    private MassTransitStateMachine`1<TInstance> _machine;
    private IStateMachineModifier`1<TInstance> _modifier;
    [CompilerGeneratedAttribute]
private bool <IsCommitted>k__BackingField;
    public bool IsCommitted { get; private set; }
    public State Initial { get; }
    public State Final { get; }
    public StateMachineEventActivitiesBuilder`1(MassTransitStateMachine`1<TInstance> machine, IStateMachineModifier`1<TInstance> modifier, Action`1<EventActivities`1[]> committer);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCommitted();
    [CompilerGeneratedAttribute]
private void set_IsCommitted(bool value);
    public sealed virtual State get_Initial();
    public sealed virtual State get_Final();
    public sealed virtual IStateMachineModifier`1<TInstance> CommitActivities();
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> When(Event event, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> configure);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> When(Event event, StateMachineCondition`1<TInstance> filter, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> configure);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> When(Event`1<TData> event, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> configure);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> When(Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> configure);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> Ignore(Event event);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> Ignore(Event`1<TData> event);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> Ignore(Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter);
    public sealed virtual void Apply();
    public sealed virtual IStateMachineModifier`1<TInstance> AfterLeave(State state, Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> AfterLeaveAny(Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> BeforeEnter(State state, Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> BeforeEnterAny(Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> CompositeEvent(string name, Event& event, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    public sealed virtual IStateMachineModifier`1<TInstance> CompositeEvent(string name, Event& event, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public sealed virtual IStateMachineModifier`1<TInstance> CompositeEvent(string name, Event& event, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, Event[] events);
    public sealed virtual IStateMachineModifier`1<TInstance> CompositeEvent(string name, Event& event, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> During(State[] states);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> DuringAny();
    public sealed virtual IStateMachineModifier`1<TInstance> Event(string name, Event& event);
    public sealed virtual IStateMachineModifier`1<TInstance> Event(string name, Event`1& event);
    public sealed virtual IStateMachineModifier`1<TInstance> Event(string name, Action`1<IEventCorrelationConfigurator`2<TInstance, T>> configure, Event`1& event);
    public sealed virtual IStateMachineModifier`1<TInstance> Event(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, Event`1<T>>> eventPropertyExpression);
    public sealed virtual IStateMachineModifier`1<TInstance> Finally(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TInstance> Initially();
    public sealed virtual IStateMachineModifier`1<TInstance> InstanceState(Expression`1<Func`2<TInstance, State>> instanceStateProperty);
    public sealed virtual IStateMachineModifier`1<TInstance> InstanceState(Expression`1<Func`2<TInstance, string>> instanceStateProperty);
    public sealed virtual IStateMachineModifier`1<TInstance> InstanceState(Expression`1<Func`2<TInstance, int>> instanceStateProperty, State[] states);
    public sealed virtual IStateMachineModifier`1<TInstance> Name(string machineName);
    public sealed virtual IStateMachineModifier`1<TInstance> OnUnhandledEvent(UnhandledEventCallback`1<TInstance> callback);
    public sealed virtual IStateMachineModifier`1<TInstance> State(string name, State`1& state);
    public sealed virtual IStateMachineModifier`1<TInstance> State(string name, State& state);
    public sealed virtual IStateMachineModifier`1<TInstance> State(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression);
    public sealed virtual IStateMachineModifier`1<TInstance> SubState(string name, State superState, State`1& subState);
    public sealed virtual IStateMachineModifier`1<TInstance> SubState(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression, State superState);
    public sealed virtual IStateMachineModifier`1<TInstance> WhenEnter(State state, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> WhenEnterAny(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> WhenLeave(State state, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TInstance> WhenLeaveAny(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
}
public class MassTransit.Configuration.StateMachineInterfaceType`2 : object {
    private ISagaConnectorFactory _connectorFactory;
    public StateMachineInterfaceType`2(SagaStateMachine`1<TInstance> machine, EventCorrelation`2<TInstance, TData> correlation);
    private sealed virtual override ISagaMessageConnector`1<T> MassTransit.Configuration.IStateMachineInterfaceType.GetConnector();
}
internal class MassTransit.Configuration.StateMachineModifier`1 : object {
    private List`1<IStateMachineEventActivitiesBuilder`1<TSaga>> _activityBuilders;
    private MassTransitStateMachine`1<TSaga> _machine;
    public State Initial { get; }
    public State Final { get; }
    public StateMachineModifier`1(MassTransitStateMachine`1<TSaga> machine);
    public sealed virtual State get_Initial();
    public sealed virtual State get_Final();
    public sealed virtual void Apply();
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TSaga> During(State[] states);
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TSaga> DuringAny();
    public sealed virtual IStateMachineEventActivitiesBuilder`1<TSaga> Initially();
    public sealed virtual IStateMachineModifier`1<TSaga> AfterLeave(State state, Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> AfterLeaveAny(Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> BeforeEnter(State state, Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> BeforeEnterAny(Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    public sealed virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public sealed virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, int>> trackingPropertyExpression, Event[] events);
    public sealed virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public sealed virtual IStateMachineModifier`1<TSaga> Event(string name, Event& event);
    public sealed virtual IStateMachineModifier`1<TSaga> Event(string name, Event`1& event);
    public sealed virtual IStateMachineModifier`1<TSaga> Event(string name, Action`1<IEventCorrelationConfigurator`2<TSaga, T>> configure, Event`1& event);
    public sealed virtual IStateMachineModifier`1<TSaga> Event(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, Event`1<T>>> eventPropertyExpression);
    public sealed virtual IStateMachineModifier`1<TSaga> Finally(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, State>> instanceStateProperty);
    public sealed virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, string>> instanceStateProperty);
    public sealed virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, int>> instanceStateProperty, State[] states);
    public sealed virtual IStateMachineModifier`1<TSaga> Name(string machineName);
    public sealed virtual IStateMachineModifier`1<TSaga> OnUnhandledEvent(UnhandledEventCallback`1<TSaga> callback);
    public sealed virtual IStateMachineModifier`1<TSaga> State(string name, State`1& state);
    public sealed virtual IStateMachineModifier`1<TSaga> State(string name, State& state);
    public sealed virtual IStateMachineModifier`1<TSaga> State(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression);
    public sealed virtual IStateMachineModifier`1<TSaga> SubState(string name, State superState, State`1& subState);
    public sealed virtual IStateMachineModifier`1<TSaga> SubState(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression, State superState);
    public sealed virtual IStateMachineModifier`1<TSaga> WhenEnter(State state, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> WhenEnterAny(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> WhenLeave(State state, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public sealed virtual IStateMachineModifier`1<TSaga> WhenLeaveAny(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, int>> instanceStateProperty, String[] stateNames);
    [CompilerGeneratedAttribute]
private void <DuringAny>b__9_0(EventActivities`1[] activities);
    [CompilerGeneratedAttribute]
private void <Initially>b__10_0(EventActivities`1[] activities);
    [CompilerGeneratedAttribute]
private State`1<TSaga> <InstanceState>b__38_0(string name);
}
public class MassTransit.Configuration.StateMachineRequestConfigurator`3 : object {
    [CompilerGeneratedAttribute]
private Uri <ServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse>> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEventCorrelationConfigurator`2<TInstance, Fault`1<TRequest>>> <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEventCorrelationConfigurator`2<TInstance, RequestTimeoutExpired`1<TRequest>>> <TimeoutExpired>k__BackingField;
    public RequestSettings`3<TInstance, TRequest, TResponse> Settings { get; }
    public Uri ServiceAddress { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public Nullable`1<TimeSpan> TimeToLive { get; public set; }
    public Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse>> Completed { get; public set; }
    public Action`1<IEventCorrelationConfigurator`2<TInstance, Fault`1<TRequest>>> Faulted { get; public set; }
    public Action`1<IEventCorrelationConfigurator`2<TInstance, RequestTimeoutExpired`1<TRequest>>> TimeoutExpired { get; public set; }
    public RequestSettings`3<TInstance, TRequest, TResponse> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ServiceAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServiceAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_TimeToLive();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeToLive(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse>> get_Completed();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Completed(Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IEventCorrelationConfigurator`2<TInstance, Fault`1<TRequest>>> get_Faulted();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Faulted(Action`1<IEventCorrelationConfigurator`2<TInstance, Fault`1<TRequest>>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IEventCorrelationConfigurator`2<TInstance, RequestTimeoutExpired`1<TRequest>>> get_TimeoutExpired();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutExpired(Action`1<IEventCorrelationConfigurator`2<TInstance, RequestTimeoutExpired`1<TRequest>>> value);
}
public class MassTransit.Configuration.StateMachineRequestConfigurator`4 : StateMachineRequestConfigurator`3<TInstance, TRequest, TResponse> {
    [CompilerGeneratedAttribute]
private Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse2>> <Completed2>k__BackingField;
    public RequestSettings`4<TInstance, TRequest, TResponse, TResponse2> Settings { get; }
    public Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse2>> Completed2 { get; public set; }
    public RequestSettings`4<TInstance, TRequest, TResponse, TResponse2> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse2>> get_Completed2();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Completed2(Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse2>> value);
}
public class MassTransit.Configuration.StateMachineRequestConfigurator`5 : StateMachineRequestConfigurator`4<TInstance, TRequest, TResponse, TResponse2> {
    [CompilerGeneratedAttribute]
private Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse3>> <Completed3>k__BackingField;
    public RequestSettings`5<TInstance, TRequest, TResponse, TResponse2, TResponse3> Settings { get; }
    public Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse3>> Completed3 { get; public set; }
    public RequestSettings`5<TInstance, TRequest, TResponse, TResponse2, TResponse3> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse3>> get_Completed3();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Completed3(Action`1<IEventCorrelationConfigurator`2<TInstance, TResponse3>> value);
}
public class MassTransit.Configuration.StateMachineScheduleConfigurator`2 : object {
    private Action`1<IEventCorrelationConfigurator`2<TInstance, TMessage>> _received;
    [CompilerGeneratedAttribute]
private ScheduleDelayProvider`1<TInstance> <DelayProvider>k__BackingField;
    public ScheduleSettings`2<TInstance, TMessage> Settings { get; }
    unknown TimeSpan Delay {public set; }
    public ScheduleDelayProvider`1<TInstance> DelayProvider { get; public set; }
    unknown Action`1<IEventCorrelationConfigurator`2<TInstance, TMessage>> MassTransit.IScheduleConfigurator<TInstance,TMessage>.Received {private set; }
    private Action`1<IEventCorrelationConfigurator`2<TInstance, TMessage>> MassTransit.ScheduleSettings<TInstance,TMessage>.Received { get; }
    public ScheduleSettings`2<TInstance, TMessage> get_Settings();
    public sealed virtual void set_Delay(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual ScheduleDelayProvider`1<TInstance> get_DelayProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DelayProvider(ScheduleDelayProvider`1<TInstance> value);
    private sealed virtual override void MassTransit.IScheduleConfigurator<TInstance,TMessage>.set_Received(Action`1<IEventCorrelationConfigurator`2<TInstance, TMessage>> value);
    private sealed virtual override Action`1<IEventCorrelationConfigurator`2<TInstance, TMessage>> MassTransit.ScheduleSettings<TInstance,TMessage>.get_Received();
}
public class MassTransit.Configuration.SystemTextJsonMessageSerializerFactory : object {
    private Lazy`1<SystemTextJsonMessageSerializer> _serializer;
    public ContentType ContentType { get; }
    public sealed virtual ContentType get_ContentType();
    public sealed virtual IMessageSerializer CreateSerializer();
    public sealed virtual IMessageDeserializer CreateDeserializer();
}
public class MassTransit.Configuration.SystemTextJsonRawMessageSerializerFactory : object {
    private Lazy`1<SystemTextJsonRawMessageSerializer> _serializer;
    public ContentType ContentType { get; }
    public SystemTextJsonRawMessageSerializerFactory(RawSerializerOptions options);
    public sealed virtual ContentType get_ContentType();
    public sealed virtual IMessageSerializer CreateSerializer();
    public sealed virtual IMessageDeserializer CreateDeserializer();
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Configuration.TestHarnessRegistrationConfigurator : object {
    private IBusRegistrationConfigurator _configurator;
    [CompilerGeneratedAttribute]
private bool <UseDefaultBusFactory>k__BackingField;
    public bool UseDefaultBusFactory { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ServiceDescriptor Item { get; public set; }
    public IContainerRegistrar Registrar { get; }
    public TestHarnessRegistrationConfigurator(IBusRegistrationConfigurator configurator);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultBusFactory();
    [CompilerGeneratedAttribute]
private void set_UseDefaultBusFactory(bool value);
    public sealed virtual IEnumerator`1<ServiceDescriptor> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(ServiceDescriptor item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ServiceDescriptor item);
    public sealed virtual void CopyTo(ServiceDescriptor[] array, int arrayIndex);
    public sealed virtual bool Remove(ServiceDescriptor item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(ServiceDescriptor item);
    public sealed virtual void Insert(int index, ServiceDescriptor item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ServiceDescriptor get_Item(int index);
    public sealed virtual void set_Item(int index, ServiceDescriptor value);
    public sealed virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public sealed virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Type consumerDefinitionType, Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSaga(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSaga(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public sealed virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Type executeActivityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public sealed virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public sealed virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Type activityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public sealed virtual void AddEndpoint(Type endpointDefinition);
    public sealed virtual void AddEndpoint(IRegistration registration, IEndpointSettings`1<IEndpointDefinition`1<T>> settings);
    public sealed virtual void AddRequestClient(RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Type requestType, RequestTimeout timeout);
    public sealed virtual void AddRequestClient(Type requestType, Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual void SetDefaultRequestTimeout(RequestTimeout timeout);
    public sealed virtual void SetDefaultRequestTimeout(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public sealed virtual void SetEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    public sealed virtual ISagaRegistrationConfigurator`1<T> AddSagaRepository();
    public sealed virtual void SetSagaRepositoryProvider(ISagaRepositoryRegistrationProvider provider);
    public sealed virtual IFutureRegistrationConfigurator`1<TFuture> AddFuture(Type futureDefinitionType);
    public sealed virtual void AddConfigureEndpointsCallback(ConfigureEndpointsCallback callback);
    public sealed virtual void AddConfigureEndpointsCallback(ConfigureEndpointsProviderCallback callback);
    public sealed virtual IContainerRegistrar get_Registrar();
    [ObsoleteAttribute("Use 'Using[TransportName]' instead. Visit https://masstransit.io/obsolete for details.")]
public sealed virtual void AddBus(Func`2<IBusRegistrationContext, IBusControl> busFactory);
    public sealed virtual void SetBusFactory(T busFactory);
    public sealed virtual void AddRider(Action`1<IRiderRegistrationConfigurator> configure);
}
public class MassTransit.Configuration.TimeoutConfigurationObserver : ConfigurationObserver {
    private Action`1<ITimeoutConfigurator> _configure;
    public TimeoutConfigurationObserver(IConsumePipeConfigurator configurator, Action`1<ITimeoutConfigurator> configure);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void BatchConsumerConfigured(IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>> configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Configuration.TimeoutConsumerConfigurationObserver`1 : object {
    private IConsumerConfigurator`1<TConsumer> _configurator;
    private Action`1<ITimeoutConfigurator> _configure;
    public TimeoutConsumerConfigurationObserver`1(IConsumerConfigurator`1<TConsumer> configurator, Action`1<ITimeoutConfigurator> configure);
    private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerConfigured(IConsumerConfigurator`1<T> configurator);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.IConsumerConfigurationObserver.ConsumerMessageConfigured(IConsumerMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.TimeoutHandlerConfigurationObserver : object {
    private Action`1<ITimeoutConfigurator> _configure;
    public TimeoutHandlerConfigurationObserver(Action`1<ITimeoutConfigurator> configure);
    private sealed virtual override void MassTransit.IHandlerConfigurationObserver.HandlerConfigured(IHandlerConfigurator`1<T> configurator);
}
public class MassTransit.Configuration.TimeoutSagaConfigurationObserver`1 : object {
    private ISagaConfigurator`1<TSaga> _configurator;
    private Action`1<ITimeoutConfigurator> _configure;
    public TimeoutSagaConfigurationObserver`1(ISagaConfigurator`1<TSaga> configurator, Action`1<ITimeoutConfigurator> configure);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaConfigured(ISagaConfigurator`1<T> configurator);
    public sealed virtual void StateMachineSagaConfigured(ISagaConfigurator`1<TInstance> configurator, SagaStateMachine`1<TInstance> stateMachine);
    [NullableContextAttribute("1")]
private sealed virtual override void MassTransit.ISagaConfigurationObserver.SagaMessageConfigured(ISagaMessageConfigurator`2<T, TMessage> configurator);
}
public class MassTransit.Configuration.TimeoutSpecification`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public TimeSpan Timeout { get; public set; }
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext`1<T>> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.TimeoutSpecification`1/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timeout(TimeSpan value);
    private static TimeoutConsumeContext`1<T> Factory(ConsumeContext`1<T> context, CancellationToken cancellationToken);
}
public class MassTransit.Configuration.TopologyConventionCache`1 : object {
    private ConcurrentDictionary`2<Type, Cached<TValue>> _dictionary;
    private IConventionTypeFactory`1<TValue> _typeFactory;
    public TopologyConventionCache`1(Type genericType, IConventionTypeFactory`1<TValue> typeFactory);
    private sealed virtual override TResult MassTransit.Configuration.ITopologyConventionCache<TValue>.GetOrAdd();
    [CompilerGeneratedAttribute]
private Cached<TValue> <MassTransit.Configuration.ITopologyConventionCache<TValue>.GetOrAdd>b__3_0(Type add);
    [CompilerGeneratedAttribute]
private TValue <MassTransit.Configuration.ITopologyConventionCache<TValue>.GetOrAdd>b__3_1();
}
public class MassTransit.Configuration.TransactionPipeSpecification`1 : object {
    private IsolationLevel _isolationLevel;
    private TimeSpan _timeout;
    unknown TimeSpan Timeout {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("MassTransit.Configuration.TransactionPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void set_Timeout(TimeSpan value);
    public sealed virtual void set_IsolationLevel(IsolationLevel value);
}
public abstract class MassTransit.Configuration.TransformSpecification`1 : object {
    private MessageTransformConvention`1<TMessage> _convention;
    [CompilerGeneratedAttribute]
private bool <Replace>k__BackingField;
    public int Count { get; }
    public bool Replace { get; public set; }
    public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_Replace();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Replace(bool value);
    public sealed virtual void Default(Expression`1<Func`2<TMessage, TProperty>> propertyExpression);
    public sealed virtual void Set(Expression`1<Func`2<TMessage, TProperty>> propertyExpression, TProperty value);
    public sealed virtual void Set(Expression`1<Func`2<TMessage, TProperty>> propertyExpression, Func`2<TransformPropertyContext`2<TProperty, TMessage>, TProperty> valueProvider);
    public sealed virtual void Set(PropertyInfo propertyInfo, IPropertyProvider`2<TMessage, TProperty> propertyProvider);
    public sealed virtual void Transform(PropertyInfo propertyInfo, IPropertyProvider`2<TMessage, TProperty> propertyProvider);
    [IteratorStateMachineAttribute("MassTransit.Configuration.TransformSpecification`1/<Validate>d__13")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    protected IMessageInitializer`1<TMessage> Build();
}
public class MassTransit.Configuration.TransformSpecificationConfigurator`1 : object {
    public sealed virtual IConsumeTransformSpecification`1<TMessage> Get();
    public sealed virtual IConsumeTransformSpecification`1<TMessage> Get(Func`1<T> transformFactory);
}
public class MassTransit.Configuration.TransportConfiguration : object {
    private ITransportConfiguration _parent;
    private Nullable`1<int> _concurrentMessageLimit;
    private Nullable`1<int> _prefetchCount;
    public ITransportConfigurator Configurator { get; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    public TransportConfiguration(ITransportConfiguration parent);
    public sealed virtual ITransportConfigurator get_Configurator();
    public sealed virtual int get_PrefetchCount();
    public sealed virtual void set_PrefetchCount(int value);
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    public sealed virtual int GetConcurrentMessageLimit();
    [IteratorStateMachineAttribute("MassTransit.Configuration.TransportConfiguration/<Validate>d__14")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public abstract class MassTransit.Configuration.TransportRegistrationBusFactory`1 : object {
    private IHostConfiguration _hostConfiguration;
    protected TransportRegistrationBusFactory`1(IHostConfiguration hostConfiguration);
    public abstract virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
    protected IBusInstance CreateBus(T configurator, IBusRegistrationContext context, Action`2<IBusRegistrationContext, TConfigurator> configure, IEnumerable`1<IBusInstanceSpecification> specifications);
    private static void ConnectBusObservers(IServiceProvider context, IBusObserverConnector connector);
    private static void ConnectReceiveEndpointObservers(IServiceProvider context, IReceiveEndpointObserverConnector connector);
    private static void ConnectReceiveObservers(IServiceProvider context, IReceiveObserverConnector connector);
    private static void ConnectConsumeObservers(IServiceProvider context, IConsumeObserverConnector connector);
    private static void ConnectSendObservers(IServiceProvider context, ISendObserverConnector connector);
    private static void ConnectPublishObservers(IServiceProvider context, IPublishObserverConnector connector);
    protected virtual IBusInstance CreateBusInstance(IBusControl bus, IHost`1<TEndpointConfigurator> host, IHostConfiguration hostConfiguration, IBusRegistrationContext context);
}
public class MassTransit.Configuration.UntypedConsumerConfigurator`1 : object {
    private IConsumerFactory`1<TConsumer> _consumerFactory;
    private IConsumerSpecification`1<TConsumer> _specification;
    unknown Nullable`1<int> ConcurrentMessageLimit {public set; }
    public UntypedConsumerConfigurator`1(Func`2<Type, object> consumerFactory, IConsumerConfigurationObserver observer);
    public sealed virtual ConnectHandle ConnectConsumerConfigurationObserver(IConsumerConfigurationObserver observer);
    public sealed virtual void set_ConcurrentMessageLimit(Nullable`1<int> value);
    [IteratorStateMachineAttribute("MassTransit.Configuration.UntypedConsumerConfigurator`1/<Validate>d__6")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Configure(IReceiveEndpointBuilder builder);
}
public class MassTransit.ConfigureEndpointsCallback : MulticastDelegate {
    public ConfigureEndpointsCallback(object object, IntPtr method);
    public virtual void Invoke(string queueName, IReceiveEndpointConfigurator configurator);
    public virtual IAsyncResult BeginInvoke(string queueName, IReceiveEndpointConfigurator configurator, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class MassTransit.ConfigureEndpointsProviderCallback : MulticastDelegate {
    public ConfigureEndpointsProviderCallback(object object, IntPtr method);
    public virtual void Invoke(IRegistrationContext context, string queueName, IReceiveEndpointConfigurator configurator);
    public virtual IAsyncResult BeginInvoke(IRegistrationContext context, string queueName, IReceiveEndpointConfigurator configurator, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class MassTransit.ConsumeContextActivatorExtensions : object {
    [ExtensionAttribute]
public static T GetServiceOrCreateInstance(ConsumeContext context);
    [ExtensionAttribute]
public static T CreateInstance(ConsumeContext context, Object[] arguments);
}
[ExtensionAttribute]
public static class MassTransit.ConsumeContextEndpointExtensions : object {
    [ExtensionAttribute]
public static Task`1<ISendEndpoint> GetFaultEndpoint(ConsumeContext context);
    [ExtensionAttribute]
public static Task`1<ISendEndpoint> GetFaultEndpoint(ConsumeContext context, Uri faultAddress, Nullable`1<Guid> requestId);
    [ExtensionAttribute]
public static Task`1<ISendEndpoint> GetReceiveFaultEndpoint(ReceiveContext context, ConsumeContext consumeContext, Nullable`1<Guid> requestId);
    [ExtensionAttribute]
public static Task`1<ISendEndpoint> GetResponseEndpoint(ConsumeContext context);
    [ExtensionAttribute]
public static Task`1<ISendEndpoint> GetResponseEndpoint(ConsumeContext context, Uri responseAddress, Nullable`1<Guid> requestId);
    private static Task`1<ISendEndpoint> GetEndpoint(ReceiveContext receiveContext, ConsumeContext consumeContext, Uri destinationAddress, Nullable`1<Guid> requestId);
    [ExtensionAttribute]
internal static Task`1<ISendEndpoint> GetPublishEndpoint(IPublishEndpointProvider publishEndpointProvider, ConsumeContext consumeContext, Nullable`1<Guid> requestId);
    [ExtensionAttribute]
internal static Task`1<ISendEndpoint> GetSendEndpoint(ISendEndpointProvider sendEndpointProvider, ConsumeContext consumeContext, Uri destinationAddress, Nullable`1<Guid> requestId);
}
public class MassTransit.Consumer.DefaultConstructorConsumerFactory`1 : object {
    [AsyncStateMachineAttribute("MassTransit.Consumer.DefaultConstructorConsumerFactory`1/<Send>d__0`1")]
public sealed virtual Task Send(ConsumeContext`1<T> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, T>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Consumer.DelegateConsumerFactory`1 : object {
    private Func`1<TConsumer> _factoryMethod;
    public DelegateConsumerFactory`1(Func`1<TConsumer> factoryMethod);
    [AsyncStateMachineAttribute("MassTransit.Consumer.DelegateConsumerFactory`1/<Send>d__2`1")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Consumer.InstanceConsumerFactory`1 : object {
    private TConsumer _consumer;
    public InstanceConsumerFactory`1(TConsumer consumer);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Consumer.ObjectConsumerFactory`1 : object {
    private IConsumerFactory`1<TConsumer> _delegate;
    public ObjectConsumerFactory`1(Func`2<Type, object> objectFactory);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public static class MassTransit.ConsumerConvention : object {
    public static bool Register();
    public static bool Register(T convention);
    public static void Remove();
}
[ExtensionAttribute]
public static class MassTransit.ConsumerExtensions : object {
    [ExtensionAttribute]
public static void Consumer(IReceiveEndpointConfigurator configurator, IConsumerFactory`1<TConsumer> consumerFactory, Action`1<IConsumerConfigurator`1<TConsumer>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, IConsumerFactory`1<TConsumer> consumerFactory, IPipeSpecification`1[] pipeSpecifications);
    [ExtensionAttribute]
public static void Consumer(IReceiveEndpointConfigurator configurator, Action`1<IConsumerConfigurator`1<TConsumer>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, IPipeSpecification`1[] pipeSpecifications);
    [ExtensionAttribute]
public static void Consumer(IReceiveEndpointConfigurator configurator, Func`1<TConsumer> consumerFactoryMethod, Action`1<IConsumerConfigurator`1<TConsumer>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, Func`1<TConsumer> consumerFactoryMethod, IPipeSpecification`1[] pipeSpecifications);
    [ExtensionAttribute]
public static void Consumer(IReceiveEndpointConfigurator configurator, Type consumerType, Func`2<Type, object> consumerFactory);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, Type consumerType, Func`2<Type, object> objectFactory);
}
[ExtensionAttribute]
public static class MassTransit.ConsumerPipeConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseFilter(IPipeConfigurator`1<ConsumerConsumeContext`2<TConsumer, T>> configurator, IFilter`1<ConsumerConsumeContext`1<TConsumer>> filter);
}
public class MassTransit.ConsumeTopology : object {
    private List`1<IMessageConsumeTopologyConvention> _conventions;
    private object _lock;
    private int _maxQueueNameLength;
    private ConcurrentDictionary`2<Type, Lazy`1<IMessageConsumeTopologyConfigurator>> _messageTypes;
    private ConcurrentDictionary`2<Type, IMessageTypeSelector> _messageTypeSelectorCache;
    private ConsumeTopologyConfigurationObservable _observers;
    protected ConsumeTopology(int maxQueueNameLength);
    private sealed virtual override void MassTransit.Configuration.IConsumeTopologyConfigurationObserver.MessageTopologyCreated(IMessageConsumeTopologyConfigurator`1<T> messageTopology);
    private sealed virtual override IMessageConsumeTopology`1<T> MassTransit.IConsumeTopology.GetMessageTopology();
    private sealed virtual override IMessageConsumeTopologyConfigurator`1<T> MassTransit.IConsumeTopologyConfigurator.GetMessageTopology();
    public sealed virtual IMessageConsumeTopologyConfigurator GetMessageTopology(Type messageType);
    public virtual string CreateTemporaryQueueName(string tag);
    public sealed virtual ConnectHandle ConnectConsumeTopologyConfigurationObserver(IConsumeTopologyConfigurationObserver observer);
    public sealed virtual bool TryAddConvention(IConsumeTopologyConvention convention);
    public virtual IEnumerable`1<ValidationResult> Validate();
    private static string ShrinkToFit(string inputName, int maxLength);
    protected IMessageConsumeTopologyConfigurator`1<T> GetMessageTopology();
    protected bool All(Func`2<IMessageConsumeTopologyConfigurator, bool> callback);
    protected IEnumerable`1<TResult> SelectMany(Func`2<T, IEnumerable`1<TResult>> selector);
    protected void ForEach(Action`1<T> callback);
    protected virtual IMessageConsumeTopologyConfigurator CreateMessageTopology();
    protected void OnMessageTopologyCreated(IMessageConsumeTopologyConfigurator`1<T> messageTopology);
    private void ApplyConventionsToMessageTopology(IMessageConsumeTopologyConfigurator`1<T> messageTopology);
    [CompilerGeneratedAttribute]
private Lazy`1<IMessageConsumeTopologyConfigurator> <GetMessageTopology>b__16_0(Type _);
    [CompilerGeneratedAttribute]
private IMessageConsumeTopologyConfigurator <GetMessageTopology>b__16_1();
}
[ExtensionAttribute]
public static class MassTransit.ContainerActivityExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Activity(EventActivityBinder`2<TInstance, TData> binder, Func`2<IStateMachineActivitySelector`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> configure);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Activity(EventActivityBinder`1<TInstance> binder, Func`2<IStateMachineActivitySelector`1<TInstance>, EventActivityBinder`1<TInstance>> configure);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Activity(ExceptionActivityBinder`2<TInstance, TException> binder, Func`2<IStateMachineFaultedActivitySelector`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> configure);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TMessage, TException> Activity(ExceptionActivityBinder`3<TInstance, TMessage, TException> binder, Func`2<IStateMachineFaultedActivitySelector`3<TInstance, TMessage, TException>, ExceptionActivityBinder`3<TInstance, TMessage, TException>> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Context.BaseConsumeContext : PublishEndpoint {
    [CompilerGeneratedAttribute]
private ReceiveContext <ReceiveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializerContext <SerializerContext>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public ReceiveContext ReceiveContext { get; protected set; }
    public SerializerContext SerializerContext { get; }
    public Task ConsumeCompleted { get; }
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public IEnumerable`1<string> SupportedMessageTypes { get; }
    protected BaseConsumeContext(ReceiveContext receiveContext, SerializerContext serializerContext);
    public virtual CancellationToken get_CancellationToken();
    public abstract virtual bool HasPayloadType(Type payloadType);
    public abstract virtual bool TryGetPayload(T& payload);
    public abstract virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public abstract virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
    [CompilerGeneratedAttribute]
public sealed virtual ReceiveContext get_ReceiveContext();
    [CompilerGeneratedAttribute]
protected void set_ReceiveContext(ReceiveContext value);
    [CompilerGeneratedAttribute]
public sealed virtual SerializerContext get_SerializerContext();
    public abstract virtual Task get_ConsumeCompleted();
    public abstract virtual Nullable`1<Guid> get_MessageId();
    public abstract virtual Nullable`1<Guid> get_RequestId();
    public abstract virtual Nullable`1<Guid> get_CorrelationId();
    public abstract virtual Nullable`1<Guid> get_ConversationId();
    public abstract virtual Nullable`1<Guid> get_InitiatorId();
    public abstract virtual Nullable`1<DateTime> get_ExpirationTime();
    public abstract virtual Uri get_SourceAddress();
    public abstract virtual Uri get_DestinationAddress();
    public abstract virtual Uri get_ResponseAddress();
    public abstract virtual Uri get_FaultAddress();
    public abstract virtual Nullable`1<DateTime> get_SentTime();
    public abstract virtual Headers get_Headers();
    public abstract virtual HostInfo get_Host();
    public abstract virtual IEnumerable`1<string> get_SupportedMessageTypes();
    public abstract virtual bool HasMessageType(Type messageType);
    public abstract virtual bool TryGetMessage(ConsumeContext`1& consumeContext);
    public virtual Task RespondAsync(T message);
    public virtual Task RespondAsync(T message, IPipe`1<SendContext`1<T>> sendPipe);
    public virtual Task RespondAsync(T message, IPipe`1<SendContext> sendPipe);
    public virtual Task RespondAsync(object message);
    public virtual Task RespondAsync(object message, Type messageType);
    public virtual Task RespondAsync(object message, IPipe`1<SendContext> sendPipe);
    public virtual Task RespondAsync(object message, Type messageType, IPipe`1<SendContext> sendPipe);
    public virtual Task RespondAsync(object values);
    public virtual Task RespondAsync(object values, IPipe`1<SendContext`1<T>> sendPipe);
    public virtual Task RespondAsync(object values, IPipe`1<SendContext> sendPipe);
    public virtual void Respond(T message);
    [AsyncStateMachineAttribute("MassTransit.Context.BaseConsumeContext/<GetSendEndpoint>d__57")]
public virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    [AsyncStateMachineAttribute("MassTransit.Context.BaseConsumeContext/<NotifyFaulted>d__59`1")]
public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public abstract virtual void AddConsumeTask(Task task);
    private Task RespondInternal(T message, IPipe`1<SendContext`1<T>> pipe);
    private Task RespondInternal(object values, IPipe`1<SendContext`1<T>> pipe);
    [AsyncStateMachineAttribute("MassTransit.Context.BaseConsumeContext/<GenerateFault>d__64`1")]
protected virtual Task GenerateFault(ConsumeContext`1<T> context, Exception exception);
    private Task ConsumeTask(Task task);
    [AsyncStateMachineAttribute("MassTransit.Context.BaseConsumeContext/<GetPublishSendEndpoint>d__66`1")]
protected virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ISendEndpoint> <>n__0();
}
public abstract class MassTransit.Context.BaseCourierContext : ConsumeContextScope`1<RoutingSlip> {
    private Guid _executionId;
    private Stopwatch _timer;
    private DateTime _timestamp;
    [CompilerGeneratedAttribute]
private IRoutingSlipEventPublisher <Publisher>k__BackingField;
    [CompilerGeneratedAttribute]
private SanitizedRoutingSlip <RoutingSlip>k__BackingField;
    protected IRoutingSlipEventPublisher Publisher { get; }
    protected SanitizedRoutingSlip RoutingSlip { get; }
    private DateTime MassTransit.CourierContext.Timestamp { get; }
    private TimeSpan MassTransit.CourierContext.Elapsed { get; }
    private Guid MassTransit.CourierContext.TrackingNumber { get; }
    private Guid MassTransit.CourierContext.ExecutionId { get; }
    private RoutingSlip MassTransit.ConsumeContext<MassTransit.Courier.Contracts.RoutingSlip>.Message { get; }
    public string ActivityName { get; }
    protected BaseCourierContext(ConsumeContext`1<RoutingSlip> consumeContext);
    [CompilerGeneratedAttribute]
protected IRoutingSlipEventPublisher get_Publisher();
    [CompilerGeneratedAttribute]
protected SanitizedRoutingSlip get_RoutingSlip();
    private sealed virtual override DateTime MassTransit.CourierContext.get_Timestamp();
    private sealed virtual override TimeSpan MassTransit.CourierContext.get_Elapsed();
    private sealed virtual override Guid MassTransit.CourierContext.get_TrackingNumber();
    private sealed virtual override Guid MassTransit.CourierContext.get_ExecutionId();
    private sealed virtual override RoutingSlip MassTransit.ConsumeContext<MassTransit.Courier.Contracts.RoutingSlip>.get_Message();
    public abstract virtual string get_ActivityName();
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Context.BatchConsumeContext`1 : ConsumeContextScope {
    private ConsumeContext _context;
    [CompilerGeneratedAttribute]
private Batch`1<TMessage> <Message>k__BackingField;
    public Batch`1<TMessage> Message { get; }
    public BatchConsumeContext`1(ConsumeContext context, Batch`1<TMessage> batch);
    public virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Batch`1<TMessage> get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Context.BindContextProxy`2 : object {
    [CompilerGeneratedAttribute]
private TLeft <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private TRight <Right>k__BackingField;
    public TLeft Left { get; }
    public TRight Right { get; }
    public CancellationToken CancellationToken { get; }
    public BindContextProxy`2(TLeft left, TRight source);
    [CompilerGeneratedAttribute]
public sealed virtual TLeft get_Left();
    [CompilerGeneratedAttribute]
public sealed virtual TRight get_Right();
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual bool HasPayloadType(Type payloadType);
    public sealed virtual bool TryGetPayload(T& payload);
    public sealed virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public sealed virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public class MassTransit.Context.CompensateContextProxy`1 : CourierContextProxy {
    private CompensateContext`1<TLog> _context;
    private TLog _log;
    private TLog MassTransit.CompensateContext<TLog>.Log { get; }
    private CompensationResult MassTransit.CompensateContext.Result { get; private set; }
    public CompensateContextProxy`1(CompensateContext`1<TLog> context, TLog log);
    protected CompensateContextProxy`1(CompensateContext`1<TLog> context);
    private sealed virtual override TLog MassTransit.CompensateContext<TLog>.get_Log();
    private sealed virtual override CompensateActivityContext`2<TActivity, TLog> MassTransit.CompensateContext<TLog>.CreateActivityContext(TActivity activity);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(object values);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(IDictionary`2<string, object> variables);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed(Exception exception);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.get_Result();
    private sealed virtual override void MassTransit.CompensateContext.set_Result(CompensationResult value);
}
public class MassTransit.Context.CompensateContextScope`1 : CourierContextScope {
    private CompensateContext`1<TLog> _context;
    public TLog Log { get; }
    public CompensationResult Result { get; public set; }
    public CompensateContextScope`1(CompensateContext`1<TLog> context, Object[] payloads);
    public sealed virtual TLog get_Log();
    public sealed virtual CompensateActivityContext`2<TActivity, TLog> CreateActivityContext(TActivity activity);
    public sealed virtual CompensationResult Compensated();
    public sealed virtual CompensationResult Compensated(object values);
    public sealed virtual CompensationResult Compensated(IDictionary`2<string, object> variables);
    public sealed virtual CompensationResult Failed();
    public sealed virtual CompensationResult Failed(Exception exception);
    public sealed virtual CompensationResult get_Result();
    public sealed virtual void set_Result(CompensationResult value);
}
public abstract class MassTransit.Context.ConsumeContextProxy : BaseConsumeContext {
    private ConsumeContext _context;
    public CancellationToken CancellationToken { get; }
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public Task ConsumeCompleted { get; }
    public IEnumerable`1<string> SupportedMessageTypes { get; }
    protected ConsumeContextProxy(ConsumeContext context);
    public virtual CancellationToken get_CancellationToken();
    public virtual Nullable`1<Guid> get_MessageId();
    public virtual Nullable`1<Guid> get_RequestId();
    public virtual Nullable`1<Guid> get_CorrelationId();
    public virtual Nullable`1<Guid> get_ConversationId();
    public virtual Nullable`1<Guid> get_InitiatorId();
    public virtual Nullable`1<DateTime> get_ExpirationTime();
    public virtual Uri get_SourceAddress();
    public virtual Uri get_DestinationAddress();
    public virtual Uri get_ResponseAddress();
    public virtual Uri get_FaultAddress();
    public virtual Nullable`1<DateTime> get_SentTime();
    public virtual Headers get_Headers();
    public virtual HostInfo get_Host();
    public virtual Task get_ConsumeCompleted();
    public virtual IEnumerable`1<string> get_SupportedMessageTypes();
    public virtual bool HasMessageType(Type messageType);
    public virtual bool TryGetMessage(ConsumeContext`1& consumeContext);
    public virtual void AddConsumeTask(Task task);
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
    public virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
}
public class MassTransit.Context.ConsumeContextProxy`1 : ConsumeContextProxy {
    private ConsumeContext`1<TMessage> _context;
    public TMessage Message { get; }
    public ConsumeContextProxy`1(ConsumeContext`1<TMessage> context);
    public sealed virtual TMessage get_Message();
    public virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public void Method1();
    public void Method2();
    public void Method3();
}
public class MassTransit.Context.ConsumeContextScope : ConsumeContextProxy {
    private ConsumeContext _context;
    private IPayloadCache _payloadCache;
    public CancellationToken CancellationToken { get; }
    private IPayloadCache PayloadCache { get; }
    public ConsumeContextScope(ConsumeContext context);
    public ConsumeContextScope(ConsumeContext context, Object[] payloads);
    public virtual CancellationToken get_CancellationToken();
    private IPayloadCache get_PayloadCache();
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public class MassTransit.Context.ConsumeContextScope`1 : ConsumeContextScope {
    private ConsumeContext`1<TMessage> _context;
    public TMessage Message { get; }
    public ConsumeContextScope`1(ConsumeContext`1<TMessage> context);
    public ConsumeContextScope`1(ConsumeContext`1<TMessage> context, Object[] payloads);
    public sealed virtual TMessage get_Message();
    public virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public void Method1();
    public void Method2();
    public void Method3();
}
public class MassTransit.Context.ConsumeMessageSchedulerContext : object {
    private Uri _inputAddress;
    private Lazy`1<IMessageScheduler> _scheduler;
    [CompilerGeneratedAttribute]
private MessageSchedulerFactory <SchedulerFactory>k__BackingField;
    public MessageSchedulerFactory SchedulerFactory { get; }
    public ConsumeMessageSchedulerContext(ConsumeContext consumeContext, MessageSchedulerFactory schedulerFactory);
    [CompilerGeneratedAttribute]
public sealed virtual MessageSchedulerFactory get_SchedulerFactory();
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IMessageScheduler.CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Type messageType, Guid tokenId, CancellationToken cancellationToken);
}
public class MassTransit.Context.ConsumerConsumeContextProxy`2 : ConsumeContextProxy`1<TMessage> {
    [CompilerGeneratedAttribute]
private TConsumer <Consumer>k__BackingField;
    public TConsumer Consumer { get; }
    public ConsumerConsumeContextProxy`2(ConsumeContext`1<TMessage> context, TConsumer consumer);
    [CompilerGeneratedAttribute]
public sealed virtual TConsumer get_Consumer();
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Context.ConsumerConsumeContextScope`2 : ConsumeContextScope`1<TMessage> {
    [CompilerGeneratedAttribute]
private TConsumer <Consumer>k__BackingField;
    public TConsumer Consumer { get; }
    public ConsumerConsumeContextScope`2(ConsumeContext`1<TMessage> context, TConsumer consumer);
    public ConsumerConsumeContextScope`2(ConsumeContext`1<TMessage> context, TConsumer consumer, Object[] payloads);
    [CompilerGeneratedAttribute]
public sealed virtual TConsumer get_Consumer();
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Context.CorrelationIdConsumeContextProxy`1 : ConsumeContextProxy`1<TMessage> {
    private Guid _correlationId;
    public Nullable`1<Guid> CorrelationId { get; }
    public CorrelationIdConsumeContextProxy`1(ConsumeContext`1<TMessage> context, Guid correlationId);
    public virtual Nullable`1<Guid> get_CorrelationId();
    public void Method4();
    public void Method5();
    public void Method6();
}
public abstract class MassTransit.Context.CourierContextProxy : ConsumeContextProxy`1<RoutingSlip> {
    private CourierContext _courierContext;
    private DateTime MassTransit.CourierContext.Timestamp { get; }
    private TimeSpan MassTransit.CourierContext.Elapsed { get; }
    private Guid MassTransit.CourierContext.TrackingNumber { get; }
    private Guid MassTransit.CourierContext.ExecutionId { get; }
    private string MassTransit.CourierContext.ActivityName { get; }
    protected CourierContextProxy(CourierContext courierContext);
    private sealed virtual override DateTime MassTransit.CourierContext.get_Timestamp();
    private sealed virtual override TimeSpan MassTransit.CourierContext.get_Elapsed();
    private sealed virtual override Guid MassTransit.CourierContext.get_TrackingNumber();
    private sealed virtual override Guid MassTransit.CourierContext.get_ExecutionId();
    private sealed virtual override string MassTransit.CourierContext.get_ActivityName();
    public void Method4();
    public void Method5();
    public void Method6();
}
public abstract class MassTransit.Context.CourierContextScope : ConsumeContextScope`1<RoutingSlip> {
    private CourierContext _courierContext;
    private DateTime MassTransit.CourierContext.Timestamp { get; }
    private TimeSpan MassTransit.CourierContext.Elapsed { get; }
    private Guid MassTransit.CourierContext.TrackingNumber { get; }
    private Guid MassTransit.CourierContext.ExecutionId { get; }
    private string MassTransit.CourierContext.ActivityName { get; }
    protected CourierContextScope(CourierContext courierContext, Object[] payloads);
    private sealed virtual override DateTime MassTransit.CourierContext.get_Timestamp();
    private sealed virtual override TimeSpan MassTransit.CourierContext.get_Elapsed();
    private sealed virtual override Guid MassTransit.CourierContext.get_TrackingNumber();
    private sealed virtual override Guid MassTransit.CourierContext.get_ExecutionId();
    private sealed virtual override string MassTransit.CourierContext.get_ActivityName();
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.Context.DefaultSagaConsumeContext`2 : ConsumeContextScope`1<TMessage> {
    [CompilerGeneratedAttribute]
private TSaga <Saga>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    public Nullable`1<Guid> CorrelationId { get; }
    public TSaga Saga { get; }
    public bool IsCompleted { get; private set; }
    public DefaultSagaConsumeContext`2(ConsumeContext`1<TMessage> context, TSaga instance);
    public virtual Nullable`1<Guid> get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual TSaga get_Saga();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    public sealed virtual Task SetCompleted();
    public void Method4();
    public void Method5();
    public void Method6();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Context.DeserializerConsumeContext : BaseConsumeContext {
    private PendingTaskCollection _consumeTasks;
    public Task ConsumeCompleted { get; }
    protected DeserializerConsumeContext(ReceiveContext receiveContext, SerializerContext serializerContext);
    public virtual Task get_ConsumeCompleted();
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
    public virtual void AddConsumeTask(Task task);
}
public class MassTransit.Context.ExecuteContextProxy`1 : CourierContextProxy {
    private ExecuteContext`1<TArguments> _context;
    [CompilerGeneratedAttribute]
private TArguments <Arguments>k__BackingField;
    public TArguments Arguments { get; }
    public ExecutionResult Result { get; public set; }
    public ExecuteContextProxy`1(ExecuteContext`1<TArguments> context, TArguments arguments);
    protected ExecuteContextProxy`1(ExecuteContext`1<TArguments> context);
    [CompilerGeneratedAttribute]
public sealed virtual TArguments get_Arguments();
    public sealed virtual ExecutionResult get_Result();
    public sealed virtual void set_Result(ExecutionResult value);
    public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> CreateActivityContext(TActivity activity);
    public sealed virtual ExecutionResult Completed();
    public sealed virtual ExecutionResult CompletedWithVariables(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object variables);
    public sealed virtual ExecutionResult Completed(TLog log);
    public sealed virtual ExecutionResult Completed(object logValues);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object logValues, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult ReviseItinerary(Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, object variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult Terminate();
    public sealed virtual ExecutionResult Terminate(object variables);
    public sealed virtual ExecutionResult Terminate(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult Faulted();
    public sealed virtual ExecutionResult Faulted(Exception exception);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, object variables);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, IEnumerable`1<KeyValuePair`2<string, object>> variables);
}
public class MassTransit.Context.ExecuteContextScope`1 : CourierContextScope {
    private ExecuteContext`1<TArguments> _context;
    [CompilerGeneratedAttribute]
private TArguments <Arguments>k__BackingField;
    public TArguments Arguments { get; }
    public ExecutionResult Result { get; public set; }
    public ExecuteContextScope`1(ExecuteContext`1<TArguments> context, Object[] payloads);
    [CompilerGeneratedAttribute]
public sealed virtual TArguments get_Arguments();
    public sealed virtual ExecutionResult get_Result();
    public sealed virtual void set_Result(ExecutionResult value);
    public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> CreateActivityContext(TActivity activity);
    public sealed virtual ExecutionResult Completed();
    public sealed virtual ExecutionResult CompletedWithVariables(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object variables);
    public sealed virtual ExecutionResult Completed(TLog log);
    public sealed virtual ExecutionResult Completed(object logValues);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object logValues, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult ReviseItinerary(Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, object variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult Terminate();
    public sealed virtual ExecutionResult Terminate(object variables);
    public sealed virtual ExecutionResult Terminate(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult Faulted();
    public sealed virtual ExecutionResult Faulted(Exception exception);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, object variables);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, IEnumerable`1<KeyValuePair`2<string, object>> variables);
}
public class MassTransit.Context.HostCompensateActivityContext`2 : CompensateContextProxy`1<TLog> {
    private TActivity _activity;
    private TActivity MassTransit.CompensateActivityContext<TActivity,TLog>.Activity { get; }
    public HostCompensateActivityContext`2(TActivity activity, CompensateContext`1<TLog> context);
    private sealed virtual override TActivity MassTransit.CompensateActivityContext<TActivity,TLog>.get_Activity();
    public void Method7();
    public void Method8();
    public void Method9();
}
public class MassTransit.Context.HostExecuteActivityContext`2 : ExecuteContextProxy`1<TArguments> {
    private TActivity _activity;
    private TActivity MassTransit.ExecuteActivityContext<TActivity,TArguments>.Activity { get; }
    public HostExecuteActivityContext`2(TActivity activity, ExecuteContext`1<TArguments> context);
    private sealed virtual override TActivity MassTransit.ExecuteActivityContext<TActivity,TArguments>.get_Activity();
    public void Method7();
    public void Method8();
    public void Method9();
}
public class MassTransit.Context.MediatorConsumeContext`1 : DeserializerConsumeContext {
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public IEnumerable`1<string> SupportedMessageTypes { get; }
    public TMessage Message { get; }
    public MediatorConsumeContext`1(ReceiveContext receiveContext, SerializerContext serializerContext, TMessage message);
    public virtual bool HasMessageType(Type messageType);
    public virtual bool TryGetMessage(ConsumeContext`1& consumeContext);
    public virtual Nullable`1<Guid> get_MessageId();
    public virtual Nullable`1<Guid> get_RequestId();
    public virtual Nullable`1<Guid> get_CorrelationId();
    public virtual Nullable`1<Guid> get_ConversationId();
    public virtual Nullable`1<Guid> get_InitiatorId();
    public virtual Nullable`1<DateTime> get_ExpirationTime();
    public virtual Uri get_SourceAddress();
    public virtual Uri get_DestinationAddress();
    public virtual Uri get_ResponseAddress();
    public virtual Uri get_FaultAddress();
    public virtual Nullable`1<DateTime> get_SentTime();
    public virtual Headers get_Headers();
    public virtual HostInfo get_Host();
    public virtual IEnumerable`1<string> get_SupportedMessageTypes();
    [CompilerGeneratedAttribute]
public sealed virtual TMessage get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    protected virtual Task GenerateFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Context.MediatorSendMessageContext`1 : object {
    private SendContext`1<T> _context;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public MediatorSendMessageContext`1(SendContext`1<T> context);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
}
public class MassTransit.Context.MessageConsumeContext`1 : object {
    private ConsumeContext _context;
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    public TMessage Message { get; }
    public CancellationToken CancellationToken { get; }
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public ReceiveContext ReceiveContext { get; }
    public SerializerContext SerializerContext { get; }
    public Task ConsumeCompleted { get; }
    public IEnumerable`1<string> SupportedMessageTypes { get; }
    public MessageConsumeContext`1(ConsumeContext context, TMessage message);
    [CompilerGeneratedAttribute]
public sealed virtual TMessage get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual bool HasPayloadType(Type payloadType);
    public sealed virtual bool TryGetPayload(T& payload);
    public sealed virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public sealed virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual Task Publish(T message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public sealed virtual ReceiveContext get_ReceiveContext();
    public sealed virtual SerializerContext get_SerializerContext();
    public sealed virtual Task get_ConsumeCompleted();
    public sealed virtual IEnumerable`1<string> get_SupportedMessageTypes();
    public sealed virtual bool HasMessageType(Type messageType);
    public sealed virtual bool TryGetMessage(ConsumeContext`1& consumeContext);
    public sealed virtual void AddConsumeTask(Task task);
    public sealed virtual Task RespondAsync(T message);
    public sealed virtual Task RespondAsync(T message, IPipe`1<SendContext`1<T>> sendPipe);
    public sealed virtual Task RespondAsync(T message, IPipe`1<SendContext> sendPipe);
    public sealed virtual Task RespondAsync(object message);
    public sealed virtual Task RespondAsync(object message, Type messageType);
    public sealed virtual Task RespondAsync(object message, IPipe`1<SendContext> sendPipe);
    public sealed virtual Task RespondAsync(object message, Type messageType, IPipe`1<SendContext> sendPipe);
    public sealed virtual Task RespondAsync(object values);
    public sealed virtual Task RespondAsync(object values, IPipe`1<SendContext`1<T>> sendPipe);
    public sealed virtual Task RespondAsync(object values, IPipe`1<SendContext> sendPipe);
    public sealed virtual void Respond(T message);
    public sealed virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    [AsyncStateMachineAttribute("MassTransit.Context.MessageConsumeContext`1/<ResponseAsyncWithMessage>d__76`1")]
private Task ResponseAsyncWithMessage(object values, IPipe`1<SendContext`1<T>> responsePipe);
    private Task ConsumeTask(Task task);
}
public class MassTransit.Context.MessageSendContext`1 : BasePipeContext {
    private static TimeSpanTypeConverter _timeSpanConverter;
    private Lazy`1<MessageBody> _body;
    private DictionarySendHeaders _headers;
    private IMessageSerializer _serializer;
    [CompilerGeneratedAttribute]
private bool <IsPublish>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <InitiatorId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ScheduledMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <FaultAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SentTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerialization <Serialization>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SupportedMessageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Durable>k__BackingField;
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mandatory>k__BackingField;
    public bool IsPublish { get; public set; }
    public MessageBody Body { get; }
    public Nullable`1<TimeSpan> Delay { get; public set; }
    public Nullable`1<Guid> MessageId { get; public set; }
    public Nullable`1<Guid> RequestId { get; public set; }
    public Nullable`1<Guid> CorrelationId { get; public set; }
    public Nullable`1<Guid> ConversationId { get; public set; }
    public Nullable`1<Guid> InitiatorId { get; public set; }
    public Nullable`1<Guid> ScheduledMessageId { get; public set; }
    public SendHeaders Headers { get; }
    public Uri SourceAddress { get; public set; }
    public Uri DestinationAddress { get; public set; }
    public Uri ResponseAddress { get; public set; }
    public Uri FaultAddress { get; public set; }
    public Nullable`1<TimeSpan> TimeToLive { get; public set; }
    public Nullable`1<DateTime> SentTime { get; private set; }
    public ContentType ContentType { get; public set; }
    public IMessageSerializer Serializer { get; public set; }
    public ISerialization Serialization { get; public set; }
    public String[] SupportedMessageTypes { get; public set; }
    public Nullable`1<long> BodyLength { get; }
    public bool Durable { get; public set; }
    public TMessage Message { get; }
    public bool Mandatory { get; public set; }
    public MessageSendContext`1(TMessage message, CancellationToken cancellationToken);
    private static MessageSendContext`1();
    [CompilerGeneratedAttribute]
public bool get_IsPublish();
    [CompilerGeneratedAttribute]
public void set_IsPublish(bool value);
    public MessageBody get_Body();
    [CompilerGeneratedAttribute]
public virtual Nullable`1<TimeSpan> get_Delay();
    [CompilerGeneratedAttribute]
public virtual void set_Delay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_MessageId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_RequestId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ConversationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConversationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_InitiatorId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InitiatorId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ScheduledMessageId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ScheduledMessageId(Nullable`1<Guid> value);
    public sealed virtual SendHeaders get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_SourceAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_DestinationAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DestinationAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ResponseAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResponseAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_FaultAddress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FaultAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_TimeToLive();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeToLive(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_SentTime();
    [CompilerGeneratedAttribute]
private void set_SentTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_ContentType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentType(ContentType value);
    public sealed virtual IMessageSerializer get_Serializer();
    public sealed virtual void set_Serializer(IMessageSerializer value);
    [CompilerGeneratedAttribute]
public sealed virtual ISerialization get_Serialization();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Serialization(ISerialization value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SupportedMessageTypes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SupportedMessageTypes(String[] value);
    public sealed virtual Nullable`1<long> get_BodyLength();
    public sealed virtual SendContext`1<T> CreateProxy(T message);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Durable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Durable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Mandatory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Mandatory(bool value);
    public virtual void WritePropertiesTo(IDictionary`2<string, object> properties);
    public virtual void ReadPropertiesFrom(IReadOnlyDictionary`2<string, object> properties);
    private MessageBody GetMessageBody();
    protected static string ReadString(IReadOnlyDictionary`2<string, object> properties, string key, string defaultValue);
    protected static String[] ReadStringArray(IReadOnlyDictionary`2<string, object> properties, string key);
    protected static Nullable`1<TimeSpan> ReadTimeSpan(IReadOnlyDictionary`2<string, object> properties, string key, Nullable`1<TimeSpan> defaultValue);
    protected static Nullable`1<T> ReadEnum(IReadOnlyDictionary`2<string, object> properties, string key, Nullable`1<T> defaultValue);
    protected static byte ReadByte(IReadOnlyDictionary`2<string, object> properties, string key, byte defaultValue);
    protected static Nullable`1<int> ReadInt(IReadOnlyDictionary`2<string, object> properties, string key, Nullable`1<int> defaultValue);
    protected static Nullable`1<short> ReadShort(IReadOnlyDictionary`2<string, object> properties, string key, Nullable`1<short> defaultValue);
    protected static Nullable`1<long> ReadLong(IReadOnlyDictionary`2<string, object> properties, string key, Nullable`1<long> defaultValue);
    protected static bool ReadBoolean(IReadOnlyDictionary`2<string, object> properties, string key, bool defaultValue);
    [CompilerGeneratedAttribute]
private MessageBody <.ctor>b__4_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Context.NoLockReceiveContext : object {
    public static ReceiveLockContext Instance;
    private static NoLockReceiveContext();
    public sealed virtual Task Complete();
    public sealed virtual Task Faulted(Exception exception);
    public sealed virtual Task ValidateLockStatus();
}
public abstract class MassTransit.Context.ReceiveContextProxy : object {
    private ReceiveContext _context;
    public CancellationToken CancellationToken { get; }
    public bool PublishFaults { get; }
    public MessageBody Body { get; }
    public TimeSpan ElapsedTime { get; }
    public Uri InputAddress { get; }
    public ContentType ContentType { get; }
    public bool Redelivered { get; }
    public Headers TransportHeaders { get; }
    public Task ReceiveCompleted { get; }
    public bool IsDelivered { get; }
    public bool IsFaulted { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    protected ReceiveContextProxy(ReceiveContext context);
    public sealed virtual CancellationToken get_CancellationToken();
    public virtual bool HasPayloadType(Type contextType);
    public virtual bool TryGetPayload(TPayload& payload);
    public virtual TPayload GetOrAddPayload(PayloadFactory`1<TPayload> payloadFactory);
    private sealed virtual override T MassTransit.PipeContext.AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
    public sealed virtual bool get_PublishFaults();
    public sealed virtual MessageBody get_Body();
    public sealed virtual TimeSpan get_ElapsedTime();
    public sealed virtual Uri get_InputAddress();
    public sealed virtual ContentType get_ContentType();
    public sealed virtual bool get_Redelivered();
    public sealed virtual Headers get_TransportHeaders();
    public sealed virtual Task get_ReceiveCompleted();
    public sealed virtual bool get_IsDelivered();
    public sealed virtual bool get_IsFaulted();
    public virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual Task NotifyFaulted(Exception exception);
    public virtual void AddReceiveTask(Task task);
    public virtual ISendEndpointProvider get_SendEndpointProvider();
    public virtual IPublishEndpointProvider get_PublishEndpointProvider();
}
public class MassTransit.Context.RetryCompensateContext`1 : CompensateContextScope`1<TLog> {
    private CompensateContext`1<TLog> _context;
    private CompensationResult _existingResult;
    private IRetryPolicy _retryPolicy;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public RetryCompensateContext`1(CompensateContext`1<TLog> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryCount();
    public sealed virtual TContext CreateNext(RetryContext retryContext);
    public sealed virtual Task NotifyPendingFaults();
}
public class MassTransit.Context.RetryExecuteContext`1 : ExecuteContextScope`1<TArguments> {
    private ExecuteContext`1<TArguments> _context;
    private ExecutionResult _existingResult;
    private IRetryPolicy _retryPolicy;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public RetryExecuteContext`1(ExecuteContext`1<TArguments> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryCount();
    public sealed virtual TContext CreateNext(RetryContext retryContext);
    public sealed virtual Task NotifyPendingFaults();
}
public class MassTransit.Context.SagaConsumeContextProxy`2 : ConsumeContextProxy`1<TMessage> {
    private SagaConsumeContext`2<TSaga, TMessage> _sagaContext;
    public Nullable`1<Guid> CorrelationId { get; }
    public TSaga Saga { get; }
    public bool IsCompleted { get; }
    public SagaConsumeContextProxy`2(ConsumeContext`1<TMessage> context, SagaConsumeContext`2<TSaga, TMessage> sagaContext);
    public virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual TSaga get_Saga();
    public sealed virtual Task SetCompleted();
    public sealed virtual bool get_IsCompleted();
    public void Method4();
    public void Method5();
    public void Method6();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Context.ScheduleMessageRedeliveryContext`1 : object {
    private ConsumeContext`1<TMessage> _context;
    private RedeliveryOptions _options;
    public ScheduleMessageRedeliveryContext`1(ConsumeContext`1<TMessage> context, RedeliveryOptions options);
    public sealed virtual Task ScheduleRedelivery(TimeSpan delay, Action`2<ConsumeContext, SendContext> callback);
}
public class MassTransit.Context.SystemTransactionContext : object {
    private CommittableTransaction _transaction;
    private bool _completed;
    private bool _disposed;
    public Transaction Transaction { get; }
    public SystemTransactionContext(TransactionOptions options);
    public sealed virtual void Dispose();
    public sealed virtual Transaction get_Transaction();
    [AsyncStateMachineAttribute("MassTransit.Context.SystemTransactionContext/<Commit>d__7")]
public sealed virtual Task Commit();
    public sealed virtual void Rollback();
    public sealed virtual void Rollback(Exception exception);
}
public interface MassTransit.Context.TransportReceiveContext {
    public abstract virtual IDictionary`2<string, object> GetTransportProperties();
}
public interface MassTransit.Context.TransportSendContext {
    public abstract virtual void WritePropertiesTo(IDictionary`2<string, object> properties);
    public abstract virtual void ReadPropertiesFrom(IReadOnlyDictionary`2<string, object> properties);
}
public interface MassTransit.Context.TransportSendContext`1 {
}
[ExtensionAttribute]
public static class MassTransit.ContextFilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseContextFilter(IPipeConfigurator`1<T> configurator, Func`2<T, Task`1<bool>> filter);
}
[ExtensionAttribute]
public static class MassTransit.CorrelationIdConventionExtensions : object {
    [ExtensionAttribute]
public static void UseCorrelationId(IMessageSendTopologyConfigurator`1<T> configurator, Func`2<T, Guid> correlationIdSelector);
    [ExtensionAttribute]
public static void UseCorrelationId(IMessageSendTopologyConfigurator`1<T> configurator, Func`2<T, Nullable`1<Guid>> correlationIdSelector);
    [ExtensionAttribute]
public static void UseCorrelationId(ISendTopology configurator, Func`2<T, Guid> correlationIdSelector);
    [ExtensionAttribute]
public static void UseCorrelationId(ISendTopology configurator, Func`2<T, Nullable`1<Guid>> correlationIdSelector);
}
public class MassTransit.Courier.CompensateActivityHost`2 : object {
    private IPipe`1<CompensateContext`1<TLog>> _compensatePipe;
    public CompensateActivityHost`2(IPipe`1<CompensateContext`1<TLog>> compensatePipe);
    [AsyncStateMachineAttribute("MassTransit.Courier.CompensateActivityHost`2/<Send>d__2")]
public sealed virtual Task Send(ConsumeContext`1<RoutingSlip> context, IPipe`1<ConsumeContext`1<RoutingSlip>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public static class MassTransit.Courier.DefaultConstructorCompensateActivityFactory`2 : object {
    public static ICompensateActivityFactory`2<TActivity, TLog> CompensateFactory { get; }
    public static ICompensateActivityFactory`2<TActivity, TLog> get_CompensateFactory();
}
public static class MassTransit.Courier.DefaultConstructorExecuteActivityFactory`2 : object {
    public static IExecuteActivityFactory`2<TActivity, TArguments> ExecuteFactory { get; }
    public static IExecuteActivityFactory`2<TActivity, TArguments> get_ExecuteFactory();
}
public class MassTransit.Courier.ExecuteActivityHost`2 : object {
    private Uri _compensateAddress;
    private IPipe`1<ExecuteContext`1<TArguments>> _executePipe;
    public ExecuteActivityHost`2(IPipe`1<ExecuteContext`1<TArguments>> executePipe, Uri compensateAddress);
    [AsyncStateMachineAttribute("MassTransit.Courier.ExecuteActivityHost`2/<Send>d__3")]
public sealed virtual Task Send(ConsumeContext`1<RoutingSlip> context, IPipe`1<ConsumeContext`1<RoutingSlip>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Courier.FactoryMethodActivityFactory`3 : object {
    private ICompensateActivityFactory`2<TActivity, TLog> _compensateFactory;
    private IExecuteActivityFactory`2<TActivity, TArguments> _executeFactory;
    public FactoryMethodActivityFactory`3(Func`2<TArguments, TActivity> executeFactory, Func`2<TLog, TActivity> compensateFactory);
    public sealed virtual Task Execute(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> next);
    public sealed virtual Task Compensate(CompensateContext`1<TLog> context, IPipe`1<CompensateActivityContext`2<TActivity, TLog>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Courier.FactoryMethodCompensateActivityFactory`2 : object {
    private Func`2<TLog, TActivity> _compensateFactory;
    public FactoryMethodCompensateActivityFactory`2(Func`2<TLog, TActivity> compensateFactory);
    [AsyncStateMachineAttribute("MassTransit.Courier.FactoryMethodCompensateActivityFactory`2/<Compensate>d__2")]
public sealed virtual Task Compensate(CompensateContext`1<TLog> context, IPipe`1<CompensateActivityContext`2<TActivity, TLog>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Courier.FactoryMethodExecuteActivityFactory`2 : object {
    private Func`2<TArguments, TActivity> _executeFactory;
    public FactoryMethodExecuteActivityFactory`2(Func`2<TArguments, TActivity> executeFactory);
    [AsyncStateMachineAttribute("MassTransit.Courier.FactoryMethodExecuteActivityFactory`2/<Execute>d__2")]
public sealed virtual Task Execute(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Courier.HostCompensateContext`1 : BaseCourierContext {
    private ActivityLog _activityLog;
    private CompensateLog _compensateLog;
    [CompilerGeneratedAttribute]
private TLog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private CompensationResult <Result>k__BackingField;
    public string ActivityName { get; }
    public TLog Log { get; }
    public CompensationResult Result { get; public set; }
    public HostCompensateContext`1(ConsumeContext`1<RoutingSlip> context);
    public virtual string get_ActivityName();
    [CompilerGeneratedAttribute]
public sealed virtual TLog get_Log();
    public sealed virtual CompensateActivityContext`2<TActivity, TLog> CreateActivityContext(TActivity activity);
    [CompilerGeneratedAttribute]
public sealed virtual CompensationResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Result(CompensationResult value);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(object values);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(IDictionary`2<string, object> variables);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed();
    public sealed virtual CompensationResult Failed(Exception exception);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_0(ActivityLog x);
}
public class MassTransit.Courier.HostExecuteContext`1 : BaseCourierContext {
    private Activity _activity;
    private Uri _compensationAddress;
    [CompilerGeneratedAttribute]
private TArguments <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionResult <Result>k__BackingField;
    public string ActivityName { get; }
    public TArguments Arguments { get; }
    public ExecutionResult Result { get; public set; }
    public HostExecuteContext`1(Uri compensationAddress, ConsumeContext`1<RoutingSlip> context);
    public virtual string get_ActivityName();
    [CompilerGeneratedAttribute]
public sealed virtual TArguments get_Arguments();
    public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> CreateActivityContext(TActivity activity);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Result(ExecutionResult value);
    public sealed virtual ExecutionResult Completed();
    public sealed virtual ExecutionResult Completed(TLog log);
    public sealed virtual ExecutionResult Completed(object logValues);
    public sealed virtual ExecutionResult CompletedWithVariables(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object logValues, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult ReviseItinerary(Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, object variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult Terminate();
    public sealed virtual ExecutionResult Terminate(object variables);
    public sealed virtual ExecutionResult Terminate(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult Faulted();
    public sealed virtual ExecutionResult Faulted(Exception exception);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, object variables);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, IEnumerable`1<KeyValuePair`2<string, object>> variables);
}
public interface MassTransit.Courier.IRoutingSlipSendEndpointTarget {
    public abstract virtual void AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents, string activityName, MessageEnvelope message);
}
internal class MassTransit.Courier.Results.CompensatedCompensationResult`1 : object {
    private CompensateContext`1<TLog> _compensateContext;
    private CompensateLog _compensateLog;
    private TimeSpan _duration;
    private IRoutingSlipEventPublisher _publisher;
    private RoutingSlip _routingSlip;
    public CompensatedCompensationResult`1(CompensateContext`1<TLog> compensateContext, IRoutingSlipEventPublisher publisher, CompensateLog compensateLog, RoutingSlip routingSlip);
    [AsyncStateMachineAttribute("MassTransit.Courier.Results.CompensatedCompensationResult`1/<Evaluate>d__6")]
public sealed virtual Task Evaluate();
    public sealed virtual bool IsFailed(Exception& exception);
    private bool HasMoreCompensations(RoutingSlip routingSlip);
    protected virtual void Build(RoutingSlipBuilder builder);
    protected virtual RoutingSlipBuilder CreateRoutingSlipBuilder(RoutingSlip routingSlip);
    [IteratorStateMachineAttribute("MassTransit.Courier.Results.CompensatedCompensationResult`1/<SkipLast>d__11`1")]
private static IEnumerable`1<T> SkipLast(IEnumerable`1<T> source);
}
internal class MassTransit.Courier.Results.CompensatedWithVariablesCompensationResult`1 : CompensatedCompensationResult`1<TLog> {
    private IDictionary`2<string, object> _variables;
    public CompensatedWithVariablesCompensationResult`1(CompensateContext`1<TLog> compensateContext, IRoutingSlipEventPublisher publisher, CompensateLog compensateLog, RoutingSlip routingSlip, IDictionary`2<string, object> variables);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal abstract class MassTransit.Courier.Results.CompletedExecutionResult`1 : object {
    [CompilerGeneratedAttribute]
private RoutingSlip <RoutingSlip>k__BackingField;
    [CompilerGeneratedAttribute]
private IRoutingSlipEventPublisher <Publisher>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteContext`1<TArguments> <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Activity <Activity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    protected RoutingSlip RoutingSlip { get; }
    protected IRoutingSlipEventPublisher Publisher { get; }
    protected IDictionary`2<string, object> Data { get; }
    protected ExecuteContext`1<TArguments> Context { get; }
    protected Activity Activity { get; }
    protected TimeSpan Duration { get; }
    protected CompletedExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip);
    protected CompletedExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
protected RoutingSlip get_RoutingSlip();
    [CompilerGeneratedAttribute]
protected IRoutingSlipEventPublisher get_Publisher();
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
protected ExecuteContext`1<TArguments> get_Context();
    [CompilerGeneratedAttribute]
protected Activity get_Activity();
    [CompilerGeneratedAttribute]
protected TimeSpan get_Duration();
    [AsyncStateMachineAttribute("MassTransit.Courier.Results.CompletedExecutionResult`1/<Evaluate>d__20")]
public sealed virtual Task Evaluate();
    public virtual bool IsFaulted(Exception& exception);
    protected virtual Task PublishActivityEvents(RoutingSlip routingSlip, RoutingSlipBuilder builder);
    private static bool HasNextActivity(RoutingSlip routingSlip);
    protected virtual void Build(RoutingSlipBuilder builder);
    protected virtual RoutingSlipBuilder CreateRoutingSlipBuilder(RoutingSlip routingSlip);
}
internal class MassTransit.Courier.Results.FailedCompensationResult`1 : object {
    private CompensateContext`1<TLog> _compensateContext;
    private CompensateLog _compensateLog;
    private TimeSpan _duration;
    private Exception _exception;
    private IRoutingSlipEventPublisher _publisher;
    private RoutingSlip _routingSlip;
    public FailedCompensationResult`1(CompensateContext`1<TLog> compensateContext, IRoutingSlipEventPublisher publisher, CompensateLog compensateLog, RoutingSlip routingSlip, Exception exception);
    public sealed virtual Task Evaluate();
    public sealed virtual bool IsFailed(Exception& exception);
}
internal class MassTransit.Courier.Results.FaultedExecutionResult`1 : object {
    private Activity _activity;
    private ActivityException _activityException;
    private TimeSpan _elapsed;
    private Exception _exception;
    private ExceptionInfo _exceptionInfo;
    private ExecuteContext`1<TArguments> _executeContext;
    private IRoutingSlipEventPublisher _publisher;
    private RoutingSlip _routingSlip;
    public FaultedExecutionResult`1(ExecuteContext`1<TArguments> executeContext, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Exception exception);
    [AsyncStateMachineAttribute("MassTransit.Courier.Results.FaultedExecutionResult`1/<Evaluate>d__9")]
public sealed virtual Task Evaluate();
    public virtual bool IsFaulted(Exception& exception);
    private static bool HasCompensationLogs(RoutingSlip routingSlip);
    protected virtual void Build(RoutingSlipBuilder builder);
    private static RoutingSlipBuilder CreateRoutingSlipBuilder(RoutingSlip routingSlip);
}
internal class MassTransit.Courier.Results.FaultedWithVariablesExecutionResult`1 : FaultedExecutionResult`1<TArguments> {
    private IDictionary`2<string, object> _variables;
    public FaultedWithVariablesExecutionResult`1(ExecuteContext`1<TArguments> executeContext, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Exception exception, IDictionary`2<string, object> variables);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.NextActivityExecutionResult`1 : CompletedExecutionResult`1<TArguments> {
    public NextActivityExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip);
}
internal class MassTransit.Courier.Results.NextActivityExecutionResult`2 : CompletedExecutionResult`1<TArguments> {
    private Uri _compensationAddress;
    public NextActivityExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, TLog log);
    public NextActivityExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, IDictionary`2<string, object> data);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.NextActivityWithVariablesExecutionResult`1 : CompletedExecutionResult`1<TArguments> {
    private IDictionary`2<string, object> _variables;
    public NextActivityWithVariablesExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, IDictionary`2<string, object> variables);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.NextActivityWithVariablesExecutionResult`2 : CompletedExecutionResult`1<TArguments> {
    private Uri _compensationAddress;
    private IDictionary`2<string, object> _variables;
    public NextActivityWithVariablesExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, IDictionary`2<string, object> data, IDictionary`2<string, object> variables);
    public NextActivityWithVariablesExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, TLog log, IDictionary`2<string, object> variables);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.ReviseItineraryExecutionResult`1 : CompletedExecutionResult`1<TArguments> {
    private Action`1<IItineraryBuilder> _itineraryBuilder;
    public ReviseItineraryExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Action`1<IItineraryBuilder> itineraryBuilder);
    public ReviseItineraryExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, IDictionary`2<string, object> data, Action`1<IItineraryBuilder> itineraryBuilder);
    protected virtual void Build(RoutingSlipBuilder builder);
    protected virtual RoutingSlipBuilder CreateRoutingSlipBuilder(RoutingSlip routingSlip);
    [AsyncStateMachineAttribute("MassTransit.Courier.Results.ReviseItineraryExecutionResult`1/<PublishActivityEvents>d__5")]
protected virtual Task PublishActivityEvents(RoutingSlip routingSlip, RoutingSlipBuilder builder);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(RoutingSlip routingSlip, RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.ReviseItineraryExecutionResult`2 : ReviseItineraryExecutionResult`1<TArguments> {
    private Uri _compensationAddress;
    public ReviseItineraryExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, TLog log, Action`1<IItineraryBuilder> itineraryBuilder);
    protected virtual void Build(RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.ReviseItineraryWithVariablesExecutionResult`2 : ReviseItineraryExecutionResult`2<TArguments, TLog> {
    private IDictionary`2<string, object> _variables;
    public ReviseItineraryWithVariablesExecutionResult`2(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, Uri compensationAddress, TLog log, IDictionary`2<string, object> variables, Action`1<IItineraryBuilder> itineraryBuilder);
    protected virtual void Build(RoutingSlipBuilder builder);
}
public class MassTransit.Courier.Results.ScheduledRedeliveryResult : object {
    public sealed virtual bool IsFailed(Exception& exception);
    public sealed virtual Task Evaluate();
    public sealed virtual bool IsFaulted(Exception& exception);
}
internal class MassTransit.Courier.Results.TerminateExecutionResult`1 : CompletedExecutionResult`1<TArguments> {
    public TerminateExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip);
    protected virtual RoutingSlipBuilder CreateRoutingSlipBuilder(RoutingSlip routingSlip);
    [AsyncStateMachineAttribute("MassTransit.Courier.Results.TerminateExecutionResult`1/<PublishActivityEvents>d__2")]
protected virtual Task PublishActivityEvents(RoutingSlip routingSlip, RoutingSlipBuilder builder);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(RoutingSlip routingSlip, RoutingSlipBuilder builder);
}
internal class MassTransit.Courier.Results.TerminateWithVariablesExecutionResult`1 : TerminateExecutionResult`1<TArguments> {
    private IDictionary`2<string, object> _variables;
    public TerminateWithVariablesExecutionResult`1(ExecuteContext`1<TArguments> context, IRoutingSlipEventPublisher publisher, Activity activity, RoutingSlip routingSlip, IDictionary`2<string, object> variables);
    protected virtual void Build(RoutingSlipBuilder builder);
}
public class MassTransit.Courier.RoutingSlipBuilderSendEndpoint : object {
    private string _activityName;
    private IRoutingSlipSendEndpointTarget _builder;
    private Uri _destinationAddress;
    private RoutingSlipEvents _events;
    private RoutingSlipEventContents _include;
    private SendObservable _observers;
    public RoutingSlipBuilderSendEndpoint(IRoutingSlipSendEndpointTarget builder, Uri destinationAddress, RoutingSlipEvents events, string activityName, RoutingSlipEventContents include);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipBuilderSendEndpoint/<Send>d__8`1")]
public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipBuilderSendEndpoint/<Send>d__14`1")]
public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipBuilderSendEndpoint/<Send>d__15`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipBuilderSendEndpoint/<Send>d__16`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class MassTransit.Courier.RoutingSlipRequestInfo`1 : ValueType {
    public Guid RequestId;
    public Uri ResponseAddress;
    [NullableAttribute("2")]
public Uri FaultAddress;
    [NullableAttribute("2")]
public Uri RequestAddress;
    public Nullable`1<int> RetryAttempt;
    public T Request;
    public RoutingSlipRequestInfo`1(IObjectDeserializer context, IDictionary`2<string, object> variables);
}
public abstract class MassTransit.Courier.RoutingSlipRequestProxy`1 : object {
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipRequestProxy`1/<Consume>d__0")]
public virtual Task Consume(ConsumeContext`1<TRequest> context);
    protected abstract virtual Task BuildRoutingSlip(RoutingSlipBuilder builder, ConsumeContext`1<TRequest> request);
    protected virtual Uri GetResponseEndpointAddress(ConsumeContext`1<TRequest> context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MassTransit.Courier.RoutingSlipRequestVariableNames : object {
    public static string RequestId;
    public static string Request;
    public static string FaultAddress;
    public static string ResponseAddress;
    public static string RequestAddress;
    public static string RetryAttempt;
    private static RoutingSlipRequestVariableNames();
}
public abstract class MassTransit.Courier.RoutingSlipResponseProxy`2 : RoutingSlipResponseProxy`3<TRequest, TResponse, Fault`1<TRequest>> {
    protected virtual Task`1<Fault`1<TRequest>> CreateFaultedResponseMessage(ConsumeContext`1<RoutingSlipFaulted> context, TRequest request, Guid requestId);
}
public abstract class MassTransit.Courier.RoutingSlipResponseProxy`3 : object {
    protected IRetryPolicy RetryPolicy { get; }
    protected virtual IRetryPolicy get_RetryPolicy();
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipResponseProxy`3/<Consume>d__2")]
public virtual Task Consume(ConsumeContext`1<RoutingSlipCompleted> context);
    [AsyncStateMachineAttribute("MassTransit.Courier.RoutingSlipResponseProxy`3/<Consume>d__3")]
public virtual Task Consume(ConsumeContext`1<RoutingSlipFaulted> context);
    private bool CanRetry(RoutingSlipRequestInfo`1<TRequest> requestInfo, ConsumeContext`1<RoutingSlipFaulted> context, Nullable`1& delay);
    protected abstract virtual Task`1<TResponse> CreateResponseMessage(ConsumeContext`1<RoutingSlipCompleted> context, TRequest request);
    protected abstract virtual Task`1<TFault> CreateFaultedResponseMessage(ConsumeContext`1<RoutingSlipFaulted> context, TRequest request, Guid requestId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Courier.SanitizedRoutingSlip : object {
    private SerializerContext _serializerContext;
    [CompilerGeneratedAttribute]
private Guid <TrackingNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreateTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Activity> <Itinerary>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ActivityLog> <ActivityLogs>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CompensateLog> <CompensateLogs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ActivityException> <ActivityExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Subscription> <Subscriptions>k__BackingField;
    public Guid TrackingNumber { get; private set; }
    public DateTime CreateTimestamp { get; private set; }
    public IList`1<Activity> Itinerary { get; private set; }
    public IList`1<ActivityLog> ActivityLogs { get; private set; }
    public IList`1<CompensateLog> CompensateLogs { get; private set; }
    public IDictionary`2<string, object> Variables { get; private set; }
    public IList`1<ActivityException> ActivityExceptions { get; private set; }
    public IList`1<Subscription> Subscriptions { get; private set; }
    public SanitizedRoutingSlip(ConsumeContext`1<RoutingSlip> context);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_TrackingNumber();
    [CompilerGeneratedAttribute]
private void set_TrackingNumber(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreateTimestamp();
    [CompilerGeneratedAttribute]
private void set_CreateTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<Activity> get_Itinerary();
    [CompilerGeneratedAttribute]
private void set_Itinerary(IList`1<Activity> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ActivityLog> get_ActivityLogs();
    [CompilerGeneratedAttribute]
private void set_ActivityLogs(IList`1<ActivityLog> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<CompensateLog> get_CompensateLogs();
    [CompilerGeneratedAttribute]
private void set_CompensateLogs(IList`1<CompensateLog> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ActivityException> get_ActivityExceptions();
    [CompilerGeneratedAttribute]
private void set_ActivityExceptions(IList`1<ActivityException> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<Subscription> get_Subscriptions();
    [CompilerGeneratedAttribute]
private void set_Subscriptions(IList`1<Subscription> value);
    public T GetActivityArguments();
    public T GetCompensateLogData();
}
[ExtensionAttribute]
public static class MassTransit.CourierHostConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, Func`1<TActivity> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Func`1<TActivity> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, Func`2<TArguments, TActivity> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Func`2<TArguments, TActivity> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, IExecuteActivityFactory`2<TActivity, TArguments> factory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, IExecuteActivityFactory`2<TActivity, TArguments> factory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
    [ExtensionAttribute]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, Func`1<TActivity> activityFactory, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
    [ExtensionAttribute]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, Func`2<TLog, TActivity> activityFactory, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
    [ExtensionAttribute]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, ICompensateActivityFactory`2<TActivity, TLog> factory, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
}
[ExtensionAttribute]
public static class MassTransit.DeadLetterExtensions : object {
    [ExtensionAttribute]
public static void UseDeadLetter(IPipeConfigurator`1<ReceiveContext> configurator, IPipe`1<ReceiveContext> rescuePipe);
}
public class MassTransit.DefaultEndpointNameFormatter : object {
    private static int MaxTemporaryQueueNameLength;
    private static int OverheadLength;
    private static Char[] _removeChars;
    private static Regex _nonAlpha;
    [CompilerGeneratedAttribute]
private bool <IncludeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JoinSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEndpointNameFormatter <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    protected bool IncludeNamespace { get; }
    protected string Prefix { get; }
    protected string JoinSeparator { get; }
    public static IEndpointNameFormatter Instance { get; }
    public string Separator { get; protected set; }
    public DefaultEndpointNameFormatter(bool includeNamespace);
    public DefaultEndpointNameFormatter(string prefix, bool includeNamespace);
    public DefaultEndpointNameFormatter(string prefix);
    public DefaultEndpointNameFormatter(string joinSeparator, string prefix, bool includeNamespace);
    private static DefaultEndpointNameFormatter();
    [CompilerGeneratedAttribute]
protected bool get_IncludeNamespace();
    [CompilerGeneratedAttribute]
protected string get_Prefix();
    [CompilerGeneratedAttribute]
protected string get_JoinSeparator();
    [CompilerGeneratedAttribute]
public static IEndpointNameFormatter get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Separator();
    [CompilerGeneratedAttribute]
protected void set_Separator(string value);
    public virtual string TemporaryEndpoint(string tag);
    public virtual string Consumer();
    public virtual string Message();
    public virtual string Saga();
    public virtual string ExecuteActivity();
    public virtual string CompensateActivity();
    public virtual string SanitizeName(string name);
    public static string GetTemporaryQueueName(string tag);
    protected virtual string GetConsumerName(Type type);
    protected virtual string GetMessageName(Type type);
    protected virtual string GetSagaName(Type type);
    protected virtual string GetActivityName(Type activityType, Type argumentType);
    protected virtual string FormatName(Type type);
}
[ExtensionAttribute]
public static class MassTransit.DelayedMessageSchedulerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseDelayedMessageScheduler(IBusFactoryConfigurator configurator);
}
[ExtensionAttribute]
public static class MassTransit.DelayedMessageSchedulerRegistrationExtensions : object {
    [ExtensionAttribute]
public static void AddDelayedMessageScheduler(IBusRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static void AddDelayedMessageScheduler(IBusRegistrationConfigurator`1<TBus> configurator);
}
[ExtensionAttribute]
public static class MassTransit.DelayedRedeliveryExtensions : object {
    [ExtensionAttribute]
public static void UseDelayedRedelivery(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<IRedeliveryConfigurator> configure);
    [ExtensionAttribute]
public static void UseDelayedRedelivery(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IRetryPolicy retryPolicy);
    private static RetryConsumeContext`1<T> Factory(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [ExtensionAttribute]
public static void UseDelayedRedelivery(IConsumePipeConfigurator configurator, Action`1<IRedeliveryConfigurator> configureRetry);
    [ExtensionAttribute]
public static void UseDelayedRedelivery(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IRedeliveryConfigurator> configure);
    [ExtensionAttribute]
public static void UseDelayedRedelivery(ISagaConfigurator`1<TSaga> configurator, Action`1<IRedeliveryConfigurator> configure);
    [ExtensionAttribute]
public static void UseDelayedRedelivery(IHandlerConfigurator`1<TMessage> configurator, Action`1<IRedeliveryConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.DelegatePipeConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseSendExecute(ISendPipeConfigurator configurator, Action`1<SendContext> callback);
    [ExtensionAttribute]
public static void UseSendExecuteAsync(ISendPipeConfigurator configurator, Func`2<SendContext, Task> callback);
    [ExtensionAttribute]
public static void UseSendExecute(ISendPipeConfigurator configurator, Action`1<SendContext`1<T>> callback);
    [ExtensionAttribute]
public static void UseSendExecuteAsync(ISendPipeConfigurator configurator, Func`2<SendContext`1<T>, Task> callback);
}
public abstract class MassTransit.DependencyInjection.BaseConsumeScopeProvider : object {
    private IServiceProvider _serviceProvider;
    protected ISetScopedConsumeContext SetScopedConsumeContext;
    protected BaseConsumeScopeProvider(IRegistrationContext context);
    protected BaseConsumeScopeProvider(IServiceProvider serviceProvider, ISetScopedConsumeContext setScopedConsumeContext);
    protected ValueTask`1<TScopeContext> GetScopeContext(TPipeContext context, Func`4<TPipeContext, IServiceScope, IDisposable, TScopeContext> existingScopeContextFactory, Func`4<TPipeContext, IServiceScope, IDisposable, TScopeContext> createdScopeContextFactory, Func`4<TPipeContext, IServiceScope, IServiceProvider, TPipeContext> pipeContextFactory);
}
public static class MassTransit.DependencyInjection.Bind`1 : object {
    public static Bind`2<TKey, TValue> Create(TValue value);
}
public class MassTransit.DependencyInjection.Bind`2 : object {
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TValue Value { get; }
    public Bind`2(TValue value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    public sealed virtual bool Equals(Bind`2<TKey, TValue> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Bind`3<TKey, TValue, T> Create(T value);
}
public class MassTransit.DependencyInjection.Bind`3 : object {
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TValue Value { get; }
    public Bind`3(TValue value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
}
public class MassTransit.DependencyInjection.BusInstanceBuilder : object {
    private static MethodAttributes PropertyAccessMethodAttributes;
    public static IBusInstanceBuilder Instance;
    private ConcurrentDictionary`2<string, ModuleBuilder> _moduleBuilders;
    private string _proxyNamespaceSuffix;
    private ConcurrentDictionary`2<Type, Lazy`1<Type>> _proxyTypes;
    private static BusInstanceBuilder();
    public sealed virtual TResult GetBusInstanceType(IBusInstanceBuilderCallback`2<TBus, TResult> callback);
    private Type CreateImplementation(Type interfaceType);
    private Type CreateTypeFromInterface(ModuleBuilder builder, Type interfaceType);
    private MethodBuilder GetGetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private MethodBuilder GetSetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private TResult GetModuleBuilderForType(Type interfaceType, Func`2<ModuleBuilder, TResult> callback);
    [CompilerGeneratedAttribute]
private Lazy`1<Type> <GetBusInstanceType>b__6_0(Type x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.BusScopedBusContext`1 : object {
    private TBus _bus;
    private IClientFactory _clientFactory;
    private IServiceProvider _provider;
    [NullableAttribute("2")]
private IPublishEndpoint _publishEndpoint;
    [NullableAttribute("2")]
private IScopedClientFactory _scopedClientFactory;
    [NullableAttribute("2")]
private ISendEndpointProvider _sendEndpointProvider;
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpoint PublishEndpoint { get; }
    public IScopedClientFactory ClientFactory { get; }
    public BusScopedBusContext`1(TBus bus, IClientFactory clientFactory, IServiceProvider provider);
    public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    public sealed virtual IPublishEndpoint get_PublishEndpoint();
    public sealed virtual IScopedClientFactory get_ClientFactory();
}
public class MassTransit.DependencyInjection.CompensateActivityScopeProvider`2 : BaseConsumeScopeProvider {
    public CompensateActivityScopeProvider`2(IRegistrationContext context);
    public CompensateActivityScopeProvider`2(IServiceProvider serviceProvider, ISetScopedConsumeContext setScopedConsumeContext);
    public sealed virtual ValueTask`1<ICompensateScopeContext`1<TLog>> GetScope(CompensateContext`1<TLog> context);
    public sealed virtual ValueTask`1<ICompensateActivityScopeContext`2<TActivity, TLog>> GetActivityScope(CompensateContext`1<TLog> context);
    public sealed virtual void Probe(ProbeContext context);
    private static CompensateContext`1<TLog> PipeContextFactory(CompensateContext`1<TLog> consumeContext, IServiceScope serviceScope, IServiceProvider serviceProvider);
    private static ICompensateScopeContext`1<TLog> ExistingScopeContextFactory(CompensateContext`1<TLog> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static ICompensateScopeContext`1<TLog> CreatedScopeContextFactory(CompensateContext`1<TLog> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static ICompensateActivityScopeContext`2<TActivity, TLog> ExistingActivityScopeContextFactory(CompensateContext`1<TLog> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static ICompensateActivityScopeContext`2<TActivity, TLog> CreatedActivityScopeContextFactory(CompensateContext`1<TLog> consumeContext, IServiceScope serviceScope, IDisposable disposable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.ConsumeContextScopedBusContext : object {
    private ScopedClientFactory _clientFactory;
    private ConsumeContext _context;
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpoint PublishEndpoint { get; }
    public IScopedClientFactory ClientFactory { get; }
    public ConsumeContextScopedBusContext(ConsumeContext context, IClientFactory clientFactory);
    public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    public sealed virtual IPublishEndpoint get_PublishEndpoint();
    public sealed virtual IScopedClientFactory get_ClientFactory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.ConsumeContextScopedBusContext`1 : object {
    private TBus _bus;
    private ScopedClientFactory _clientFactory;
    private ConsumeContext _context;
    private IServiceProvider _provider;
    [NullableAttribute("2")]
private IPublishEndpoint _publishEndpoint;
    [NullableAttribute("2")]
private ISendEndpointProvider _sendEndpointProvider;
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpoint PublishEndpoint { get; }
    public IScopedClientFactory ClientFactory { get; }
    public ConsumeContextScopedBusContext`1(TBus bus, ConsumeContext context, IClientFactory clientFactory, IServiceProvider provider);
    public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    public sealed virtual IPublishEndpoint get_PublishEndpoint();
    public sealed virtual IScopedClientFactory get_ClientFactory();
}
public class MassTransit.DependencyInjection.ConsumeScopeProvider : BaseConsumeScopeProvider {
    public ConsumeScopeProvider(IRegistrationContext context);
    public ConsumeScopeProvider(IServiceProvider serviceProvider, ISetScopedConsumeContext setScopedConsumeContext);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ValueTask`1<IConsumeScopeContext> GetScope(ConsumeContext context);
    public sealed virtual ValueTask`1<IConsumeScopeContext`1<T>> GetScope(ConsumeContext`1<T> context);
    public sealed virtual ValueTask`1<IConsumerConsumeScopeContext`2<TConsumer, T>> GetScope(ConsumeContext`1<T> context);
    private static ConsumeContext PipeContextFactory(ConsumeContext consumeContext, IServiceScope serviceScope, IServiceProvider serviceProvider);
    private static IConsumeScopeContext ExistingScopeContextFactory(ConsumeContext consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IConsumeScopeContext CreatedScopeContextFactory(ConsumeContext consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static ConsumeContext`1<T> PipeContextFactory(ConsumeContext`1<T> consumeContext, IServiceScope serviceScope, IServiceProvider serviceProvider);
    private IConsumeScopeContext`1<T> ExistingScopeContextFactory(ConsumeContext`1<T> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private IConsumeScopeContext`1<T> CreatedScopeContextFactory(ConsumeContext`1<T> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IConsumerConsumeScopeContext`2<TConsumer, T> ExistingScopeContextFactory(ConsumeContext`1<T> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IConsumerConsumeScopeContext`2<TConsumer, T> CreatedScopeContextFactory(ConsumeContext`1<T> consumeContext, IServiceScope serviceScope, IDisposable disposable);
}
public class MassTransit.DependencyInjection.CreatedCompensateActivityScopeContext`2 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private CompensateActivityContext`2<TActivity, TLog> <Context>k__BackingField;
    public CompensateActivityContext`2<TActivity, TLog> Context { get; }
    public CreatedCompensateActivityScopeContext`2(CompensateActivityContext`2<TActivity, TLog> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual CompensateActivityContext`2<TActivity, TLog> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.CreatedCompensateScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private CompensateContext`1<TLog> <Context>k__BackingField;
    public CompensateContext`1<TLog> Context { get; }
    public CreatedCompensateScopeContext`1(IServiceScope scope, CompensateContext`1<TLog> context, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual CompensateContext`1<TLog> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.CreatedConsumerConsumeScopeContext`2 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ConsumerConsumeContext`2<TConsumer, T> <Context>k__BackingField;
    public ConsumerConsumeContext`2<TConsumer, T> Context { get; }
    public CreatedConsumerConsumeScopeContext`2(IServiceScope scope, ConsumerConsumeContext`2<TConsumer, T> context, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumerConsumeContext`2<TConsumer, T> get_Context();
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.DependencyInjection.CreatedConsumeScopeContext : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ConsumeContext <Context>k__BackingField;
    public ConsumeContext Context { get; }
    public CreatedConsumeScopeContext(IServiceScope scope, ConsumeContext context, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumeContext get_Context();
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.DependencyInjection.CreatedConsumeScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private ConsumeContext`1<TMessage> <Context>k__BackingField;
    public ConsumeContext`1<TMessage> Context { get; }
    public CreatedConsumeScopeContext`1(IServiceScope scope, ConsumeContext`1<TMessage> context, IDisposable disposable, ISetScopedConsumeContext setter);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumeContext`1<TMessage> get_Context();
    public sealed virtual T GetService();
    public sealed virtual T CreateInstance(Object[] arguments);
    public sealed virtual IDisposable PushConsumeContext(ConsumeContext context);
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.DependencyInjection.CreatedExecuteActivityScopeContext`2 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ExecuteActivityContext`2<TActivity, TArguments> <Context>k__BackingField;
    public ExecuteActivityContext`2<TActivity, TArguments> Context { get; }
    public CreatedExecuteActivityScopeContext`2(ExecuteActivityContext`2<TActivity, TArguments> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.CreatedExecuteScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ExecuteContext`1<TArguments> <Context>k__BackingField;
    public ExecuteContext`1<TArguments> Context { get; }
    public CreatedExecuteScopeContext`1(ExecuteContext`1<TArguments> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteContext`1<TArguments> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.DependencyInjectionLoadSagaRepository`1 : LoadSagaRepository`1<TSaga> {
    public DependencyInjectionLoadSagaRepository`1(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.DependencyInjectionQuerySagaRepository`1 : QuerySagaRepository`1<TSaga> {
    public DependencyInjectionQuerySagaRepository`1(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.DependencyInjectionSagaRepository`1 : object {
    private ISagaRepositoryContextFactory`1<TSaga> _repositoryContextFactory;
    public DependencyInjectionSagaRepository`1(IRegistrationContext context);
    public DependencyInjectionSagaRepository`1(IServiceProvider serviceProvider, ISetScopedConsumeContext setter);
    private DependencyInjectionSagaRepository`1(ISagaRepositoryContextFactory`1<TSaga> repositoryContextFactory);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<T> context, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
    public sealed virtual Task SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
}
public class MassTransit.DependencyInjection.DependencyInjectionSagaRepositoryContextFactory`1 : object {
    private IServiceProvider _serviceProvider;
    private ISetScopedConsumeContext _setter;
    public DependencyInjectionSagaRepositoryContextFactory`1(IRegistrationContext context);
    public DependencyInjectionSagaRepositoryContextFactory`1(IServiceProvider serviceProvider, ISetScopedConsumeContext setter);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<T> context, IPipe`1<SagaRepositoryContext`2<TSaga, T>> next);
    public sealed virtual Task SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, IPipe`1<SagaRepositoryQueryContext`2<TSaga, T>> next);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.DependencyInjectionSagaRepositoryContextFactory`1/<Send>d__7`1")]
private Task Send(ConsumeContext`1<T> context, Func`3<ConsumeContext`1<T>, ISagaRepositoryContextFactory`1<TSaga>, Task> send);
}
public class MassTransit.DependencyInjection.ExecuteActivityScopeProvider`2 : BaseConsumeScopeProvider {
    public ExecuteActivityScopeProvider`2(IRegistrationContext context);
    public ExecuteActivityScopeProvider`2(IServiceProvider serviceProvider, ISetScopedConsumeContext setScopedConsumeContext);
    public sealed virtual ValueTask`1<IExecuteScopeContext`1<TArguments>> GetScope(ExecuteContext`1<TArguments> context);
    public sealed virtual ValueTask`1<IExecuteActivityScopeContext`2<TActivity, TArguments>> GetActivityScope(ExecuteContext`1<TArguments> context);
    public sealed virtual void Probe(ProbeContext context);
    private static ExecuteContext`1<TArguments> PipeContextFactory(ExecuteContext`1<TArguments> consumeContext, IServiceScope serviceScope, IServiceProvider serviceProvider);
    private static IExecuteScopeContext`1<TArguments> ExistingScopeContextFactory(ExecuteContext`1<TArguments> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IExecuteScopeContext`1<TArguments> CreatedScopeContextFactory(ExecuteContext`1<TArguments> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IExecuteActivityScopeContext`2<TActivity, TArguments> ExistingActivityScopeContextFactory(ExecuteContext`1<TArguments> consumeContext, IServiceScope serviceScope, IDisposable disposable);
    private static IExecuteActivityScopeContext`2<TActivity, TArguments> CreatedActivityScopeContextFactory(ExecuteContext`1<TArguments> consumeContext, IServiceScope serviceScope, IDisposable disposable);
}
public class MassTransit.DependencyInjection.ExistingCompensateActivityScopeContext`2 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private CompensateActivityContext`2<TActivity, TLog> <Context>k__BackingField;
    public CompensateActivityContext`2<TActivity, TLog> Context { get; }
    public ExistingCompensateActivityScopeContext`2(CompensateActivityContext`2<TActivity, TLog> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual CompensateActivityContext`2<TActivity, TLog> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.ExistingCompensateScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private CompensateContext`1<TLog> <Context>k__BackingField;
    public CompensateContext`1<TLog> Context { get; }
    public ExistingCompensateScopeContext`1(CompensateContext`1<TLog> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual CompensateContext`1<TLog> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.ExistingConsumerConsumeScopeContext`2 : object {
    private IDisposable _disposable;
    [CompilerGeneratedAttribute]
private ConsumerConsumeContext`2<TConsumer, T> <Context>k__BackingField;
    public ConsumerConsumeContext`2<TConsumer, T> Context { get; }
    public ExistingConsumerConsumeScopeContext`2(ConsumerConsumeContext`2<TConsumer, T> context, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumerConsumeContext`2<TConsumer, T> get_Context();
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.DependencyInjection.ExistingConsumeScopeContext : object {
    private IDisposable _disposable;
    [CompilerGeneratedAttribute]
private ConsumeContext <Context>k__BackingField;
    public ConsumeContext Context { get; }
    public ExistingConsumeScopeContext(ConsumeContext context, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumeContext get_Context();
    public sealed virtual ValueTask DisposeAsync();
}
public class MassTransit.DependencyInjection.ExistingConsumeScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    private ISetScopedConsumeContext _setter;
    [CompilerGeneratedAttribute]
private ConsumeContext`1<TMessage> <Context>k__BackingField;
    public ConsumeContext`1<TMessage> Context { get; }
    public ExistingConsumeScopeContext`1(ConsumeContext`1<TMessage> context, IServiceScope scope, IDisposable disposable, ISetScopedConsumeContext setter);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
    public sealed virtual T CreateInstance(Object[] arguments);
    public sealed virtual IDisposable PushConsumeContext(ConsumeContext context);
    [CompilerGeneratedAttribute]
public sealed virtual ConsumeContext`1<TMessage> get_Context();
}
public class MassTransit.DependencyInjection.ExistingExecuteActivityScopeContext`2 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ExecuteActivityContext`2<TActivity, TArguments> <Context>k__BackingField;
    public ExecuteActivityContext`2<TActivity, TArguments> Context { get; }
    public ExistingExecuteActivityScopeContext`2(ExecuteActivityContext`2<TActivity, TArguments> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.ExistingExecuteScopeContext`1 : object {
    private IDisposable _disposable;
    private IServiceScope _scope;
    [CompilerGeneratedAttribute]
private ExecuteContext`1<TArguments> <Context>k__BackingField;
    public ExecuteContext`1<TArguments> Context { get; }
    public ExistingExecuteScopeContext`1(ExecuteContext`1<TArguments> context, IServiceScope scope, IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteContext`1<TArguments> get_Context();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual T GetService();
}
public class MassTransit.DependencyInjection.FilterScopeProvider`2 : object {
    private IServiceProvider _serviceProvider;
    public FilterScopeProvider`2(IServiceProvider serviceProvider);
    public sealed virtual IFilterScopeContext`1<TContext> Create(TContext context);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.DependencyInjection.GenericRequestClient`1 : object {
    private IRequestClient`1<TRequest> _client;
    public GenericRequestClient`1(IServiceProvider provider);
    public sealed virtual RequestHandle`1<TRequest> Create(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<TRequest> Create(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`1<T>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`2<T1, T2>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(TRequest message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(TRequest message, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual Task`1<Response`3<T1, T2, T3>> GetResponse(object values, RequestPipeConfiguratorCallback`1<TRequest> callback, CancellationToken cancellationToken, RequestTimeout timeout);
    private static IRequestClient`1<TRequest> GetRequestClient(IServiceProvider provider);
}
public interface MassTransit.DependencyInjection.IBusInstanceBuilder {
    public abstract virtual TResult GetBusInstanceType(IBusInstanceBuilderCallback`2<TBus, TResult> callback);
}
public interface MassTransit.DependencyInjection.IBusInstanceBuilderCallback`2 {
    public abstract virtual TResult GetResult();
}
public interface MassTransit.DependencyInjection.ICompensateActivityScopeContext`2 {
    public CompensateActivityContext`2<TActivity, TLog> Context { get; }
    public abstract virtual CompensateActivityContext`2<TActivity, TLog> get_Context();
    public abstract virtual T GetService();
}
public interface MassTransit.DependencyInjection.ICompensateActivityScopeProvider`2 {
    public abstract virtual ValueTask`1<ICompensateScopeContext`1<TLog>> GetScope(CompensateContext`1<TLog> context);
    public abstract virtual ValueTask`1<ICompensateActivityScopeContext`2<TActivity, TLog>> GetActivityScope(CompensateContext`1<TLog> context);
}
public interface MassTransit.DependencyInjection.ICompensateScopeContext`1 {
    public CompensateContext`1<TLog> Context { get; }
    public abstract virtual CompensateContext`1<TLog> get_Context();
    public abstract virtual T GetService();
}
public interface MassTransit.DependencyInjection.IConsumerConsumeScopeContext`2 {
    public ConsumerConsumeContext`2<TConsumer, T> Context { get; }
    public abstract virtual ConsumerConsumeContext`2<TConsumer, T> get_Context();
}
public interface MassTransit.DependencyInjection.IConsumeScopeContext {
    public ConsumeContext Context { get; }
    public abstract virtual ConsumeContext get_Context();
}
public interface MassTransit.DependencyInjection.IConsumeScopeContext`1 {
    public ConsumeContext`1<TMessage> Context { get; }
    public abstract virtual ConsumeContext`1<TMessage> get_Context();
    public abstract virtual T GetService();
    public abstract virtual T CreateInstance(Object[] arguments);
    public abstract virtual IDisposable PushConsumeContext(ConsumeContext context);
}
public interface MassTransit.DependencyInjection.IConsumeScopeProvider {
    public abstract virtual ValueTask`1<IConsumeScopeContext> GetScope(ConsumeContext context);
    public abstract virtual ValueTask`1<IConsumeScopeContext`1<T>> GetScope(ConsumeContext`1<T> context);
    public abstract virtual ValueTask`1<IConsumerConsumeScopeContext`2<TConsumer, T>> GetScope(ConsumeContext`1<T> context);
}
public interface MassTransit.DependencyInjection.IExecuteActivityScopeContext`2 {
    public ExecuteActivityContext`2<TActivity, TArguments> Context { get; }
    public abstract virtual ExecuteActivityContext`2<TActivity, TArguments> get_Context();
    public abstract virtual T GetService();
}
public interface MassTransit.DependencyInjection.IExecuteActivityScopeProvider`2 {
    public abstract virtual ValueTask`1<IExecuteScopeContext`1<TArguments>> GetScope(ExecuteContext`1<TArguments> context);
    public abstract virtual ValueTask`1<IExecuteActivityScopeContext`2<TActivity, TArguments>> GetActivityScope(ExecuteContext`1<TArguments> context);
}
public interface MassTransit.DependencyInjection.IExecuteScopeContext`1 {
    public ExecuteContext`1<TArguments> Context { get; }
    public abstract virtual ExecuteContext`1<TArguments> get_Context();
    public abstract virtual T GetService();
}
public interface MassTransit.DependencyInjection.IFilterScopeContext`1 {
    public IFilter`1<TContext> Filter { get; }
    public TContext Context { get; }
    public abstract virtual IFilter`1<TContext> get_Filter();
    public abstract virtual TContext get_Context();
}
public interface MassTransit.DependencyInjection.IFilterScopeProvider`1 {
    public abstract virtual IFilterScopeContext`1<TContext> Create(TContext context);
}
public interface MassTransit.DependencyInjection.IRegistrationRiderFactory`1 {
    public abstract virtual IBusInstanceSpecification CreateRider(IRiderRegistrationContext context);
}
public interface MassTransit.DependencyInjection.IScopedBusContextProvider`1 {
    public ScopedBusContext Context { get; }
    public abstract virtual ScopedBusContext get_Context();
}
public interface MassTransit.DependencyInjection.IScopedConsumeContextProvider {
    public bool HasContext { get; }
    public abstract virtual bool get_HasContext();
    public abstract virtual ConsumeContext GetContext();
    public abstract virtual IDisposable PushContext(ConsumeContext context);
}
public class MassTransit.DependencyInjection.LegacySetScopedConsumeContext : object {
    public static ISetScopedConsumeContext Instance;
    private static LegacySetScopedConsumeContext();
    public sealed virtual IDisposable PushContext(IServiceScope scope, ConsumeContext context);
}
public class MassTransit.DependencyInjection.MessageHandlerConsumer`1 : object {
    private Func`2<ConsumeContext`1<T>, Task> _handler;
    public MessageHandlerConsumer`1(MessageHandlerMethod`1<T> method);
    public sealed virtual Task Consume(ConsumeContext`1<T> context);
}
public class MassTransit.DependencyInjection.MessageHandlerConsumer`2 : object {
    private T1 _arg1;
    private Func`3<ConsumeContext`1<T>, T1, Task> _handler;
    public MessageHandlerConsumer`2(MessageHandlerMethod`2<T, T1> method, T1 arg1);
    public sealed virtual Task Consume(ConsumeContext`1<T> context);
}
public class MassTransit.DependencyInjection.MessageHandlerConsumer`3 : object {
    private T1 _arg1;
    private T2 _arg2;
    private Func`4<ConsumeContext`1<T>, T1, T2, Task> _handler;
    public MessageHandlerConsumer`3(MessageHandlerMethod`3<T, T1, T2> method, T1 arg1, T2 arg2);
    public sealed virtual Task Consume(ConsumeContext`1<T> context);
}
public class MassTransit.DependencyInjection.MessageHandlerConsumer`4 : object {
    private T1 _arg1;
    private T2 _arg2;
    private T3 _arg3;
    private Func`5<ConsumeContext`1<T>, T1, T2, T3, Task> _handler;
    public MessageHandlerConsumer`4(MessageHandlerMethod`4<T, T1, T2, T3> method, T1 arg1, T2 arg2, T3 arg3);
    public sealed virtual Task Consume(ConsumeContext`1<T> context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.MessageHandlerConsumerDefinition`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEndpointDefinition`1<TConsumer> <EndpointDefinition>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public Type ConsumerType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEndpointDefinition`1<TConsumer> EndpointDefinition { get; public set; }
    [NullableAttribute("2")]
private IEndpointDefinition MassTransit.IConsumerDefinition.EndpointDefinition { get; }
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual Type get_ConsumerType();
    public sealed virtual void Configure(IReceiveEndpointConfigurator endpointConfigurator, IConsumerConfigurator`1<TConsumer> consumerConfigurator, IRegistrationContext context);
    [CompilerGeneratedAttribute]
public IEndpointDefinition`1<TConsumer> get_EndpointDefinition();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndpointDefinition(IEndpointDefinition`1<TConsumer> value);
    [NullableContextAttribute("2")]
private sealed virtual override IEndpointDefinition MassTransit.IConsumerDefinition.get_EndpointDefinition();
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
}
public class MassTransit.DependencyInjection.MessageHandlerMethod`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<ConsumeContext`1<TMessage>, Task> <Handler>k__BackingField;
    public Func`2<ConsumeContext`1<TMessage>, Task> Handler { get; }
    public MessageHandlerMethod`1(Func`2<ConsumeContext`1<TMessage>, Task> handler);
    public MessageHandlerMethod`1(Func`2<TMessage, Task> handler);
    [CompilerGeneratedAttribute]
public Func`2<ConsumeContext`1<TMessage>, Task> get_Handler();
}
public class MassTransit.DependencyInjection.MessageHandlerMethod`2 : object {
    [CompilerGeneratedAttribute]
private Func`3<ConsumeContext`1<TMessage>, T1, Task> <Handler>k__BackingField;
    public Func`3<ConsumeContext`1<TMessage>, T1, Task> Handler { get; }
    public MessageHandlerMethod`2(Func`3<ConsumeContext`1<TMessage>, T1, Task> handler);
    public MessageHandlerMethod`2(Func`3<TMessage, T1, Task> handler);
    [CompilerGeneratedAttribute]
public Func`3<ConsumeContext`1<TMessage>, T1, Task> get_Handler();
}
public class MassTransit.DependencyInjection.MessageHandlerMethod`3 : object {
    [CompilerGeneratedAttribute]
private Func`4<ConsumeContext`1<TMessage>, T1, T2, Task> <Handler>k__BackingField;
    public Func`4<ConsumeContext`1<TMessage>, T1, T2, Task> Handler { get; }
    public MessageHandlerMethod`3(Func`4<ConsumeContext`1<TMessage>, T1, T2, Task> handler);
    public MessageHandlerMethod`3(Func`4<TMessage, T1, T2, Task> handler);
    [CompilerGeneratedAttribute]
public Func`4<ConsumeContext`1<TMessage>, T1, T2, Task> get_Handler();
}
public class MassTransit.DependencyInjection.MessageHandlerMethod`4 : object {
    [CompilerGeneratedAttribute]
private Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task> <Handler>k__BackingField;
    public Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task> Handler { get; }
    public MessageHandlerMethod`4(Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task> handler);
    public MessageHandlerMethod`4(Func`5<TMessage, T1, T2, T3, Task> handler);
    [CompilerGeneratedAttribute]
public Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task> get_Handler();
}
public class MassTransit.DependencyInjection.Registration.ActivityRegistration`3 : object {
    private List`1<Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>>> _compensateActions;
    private List`1<Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>>> _executeActions;
    private IActivityDefinition`3<TActivity, TArguments, TLog> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    public sealed virtual void AddConfigureAction(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<T, TA>> configure);
    public sealed virtual void AddConfigureAction(Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<T, TL>> configure);
    public sealed virtual void Configure(IReceiveEndpointConfigurator executeEndpointConfigurator, IReceiveEndpointConfigurator compensateEndpointConfigurator, IRegistrationContext context);
    private sealed virtual override IActivityDefinition MassTransit.Configuration.IActivityRegistration.GetDefinition(IRegistrationContext context);
    public sealed virtual void ConfigureCompensate(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public sealed virtual void ConfigureExecute(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Uri compensateAddress);
    private IActivityDefinition`3<TActivity, TArguments, TLog> GetActivityDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.ActivityRegistrationConfigurator`3 : object {
    private IRegistrationConfigurator _configurator;
    private IActivityRegistration _registration;
    public ActivityRegistrationConfigurator`3(IRegistrationConfigurator configurator, IActivityRegistration registration);
    public sealed virtual void Endpoints(Action`1<IEndpointRegistrationConfigurator> configureExecute, Action`1<IEndpointRegistrationConfigurator> configureCompensate);
    public sealed virtual IActivityRegistrationConfigurator ExecuteEndpoint(Action`1<IEndpointRegistrationConfigurator> configureExecute);
    public sealed virtual IActivityRegistrationConfigurator CompensateEndpoint(Action`1<IEndpointRegistrationConfigurator> configureCompensate);
    public sealed virtual void ExcludeFromConfigureEndpoints();
}
public interface MassTransit.DependencyInjection.Registration.CachedRegistration {
    public abstract virtual void Register(IServiceCollection collection);
}
public class MassTransit.DependencyInjection.Registration.ConsumerRegistration`1 : object {
    private List`1<Action`2<IRegistrationContext, IConsumerConfigurator`1<TConsumer>>> _configureActions;
    private IConsumerDefinition`1<TConsumer> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    private sealed virtual override void MassTransit.Configuration.IConsumerRegistration.AddConfigureAction(Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    private sealed virtual override void MassTransit.Configuration.IConsumerRegistration.Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    private sealed virtual override IConsumerDefinition MassTransit.Configuration.IConsumerRegistration.GetDefinition(IRegistrationContext context);
    public sealed virtual IConsumerRegistrationConfigurator GetConsumerRegistrationConfigurator(IRegistrationConfigurator registrationConfigurator);
    private IConsumerDefinition`1<TConsumer> GetConsumerDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.ConsumerRegistrationConfigurator`1 : object {
    private IRegistrationConfigurator _configurator;
    private IConsumerRegistration _registration;
    public ConsumerRegistrationConfigurator`1(IRegistrationConfigurator configurator, IConsumerRegistration registration);
    public sealed virtual void Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual void ExcludeFromConfigureEndpoints();
}
public class MassTransit.DependencyInjection.Registration.DefaultFutureDefinition`1 : FutureDefinition`1<TFuture> {
    protected virtual void ConfigureSaga(IReceiveEndpointConfigurator endpointConfigurator, ISagaConfigurator`1<FutureState> sagaConfigurator, IRegistrationContext context);
}
public class MassTransit.DependencyInjection.Registration.EndpointRegistration`1 : object {
    private IRegistration _registration;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public EndpointRegistration`1(IRegistration registration);
    public sealed virtual Type get_Type();
    public sealed virtual bool get_IncludeInConfigureEndpoints();
    public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    public sealed virtual IEndpointDefinition GetDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.ExecuteActivityRegistration`2 : object {
    private List`1<Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>>> _configureActions;
    private IExecuteActivityDefinition`2<TActivity, TArguments> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    private sealed virtual override void MassTransit.Configuration.IExecuteActivityRegistration.AddConfigureAction(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<T, TArgs>> configure);
    public sealed virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    private sealed virtual override IExecuteActivityDefinition MassTransit.Configuration.IExecuteActivityRegistration.GetDefinition(IRegistrationContext context);
    private IExecuteActivityDefinition`2<TActivity, TArguments> GetActivityDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.ExecuteActivityRegistrationConfigurator`2 : object {
    private IRegistrationConfigurator _configurator;
    private IExecuteActivityRegistration _registration;
    public ExecuteActivityRegistrationConfigurator`2(IRegistrationConfigurator configurator, IExecuteActivityRegistration registration);
    public sealed virtual void Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual void ExcludeFromConfigureEndpoints();
}
public class MassTransit.DependencyInjection.Registration.FutureRegistration`1 : object {
    private IFutureDefinition`1<TFuture> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    public sealed virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    public sealed virtual IFutureDefinition GetDefinition(IRegistrationContext context);
    private IFutureDefinition`1<TFuture> GetFutureDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.FutureRegistrationConfigurator`1 : object {
    private IRegistrationConfigurator _configurator;
    private IFutureRegistration _registration;
    public FutureRegistrationConfigurator`1(IRegistrationConfigurator configurator, IFutureRegistration registration);
    private sealed virtual override IFutureRegistrationConfigurator MassTransit.IFutureRegistrationConfigurator.Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual void ExcludeFromConfigureEndpoints();
    public sealed virtual IFutureRegistrationConfigurator`1<TFuture> Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual IFutureRegistrationConfigurator`1<TFuture> Repository(Action`1<ISagaRepositoryRegistrationConfigurator`1<FutureState>> configure);
}
public class MassTransit.DependencyInjection.Registration.FutureRequestConsumerDefinition`2 : ConsumerDefinition`1<TConsumer> {
    private Lazy`1<Uri> _requestAddress;
    public Uri RequestAddress { get; }
    public sealed virtual Uri get_RequestAddress();
    protected virtual void ConfigureConsumer(IReceiveEndpointConfigurator endpointConfigurator, IConsumerConfigurator`1<TConsumer> consumerConfigurator, IRegistrationContext context);
}
public interface MassTransit.DependencyInjection.Registration.IConsumerFactoryDecoratorRegistration`1 {
    public ReceivedMessageList Consumed { get; }
    public abstract virtual ReceivedMessageList get_Consumed();
    public abstract virtual IConsumerFactory`1<TConsumer> DecorateConsumerFactory(IConsumerFactory`1<TConsumer> consumerFactory);
}
public interface MassTransit.DependencyInjection.Registration.IRegistrationFilter {
    public abstract virtual bool Matches(IConsumerRegistration registration);
    public abstract virtual bool Matches(ISagaRegistration registration);
    public abstract virtual bool Matches(IExecuteActivityRegistration registration);
    public abstract virtual bool Matches(IActivityRegistration registration);
    public abstract virtual bool Matches(IFutureRegistration registration);
    public abstract virtual bool Matches(IEndpointRegistration registration);
}
public interface MassTransit.DependencyInjection.Registration.IRegistrationFilterConfigurator {
    public abstract virtual void Include(Type[] types);
    public abstract virtual void Include();
    public abstract virtual void Exclude(Type[] types);
    public abstract virtual void Exclude();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.Registration.JobSagaRegistrationConfigurator : object {
    private IBusRegistrationConfigurator _configurator;
    private ISagaRegistrationConfigurator`1<JobAttemptSaga> _jobAttemptConfigurator;
    private ISagaRegistrationConfigurator`1<JobSaga> _jobConfigurator;
    private ISagaRegistrationConfigurator`1<JobTypeSaga> _jobTypeConfigurator;
    public JobSagaRegistrationConfigurator(IBusRegistrationConfigurator configurator, Action`1<JobSagaOptions> configure);
    public sealed virtual IJobSagaRegistrationConfigurator Endpoints(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual IJobSagaRegistrationConfigurator JobAttemptEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual IJobSagaRegistrationConfigurator JobEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual IJobSagaRegistrationConfigurator JobTypeEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual IJobSagaRegistrationConfigurator UseRepositoryRegistrationProvider(ISagaRepositoryRegistrationProvider registrationProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.Registration.JobServiceRegistration : object {
    private List`1<Action`1<JobConsumerOptions>> _configureActions;
    private List`1<IReceiveEndpointConfigurator> _dependencies;
    private EndpointRegistrationConfigurator`1<JobService> _endpointConfigurator;
    private Lazy`1<InstanceJobServiceSettings> _settings;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    private JobServiceSettings Settings { get; }
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public IEndpointRegistrationConfigurator EndpointRegistrationConfigurator { get; }
    public IEndpointDefinition EndpointDefinition { get; }
    private JobServiceSettings get_Settings();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    public sealed virtual IEndpointRegistrationConfigurator get_EndpointRegistrationConfigurator();
    public sealed virtual IEndpointDefinition get_EndpointDefinition();
    public sealed virtual void AddConfigureAction(Action`1<JobConsumerOptions> configure);
    public sealed virtual void AddReceiveEndpointDependency(IReceiveEndpointConfigurator dependency);
    public sealed virtual void Configure(IServiceInstanceConfigurator instanceConfigurator, IRegistrationContext context);
    private void ConfigureJobConsumerEndpoint(IReceiveEndpointConfigurator configurator);
    private InstanceJobServiceSettings GetJobServiceSettings();
}
public class MassTransit.DependencyInjection.Registration.JobServiceRegistrationConfigurator : object {
    private IBusRegistrationConfigurator _configurator;
    private IJobServiceRegistration _registration;
    public JobServiceRegistrationConfigurator(IBusRegistrationConfigurator configurator, IJobServiceRegistration registration);
    public sealed virtual IJobServiceRegistrationConfigurator Options(Action`1<JobConsumerOptions> configure);
    public sealed virtual void Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
}
public class MassTransit.DependencyInjection.Registration.RegistrationBusFactory : object {
    private Func`2<IBusRegistrationContext, IBusControl> _configure;
    public RegistrationBusFactory(Func`2<IBusRegistrationContext, IBusControl> configure);
    public sealed virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
}
public class MassTransit.DependencyInjection.Registration.RegistrationCache`1 : object {
    private IDictionary`2<Type, T> _dictionary;
    private Func`2<Type, T> _missingRegistrationFactory;
    public IEnumerable`1<T> Values { get; }
    public RegistrationCache`1(Func`2<Type, T> missingRegistrationFactory);
    public sealed virtual IEnumerable`1<T> get_Values();
    public T GetOrAdd(Type type, Func`2<Type, T> missingRegistrationFactory);
}
internal class MassTransit.DependencyInjection.Registration.RegistrationFilter : object {
    private CompositeFilter`1<Type> _filter;
    public RegistrationFilter(CompositeFilter`1<Type> filter);
    public sealed virtual bool Matches(IConsumerRegistration registration);
    public sealed virtual bool Matches(ISagaRegistration registration);
    public sealed virtual bool Matches(IExecuteActivityRegistration registration);
    public sealed virtual bool Matches(IActivityRegistration registration);
    public sealed virtual bool Matches(IFutureRegistration registration);
    public sealed virtual bool Matches(IEndpointRegistration registration);
}
public class MassTransit.DependencyInjection.Registration.RegistrationFilterConfigurator : object {
    private CompositeFilter`1<Type> _filter;
    [CompilerGeneratedAttribute]
private IRegistrationFilter <Filter>k__BackingField;
    public IRegistrationFilter Filter { get; }
    [CompilerGeneratedAttribute]
public IRegistrationFilter get_Filter();
    public sealed virtual void Include(Type[] types);
    public sealed virtual void Include();
    public sealed virtual void Exclude(Type[] types);
    public sealed virtual void Exclude();
}
public static class MassTransit.DependencyInjection.Registration.RequestClientRegistrationCache : object {
    public static void Register(Type requestType, RequestTimeout timeout, IContainerRegistrar registrar);
    public static void Register(Type requestType, Uri destinationAddress, RequestTimeout timeout, IContainerRegistrar registrar);
    private static CachedRegistration Factory(Type type);
}
public class MassTransit.DependencyInjection.Registration.RequestConsumerFutureDefinition`4 : RequestConsumerFutureDefinition`5<TFuture, TConsumer, TRequest, TResponse, Fault`1<TRequest>> {
    public RequestConsumerFutureDefinition`4(IConsumerDefinition`1<TConsumer> consumerDefinition);
}
public class MassTransit.DependencyInjection.Registration.RequestConsumerFutureDefinition`5 : FutureDefinition`1<TFuture> {
    private IFutureRequestDefinition`1<TRequest> _requestDefinition;
    public Uri RequestAddress { get; }
    public RequestConsumerFutureDefinition`5(IConsumerDefinition`1<TConsumer> consumerDefinition);
    public sealed virtual Uri get_RequestAddress();
    protected virtual void ConfigureSaga(IReceiveEndpointConfigurator endpointConfigurator, ISagaConfigurator`1<FutureState> sagaConfigurator, IRegistrationContext context);
}
public class MassTransit.DependencyInjection.Registration.RequestConsumerFutureEndpointDefinition`1 : object {
    private IConsumerDefinition _consumerDefinition;
    private IDefinition _definition;
    private string _endpointName;
    public bool ConfigureConsumeTopology { get; }
    public bool IsTemporary { get; }
    public Nullable`1<int> PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public RequestConsumerFutureEndpointDefinition`1(IDefinition definition, IConsumerDefinition consumerDefinition);
    public sealed virtual bool get_ConfigureConsumeTopology();
    public sealed virtual void Configure(T configurator);
    public sealed virtual bool get_IsTemporary();
    public sealed virtual Nullable`1<int> get_PrefetchCount();
    public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual string GetEndpointName(IEndpointNameFormatter formatter);
    [CompilerGeneratedAttribute]
internal static string <GetEndpointName>g__GetSeparator|13_0(<>c__DisplayClass13_0& );
}
public class MassTransit.DependencyInjection.Registration.SagaRegistration`1 : object {
    private List`1<Action`2<IRegistrationContext, ISagaConfigurator`1<TSaga>>> _configureActions;
    private ISagaDefinition`1<TSaga> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    private sealed virtual override void MassTransit.Configuration.ISagaRegistration.AddConfigureAction(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    private sealed virtual override void MassTransit.Configuration.ISagaRegistration.Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    private sealed virtual override ISagaDefinition MassTransit.Configuration.ISagaRegistration.GetDefinition(IRegistrationContext context);
    private ISagaDefinition`1<TSaga> GetSagaDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.Registration.SagaRegistrationConfigurator`1 : object {
    private IRegistrationConfigurator _configurator;
    private ISagaRegistration _registration;
    public SagaRegistrationConfigurator`1(IRegistrationConfigurator configurator, ISagaRegistration registration);
    private sealed virtual override ISagaRegistrationConfigurator MassTransit.ISagaRegistrationConfigurator.Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    private sealed virtual override void MassTransit.ISagaRegistrationConfigurator.ExcludeFromConfigureEndpoints();
    public sealed virtual ISagaRegistrationConfigurator`1<TSaga> Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public sealed virtual ISagaRegistrationConfigurator`1<TSaga> Repository(Action`1<ISagaRepositoryRegistrationConfigurator`1<TSaga>> configure);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.DependencyInjection.Registration.SagaRepositoryRegistrationConfigurator`1 : object {
    private IServiceCollection _collection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ServiceDescriptor Item { get; public set; }
    public SagaRepositoryRegistrationConfigurator`1(IServiceCollection collection);
    public sealed virtual IEnumerator`1<ServiceDescriptor> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(ServiceDescriptor item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ServiceDescriptor item);
    public sealed virtual void CopyTo(ServiceDescriptor[] array, int arrayIndex);
    public sealed virtual bool Remove(ServiceDescriptor item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(ServiceDescriptor item);
    public sealed virtual void Insert(int index, ServiceDescriptor item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ServiceDescriptor get_Item(int index);
    public sealed virtual void set_Item(int index, ServiceDescriptor value);
}
public class MassTransit.DependencyInjection.Registration.SagaStateMachineRegistration`2 : object {
    private List`1<Action`2<IRegistrationContext, ISagaConfigurator`1<TInstance>>> _configureActions;
    private ISagaDefinition`1<TInstance> _definition;
    [CompilerGeneratedAttribute]
private bool <IncludeInConfigureEndpoints>k__BackingField;
    public Type Type { get; }
    public bool IncludeInConfigureEndpoints { get; public set; }
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeInConfigureEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeInConfigureEndpoints(bool value);
    public sealed virtual void AddConfigureAction(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public sealed virtual void Configure(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    private sealed virtual override ISagaDefinition MassTransit.Configuration.ISagaRegistration.GetDefinition(IRegistrationContext context);
    private ISagaDefinition`1<TInstance> GetSagaDefinition(IServiceProvider provider);
}
public class MassTransit.DependencyInjection.RequestHandlerConsumer`2 : object {
    private Func`2<ConsumeContext`1<TMessage>, Task`1<TResponse>> _handler;
    public RequestHandlerConsumer`2(RequestHandlerMethod`2<TMessage, TResponse> method);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.RequestHandlerConsumer`2/<Consume>d__2")]
public sealed virtual Task Consume(ConsumeContext`1<TMessage> context);
}
public class MassTransit.DependencyInjection.RequestHandlerConsumer`3 : object {
    private T1 _arg1;
    private Func`3<ConsumeContext`1<TMessage>, T1, Task`1<TResponse>> _handler;
    public RequestHandlerConsumer`3(RequestHandlerMethod`3<TMessage, T1, TResponse> method, T1 arg1);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.RequestHandlerConsumer`3/<Consume>d__3")]
public sealed virtual Task Consume(ConsumeContext`1<TMessage> context);
}
public class MassTransit.DependencyInjection.RequestHandlerConsumer`4 : object {
    private T1 _arg1;
    private T2 _arg2;
    private Func`4<ConsumeContext`1<TMessage>, T1, T2, Task`1<TResponse>> _handler;
    public RequestHandlerConsumer`4(RequestHandlerMethod`4<TMessage, T1, T2, TResponse> method, T1 arg1, T2 arg2);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.RequestHandlerConsumer`4/<Consume>d__4")]
public sealed virtual Task Consume(ConsumeContext`1<TMessage> context);
}
public class MassTransit.DependencyInjection.RequestHandlerConsumer`5 : object {
    private T1 _arg1;
    private T2 _arg2;
    private T3 _arg3;
    private Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task`1<TResponse>> _handler;
    public RequestHandlerConsumer`5(RequestHandlerMethod`5<TMessage, T1, T2, T3, TResponse> method, T1 arg1, T2 arg2, T3 arg3);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.RequestHandlerConsumer`5/<Consume>d__5")]
public sealed virtual Task Consume(ConsumeContext`1<TMessage> context);
}
public class MassTransit.DependencyInjection.RequestHandlerMethod`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<ConsumeContext`1<TMessage>, Task`1<TResponse>> <Handler>k__BackingField;
    public Func`2<ConsumeContext`1<TMessage>, Task`1<TResponse>> Handler { get; }
    public RequestHandlerMethod`2(Func`2<ConsumeContext`1<TMessage>, Task`1<TResponse>> handler);
    public RequestHandlerMethod`2(Func`2<TMessage, Task`1<TResponse>> handler);
    [CompilerGeneratedAttribute]
public Func`2<ConsumeContext`1<TMessage>, Task`1<TResponse>> get_Handler();
}
public class MassTransit.DependencyInjection.RequestHandlerMethod`3 : object {
    [CompilerGeneratedAttribute]
private Func`3<ConsumeContext`1<TMessage>, T1, Task`1<TResponse>> <Handler>k__BackingField;
    public Func`3<ConsumeContext`1<TMessage>, T1, Task`1<TResponse>> Handler { get; }
    public RequestHandlerMethod`3(Func`3<ConsumeContext`1<TMessage>, T1, Task`1<TResponse>> handler);
    public RequestHandlerMethod`3(Func`3<TMessage, T1, Task`1<TResponse>> handler);
    [CompilerGeneratedAttribute]
public Func`3<ConsumeContext`1<TMessage>, T1, Task`1<TResponse>> get_Handler();
}
public class MassTransit.DependencyInjection.RequestHandlerMethod`4 : object {
    [CompilerGeneratedAttribute]
private Func`4<ConsumeContext`1<TMessage>, T1, T2, Task`1<TResponse>> <Handler>k__BackingField;
    public Func`4<ConsumeContext`1<TMessage>, T1, T2, Task`1<TResponse>> Handler { get; }
    public RequestHandlerMethod`4(Func`4<ConsumeContext`1<TMessage>, T1, T2, Task`1<TResponse>> handler);
    public RequestHandlerMethod`4(Func`4<TMessage, T1, T2, Task`1<TResponse>> handler);
    [CompilerGeneratedAttribute]
public Func`4<ConsumeContext`1<TMessage>, T1, T2, Task`1<TResponse>> get_Handler();
}
public class MassTransit.DependencyInjection.RequestHandlerMethod`5 : object {
    [CompilerGeneratedAttribute]
private Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task`1<TResponse>> <Handler>k__BackingField;
    public Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task`1<TResponse>> Handler { get; }
    public RequestHandlerMethod`5(Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task`1<TResponse>> handler);
    public RequestHandlerMethod`5(Func`5<TMessage, T1, T2, T3, Task`1<TResponse>> handler);
    [CompilerGeneratedAttribute]
public Func`5<ConsumeContext`1<TMessage>, T1, T2, T3, Task`1<TResponse>> get_Handler();
}
public class MassTransit.DependencyInjection.ScopeCompensateActivityFactory`2 : object {
    private ICompensateActivityScopeProvider`2<TActivity, TLog> _scopeProvider;
    public ScopeCompensateActivityFactory`2(ICompensateActivityScopeProvider`2<TActivity, TLog> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopeCompensateActivityFactory`2/<Compensate>d__2")]
public sealed virtual Task Compensate(CompensateContext`1<TLog> context, IPipe`1<CompensateActivityContext`2<TActivity, TLog>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.DependencyInjection.ScopeConsumerFactory`1 : object {
    private IConsumeScopeProvider _scopeProvider;
    public ScopeConsumerFactory`1(IConsumeScopeProvider scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopeConsumerFactory`1/<Send>d__2`1")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public interface MassTransit.DependencyInjection.ScopedBusContext {
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpoint PublishEndpoint { get; }
    public IScopedClientFactory ClientFactory { get; }
    public abstract virtual ISendEndpointProvider get_SendEndpointProvider();
    public abstract virtual IPublishEndpoint get_PublishEndpoint();
    public abstract virtual IScopedClientFactory get_ClientFactory();
}
public class MassTransit.DependencyInjection.ScopedBusContextProvider`1 : object {
    [CompilerGeneratedAttribute]
private ScopedBusContext <Context>k__BackingField;
    public ScopedBusContext Context { get; }
    public ScopedBusContextProvider`1(TBus bus, Bind`2<TBus, IClientFactory> clientFactory, Bind`2<TBus, IScopedConsumeContextProvider> consumeContextProvider, IScopedConsumeContextProvider globalConsumeContextProvider, IServiceProvider provider);
    [CompilerGeneratedAttribute]
public sealed virtual ScopedBusContext get_Context();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.DependencyInjection.ScopedClientFactoryContext : object {
    private IClientFactory _clientFactory;
    private IServiceProvider _serviceProvider;
    public RequestTimeout DefaultTimeout { get; }
    public Uri ResponseAddress { get; }
    public ScopedClientFactoryContext(IClientFactory clientFactory, IServiceProvider serviceProvider);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual RequestTimeout get_DefaultTimeout();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(ConsumeContext consumeContext);
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(Uri destinationAddress, ConsumeContext consumeContext);
}
public class MassTransit.DependencyInjection.ScopedConsumeContextProvider : object {
    private ConsumeContext _context;
    public bool HasContext { get; }
    public sealed virtual bool get_HasContext();
    public virtual IDisposable PushContext(ConsumeContext context);
    public sealed virtual ConsumeContext GetContext();
    private void PopContext(ConsumeContext context, ConsumeContext originalContext);
}
public class MassTransit.DependencyInjection.ScopedConsumePublishEndpointProvider : object {
    private ConsumeContext _consumeContext;
    private IPublishEndpointProvider _provider;
    private IServiceProvider _serviceProvider;
    public ScopedConsumePublishEndpointProvider(IPublishEndpointProvider provider, ConsumeContext consumeContext, IServiceProvider serviceProvider);
    private sealed virtual override ConnectHandle MassTransit.IPublishObserverConnector.ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopedConsumePublishEndpointProvider/<MassTransit-IPublishEndpointProvider-GetPublishSendEndpoint>d__5`1")]
private sealed virtual override Task`1<ISendEndpoint> MassTransit.IPublishEndpointProvider.GetPublishSendEndpoint();
}
public class MassTransit.DependencyInjection.ScopedConsumeSendEndpointProvider : object {
    private ConsumeContext _consumeContext;
    private ISendEndpointProvider _provider;
    private IServiceProvider _scope;
    public ScopedConsumeSendEndpointProvider(ISendEndpointProvider provider, ConsumeContext consumeContext, IServiceProvider scope);
    private sealed virtual override ConnectHandle MassTransit.ISendObserverConnector.ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopedConsumeSendEndpointProvider/<MassTransit-ISendEndpointProvider-GetSendEndpoint>d__5")]
private sealed virtual override Task`1<ISendEndpoint> MassTransit.ISendEndpointProvider.GetSendEndpoint(Uri address);
}
public class MassTransit.DependencyInjection.ScopedMediator : SendEndpointProxy {
    private IMediator _mediator;
    private IServiceProvider _provider;
    private IClientFactory _clientFactory;
    private IClientFactory ClientFactory { get; }
    public ClientFactoryContext Context { get; }
    public ScopedMediator(IMediator mediator, IServiceProvider provider);
    private IClientFactory get_ClientFactory();
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopedMediator/<GetPublishSendEndpoint>d__7`1")]
public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual Task Publish(T message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual ClientFactoryContext get_Context();
    public sealed virtual RequestHandle`1<T> CreateRequest(T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    protected virtual IPipe`1<SendContext`1<T>> GetPipeProxy(IPipe`1<SendContext`1<T>> pipe);
    private Task PublishInternal(CancellationToken cancellationToken, T message, IPipe`1<PublishContext`1<T>> pipe);
    private Task PublishInternal(CancellationToken cancellationToken, object values, IPipe`1<PublishContext`1<T>> pipe);
}
public class MassTransit.DependencyInjection.ScopedPublishEndpointProvider : object {
    private IPublishEndpointProvider _provider;
    private IServiceProvider _serviceProvider;
    public ScopedPublishEndpointProvider(IPublishEndpointProvider provider, IServiceProvider serviceProvider);
    private sealed virtual override ConnectHandle MassTransit.IPublishObserverConnector.ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopedPublishEndpointProvider/<MassTransit-IPublishEndpointProvider-GetPublishSendEndpoint>d__4`1")]
private sealed virtual override Task`1<ISendEndpoint> MassTransit.IPublishEndpointProvider.GetPublishSendEndpoint();
}
public class MassTransit.DependencyInjection.ScopedRequestSendEndpoint`1 : object {
    private IRequestSendEndpoint`1<TRequest> _endpoint;
    private IServiceProvider _serviceProvider;
    public ScopedRequestSendEndpoint`1(IRequestSendEndpoint`1<TRequest> endpoint, IServiceProvider serviceProvider);
    public sealed virtual Task`1<TRequest> Send(Guid requestId, object values, IPipe`1<SendContext`1<TRequest>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(Guid requestId, TRequest message, IPipe`1<SendContext`1<TRequest>> pipe, CancellationToken cancellationToken);
}
public class MassTransit.DependencyInjection.ScopedSendEndpoint : SendEndpointProxy {
    private IServiceProvider _scope;
    public ScopedSendEndpoint(ISendEndpoint endpoint, IServiceProvider scope);
    protected virtual IPipe`1<SendContext`1<T>> GetPipeProxy(IPipe`1<SendContext`1<T>> pipe);
}
public class MassTransit.DependencyInjection.ScopedSendEndpointProvider : object {
    private ISendEndpointProvider _provider;
    private IServiceProvider _serviceProvider;
    public ScopedSendEndpointProvider(ISendEndpointProvider provider, IServiceProvider serviceProvider);
    private sealed virtual override ConnectHandle MassTransit.ISendObserverConnector.ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopedSendEndpointProvider/<MassTransit-ISendEndpointProvider-GetSendEndpoint>d__4")]
private sealed virtual override Task`1<ISendEndpoint> MassTransit.ISendEndpointProvider.GetSendEndpoint(Uri address);
}
public class MassTransit.DependencyInjection.ScopedSendPipeAdapter`1 : SendContextPipeAdapter`1<TMessage> {
    private IServiceProvider _provider;
    public ScopedSendPipeAdapter`1(IServiceProvider provider, IPipe`1<SendContext`1<TMessage>> pipe);
    protected virtual void Send(SendContext`1<T> context);
    protected virtual void Send(SendContext`1<TMessage> context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IServiceProvider <Send>b__2_0();
}
public class MassTransit.DependencyInjection.ScopeExecuteActivityFactory`2 : object {
    private IExecuteActivityScopeProvider`2<TActivity, TArguments> _scopeProvider;
    public ScopeExecuteActivityFactory`2(IExecuteActivityScopeProvider`2<TActivity, TArguments> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.ScopeExecuteActivityFactory`2/<Execute>d__2")]
public sealed virtual Task Execute(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.DependencyInjection.SetScopedConsumeContext : object {
    private Func`2<IServiceProvider, IScopedConsumeContextProvider> _setterProvider;
    public SetScopedConsumeContext(Func`2<IServiceProvider, IScopedConsumeContextProvider> setterProvider);
    public sealed virtual IDisposable PushContext(IServiceScope scope, ConsumeContext context);
}
public class MassTransit.DependencyInjection.Testing.ConsumerContainerTestHarnessRegistration`1 : object {
    [CompilerGeneratedAttribute]
private ReceivedMessageList <Consumed>k__BackingField;
    public ReceivedMessageList Consumed { get; }
    public ConsumerContainerTestHarnessRegistration`1(ITestHarness testHarness);
    [CompilerGeneratedAttribute]
public sealed virtual ReceivedMessageList get_Consumed();
    public sealed virtual IConsumerFactory`1<TConsumer> DecorateConsumerFactory(IConsumerFactory`1<TConsumer> consumerFactory);
}
public class MassTransit.DependencyInjection.Testing.ConsumerTestHarnessRegistration`1 : object {
    [CompilerGeneratedAttribute]
private ReceivedMessageList <Consumed>k__BackingField;
    public ReceivedMessageList Consumed { get; }
    public ConsumerTestHarnessRegistration`1(BusTestHarness testHarness);
    [CompilerGeneratedAttribute]
public sealed virtual ReceivedMessageList get_Consumed();
    public sealed virtual IConsumerFactory`1<TConsumer> DecorateConsumerFactory(IConsumerFactory`1<TConsumer> consumerFactory);
}
public class MassTransit.DependencyInjection.Testing.ContainerTestHarness : object {
    private Lazy`1<BusTestConsumeObserver> _consumed;
    private List`1<ConnectHandle> _handles;
    private Lazy`1<AsyncInactivityObserver> _inactivityObserver;
    private IServiceProvider _provider;
    private Lazy`1<BusTestPublishObserver> _published;
    private Lazy`1<BusTestReceiveObserver> _received;
    private Lazy`1<IServiceScope> _scope;
    private Lazy`1<BusTestSendObserver> _sent;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private Task`1<bool> _cancelledTask;
    private bool _disposing;
    private IEnumerable`1<IHostedService> _hostedServices;
    private CancellationTokenRegistration _registration;
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TestInactivityTimeout>k__BackingField;
    public Task InactivityTask { get; }
    public IReceivedMessageList Consumed { get; }
    public IPublishedMessageList Published { get; }
    public ISentMessageList Sent { get; }
    public IServiceScope Scope { get; }
    public IServiceProvider Provider { get; }
    public IEndpointNameFormatter EndpointNameFormatter { get; }
    public IBus Bus { get; }
    public TimeSpan TestTimeout { get; public set; }
    public TimeSpan TestInactivityTimeout { get; public set; }
    public CancellationToken InactivityToken { get; }
    public CancellationToken CancellationToken { get; }
    public ContainerTestHarness(IServiceProvider provider, IOptions`1<TestHarnessOptions> options);
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.Testing.ContainerTestHarness/<DisposeAsync>d__15")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task get_InactivityTask();
    public sealed virtual IReceivedMessageList get_Consumed();
    public sealed virtual IPublishedMessageList get_Published();
    public sealed virtual ISentMessageList get_Sent();
    public sealed virtual IServiceScope get_Scope();
    public sealed virtual IServiceProvider get_Provider();
    public sealed virtual IEndpointNameFormatter get_EndpointNameFormatter();
    public sealed virtual IBus get_Bus();
    public sealed virtual void Cancel();
    public sealed virtual void ForceInactive();
    public sealed virtual IConsumerTestHarness`1<T> GetConsumerHarness();
    public sealed virtual ISagaTestHarness`1<T> GetSagaHarness();
    public sealed virtual ISagaStateMachineTestHarness`2<TStateMachine, T> GetSagaStateMachineHarness();
    public sealed virtual IRequestClient`1<T> GetRequestClient();
    public sealed virtual Task`1<ISendEndpoint> GetConsumerEndpoint();
    public sealed virtual Task`1<ISendEndpoint> GetHandlerEndpoint();
    public sealed virtual Uri GetConsumerAddress();
    public sealed virtual Uri GetHandlerAddress();
    public sealed virtual Task`1<ISendEndpoint> GetSagaEndpoint();
    public sealed virtual Uri GetSagaAddress();
    public sealed virtual Task`1<ISendEndpoint> GetExecuteActivityEndpoint();
    public sealed virtual Uri GetExecuteActivityAddress();
    [AsyncStateMachineAttribute("MassTransit.DependencyInjection.Testing.ContainerTestHarness/<Start>d__46")]
public sealed virtual Task Start();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestInactivityTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TestInactivityTimeout(TimeSpan value);
    public sealed virtual CancellationToken get_InactivityToken();
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual TaskCompletionSource`1<T> GetTask();
    public void PostCreate(IBus bus);
    [CompilerGeneratedAttribute]
private AsyncInactivityObserver <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private BusTestConsumeObserver <.ctor>b__14_1();
    [CompilerGeneratedAttribute]
private BusTestPublishObserver <.ctor>b__14_2();
    [CompilerGeneratedAttribute]
private BusTestReceiveObserver <.ctor>b__14_3();
    [CompilerGeneratedAttribute]
private BusTestSendObserver <.ctor>b__14_4();
    [CompilerGeneratedAttribute]
private IServiceScope <.ctor>b__14_5();
    [CompilerGeneratedAttribute]
private Task <DisposeAsync>b__15_0(IHostedService x);
}
public class MassTransit.DependencyInjection.Testing.ContainerTestHarnessBusObserver : object {
    private ContainerTestHarness _harness;
    public ContainerTestHarnessBusObserver(ContainerTestHarness harness);
    public sealed virtual void PostCreate(IBus bus);
    public sealed virtual void CreateFaulted(Exception exception);
    public sealed virtual Task PreStart(IBus bus);
    public sealed virtual Task PostStart(IBus bus, Task`1<BusReady> busReady);
    public sealed virtual Task StartFaulted(IBus bus, Exception exception);
    public sealed virtual Task PreStop(IBus bus);
    public sealed virtual Task PostStop(IBus bus);
    public sealed virtual Task StopFaulted(IBus bus, Exception exception);
}
public class MassTransit.DependencyInjection.Testing.SagaContainerTestHarnessRegistration`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceivedMessageList <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaList`1<TSaga> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaList`1<TSaga> <Sagas>k__BackingField;
    public TimeSpan TestTimeout { get; }
    public ReceivedMessageList Consumed { get; }
    public SagaList`1<TSaga> Created { get; }
    public SagaList`1<TSaga> Sagas { get; }
    public SagaContainerTestHarnessRegistration`1(ITestHarness testHarness);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual ReceivedMessageList get_Consumed();
    [CompilerGeneratedAttribute]
public sealed virtual SagaList`1<TSaga> get_Created();
    [CompilerGeneratedAttribute]
public sealed virtual SagaList`1<TSaga> get_Sagas();
    public sealed virtual ISagaRepository`1<TSaga> DecorateSagaRepository(ISagaRepository`1<TSaga> repository);
}
public class MassTransit.DependencyInjection.Testing.SagaTestHarnessRegistration`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceivedMessageList <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaList`1<TSaga> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaList`1<TSaga> <Sagas>k__BackingField;
    public TimeSpan TestTimeout { get; }
    public ReceivedMessageList Consumed { get; }
    public SagaList`1<TSaga> Created { get; }
    public SagaList`1<TSaga> Sagas { get; }
    public SagaTestHarnessRegistration`1(BusTestHarness testHarness);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual ReceivedMessageList get_Consumed();
    [CompilerGeneratedAttribute]
public sealed virtual SagaList`1<TSaga> get_Created();
    [CompilerGeneratedAttribute]
public sealed virtual SagaList`1<TSaga> get_Sagas();
    public sealed virtual ISagaRepository`1<TSaga> DecorateSagaRepository(ISagaRepository`1<TSaga> repository);
}
public class MassTransit.DependencyInjection.TransactionalScopedBusContextProvider`1 : object {
    [CompilerGeneratedAttribute]
private ScopedBusContext <Context>k__BackingField;
    public ScopedBusContext Context { get; }
    public TransactionalScopedBusContextProvider`1(ITransactionalBus bus, Bind`2<TBus, IClientFactory> clientFactory, Bind`2<TBus, IScopedConsumeContextProvider> consumeContextProvider, IScopedConsumeContextProvider globalConsumeContextProvider, IServiceProvider provider);
    [CompilerGeneratedAttribute]
public sealed virtual ScopedBusContext get_Context();
}
public class MassTransit.DependencyInjection.TypedScopedConsumeContextProvider : ScopedConsumeContextProvider {
    private IScopedConsumeContextProvider _global;
    public TypedScopedConsumeContextProvider(IScopedConsumeContextProvider global);
    public virtual IDisposable PushContext(ConsumeContext context);
}
public class MassTransit.DependencyInjection.ValidateMassTransitHostOptions : object {
    public sealed virtual ValidateOptionsResult Validate(string name, MassTransitHostOptions options);
}
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionExtensions : object {
    [ExtensionAttribute]
public static void UseServiceScope(IConsumePipeConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseServiceScope(IConsumePipeConfigurator configurator, IServiceProvider serviceProvider);
    [ExtensionAttribute]
public static void UseMessageScope(IConsumePipeConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseMessageScope(IConsumePipeConfigurator configurator, IServiceProvider serviceProvider);
    [ExtensionAttribute]
public static void RegisterInMemorySagaRepository(IServiceCollection collection);
    [ExtensionAttribute]
public static IRequestClient`1<T> CreateRequestClient(IServiceProvider provider, RequestTimeout timeout);
    [ExtensionAttribute]
public static IRequestClient`1<T> CreateRequestClient(IServiceProvider provider, Uri destinationAddress, RequestTimeout timeout);
    [ExtensionAttribute]
[ObsoleteAttribute("Remove, the generic request client is automatically registered. Visit https://masstransit.io/obsolete for details.")]
public static IServiceCollection AddGenericRequestClient(IServiceCollection collection);
}
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionFilterExtensions : object {
    [ExtensionAttribute]
public static void UseConsumeFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseConsumeFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context, Action`1<IMessageTypeFilterConfigurator> configureMessageTypeFilter);
    [ExtensionAttribute]
public static void UseConsumeFilter(IConsumePipeConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseSendFilter(ISendPipelineConfigurator configurator, Type filterType, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseSendFilter(ISendPipelineConfigurator configurator, Type filterType, IRegistrationContext context, Action`1<IMessageTypeFilterConfigurator> configureMessageTypeFilter);
    [ExtensionAttribute]
public static void UseSendFilter(ISendPipelineConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
public static void UsePublishFilter(IPublishPipelineConfigurator configurator, Type filterType, IRegistrationContext context);
    [ExtensionAttribute]
public static void UsePublishFilter(IPublishPipelineConfigurator configurator, Type filterType, IRegistrationContext context, Action`1<IMessageTypeFilterConfigurator> configureMessageTypeFilter);
    [ExtensionAttribute]
public static void UsePublishFilter(IPublishPipelineConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseExecuteActivityFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseExecuteActivityFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context, Action`1<IMessageTypeFilterConfigurator> configureMessageTypeFilter);
    [ExtensionAttribute]
public static void UseExecuteActivityFilter(IConsumePipeConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseCompensateActivityFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context);
    [ExtensionAttribute]
public static void UseCompensateActivityFilter(IConsumePipeConfigurator configurator, Type filterType, IRegistrationContext context, Action`1<IMessageTypeFilterConfigurator> configureMessageTypeFilter);
    [ExtensionAttribute]
public static void UseCompensateActivityFilter(IConsumePipeConfigurator configurator, IRegistrationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionHostingExtensions : object {
    [ExtensionAttribute]
public static IHostBuilder UseMassTransit(IHostBuilder hostBuilder, Action`2<HostBuilderContext, IBusRegistrationConfigurator> configure);
    [ExtensionAttribute]
public static IHostBuilder UseMassTransit(IHostBuilder hostBuilder, Action`2<HostBuilderContext, IBusRegistrationConfigurator`1<TBus>> configure);
    [ExtensionAttribute]
public static IHostBuilder UseMassTransit(IHostBuilder hostBuilder, Action`2<HostBuilderContext, IBusRegistrationConfigurator`1<TBus>> configure);
    [ExtensionAttribute]
public static IHostBuilder UseMediator(IHostBuilder hostBuilder, Action`2<HostBuilderContext, IMediatorRegistrationConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionReceiveEndpointExtensions : object {
    [ExtensionAttribute]
public static void Consumer(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void Consumer(IReceiveEndpointConfigurator configurator, IServiceProvider provider, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void Consumer(IBatchConfigurator`1<TMessage> configurator, IRegistrationContext context, Action`1<IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void Consumer(IBatchConfigurator`1<TMessage> configurator, IServiceProvider provider, Action`1<IConsumerMessageConfigurator`2<TConsumer, Batch`1<TMessage>>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, IRegistrationContext context, IPipeSpecification`1[] pipeSpecifications);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static ConnectHandle ConnectConsumer(IConsumePipeConnector connector, IServiceProvider provider, IPipeSpecification`1[] pipeSpecifications);
    [ExtensionAttribute]
public static void Saga(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void Saga(IReceiveEndpointConfigurator configurator, IServiceProvider provider, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void StateMachineSaga(IReceiveEndpointConfigurator configurator, SagaStateMachine`1<TInstance> stateMachine, IRegistrationContext context, Action`1<ISagaConfigurator`1<TInstance>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void StateMachineSaga(IReceiveEndpointConfigurator configurator, SagaStateMachine`1<TInstance> stateMachine, IServiceProvider serviceProvider, Action`1<ISagaConfigurator`1<TInstance>> configure);
    [ExtensionAttribute]
public static void StateMachineSaga(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Action`1<ISagaConfigurator`1<TInstance>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void StateMachineSaga(IReceiveEndpointConfigurator configurator, IServiceProvider provider, Action`1<ISagaConfigurator`1<TInstance>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, IRegistrationContext context, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, Uri compensateAddress, IServiceProvider provider, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void ExecuteActivityHost(IReceiveEndpointConfigurator configurator, IServiceProvider provider, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, IRegistrationContext context, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void CompensateActivityHost(IReceiveEndpointConfigurator configurator, IServiceProvider provider, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configure);
}
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionRegistrationExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddMassTransit(IServiceCollection collection, Action`1<IBusRegistrationConfigurator> configure);
    [ExtensionAttribute]
public static IServiceCollection AddMediator(IServiceCollection collection, Action`1<IMediatorRegistrationConfigurator> configure);
    [ExtensionAttribute]
public static IServiceCollection AddMassTransit(IServiceCollection collection, Action`1<IBusRegistrationConfigurator`1<TBus>> configure);
    [ExtensionAttribute]
public static IServiceCollection AddMassTransit(IServiceCollection collection, Action`1<IBusRegistrationConfigurator`1<TBus>> configure);
    [ExtensionAttribute]
public static IServiceCollection RemoveMassTransitHostedService(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection RemoveHostedService(IServiceCollection services);
    [ExtensionAttribute]
public static void ReplaceScoped(IServiceCollection services);
    private static void AddInstrumentation(IServiceCollection collection);
    private static void AddHostedService(IServiceCollection collection);
    [ExtensionAttribute]
internal static void RemoveMassTransit(IServiceCollection collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionTestingExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddMassTransitTestHarness(IServiceCollection services, Action`1<IBusRegistrationConfigurator> configure);
    [ExtensionAttribute]
public static IServiceCollection AddMassTransitTestHarness(IServiceCollection services, TextWriter textWriter, Action`1<IBusRegistrationConfigurator> configure);
    [ExtensionAttribute]
public static IServiceCollection AddTelemetryListener(IServiceCollection services, bool includeDetails);
    [ExtensionAttribute]
public static IServiceCollection AddTelemetryListener(IServiceCollection services, TextWriter textWriter, bool includeDetails);
    [ExtensionAttribute]
public static IBusRegistrationConfigurator SetTestTimeouts(IBusRegistrationConfigurator configurator, Nullable`1<TimeSpan> testTimeout, Nullable`1<TimeSpan> testInactivityTimeout);
    private static void RegisterConsumerTestHarnesses(IServiceCollection services);
    private static void RegisterSagaTestHarnesses(IServiceCollection services);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddMassTransitTestHarness instead. Visit https://masstransit.io/obsolete for details.")]
public static IServiceCollection AddMassTransitInMemoryTestHarness(IServiceCollection services, Action`1<IBusRegistrationConfigurator> configure);
    private static ValueTuple`2<string, string> GetTestMethodInfo();
    [ExtensionAttribute]
public static void AddConsumerContainerTestHarness(IServiceCollection configurator);
    [ExtensionAttribute]
public static void AddSagaContainerTestHarness(IServiceCollection services);
    [ExtensionAttribute]
public static void AddSagaStateMachineContainerTestHarness(IServiceCollection services);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddMassTransitTestHarness instead. Visit https://masstransit.io/obsolete for details.")]
public static void AddConsumerTestHarness(IBusRegistrationConfigurator configurator);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddMassTransitTestHarness instead. Visit https://masstransit.io/obsolete for details.")]
public static void AddSagaTestHarness(IBusRegistrationConfigurator configurator);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddMassTransitTestHarness instead. Visit https://masstransit.io/obsolete for details.")]
public static void AddSagaStateMachineTestHarness(IBusRegistrationConfigurator configurator);
}
[ExtensionAttribute]
public static class MassTransit.DependencyInjectionTransactionExtensions : object {
    [ExtensionAttribute]
public static void AddTransactionalEnlistmentBus(IBusRegistrationConfigurator busConfigurator);
    [ExtensionAttribute]
public static void AddTransactionalEnlistmentBus(IBusRegistrationConfigurator`1<TBus> busConfigurator);
    [ExtensionAttribute]
public static void AddTransactionalBus(IBusRegistrationConfigurator busConfigurator);
    [ExtensionAttribute]
public static void AddTransactionalBus(IBusRegistrationConfigurator`1<TBus> busConfigurator);
}
[ExtensionAttribute]
public static class MassTransit.DispatchConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseDispatch(IPipeConfigurator`1<T> configurator, IPipeContextConverterFactory`1<T> pipeContextProviderFactory, Action`1<IDispatchConfigurator`1<T>> configure);
}
public class MassTransit.EndpointAddressProvider`1 : MulticastDelegate {
    public EndpointAddressProvider`1(object object, IntPtr method);
    public virtual bool Invoke(Uri& address);
    public virtual IAsyncResult BeginInvoke(Uri& address, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Uri& address, IAsyncResult result);
}
public static class MassTransit.EndpointConvention : object {
    public static void Map(Uri destinationAddress);
    public static void Map(EndpointAddressProvider`1<T> endpointAddressProvider);
    public static bool TryGetDestinationAddress(Uri& destinationAddress);
    public static bool TryGetDestinationAddress(Type messageType, Uri& destinationAddress);
}
public static class MassTransit.EndpointConventionCache : object {
    public static bool TryGetEndpointAddress(Uri& address);
    public static bool TryGetEndpointAddress(Type messageType, Uri& address);
    private static CachedConvention GetOrAdd(Type type);
}
public class MassTransit.EndpointConventionCache`1 : object {
    private Lazy`1<EndpointAddressProvider`1<TMessage>> _endpointAddressProvider;
    private EndpointConventionCache`1(EndpointAddressProvider`1<TMessage> endpointAddressProvider);
    private sealed virtual override bool MassTransit.IEndpointConventionCache<TMessage>.TryGetEndpointAddress(Uri& address);
    internal static void Map(EndpointAddressProvider`1<TMessage> endpointAddressProvider);
    internal static void Map(Uri destinationAddress);
    internal static bool TryGetEndpointAddress(Uri& address);
    private EndpointAddressProvider`1<TMessage> CreateDefaultConvention();
}
[ExtensionAttribute]
public static class MassTransit.EndpointConventionExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__0`1")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__1`1")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__3")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__4")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object message, Type messageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__5")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__6")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.EndpointConventionExtensions/<Send>d__8`1")]
[ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(ISendEndpointProvider provider, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
}
public interface MassTransit.EventActivities`1 {
    public abstract virtual IEnumerable`1<IActivityBinder`1<TInstance>> GetStateActivityBinders();
}
public interface MassTransit.EventActivityBinder`1 {
    public StateMachine`1<TSaga> StateMachine { get; }
    public Event Event { get; }
    public abstract virtual StateMachine`1<TSaga> get_StateMachine();
    public abstract virtual Event get_Event();
    public abstract virtual EventActivityBinder`1<TSaga> Add(IStateMachineActivity`1<TSaga> activity);
    public abstract virtual EventActivityBinder`1<TSaga> Catch(Func`2<ExceptionActivityBinder`2<TSaga, T>, ExceptionActivityBinder`2<TSaga, T>> activityCallback);
    public abstract virtual EventActivityBinder`1<TSaga> Retry(Action`1<IRetryConfigurator> configure, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual EventActivityBinder`1<TSaga> If(StateMachineCondition`1<TSaga> condition, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual EventActivityBinder`1<TSaga> IfAsync(StateMachineAsyncCondition`1<TSaga> condition, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual EventActivityBinder`1<TSaga> IfElse(StateMachineCondition`1<TSaga> condition, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> thenActivityCallback, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> elseActivityCallback);
    public abstract virtual EventActivityBinder`1<TSaga> IfElseAsync(StateMachineAsyncCondition`1<TSaga> condition, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> thenActivityCallback, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> elseActivityCallback);
}
public interface MassTransit.EventActivityBinder`2 {
    public StateMachine`1<TSaga> StateMachine { get; }
    public Event`1<TMessage> Event { get; }
    public abstract virtual StateMachine`1<TSaga> get_StateMachine();
    public abstract virtual Event`1<TMessage> get_Event();
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> Add(IStateMachineActivity`1<TSaga> activity);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> Add(IStateMachineActivity`2<TSaga, TMessage> activity);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> Catch(Func`2<ExceptionActivityBinder`3<TSaga, TMessage, T>, ExceptionActivityBinder`3<TSaga, TMessage, T>> activityCallback);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> Retry(Action`1<IRetryConfigurator> configure, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> activityCallback);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> If(StateMachineCondition`2<TSaga, TMessage> condition, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> activityCallback);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> IfAsync(StateMachineAsyncCondition`2<TSaga, TMessage> condition, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> activityCallback);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> IfElse(StateMachineCondition`2<TSaga, TMessage> condition, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> thenActivityCallback, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> elseActivityCallback);
    public abstract virtual EventActivityBinder`2<TSaga, TMessage> IfElseAsync(StateMachineAsyncCondition`2<TSaga, TMessage> condition, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> thenActivityCallback, Func`2<EventActivityBinder`2<TSaga, TMessage>, EventActivityBinder`2<TSaga, TMessage>> elseActivityCallback);
}
public class MassTransit.Events.BusReadyEvent : object {
    [CompilerGeneratedAttribute]
private IBus <Bus>k__BackingField;
    [CompilerGeneratedAttribute]
private HostReady <Host>k__BackingField;
    public IBus Bus { get; }
    public HostReady Host { get; }
    public BusReadyEvent(HostReady host, IBus bus);
    [CompilerGeneratedAttribute]
public sealed virtual IBus get_Bus();
    [CompilerGeneratedAttribute]
public sealed virtual HostReady get_Host();
}
public class MassTransit.Events.FaultEvent : object {
    [CompilerGeneratedAttribute]
private Guid <FaultId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <FaultedMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo[] <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HostInfo <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FaultMessageTypes>k__BackingField;
    public Guid FaultId { get; public set; }
    public Nullable`1<Guid> FaultedMessageId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public ExceptionInfo[] Exceptions { get; public set; }
    public HostInfo Host { get; public set; }
    public String[] FaultMessageTypes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_FaultId();
    [CompilerGeneratedAttribute]
public void set_FaultId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_FaultedMessageId();
    [CompilerGeneratedAttribute]
public void set_FaultedMessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionInfo[] get_Exceptions();
    [CompilerGeneratedAttribute]
public void set_Exceptions(ExceptionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual HostInfo get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(HostInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FaultMessageTypes();
    [CompilerGeneratedAttribute]
public void set_FaultMessageTypes(String[] value);
}
public class MassTransit.Events.FaultEvent`1 : object {
    [CompilerGeneratedAttribute]
private Guid <FaultId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <FaultedMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo[] <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HostInfo <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FaultMessageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Message>k__BackingField;
    public Guid FaultId { get; public set; }
    public Nullable`1<Guid> FaultedMessageId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public ExceptionInfo[] Exceptions { get; public set; }
    public HostInfo Host { get; public set; }
    public String[] FaultMessageTypes { get; public set; }
    public T Message { get; public set; }
    public FaultEvent`1(T message, Nullable`1<Guid> faultedMessageId, HostInfo host, Exception exception, String[] faultMessageTypes);
    public FaultEvent`1(T message, Nullable`1<Guid> faultedMessageId, HostInfo host, IEnumerable`1<ExceptionInfo> exceptions, String[] faultMessageTypes);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_FaultId();
    [CompilerGeneratedAttribute]
public void set_FaultId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_FaultedMessageId();
    [CompilerGeneratedAttribute]
public void set_FaultedMessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionInfo[] get_Exceptions();
    [CompilerGeneratedAttribute]
public void set_Exceptions(ExceptionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual HostInfo get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(HostInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FaultMessageTypes();
    [CompilerGeneratedAttribute]
public void set_FaultMessageTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(T value);
    private static ExceptionInfo[] GetExceptions(Exception exception);
}
public class MassTransit.Events.FaultExceptionInfo : object {
    [CompilerGeneratedAttribute]
private string <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Data>k__BackingField;
    public string ExceptionType { get; public set; }
    public ExceptionInfo InnerException { get; public set; }
    public string StackTrace { get; public set; }
    public string Message { get; public set; }
    public string Source { get; public set; }
    public IDictionary`2<string, object> Data { get; public set; }
    public FaultExceptionInfo(Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExceptionType();
    [CompilerGeneratedAttribute]
public void set_ExceptionType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionInfo get_InnerException();
    [CompilerGeneratedAttribute]
public void set_InnerException(ExceptionInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IDictionary`2<string, object> value);
    private void UpdateData(IDictionary dictionary);
}
public class MassTransit.Events.HostReadyEvent : object {
    [CompilerGeneratedAttribute]
private Uri <HostAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceiveEndpointReady[] <ReceiveEndpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private RiderReady[] <Riders>k__BackingField;
    public Uri HostAddress { get; }
    public ReceiveEndpointReady[] ReceiveEndpoints { get; }
    public RiderReady[] Riders { get; }
    public HostReadyEvent(Uri hostAddress, ReceiveEndpointReady[] receiveEndpoints, RiderReady[] riders);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_HostAddress();
    [CompilerGeneratedAttribute]
public sealed virtual ReceiveEndpointReady[] get_ReceiveEndpoints();
    [CompilerGeneratedAttribute]
public sealed virtual RiderReady[] get_Riders();
}
public class MassTransit.Events.ReceiveEndpointCompletedEvent : object {
    private ReceiveTransportCompleted _completed;
    [CompilerGeneratedAttribute]
private IReceiveEndpoint <ReceiveEndpoint>k__BackingField;
    public Uri InputAddress { get; }
    public long DeliveryCount { get; }
    public long ConcurrentDeliveryCount { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; }
    public ReceiveEndpointCompletedEvent(ReceiveTransportCompleted completed, IReceiveEndpoint receiveEndpoint);
    public sealed virtual Uri get_InputAddress();
    public sealed virtual long get_DeliveryCount();
    public sealed virtual long get_ConcurrentDeliveryCount();
    [CompilerGeneratedAttribute]
public sealed virtual IReceiveEndpoint get_ReceiveEndpoint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Events.ReceiveEndpointFaultedEvent : object {
    private ReceiveTransportFaulted _faulted;
    [CompilerGeneratedAttribute]
private IReceiveEndpoint <ReceiveEndpoint>k__BackingField;
    public Uri InputAddress { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; }
    public ReceiveEndpointFaultedEvent(ReceiveTransportFaulted faulted, IReceiveEndpoint receiveEndpoint);
    public sealed virtual Uri get_InputAddress();
    [NullableContextAttribute("2")]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual IReceiveEndpoint get_ReceiveEndpoint();
}
public class MassTransit.Events.ReceiveEndpointReadyEvent : object {
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IReceiveEndpoint <ReceiveEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarted>k__BackingField;
    public Uri InputAddress { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; }
    public bool IsStarted { get; }
    public ReceiveEndpointReadyEvent(Uri inputAddress, IReceiveEndpoint receiveEndpoint, bool isStarted);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public sealed virtual IReceiveEndpoint get_ReceiveEndpoint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStarted();
}
public class MassTransit.Events.ReceiveEndpointStoppingEvent : object {
    [CompilerGeneratedAttribute]
private bool <Removed>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IReceiveEndpoint <ReceiveEndpoint>k__BackingField;
    public bool Removed { get; }
    public Uri InputAddress { get; }
    public IReceiveEndpoint ReceiveEndpoint { get; }
    public ReceiveEndpointStoppingEvent(Uri inputAddress, IReceiveEndpoint receiveEndpoint, bool removed);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Removed();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public sealed virtual IReceiveEndpoint get_ReceiveEndpoint();
}
public class MassTransit.Events.ReceiveFaultEvent : object {
    [CompilerGeneratedAttribute]
private Guid <FaultId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <FaultedMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo[] <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HostInfo <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FaultMessageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public Guid FaultId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public Nullable`1<Guid> FaultedMessageId { get; public set; }
    public ExceptionInfo[] Exceptions { get; public set; }
    public HostInfo Host { get; public set; }
    public String[] FaultMessageTypes { get; public set; }
    public string ContentType { get; public set; }
    public ReceiveFaultEvent(HostInfo host, Exception exception, string contentType, Nullable`1<Guid> faultedMessageId, String[] faultMessageTypes);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_FaultId();
    [CompilerGeneratedAttribute]
public void set_FaultId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_FaultedMessageId();
    [CompilerGeneratedAttribute]
public void set_FaultedMessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionInfo[] get_Exceptions();
    [CompilerGeneratedAttribute]
public void set_Exceptions(ExceptionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual HostInfo get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(HostInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FaultMessageTypes();
    [CompilerGeneratedAttribute]
public void set_FaultMessageTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
}
public class MassTransit.Events.ReceiveTransportCompletedEvent : object {
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConcurrentDeliveryCount>k__BackingField;
    public Uri InputAddress { get; }
    public long DeliveryCount { get; }
    public long ConcurrentDeliveryCount { get; }
    public ReceiveTransportCompletedEvent(Uri inputAddress, DeliveryMetrics metrics);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public sealed virtual long get_DeliveryCount();
    [CompilerGeneratedAttribute]
public sealed virtual long get_ConcurrentDeliveryCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Events.ReceiveTransportFaultedEvent : object {
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Uri InputAddress { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    public ReceiveTransportFaultedEvent(Uri inputAddress, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
}
public class MassTransit.Events.ReceiveTransportReadyEvent : object {
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarted>k__BackingField;
    public Uri InputAddress { get; }
    public bool IsStarted { get; }
    public ReceiveTransportReadyEvent(Uri inputAddress, bool isStarted);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStarted();
}
public interface MassTransit.ExceptionActivityBinder`2 {
    public StateMachine`1<TSaga> StateMachine { get; }
    public Event Event { get; }
    public abstract virtual StateMachine`1<TSaga> get_StateMachine();
    public abstract virtual Event get_Event();
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> Add(IStateMachineActivity`1<TSaga> activity);
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> Catch(Func`2<ExceptionActivityBinder`2<TSaga, T>, ExceptionActivityBinder`2<TSaga, T>> activityCallback);
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> If(StateMachineExceptionCondition`2<TSaga, TException> condition, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> activityCallback);
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> IfAsync(StateMachineAsyncExceptionCondition`2<TSaga, TException> condition, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> activityCallback);
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> IfElse(StateMachineExceptionCondition`2<TSaga, TException> condition, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> elseActivityCallback);
    public abstract virtual ExceptionActivityBinder`2<TSaga, TException> IfElseAsync(StateMachineAsyncExceptionCondition`2<TSaga, TException> condition, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`2<TSaga, TException>, ExceptionActivityBinder`2<TSaga, TException>> elseActivityCallback);
}
public interface MassTransit.ExceptionActivityBinder`3 {
    public StateMachine`1<TSaga> StateMachine { get; }
    public Event`1<TMessage> Event { get; }
    public abstract virtual StateMachine`1<TSaga> get_StateMachine();
    public abstract virtual Event`1<TMessage> get_Event();
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> Add(IStateMachineActivity`1<TSaga> activity);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> Add(IStateMachineActivity`2<TSaga, TMessage> activity);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> Catch(Func`2<ExceptionActivityBinder`3<TSaga, TMessage, T>, ExceptionActivityBinder`3<TSaga, TMessage, T>> activityCallback);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> If(StateMachineExceptionCondition`3<TSaga, TMessage, TException> condition, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> activityCallback);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> IfAsync(StateMachineAsyncExceptionCondition`3<TSaga, TMessage, TException> condition, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> activityCallback);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> IfElse(StateMachineExceptionCondition`3<TSaga, TMessage, TException> condition, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> elseActivityCallback);
    public abstract virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> IfElseAsync(StateMachineAsyncExceptionCondition`3<TSaga, TMessage, TException> condition, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`3<TSaga, TMessage, TException>, ExceptionActivityBinder`3<TSaga, TMessage, TException>> elseActivityCallback);
}
[ExtensionAttribute]
public static class MassTransit.ForkConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseFork(IPipeConfigurator`1<T> configurator, IPipe`1<T> pipe);
}
[ExtensionAttribute]
public static class MassTransit.ForwardExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.ForwardExtensions/<Forward>d__0`1")]
[ExtensionAttribute]
public static Task Forward(ConsumeContext`1<T> context, Uri address);
    [AsyncStateMachineAttribute("MassTransit.ForwardExtensions/<Forward>d__1`1")]
[ExtensionAttribute]
public static Task Forward(ConsumeContext`1<T> context, Uri address, IPipe`1<SendContext`1<T>> pipe);
    [ExtensionAttribute]
public static Task Forward(ConsumeContext`1<T> context, ISendEndpoint endpoint);
    [ExtensionAttribute]
public static Task Forward(ConsumeContext`1<T> context, ISendEndpoint endpoint, IPipe`1<SendContext`1<T>> pipe);
    [AsyncStateMachineAttribute("MassTransit.ForwardExtensions/<Forward>d__4`1")]
[ExtensionAttribute]
public static Task Forward(ConsumeContext context, Uri address, T message);
    [ExtensionAttribute]
public static Task Forward(ConsumeContext context, ISendEndpoint endpoint, T message);
}
public abstract class MassTransit.Future`2 : Future`3<TCommand, TResult, Fault`1<TCommand>> {
}
public abstract class MassTransit.Future`3 : MassTransitStateMachine`1<FutureState> {
    private FutureFault`1<TFault> _fault;
    private FutureResult`2<TCommand, TResult> _result;
    [CompilerGeneratedAttribute]
private State <WaitingForCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<TCommand> <CommandReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<Get`1<TCommand>> <ResultRequested>k__BackingField;
    public State WaitingForCompletion { get; protected set; }
    public State Completed { get; protected set; }
    public State Faulted { get; protected set; }
    public Event`1<TCommand> CommandReceived { get; protected set; }
    public Event`1<Get`1<TCommand>> ResultRequested { get; protected set; }
    [CompilerGeneratedAttribute]
public State get_WaitingForCompletion();
    [CompilerGeneratedAttribute]
protected void set_WaitingForCompletion(State value);
    [CompilerGeneratedAttribute]
public State get_Completed();
    [CompilerGeneratedAttribute]
protected void set_Completed(State value);
    [CompilerGeneratedAttribute]
public State get_Faulted();
    [CompilerGeneratedAttribute]
protected void set_Faulted(State value);
    [CompilerGeneratedAttribute]
public Event`1<TCommand> get_CommandReceived();
    [CompilerGeneratedAttribute]
protected void set_CommandReceived(Event`1<TCommand> value);
    [CompilerGeneratedAttribute]
public Event`1<Get`1<TCommand>> get_ResultRequested();
    [CompilerGeneratedAttribute]
protected void set_ResultRequested(Event`1<Get`1<TCommand>> value);
    protected void ConfigureCommand(Action`1<IEventCorrelationConfigurator`2<FutureState, TCommand>> configure);
    protected FutureRequestHandle`4<TCommand, TResult, TFault, TRequest> SendRequest(Action`1<IFutureRequestConfigurator`3<TFault, TCommand, TRequest>> configure);
    protected FutureRequestHandle`4<TCommand, TResult, TFault, TRequest> SendRequest(Func`2<TCommand, TInput> inputSelector, Action`1<IFutureRequestConfigurator`3<TFault, TInput, TRequest>> configure);
    protected FutureRequestHandle`4<TCommand, TResult, TFault, TRequest> SendRequests(Func`2<TCommand, IEnumerable`1<TInput>> inputSelector, Action`1<IFutureRequestConfigurator`3<TFault, TInput, TRequest>> configure);
    protected FutureRoutingSlipHandle ExecuteRoutingSlip(Action`1<IFutureRoutingSlipConfigurator`3<TResult, TFault, TCommand>> configure);
    private FutureRequestConfigurator`5<TCommand, TResult, TFault, TInput, TRequest> CreateFutureRequest(Action`1<IFutureRequestConfigurator`3<TFault, TInput, TRequest>> configure);
    private FutureRoutingSlipConfigurator`4<TCommand, TResult, TFault, TInput> CreateFutureRoutingSlip(Action`1<IFutureRoutingSlipConfigurator`3<TResult, TFault, TInput>> configure);
    private sealed virtual override Event`1<T> MassTransit.Futures.IFutureStateMachineConfigurator.CreateResponseEvent();
    private sealed virtual override void MassTransit.Futures.IFutureStateMachineConfigurator.CompletePendingRequest(Event`1<T> requestCompleted, PendingFutureIdProvider`1<T> pendingIdProvider);
    private sealed virtual override void MassTransit.Futures.IFutureStateMachineConfigurator.DuringAnyWhen(Event`1<T> whenEvent, Func`2<EventActivityBinder`2<FutureState, T>, EventActivityBinder`2<FutureState, T>> configure);
    private void CompletePending(Event`1<T> completedEvent, PendingFutureIdProvider`1<T> pendingIdProvider);
    public void FaultPendingRequest(Event`1<Fault`1<T>> requestFaulted, PendingFutureIdProvider`1<T> pendingIdProvider);
    private void FaultPendingRoutingSlip(Event`1<RoutingSlipFaulted> requestFaulted);
    private sealed virtual override void MassTransit.Futures.IFutureStateMachineConfigurator.SetResult(Event`1<T> responseReceived, Func`2<BehaviorContext`2<FutureState, T>, Task> callback);
    private void SetResult(Event`1<T> resultEvent, Func`2<BehaviorContext`2<FutureState, T>, Task> callback);
    public sealed virtual void SetFaulted(Event`1<T> faultEvent, Func`2<BehaviorContext`2<FutureState, T>, Task> callback);
    private static string FormatEventName();
    protected static Guid RequestIdOrFault(MessageContext context);
    protected static Guid RequestIdOrDefault(MessageContext context);
    protected static Guid FutureIdOrFault(ConsumeContext context, IDictionary`2<string, object> variables);
    protected static Guid FutureIdOrDefault(ConsumeContext context, IDictionary`2<string, object> variables);
    protected void WhenAllCompleted(Action`1<IFutureResultConfigurator`1<TResult>> configure);
    protected void WhenAnyFaulted(Action`1<IFutureFaultConfigurator`1<TFault>> configure);
    protected void WhenAllCompletedOrFaulted(Action`1<IFutureFaultConfigurator`1<TFault>> configure);
    private static Task`1<TResult> GetResult(BehaviorContext`1<FutureState> context);
    private static Task`1<TFault> GetFault(BehaviorContext`1<FutureState> context);
    [CompilerGeneratedAttribute]
private void <CreateFutureRequest>b__28_0(IEventCorrelationConfigurator`2<FutureState, Fault`1<TRequest>> x);
    [CompilerGeneratedAttribute]
private IPipe`1<ConsumeContext`1<Fault`1<TRequest>>> <CreateFutureRequest>b__28_2(IMissingInstanceConfigurator`2<FutureState, Fault`1<TRequest>> m);
    [CompilerGeneratedAttribute]
private void <CreateFutureRequest>b__28_3(ConsumeContext`1<Fault`1<TRequest>> context);
    [CompilerGeneratedAttribute]
private void <CreateFutureRoutingSlip>b__29_0(IEventCorrelationConfigurator`2<FutureState, RoutingSlipCompleted> x);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IPipe`1<ConsumeContext`1<RoutingSlipCompleted>> <CreateFutureRoutingSlip>b__29_3(IMissingInstanceConfigurator`2<FutureState, RoutingSlipCompleted> m);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CreateFutureRoutingSlip>b__29_4(ConsumeContext`1<RoutingSlipCompleted> context);
    [CompilerGeneratedAttribute]
private void <CreateFutureRoutingSlip>b__29_1(IEventCorrelationConfigurator`2<FutureState, RoutingSlipFaulted> x);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IPipe`1<ConsumeContext`1<RoutingSlipFaulted>> <CreateFutureRoutingSlip>b__29_6(IMissingInstanceConfigurator`2<FutureState, RoutingSlipFaulted> m);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CreateFutureRoutingSlip>b__29_7(ConsumeContext`1<RoutingSlipFaulted> context);
    [CompilerGeneratedAttribute]
private void <MassTransit.Futures.IFutureStateMachineConfigurator.CreateResponseEvent>b__30_0(IEventCorrelationConfigurator`2<FutureState, T> x);
    [CompilerGeneratedAttribute]
private IPipe`1<ConsumeContext`1<T>> <MassTransit.Futures.IFutureStateMachineConfigurator.CreateResponseEvent>b__30_2(IMissingInstanceConfigurator`2<FutureState, T> m);
    [CompilerGeneratedAttribute]
private void <MassTransit.Futures.IFutureStateMachineConfigurator.CreateResponseEvent>b__30_3(ConsumeContext`1<T> context);
    [CompilerGeneratedAttribute]
private EventActivityBinder`2<FutureState, RoutingSlipFaulted> <FaultPendingRoutingSlip>b__35_2(EventActivityBinder`2<FutureState, RoutingSlipFaulted> faulted);
    [CompilerGeneratedAttribute]
private Task <FaultPendingRoutingSlip>b__35_3(BehaviorContext`2<FutureState, RoutingSlipFaulted> context);
}
[ExtensionAttribute]
public static class MassTransit.FutureExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, T> InitializeFuture(EventActivityBinder`2<FutureState, T> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, T> AddSubscription(EventActivityBinder`2<FutureState, T> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, T> SetResult(EventActivityBinder`2<FutureState, T> binder, Func`2<BehaviorContext`2<FutureState, T>, Guid> getResultId, AsyncEventMessageFactory`3<FutureState, T, TResult> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, T> SetResult(EventActivityBinder`2<FutureState, T> binder, Func`2<BehaviorContext`2<FutureState, T>, Guid> getResultId, EventMessageFactory`3<FutureState, T, TResult> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, Fault`1<T>> SetFault(EventActivityBinder`2<FutureState, Fault`1<T>> binder, Func`2<BehaviorContext`2<FutureState, Fault`1<T>>, Guid> getResultId, EventMessageFactory`3<FutureState, Fault`1<T>, TResult> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, RoutingSlipFaulted> SetFault(EventActivityBinder`2<FutureState, RoutingSlipFaulted> binder, EventMessageFactory`3<FutureState, RoutingSlipFaulted, TResult> messageFactory);
}
[IsReadOnlyAttribute]
public class MassTransit.FutureLocation : ValueType {
    public Uri Address;
    public Guid Id;
    private static INewIdFormatter IdFormatter;
    private static INewIdParser IdParser;
    public FutureLocation(Uri location);
    public FutureLocation(Guid id, Uri address);
    private static FutureLocation();
    public static Uri op_Implicit(FutureLocation location);
}
public interface MassTransit.FutureRequestHandle`4 {
    public Event`1<Fault`1<TRequest>> Faulted { get; }
    public abstract virtual Event`1<Fault`1<TRequest>> get_Faulted();
    public abstract virtual FutureResponseHandle`5<TCommand, TResult, TFault, TRequest, T> OnResponseReceived(Action`1<IFutureResponseConfigurator`2<TResult, T>> configure);
}
public interface MassTransit.FutureResponseHandle`5 {
    public Event`1<TResponse> Completed { get; }
    public abstract virtual Event`1<TResponse> get_Completed();
}
[ExtensionAttribute]
public static class MassTransit.FutureResultConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void SetCompleted(IFutureResultConfigurator`2<TResult, TInput> configurator);
}
public interface MassTransit.FutureRoutingSlipHandle {
    public Event`1<RoutingSlipFaulted> Faulted { get; }
    public Event`1<RoutingSlipCompleted> Completed { get; }
    public abstract virtual Event`1<RoutingSlipFaulted> get_Faulted();
    public abstract virtual Event`1<RoutingSlipCompleted> get_Completed();
}
public class MassTransit.Futures.BuildRoutingSlipExecutor`1 : object {
    private BuildItineraryCallback`1<TInput> _buildItinerary;
    [CompilerGeneratedAttribute]
private bool <TrackRoutingSlip>k__BackingField;
    public bool TrackRoutingSlip { get; public set; }
    public BuildRoutingSlipExecutor`1(BuildItineraryCallback`1<TInput> buildItinerary);
    [AsyncStateMachineAttribute("MassTransit.Futures.BuildRoutingSlipExecutor`1/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<FutureState, TInput> context);
    [CompilerGeneratedAttribute]
public bool get_TrackRoutingSlip();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TrackRoutingSlip(bool value);
}
public class MassTransit.Futures.FutureFault`1 : object {
    private static object _defaultValues;
    private ContextMessageFactory`2<BehaviorContext`1<FutureState>, TFault> _factory;
    [CompilerGeneratedAttribute]
private bool <WaitForPending>k__BackingField;
    unknown ContextMessageFactory`2<BehaviorContext`1<FutureState>, TFault> Factory {public set; }
    public bool WaitForPending { get; public set; }
    private static FutureFault`1();
    public void set_Factory(ContextMessageFactory`2<BehaviorContext`1<FutureState>, TFault> value);
    [CompilerGeneratedAttribute]
public bool get_WaitForPending();
    [CompilerGeneratedAttribute]
public void set_WaitForPending(bool value);
    [IteratorStateMachineAttribute("MassTransit.Futures.FutureFault`1/<Validate>d__9")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureFault`1/<SetFaulted>d__10")]
public Task SetFaulted(BehaviorContext`1<FutureState> context);
    private static Task`1<SendTuple`1<TFault>> DefaultFactory(BehaviorContext`1<FutureState> context);
}
public class MassTransit.Futures.FutureFault`3 : object {
    private static object _defaultValues;
    private ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TFault> _factory;
    [CompilerGeneratedAttribute]
private bool <WaitForPending>k__BackingField;
    unknown ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TFault> Factory {public set; }
    public bool WaitForPending { get; public set; }
    private static FutureFault`3();
    public void set_Factory(ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TFault> value);
    [CompilerGeneratedAttribute]
public bool get_WaitForPending();
    [CompilerGeneratedAttribute]
public void set_WaitForPending(bool value);
    [IteratorStateMachineAttribute("MassTransit.Futures.FutureFault`3/<Validate>d__9")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureFault`3/<SetFaulted>d__10")]
public Task SetFaulted(BehaviorContext`2<FutureState, TInput> context);
    private static Task`1<SendTuple`1<TFault>> DefaultFactory(BehaviorContext`2<FutureState, TInput> context);
}
public class MassTransit.Futures.FutureRequest`2 : object {
    private ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TRequest> _factory;
    [CompilerGeneratedAttribute]
private RequestAddressProvider`1<TInput> <AddressProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PendingFutureIdProvider`1<TRequest> <PendingRequestIdProvider>k__BackingField;
    public RequestAddressProvider`1<TInput> AddressProvider { get; public set; }
    public PendingFutureIdProvider`1<TRequest> PendingRequestIdProvider { get; public set; }
    unknown ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TRequest> Factory {public set; }
    [CompilerGeneratedAttribute]
public RequestAddressProvider`1<TInput> get_AddressProvider();
    [CompilerGeneratedAttribute]
public void set_AddressProvider(RequestAddressProvider`1<TInput> value);
    [CompilerGeneratedAttribute]
public PendingFutureIdProvider`1<TRequest> get_PendingRequestIdProvider();
    [CompilerGeneratedAttribute]
public void set_PendingRequestIdProvider(PendingFutureIdProvider`1<TRequest> value);
    public void set_Factory(ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TRequest> value);
    [IteratorStateMachineAttribute("MassTransit.Futures.FutureRequest`2/<Validate>d__12")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private static Uri PublishAddressProvider(BehaviorContext`2<FutureState, T> context);
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureRequest`2/<SendRequest>d__14")]
public Task SendRequest(BehaviorContext`2<FutureState, TInput> context);
    private static Task`1<SendTuple`1<TRequest>> DefaultFactory(BehaviorContext`2<FutureState, TInput> context);
}
public class MassTransit.Futures.FutureResult`2 : object {
    private ContextMessageFactory`2<BehaviorContext`1<FutureState>, TResult> _factory;
    unknown ContextMessageFactory`2<BehaviorContext`1<FutureState>, TResult> Factory {public set; }
    public void set_Factory(ContextMessageFactory`2<BehaviorContext`1<FutureState>, TResult> value);
    [IteratorStateMachineAttribute("MassTransit.Futures.FutureResult`2/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureResult`2/<SetResult>d__4")]
public Task SetResult(BehaviorContext`1<FutureState> context);
}
public class MassTransit.Futures.FutureResult`3 : object {
    private ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TResult> _factory;
    unknown ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TResult> Factory {public set; }
    public void set_Factory(ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, TResult> value);
    [IteratorStateMachineAttribute("MassTransit.Futures.FutureResult`3/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureResult`3/<SetResult>d__4")]
public Task SetResult(BehaviorContext`2<FutureState, TInput> context);
}
[ExtensionAttribute]
public static class MassTransit.Futures.FutureSubscriptionExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureSubscriptionExtensions/<SendMessageToSubscriptions>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> SendMessageToSubscriptions(BehaviorContext`1<FutureState> context, ContextMessageFactory`2<BehaviorContext`1<FutureState>, T> factory, IEnumerable`1<FutureSubscription> subscriptions);
    [AsyncStateMachineAttribute("MassTransit.Futures.FutureSubscriptionExtensions/<SendMessageToSubscriptions>d__1`2")]
[ExtensionAttribute]
public static Task`1<T> SendMessageToSubscriptions(BehaviorContext`2<FutureState, TInput> context, ContextMessageFactory`2<BehaviorContext`2<FutureState, TInput>, T> factory, IEnumerable`1<FutureSubscription> subscriptions);
}
public interface MassTransit.Futures.IFutureStateMachineConfigurator {
    public abstract virtual Event`1<T> CreateResponseEvent();
    public abstract virtual void SetResult(Event`1<T> responseReceived, Func`2<BehaviorContext`2<FutureState, T>, Task> callback);
    public abstract virtual void SetFaulted(Event`1<T> requestCompleted, Func`2<BehaviorContext`2<FutureState, T>, Task> callback);
    public abstract virtual void CompletePendingRequest(Event`1<T> requestCompleted, PendingFutureIdProvider`1<T> pendingIdProvider);
    public abstract virtual void DuringAnyWhen(Event`1<T> whenEvent, Func`2<EventActivityBinder`2<FutureState, T>, EventActivityBinder`2<FutureState, T>> configure);
}
public interface MassTransit.Futures.IRoutingSlipExecutor`1 {
    unknown bool TrackRoutingSlip {public set; }
    public abstract virtual void set_TrackRoutingSlip(bool value);
    public abstract virtual Task Execute(BehaviorContext`2<FutureState, TInput> context);
}
public class MassTransit.Futures.PlanRoutingSlipExecutor`1 : object {
    [CompilerGeneratedAttribute]
private bool <TrackRoutingSlip>k__BackingField;
    public bool TrackRoutingSlip { get; public set; }
    [AsyncStateMachineAttribute("MassTransit.Futures.PlanRoutingSlipExecutor`1/<Execute>d__0")]
public sealed virtual Task Execute(BehaviorContext`2<FutureState, TInput> context);
    [CompilerGeneratedAttribute]
public bool get_TrackRoutingSlip();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TrackRoutingSlip(bool value);
}
[ExtensionAttribute]
public static class MassTransit.FutureStateExtensions : object {
    [ExtensionAttribute]
public static T GetCommand(BehaviorContext`1<FutureState> context);
    [ExtensionAttribute]
public static T ToObject(BehaviorContext`1<FutureState> context, FutureMessage message);
    [ExtensionAttribute]
public static FutureMessage CreateFutureMessage(BehaviorContext`1<FutureState> context, T message);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectResults(BehaviorContext`1<FutureState> context);
    [ExtensionAttribute]
public static void AddSubscription(BehaviorContext`1<FutureState> context);
    [AsyncStateMachineAttribute("MassTransit.FutureStateExtensions/<SetResult>d__5`2")]
[ExtensionAttribute]
public static Task`1<TResult> SetResult(BehaviorContext`2<FutureState, T> context, Guid id, AsyncEventMessageFactory`3<FutureState, T, TResult> factory);
    [AsyncStateMachineAttribute("MassTransit.FutureStateExtensions/<SetResult>d__6`1")]
[ExtensionAttribute]
public static Task`1<TResult> SetResult(BehaviorContext`1<FutureState> context, Guid id, AsyncEventMessageFactory`2<FutureState, TResult> factory);
    [ExtensionAttribute]
public static void SetResult(BehaviorContext`2<FutureState, T> context, Guid id, EventMessageFactory`3<FutureState, T, TResult> factory);
    [ExtensionAttribute]
public static TResult SetResult(BehaviorContext`1<FutureState> context, Guid id, EventMessageFactory`2<FutureState, TResult> factory);
    [ExtensionAttribute]
public static void SetResult(BehaviorContext`1<FutureState> context, Guid id, TResult result);
    [ExtensionAttribute]
public static void SetCompleted(BehaviorContext`1<FutureState> context, Guid id);
    [ExtensionAttribute]
public static void SetFaulted(BehaviorContext`1<FutureState> context, Guid id, Nullable`1<DateTime> timestamp);
    [ExtensionAttribute]
public static void SetFault(BehaviorContext`1<FutureState> context, Guid id, TFault fault, Nullable`1<DateTime> timestamp);
    [ExtensionAttribute]
public static void SetFault(BehaviorContext`2<FutureState, T> context, Guid id, EventMessageFactory`3<FutureState, T, TFault> factory);
    [AsyncStateMachineAttribute("MassTransit.FutureStateExtensions/<SetFault>d__14`2")]
[ExtensionAttribute]
public static Task`1<TFault> SetFault(FutureState future, BehaviorContext`2<FutureState, T> context, Guid id, AsyncEventMessageFactory`3<FutureState, T, TFault> factory);
    [ExtensionAttribute]
public static bool TryGetResult(BehaviorContext`1<FutureState> context, Guid id, T& result);
    [ExtensionAttribute]
public static bool TryGetFault(BehaviorContext`1<FutureState> context, Guid id, T& fault);
}
[ExtensionAttribute]
public static class MassTransit.FutureVariableExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.FutureVariableExtensions/<SetVariable>d__0`2")]
[ExtensionAttribute]
public static Task`1<TValue> SetVariable(BehaviorContext`2<FutureState, T> context, string key, AsyncEventMessageFactory`3<FutureState, T, TValue> factory);
    [AsyncStateMachineAttribute("MassTransit.FutureVariableExtensions/<SetVariable>d__1`1")]
[ExtensionAttribute]
public static Task`1<TValue> SetVariable(BehaviorContext`1<FutureState> context, string key, AsyncEventMessageFactory`2<FutureState, TValue> factory);
    [ExtensionAttribute]
public static TValue SetVariable(BehaviorContext`2<FutureState, T> context, string key, EventMessageFactory`3<FutureState, T, TValue> factory);
    [ExtensionAttribute]
public static TValue SetVariable(BehaviorContext`1<FutureState> context, string key, EventMessageFactory`2<FutureState, TValue> factory);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, TData> SetVariable(EventActivityBinder`2<FutureState, TData> binder, string key, EventMessageFactory`3<FutureState, TData, TValue> valueFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<FutureState> SetVariable(EventActivityBinder`1<FutureState> binder, string key, EventMessageFactory`2<FutureState, TValue> valueFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<FutureState, TData> SetVariable(EventActivityBinder`2<FutureState, TData> binder, string key, AsyncEventMessageFactory`3<FutureState, TData, TValue> valueFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<FutureState> SetVariable(EventActivityBinder`1<FutureState> binder, string key, AsyncEventMessageFactory`2<FutureState, TValue> valueFactory);
    [ExtensionAttribute]
public static void SetVariable(BehaviorContext`1<FutureState> context, string key, TValue value);
    [ExtensionAttribute]
public static bool TryGetVariable(BehaviorContext`1<FutureState> context, string key, T& result);
}
public class MassTransit.GlobalTopology : object {
    private HashSet`1<Type> _notConsumableMessageTypes;
    private IPublishTopologyConfigurator _publish;
    private ConnectHandle _publishToSendHandle;
    private ISendTopologyConfigurator _send;
    public static ISendTopologyConfigurator Send { get; }
    public static IPublishTopologyConfigurator Publish { get; }
    private ISendTopologyConfigurator MassTransit.IGlobalTopology.Send { get; }
    private IPublishTopologyConfigurator MassTransit.IGlobalTopology.Publish { get; }
    public static ISendTopologyConfigurator get_Send();
    public static IPublishTopologyConfigurator get_Publish();
    private sealed virtual override void MassTransit.IGlobalTopology.SeparatePublishFromSend();
    private sealed virtual override ISendTopologyConfigurator MassTransit.IGlobalTopology.get_Send();
    private sealed virtual override IPublishTopologyConfigurator MassTransit.IGlobalTopology.get_Publish();
    private sealed virtual override bool MassTransit.IGlobalTopology.IsConsumableMessageType(Type type);
    private sealed virtual override void MassTransit.IGlobalTopology.MarkMessageTypeNotConsumable(Type type);
    public static void MarkMessageTypeNotConsumable(Type type);
    public static bool IsConsumableMessageType(Type type);
    public static void SeparatePublishFromSend();
    private void ConfigureRoutingSlipCorrelation();
}
[ExtensionAttribute]
public static class MassTransit.HandlerExtensions : object {
    [ExtensionAttribute]
public static void Handler(IReceiveEndpointConfigurator configurator, MessageHandler`1<T> handler, Action`1<IHandlerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectHandler(IConsumePipeConnector connector, MessageHandler`1<T> handler, IBuildPipeConfigurator`1<ConsumeContext`1<T>> configurator);
    [ExtensionAttribute]
public static ConnectHandle ConnectRequestHandler(IRequestPipeConnector connector, Guid requestId, MessageHandler`1<T> handler, IBuildPipeConfigurator`1<ConsumeContext`1<T>> configurator);
}
[ExtensionAttribute]
public static class MassTransit.HandlerRegistrationConfiguratorExtensions : object {
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`2<ConsumeContext`1<T>, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`2<T, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`2<ConsumeContext`1<T>, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`2<T, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`3<ConsumeContext`1<T>, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`3<ConsumeContext`1<T>, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`3<T, T1, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`3<T, T1, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`4<ConsumeContext`1<T>, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`4<ConsumeContext`1<T>, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`4<T, T1, T2, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`4<T, T1, T2, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`5<ConsumeContext`1<T>, T1, T2, T3, Task`1<TResponse>> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`5<T, T1, T2, T3, Task> handler);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddHandler(IRegistrationConfigurator configurator, Func`5<T, T1, T2, T3, Task`1<TResponse>> handler);
}
[ExtensionAttribute]
public static class MassTransit.HealthReportExtensions : object {
    [ExtensionAttribute]
public static string ToJsonString(HealthReport result);
}
[ExtensionAttribute]
public static class MassTransit.HostedServiceConfigurationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Remove, the hosted service is automatically registered. Visit https://masstransit.io/obsolete for details.")]
public static IServiceCollection AddMassTransitHostedService(IServiceCollection services);
    [ExtensionAttribute]
[ObsoleteAttribute("Remove, the hosted service is automatically registered. Visit https://masstransit.io/obsolete for details.")]
public static IServiceCollection AddMassTransitHostedService(IServiceCollection services, bool waitUntilStarted);
    [ExtensionAttribute]
[ObsoleteAttribute("Remove, the hosted service is automatically registered. Visit https://masstransit.io/obsolete for details.")]
public static IServiceCollection AddMassTransitHostedService(IServiceCollection services, bool waitUntilStarted, Nullable`1<TimeSpan> startTimeout, Nullable`1<TimeSpan> stopTimeout);
}
public interface MassTransit.IAsyncBusHandle {
}
public interface MassTransit.IAsyncPipeContextHandle`1 {
    public abstract virtual Task Created(TContext context);
    public abstract virtual Task CreateCanceled();
    public abstract virtual Task CreateFaulted(Exception exception);
    public abstract virtual Task Faulted(Exception exception);
}
public interface MassTransit.IBindConfigurator`1 {
    public abstract virtual void Source(IPipeContextSource`2<T, TLeft> source, Action`1<IBindConfigurator`2<TLeft, T>> configureTarget);
}
public interface MassTransit.IBindConfigurator`2 {
    public IPipeConfigurator`1<TLeft> ContextPipe { get; }
    public abstract virtual IPipeConfigurator`1<TLeft> get_ContextPipe();
}
public interface MassTransit.IBusFactory {
    public abstract virtual IReceiveEndpointConfiguration CreateBusEndpointConfiguration(Action`1<IReceiveEndpointConfigurator> configure);
}
public interface MassTransit.IBusFactorySelector {
}
public interface MassTransit.IBusOutboxConfigurator {
    public abstract virtual void DisableDeliveryService();
}
public interface MassTransit.IBusRegistrationConfigurator {
    public IContainerRegistrar Registrar { get; }
    public abstract virtual IContainerRegistrar get_Registrar();
    [ObsoleteAttribute("Use 'Using[TransportName]' instead. Visit https://masstransit.io/obsolete for details.")]
public abstract virtual void AddBus(Func`2<IBusRegistrationContext, IBusControl> busFactory);
    public abstract virtual void SetBusFactory(T busFactory);
    public abstract virtual void AddRider(Action`1<IRiderRegistrationConfigurator> configure);
    public abstract virtual void AddConfigureEndpointsCallback(ConfigureEndpointsCallback callback);
    public abstract virtual void AddConfigureEndpointsCallback(ConfigureEndpointsProviderCallback callback);
}
public interface MassTransit.IBusRegistrationConfigurator`1 {
    public abstract virtual void AddRider(Action`1<IRiderRegistrationConfigurator`1<TBus>> configure);
}
[NullableContextAttribute("1")]
public interface MassTransit.IBusRegistrationContext {
    public IEndpointNameFormatter EndpointNameFormatter { get; }
    public abstract virtual IEndpointNameFormatter get_EndpointNameFormatter();
    public abstract virtual void ConfigureEndpoints(IReceiveConfigurator`1<T> configurator, IEndpointNameFormatter endpointNameFormatter);
    public abstract virtual void ConfigureEndpoints(IReceiveConfigurator`1<T> configurator, IEndpointNameFormatter endpointNameFormatter, Action`1<IRegistrationFilterConfigurator> configureFilter);
    public abstract virtual IConfigureReceiveEndpoint GetConfigureReceiveEndpoints();
}
public interface MassTransit.ICircuitBreakerConfigurator`1 {
    unknown TimeSpan TrackingPeriod {public set; }
    unknown int TripThreshold {public set; }
    unknown int ActiveThreshold {public set; }
    unknown TimeSpan ResetInterval {public set; }
    unknown IPipeRouter Router {public set; }
    public abstract virtual void set_TrackingPeriod(TimeSpan value);
    public abstract virtual void set_TripThreshold(int value);
    public abstract virtual void set_ActiveThreshold(int value);
    public abstract virtual void set_ResetInterval(TimeSpan value);
    public abstract virtual void set_Router(IPipeRouter value);
}
public interface MassTransit.IDbMessageConsumeTopologyConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.IDispatchConfigurator`1 {
    public abstract virtual void Pipe(Action`1<IPipeConfigurator`1<T>> configurePipe);
}
public interface MassTransit.IEndpointConventionCache`1 {
    public abstract virtual bool TryGetEndpointAddress(Uri& address);
}
public interface MassTransit.IFutureFaultConfigurator`1 {
    public abstract virtual void SetFaultedUsingFactory(EventMessageFactory`2<FutureState, TFault> factoryMethod);
    public abstract virtual void SetFaultedUsingFactory(AsyncEventMessageFactory`2<FutureState, TFault> factoryMethod);
    public abstract virtual void SetFaultedUsingInitializer(InitializerValueProvider valueProvider);
}
public interface MassTransit.IFutureFaultConfigurator`2 {
    public abstract virtual void SetFaultedUsingFactory(EventMessageFactory`3<FutureState, TInput, TFault> factoryMethod);
    public abstract virtual void SetFaultedUsingFactory(AsyncEventMessageFactory`3<FutureState, TInput, TFault> factoryMethod);
    public abstract virtual void SetFaultedUsingInitializer(InitializerValueProvider`1<TInput> valueProvider);
}
public interface MassTransit.IFutureRegistrationConfigurator {
    public abstract virtual IFutureRegistrationConfigurator Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual void ExcludeFromConfigureEndpoints();
}
public interface MassTransit.IFutureRegistrationConfigurator`1 {
    public abstract virtual IFutureRegistrationConfigurator`1<TFuture> Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual IFutureRegistrationConfigurator`1<TFuture> Repository(Action`1<ISagaRepositoryRegistrationConfigurator`1<FutureState>> configure);
}
public interface MassTransit.IFutureRequestConfigurator`3 {
    unknown Uri RequestAddress {public set; }
    public abstract virtual void set_RequestAddress(Uri value);
    public abstract virtual void SetRequestAddressProvider(RequestAddressProvider`1<TInput> provider);
    public abstract virtual void UsingRequestFactory(EventMessageFactory`3<FutureState, TInput, TRequest> factoryMethod);
    public abstract virtual void UsingRequestFactory(AsyncEventMessageFactory`3<FutureState, TInput, TRequest> factoryMethod);
    public abstract virtual void UsingRequestInitializer(InitializerValueProvider`1<TInput> valueProvider);
    public abstract virtual void TrackPendingRequest(PendingFutureIdProvider`1<TRequest> provider);
    public abstract virtual void OnRequestFaulted(Action`1<IFutureFaultConfigurator`2<TFault, Fault`1<TRequest>>> configure);
    public abstract virtual void WhenFaulted(Func`2<EventActivityBinder`2<FutureState, Fault`1<TRequest>>, EventActivityBinder`2<FutureState, Fault`1<TRequest>>> configure);
}
public interface MassTransit.IFutureRequestDefinition`1 {
    public Uri RequestAddress { get; }
    public abstract virtual Uri get_RequestAddress();
}
public interface MassTransit.IFutureResponseConfigurator`2 {
    public abstract virtual void CompletePendingRequest(PendingFutureIdProvider`1<TResponse> provider);
    public abstract virtual void WhenReceived(Func`2<EventActivityBinder`2<FutureState, TResponse>, EventActivityBinder`2<FutureState, TResponse>> configure);
}
public interface MassTransit.IFutureResultConfigurator`1 {
    public abstract virtual void SetCompletedUsingFactory(EventMessageFactory`2<FutureState, TResult> factoryMethod);
    public abstract virtual void SetCompletedUsingFactory(AsyncEventMessageFactory`2<FutureState, TResult> factoryMethod);
    public abstract virtual void SetCompletedUsingInitializer(InitializerValueProvider valueProvider);
}
public interface MassTransit.IFutureResultConfigurator`2 {
    public abstract virtual void SetCompletedUsingFactory(EventMessageFactory`3<FutureState, TInput, TResult> factoryMethod);
    public abstract virtual void SetCompletedUsingFactory(AsyncEventMessageFactory`3<FutureState, TInput, TResult> factoryMethod);
    public abstract virtual void SetCompletedUsingInitializer(InitializerValueProvider`1<TInput> valueProvider);
}
public interface MassTransit.IFutureRoutingSlipConfigurator`3 {
    public abstract virtual void TrackPendingRoutingSlip();
    public abstract virtual void BuildItinerary(BuildItineraryCallback`1<TInput> buildItinerary);
    public abstract virtual void BuildUsingItineraryPlanner();
    public abstract virtual void OnRoutingSlipCompleted(Action`1<IFutureResultConfigurator`2<TResult, RoutingSlipCompleted>> configure);
    public abstract virtual void OnRoutingSlipFaulted(Action`1<IFutureFaultConfigurator`2<TFault, RoutingSlipFaulted>> configure);
    public abstract virtual void WhenRoutingSlipCompleted(Func`2<EventActivityBinder`2<FutureState, RoutingSlipCompleted>, EventActivityBinder`2<FutureState, RoutingSlipCompleted>> configure);
    public abstract virtual void WhenRoutingSlipFaulted(Func`2<EventActivityBinder`2<FutureState, RoutingSlipFaulted>, EventActivityBinder`2<FutureState, RoutingSlipFaulted>> configure);
}
public interface MassTransit.IGlobalTopology {
    public ISendTopologyConfigurator Send { get; }
    public IPublishTopologyConfigurator Publish { get; }
    public abstract virtual ISendTopologyConfigurator get_Send();
    public abstract virtual IPublishTopologyConfigurator get_Publish();
    public abstract virtual void SeparatePublishFromSend();
    public abstract virtual void MarkMessageTypeNotConsumable(Type type);
    public abstract virtual bool IsConsumableMessageType(Type type);
}
public interface MassTransit.IHealthCheckOptionsConfigurator {
    unknown string Name {public set; }
    [ObsoleteAttribute("Use MinimalFailureStatus instead.", "True")]
unknown Nullable`1<HealthStatus> FailureStatus {public set; }
    unknown Nullable`1<HealthStatus> MinimalFailureStatus {public set; }
    public HashSet`1<string> Tags { get; }
    public abstract virtual void set_Name(string value);
    public abstract virtual void set_FailureStatus(Nullable`1<HealthStatus> value);
    public abstract virtual void set_MinimalFailureStatus(Nullable`1<HealthStatus> value);
    public abstract virtual HashSet`1<string> get_Tags();
}
public interface MassTransit.IInMemoryBusFactoryConfigurator {
    [NullableAttribute("1")]
public IInMemoryPublishTopologyConfigurator PublishTopology { get; }
    [NullableContextAttribute("1")]
public abstract virtual IInMemoryPublishTopologyConfigurator get_PublishTopology();
    [NullableContextAttribute("1")]
public abstract virtual void Publish(Action`1<IInMemoryMessagePublishTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public abstract virtual void Publish(Type messageType, Action`1<IInMemoryMessagePublishTopologyConfigurator> configure);
    public abstract virtual void Host(Action`1<IInMemoryHostConfigurator> configure);
    [NullableContextAttribute("1")]
public abstract virtual void Host(Uri baseAddress, Action`1<IInMemoryHostConfigurator> configure);
}
public interface MassTransit.IInMemoryBusTopology {
    public abstract virtual IInMemoryMessagePublishTopology`1<T> Publish();
}
public interface MassTransit.IInMemoryConsumeTopology {
    public abstract virtual IInMemoryMessageConsumeTopology`1<T> GetMessageTopology();
    public abstract virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
}
public interface MassTransit.IInMemoryConsumeTopologyConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual IInMemoryMessageConsumeTopologyConfigurator`1<T> GetMessageTopology();
    [NullableContextAttribute("1")]
public abstract virtual void AddSpecification(IInMemoryConsumeTopologySpecification specification);
    [NullableContextAttribute("1")]
public abstract virtual void Bind(string exchangeName, ExchangeType exchangeType, string routingKey);
}
public interface MassTransit.IInMemoryHostConfigurator {
}
public interface MassTransit.IInMemoryMessageConsumeTopology`1 {
}
public interface MassTransit.IInMemoryMessageConsumeTopologyConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
}
public interface MassTransit.IInMemoryMessageConsumeTopologyConfigurator`1 {
    [NullableContextAttribute("2")]
public abstract virtual void Bind(Nullable`1<ExchangeType> exchangeType, string routingKey);
}
public interface MassTransit.IInMemoryMessagePublishTopology {
    public abstract virtual void Apply(IMessageFabricPublishTopologyBuilder builder);
}
public interface MassTransit.IInMemoryMessagePublishTopology`1 {
    public ExchangeType ExchangeType { get; }
    public abstract virtual ExchangeType get_ExchangeType();
}
public interface MassTransit.IInMemoryMessagePublishTopologyConfigurator {
}
public interface MassTransit.IInMemoryMessagePublishTopologyConfigurator`1 {
    unknown ExchangeType ExchangeType {public set; }
    public abstract virtual void set_ExchangeType(ExchangeType value);
}
public interface MassTransit.IInMemoryPublishTopology {
    public abstract virtual IInMemoryMessagePublishTopology`1<T> GetMessageTopology();
}
public interface MassTransit.IInMemoryPublishTopologyConfigurator {
    public abstract virtual IInMemoryMessagePublishTopologyConfigurator`1<T> GetMessageTopology();
    public abstract virtual IInMemoryMessagePublishTopologyConfigurator GetMessageTopology(Type messageType);
}
public interface MassTransit.IInMemoryReceiveEndpointConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual void Bind(string exchangeName, ExchangeType exchangeType, string routingKey);
    [NullableContextAttribute("1")]
public abstract virtual void Bind(ExchangeType exchangeType, string routingKey);
}
public interface MassTransit.IItineraryPlanner`1 {
    public abstract virtual Task PlanItinerary(BehaviorContext`2<FutureState, TInput> value, IItineraryBuilder builder);
}
public interface MassTransit.IJobSagaOptionsConfigurator {
    unknown TimeSpan SlotWaitTime {public set; }
    unknown TimeSpan StatusCheckInterval {public set; }
    unknown TimeSpan SlotRequestTimeout {public set; }
    unknown TimeSpan StartJobTimeout {public set; }
    unknown int SuspectJobRetryCount {public set; }
    unknown TimeSpan SuspectJobRetryDelay {public set; }
    unknown Nullable`1<int> SagaPartitionCount {public set; }
    unknown bool FinalizeCompleted {public set; }
    public abstract virtual void set_SlotWaitTime(TimeSpan value);
    public abstract virtual void set_StatusCheckInterval(TimeSpan value);
    public abstract virtual void set_SlotRequestTimeout(TimeSpan value);
    public abstract virtual void set_StartJobTimeout(TimeSpan value);
    public abstract virtual void set_SuspectJobRetryCount(int value);
    public abstract virtual void set_SuspectJobRetryDelay(TimeSpan value);
    public abstract virtual void set_SagaPartitionCount(Nullable`1<int> value);
    public abstract virtual void set_FinalizeCompleted(bool value);
}
public interface MassTransit.IJobSagaRegistrationConfigurator {
    public abstract virtual IJobSagaRegistrationConfigurator Endpoints(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual IJobSagaRegistrationConfigurator JobAttemptEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual IJobSagaRegistrationConfigurator JobEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual IJobSagaRegistrationConfigurator JobTypeEndpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual IJobSagaRegistrationConfigurator UseRepositoryRegistrationProvider(ISagaRepositoryRegistrationProvider registrationProvider);
}
public interface MassTransit.IJobServiceConfigurator {
    unknown ISagaRepository`1<JobTypeSaga> Repository {public set; }
    unknown ISagaRepository`1<JobSaga> JobRepository {public set; }
    unknown ISagaRepository`1<JobAttemptSaga> JobAttemptRepository {public set; }
    unknown string JobServiceStateEndpointName {public set; }
    unknown string JobServiceJobStateEndpointName {public set; }
    unknown string JobServiceJobAttemptStateEndpointName {public set; }
    unknown TimeSpan SlotWaitTime {public set; }
    unknown TimeSpan StatusCheckInterval {public set; }
    unknown int SuspectJobRetryCount {public set; }
    unknown TimeSpan SuspectJobRetryDelay {public set; }
    unknown Nullable`1<int> SagaPartitionCount {public set; }
    unknown bool FinalizeCompleted {public set; }
    public abstract virtual void set_Repository(ISagaRepository`1<JobTypeSaga> value);
    public abstract virtual void set_JobRepository(ISagaRepository`1<JobSaga> value);
    public abstract virtual void set_JobAttemptRepository(ISagaRepository`1<JobAttemptSaga> value);
    public abstract virtual void set_JobServiceStateEndpointName(string value);
    public abstract virtual void set_JobServiceJobStateEndpointName(string value);
    public abstract virtual void set_JobServiceJobAttemptStateEndpointName(string value);
    public abstract virtual void set_SlotWaitTime(TimeSpan value);
    public abstract virtual void set_StatusCheckInterval(TimeSpan value);
    public abstract virtual void set_SuspectJobRetryCount(int value);
    public abstract virtual void set_SuspectJobRetryDelay(TimeSpan value);
    public abstract virtual void set_SagaPartitionCount(Nullable`1<int> value);
    public abstract virtual void set_FinalizeCompleted(bool value);
}
public interface MassTransit.IJobServiceRegistrationConfigurator {
    public abstract virtual IJobServiceRegistrationConfigurator Options(Action`1<JobConsumerOptions> configure);
    public abstract virtual void Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
}
public interface MassTransit.ILatestConfigurator`1 {
    unknown LatestFilterCreated`1<T> Created {public set; }
    public abstract virtual void set_Created(LatestFilterCreated`1<T> value);
}
public interface MassTransit.IMediatorConfigurator {
}
public interface MassTransit.IMediatorRegistrationConfigurator {
    public abstract virtual void ConfigureMediator(Action`2<IMediatorRegistrationContext, IMediatorConfigurator> configure);
}
public interface MassTransit.IMediatorRegistrationContext {
}
public interface MassTransit.IMessageCorrelationId`1 {
    public abstract virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public interface MassTransit.IMissingInstanceRedeliveryConfigurator {
    unknown bool UseMessageScheduler {public set; }
    public abstract virtual void set_UseMessageScheduler(bool value);
}
public interface MassTransit.IMissingInstanceRedeliveryConfigurator`2 {
    public abstract virtual void OnRedeliveryLimitReached(Func`2<IMissingInstanceConfigurator`2<TInstance, TData>, IPipe`1<ConsumeContext`1<TData>>> configure);
}
public class MassTransit.InboxCleanupServiceOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <DuplicateDetectionWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryMessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <QueryTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <QueryDelay>k__BackingField;
    public TimeSpan DuplicateDetectionWindow { get; public set; }
    public int QueryMessageLimit { get; public set; }
    public TimeSpan QueryTimeout { get; public set; }
    public TimeSpan QueryDelay { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_DuplicateDetectionWindow();
    [CompilerGeneratedAttribute]
public void set_DuplicateDetectionWindow(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_QueryMessageLimit();
    [CompilerGeneratedAttribute]
public void set_QueryMessageLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_QueryTimeout();
    [CompilerGeneratedAttribute]
public void set_QueryTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_QueryDelay();
    [CompilerGeneratedAttribute]
public void set_QueryDelay(TimeSpan value);
}
public class MassTransit.Initializers.Contexts.BaseInitializeContext : BasePipeContext {
    public int Depth { get; }
    public InitializeContext Parent { get; }
    public BaseInitializeContext(CancellationToken cancellationToken);
    public virtual int get_Depth();
    public virtual InitializeContext get_Parent();
    public virtual bool TryGetParent(InitializeContext`1& parentContext);
    public sealed virtual InitializeContext`1<T> CreateMessageContext(T message);
}
public class MassTransit.Initializers.Contexts.DynamicInitializeContext`1 : ProxyPipeContext {
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private InitializeContext <Parent>k__BackingField;
    public TMessage Message { get; }
    public Type MessageType { get; }
    public int Depth { get; }
    public InitializeContext Parent { get; }
    public DynamicInitializeContext`1(InitializeContext context, TMessage message);
    [CompilerGeneratedAttribute]
public sealed virtual TMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MessageType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Depth();
    [CompilerGeneratedAttribute]
public sealed virtual InitializeContext get_Parent();
    public sealed virtual InitializeContext`2<TMessage, T> CreateInputContext(T input);
    public sealed virtual bool TryGetParent(InitializeContext`1& parentContext);
    public sealed virtual InitializeContext`1<T> CreateMessageContext(T message);
}
public class MassTransit.Initializers.Contexts.DynamicInitializeContext`2 : DynamicInitializeContext`1<TMessage> {
    [CompilerGeneratedAttribute]
private bool <HasInput>k__BackingField;
    [CompilerGeneratedAttribute]
private TInput <Input>k__BackingField;
    public bool HasInput { get; }
    public TInput Input { get; }
    public DynamicInitializeContext`2(InitializeContext context, TMessage message, TInput input);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasInput();
    [CompilerGeneratedAttribute]
public sealed virtual TInput get_Input();
}
public class MassTransit.Initializers.Contexts.ScopeInitializeContext : ScopePipeContext {
    public int Depth { get; }
    public InitializeContext Parent { get; }
    public ScopeInitializeContext(PipeContext context);
    public virtual int get_Depth();
    public virtual InitializeContext get_Parent();
    public virtual bool TryGetParent(InitializeContext`1& parentContext);
    public sealed virtual InitializeContext`1<T> CreateMessageContext(T message);
}
public class MassTransit.Initializers.Conventions.ConventionTypeCache`1 : object {
    private IInitializerConvention _convention;
    private ConcurrentDictionary`2<Type, Cached<TValue>> _dictionary;
    private IConventionTypeCacheFactory`1<TValue> _typeFactory;
    public ConventionTypeCache`1(IConventionTypeCacheFactory`1<TValue> typeFactory, IInitializerConvention convention);
    private sealed virtual override TResult MassTransit.Initializers.Conventions.IConventionTypeCache<TValue>.GetOrAdd();
    [CompilerGeneratedAttribute]
private Cached<TValue> <MassTransit.Initializers.Conventions.IConventionTypeCache<TValue>.GetOrAdd>b__4_0(Type add);
    [CompilerGeneratedAttribute]
private TValue <MassTransit.Initializers.Conventions.IConventionTypeCache<TValue>.GetOrAdd>b__4_1();
}
public class MassTransit.Initializers.Conventions.DefaultInitializerConvention : InitializerConvention {
}
public class MassTransit.Initializers.Conventions.DefaultInitializerConvention`1 : InitializerConvention`1<TMessage> {
    public DefaultInitializerConvention`1(IInitializerConvention convention);
}
public class MassTransit.Initializers.Conventions.DefaultInitializerConvention`2 : object {
    private IReadOnlyDictionary`2<string, PropertyInfo> _inputProperties;
    private IPropertyProviderFactory`1<TInput> _providerFactory;
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public class MassTransit.Initializers.Conventions.DictionaryInitializerConvention : InitializerConvention {
}
public class MassTransit.Initializers.Conventions.DictionaryInitializerConvention`1 : InitializerConvention`1<TMessage> {
    public DictionaryInitializerConvention`1(IInitializerConvention convention);
}
public class MassTransit.Initializers.Conventions.DictionaryInitializerConvention`3 : object {
    private IPropertyProviderFactory`1<TInput> _providerFactory;
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public interface MassTransit.Initializers.Conventions.IConventionTypeCache`1 {
    public abstract virtual TResult GetOrAdd();
}
public interface MassTransit.Initializers.Conventions.IConventionTypeCacheFactory`1 {
    public abstract virtual TValue Create(IInitializerConvention convention);
}
public interface MassTransit.Initializers.Conventions.IInitializerConvention {
    public abstract virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public abstract virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public abstract virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public interface MassTransit.Initializers.Conventions.IInitializerConvention`1 {
    public abstract virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public abstract virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public abstract virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public interface MassTransit.Initializers.Conventions.IInitializerConvention`2 {
    public abstract virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public abstract virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public abstract virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public interface MassTransit.Initializers.Conventions.IMessageInitializerConvention {
}
public interface MassTransit.Initializers.Conventions.IMessageInputInitializerConvention`1 {
}
public abstract class MassTransit.Initializers.Conventions.InitializerConvention : object {
    private IConventionTypeCache`1<IMessageInitializerConvention> _typeCache;
    protected InitializerConvention(IConventionTypeCacheFactory`1<IMessageInitializerConvention> cacheFactory);
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public abstract class MassTransit.Initializers.Conventions.InitializerConvention`1 : object {
    private IConventionTypeCache`1<IMessageInputInitializerConvention`1<TMessage>> _typeCache;
    protected InitializerConvention`1(IConventionTypeCacheFactory`1<IMessageInputInitializerConvention`1<TMessage>> cacheFactory, IInitializerConvention convention);
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
}
public class MassTransit.Initializers.Factories.DynamicMessageFactory`1 : object {
    public sealed virtual object Create();
    public sealed virtual InitializeContext`1<TMessage> Create(InitializeContext context);
}
public class MassTransit.Initializers.Factories.DynamicMessageFactory`2 : object {
    public sealed virtual InitializeContext`1<TMessage> Create(InitializeContext context);
}
public class MassTransit.Initializers.Factories.HeaderInitializerInspector`3 : object {
    private PropertyInfo _propertyInfo;
    public HeaderInitializerInspector`3(PropertyInfo propertyInfo);
    public sealed virtual bool Apply(IMessageInitializerBuilder`2<TMessage, TInput> builder, IInitializerConvention convention);
}
public interface MassTransit.Initializers.Factories.IHeaderInitializerInspector`2 {
    public abstract virtual bool Apply(IMessageInitializerBuilder`2<TMessage, TInput> builder, IInitializerConvention convention);
}
public interface MassTransit.Initializers.Factories.IMessageInitializerBuilder`2 {
    public abstract virtual void Add(string propertyName, IPropertyInitializer`1<TMessage> initializer);
    public abstract virtual void Add(string propertyName, IPropertyInitializer`2<TMessage, TInput> initializer);
    public abstract virtual void Add(IHeaderInitializer`1<TMessage> initializer);
    public abstract virtual void Add(IHeaderInitializer`2<TMessage, TInput> initializer);
    public abstract virtual bool IsInputPropertyUsed(string propertyName);
    public abstract virtual void SetInputPropertyUsed(string propertyName);
}
public class MassTransit.Initializers.Factories.InputHeaderInitializerInspector`3 : object {
    private PropertyInfo _propertyInfo;
    public InputHeaderInitializerInspector`3(PropertyInfo propertyInfo);
    public sealed virtual bool Apply(IMessageInitializerBuilder`2<TMessage, TInput> builder, IInitializerConvention convention);
}
public interface MassTransit.Initializers.Factories.IPropertyInitializerInspector`2 {
    public abstract virtual bool Apply(IMessageInitializerBuilder`2<TMessage, TInput> builder, IInitializerConvention convention);
}
public class MassTransit.Initializers.Factories.MessageInitializerBuilder`2 : object {
    private List`1<IHeaderInitializer`2<TMessage, TInput>> _headerInitializers;
    private IDictionary`2<string, IPropertyInitializer`2<TMessage, TInput>> _initializers;
    private HashSet`1<string> _inputPropertyUsed;
    private IMessageFactory`1<TMessage> _messageFactory;
    public MessageInitializerBuilder`2(IMessageFactory`1<TMessage> messageFactory);
    public sealed virtual void Add(string propertyName, IPropertyInitializer`1<TMessage> initializer);
    public sealed virtual void Add(string propertyName, IPropertyInitializer`2<TMessage, TInput> initializer);
    public sealed virtual void Add(IHeaderInitializer`1<TMessage> initializer);
    public sealed virtual void Add(IHeaderInitializer`2<TMessage, TInput> initializer);
    public sealed virtual bool IsInputPropertyUsed(string propertyName);
    public sealed virtual void SetInputPropertyUsed(string propertyName);
    public IMessageInitializer`1<TMessage> Build();
}
public class MassTransit.Initializers.Factories.MessageInitializerFactory`2 : object {
    private IInitializerConvention[] _conventions;
    private IMessageFactory`1<TMessage> _messageFactory;
    public MessageInitializerFactory`2(IInitializerConvention[] conventions);
    public MessageInitializerFactory`2(IMessageFactory`1<TMessage> messageFactory, IInitializerConvention[] conventions);
    public sealed virtual IMessageInitializer`1<TMessage> CreateMessageInitializer();
    private static IEnumerable`1<IPropertyInitializerInspector`2<TMessage, TInput>> CreatePropertyInspectors();
    private static IEnumerable`1<IHeaderInitializerInspector`2<TMessage, TInput>> CreateInputHeaderInspectors();
    [IteratorStateMachineAttribute("MassTransit.Initializers.Factories.MessageInitializerFactory`2/<CreateHeaderInspectors>d__7")]
private static IEnumerable`1<IHeaderInitializerInspector`2<TMessage, TInput>> CreateHeaderInspectors();
    private static IHeaderInitializerInspector`2<TMessage, TInput> CreateHeaderInspector(Expression`1<Func`2<SendContext, Nullable`1<Guid>>> expression);
    private static IHeaderInitializerInspector`2<TMessage, TInput> CreateHeaderInspector(Expression`1<Func`2<SendContext, Nullable`1<TimeSpan>>> expression);
    private static IHeaderInitializerInspector`2<TMessage, TInput> CreateHeaderInspector(Expression`1<Func`2<SendContext, Uri>> expression);
    private static IHeaderInitializerInspector`2<TMessage, TInput> CreateHeaderInspector(Expression`1<Func`2<SendContext, bool>> expression);
}
public class MassTransit.Initializers.Factories.PropertyInitializerInspector`3 : object {
    private PropertyInfo _propertyInfo;
    public PropertyInitializerInspector`3(PropertyInfo propertyInfo);
    public sealed virtual bool Apply(IMessageInitializerBuilder`2<TMessage, TInput> builder, IInitializerConvention convention);
}
public class MassTransit.Initializers.HeaderInitializers.CopyHeaderInitializer`3 : object {
    private IWriteProperty`2<SendContext, THeader> _headerProperty;
    private IReadProperty`2<TInput, THeader> _inputProperty;
    public CopyHeaderInitializer`3(PropertyInfo headerPropertyInfo, PropertyInfo inputPropertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
}
public class MassTransit.Initializers.HeaderInitializers.DictionaryCopyHeaderInitializer`3 : object {
    private IWriteProperty`2<SendContext, THeader> _headerProperty;
    private string _key;
    public DictionaryCopyHeaderInitializer`3(PropertyInfo propertyInfo, string key);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
}
public class MassTransit.Initializers.HeaderInitializers.ProviderHeaderInitializer`3 : object {
    private IWriteProperty`2<SendContext, TProperty> _messageProperty;
    private IPropertyProvider`2<TInput, TProperty> _propertyProvider;
    public ProviderHeaderInitializer`3(IPropertyProvider`2<TInput, TProperty> propertyProvider, PropertyInfo propertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
    [AsyncStateMachineAttribute("MassTransit.Initializers.HeaderInitializers.ProviderHeaderInitializer`3/<ApplyAsync>d__4")]
private Task ApplyAsync(SendContext sendContext, Task`1<TProperty> propertyTask);
}
public class MassTransit.Initializers.HeaderInitializers.SetHeaderInitializer`3 : object {
    private string _headerName;
    private IPropertyProvider`2<TInput, THeader> _provider;
    public SetHeaderInitializer`3(string headerName, IPropertyProvider`2<TInput, THeader> provider);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
}
public class MassTransit.Initializers.HeaderInitializers.SetStringHeaderInitializer`2 : object {
    private string _headerName;
    private IReadProperty`2<TInput, string> _inputProperty;
    public SetStringHeaderInitializer`2(string headerName, PropertyInfo propertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
}
public interface MassTransit.Initializers.IHeaderInitializer`1 {
    public abstract virtual Task Apply(InitializeContext`1<TMessage> context, SendContext sendContext);
}
public interface MassTransit.Initializers.IHeaderInitializer`2 {
    public abstract virtual Task Apply(InitializeContext`2<TMessage, TInput> context, SendContext sendContext);
}
public interface MassTransit.Initializers.IMessageFactory {
    public abstract virtual object Create();
}
public interface MassTransit.Initializers.IMessageFactory`1 {
    public abstract virtual InitializeContext`1<TMessage> Create(InitializeContext context);
}
public interface MassTransit.Initializers.IMessageInitializerCache`1 {
    public abstract virtual IMessageInitializer`1<TMessage> GetInitializer(Type objectType);
}
public interface MassTransit.Initializers.IMessageInitializerFactory`1 {
    public abstract virtual IMessageInitializer`1<TMessage> CreateMessageInitializer();
}
public interface MassTransit.Initializers.IPropertyConverter`2 {
    public abstract virtual Task`1<TResult> Convert(InitializeContext`1<T> context, TProperty input);
}
public interface MassTransit.Initializers.IPropertyInitializer`1 {
    public abstract virtual Task Apply(InitializeContext`1<TMessage> context);
}
public interface MassTransit.Initializers.IPropertyInitializer`2 {
    public abstract virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public interface MassTransit.Initializers.IPropertyProvider`2 {
    public abstract virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public interface MassTransit.Initializers.IPropertyProviderFactory`1 {
    public abstract virtual bool TryGetPropertyProvider(PropertyInfo propertyInfo, IPropertyProvider`2& provider);
    public abstract virtual bool TryGetPropertyConverter(IPropertyConverter`2& converter);
}
public interface MassTransit.Initializers.ITypeConverter`2 {
    public abstract virtual bool TryConvert(TInput input, TResult& result);
}
public static class MassTransit.Initializers.MessageFactoryCache`1 : object {
    public static IMessageFactory`1<TMessage> Factory { get; }
    public static IMessageFactory`1<TMessage> get_Factory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MassTransit.Initializers.MessageInitializer : object {
    private static List`1<IInitializerConvention> _conventions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IInitializerConvention[] _conventionsArray;
    public static IInitializerConvention[] Conventions { get; }
    private static MessageInitializer();
    public static IInitializerConvention[] get_Conventions();
    [NullableContextAttribute("0")]
public static void AddConvention();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Initializers.MessageInitializer`2 : object {
    private IMessageFactory`1<TMessage> _factory;
    private IHeaderInitializer`2[] _headerInitializers;
    private IPropertyInitializer`2[] _initializers;
    public MessageInitializer`2(IMessageFactory`1<TMessage> factory, IEnumerable`1<IPropertyInitializer`2<TMessage, TInput>> initializers, IEnumerable`1<IHeaderInitializer`2<TMessage, TInput>> headerInitializers);
    public sealed virtual InitializeContext`1<TMessage> Create(PipeContext context);
    public sealed virtual InitializeContext`1<TMessage> Create(CancellationToken cancellationToken);
    public sealed virtual Task`1<InitializeContext`1<TMessage>> Initialize(object input, CancellationToken cancellationToken);
    public sealed virtual Task`1<InitializeContext`1<TMessage>> Initialize(InitializeContext`1<TMessage> context, object input);
    public sealed virtual Task`1<SendTuple`1<TMessage>> InitializeMessage(PipeContext context, object input, IPipe`1<SendContext`1<TMessage>> pipe);
    public sealed virtual Task`1<SendTuple`1<TMessage>> InitializeMessage(object input, IPipe`1<SendContext`1<TMessage>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Initializers.MessageInitializer`2/<InitializeMessage>d__10")]
public sealed virtual Task`1<SendTuple`1<TMessage>> InitializeMessage(PipeContext context, object input, Object[] moreInputs, IPipe`1<SendContext`1<TMessage>> pipe);
    private Task`1<InitializeContext`1<TMessage>> InitializeMessage(TInput input, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Initializers.MessageInitializer`2/<InitializeMessage>d__12")]
private Task`1<InitializeContext`1<TMessage>> InitializeMessage(InitializeContext`1<TMessage> messageContext, TInput input);
    [AsyncStateMachineAttribute("MassTransit.Initializers.MessageInitializer`2/<PrepareSendTuple>d__13")]
private Task`1<SendTuple`1<TMessage>> PrepareSendTuple(InitializeContext`1<TMessage> messageContext, TInput input, IPipe`1<SendContext`1<TMessage>> pipe);
}
public class MassTransit.Initializers.MessageInitializerCache`1 : object {
    private IDictionary`2<Type, Lazy`1<IMessageInitializer`1<TMessage>>> _initializers;
    private sealed virtual override IMessageInitializer`1<TMessage> MassTransit.Initializers.IMessageInitializerCache<TMessage>.GetInitializer(Type inputType);
    private static IMessageInitializer`1<TMessage> CreateMessageInitializer(Type inputType);
    public static IMessageInitializer`1<TMessage> GetInitializer(Type inputType);
    public static Task`1<InitializeContext`1<TMessage>> Initialize(object values, CancellationToken cancellationToken);
    public static Task`1<SendTuple`1<TMessage>> InitializeMessage(PipeContext context, object values);
    public static Task`1<SendTuple`1<TMessage>> InitializeMessage(PipeContext context, object values, Object[] moreValues, IPipe`1<SendContext`1<TMessage>> pipe);
    public static Task`1<SendTuple`1<TMessage>> InitializeMessage(PipeContext context, object values, IPipe`1<SendContext`1<TMessage>> pipe);
    public static Task`1<SendTuple`1<TMessage>> InitializeMessage(object values, CancellationToken cancellationToken);
    public static Task`1<SendTuple`1<TMessage>> InitializeMessage(object values, IPipe`1<SendContext`1<TMessage>> pipe, CancellationToken cancellationToken);
    public static Task`1<InitializeContext`1<TMessage>> Initialize(InitializeContext`1<TMessage> context, object values);
}
public class MassTransit.Initializers.PropertyConverters.ArrayPropertyConverter`1 : object {
    public sealed virtual Task`1<TElement[]> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<TElement> input);
}
public class MassTransit.Initializers.PropertyConverters.ArrayPropertyConverter`2 : object {
    private static TElement[] _emptyArray;
    private IPropertyConverter`2<TElement, TInputElement> _converter;
    public ArrayPropertyConverter`2(IPropertyConverter`2<TElement, TInputElement> converter);
    private static ArrayPropertyConverter`2();
    public sealed virtual Task`1<TElement[]> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<TInputElement> input);
    private Task`1<TElement[]> ConvertSync(InitializeContext`1<TMessage> context, IEnumerable`1<TInputElement> input);
}
public class MassTransit.Initializers.PropertyConverters.DictionaryKeyPropertyConverter`3 : object {
    private IPropertyConverter`2<TKey, TInputKey> _converter;
    public DictionaryKeyPropertyConverter`3(IPropertyConverter`2<TKey, TInputKey> converter);
    public sealed virtual Task`1<Dictionary`2<TKey, TElement>> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TElement>> input);
    private sealed virtual override Task`1<IDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TElement>> input);
    private sealed virtual override Task`1<IEnumerable`1<KeyValuePair`2<TKey, TElement>>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TElement>> input);
    private sealed virtual override Task`1<IReadOnlyDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TElement>> input);
    private Task`1<Dictionary`2<TKey, TElement>> ConvertSync(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TElement>> input);
}
public class MassTransit.Initializers.PropertyConverters.DictionaryPropertyConverter`2 : object {
    public sealed virtual Task`1<Dictionary`2<TKey, TElement>> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TElement>> input);
    private sealed virtual override Task`1<IDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TElement>> input);
    private sealed virtual override Task`1<IEnumerable`1<KeyValuePair`2<TKey, TElement>>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TElement>> input);
    private sealed virtual override Task`1<IReadOnlyDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TElement>> input);
}
public class MassTransit.Initializers.PropertyConverters.DictionaryPropertyConverter`3 : object {
    private IPropertyConverter`2<TElement, TInputElement> _converter;
    public DictionaryPropertyConverter`3(IPropertyConverter`2<TElement, TInputElement> converter);
    public sealed virtual Task`1<Dictionary`2<TKey, TElement>> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TInputElement>> input);
    private sealed virtual override Task`1<IDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TInputElement>> input);
    private sealed virtual override Task`1<IEnumerable`1<KeyValuePair`2<TKey, TElement>>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TInputElement>> input);
    private sealed virtual override Task`1<IReadOnlyDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TInputElement>> input);
    private Task`1<Dictionary`2<TKey, TElement>> ConvertSync(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TKey, TInputElement>> input);
}
public class MassTransit.Initializers.PropertyConverters.DictionaryPropertyConverter`4 : object {
    private IPropertyConverter`2<TElement, TInputElement> _elementConverter;
    private IPropertyConverter`2<TKey, TInputKey> _keyConverter;
    public DictionaryPropertyConverter`4(IPropertyConverter`2<TKey, TInputKey> keyConverter, IPropertyConverter`2<TElement, TInputElement> elementConverter);
    public sealed virtual Task`1<Dictionary`2<TKey, TElement>> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TInputElement>> input);
    private sealed virtual override Task`1<IDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TInputElement>> input);
    private sealed virtual override Task`1<IEnumerable`1<KeyValuePair`2<TKey, TElement>>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TElement>>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TInputElement>> input);
    private sealed virtual override Task`1<IReadOnlyDictionary`2<TKey, TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyDictionary<TKey,TElement>,System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TInputKey,TInputElement>>>.Convert(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TInputElement>> input);
    private Task`1<Dictionary`2<TKey, TElement>> ConvertSync(InitializeContext`1<TMessage> context, IEnumerable`1<KeyValuePair`2<TInputKey, TInputElement>> input);
}
public class MassTransit.Initializers.PropertyConverters.FromNullablePropertyConverter`1 : object {
    private sealed virtual override Task`1<TResult> MassTransit.Initializers.IPropertyConverter<TResult,TResult?>.Convert(InitializeContext`1<T> context, Nullable`1<TResult> input);
}
public class MassTransit.Initializers.PropertyConverters.FromNullablePropertyConverter`2 : object {
    private IPropertyConverter`2<TResult, TInput> _converter;
    public FromNullablePropertyConverter`2(IPropertyConverter`2<TResult, TInput> converter);
    private sealed virtual override Task`1<TResult> MassTransit.Initializers.IPropertyConverter<TResult,TInput?>.Convert(InitializeContext`1<T> context, Nullable`1<TInput> input);
}
public class MassTransit.Initializers.PropertyConverters.InitializePropertyConverter`1 : object {
    private sealed virtual override Task`1<TProperty> MassTransit.Initializers.IPropertyConverter<TProperty,System.Object>.Convert(InitializeContext`1<TMessage> context, object input);
}
public class MassTransit.Initializers.PropertyConverters.InitializePropertyConverter`2 : object {
    private IMessageInitializer`1<TProperty> _initializer;
    private sealed virtual override Task`1<TProperty> MassTransit.Initializers.IPropertyConverter<TProperty,TInput>.Convert(InitializeContext`1<TMessage> context, TInput input);
}
public class MassTransit.Initializers.PropertyConverters.ListPropertyConverter`1 : object {
    private sealed virtual override Task`1<ICollection`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.ICollection<TElement>,System.Collections.Generic.IEnumerable<TElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TElement> input);
    private sealed virtual override Task`1<IEnumerable`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<TElement>,System.Collections.Generic.IEnumerable<TElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TElement> input);
    private sealed virtual override Task`1<IList`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IList<TElement>,System.Collections.Generic.IEnumerable<TElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TElement> input);
    private sealed virtual override Task`1<IReadOnlyList`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyList<TElement>,System.Collections.Generic.IEnumerable<TElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TElement> input);
    public sealed virtual Task`1<List`1<TElement>> Convert(InitializeContext`1<TMessage> context, IEnumerable`1<TElement> input);
}
public class MassTransit.Initializers.PropertyConverters.ListPropertyConverter`2 : object {
    private IPropertyConverter`2<TElement, TInputElement> _converter;
    public ListPropertyConverter`2(IPropertyConverter`2<TElement, TInputElement> converter);
    public sealed virtual Task`1<ICollection`1<TElement>> Convert(InitializeContext`1<T> context, IEnumerable`1<TInputElement> elements);
    private sealed virtual override Task`1<IEnumerable`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IEnumerable<TElement>,System.Collections.Generic.IEnumerable<TInputElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TInputElement> elements);
    private sealed virtual override Task`1<IList`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IList<TElement>,System.Collections.Generic.IEnumerable<TInputElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TInputElement> elements);
    private sealed virtual override Task`1<IReadOnlyList`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.IReadOnlyList<TElement>,System.Collections.Generic.IEnumerable<TInputElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TInputElement> elements);
    private sealed virtual override Task`1<List`1<TElement>> MassTransit.Initializers.IPropertyConverter<System.Collections.Generic.List<TElement>,System.Collections.Generic.IEnumerable<TInputElement>>.Convert(InitializeContext`1<T> context, IEnumerable`1<TInputElement> elements);
    private Task`1<List`1<TElement>> ConvertSync(InitializeContext`1<TMessage> context, IEnumerable`1<TInputElement> input);
}
public class MassTransit.Initializers.PropertyConverters.MessageDataPropertyConverter : object {
    public static MessageDataPropertyConverter Instance;
    private static MessageDataPropertyConverter();
    public sealed virtual Task`1<MessageData`1<Byte[]>> Convert(InitializeContext`1<T> context, Byte[] input);
    public sealed virtual Task`1<MessageData`1<Byte[]>> Convert(InitializeContext`1<T> context, MessageData`1<Byte[]> input);
    [AsyncStateMachineAttribute("MassTransit.Initializers.PropertyConverters.MessageDataPropertyConverter/<MassTransit-Initializers-IPropertyConverter<MassTransit-MessageData<System-Byte[]>,MassTransit-MessageData<System-String>>-Convert>d__4`1")]
private sealed virtual override Task`1<MessageData`1<Byte[]>> MassTransit.Initializers.IPropertyConverter<MassTransit.MessageData<System.Byte[]>,MassTransit.MessageData<System.String>>.Convert(InitializeContext`1<T> context, MessageData`1<string> input);
    private sealed virtual override Task`1<MessageData`1<Byte[]>> MassTransit.Initializers.IPropertyConverter<MassTransit.MessageData<System.Byte[]>,System.String>.Convert(InitializeContext`1<T> context, string input);
    public sealed virtual Task`1<MessageData`1<Stream>> Convert(InitializeContext`1<T> context, MessageData`1<Stream> input);
    public sealed virtual Task`1<MessageData`1<Stream>> Convert(InitializeContext`1<T> context, Stream input);
    private sealed virtual override Task`1<MessageData`1<string>> MassTransit.Initializers.IPropertyConverter<MassTransit.MessageData<System.String>,MassTransit.MessageData<System.String>>.Convert(InitializeContext`1<T> context, MessageData`1<string> input);
    private sealed virtual override Task`1<MessageData`1<string>> MassTransit.Initializers.IPropertyConverter<MassTransit.MessageData<System.String>,System.String>.Convert(InitializeContext`1<T> context, string input);
}
public class MassTransit.Initializers.PropertyConverters.MessageDataPropertyConverter`1 : object {
    public sealed virtual Task`1<MessageData`1<TValue>> Convert(InitializeContext`1<T> context, MessageData`1<TValue> input);
    public sealed virtual Task`1<MessageData`1<TValue>> Convert(InitializeContext`1<T1> context, TValue input);
}
public class MassTransit.Initializers.PropertyConverters.StatePropertyConverter`1 : object {
    public sealed virtual Task`1<string> Convert(InitializeContext`1<T> context, State`1<TInstance> input);
}
public class MassTransit.Initializers.PropertyConverters.StatePropertyConverter`2 : object {
    private IPropertyConverter`2<TResult, string> _propertyConverter;
    public StatePropertyConverter`2(IPropertyConverter`2<TResult, string> propertyConverter);
    public sealed virtual Task`1<TResult> Convert(InitializeContext`1<T> context, State`1<TInstance> input);
}
public class MassTransit.Initializers.PropertyConverters.TaskPropertyConverter`1 : object {
    public sealed virtual Task`1<Task`1<TResult>> Convert(InitializeContext`1<TMessage> context, TResult input);
    private sealed virtual override Task`1<TResult> MassTransit.Initializers.IPropertyConverter<TResult,System.Threading.Tasks.Task<TResult>>.Convert(InitializeContext`1<T> context, Task`1<TResult> input);
}
public class MassTransit.Initializers.PropertyConverters.TaskPropertyConverter`2 : object {
    private IPropertyConverter`2<TResult, TInput> _converter;
    public TaskPropertyConverter`2(IPropertyConverter`2<TResult, TInput> converter);
    public sealed virtual Task`1<Task`1<TResult>> Convert(InitializeContext`1<T> context, TInput input);
    private sealed virtual override Task`1<TResult> MassTransit.Initializers.IPropertyConverter<TResult,System.Threading.Tasks.Task<TInput>>.Convert(InitializeContext`1<T> context, Task`1<TInput> input);
}
public class MassTransit.Initializers.PropertyConverters.ToNullablePropertyConverter`1 : object {
    public sealed virtual Task`1<Nullable`1<TResult>> Convert(InitializeContext`1<T> context, TResult input);
}
public class MassTransit.Initializers.PropertyConverters.ToNullablePropertyConverter`2 : object {
    private IPropertyConverter`2<TResult, TInput> _converter;
    public ToNullablePropertyConverter`2(IPropertyConverter`2<TResult, TInput> converter);
    public sealed virtual Task`1<Nullable`1<TResult>> Convert(InitializeContext`1<T> context, TInput input);
}
public class MassTransit.Initializers.PropertyConverters.ToObjectPropertyConverter`1 : object {
    public sealed virtual Task`1<object> Convert(InitializeContext`1<T> context, TInput input);
}
public class MassTransit.Initializers.PropertyConverters.TypePropertyConverter`2 : object {
    private ITypeConverter`2<TResult, TInput> _converter;
    public TypePropertyConverter`2(ITypeConverter`2<TResult, TInput> converter);
    private sealed virtual override Task`1<TResult> MassTransit.Initializers.IPropertyConverter<TResult,TInput>.Convert(InitializeContext`1<TMessage> context, TInput input);
}
public class MassTransit.Initializers.PropertyConverters.VariablePropertyConverter`2 : object {
    public sealed virtual Task`1<TResult> Convert(InitializeContext`1<T> context, TVariable input);
}
public class MassTransit.Initializers.PropertyConverters.VariablePropertyConverter`3 : object {
    private IPropertyConverter`2<TResult, TValue> _propertyConverter;
    public VariablePropertyConverter`3(IPropertyConverter`2<TResult, TValue> propertyConverter);
    public sealed virtual Task`1<TResult> Convert(InitializeContext`1<T> context, TVariable input);
}
public class MassTransit.Initializers.PropertyInitializers.CopyAsyncObjectPropertyInitializer`3 : object {
    private IReadProperty`2<TInput, Task`1<TInputProperty>> _inputProperty;
    private IWriteProperty`2<TMessage, object> _messageProperty;
    public CopyAsyncObjectPropertyInitializer`3(PropertyInfo messagePropertyInfo, PropertyInfo inputPropertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public class MassTransit.Initializers.PropertyInitializers.CopyObjectPropertyInitializer`3 : object {
    private IReadProperty`2<TInput, TInputProperty> _inputProperty;
    private IWriteProperty`2<TMessage, object> _messageProperty;
    public CopyObjectPropertyInitializer`3(PropertyInfo messagePropertyInfo, PropertyInfo inputPropertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public class MassTransit.Initializers.PropertyInitializers.CopyPropertyInitializer`3 : object {
    private IReadProperty`2<TInput, TProperty> _inputProperty;
    private IWriteProperty`2<TMessage, TProperty> _messageProperty;
    public CopyPropertyInitializer`3(PropertyInfo messagePropertyInfo, PropertyInfo inputPropertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public class MassTransit.Initializers.PropertyInitializers.DictionaryCopyPropertyInitializer`3 : object {
    private string _key;
    private IWriteProperty`2<TMessage, TProperty> _messageProperty;
    public DictionaryCopyPropertyInitializer`3(PropertyInfo propertyInfo, string key);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public class MassTransit.Initializers.PropertyInitializers.ProviderPropertyInitializer`3 : object {
    private IWriteProperty`2<TMessage, TProperty> _messageProperty;
    private IPropertyProvider`2<TInput, TProperty> _propertyProvider;
    public ProviderPropertyInitializer`3(IPropertyProvider`2<TInput, TProperty> propertyProvider, PropertyInfo propertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.AsyncPropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, Task`1<TProperty>> _provider;
    public AsyncPropertyProvider`2(IPropertyProvider`2<TInput, Task`1<TProperty>> provider);
    private sealed virtual override Task`1<TProperty> MassTransit.Initializers.IPropertyProvider<TInput,TProperty>.GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.AsyncPropertyProvider`3 : object {
    private IPropertyConverter`2<TProperty, TTask> _converter;
    private IPropertyProvider`2<TInput, Task`1<TTask>> _provider;
    public AsyncPropertyProvider`3(IPropertyProvider`2<TInput, Task`1<TTask>> provider, IPropertyConverter`2<TProperty, TTask> converter);
    private sealed virtual override Task`1<TProperty> MassTransit.Initializers.IPropertyProvider<TInput,TProperty>.GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.ConstantPropertyProvider`2 : object {
    private Task`1<TProperty> _propertyValue;
    public ConstantPropertyProvider`2(TProperty propertyValue);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.FromNullablePropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, Nullable`1<TProperty>> _provider;
    public FromNullablePropertyProvider`2(IPropertyProvider`2<TInput, Nullable`1<TProperty>> provider);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.InputDictionaryPropertyProvider`2 : object {
    private string _key;
    public InputDictionaryPropertyProvider`2(string key);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.InputPropertyProvider`2 : object {
    private IReadProperty`2<TInput, TProperty> _inputProperty;
    public InputPropertyProvider`2(PropertyInfo propertyInfo);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.ObjectPropertyProvider`2 : object {
    private ConcurrentDictionary`2<Type, Converter<TInput, TProperty>> _converters;
    private IPropertyProviderFactory`1<TInput> _factory;
    private IPropertyProvider`2<TInput, object> _provider;
    public ObjectPropertyProvider`2(IPropertyProviderFactory`1<TInput> factory, IPropertyProvider`2<TInput, object> provider);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
    private Converter<TInput, TProperty> CreateConverter(Type type);
}
public class MassTransit.Initializers.PropertyProviders.PropertyConverterPropertyProvider`3 : object {
    private IPropertyConverter`2<TProperty, TInputProperty> _converter;
    private IPropertyProvider`2<TInput, TInputProperty> _inputProvider;
    public PropertyConverterPropertyProvider`3(IPropertyConverter`2<TProperty, TInputProperty> converter, IPropertyProvider`2<TInput, TInputProperty> inputProvider);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.PropertyProviderFactory`1 : object {
    public sealed virtual bool TryGetPropertyProvider(PropertyInfo propertyInfo, IPropertyProvider`2& provider);
    public sealed virtual bool TryGetPropertyConverter(IPropertyConverter`2& converter);
    private IProviderFactory<TInput> CreateProviderFactory(Type propertyType);
}
public class MassTransit.Initializers.PropertyProviders.TaskPropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, TProperty> _provider;
    public TaskPropertyProvider`2(IPropertyProvider`2<TInput, TProperty> provider);
    public sealed virtual Task`1<Task`1<TProperty>> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.ToNullablePropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, TProperty> _provider;
    public ToNullablePropertyProvider`2(IPropertyProvider`2<TInput, TProperty> provider);
    public sealed virtual Task`1<Nullable`1<TProperty>> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Initializers.PropertyProviders.VariablePropertyProvider`3 : object {
    private IPropertyProvider`2<TInput, TProperty> _provider;
    public VariablePropertyProvider`3(IPropertyProvider`2<TInput, TProperty> provider);
    public sealed virtual Task`1<TValue> GetProperty(InitializeContext`2<T, TInput> context);
}
[ExtensionAttribute]
public static class MassTransit.Initializers.TaskInitializerExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__0`1")]
[ExtensionAttribute]
public static Task`1<string> Select(Task`1<T> task, Func`2<T, string> selector);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__1`1")]
[ExtensionAttribute]
public static Task`1<string> Select(Task`1<T> task, Func`2<T, string> selector, string defaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__2`1")]
[ExtensionAttribute]
public static Task`1<string> Select(Task`1<T> task, Func`2<T, string> selector, Func`1<string> getDefaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__3`1")]
[ExtensionAttribute]
public static Task`1<string> Select(Task`1<T> task, Func`2<T, string> selector, Func`1<Task`1<string>> getDefaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__4`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, TResult> selector);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__5`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, TResult> selector, TResult defaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__6`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, Nullable`1<TResult>> selector, TResult defaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__7`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, TResult> selector, Func`1<TResult> getDefaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__8`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, Nullable`1<TResult>> selector, Func`1<TResult> getDefaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__9`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, TResult> selector, Func`1<Task`1<TResult>> getDefaultValue);
    [AsyncStateMachineAttribute("MassTransit.Initializers.TaskInitializerExtensions/<Select>d__10`2")]
[ExtensionAttribute]
public static Task`1<TResult> Select(Task`1<T> task, Func`2<T, Nullable`1<TResult>> selector, Func`1<Task`1<TResult>> getDefaultValue);
}
public class MassTransit.Initializers.TypeConverters.BooleanTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Boolean& result);
    public sealed virtual bool TryConvert(int input, Boolean& result);
    public sealed virtual bool TryConvert(long input, Boolean& result);
    public sealed virtual bool TryConvert(object input, Boolean& result);
    public sealed virtual bool TryConvert(sbyte input, Boolean& result);
    public sealed virtual bool TryConvert(short input, Boolean& result);
    public sealed virtual bool TryConvert(string input, Boolean& result);
    public sealed virtual bool TryConvert(UInt32 input, Boolean& result);
    public sealed virtual bool TryConvert(ulong input, Boolean& result);
    public sealed virtual bool TryConvert(ushort input, Boolean& result);
    public sealed virtual bool TryConvert(bool input, String& result);
}
public class MassTransit.Initializers.TypeConverters.ByteTypeConverter : object {
    public sealed virtual bool TryConvert(int input, Byte& result);
    public sealed virtual bool TryConvert(long input, Byte& result);
    public sealed virtual bool TryConvert(object input, Byte& result);
    public sealed virtual bool TryConvert(sbyte input, Byte& result);
    public sealed virtual bool TryConvert(short input, Byte& result);
    public sealed virtual bool TryConvert(string input, Byte& result);
    public sealed virtual bool TryConvert(UInt32 input, Byte& result);
    public sealed virtual bool TryConvert(ulong input, Byte& result);
    public sealed virtual bool TryConvert(ushort input, Byte& result);
    public sealed virtual bool TryConvert(byte input, String& result);
}
public class MassTransit.Initializers.TypeConverters.DateTimeOffsetTypeConverter : object {
    public sealed virtual bool TryConvert(object input, DateTimeOffset& result);
    public sealed virtual bool TryConvert(string input, DateTimeOffset& result);
    public sealed virtual bool TryConvert(DateTimeOffset input, Int32& result);
    public sealed virtual bool TryConvert(DateTimeOffset input, Int64& result);
    public sealed virtual bool TryConvert(DateTimeOffset input, String& result);
}
public class MassTransit.Initializers.TypeConverters.DateTimeTypeConverter : object {
    public sealed virtual bool TryConvert(DateTimeOffset input, DateTime& result);
    public sealed virtual bool TryConvert(int input, DateTime& result);
    public sealed virtual bool TryConvert(long input, DateTime& result);
    public sealed virtual bool TryConvert(object input, DateTime& result);
    public sealed virtual bool TryConvert(string input, DateTime& result);
    public sealed virtual bool TryConvert(DateTime input, Int32& result);
    public sealed virtual bool TryConvert(DateTime input, Int64& result);
    public sealed virtual bool TryConvert(DateTime input, String& result);
}
public class MassTransit.Initializers.TypeConverters.DecimalTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Decimal& result);
    public sealed virtual bool TryConvert(int input, Decimal& result);
    public sealed virtual bool TryConvert(long input, Decimal& result);
    public sealed virtual bool TryConvert(object input, Decimal& result);
    public sealed virtual bool TryConvert(sbyte input, Decimal& result);
    public sealed virtual bool TryConvert(short input, Decimal& result);
    public sealed virtual bool TryConvert(string input, Decimal& result);
    public sealed virtual bool TryConvert(UInt32 input, Decimal& result);
    public sealed virtual bool TryConvert(ulong input, Decimal& result);
    public sealed virtual bool TryConvert(ushort input, Decimal& result);
    public sealed virtual bool TryConvert(decimal input, String& result);
}
public class MassTransit.Initializers.TypeConverters.DoubleTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Double& result);
    public sealed virtual bool TryConvert(int input, Double& result);
    public sealed virtual bool TryConvert(long input, Double& result);
    public sealed virtual bool TryConvert(object input, Double& result);
    public sealed virtual bool TryConvert(sbyte input, Double& result);
    public sealed virtual bool TryConvert(short input, Double& result);
    public sealed virtual bool TryConvert(string input, Double& result);
    public sealed virtual bool TryConvert(UInt32 input, Double& result);
    public sealed virtual bool TryConvert(ulong input, Double& result);
    public sealed virtual bool TryConvert(ushort input, Double& result);
    public sealed virtual bool TryConvert(double input, String& result);
}
public class MassTransit.Initializers.TypeConverters.EnumTypeConverter`1 : object {
    public sealed virtual bool TryConvert(byte input, T& result);
    public sealed virtual bool TryConvert(int input, T& result);
    public sealed virtual bool TryConvert(long input, T& result);
    public sealed virtual bool TryConvert(object input, T& result);
    public sealed virtual bool TryConvert(sbyte input, T& result);
    public sealed virtual bool TryConvert(short input, T& result);
    public sealed virtual bool TryConvert(string input, T& result);
    public sealed virtual bool TryConvert(UInt32 input, T& result);
    public sealed virtual bool TryConvert(ulong input, T& result);
    public sealed virtual bool TryConvert(ushort input, T& result);
}
public class MassTransit.Initializers.TypeConverters.ExceptionTypeConverter : object {
    public sealed virtual bool TryConvert(Exception input, ExceptionInfo& result);
    public sealed virtual bool TryConvert(object input, ExceptionInfo& result);
    public sealed virtual bool TryConvert(Exception input, String& result);
}
public class MassTransit.Initializers.TypeConverters.FromNullableTypeConverter`1 : object {
    public sealed virtual bool TryConvert(Nullable`1<T> input, T& result);
}
public class MassTransit.Initializers.TypeConverters.FromNullableTypeConverter`2 : object {
    private ITypeConverter`2<T, TInput> _typeConverter;
    public FromNullableTypeConverter`2(ITypeConverter`2<T, TInput> typeConverter);
    public sealed virtual bool TryConvert(Nullable`1<TInput> input, T& result);
}
public class MassTransit.Initializers.TypeConverters.GuidTypeConverter : object {
    public sealed virtual bool TryConvert(NewId input, Guid& result);
    public sealed virtual bool TryConvert(object input, Guid& result);
    public sealed virtual bool TryConvert(string input, Guid& result);
    public sealed virtual bool TryConvert(Guid input, String& result);
}
public class MassTransit.Initializers.TypeConverters.IntTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Int32& result);
    public sealed virtual bool TryConvert(long input, Int32& result);
    public sealed virtual bool TryConvert(object input, Int32& result);
    public sealed virtual bool TryConvert(sbyte input, Int32& result);
    public sealed virtual bool TryConvert(short input, Int32& result);
    public sealed virtual bool TryConvert(string input, Int32& result);
    public sealed virtual bool TryConvert(UInt32 input, Int32& result);
    public sealed virtual bool TryConvert(ulong input, Int32& result);
    public sealed virtual bool TryConvert(ushort input, Int32& result);
    public sealed virtual bool TryConvert(int input, String& result);
}
public interface MassTransit.Initializers.TypeConverters.ITypeConverterCache {
    public abstract virtual bool TryGetTypeConverter(ITypeConverter`2& typeConverter);
}
public class MassTransit.Initializers.TypeConverters.LongTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Int64& result);
    public sealed virtual bool TryConvert(int input, Int64& result);
    public sealed virtual bool TryConvert(object input, Int64& result);
    public sealed virtual bool TryConvert(sbyte input, Int64& result);
    public sealed virtual bool TryConvert(short input, Int64& result);
    public sealed virtual bool TryConvert(string input, Int64& result);
    public sealed virtual bool TryConvert(UInt32 input, Int64& result);
    public sealed virtual bool TryConvert(ulong input, Int64& result);
    public sealed virtual bool TryConvert(ushort input, Int64& result);
    public sealed virtual bool TryConvert(long input, String& result);
}
public class MassTransit.Initializers.TypeConverters.ShortTypeConverter : object {
    public sealed virtual bool TryConvert(byte input, Int16& result);
    public sealed virtual bool TryConvert(int input, Int16& result);
    public sealed virtual bool TryConvert(long input, Int16& result);
    public sealed virtual bool TryConvert(object input, Int16& result);
    public sealed virtual bool TryConvert(sbyte input, Int16& result);
    public sealed virtual bool TryConvert(string input, Int16& result);
    public sealed virtual bool TryConvert(UInt32 input, Int16& result);
    public sealed virtual bool TryConvert(ulong input, Int16& result);
    public sealed virtual bool TryConvert(ushort input, Int16& result);
    public sealed virtual bool TryConvert(short input, String& result);
}
public class MassTransit.Initializers.TypeConverters.StateTypeConverter : object {
    public sealed virtual bool TryConvert(State input, String& result);
}
public class MassTransit.Initializers.TypeConverters.StringTypeConverter : object {
    public sealed virtual bool TryConvert(object input, String& result);
}
public class MassTransit.Initializers.TypeConverters.TimeSpanTypeConverter : object {
    public sealed virtual bool TryConvert(TimeSpan input, String& result);
    public sealed virtual bool TryConvert(byte input, TimeSpan& result);
    public sealed virtual bool TryConvert(double input, TimeSpan& result);
    public sealed virtual bool TryConvert(int input, TimeSpan& result);
    public sealed virtual bool TryConvert(long input, TimeSpan& result);
    public sealed virtual bool TryConvert(object input, TimeSpan& result);
    public sealed virtual bool TryConvert(sbyte input, TimeSpan& result);
    public sealed virtual bool TryConvert(short input, TimeSpan& result);
    public sealed virtual bool TryConvert(string input, TimeSpan& result);
    public sealed virtual bool TryConvert(UInt32 input, TimeSpan& result);
    public sealed virtual bool TryConvert(ulong input, TimeSpan& result);
    public sealed virtual bool TryConvert(ushort input, TimeSpan& result);
}
public class MassTransit.Initializers.TypeConverters.ToNullableTypeConverter`1 : object {
    public sealed virtual bool TryConvert(T input, Nullable`1& result);
}
public class MassTransit.Initializers.TypeConverters.ToNullableTypeConverter`2 : object {
    private ITypeConverter`2<T, TInput> _typeConverter;
    public ToNullableTypeConverter`2(ITypeConverter`2<T, TInput> typeConverter);
    public sealed virtual bool TryConvert(TInput input, Nullable`1& result);
}
public class MassTransit.Initializers.TypeConverters.ToObjectTypeConverter`1 : object {
    public sealed virtual bool TryConvert(T input, Object& result);
}
public class MassTransit.Initializers.TypeConverters.TypeConverterCache : object {
    private List`1<object> _converters;
    private ConcurrentDictionary`2<Type, object> _typeConverters;
    private sealed virtual override bool MassTransit.Initializers.TypeConverters.ITypeConverterCache.TryGetTypeConverter(ITypeConverter`2& typeConverter);
    private void AddSupportedTypes(Type converterType, Object[] args);
    public static bool TryGetTypeConverter(ITypeConverter`2& typeConverter);
}
public class MassTransit.Initializers.TypeConverters.UriTypeConverter : object {
    public sealed virtual bool TryConvert(Uri input, String& result);
    public sealed virtual bool TryConvert(object input, Uri& result);
    public sealed virtual bool TryConvert(string input, Uri& result);
}
public class MassTransit.Initializers.TypeConverters.VersionTypeConverter : object {
    public sealed virtual bool TryConvert(Version input, String& result);
    public sealed virtual bool TryConvert(object input, Version& result);
    public sealed virtual bool TryConvert(string input, Version& result);
}
public class MassTransit.InitializerValueProvider : MulticastDelegate {
    public InitializerValueProvider(object object, IntPtr method);
    public virtual object Invoke(BehaviorContext`1<FutureState> context);
    public virtual IAsyncResult BeginInvoke(BehaviorContext`1<FutureState> context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class MassTransit.InitializerValueProvider`1 : MulticastDelegate {
    public InitializerValueProvider`1(object object, IntPtr method);
    public virtual object Invoke(BehaviorContext`2<FutureState, TMessage> context);
    public virtual IAsyncResult BeginInvoke(BehaviorContext`2<FutureState, TMessage> context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class MassTransit.InlineFilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInlineFilter(IPipeConfigurator`1<T> configurator, InlineFilterMethod`1<T> inlineFilterMethod);
}
public class MassTransit.InlineFilterMethod`1 : MulticastDelegate {
    public InlineFilterMethod`1(object object, IntPtr method);
    public virtual Task Invoke(T context, IPipe`1<T> next);
    public virtual IAsyncResult BeginInvoke(T context, IPipe`1<T> next, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public static class MassTransit.InMemoryBus : object {
    public static IBusControl Create(Action`1<IInMemoryBusFactoryConfigurator> configure);
    public static IBusControl Create(Uri baseAddress, Action`1<IInMemoryBusFactoryConfigurator> configure);
    public static IMessageTopologyConfigurator CreateMessageTopology();
}
[ExtensionAttribute]
public static class MassTransit.InMemoryConfigurationExtensions : object {
    [ExtensionAttribute]
public static IBusControl CreateUsingInMemory(IBusFactorySelector selector, Action`1<IInMemoryBusFactoryConfigurator> configure);
    [ExtensionAttribute]
public static IBusControl CreateUsingInMemory(IBusFactorySelector selector, Uri baseAddress, Action`1<IInMemoryBusFactoryConfigurator> configure);
    [ExtensionAttribute]
public static void UsingInMemory(IBusRegistrationConfigurator configurator, Action`2<IBusRegistrationContext, IInMemoryBusFactoryConfigurator> configure);
    [ExtensionAttribute]
public static void UsingInMemory(IBusRegistrationConfigurator configurator, Uri baseAddress, Action`2<IBusRegistrationContext, IInMemoryBusFactoryConfigurator> configure);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.InMemoryEndpointAddress : ValueType {
    private static string BindQueueKey;
    private static string QueueNameKey;
    private static string ExchangeTypeKey;
    public string Scheme;
    public string Host;
    public string VirtualHost;
    public string Name;
    public bool BindToQueue;
    public string QueueName;
    public ExchangeType ExchangeType;
    private Uri DebuggerDisplay { get; }
    public InMemoryEndpointAddress(Uri hostAddress, Uri address);
    public InMemoryEndpointAddress(Uri hostAddress, string exchangeName, bool bindToQueue, string queueName, ExchangeType exchangeType);
    private static void ParseLeft(Uri address, String& scheme, String& host, String& virtualHost);
    public static Uri op_Implicit(InMemoryEndpointAddress& address);
    private Uri get_DebuggerDisplay();
    [IteratorStateMachineAttribute("MassTransit.InMemoryEndpointAddress/<GetQueryStringOptions>d__16")]
private IEnumerable`1<string> GetQueryStringOptions();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.InMemoryHostAddress : ValueType {
    private static string InMemorySchema;
    public string Scheme;
    public string Host;
    public string VirtualHost;
    private Uri DebuggerDisplay { get; }
    public InMemoryHostAddress(Uri address);
    private static void ParseLeft(Uri address, String& scheme, String& host, String& virtualHost);
    public static Uri op_Implicit(InMemoryHostAddress& address);
    private Uri get_DebuggerDisplay();
}
[ExtensionAttribute]
public static class MassTransit.InMemoryOutboxConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInMemoryOutbox(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryOutbox(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
public static void UseInMemoryOutbox(IConsumePipeConfigurator configurator, IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryOutbox(IConsumePipeConfigurator configurator, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
public static void UseInMemoryOutbox(IConsumerConfigurator`1<TConsumer> configurator, IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryOutbox(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
public static void UseInMemoryOutbox(ISagaConfigurator`1<TSaga> configurator, IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryOutbox(ISagaConfigurator`1<TSaga> configurator, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
public static void UseInMemoryOutbox(IHandlerConfigurator`1<TMessage> configurator, IRegistrationContext context, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryOutbox(IHandlerConfigurator`1<TMessage> configurator, Action`1<IOutboxConfigurator> configure);
    [ExtensionAttribute]
public static IServiceCollection AddInMemoryInboxOutbox(IServiceCollection collection);
    [ExtensionAttribute]
public static void UseInMemoryInboxOutbox(IReceiveEndpointConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("Obsolete, use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseInMemoryInboxOutbox(IReceiveEndpointConfigurator configurator, IServiceProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.InMemoryPublishTopologyConfigurationExtensions : object {
    [ExtensionAttribute]
public static void AddPublishMessageTypesFromNamespaceContaining(IInMemoryBusFactoryConfigurator configurator, Action`2<IInMemoryMessagePublishTopologyConfigurator, Type> configure, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddPublishMessageTypesFromNamespaceContaining(IInMemoryBusFactoryConfigurator configurator, Type type, Action`2<IInMemoryMessagePublishTopologyConfigurator, Type> configure, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddPublishMessageTypes(IInMemoryBusFactoryConfigurator configurator, IEnumerable`1<Type> messageTypes, Action`2<IInMemoryMessagePublishTopologyConfigurator, Type> configure);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.InMemorySagaRepository`1 : object {
    private SagaRepository`1<TSaga> _repository;
    private IndexedSagaDictionary`1<TSaga> _sagas;
    public SagaInstance`1<TSaga> Item { get; }
    public int Count { get; }
    public SagaInstance`1<TSaga> get_Item(Guid id);
    public int get_Count();
    public sealed virtual Task`1<TSaga> Load(Guid correlationId);
    public sealed virtual Task`1<IEnumerable`1<Guid>> Find(ISagaQuery`1<TSaga> query);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.ISagaRepository<TSaga>.Send(ConsumeContext`1<T> context, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
    private sealed virtual override Task MassTransit.ISagaRepository<TSaga>.SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
}
[ExtensionAttribute]
public static class MassTransit.InMemorySagaRepositoryRegistrationExtensions : object {
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> InMemoryRepository(ISagaRegistrationConfigurator`1<T> configurator);
    [ExtensionAttribute]
public static void SetInMemorySagaRepositoryProvider(IRegistrationConfigurator configurator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.InMemoryTransport.Configuration.ExchangeBindingConsumeTopologySpecification : object {
    private string _exchange;
    private ExchangeType _exchangeType;
    [NullableAttribute("2")]
private string _routingKey;
    public ExchangeBindingConsumeTopologySpecification(string exchange, ExchangeType exchangeType, string routingKey);
    [IteratorStateMachineAttribute("MassTransit.InMemoryTransport.Configuration.ExchangeBindingConsumeTopologySpecification/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryBusConfiguration {
    public IInMemoryHostConfiguration HostConfiguration { get; }
    public IInMemoryEndpointConfiguration BusEndpointConfiguration { get; }
    public abstract virtual IInMemoryHostConfiguration get_HostConfiguration();
    public abstract virtual IInMemoryEndpointConfiguration get_BusEndpointConfiguration();
    public abstract virtual IInMemoryEndpointConfiguration CreateEndpointConfiguration(bool isBusEndpoint);
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryConsumeTopologySpecification {
    public abstract virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryEndpointConfiguration {
    public IInMemoryTopologyConfiguration Topology { get; }
    public abstract virtual IInMemoryTopologyConfiguration get_Topology();
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration {
    unknown Uri BaseAddress {public set; }
    public IInMemoryHostConfigurator Configurator { get; }
    public IInMemoryTransportProvider TransportProvider { get; }
    public IInMemoryBusTopology Topology { get; }
    public abstract virtual void set_BaseAddress(Uri value);
    public abstract virtual IInMemoryHostConfigurator get_Configurator();
    public abstract virtual IInMemoryTransportProvider get_TransportProvider();
    public abstract virtual IInMemoryBusTopology get_Topology();
    public abstract virtual void ApplyEndpointDefinition(IInMemoryReceiveEndpointConfigurator configurator, IEndpointDefinition definition);
    public abstract virtual IInMemoryReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IInMemoryReceiveEndpointConfigurator> configure);
    public abstract virtual IInMemoryReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, IInMemoryEndpointConfiguration endpointConfiguration, Action`1<IInMemoryReceiveEndpointConfigurator> configure);
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryReceiveEndpointConfiguration {
    public IInMemoryReceiveEndpointConfigurator Configurator { get; }
    public abstract virtual IInMemoryReceiveEndpointConfigurator get_Configurator();
    public abstract virtual void Build(IHost host);
}
public interface MassTransit.InMemoryTransport.Configuration.IInMemoryTopologyConfiguration {
    public IInMemoryPublishTopologyConfigurator Publish { get; }
    public IInMemoryConsumeTopologyConfigurator Consume { get; }
    public abstract virtual IInMemoryPublishTopologyConfigurator get_Publish();
    public abstract virtual IInMemoryConsumeTopologyConfigurator get_Consume();
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryBusConfiguration : InMemoryEndpointConfiguration {
    private BusObservable _busObservers;
    [CompilerGeneratedAttribute]
private IInMemoryEndpointConfiguration <BusEndpointConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IInMemoryHostConfiguration <HostConfiguration>k__BackingField;
    private IHostConfiguration MassTransit.Configuration.IBusConfiguration.HostConfiguration { get; }
    private IEndpointConfiguration MassTransit.Configuration.IBusConfiguration.BusEndpointConfiguration { get; }
    private IBusObserver MassTransit.Configuration.IBusConfiguration.BusObservers { get; }
    public IInMemoryEndpointConfiguration BusEndpointConfiguration { get; }
    public IInMemoryHostConfiguration HostConfiguration { get; }
    public InMemoryBusConfiguration(IInMemoryTopologyConfiguration topologyConfiguration, Uri baseAddress);
    private sealed virtual override IHostConfiguration MassTransit.Configuration.IBusConfiguration.get_HostConfiguration();
    private sealed virtual override IEndpointConfiguration MassTransit.Configuration.IBusConfiguration.get_BusEndpointConfiguration();
    private sealed virtual override IBusObserver MassTransit.Configuration.IBusConfiguration.get_BusObservers();
    [CompilerGeneratedAttribute]
public sealed virtual IInMemoryEndpointConfiguration get_BusEndpointConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual IInMemoryHostConfiguration get_HostConfiguration();
    public sealed virtual ConnectHandle ConnectBusObserver(IBusObserver observer);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryBusFactoryConfigurator : BusFactoryConfigurator {
    [NullableAttribute("1")]
private IInMemoryBusConfiguration _busConfiguration;
    [NullableAttribute("1")]
private IInMemoryHostConfiguration _hostConfiguration;
    unknown int TransportConcurrencyLimit {public set; }
    unknown bool AutoStart {public set; }
    [NullableAttribute("1")]
public IInMemoryPublishTopologyConfigurator PublishTopology { get; }
    [NullableContextAttribute("1")]
public InMemoryBusFactoryConfigurator(IInMemoryBusConfiguration busConfiguration);
    public void set_TransportConcurrencyLimit(int value);
    [NullableContextAttribute("1")]
public sealed virtual IReceiveEndpointConfiguration CreateBusEndpointConfiguration(Action`1<IReceiveEndpointConfigurator> configure);
    public virtual void set_AutoStart(bool value);
    [NullableContextAttribute("1")]
public sealed virtual void Publish(Action`1<IInMemoryMessagePublishTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public sealed virtual void Publish(Type messageType, Action`1<IInMemoryMessagePublishTopologyConfigurator> configure);
    public sealed virtual void Host(Action`1<IInMemoryHostConfigurator> configure);
    [NullableContextAttribute("1")]
public sealed virtual void Host(Uri baseAddress, Action`1<IInMemoryHostConfigurator> configure);
    [NullableContextAttribute("1")]
public sealed virtual IInMemoryPublishTopologyConfigurator get_PublishTopology();
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IInMemoryReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(string queueName, Action`1<IInMemoryReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryEndpointConfiguration : EndpointConfiguration {
    private IInMemoryTopologyConfiguration _topologyConfiguration;
    private IInMemoryTopologyConfiguration MassTransit.InMemoryTransport.Configuration.IInMemoryEndpointConfiguration.Topology { get; }
    protected InMemoryEndpointConfiguration(IInMemoryTopologyConfiguration topologyConfiguration);
    private InMemoryEndpointConfiguration(IInMemoryEndpointConfiguration parentConfiguration, IInMemoryTopologyConfiguration topologyConfiguration, bool isBusEndpoint);
    private sealed virtual override IInMemoryTopologyConfiguration MassTransit.InMemoryTransport.Configuration.IInMemoryEndpointConfiguration.get_Topology();
    public sealed virtual IInMemoryEndpointConfiguration CreateEndpointConfiguration(bool isBusEndpoint);
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryHostConfiguration : BaseHostConfiguration`2<IInMemoryReceiveEndpointConfiguration, IInMemoryReceiveEndpointConfigurator> {
    private IInMemoryBusConfiguration _busConfiguration;
    private InMemoryBusTopology _topology;
    private Recycle`1<IInMemoryTransportProvider> _transportProvider;
    private Uri _hostAddress;
    [CompilerGeneratedAttribute]
private IRetryPolicy <ReceiveTransportRetryPolicy>k__BackingField;
    public Uri HostAddress { get; }
    public IBusTopology Topology { get; }
    public IRetryPolicy ReceiveTransportRetryPolicy { get; }
    unknown Uri BaseAddress {public set; }
    private IInMemoryHostConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.Configurator { get; }
    private IInMemoryTransportProvider MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.TransportProvider { get; }
    private IInMemoryBusTopology MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.Topology { get; }
    public InMemoryHostConfiguration(IInMemoryBusConfiguration busConfiguration, Uri baseAddress, IInMemoryTopologyConfiguration topologyConfiguration);
    public virtual Uri get_HostAddress();
    public virtual IBusTopology get_Topology();
    [CompilerGeneratedAttribute]
public virtual IRetryPolicy get_ReceiveTransportRetryPolicy();
    public sealed virtual void set_BaseAddress(Uri value);
    private sealed virtual override IInMemoryHostConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.get_Configurator();
    private sealed virtual override IInMemoryTransportProvider MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.get_TransportProvider();
    private sealed virtual override IInMemoryBusTopology MassTransit.InMemoryTransport.Configuration.IInMemoryHostConfiguration.get_Topology();
    public sealed virtual void ApplyEndpointDefinition(IInMemoryReceiveEndpointConfigurator configurator, IEndpointDefinition definition);
    public sealed virtual IInMemoryReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IInMemoryReceiveEndpointConfigurator> configure);
    public sealed virtual IInMemoryReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, IInMemoryEndpointConfiguration endpointConfiguration, Action`1<IInMemoryReceiveEndpointConfigurator> configure);
    public virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IInMemoryReceiveEndpointConfigurator> configureEndpoint);
    public virtual void ReceiveEndpoint(string queueName, Action`1<IInMemoryReceiveEndpointConfigurator> configureEndpoint);
    public virtual IReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IReceiveEndpointConfigurator> configure);
    public virtual IHost Build();
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryReceiveEndpointBuilder : ReceiveEndpointBuilder {
    private IInMemoryReceiveEndpointConfiguration _configuration;
    private IInMemoryHostConfiguration _hostConfiguration;
    public InMemoryReceiveEndpointBuilder(IInMemoryHostConfiguration hostConfiguration, IInMemoryReceiveEndpointConfiguration configuration);
    public virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public InMemoryReceiveEndpointContext CreateReceiveEndpointContext();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IInMemoryBusTopology <CreateReceiveEndpointContext>b__4_0();
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryReceiveEndpointConfiguration : ReceiveEndpointConfiguration {
    [NullableAttribute("1")]
private IInMemoryEndpointConfiguration _endpointConfiguration;
    [NullableAttribute("1")]
private IInMemoryHostConfiguration _hostConfiguration;
    [NullableAttribute("1")]
private string _queueName;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Uri <HostAddress>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [NullableAttribute("1")]
private IInMemoryReceiveEndpointConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryReceiveEndpointConfiguration.Configurator { get; }
    [NullableAttribute("1")]
private IInMemoryTopologyConfiguration MassTransit.InMemoryTransport.Configuration.IInMemoryEndpointConfiguration.Topology { get; }
    [NullableAttribute("1")]
public Uri HostAddress { get; }
    [NullableAttribute("1")]
public Uri InputAddress { get; }
    [NullableContextAttribute("1")]
public InMemoryReceiveEndpointConfiguration(IInMemoryHostConfiguration hostConfiguration, string queueName, IInMemoryEndpointConfiguration endpointConfiguration);
    [NullableContextAttribute("1")]
private sealed virtual override IInMemoryReceiveEndpointConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryReceiveEndpointConfiguration.get_Configurator();
    [NullableContextAttribute("1")]
private sealed virtual override IInMemoryTopologyConfiguration MassTransit.InMemoryTransport.Configuration.IInMemoryEndpointConfiguration.get_Topology();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual Uri get_HostAddress();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual Uri get_InputAddress();
    [NullableContextAttribute("1")]
public virtual ReceiveEndpointContext CreateReceiveEndpointContext();
    [NullableContextAttribute("1")]
public sealed virtual void Build(IHost host);
    [NullableContextAttribute("1")]
public sealed virtual void Bind(string exchangeName, ExchangeType exchangeType, string routingKey);
    [NullableContextAttribute("1")]
public sealed virtual void Bind(ExchangeType exchangeType, string routingKey);
    [NullableContextAttribute("1")]
private InMemoryReceiveEndpointContext CreateInMemoryReceiveEndpointContext();
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryRegistrationBusFactory : TransportRegistrationBusFactory`1<IInMemoryReceiveEndpointConfigurator> {
    private InMemoryBusConfiguration _busConfiguration;
    private Action`2<IBusRegistrationContext, IInMemoryBusFactoryConfigurator> _configure;
    public InMemoryRegistrationBusFactory(Uri baseAddress, Action`2<IBusRegistrationContext, IInMemoryBusFactoryConfigurator> configure);
    private InMemoryRegistrationBusFactory(InMemoryBusConfiguration busConfiguration, Action`2<IBusRegistrationContext, IInMemoryBusFactoryConfigurator> configure);
    public virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
}
public class MassTransit.InMemoryTransport.Configuration.InMemoryTopologyConfiguration : object {
    private InMemoryConsumeTopology _consumeTopology;
    private IMessageTopologyConfigurator _messageTopology;
    private IInMemoryPublishTopologyConfigurator _publishTopology;
    private ISendTopologyConfigurator _sendTopology;
    private IMessageTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Message { get; }
    private ISendTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Send { get; }
    private IPublishTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Publish { get; }
    private IConsumeTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Consume { get; }
    private IInMemoryPublishTopologyConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryTopologyConfiguration.Publish { get; }
    private IInMemoryConsumeTopologyConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryTopologyConfiguration.Consume { get; }
    public InMemoryTopologyConfiguration(IMessageTopologyConfigurator messageTopology);
    public InMemoryTopologyConfiguration(IInMemoryTopologyConfiguration topologyConfiguration);
    private sealed virtual override IMessageTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Message();
    private sealed virtual override ISendTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Send();
    private sealed virtual override IPublishTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Publish();
    private sealed virtual override IConsumeTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Consume();
    private sealed virtual override IInMemoryPublishTopologyConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryTopologyConfiguration.get_Publish();
    private sealed virtual override IInMemoryConsumeTopologyConfigurator MassTransit.InMemoryTransport.Configuration.IInMemoryTopologyConfiguration.get_Consume();
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.InMemoryTransport.Configuration.InvalidInMemoryConsumeTopologySpecification : object {
    private string _key;
    private string _message;
    public InvalidInMemoryConsumeTopologySpecification(string key, string message);
    [IteratorStateMachineAttribute("MassTransit.InMemoryTransport.Configuration.InvalidInMemoryConsumeTopologySpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
}
public interface MassTransit.InMemoryTransport.IInMemoryHost {
}
public interface MassTransit.InMemoryTransport.IInMemoryTransportProvider {
    public IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> MessageFabric { get; }
    public abstract virtual IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> get_MessageFabric();
    public abstract virtual Task`1<ISendTransport> CreateSendTransport(ReceiveEndpointContext context, Uri address);
    public abstract virtual Task`1<ISendTransport> CreatePublishTransport(ReceiveEndpointContext context, Uri publishAddress);
    public abstract virtual Uri NormalizeAddress(Uri address);
}
public class MassTransit.InMemoryTransport.InMemoryBusTopology : BusTopology {
    private IInMemoryTopologyConfiguration _configuration;
    public InMemoryBusTopology(IInMemoryHostConfiguration hostConfiguration, IInMemoryTopologyConfiguration configuration);
    public sealed virtual IInMemoryMessagePublishTopology`1<T> Publish();
}
public interface MassTransit.InMemoryTransport.InMemoryConsumeContext {
}
public class MassTransit.InMemoryTransport.InMemoryConsumeTopology : ConsumeTopology {
    private IMessageTopology _messageTopology;
    private IInMemoryPublishTopologyConfigurator _publishTopology;
    private List`1<IInMemoryConsumeTopologySpecification> _specifications;
    public InMemoryConsumeTopology(IMessageTopology messageTopology, IInMemoryPublishTopologyConfigurator publishTopology);
    private sealed virtual override IInMemoryMessageConsumeTopology`1<T> MassTransit.IInMemoryConsumeTopology.GetMessageTopology();
    public sealed virtual void AddSpecification(IInMemoryConsumeTopologySpecification specification);
    public sealed virtual void Bind(string exchangeName, ExchangeType exchangeType, string routingKey);
    private sealed virtual override IInMemoryMessageConsumeTopologyConfigurator`1<T> MassTransit.IInMemoryConsumeTopologyConfigurator.GetMessageTopology();
    public sealed virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
    public virtual IEnumerable`1<ValidationResult> Validate();
    protected virtual IMessageConsumeTopologyConfigurator CreateMessageTopology();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.InMemoryTransport.InMemoryDeliveryContext : object {
    private HashSet`1<IMessageSink`1<InMemoryTransportMessage>> _delivered;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryTransportMessage <Message>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public InMemoryTransportMessage Message { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public Nullable`1<DateTime> EnqueueTime { get; }
    public Nullable`1<long> ReceiverId { get; }
    public InMemoryDeliveryContext(InMemoryTransportMessage message, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual InMemoryTransportMessage get_Message();
    [NullableContextAttribute("2")]
public sealed virtual string get_RoutingKey();
    public sealed virtual Nullable`1<DateTime> get_EnqueueTime();
    public sealed virtual Nullable`1<long> get_ReceiverId();
    public sealed virtual bool WasAlreadyDelivered(IMessageSink`1<InMemoryTransportMessage> sink);
    public sealed virtual void Delivered(IMessageSink`1<InMemoryTransportMessage> sink);
}
public class MassTransit.InMemoryTransport.InMemoryHost : BaseHost {
    private IInMemoryHostConfiguration _hostConfiguration;
    public InMemoryHost(IInMemoryHostConfiguration hostConfiguration, IInMemoryBusTopology busTopology);
    public virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IInMemoryReceiveEndpointConfigurator> configureEndpoint);
    public virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<IInMemoryReceiveEndpointConfigurator> configure);
    protected virtual void Probe(ProbeContext context);
    protected virtual IAgent[] GetAgentHandles();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.InMemoryTransport.InMemoryMessageConsumeTopology`1 : MessageConsumeTopology`1<TMessage> {
    private IMessageTopology`1<TMessage> _messageTopology;
    private IInMemoryPublishTopology _publishTopology;
    private List`1<IInMemoryConsumeTopologySpecification> _specifications;
    public InMemoryMessageConsumeTopology`1(IMessageTopology`1<TMessage> messageTopology, IInMemoryPublishTopologyConfigurator publishTopology);
    public sealed virtual void Apply(IMessageFabricConsumeTopologyBuilder builder);
    [NullableContextAttribute("2")]
public sealed virtual void Bind(Nullable`1<ExchangeType> exchangeType, string routingKey);
    public virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.InMemoryTransport.InMemoryMessageDeadLetterTransport : InMemoryMessageMoveTransport {
    public InMemoryMessageDeadLetterTransport(IMessageExchange`1<InMemoryTransportMessage> exchange);
    public sealed virtual Task Send(ReceiveContext context, string reason);
}
public class MassTransit.InMemoryTransport.InMemoryMessageErrorTransport : InMemoryMessageMoveTransport {
    public InMemoryMessageErrorTransport(IMessageExchange`1<InMemoryTransportMessage> exchange);
    public sealed virtual Task Send(ExceptionReceiveContext context);
}
public class MassTransit.InMemoryTransport.InMemoryMessageMoveTransport : object {
    private IMessageExchange`1<InMemoryTransportMessage> _exchange;
    protected InMemoryMessageMoveTransport(IMessageExchange`1<InMemoryTransportMessage> exchange);
    [AsyncStateMachineAttribute("MassTransit.InMemoryTransport.InMemoryMessageMoveTransport/<Move>d__2")]
protected Task Move(ReceiveContext context, Action`2<InMemoryTransportMessage, IDictionary`2<string, object>> preSend);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.InMemoryTransport.InMemoryMessagePublishTopology`1 : MessagePublishTopology`1<TMessage> {
    private List`1<IInMemoryMessagePublishTopology> _implementedMessageTypes;
    private IMessageTopology`1<TMessage> _messageTopology;
    [CompilerGeneratedAttribute]
private ExchangeType <ExchangeType>k__BackingField;
    public ExchangeType ExchangeType { get; public set; }
    public InMemoryMessagePublishTopology`1(IPublishTopologyConfigurator publishTopology, IMessageTopology`1<TMessage> messageTopology);
    [CompilerGeneratedAttribute]
public sealed virtual ExchangeType get_ExchangeType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExchangeType(ExchangeType value);
    public sealed virtual void Apply(IMessageFabricPublishTopologyBuilder builder);
    public virtual bool TryGetPublishAddress(Uri baseAddress, Uri& publishAddress);
    public void AddImplementedMessageConfigurator(IInMemoryMessagePublishTopologyConfigurator`1<T> configurator, bool direct);
}
public class MassTransit.InMemoryTransport.InMemoryPublishTopology : PublishTopology {
    private IMessageTopology _messageTopology;
    public InMemoryPublishTopology(IMessageTopology messageTopology);
    private sealed virtual override IInMemoryMessagePublishTopology`1<T> MassTransit.IInMemoryPublishTopology.GetMessageTopology();
    private sealed virtual override IInMemoryMessagePublishTopologyConfigurator`1<T> MassTransit.IInMemoryPublishTopologyConfigurator.GetMessageTopology();
    private sealed virtual override IInMemoryMessagePublishTopologyConfigurator MassTransit.IInMemoryPublishTopologyConfigurator.GetMessageTopology(Type messageType);
    protected virtual IMessagePublishTopologyConfigurator CreateMessageTopology();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.InMemoryTransport.InMemoryPublishTransportProvider : object {
    private ReceiveEndpointContext _context;
    private IInMemoryTransportProvider _transportProvider;
    public InMemoryPublishTransportProvider(IInMemoryTransportProvider transportProvider, ReceiveEndpointContext context);
    public sealed virtual Task`1<ISendTransport> GetPublishTransport(Uri publishAddress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.InMemoryTransport.InMemoryReceiveContext : BaseReceiveContext {
    private InMemoryTransportMessage _message;
    [CompilerGeneratedAttribute]
private MessageBody <Body>k__BackingField;
    protected IHeaderProvider HeaderProvider { get; }
    public MessageBody Body { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public InMemoryReceiveContext(InMemoryTransportMessage message, InMemoryReceiveEndpointContext receiveEndpointContext);
    protected virtual IHeaderProvider get_HeaderProvider();
    [CompilerGeneratedAttribute]
public virtual MessageBody get_Body();
    [NullableContextAttribute("2")]
public sealed virtual string get_RoutingKey();
}
public interface MassTransit.InMemoryTransport.InMemoryReceiveEndpointContext {
    public ISendTopology Send { get; }
    public IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> MessageFabric { get; }
    public InMemoryTransportContext TransportContext { get; }
    public abstract virtual ISendTopology get_Send();
    public abstract virtual IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> get_MessageFabric();
    public abstract virtual InMemoryTransportContext get_TransportContext();
    public abstract virtual void ConfigureTopology();
}
public class MassTransit.InMemoryTransport.InMemoryReceiveTransport : object {
    private InMemoryReceiveEndpointContext _context;
    private string _queueName;
    public InMemoryReceiveTransport(InMemoryReceiveEndpointContext context, string queueName);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override ReceiveTransportHandle MassTransit.Transports.IReceiveTransport.Start();
    private sealed virtual override ConnectHandle MassTransit.IReceiveObserverConnector.ConnectReceiveObserver(IReceiveObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IReceiveTransportObserverConnector.ConnectReceiveTransportObserver(IReceiveTransportObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IPublishObserverConnector.ConnectPublishObserver(IPublishObserver observer);
    private sealed virtual override ConnectHandle MassTransit.ISendObserverConnector.ConnectSendObserver(ISendObserver observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.InMemoryTransport.InMemorySendContext`1 : MessageSendContext`1<T> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    [NullableAttribute("2")]
public string RoutingKey { get; public set; }
    public InMemorySendContext`1(T message, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_RoutingKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_RoutingKey(string value);
    public virtual void ReadPropertiesFrom(IReadOnlyDictionary`2<string, object> properties);
    public virtual void WritePropertiesTo(IDictionary`2<string, object> properties);
}
public class MassTransit.InMemoryTransport.InMemorySendTransportContext : BaseSendTransportContext {
    private static DateTimeOffsetTypeConverter _dateTimeOffsetConverter;
    private static DateTimeTypeConverter _dateTimeConverter;
    private IMessageExchange`1<InMemoryTransportMessage> _exchange;
    public string EntityName { get; }
    public string ActivitySystem { get; }
    public InMemorySendTransportContext(IHostConfiguration hostConfiguration, ReceiveEndpointContext context, IMessageExchange`1<InMemoryTransportMessage> exchange);
    private static InMemorySendTransportContext();
    public virtual string get_EntityName();
    public virtual string get_ActivitySystem();
    [AsyncStateMachineAttribute("MassTransit.InMemoryTransport.InMemorySendTransportContext/<CreateSendContext>d__8`1")]
public virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(PipeContext context, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(PipeContext transportContext, SendContext`1<T> sendContext);
    public sealed virtual Task Send(IPipe`1<PipeContext> pipe, CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    private static void SetHeaders(IDictionary`2<string, object> dictionary, Headers headers);
}
public class MassTransit.InMemoryTransport.InMemorySendTransportProvider : object {
    private ReceiveEndpointContext _context;
    private IInMemoryTransportProvider _transportProvider;
    public InMemorySendTransportProvider(IInMemoryTransportProvider transportProvider, ReceiveEndpointContext context);
    public sealed virtual Uri NormalizeAddress(Uri address);
    public sealed virtual Task`1<ISendTransport> GetSendTransport(Uri address);
}
public interface MassTransit.InMemoryTransport.InMemoryTransportContext {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.InMemoryTransport.InMemoryTransportMessage : object {
    private static long _nextSequenceNumber;
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Delay>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public long SequenceNumber { get; }
    public Guid MessageId { get; }
    public Byte[] Body { get; }
    public int DeliveryCount { get; public set; }
    public IDictionary`2<string, object> Headers { get; }
    public Nullable`1<TimeSpan> Delay { get; public set; }
    [NullableAttribute("2")]
public string RoutingKey { get; public set; }
    public InMemoryTransportMessage(Guid messageId, Byte[] body, string contentType);
    [CompilerGeneratedAttribute]
public long get_SequenceNumber();
    [CompilerGeneratedAttribute]
public Guid get_MessageId();
    [CompilerGeneratedAttribute]
public Byte[] get_Body();
    [CompilerGeneratedAttribute]
public int get_DeliveryCount();
    [CompilerGeneratedAttribute]
public void set_DeliveryCount(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Headers();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_RoutingKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
}
public class MassTransit.InMemoryTransport.InMemoryTransportProvider : Agent {
    private IInMemoryHostConfiguration _hostConfiguration;
    private IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> _messageFabric;
    private IInMemoryTopologyConfiguration _topologyConfiguration;
    public IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> MessageFabric { get; }
    public InMemoryTransportProvider(IInMemoryHostConfiguration hostConfiguration, IInMemoryTopologyConfiguration topologyConfiguration);
    public sealed virtual IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> get_MessageFabric();
    [AsyncStateMachineAttribute("MassTransit.InMemoryTransport.InMemoryTransportProvider/<CreateSendTransport>d__6")]
public sealed virtual Task`1<ISendTransport> CreateSendTransport(ReceiveEndpointContext receiveEndpointContext, Uri address);
    public sealed virtual Uri NormalizeAddress(Uri address);
    public sealed virtual Task`1<ISendTransport> CreatePublishTransport(ReceiveEndpointContext receiveEndpointContext, Uri publishAddress);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.InMemoryTransport.InMemoryTransportProvider/<StopAgent>d__10")]
protected virtual Task StopAgent(StopContext context);
    private void ApplyTopologyToMessageFabric(IInMemoryMessagePublishTopology`1<T> publishTopology);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class MassTransit.InMemoryTransport.TransportInMemoryReceiveEndpointContext : BaseReceiveEndpointContext {
    private IInMemoryReceiveEndpointConfiguration _configuration;
    private IInMemoryHostConfiguration _hostConfiguration;
    public ISendTopology Send { get; }
    public IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> MessageFabric { get; }
    public InMemoryTransportContext TransportContext { get; }
    public TransportInMemoryReceiveEndpointContext(IInMemoryHostConfiguration hostConfiguration, IInMemoryReceiveEndpointConfiguration configuration);
    public sealed virtual ISendTopology get_Send();
    public sealed virtual IMessageFabric`2<InMemoryTransportContext, InMemoryTransportMessage> get_MessageFabric();
    public sealed virtual InMemoryTransportContext get_TransportContext();
    public virtual void AddSendAgent(IAgent agent);
    public virtual void AddConsumeAgent(IAgent agent);
    public virtual Exception ConvertException(Exception exception, string message);
    public sealed virtual void ConfigureTopology();
    protected virtual ISendTransportProvider CreateSendTransportProvider();
    protected virtual IPublishTransportProvider CreatePublishTransportProvider();
}
[ExtensionAttribute]
public static class MassTransit.InstanceExtensions : object {
    [ExtensionAttribute]
public static void Instance(IReceiveEndpointConfigurator configurator, object instance);
    [ExtensionAttribute]
public static ConnectHandle ConnectInstance(IConsumePipeConnector connector, object instance);
    [ExtensionAttribute]
public static void Instance(IReceiveEndpointConfigurator configurator, T instance, Action`1<IInstanceConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectInstance(IConsumePipeConnector connector, T instance);
}
[ExtensionAttribute]
public static class MassTransit.InstrumentationConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInstrumentation(IBusFactoryConfigurator configurator, Action`1<InstrumentationOptions> configureOptions, string serviceName);
}
[ExtensionAttribute]
public static class MassTransit.InterceptConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseIntercept(IPipeConfigurator`1<T> configurator, IPipe`1<T> pipe);
}
[ExtensionAttribute]
public static class MassTransit.Internals.AsyncEnumerableExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Internals.AsyncEnumerableExtensions/<ToListAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<IList`1<TElement>> ToListAsync(IAsyncEnumerable`1<TElement> elements);
    [AsyncStateMachineAttribute("MassTransit.Internals.AsyncEnumerableExtensions/<ToListAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<IList`1<TElement>> ToListAsync(IAsyncEnumerable`1<TElement> elements, CancellationToken cancellationToken);
}
public class MassTransit.Internals.Caching.Bucket`2 : object {
    private int _capacity;
    private ConcurrentQueue`1<TCacheValue> _values;
    private IValueTracker`2<TValue, TCacheValue> _valueTracker;
    private int _count;
    public int Count { get; }
    public int Capacity { get; }
    public Bucket`2(IValueTracker`2<TValue, TCacheValue> valueTracker, int capacity);
    public int get_Count();
    public int get_Capacity();
    public sealed virtual Task Add(TCacheValue value);
    [AsyncStateMachineAttribute("MassTransit.Internals.Caching.Bucket`2/<Clear>d__10")]
public Task Clear();
}
public class MassTransit.Internals.Caching.CacheMetrics : ValueType {
    private long _hits;
    private long _misses;
    public double HitRatio { get; }
    private long Total { get; }
    public double get_HitRatio();
    private long get_Total();
    public void Miss();
    public void Hit();
}
public class MassTransit.Internals.Caching.CacheOptions : object {
    private int _capacity;
    [CompilerGeneratedAttribute]
private int <ConcurrencyLevel>k__BackingField;
    public int ConcurrencyLevel { get; public set; }
    public int Capacity { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ConcurrencyLevel();
    [CompilerGeneratedAttribute]
public void set_ConcurrencyLevel(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
}
public class MassTransit.Internals.Caching.CacheValue`1 : object {
    private Action _remove;
    private TaskCompletionSource`1<TValue> _value;
    private Task`1<TValue> _createValue;
    private Queue`1<IPendingValue`1<TValue>> _pending;
    private int _usage;
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsFaultedOrCanceled { get; }
    public int Usage { get; }
    public CacheValue`1(Action remove);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsFaultedOrCanceled();
    public sealed virtual int get_Usage();
    public sealed virtual Task`1<TValue> GetValue(Func`1<IPendingValue`1<TValue>> pendingValueFactory);
    public sealed virtual Task Evict();
    [AsyncStateMachineAttribute("MassTransit.Internals.Caching.CacheValue`1/<CreateValue>d__16")]
private Task`1<TValue> CreateValue(IPendingValue`1<TValue> pendingValue);
    private bool TryTake(IPendingValue`1& pendingValue);
    private void SetResult(TValue value);
    private void SetException(ExceptionDispatchInfo dispatchInfo);
}
public interface MassTransit.Internals.Caching.IBucket`2 {
    public abstract virtual Task Add(TCacheValue value);
}
public interface MassTransit.Internals.Caching.ICache`2 {
    public int Count { get; }
    public double HitRatio { get; }
    public Task`1<IEnumerable`1<TValue>> Values { get; }
    public abstract virtual int get_Count();
    public abstract virtual double get_HitRatio();
    public abstract virtual Task`1<IEnumerable`1<TValue>> get_Values();
    public abstract virtual Task`1<TValue> GetOrAdd(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public abstract virtual Task`1<TValue> Get(TKey key);
    public abstract virtual Task`1<bool> Remove(TKey key);
    public abstract virtual Task Clear();
}
public interface MassTransit.Internals.Caching.ICache`3 {
}
public interface MassTransit.Internals.Caching.ICachePolicy`2 {
    public abstract virtual TCacheValue CreateValue(Action remove);
    public abstract virtual bool IsValid(TCacheValue value);
    public abstract virtual int CheckValue(TCacheValue value);
}
public interface MassTransit.Internals.Caching.ICacheValue {
    public bool HasValue { get; }
    public bool IsFaultedOrCanceled { get; }
    public int Usage { get; }
    public abstract virtual bool get_HasValue();
    public abstract virtual bool get_IsFaultedOrCanceled();
    public abstract virtual int get_Usage();
    public abstract virtual Task Evict();
}
public interface MassTransit.Internals.Caching.ICacheValue`1 {
    public Task`1<TValue> Value { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual Task`1<TValue> GetValue(Func`1<IPendingValue`1<TValue>> pendingValueFactory);
}
public interface MassTransit.Internals.Caching.IPendingValue`1 {
    public Task`1<TValue> Value { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual void SetValue(Task`1<TValue> value);
    public abstract virtual Task`1<TValue> CreateValue();
}
public interface MassTransit.Internals.Caching.ITimeToLiveCacheValue`1 {
    public long Timestamp { get; }
    public abstract virtual long get_Timestamp();
}
public interface MassTransit.Internals.Caching.IValueTracker`2 {
    public int Capacity { get; }
    public abstract virtual int get_Capacity();
    public abstract virtual Task Add(TCacheValue value);
    public abstract virtual Task ReBucket(IBucket`2<TValue, TCacheValue> source, TCacheValue value);
    public abstract virtual Task Clear();
}
public class MassTransit.Internals.Caching.KeyProvider`2 : MulticastDelegate {
    public KeyProvider`2(object object, IntPtr method);
    public virtual TKey Invoke(TValue value);
    public virtual IAsyncResult BeginInvoke(TValue value, AsyncCallback callback, object object);
    public virtual TKey EndInvoke(IAsyncResult result);
}
public class MassTransit.Internals.Caching.MassTransitCache`3 : object {
    private ICachePolicy`2<TValue, TCacheValue> _policy;
    private IValueTracker`2<TValue, TCacheValue> _tracker;
    private ConcurrentDictionary`2<TKey, TCacheValue> _values;
    private CacheMetrics _metrics;
    public int Count { get; }
    public double HitRatio { get; }
    public Task`1<IEnumerable`1<TValue>> Values { get; }
    public MassTransitCache`3(ICachePolicy`2<TValue, TCacheValue> policy, CacheOptions options);
    public sealed virtual int get_Count();
    public sealed virtual double get_HitRatio();
    public sealed virtual Task`1<IEnumerable`1<TValue>> get_Values();
    public sealed virtual Task`1<TValue> Get(TKey key);
    public sealed virtual Task`1<TValue> GetOrAdd(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    [AsyncStateMachineAttribute("MassTransit.Internals.Caching.MassTransitCache`3/<Remove>d__13")]
public sealed virtual Task`1<bool> Remove(TKey key);
    public sealed virtual Task Clear();
    [AsyncStateMachineAttribute("MassTransit.Internals.Caching.MassTransitCache`3/<GetValues>d__15")]
private Task`1<IEnumerable`1<TValue>> GetValues();
    private bool TryGetValue(TKey key, TCacheValue& value);
}
public class MassTransit.Internals.Caching.MissingValueFactory`2 : MulticastDelegate {
    public MissingValueFactory`2(object object, IntPtr method);
    public virtual Task`1<TValue> Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual Task`1<TValue> EndInvoke(IAsyncResult result);
}
public class MassTransit.Internals.Caching.PendingValue`2 : object {
    private MissingValueFactory`2<TKey, TValue> _factory;
    private TKey _key;
    private TaskCompletionSource`1<TValue> _value;
    public Task`1<TValue> Value { get; }
    public PendingValue`2(TKey key, MissingValueFactory`2<TKey, TValue> factory);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual Task`1<TValue> CreateValue();
    public sealed virtual void SetValue(Task`1<TValue> value);
    private static Task`1<TValue> DefaultMissingValueFactory(TKey key);
}
public class MassTransit.Internals.Caching.TimeToLiveCachePolicy`1 : object {
    private long _timeToLive;
    public TimeToLiveCachePolicy`1(TimeSpan timeToLive);
    public sealed virtual ITimeToLiveCacheValue`1<TValue> CreateValue(Action remove);
    public sealed virtual bool IsValid(ITimeToLiveCacheValue`1<TValue> value);
    public sealed virtual int CheckValue(ITimeToLiveCacheValue`1<TValue> value);
}
public class MassTransit.Internals.Caching.TimeToLiveCacheValue`1 : CacheValue`1<TValue> {
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    public long Timestamp { get; public set; }
    public TimeToLiveCacheValue`1(Action remove, long timestamp);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
}
public class MassTransit.Internals.Caching.UsageCachePolicy`1 : object {
    public sealed virtual CacheValue`1<TValue> CreateValue(Action remove);
    public sealed virtual bool IsValid(CacheValue`1<TValue> value);
    public sealed virtual int CheckValue(CacheValue`1<TValue> value);
}
public class MassTransit.Internals.Caching.ValueFactoryException : Exception {
    public ValueFactoryException(string message);
    protected ValueFactoryException(SerializationInfo info, StreamingContext context);
    public ValueFactoryException(string message, Exception innerException);
}
public class MassTransit.Internals.Caching.ValueTracker`2 : object {
    private Bucket`2<TValue, TCacheValue> _new;
    private ICachePolicy`2<TValue, TCacheValue> _policy;
    private Bucket`2<TValue, TCacheValue> _unused;
    private Bucket`2<TValue, TCacheValue> _used;
    public int Capacity { get; }
    public ValueTracker`2(ICachePolicy`2<TValue, TCacheValue> policy, int capacity);
    public sealed virtual int get_Capacity();
    public sealed virtual Task Add(TCacheValue value);
    public sealed virtual Task Clear();
    public sealed virtual Task ReBucket(IBucket`2<TValue, TCacheValue> source, TCacheValue value);
}
[ExtensionAttribute]
public static class MassTransit.Internals.CodePrinter : object {
    private static string _nonPubStatMethods;
    private static string _nonPubInstMethods;
    internal static IObjectToCode DefaultConstantValueToCode;
    private static Type[] TypesImplementedByArray;
    private static CodePrinter();
    [ExtensionAttribute]
public static StringBuilder AppendTypeof(StringBuilder sb, Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static StringBuilder AppendTypeofList(StringBuilder sb, Type[] types, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
internal static StringBuilder AppendMember(StringBuilder sb, MemberInfo member, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendField(StringBuilder sb, FieldInfo field, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendProperty(StringBuilder sb, PropertyInfo property, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendEnum(StringBuilder sb, TEnum value, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static StringBuilder AppendMethod(StringBuilder sb, MethodInfo method, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, Type type, T identity);
    [ExtensionAttribute]
public static string ToCode(Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static string ToCode(bool x);
    [ExtensionAttribute]
public static string ToCode(string x);
    [ExtensionAttribute]
public static string ToEnumValueCode(Type enumType, object x, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static Type[] GetGenericTypeParametersOrArguments(TypeInfo typeInfo);
    [ExtensionAttribute]
public static string ToCommaSeparatedCode(IEnumerable items, IObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToArrayInitializerCode(IEnumerable items, Type itemType, IObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToCode(object x, IObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdent(StringBuilder sb, int lineIdent);
    [ExtensionAttribute]
internal static StringBuilder NewLine(StringBuilder sb, int lineIdent, int identSpaces);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentExpr(StringBuilder sb, Expression expr, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, IReadOnlyList`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
}
[FlagsAttribute]
public enum MassTransit.Internals.CompilerFlags : Enum {
    public int value__;
    public static CompilerFlags Default;
    public static CompilerFlags NoInvocationLambdaInlining;
    public static CompilerFlags EnableDelegateDebugInfo;
    public static CompilerFlags ThrowOnNotSupportedExpression;
}
public class MassTransit.Internals.DynamicImplementationBuilder : object {
    private static MethodAttributes PropertyAccessMethodAttributes;
    private ConcurrentDictionary`2<string, ModuleBuilder> _moduleBuilders;
    private string _proxyNamespaceSuffix;
    private ConcurrentDictionary`2<Type, Lazy`1<Type>> _proxyTypes;
    public sealed virtual Type GetImplementationType(Type interfaceType);
    private Type CreateImplementation(Type interfaceType);
    private static Type CreateTypeFromInterface(ModuleBuilder builder, Type interfaceType);
    private static MethodBuilder GetGetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private static MethodBuilder GetSetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private static CustomAttributeBuilder GetCustomAttributeBuilder(CustomAttributeData data);
    private TResult GetModuleBuilderForType(Type interfaceType, Func`2<ModuleBuilder, TResult> callback);
    [CompilerGeneratedAttribute]
private Lazy`1<Type> <GetImplementationType>b__5_0(Type x);
}
[ExtensionAttribute]
public static class MassTransit.Internals.ExpressionCompiler : object {
    private static Type[] _closureAsASingleParamType;
    private static Type[][] _closureTypePlusParamTypesPool;
    public static ArrayClosure EmptyArrayClosure;
    public static FieldInfo ArrayClosureArrayField;
    public static FieldInfo ArrayClosureWithNonPassedParamsField;
    private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
    private static ExpressionCompiler();
    [ExtensionAttribute]
public static TDelegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static bool CompileFastToIL(LambdaExpression lambdaExpr, ILGenerator il, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Delegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate CompileSys(Expression`1<TDelegate> lambdaExpr);
    [ExtensionAttribute]
public static Delegate CompileSys(LambdaExpression lambdaExpr);
    [ExtensionAttribute]
public static TDelegate CompileFast(Expression`1<TDelegate> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`1<R> CompileFast(Expression`1<Func`1<R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`2<T1, R> CompileFast(Expression`1<Func`2<T1, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`3<T1, T2, R> CompileFast(Expression`1<Func`3<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`4<T1, T2, T3, R> CompileFast(Expression`1<Func`4<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`5<T1, T2, T3, T4, R> CompileFast(Expression`1<Func`5<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> CompileFast(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> CompileFast(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action CompileFast(Expression`1<Action> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`1<T1> CompileFast(Expression`1<Action`1<T1>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`2<T1, T2> CompileFast(Expression`1<Action`2<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`3<T1, T2, T3> CompileFast(Expression`1<Action`3<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`4<T1, T2, T3, T4> CompileFast(Expression`1<Action`4<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`5<T1, T2, T3, T4, T5> CompileFast(Expression`1<Action`5<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> CompileFast(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompile(LambdaExpression lambdaExpr, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs, CompilerFlags flags);
    [ExtensionAttribute]
internal static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ClosureInfo& closureInfo, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithoutClosure(LambdaExpression lambdaExpr, CompilerFlags flags);
    internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IReadOnlyList`1<ParameterExpression> paramExprs, Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags);
    private static Type[] GetClosureTypeToParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes);
    public static bool IsClosureBoundConstant(object value, Type type);
    private static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static void PropagateNonPassedParamsToOuterLambda(ClosureInfo& closure, IReadOnlyList`1<ParameterExpression> paramExprs, IReadOnlyList`1<ParameterExpression> nestedLambdaParamExprs, ParameterExpression[] nestedNonPassedParams);
    private static NestedLambdaInfo FindAlreadyCollectedNestedLambdaInfo(NestedLambdaInfo[] nestedLambdas, LambdaExpression nestedLambdaExpr, NestedLambdaInfo[]& foundInLambdas);
    private static bool TryCompileNestedLambda(ClosureInfo& outerClosureInfo, int nestedLambdaIndex, CompilerFlags setup);
    private static bool TryCollectMemberInitExprConstants(ClosureInfo& closure, MemberInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static bool TryCollectListInitExprConstants(ClosureInfo& closure, ListInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static bool TryCollectTryExprConstants(ClosureInfo& closure, TryExpression tryExpr, IReadOnlyList`1<ParameterExpression> paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    [ExtensionAttribute]
internal static bool IgnoresResult(ParentFlags parent);
    [ExtensionAttribute]
internal static bool EmitPopIfIgnoreResult(ILGenerator il, ParentFlags parent);
}
[ExtensionAttribute]
internal static class MassTransit.Internals.FecHelpers : object {
    [ExtensionAttribute]
public static int GetFirstIndex(IReadOnlyList`1<T> source, T item);
    [ExtensionAttribute]
public static T GetArgument(IReadOnlyList`1<T> source, int index);
    [ExtensionAttribute]
public static ParameterExpression GetParameter(IReadOnlyList`1<ParameterExpression> source, int index);
    [ExtensionAttribute]
public static IReadOnlyList`1<ParameterExpression> ToReadOnlyList(IReadOnlyList`1<ParameterExpression> source);
}
public interface MassTransit.Internals.IDelegateDebugInfo {
    public LambdaExpression Expression { get; }
    public string ExpressionString { get; }
    public string CSharpString { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual string get_ExpressionString();
    public abstract virtual string get_CSharpString();
}
public interface MassTransit.Internals.IImplementationBuilder {
    public abstract virtual Type GetImplementationType(Type interfaceType);
}
[ExtensionAttribute]
public static class MassTransit.Internals.ILGeneratorHacks : object {
    private static Func`3<ILGenerator, Type, int> _getNextLocalVarIndex;
    private static ILGeneratorHacks();
    internal static int PostInc(Int32& i);
    [ExtensionAttribute]
public static int GetNextLocalVarIndex(ILGenerator il, Type t);
}
public interface MassTransit.Internals.IReadProperty`1 {
}
public interface MassTransit.Internals.IReadProperty`2 {
    public abstract virtual TProperty Get(T entity);
}
[NullableContextAttribute("1")]
public interface MassTransit.Internals.IReadPropertyCache`1 {
    [NullableContextAttribute("2")]
public abstract virtual IReadProperty`2<T, TProperty> GetProperty(string name);
    [NullableContextAttribute("2")]
public abstract virtual IReadProperty`2<T, TProperty> GetProperty(PropertyInfo propertyInfo);
    public abstract virtual bool TryGetProperty(string name, IReadProperty`2& property);
}
public interface MassTransit.Internals.IWriteProperty`1 {
    public Type TargetType { get; }
    public abstract virtual Type get_TargetType();
}
public interface MassTransit.Internals.IWriteProperty`2 {
    public abstract virtual void Set(T entity, TProperty value);
}
public interface MassTransit.Internals.IWritePropertyCache`1 {
    public abstract virtual bool CanWrite(string name);
    public abstract virtual IWriteProperty`2<T, TProperty> GetProperty(string name);
    public abstract virtual IWriteProperty`2<T, TProperty> GetProperty(PropertyInfo propertyInfo);
}
internal class MassTransit.Internals.LiveCountArray`1 : ValueType {
    public int Count;
    public T[] Items;
    public LiveCountArray`1(T[] items);
    public T& PushSlot();
    public void PushSlot(T item);
    public void Pop();
    public static T[] Expand(T[] items);
}
public enum MassTransit.Internals.NotSupported : Enum {
    public int value__;
    public static NotSupported NewArrayInit_MultidimensionalArray;
    public static NotSupported Quote;
    public static NotSupported Dynamic;
    public static NotSupported RuntimeVariables;
    public static NotSupported MemberInit_MemberBinding;
    public static NotSupported MemberInit_ListBinding;
    public static NotSupported Try_GotoReturnToTheFollowupLabel;
    public static NotSupported Assign_Target;
    public static NotSupported TypeEqual;
}
public class MassTransit.Internals.NotSupportedExpressionException : InvalidOperationException {
    public NotSupported Reason;
    public NotSupportedExpressionException(NotSupported reason);
    public NotSupportedExpressionException(NotSupported reason, string message);
}
public class MassTransit.Internals.ReadProperty`2 : object {
    private Func`2<T, TProperty> _getMethod;
    public ReadProperty`2(PropertyInfo propertyInfo);
    public sealed virtual TProperty Get(T content);
    [AsyncStateMachineAttribute("MassTransit.Internals.ReadProperty`2/<GenerateExpressionGetMethod>d__3")]
private Task GenerateExpressionGetMethod(MethodInfo getMethod);
    private static Func`2<T, TProperty> CompileGetMethod(MethodInfo getMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Internals.ReadPropertyCache`1 : object {
    private IDictionary`2<string, IReadProperty`1<T>> _properties;
    private IDictionary`2<string, PropertyInfo> _propertyIndex;
    [NullableContextAttribute("2")]
private sealed virtual override IReadProperty`2<T, TProperty> MassTransit.Internals.IReadPropertyCache<T>.GetProperty(string name);
    [NullableContextAttribute("2")]
private sealed virtual override IReadProperty`2<T, TProperty> MassTransit.Internals.IReadPropertyCache<T>.GetProperty(PropertyInfo propertyInfo);
    private sealed virtual override bool MassTransit.Internals.IReadPropertyCache<T>.TryGetProperty(string name, IReadProperty`2& property);
    private IReadProperty`2<T, TProperty> GetReadProperty(string name);
    public static IReadProperty`2<T, TProperty> GetProperty(string name);
    public static bool TryGetProperty(string name, IReadProperty`2& property);
    public static IReadProperty`2<T, TProperty> GetProperty(PropertyInfo propertyInfo);
}
[ExtensionAttribute]
public static class MassTransit.Internals.ToCSharpPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr);
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
public static StringBuilder ToCSharpString(Expression e, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder AddSemicolonIfFits(StringBuilder sb);
    private static bool CanBeReturned(ExpressionType nt);
    [ExtensionAttribute]
private static string GetCSharpName(MemberInfo m);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(LabelTarget target, StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder ToCSharpString(IReadOnlyList`1<MemberBinding> bindings, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder BlockToCSharpString(BlockExpression b, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant, bool inTheLastBlock, BinaryExpression blockResultAssignment);
    private static string OperatorToCSharpString(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
internal static void <ToCSharpString>g__PrintPart|2_0(Expression part, <>c__DisplayClass2_0& , <>c__DisplayClass2_1& );
}
[ExtensionAttribute]
public static class MassTransit.Internals.ToExpressionPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, List`1& paramsExprs, List`1& uniqueExprs, List`1& lts, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(Expression expr, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(ParameterExpression pe, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(LabelTarget lt, StringBuilder sb, List`1<LabelTarget> labelTargets, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<CatchBlock> bs, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(CatchBlock b, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<SwitchCase> items, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(SwitchCase s, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(MemberBinding mb, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(ElementInit ei, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
    [ExtensionAttribute]
internal static StringBuilder CreateExpressionString(Expression e, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, TryPrintConstant tryPrintConstant);
}
[ExtensionAttribute]
internal static class MassTransit.Internals.Tools : object {
    internal static MethodInfo DelegateTargetGetterMethod;
    private static Tools();
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindMethod(Type type, string methodName);
    [ExtensionAttribute]
internal static MethodInfo FindDelegateInvokeMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindNullableGetValueOrDefaultMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindValueGetterMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindNullableHasValueGetterMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
internal static ConstructorInfo FindSingleParamConstructor(Type type, Type paramType);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> xs);
    public static T[] Empty();
    public static Type[] GetParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    public static Type GetFuncOrActionType(Type returnType);
    public static Type GetFuncOrActionType(Type p, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType);
    public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType);
    [ExtensionAttribute]
public static T GetFirst(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T GetFirst(T[] source);
}
public class MassTransit.Internals.TryPrintConstant : MulticastDelegate {
    public TryPrintConstant(object object, IntPtr method);
    public virtual string Invoke(ConstantExpression e);
    public virtual IAsyncResult BeginInvoke(ConstantExpression e, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class MassTransit.Internals.WriteProperty`2 : object {
    private Action`2<T, TProperty> _setMethod;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; }
    public WriteProperty`2(Type implementationType, PropertyInfo propertyInfo);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TargetType();
    public sealed virtual void Set(T content, TProperty value);
    [AsyncStateMachineAttribute("MassTransit.Internals.WriteProperty`2/<GenerateExpressionSetMethod>d__6")]
private Task GenerateExpressionSetMethod(Type implementationType, MethodInfo setMethod);
    private static Action`2<T, TProperty> CompileSetMethod(Type implementationType, MethodInfo setMethod);
}
public class MassTransit.Internals.WritePropertyCache`1 : object {
    private Type _implementationType;
    private IDictionary`2<string, IWriteProperty`1<T>> _properties;
    private IDictionary`2<string, PropertyInfo> _propertyIndex;
    private sealed virtual override bool MassTransit.Internals.IWritePropertyCache<T>.CanWrite(string name);
    private sealed virtual override IWriteProperty`2<T, TProperty> MassTransit.Internals.IWritePropertyCache<T>.GetProperty(string name);
    private sealed virtual override IWriteProperty`2<T, TProperty> MassTransit.Internals.IWritePropertyCache<T>.GetProperty(PropertyInfo propertyInfo);
    private IWriteProperty`2<T, TProperty> GetWriteProperty(string name);
    public static IWriteProperty`2<T, TProperty> GetProperty(string name);
    public static IWriteProperty`2<T, TProperty> GetProperty(PropertyInfo propertyInfo);
    public static bool CanWrite(string name);
}
public interface MassTransit.Introspection.IProbeResultBuilder {
    public abstract virtual ProbeResult Build();
}
public interface MassTransit.Introspection.ProbeResult {
    public Guid ResultId { get; }
    public Guid ProbeId { get; }
    public DateTime StartTimestamp { get; }
    public TimeSpan Duration { get; }
    public HostInfo Host { get; }
    public IDictionary`2<string, object> Results { get; }
    public abstract virtual Guid get_ResultId();
    public abstract virtual Guid get_ProbeId();
    public abstract virtual DateTime get_StartTimestamp();
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual HostInfo get_Host();
    public abstract virtual IDictionary`2<string, object> get_Results();
}
public class MassTransit.Introspection.ProbeResultBuilder : ScopeProbeContext {
    private Guid _probeId;
    private Guid _resultId;
    private DateTime _startTimestamp;
    public ProbeResultBuilder(Guid probeId, CancellationToken cancellationToken);
    public sealed virtual ProbeResult Build();
}
public class MassTransit.Introspection.ScopeProbeContext : object {
    private CancellationToken _cancellationToken;
    private IDictionary`2<string, object> _variables;
    private CancellationToken MassTransit.ProbeContext.CancellationToken { get; }
    protected ScopeProbeContext(CancellationToken cancellationToken);
    private sealed virtual override CancellationToken MassTransit.ProbeContext.get_CancellationToken();
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Set(object values);
    public sealed virtual void Set(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public sealed virtual ProbeContext CreateScope(string key);
    protected IDictionary`2<string, object> Build();
    private void SetVariablesFromDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values);
}
[ExtensionAttribute]
public static class MassTransit.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static ProbeResult GetProbeResult(IProbeSite probeSite, CancellationToken cancellationToken);
}
public class MassTransit.InvalidLicenseException : Exception {
    public InvalidLicenseException(string message);
}
public class MassTransit.InvalidLicenseFormatException : Exception {
    public InvalidLicenseFormatException(string message);
}
public interface MassTransit.IOutboxConfigurator {
    unknown bool ConcurrentMessageDelivery {public set; }
    public abstract virtual void set_ConcurrentMessageDelivery(bool value);
}
public interface MassTransit.IOutboxOptionsConfigurator {
    unknown int MessageDeliveryLimit {public set; }
    unknown TimeSpan MessageDeliveryTimeout {public set; }
    public abstract virtual void set_MessageDeliveryLimit(int value);
    public abstract virtual void set_MessageDeliveryTimeout(TimeSpan value);
}
public interface MassTransit.IPartitioner {
    public abstract virtual IPartitioner`1<T> GetPartitioner(PartitionKeyProvider`1<T> keyProvider);
}
public interface MassTransit.IPartitioner`1 {
    public abstract virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public interface MassTransit.IPipeConnectorSpecification {
    public abstract virtual void Connect(IPipeConnector connector);
}
public interface MassTransit.IReceiveEndpointConnector {
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
}
public interface MassTransit.IReceiveEndpointConnector`1 {
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, TEndpointConfigurator> configure);
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, TEndpointConfigurator> configure);
}
public interface MassTransit.IRedeliveryConfigurator {
    unknown bool ReplaceMessageId {public set; }
    public abstract virtual void set_ReplaceMessageId(bool value);
}
public interface MassTransit.IRegistrationBusFactory {
    public abstract virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
}
public interface MassTransit.IRegistrationConfigurator {
    public abstract virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public abstract virtual IConsumerRegistrationConfigurator`1<T> AddConsumer(Type consumerDefinitionType, Action`2<IRegistrationContext, IConsumerConfigurator`1<T>> configure);
    public abstract virtual ISagaRegistrationConfigurator`1<T> AddSaga(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public abstract virtual ISagaRegistrationConfigurator`1<T> AddSaga(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public abstract virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public abstract virtual ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(Type sagaDefinitionType, Action`2<IRegistrationContext, ISagaConfigurator`1<T>> configure);
    public abstract virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public abstract virtual IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(Type executeActivityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    public abstract virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public abstract virtual IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(Type activityDefinitionType, Action`2<IRegistrationContext, IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`2<IRegistrationContext, ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    public abstract virtual void AddEndpoint(Type endpointDefinition);
    public abstract virtual void AddEndpoint(IRegistration registration, IEndpointSettings`1<IEndpointDefinition`1<T>> settings);
    public abstract virtual void AddRequestClient(RequestTimeout timeout);
    public abstract virtual void AddRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public abstract virtual void AddRequestClient(Type requestType, RequestTimeout timeout);
    public abstract virtual void AddRequestClient(Type requestType, Uri destinationAddress, RequestTimeout timeout);
    public abstract virtual void SetDefaultRequestTimeout(RequestTimeout timeout);
    public abstract virtual void SetDefaultRequestTimeout(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public abstract virtual void SetEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
    public abstract virtual ISagaRegistrationConfigurator`1<T> AddSagaRepository();
    public abstract virtual void SetSagaRepositoryProvider(ISagaRepositoryRegistrationProvider provider);
    public abstract virtual IFutureRegistrationConfigurator`1<TFuture> AddFuture(Type futureDefinitionType);
}
public interface MassTransit.IRequestStateMachineMissingInstanceConfigurator {
    public abstract virtual IPipe`1<ConsumeContext`1<TMessage>> Apply(IMissingInstanceConfigurator`2<TInstance, TMessage> configurator);
}
public interface MassTransit.IRescueConfigurator`2 {
    public IPipeConfigurator`1<TContext> ContextPipe { get; }
    public abstract virtual IPipeConfigurator`1<TContext> get_ContextPipe();
}
public interface MassTransit.IRetryConfigurator {
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetRetryPolicy(RetryPolicyFactory factory);
}
public interface MassTransit.IRiderRegistrationConfigurator {
    public IContainerRegistrar Registrar { get; }
    public abstract virtual IContainerRegistrar get_Registrar();
    public abstract virtual void TryAddScoped(Func`3<TRider, IServiceProvider, TService> factory);
    public abstract virtual void SetRiderFactory(IRegistrationRiderFactory`1<TRider> riderFactory);
}
public interface MassTransit.IRiderRegistrationConfigurator`1 {
}
public interface MassTransit.IRiderRegistrationContext {
    public abstract virtual IEnumerable`1<T> GetRegistrations();
}
public interface MassTransit.ISagaRegistrationConfigurator {
    public abstract virtual ISagaRegistrationConfigurator Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual void ExcludeFromConfigureEndpoints();
}
public interface MassTransit.ISagaRegistrationConfigurator`1 {
    public abstract virtual ISagaRegistrationConfigurator`1<TSaga> Endpoint(Action`1<IEndpointRegistrationConfigurator> configure);
    public abstract virtual ISagaRegistrationConfigurator`1<TSaga> Repository(Action`1<ISagaRepositoryRegistrationConfigurator`1<TSaga>> configure);
}
public interface MassTransit.ISagaRepositoryRegistrationConfigurator`1 {
}
public interface MassTransit.IScopedClientFactory {
    public abstract virtual RequestHandle`1<T> CreateRequest(T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public abstract virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public abstract virtual RequestHandle`1<T> CreateRequest(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public abstract virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public abstract virtual IRequestClient`1<T> CreateRequestClient(RequestTimeout timeout);
    public abstract virtual IRequestClient`1<T> CreateRequestClient(Uri destinationAddress, RequestTimeout timeout);
}
public interface MassTransit.ISetScopedConsumeContext {
    public abstract virtual IDisposable PushContext(IServiceScope serviceProvider, ConsumeContext context);
}
public interface MassTransit.ISqlBusFactoryConfigurator {
    [NullableAttribute("1")]
public ISqlSendTopologyConfigurator SendTopology { get; }
    [NullableAttribute("1")]
public ISqlPublishTopologyConfigurator PublishTopology { get; }
    [NullableContextAttribute("1")]
public abstract virtual ISqlSendTopologyConfigurator get_SendTopology();
    [NullableContextAttribute("1")]
public abstract virtual ISqlPublishTopologyConfigurator get_PublishTopology();
    [NullableContextAttribute("1")]
public abstract virtual void Send(Action`1<ISqlMessageSendTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public abstract virtual void Publish(Action`1<ISqlMessagePublishTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public abstract virtual void Publish(Type messageType, Action`1<ISqlMessagePublishTopologyConfigurator> configure);
    [NullableContextAttribute("1")]
public abstract virtual void OverrideDefaultBusEndpointQueueName(string value);
    [NullableContextAttribute("1")]
public abstract virtual void Host(SqlHostSettings settings);
}
public interface MassTransit.ISqlBusTopology {
    public ISqlPublishTopology PublishTopology { get; }
    public ISqlSendTopology SendTopology { get; }
    public abstract virtual ISqlPublishTopology get_PublishTopology();
    public abstract virtual ISqlSendTopology get_SendTopology();
    public abstract virtual ISqlMessagePublishTopology`1<T> Publish();
    public abstract virtual ISqlMessageSendTopology`1<T> Send();
}
public interface MassTransit.ISqlConsumeTopology {
    public abstract virtual ISqlMessageConsumeTopology`1<T> GetMessageTopology();
    public abstract virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.ISqlConsumeTopologyConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual ISqlMessageConsumeTopologyConfigurator`1<T> GetMessageTopology();
    [NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public abstract virtual void AddSpecification(ISqlConsumeTopologySpecification specification);
    [NullableContextAttribute("1")]
public abstract virtual void Subscribe(string topicName, Action`1<ISqlTopicSubscriptionConfigurator> configure);
}
[NullableContextAttribute("2")]
public interface MassTransit.ISqlHostConfigurator {
    unknown string ConnectionString {public set; }
    unknown string ConnectionTag {public set; }
    unknown string Host {public set; }
    unknown string InstanceName {public set; }
    unknown Nullable`1<int> Port {public set; }
    unknown string Database {public set; }
    unknown string Schema {public set; }
    unknown string Username {public set; }
    unknown string Password {public set; }
    unknown string VirtualHost {public set; }
    unknown string Area {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    unknown int ConnectionLimit {public set; }
    unknown TimeSpan MaintenanceInterval {public set; }
    unknown int MaintenanceBatchSize {public set; }
    unknown TimeSpan QueueCleanupInterval {public set; }
    public abstract virtual void set_ConnectionString(string value);
    public abstract virtual void set_ConnectionTag(string value);
    public abstract virtual void set_Host(string value);
    public abstract virtual void set_InstanceName(string value);
    public abstract virtual void set_Port(Nullable`1<int> value);
    public abstract virtual void set_Database(string value);
    public abstract virtual void set_Schema(string value);
    public abstract virtual void set_Username(string value);
    public abstract virtual void set_Password(string value);
    public abstract virtual void set_VirtualHost(string value);
    public abstract virtual void set_Area(string value);
    public abstract virtual void set_IsolationLevel(IsolationLevel value);
    public abstract virtual void set_ConnectionLimit(int value);
    public abstract virtual void set_MaintenanceInterval(TimeSpan value);
    public abstract virtual void set_MaintenanceBatchSize(int value);
    public abstract virtual void set_QueueCleanupInterval(TimeSpan value);
    [NullableContextAttribute("1")]
public abstract virtual void UseLicense(string license);
    [NullableContextAttribute("1")]
public abstract virtual void UseLicenseFile(string path);
}
public interface MassTransit.ISqlMessageConsumeTopology`1 {
}
public interface MassTransit.ISqlMessageConsumeTopologyConfigurator`1 {
    public abstract virtual void Subscribe(Action`1<ISqlTopicSubscriptionConfigurator> configure);
}
public interface MassTransit.ISqlMessagePublishTopology {
    public abstract virtual void Apply(IPublishEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.ISqlMessagePublishTopology`1 {
    public Topic Topic { get; }
    public abstract virtual Topic get_Topic();
    public abstract virtual SendSettings GetSendSettings(Uri hostAddress);
    public abstract virtual BrokerTopology GetBrokerTopology();
}
public interface MassTransit.ISqlMessagePublishTopologyConfigurator {
}
public interface MassTransit.ISqlMessagePublishTopologyConfigurator`1 {
}
public interface MassTransit.ISqlMessageSendTopology`1 {
}
public interface MassTransit.ISqlMessageSendTopologyConfigurator {
}
public interface MassTransit.ISqlMessageSendTopologyConfigurator`1 {
}
public interface MassTransit.ISqlPublishTopology {
    public abstract virtual ISqlMessagePublishTopology`1<T> GetMessageTopology();
    public abstract virtual BrokerTopology GetPublishBrokerTopology();
}
public interface MassTransit.ISqlPublishTopologyConfigurator {
    public abstract virtual ISqlMessagePublishTopologyConfigurator`1<T> GetMessageTopology();
    public abstract virtual ISqlMessagePublishTopologyConfigurator GetMessageTopology(Type messageType);
}
public interface MassTransit.ISqlQueueConfigurator {
    unknown Nullable`1<TimeSpan> AutoDeleteOnIdle {public set; }
    public abstract virtual void set_AutoDeleteOnIdle(Nullable`1<TimeSpan> value);
}
public interface MassTransit.ISqlQueueEndpointConfigurator {
    unknown TimeSpan PollingInterval {public set; }
    unknown TimeSpan LockDuration {public set; }
    unknown TimeSpan MaxLockDuration {public set; }
    unknown int MaxDeliveryCount {public set; }
    unknown bool PurgeOnStartup {public set; }
    public abstract virtual void set_PollingInterval(TimeSpan value);
    public abstract virtual void set_LockDuration(TimeSpan value);
    public abstract virtual void set_MaxLockDuration(TimeSpan value);
    public abstract virtual void set_MaxDeliveryCount(int value);
    public abstract virtual void set_PurgeOnStartup(bool value);
}
public interface MassTransit.ISqlReceiveEndpointConfigurator {
    unknown Nullable`1<TimeSpan> UnlockDelay {public set; }
    unknown int ConcurrentDeliveryLimit {public set; }
    public abstract virtual void set_UnlockDelay(Nullable`1<TimeSpan> value);
    public abstract virtual void set_ConcurrentDeliveryLimit(int value);
    public abstract virtual void SetReceiveMode(SqlReceiveMode mode, Nullable`1<int> concurrentDeliveryLimit);
    [NullableContextAttribute("1")]
public abstract virtual void Subscribe(Action`1<ISqlTopicSubscriptionConfigurator> callback);
    [NullableContextAttribute("1")]
public abstract virtual void Subscribe(string topicName, Action`1<ISqlTopicSubscriptionConfigurator> callback);
    public abstract virtual void ConfigureClient(Action`1<IPipeConfigurator`1<ClientContext>> configure);
}
public interface MassTransit.ISqlSendTopology {
    public abstract virtual ISqlMessageSendTopologyConfigurator`1<T> GetMessageTopology();
    public abstract virtual SendSettings GetSendSettings(SqlEndpointAddress address);
    public abstract virtual SendSettings GetErrorSettings(ReceiveSettings settings);
    public abstract virtual SendSettings GetDeadLetterSettings(ReceiveSettings settings);
}
public interface MassTransit.ISqlSendTopologyConfigurator {
    unknown Action`1<ISqlQueueConfigurator> ConfigureErrorSettings {public set; }
    unknown Action`1<ISqlQueueConfigurator> ConfigureDeadLetterSettings {public set; }
    public abstract virtual void set_ConfigureErrorSettings(Action`1<ISqlQueueConfigurator> value);
    public abstract virtual void set_ConfigureDeadLetterSettings(Action`1<ISqlQueueConfigurator> value);
}
public interface MassTransit.ISqlTopicConfigurator {
}
[NullableContextAttribute("2")]
public interface MassTransit.ISqlTopicSubscriptionConfigurator {
    unknown SqlSubscriptionType SubscriptionType {public set; }
    unknown string RoutingKey {public set; }
    public abstract virtual void set_SubscriptionType(SqlSubscriptionType value);
    public abstract virtual void set_RoutingKey(string value);
}
public interface MassTransit.ISqlTopicToTopicBindingConfigurator {
    [NullableContextAttribute("1")]
public abstract virtual void Subscribe(string topicName, Action`1<ISqlTopicToTopicBindingConfigurator> configure);
}
public interface MassTransit.IStateMachineActivitySelector`1 {
    public abstract virtual EventActivityBinder`1<TInstance> OfType();
}
public interface MassTransit.IStateMachineActivitySelector`2 {
    public abstract virtual EventActivityBinder`2<TInstance, TData> OfType();
    public abstract virtual EventActivityBinder`2<TInstance, TData> OfInstanceType();
}
public interface MassTransit.IStateMachineEventActivitiesBuilder`1 {
    public bool IsCommitted { get; }
    public abstract virtual bool get_IsCommitted();
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> When(Event event, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> configure);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> When(Event event, StateMachineCondition`1<TSaga> filter, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> configure);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> When(Event`1<TData> event, Func`2<EventActivityBinder`2<TSaga, TData>, EventActivityBinder`2<TSaga, TData>> configure);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> When(Event`1<TData> event, StateMachineCondition`2<TSaga, TData> filter, Func`2<EventActivityBinder`2<TSaga, TData>, EventActivityBinder`2<TSaga, TData>> configure);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> Ignore(Event event);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> Ignore(Event`1<TMessage> event);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> Ignore(Event`1<TMessage> event, StateMachineCondition`2<TSaga, TMessage> filter);
    public abstract virtual IStateMachineModifier`1<TSaga> CommitActivities();
}
public interface MassTransit.IStateMachineFaultedActivitySelector`2 {
    public abstract virtual ExceptionActivityBinder`2<TInstance, TException> OfType();
}
public interface MassTransit.IStateMachineFaultedActivitySelector`3 {
    public abstract virtual ExceptionActivityBinder`3<TInstance, TData, TException> OfType();
    public abstract virtual ExceptionActivityBinder`3<TInstance, TData, TException> OfInstanceType();
}
public interface MassTransit.IStateMachineModifier`1 {
    public State Initial { get; }
    public State Final { get; }
    public abstract virtual State get_Initial();
    public abstract virtual State get_Final();
    public abstract virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, State>> instanceStateProperty);
    public abstract virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, string>> instanceStateProperty);
    public abstract virtual IStateMachineModifier`1<TSaga> InstanceState(Expression`1<Func`2<TSaga, int>> instanceStateProperty, State[] states);
    public abstract virtual IStateMachineModifier`1<TSaga> Name(string machineName);
    public abstract virtual IStateMachineModifier`1<TSaga> Event(string name, Event& event);
    public abstract virtual IStateMachineModifier`1<TSaga> Event(string name, Event`1& event);
    public abstract virtual IStateMachineModifier`1<TSaga> Event(string name, Action`1<IEventCorrelationConfigurator`2<TSaga, T>> configure, Event`1& event);
    public abstract virtual IStateMachineModifier`1<TSaga> Event(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, Event`1<T>>> eventPropertyExpression);
    public abstract virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    public abstract virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public abstract virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, int>> trackingPropertyExpression, Event[] events);
    public abstract virtual IStateMachineModifier`1<TSaga> CompositeEvent(string name, Event& event, Expression`1<Func`2<TSaga, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    public abstract virtual IStateMachineModifier`1<TSaga> State(string name, State`1& state);
    public abstract virtual IStateMachineModifier`1<TSaga> State(string name, State& state);
    public abstract virtual IStateMachineModifier`1<TSaga> State(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression);
    public abstract virtual IStateMachineModifier`1<TSaga> SubState(string name, State superState, State`1& subState);
    public abstract virtual IStateMachineModifier`1<TSaga> SubState(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression, State superState);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> During(State[] states);
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> Initially();
    public abstract virtual IStateMachineEventActivitiesBuilder`1<TSaga> DuringAny();
    public abstract virtual IStateMachineModifier`1<TSaga> Finally(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> WhenEnter(State state, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> WhenEnterAny(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> WhenLeaveAny(Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> BeforeEnterAny(Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> AfterLeaveAny(Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> WhenLeave(State state, Func`2<EventActivityBinder`1<TSaga>, EventActivityBinder`1<TSaga>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> BeforeEnter(State state, Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> AfterLeave(State state, Func`2<EventActivityBinder`2<TSaga, State>, EventActivityBinder`2<TSaga, State>> activityCallback);
    public abstract virtual IStateMachineModifier`1<TSaga> OnUnhandledEvent(UnhandledEventCallback`1<TSaga> callback);
    public abstract virtual void Apply();
}
public interface MassTransit.ITimeoutConfigurator {
    unknown TimeSpan Timeout {public set; }
    public abstract virtual void set_Timeout(TimeSpan value);
}
public interface MassTransit.ITransactionalOutboxConfigurator {
}
public interface MassTransit.ITransactionConfigurator {
    unknown TimeSpan Timeout {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    public abstract virtual void set_Timeout(TimeSpan value);
    public abstract virtual void set_IsolationLevel(IsolationLevel value);
}
public interface MassTransit.ITransformConfigurator`1 {
    unknown bool Replace {public set; }
    public abstract virtual void set_Replace(bool value);
    public abstract virtual void Default(Expression`1<Func`2<TInput, TProperty>> propertyExpression);
    public abstract virtual void Set(Expression`1<Func`2<TInput, TProperty>> propertyExpression, TProperty value);
    public abstract virtual void Set(Expression`1<Func`2<TInput, TProperty>> propertyExpression, Func`2<TransformPropertyContext`2<TProperty, TInput>, TProperty> valueProvider);
    public abstract virtual void Set(PropertyInfo property, IPropertyProvider`2<TInput, TProperty> propertyProvider);
    public abstract virtual void Transform(PropertyInfo property, IPropertyProvider`2<TInput, TProperty> propertyProvider);
}
public interface MassTransit.ITransformSpecificationConfigurator`1 {
    public abstract virtual IConsumeTransformSpecification`1<TMessage> Get();
    public abstract virtual IConsumeTransformSpecification`1<TMessage> Get(Func`1<T> transformFactory);
}
public class MassTransit.JobAttemptSaga : object {
    [CompilerGeneratedAttribute]
private int <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstanceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <StatusCheckTokenId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RowVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    public int CurrentState { get; public set; }
    public Guid JobId { get; public set; }
    public int RetryAttempt { get; public set; }
    public Uri ServiceAddress { get; public set; }
    public Uri InstanceAddress { get; public set; }
    public Nullable`1<DateTime> Started { get; public set; }
    public Nullable`1<DateTime> Faulted { get; public set; }
    public Nullable`1<Guid> StatusCheckTokenId { get; public set; }
    public Byte[] RowVersion { get; public set; }
    public int Version { get; public set; }
    public Guid CorrelationId { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(int value);
    [CompilerGeneratedAttribute]
public Guid get_JobId();
    [CompilerGeneratedAttribute]
public void set_JobId(Guid value);
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public void set_RetryAttempt(int value);
    [CompilerGeneratedAttribute]
public Uri get_ServiceAddress();
    [CompilerGeneratedAttribute]
public void set_ServiceAddress(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_InstanceAddress();
    [CompilerGeneratedAttribute]
public void set_InstanceAddress(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Faulted();
    [CompilerGeneratedAttribute]
public void set_Faulted(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_StatusCheckTokenId();
    [CompilerGeneratedAttribute]
public void set_StatusCheckTokenId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Byte[] get_RowVersion();
    [CompilerGeneratedAttribute]
public void set_RowVersion(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Version(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(Guid value);
}
public class MassTransit.JobAttemptStateMachine : MassTransitStateMachine`1<JobAttemptSaga> {
    [CompilerGeneratedAttribute]
private State <Starting>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Running>k__BackingField;
    [CompilerGeneratedAttribute]
private State <CheckingStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Suspect>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<StartJobAttempt> <StartJobAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<Fault`1<StartJob>> <StartJobFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptStarted> <AttemptStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptFaulted> <AttemptFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptCompleted> <AttemptCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptCanceled> <AttemptCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptStatus> <AttemptStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule`2<JobAttemptSaga, JobStatusCheckRequested> <StatusCheckRequested>k__BackingField;
    public State Starting { get; }
    public State Running { get; }
    public State CheckingStatus { get; }
    public State Suspect { get; }
    public State Faulted { get; }
    public Event`1<StartJobAttempt> StartJobAttempt { get; }
    public Event`1<Fault`1<StartJob>> StartJobFaulted { get; }
    public Event`1<JobAttemptStarted> AttemptStarted { get; }
    public Event`1<JobAttemptFaulted> AttemptFaulted { get; }
    public Event`1<JobAttemptCompleted> AttemptCompleted { get; }
    public Event`1<JobAttemptCanceled> AttemptCanceled { get; }
    public Event`1<JobAttemptStatus> AttemptStatus { get; }
    public Schedule`2<JobAttemptSaga, JobStatusCheckRequested> StatusCheckRequested { get; }
    [CompilerGeneratedAttribute]
public State get_Starting();
    [CompilerGeneratedAttribute]
public State get_Running();
    [CompilerGeneratedAttribute]
public State get_CheckingStatus();
    [CompilerGeneratedAttribute]
public State get_Suspect();
    [CompilerGeneratedAttribute]
public State get_Faulted();
    [CompilerGeneratedAttribute]
public Event`1<StartJobAttempt> get_StartJobAttempt();
    [CompilerGeneratedAttribute]
public Event`1<Fault`1<StartJob>> get_StartJobFaulted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptStarted> get_AttemptStarted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptFaulted> get_AttemptFaulted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptCompleted> get_AttemptCompleted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptCanceled> get_AttemptCanceled();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptStatus> get_AttemptStatus();
    [CompilerGeneratedAttribute]
public Schedule`2<JobAttemptSaga, JobStatusCheckRequested> get_StatusCheckRequested();
}
[ExtensionAttribute]
internal static class MassTransit.JobAttemptStateMachineBehaviorExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<TimeSpan> GetRetryDelay(BehaviorContext`2<JobAttemptSaga, T> context);
    [ExtensionAttribute]
private static Uri GetJobSagaAddress(SagaConsumeContext`1<JobAttemptSaga> context);
    [ExtensionAttribute]
private static Uri GetJobAttemptSagaAddress(SagaConsumeContext`1<JobAttemptSaga> context);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, StartJobAttempt> SendStartJob(EventActivityBinder`2<JobAttemptSaga, StartJobAttempt> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, JobStatusCheckRequested> SendCheckJobStatus(EventActivityBinder`2<JobAttemptSaga, JobStatusCheckRequested> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, T> ScheduleJobStatusCheck(EventActivityBinder`2<JobAttemptSaga, T> binder, JobAttemptStateMachine machine);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, Fault`1<StartJob>> SendJobAttemptFaulted(EventActivityBinder`2<JobAttemptSaga, Fault`1<StartJob>> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, T> SendJobAttemptFaulted(EventActivityBinder`2<JobAttemptSaga, T> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobAttemptSaga, T> SendJobAttemptStartTimeout(EventActivityBinder`2<JobAttemptSaga, T> binder);
}
public class MassTransit.JobConsumerOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatInterval>k__BackingField;
    public TimeSpan HeartbeatInterval { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_HeartbeatInterval();
    [CompilerGeneratedAttribute]
public void set_HeartbeatInterval(TimeSpan value);
    [IteratorStateMachineAttribute("MassTransit.JobConsumerOptions/<MassTransit-ISpecification-Validate>d__5")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
    public JobConsumerOptions SetHeartbeatInterval(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public JobConsumerOptions SetHeartbeatInterval(TimeSpan interval);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.JobOptions`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <JobTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <JobCancellationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConcurrentJobLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private IRetryPolicy <RetryPolicy>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <JobTypeName>k__BackingField;
    public TimeSpan JobTimeout { get; public set; }
    public TimeSpan JobCancellationTimeout { get; public set; }
    public int ConcurrentJobLimit { get; public set; }
    public IRetryPolicy RetryPolicy { get; private set; }
    [NullableAttribute("2")]
public string JobTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_JobTimeout();
    [CompilerGeneratedAttribute]
public void set_JobTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_JobCancellationTimeout();
    [CompilerGeneratedAttribute]
public void set_JobCancellationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_ConcurrentJobLimit();
    [CompilerGeneratedAttribute]
public void set_ConcurrentJobLimit(int value);
    [CompilerGeneratedAttribute]
public IRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private void set_RetryPolicy(IRetryPolicy value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_JobTypeName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_JobTypeName(string value);
    [IteratorStateMachineAttribute("MassTransit.JobOptions`1/<MassTransit-ISpecification-Validate>d__21")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
    public JobOptions`1<TJob> SetJobTimeout(TimeSpan timeout);
    public JobOptions`1<TJob> SetJobCancellationTimeout(TimeSpan timeout);
    public JobOptions`1<TJob> SetConcurrentJobLimit(int limit);
    public JobOptions`1<TJob> SetJobTypeName(string name);
    public JobOptions`1<TJob> SetRetry(Action`1<IRetryConfigurator> configure);
}
public class MassTransit.JobSaga : object {
    [CompilerGeneratedAttribute]
private int <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Submitted>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <JobTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <JobTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <AttemptId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <JobSlotWaitToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <JobRetryDelayToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RowVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    public int CurrentState { get; public set; }
    public Nullable`1<DateTime> Submitted { get; public set; }
    public Uri ServiceAddress { get; public set; }
    public Nullable`1<TimeSpan> JobTimeout { get; public set; }
    public IDictionary`2<string, object> Job { get; public set; }
    public Guid JobTypeId { get; public set; }
    public Guid AttemptId { get; public set; }
    public int RetryAttempt { get; public set; }
    public Nullable`1<DateTime> Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; public set; }
    public Nullable`1<DateTime> Faulted { get; public set; }
    public string Reason { get; public set; }
    public Nullable`1<Guid> JobSlotWaitToken { get; public set; }
    public Nullable`1<Guid> JobRetryDelayToken { get; public set; }
    public Byte[] RowVersion { get; public set; }
    public int Version { get; public set; }
    public Guid CorrelationId { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Submitted();
    [CompilerGeneratedAttribute]
public void set_Submitted(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Uri get_ServiceAddress();
    [CompilerGeneratedAttribute]
public void set_ServiceAddress(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_JobTimeout();
    [CompilerGeneratedAttribute]
public void set_JobTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Guid get_JobTypeId();
    [CompilerGeneratedAttribute]
public void set_JobTypeId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_AttemptId();
    [CompilerGeneratedAttribute]
public void set_AttemptId(Guid value);
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public void set_RetryAttempt(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Faulted();
    [CompilerGeneratedAttribute]
public void set_Faulted(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_JobSlotWaitToken();
    [CompilerGeneratedAttribute]
public void set_JobSlotWaitToken(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_JobRetryDelayToken();
    [CompilerGeneratedAttribute]
public void set_JobRetryDelayToken(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Byte[] get_RowVersion();
    [CompilerGeneratedAttribute]
public void set_RowVersion(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Version(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(Guid value);
}
[ExtensionAttribute]
public static class MassTransit.JobSagaBusConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseJobSagaPartitionKeyFormatters(IBusFactoryConfigurator configurator);
    [ExtensionAttribute]
public static IJobSagaRegistrationConfigurator SetPartitionedReceiveMode(IJobSagaRegistrationConfigurator configurator);
}
public class MassTransit.JobSagaOptions : object {
    private Uri _jobAttemptSagaEndpointAddress;
    private Uri _jobSagaEndpointAddress;
    private Uri _jobTypeSagaEndpointAddress;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SlotWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <StatusCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuspectJobRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <SuspectJobRetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FinalizeCompleted>k__BackingField;
    public Nullable`1<int> ConcurrentMessageLimit { get; public set; }
    unknown Uri MassTransit.Configuration.JobSagaSettingsConfigurator.JobSagaEndpointAddress {private set; }
    unknown Uri MassTransit.Configuration.JobSagaSettingsConfigurator.JobTypeSagaEndpointAddress {private set; }
    unknown Uri MassTransit.Configuration.JobSagaSettingsConfigurator.JobAttemptSagaEndpointAddress {private set; }
    private Uri MassTransit.Configuration.JobSagaSettings.JobAttemptSagaEndpointAddress { get; }
    private Uri MassTransit.Configuration.JobSagaSettings.JobTypeSagaEndpointAddress { get; }
    private Uri MassTransit.Configuration.JobSagaSettings.JobSagaEndpointAddress { get; }
    public TimeSpan SlotWaitTime { get; public set; }
    public TimeSpan StatusCheckInterval { get; public set; }
    public TimeSpan HeartbeatTimeout { get; public set; }
    public int SuspectJobRetryCount { get; public set; }
    public Nullable`1<TimeSpan> SuspectJobRetryDelay { get; public set; }
    public bool FinalizeCompleted { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConcurrentMessageLimit();
    [CompilerGeneratedAttribute]
public void set_ConcurrentMessageLimit(Nullable`1<int> value);
    [IteratorStateMachineAttribute("MassTransit.JobSagaOptions/<MassTransit-ISpecification-Validate>d__8")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
    private sealed virtual override void MassTransit.Configuration.JobSagaSettingsConfigurator.set_JobSagaEndpointAddress(Uri value);
    private sealed virtual override void MassTransit.Configuration.JobSagaSettingsConfigurator.set_JobTypeSagaEndpointAddress(Uri value);
    private sealed virtual override void MassTransit.Configuration.JobSagaSettingsConfigurator.set_JobAttemptSagaEndpointAddress(Uri value);
    private sealed virtual override Uri MassTransit.Configuration.JobSagaSettings.get_JobAttemptSagaEndpointAddress();
    private sealed virtual override Uri MassTransit.Configuration.JobSagaSettings.get_JobTypeSagaEndpointAddress();
    private sealed virtual override Uri MassTransit.Configuration.JobSagaSettings.get_JobSagaEndpointAddress();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_SlotWaitTime();
    [CompilerGeneratedAttribute]
public void set_SlotWaitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_StatusCheckInterval();
    [CompilerGeneratedAttribute]
public void set_StatusCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_HeartbeatTimeout();
    [CompilerGeneratedAttribute]
public void set_HeartbeatTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuspectJobRetryCount();
    [CompilerGeneratedAttribute]
public void set_SuspectJobRetryCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_SuspectJobRetryDelay();
    [CompilerGeneratedAttribute]
public void set_SuspectJobRetryDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FinalizeCompleted();
    [CompilerGeneratedAttribute]
public void set_FinalizeCompleted(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.JobService.ConsumeJobContext`1 : ConsumeContextProxy {
    private ConsumeContext`1<StartJob> _context;
    private Uri _instanceAddress;
    private CancellationTokenSource _source;
    private Stopwatch _stopwatch;
    [CompilerGeneratedAttribute]
private Guid <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <AttemptId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private TJob <Job>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public TJob Message { get; }
    public Guid JobId { get; }
    public Guid AttemptId { get; }
    public int RetryAttempt { get; }
    public TJob Job { get; }
    public TimeSpan ElapsedTime { get; }
    public ConsumeJobContext`1(ConsumeContext`1<StartJob> context, Uri instanceAddress, Guid jobId, Guid attemptId, int retryAttempt, TJob job, TimeSpan jobTimeout);
    public virtual CancellationToken get_CancellationToken();
    public sealed virtual TJob get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_JobId();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_AttemptId();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual TJob get_Job();
    public sealed virtual TimeSpan get_ElapsedTime();
    public sealed virtual Task NotifyCanceled(string reason);
    public sealed virtual Task NotifyStarted();
    public sealed virtual Task NotifyCompleted();
    public sealed virtual Task NotifyFaulted(Exception exception, Nullable`1<TimeSpan> delay);
    [AsyncStateMachineAttribute("MassTransit.JobService.ConsumeJobContext`1/<Notify>d__30`1")]
private Task Notify(object values);
    public void Cancel();
}
public class MassTransit.JobService.ConsumerJobHandle`1 : object {
    private ConsumeJobContext`1<T> _context;
    private TimeSpan _jobCancellationTimeout;
    [CompilerGeneratedAttribute]
private Task <JobTask>k__BackingField;
    public Guid JobId { get; }
    public Task JobTask { get; }
    public ConsumerJobHandle`1(ConsumeJobContext`1<T> context, Task task, TimeSpan jobCancellationTimeout);
    public sealed virtual Guid get_JobId();
    [CompilerGeneratedAttribute]
public sealed virtual Task get_JobTask();
    [AsyncStateMachineAttribute("MassTransit.JobService.ConsumerJobHandle`1/<Cancel>d__8")]
public sealed virtual Task Cancel();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.JobService.FaultJobContext`1 : ConsumeContextProxy {
    private ConsumeContext`1<FaultJob> _context;
    [CompilerGeneratedAttribute]
private TJob <Job>k__BackingField;
    public TJob Job { get; }
    public TJob Message { get; }
    public FaultJobContext`1(ConsumeContext`1<FaultJob> context, TJob job);
    [CompilerGeneratedAttribute]
public TJob get_Job();
    public sealed virtual TJob get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
}
public class MassTransit.JobService.FinalizeJobConsumer`1 : object {
    private string _jobConsumerTypeName;
    private Guid _jobTypeId;
    public FinalizeJobConsumer`1(Guid jobTypeId, string jobConsumerTypeName);
    public sealed virtual Task Consume(ConsumeContext`1<CompleteJob> context);
    public sealed virtual Task Consume(ConsumeContext`1<FaultJob> context);
}
public interface MassTransit.JobService.IJobService {
    public Uri InstanceAddress { get; }
    public JobServiceSettings Settings { get; }
    public abstract virtual Uri get_InstanceAddress();
    public abstract virtual JobServiceSettings get_Settings();
    public abstract virtual Task`1<JobHandle> StartJob(ConsumeContext`1<StartJob> context, T job, IPipe`1<ConsumeContext`1<T>> jobPipe, JobOptions`1<T> jobOptions);
    public abstract virtual Task Stop(IPublishEndpoint publishEndpoint);
    public abstract virtual bool TryGetJob(Guid jobId, JobHandle& jobReference);
    public abstract virtual bool TryRemoveJob(Guid jobId, JobHandle& jobHandle);
    public abstract virtual void RegisterJobType(IReceiveEndpointConfigurator configurator, JobOptions`1<T> options, Guid jobTypeId, string jobTypeName);
    public abstract virtual Task BusStarted(IPublishEndpoint publishEndpoint);
    public abstract virtual Guid GetJobTypeId();
    public abstract virtual void ConfigureSuperviseJobConsumer(IReceiveEndpointConfigurator configurator);
}
public interface MassTransit.JobService.JobHandle {
    public Guid JobId { get; }
    public Task JobTask { get; }
    public abstract virtual Guid get_JobId();
    public abstract virtual Task get_JobTask();
    public abstract virtual Task Cancel();
}
public static class MassTransit.JobService.JobMetadataCache`2 : object {
    public static Guid GenerateJobTypeId(string queueName);
    public static string GenerateJobTypeName(string queueName);
}
public class MassTransit.JobService.JobService : object {
    private ConcurrentDictionary`2<Guid, JobHandle> _jobs;
    private Dictionary`2<Type, IJobTypeRegistration> _jobTypes;
    private Timer _heartbeat;
    [CompilerGeneratedAttribute]
private JobServiceSettings <Settings>k__BackingField;
    public JobServiceSettings Settings { get; }
    public Uri InstanceAddress { get; }
    public JobService(JobServiceSettings settings);
    [CompilerGeneratedAttribute]
public sealed virtual JobServiceSettings get_Settings();
    public sealed virtual Uri get_InstanceAddress();
    public sealed virtual bool TryGetJob(Guid jobId, JobHandle& jobReference);
    public sealed virtual bool TryRemoveJob(Guid jobId, JobHandle& jobHandle);
    [AsyncStateMachineAttribute("MassTransit.JobService.JobService/<StartJob>d__11`1")]
public sealed virtual Task`1<JobHandle> StartJob(ConsumeContext`1<StartJob> context, T job, IPipe`1<ConsumeContext`1<T>> jobPipe, JobOptions`1<T> jobOptions);
    [AsyncStateMachineAttribute("MassTransit.JobService.JobService/<Stop>d__12")]
public sealed virtual Task Stop(IPublishEndpoint publishEndpoint);
    public sealed virtual void RegisterJobType(IReceiveEndpointConfigurator configurator, JobOptions`1<T> options, Guid jobTypeId, string jobTypeName);
    [AsyncStateMachineAttribute("MassTransit.JobService.JobService/<BusStarted>d__14")]
public sealed virtual Task BusStarted(IPublishEndpoint publishEndpoint);
    public sealed virtual Guid GetJobTypeId();
    public sealed virtual void ConfigureSuperviseJobConsumer(IReceiveEndpointConfigurator configurator);
    private void Add(JobHandle jobHandle);
    [CompilerGeneratedAttribute]
private SuperviseJobConsumer <ConfigureSuperviseJobConsumer>b__16_0();
}
public class MassTransit.JobService.JobServiceBusObserver : object {
    private IJobService _jobService;
    public JobServiceBusObserver(IJobService jobService);
    public sealed virtual void PostCreate(IBus bus);
    public sealed virtual void CreateFaulted(Exception exception);
    public sealed virtual Task PreStart(IBus bus);
    [AsyncStateMachineAttribute("MassTransit.JobService.JobServiceBusObserver/<PostStart>d__5")]
public sealed virtual Task PostStart(IBus bus, Task`1<BusReady> busReady);
    public sealed virtual Task StartFaulted(IBus bus, Exception exception);
    [AsyncStateMachineAttribute("MassTransit.JobService.JobServiceBusObserver/<PreStop>d__7")]
public sealed virtual Task PreStop(IBus bus);
    public sealed virtual Task PostStop(IBus bus);
    public sealed virtual Task StopFaulted(IBus bus, Exception exception);
}
[NullableContextAttribute("2")]
public interface MassTransit.JobService.JobServiceSettings {
    [NullableAttribute("1")]
public IJobService JobService { get; }
    public TimeSpan HeartbeatInterval { get; }
    public Uri InstanceAddress { get; }
    public IReceiveEndpointConfigurator InstanceEndpointConfigurator { get; }
    [NullableContextAttribute("1")]
public abstract virtual IJobService get_JobService();
    public abstract virtual TimeSpan get_HeartbeatInterval();
    public abstract virtual Uri get_InstanceAddress();
    public abstract virtual IReceiveEndpointConfigurator get_InstanceEndpointConfigurator();
}
public class MassTransit.JobService.StartJobConsumer`1 : object {
    private IPipe`1<ConsumeContext`1<TJob>> _jobPipe;
    private IJobService _jobService;
    private Guid _jobTypeId;
    private JobOptions`1<TJob> _options;
    public StartJobConsumer`1(IJobService jobService, JobOptions`1<TJob> options, Guid jobTypeId, IPipe`1<ConsumeContext`1<TJob>> jobPipe);
    [AsyncStateMachineAttribute("MassTransit.JobService.StartJobConsumer`1/<Consume>d__5")]
public sealed virtual Task Consume(ConsumeContext`1<StartJob> context);
}
public class MassTransit.JobService.SubmitJobConsumer`1 : object {
    private Guid _jobTypeId;
    private JobOptions`1<TJob> _options;
    public SubmitJobConsumer`1(JobOptions`1<TJob> options, Guid jobTypeId);
    public sealed virtual Task Consume(ConsumeContext`1<SubmitJob`1<TJob>> context);
    public sealed virtual Task Consume(ConsumeContext`1<TJob> context);
    [AsyncStateMachineAttribute("MassTransit.JobService.SubmitJobConsumer`1/<PublishJobSubmitted>d__5")]
private Task PublishJobSubmitted(ConsumeContext context, Guid jobId, TJob job, DateTime timestamp);
}
public class MassTransit.JobService.SuperviseJobConsumer : object {
    private IJobService _jobService;
    public SuperviseJobConsumer(IJobService jobService);
    [AsyncStateMachineAttribute("MassTransit.JobService.SuperviseJobConsumer/<Consume>d__2")]
public sealed virtual Task Consume(ConsumeContext`1<CancelJob> context);
    public sealed virtual Task Consume(ConsumeContext`1<GetJobAttemptStatus> context);
}
[ExtensionAttribute]
public static class MassTransit.JobServiceConfigurationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddJobSagaStateMachines instead. Visit https://masstransit.io/obsolete for details.")]
public static IServiceInstanceConfigurator`1<T> ConfigureJobServiceEndpoints(IServiceInstanceConfigurator`1<T> configurator, IRegistrationContext context, Action`1<IJobServiceConfigurator> configure);
    [ExtensionAttribute]
public static IServiceInstanceConfigurator`1<T> ConfigureJobServiceEndpoints(IServiceInstanceConfigurator`1<T> configurator, Action`1<IJobServiceConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddJobSagaStateMachines instead. Visit https://masstransit.io/obsolete for details.")]
public static IServiceInstanceConfigurator`1<T> ConfigureJobServiceEndpoints(IServiceInstanceConfigurator`1<T> configurator, JobServiceOptions options, IRegistrationContext context, Action`1<IJobServiceConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddJobSagaStateMachines instead. Visit https://masstransit.io/obsolete for details.")]
public static IServiceInstanceConfigurator`1<T> ConfigureJobServiceEndpoints(IServiceInstanceConfigurator`1<T> configurator, JobServiceOptions options, Action`1<IJobServiceConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static IServiceInstanceConfigurator`1<T> ConfigureJobService(IServiceInstanceConfigurator`1<T> configurator, Action`1<IJobServiceConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static IServiceInstanceConfigurator`1<T> ConfigureJobService(IServiceInstanceConfigurator`1<T> configurator, JobServiceOptions options, Action`1<IJobServiceConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.JobServiceContainerConfigurationExtensions : object {
    [ExtensionAttribute]
public static IJobServiceConfigurator ConfigureSagaRepositories(IJobServiceConfigurator configurator, IRegistrationContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the IRegistrationContext overload instead. Visit https://masstransit.io/obsolete for details.")]
public static IJobServiceConfigurator ConfigureSagaRepositories(IJobServiceConfigurator configurator, IServiceProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.JobServiceEventExtensions : object {
    [ExtensionAttribute]
public static TJob GetJob(ConsumeContext`1<StartJob> context);
    [ExtensionAttribute]
public static TJob GetJob(ConsumeContext`1<FaultJob> context);
    [ExtensionAttribute]
public static TJob GetJob(ConsumeContext`1<CompleteJob> context);
    [ExtensionAttribute]
public static TJob GetJob(ConsumeContext`1<JobCompleted> context);
    [ExtensionAttribute]
public static TResult GetResult(ConsumeContext`1<JobCompleted> context);
    [ExtensionAttribute]
public static TJob GetJob(ConsumeContext`1<JobFaulted> context);
}
[ExtensionAttribute]
public static class MassTransit.JobServiceExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.JobServiceExtensions/<GetJobState>d__0")]
[ExtensionAttribute]
public static Task`1<JobState> GetJobState(IRequestClient`1<GetJobState> client, Guid jobId);
}
public class MassTransit.JobServiceOptions : object {
    private string _jobAttemptSagaEndpointName;
    private string _jobSagaEndpointName;
    private string _jobTypeSagaEndpointName;
    [CompilerGeneratedAttribute]
private IJobService <JobService>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SagaPartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReceiveEndpointConfigurator <InstanceEndpointConfigurator>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IReceiveEndpointConfigurator> <OnConfigureEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <JobSagaEndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <JobTypeSagaEndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <JobAttemptSagaEndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SlotWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <StatusCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuspectJobRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <SuspectJobRetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FinalizeCompleted>k__BackingField;
    public string JobTypeSagaEndpointName { get; public set; }
    public string JobStateSagaEndpointName { get; public set; }
    public string JobAttemptSagaEndpointName { get; public set; }
    public IJobService JobService { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public Nullable`1<int> SagaPartitionCount { get; public set; }
    public IReceiveEndpointConfigurator InstanceEndpointConfigurator { get; public set; }
    public Action`1<IReceiveEndpointConfigurator> OnConfigureEndpoint { get; public set; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public Uri JobSagaEndpointAddress { get; public set; }
    public Uri JobTypeSagaEndpointAddress { get; public set; }
    public Uri JobAttemptSagaEndpointAddress { get; public set; }
    public TimeSpan SlotWaitTime { get; public set; }
    public TimeSpan StatusCheckInterval { get; public set; }
    public TimeSpan HeartbeatTimeout { get; public set; }
    public int SuspectJobRetryCount { get; public set; }
    public Nullable`1<TimeSpan> SuspectJobRetryDelay { get; public set; }
    public bool FinalizeCompleted { get; public set; }
    public string get_JobTypeSagaEndpointName();
    public void set_JobTypeSagaEndpointName(string value);
    public string get_JobStateSagaEndpointName();
    public void set_JobStateSagaEndpointName(string value);
    public string get_JobAttemptSagaEndpointName();
    public void set_JobAttemptSagaEndpointName(string value);
    [CompilerGeneratedAttribute]
public IJobService get_JobService();
    [CompilerGeneratedAttribute]
public void set_JobService(IJobService value);
    [CompilerGeneratedAttribute]
public TimeSpan get_HeartbeatInterval();
    [CompilerGeneratedAttribute]
public void set_HeartbeatInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SagaPartitionCount();
    [CompilerGeneratedAttribute]
public void set_SagaPartitionCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IReceiveEndpointConfigurator get_InstanceEndpointConfigurator();
    [CompilerGeneratedAttribute]
public void set_InstanceEndpointConfigurator(IReceiveEndpointConfigurator value);
    [CompilerGeneratedAttribute]
public Action`1<IReceiveEndpointConfigurator> get_OnConfigureEndpoint();
    [CompilerGeneratedAttribute]
public void set_OnConfigureEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    public Nullable`1<int> get_ConcurrentMessageLimit();
    [IteratorStateMachineAttribute("MassTransit.JobServiceOptions/<MassTransit-ISpecification-Validate>d__35")]
private sealed virtual override IEnumerable`1<ValidationResult> MassTransit.ISpecification.Validate();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_JobSagaEndpointAddress();
    [CompilerGeneratedAttribute]
public void set_JobSagaEndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_JobTypeSagaEndpointAddress();
    [CompilerGeneratedAttribute]
public void set_JobTypeSagaEndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_JobAttemptSagaEndpointAddress();
    [CompilerGeneratedAttribute]
public void set_JobAttemptSagaEndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_SlotWaitTime();
    [CompilerGeneratedAttribute]
public void set_SlotWaitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_StatusCheckInterval();
    [CompilerGeneratedAttribute]
public void set_StatusCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_HeartbeatTimeout();
    [CompilerGeneratedAttribute]
public void set_HeartbeatTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuspectJobRetryCount();
    [CompilerGeneratedAttribute]
public void set_SuspectJobRetryCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_SuspectJobRetryDelay();
    [CompilerGeneratedAttribute]
public void set_SuspectJobRetryDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FinalizeCompleted();
    [CompilerGeneratedAttribute]
public void set_FinalizeCompleted(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.JobServiceRegistrationExtensions : object {
    [ExtensionAttribute]
public static IJobServiceRegistrationConfigurator SetJobConsumerOptions(IBusRegistrationConfigurator configurator, Action`1<JobConsumerOptions> configure);
    [ExtensionAttribute]
public static IJobSagaRegistrationConfigurator AddJobSagaStateMachines(IBusRegistrationConfigurator configurator, Action`1<JobSagaOptions> configure);
}
public class MassTransit.JobStateMachine : MassTransitStateMachine`1<JobSaga> {
    [CompilerGeneratedAttribute]
private State <Submitted>k__BackingField;
    [CompilerGeneratedAttribute]
private State <WaitingToStart>k__BackingField;
    [CompilerGeneratedAttribute]
private State <WaitingToRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private State <WaitingForSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private State <AllocatingJobSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private State <StartingJobAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobSlotAllocated> <JobSlotAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobSlotUnavailable> <JobSlotUnavailable>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<Fault`1<AllocateJobSlot>> <AllocateJobSlotFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptCreated> <JobAttemptCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<Fault`1<StartJobAttempt>> <StartJobAttemptFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobSubmitted> <JobSubmitted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptStarted> <AttemptStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptCompleted> <AttemptCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptCanceled> <AttemptCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobAttemptFaulted> <AttemptFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobCompleted> <JobCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<CancelJob> <CancelJob>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<RetryJob> <RetryJob>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<GetJobState> <GetJobState>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule`2<JobSaga, JobSlotWaitElapsed> <JobSlotWaitElapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule`2<JobSaga, JobRetryDelayElapsed> <JobRetryDelayElapsed>k__BackingField;
    public State Submitted { get; }
    public State WaitingToStart { get; }
    public State WaitingToRetry { get; }
    public State WaitingForSlot { get; }
    public State Started { get; }
    public State Completed { get; }
    public State Canceled { get; }
    public State Faulted { get; }
    public State AllocatingJobSlot { get; }
    public State StartingJobAttempt { get; }
    public Event`1<JobSlotAllocated> JobSlotAllocated { get; }
    public Event`1<JobSlotUnavailable> JobSlotUnavailable { get; }
    public Event`1<Fault`1<AllocateJobSlot>> AllocateJobSlotFaulted { get; }
    public Event`1<JobAttemptCreated> JobAttemptCreated { get; }
    public Event`1<Fault`1<StartJobAttempt>> StartJobAttemptFaulted { get; }
    public Event`1<JobSubmitted> JobSubmitted { get; }
    public Event`1<JobAttemptStarted> AttemptStarted { get; }
    public Event`1<JobAttemptCompleted> AttemptCompleted { get; }
    public Event`1<JobAttemptCanceled> AttemptCanceled { get; }
    public Event`1<JobAttemptFaulted> AttemptFaulted { get; }
    public Event`1<JobCompleted> JobCompleted { get; }
    public Event`1<CancelJob> CancelJob { get; }
    public Event`1<RetryJob> RetryJob { get; }
    public Event`1<GetJobState> GetJobState { get; }
    public Schedule`2<JobSaga, JobSlotWaitElapsed> JobSlotWaitElapsed { get; }
    public Schedule`2<JobSaga, JobRetryDelayElapsed> JobRetryDelayElapsed { get; }
    [CompilerGeneratedAttribute]
public State get_Submitted();
    [CompilerGeneratedAttribute]
public State get_WaitingToStart();
    [CompilerGeneratedAttribute]
public State get_WaitingToRetry();
    [CompilerGeneratedAttribute]
public State get_WaitingForSlot();
    [CompilerGeneratedAttribute]
public State get_Started();
    [CompilerGeneratedAttribute]
public State get_Completed();
    [CompilerGeneratedAttribute]
public State get_Canceled();
    [CompilerGeneratedAttribute]
public State get_Faulted();
    [CompilerGeneratedAttribute]
public State get_AllocatingJobSlot();
    [CompilerGeneratedAttribute]
public State get_StartingJobAttempt();
    [CompilerGeneratedAttribute]
public Event`1<JobSlotAllocated> get_JobSlotAllocated();
    [CompilerGeneratedAttribute]
public Event`1<JobSlotUnavailable> get_JobSlotUnavailable();
    [CompilerGeneratedAttribute]
public Event`1<Fault`1<AllocateJobSlot>> get_AllocateJobSlotFaulted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptCreated> get_JobAttemptCreated();
    [CompilerGeneratedAttribute]
public Event`1<Fault`1<StartJobAttempt>> get_StartJobAttemptFaulted();
    [CompilerGeneratedAttribute]
public Event`1<JobSubmitted> get_JobSubmitted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptStarted> get_AttemptStarted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptCompleted> get_AttemptCompleted();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptCanceled> get_AttemptCanceled();
    [CompilerGeneratedAttribute]
public Event`1<JobAttemptFaulted> get_AttemptFaulted();
    [CompilerGeneratedAttribute]
public Event`1<JobCompleted> get_JobCompleted();
    [CompilerGeneratedAttribute]
public Event`1<CancelJob> get_CancelJob();
    [CompilerGeneratedAttribute]
public Event`1<RetryJob> get_RetryJob();
    [CompilerGeneratedAttribute]
public Event`1<GetJobState> get_GetJobState();
    [CompilerGeneratedAttribute]
public Schedule`2<JobSaga, JobSlotWaitElapsed> get_JobSlotWaitElapsed();
    [CompilerGeneratedAttribute]
public Schedule`2<JobSaga, JobRetryDelayElapsed> get_JobRetryDelayElapsed();
    [CompilerGeneratedAttribute]
private EventActivityBinder`2<JobSaga, JobAttemptFaulted> <.ctor>b__0_41(EventActivityBinder`2<JobSaga, JobAttemptFaulted> retry);
    [CompilerGeneratedAttribute]
private EventActivityBinder`2<JobSaga, JobAttemptFaulted> <.ctor>b__0_42(EventActivityBinder`2<JobSaga, JobAttemptFaulted> fault);
    [CompilerGeneratedAttribute]
private Task`1<SendTuple`1<JobState>> <.ctor>b__0_51(BehaviorContext`2<JobSaga, GetJobState> x);
}
[ExtensionAttribute]
internal static class MassTransit.JobStateMachineBehaviorExtensions : object {
    [ExtensionAttribute]
private static Uri GetJobAttemptSagaAddress(SagaConsumeContext`1<JobSaga> context);
    [ExtensionAttribute]
private static Uri GetJobTypeSagaAddress(SagaConsumeContext`1<JobSaga> context);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobSubmitted> InitializeJob(EventActivityBinder`2<JobSaga, JobSubmitted> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, T> RequestJobSlot(EventActivityBinder`2<JobSaga, T> binder, JobStateMachine machine);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobSlotAllocated> RequestStartJob(EventActivityBinder`2<JobSaga, JobSlotAllocated> binder, JobStateMachine machine);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, T> WaitForJobSlot(EventActivityBinder`2<JobSaga, T> binder, JobStateMachine machine);
    [ExtensionAttribute]
public static EventActivityBinder`1<JobSaga> SendJobSlotReleased(EventActivityBinder`1<JobSaga> binder, JobSlotDisposition disposition);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobAttemptStarted> PublishJobStarted(EventActivityBinder`2<JobSaga, JobAttemptStarted> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobAttemptCompleted> NotifyJobCompleted(EventActivityBinder`2<JobSaga, JobAttemptCompleted> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobAttemptFaulted> NotifyJobFaulted(EventActivityBinder`2<JobSaga, JobAttemptFaulted> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, JobAttemptCanceled> PublishJobCanceled(EventActivityBinder`2<JobSaga, JobAttemptCanceled> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, CancelJob> PublishJobCanceled(EventActivityBinder`2<JobSaga, CancelJob> binder);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobSaga, Fault`1<StartJobAttempt>> NotifyJobFaulted(EventActivityBinder`2<JobSaga, Fault`1<StartJobAttempt>> binder);
}
public class MassTransit.JobTypeInstance : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Updated>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Used>k__BackingField;
    public Nullable`1<DateTime> Updated { get; public set; }
    public Nullable`1<DateTime> Used { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Updated();
    [CompilerGeneratedAttribute]
public void set_Updated(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Used();
    [CompilerGeneratedAttribute]
public void set_Used(Nullable`1<DateTime> value);
}
public class MassTransit.JobTypeSaga : object {
    [CompilerGeneratedAttribute]
private int <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActiveJobCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConcurrentJobLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OverrideJobLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <OverrideLimitExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ActiveJob> <ActiveJobs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Uri, JobTypeInstance> <Instances>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RowVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    public int CurrentState { get; public set; }
    public int ActiveJobCount { get; public set; }
    public int ConcurrentJobLimit { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> OverrideJobLimit { get; public set; }
    public Nullable`1<DateTime> OverrideLimitExpiration { get; public set; }
    public List`1<ActiveJob> ActiveJobs { get; public set; }
    public Dictionary`2<Uri, JobTypeInstance> Instances { get; public set; }
    public Byte[] RowVersion { get; public set; }
    public int Version { get; public set; }
    public Guid CorrelationId { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(int value);
    [CompilerGeneratedAttribute]
public int get_ActiveJobCount();
    [CompilerGeneratedAttribute]
public void set_ActiveJobCount(int value);
    [CompilerGeneratedAttribute]
public int get_ConcurrentJobLimit();
    [CompilerGeneratedAttribute]
public void set_ConcurrentJobLimit(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OverrideJobLimit();
    [CompilerGeneratedAttribute]
public void set_OverrideJobLimit(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_OverrideLimitExpiration();
    [CompilerGeneratedAttribute]
public void set_OverrideLimitExpiration(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public List`1<ActiveJob> get_ActiveJobs();
    [CompilerGeneratedAttribute]
public void set_ActiveJobs(List`1<ActiveJob> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Uri, JobTypeInstance> get_Instances();
    [CompilerGeneratedAttribute]
public void set_Instances(Dictionary`2<Uri, JobTypeInstance> value);
    [CompilerGeneratedAttribute]
public Byte[] get_RowVersion();
    [CompilerGeneratedAttribute]
public void set_RowVersion(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Version(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(Guid value);
}
public class MassTransit.JobTypeStateMachine : MassTransitStateMachine`1<JobTypeSaga> {
    [CompilerGeneratedAttribute]
private State <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private State <Idle>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<AllocateJobSlot> <JobSlotRequested>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<JobSlotReleased> <JobSlotReleased>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<SetConcurrentJobLimit> <SetConcurrentJobLimit>k__BackingField;
    public State Active { get; }
    public State Idle { get; }
    public Event`1<AllocateJobSlot> JobSlotRequested { get; }
    public Event`1<JobSlotReleased> JobSlotReleased { get; }
    public Event`1<SetConcurrentJobLimit> SetConcurrentJobLimit { get; }
    [CompilerGeneratedAttribute]
public State get_Active();
    [CompilerGeneratedAttribute]
public State get_Idle();
    [CompilerGeneratedAttribute]
public Event`1<AllocateJobSlot> get_JobSlotRequested();
    [CompilerGeneratedAttribute]
public Event`1<JobSlotReleased> get_JobSlotReleased();
    [CompilerGeneratedAttribute]
public Event`1<SetConcurrentJobLimit> get_SetConcurrentJobLimit();
    [CompilerGeneratedAttribute]
private EventActivityBinder`2<JobTypeSaga, AllocateJobSlot> <.ctor>b__0_8(EventActivityBinder`2<JobTypeSaga, AllocateJobSlot> allocate);
    [CompilerGeneratedAttribute]
private EventActivityBinder`2<JobTypeSaga, JobSlotReleased> <.ctor>b__0_13(EventActivityBinder`2<JobTypeSaga, JobSlotReleased> empty);
}
[ExtensionAttribute]
internal static class MassTransit.JobTypeStateMachineBehaviorExtensions : object {
    [ExtensionAttribute]
public static bool IsSlotAvailable(BehaviorContext`2<JobTypeSaga, AllocateJobSlot> context, TimeSpan heartbeatTimeout);
    [ExtensionAttribute]
public static EventActivityBinder`2<JobTypeSaga, SetConcurrentJobLimit> SetConcurrentLimit(EventActivityBinder`2<JobTypeSaga, SetConcurrentJobLimit> binder);
}
public interface MassTransit.JsonMessageBody {
    public abstract virtual Nullable`1<JsonElement> GetJsonElement(JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.JsonSerializerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseJsonSerializer(IBusFactoryConfigurator configurator);
    [ExtensionAttribute]
public static void UseJsonDeserializer(IBusFactoryConfigurator configurator, bool isDefault);
    [ExtensionAttribute]
public static void UseJsonSerializer(IReceiveEndpointConfigurator configurator);
    [ExtensionAttribute]
public static void UseJsonDeserializer(IReceiveEndpointConfigurator configurator, bool isDefault);
    [ExtensionAttribute]
public static void ConfigureJsonSerializerOptions(IBusFactoryConfigurator configurator, Func`2<JsonSerializerOptions, JsonSerializerOptions> configure);
    [ExtensionAttribute]
public static void SetMessageSerializerOptions(JsonSerializerOptions options, Func`2<JsonSerializerOptions, JsonSerializerOptions> configure);
}
public class MassTransit.KebabCaseEndpointNameFormatter : SnakeCaseEndpointNameFormatter {
    private static char KebabCaseSeparator;
    [CompilerGeneratedAttribute]
private static IEndpointNameFormatter <Instance>k__BackingField;
    public static IEndpointNameFormatter Instance { get; }
    public KebabCaseEndpointNameFormatter(bool includeNamespace);
    public KebabCaseEndpointNameFormatter(string prefix);
    public KebabCaseEndpointNameFormatter(string prefix, bool includeNamespace);
    private static KebabCaseEndpointNameFormatter();
    [CompilerGeneratedAttribute]
public static IEndpointNameFormatter get_Instance();
    public virtual string SanitizeName(string name);
}
[ExtensionAttribute]
public static class MassTransit.KillSwitchConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseKillSwitch(IBusFactoryConfigurator configurator, Action`1<KillSwitchOptions> configure);
    [ExtensionAttribute]
public static void UseKillSwitch(IReceiveEndpointConfigurator configurator, Action`1<KillSwitchOptions> configure);
}
[ExtensionAttribute]
public static class MassTransit.LatestConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseLatest(IPipeConfigurator`1<T> configurator, Action`1<ILatestConfigurator`1<T>> configure);
}
public class MassTransit.LatestFilterCreated`1 : MulticastDelegate {
    public LatestFilterCreated`1(object object, IntPtr method);
    public virtual void Invoke(ILatestFilter`1<T> filter);
    public virtual IAsyncResult BeginInvoke(ILatestFilter`1<T> filter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class MassTransit.LegacySerializationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated, use ClearSerialization instead")]
public static void ClearMessageDeserializers(IBusFactoryConfigurator configurator);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated, use ClearSerialization instead")]
public static void ClearMessageDeserializers(IReceiveEndpointConfigurator configurator);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Licensing.LicenseFile : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    public string Version { get; public set; }
    public string Kind { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Meta { get; public set; }
    public string Data { get; public set; }
    public string Signature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Meta();
    [CompilerGeneratedAttribute]
public void set_Meta(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
}
public class MassTransit.Licensing.LicenseReader : object {
    private static string _;
    public static LicenseInfo LoadFromFile(string path);
    public static LicenseInfo Load(string license);
    private static Byte[] ExtractPayload(string text);
}
public static class MassTransit.Licensing.LicenseSettings : object {
    public static JsonSerializerOptions SerializerOptions;
    private static LicenseSettings();
}
public static class MassTransit.LogContext : object {
    private static AsyncLocal`1<ILogContext> _current;
    public static Nullable`1<EnabledLogger> Critical { get; }
    public static Nullable`1<EnabledLogger> Debug { get; }
    public static Nullable`1<EnabledLogger> Error { get; }
    public static Nullable`1<EnabledLogger> Info { get; }
    public static Nullable`1<EnabledLogger> Trace { get; }
    public static Nullable`1<EnabledLogger> Warning { get; }
    public static ILogContext Current { get; public set; }
    private static LogContext();
    public static Nullable`1<EnabledLogger> get_Critical();
    public static Nullable`1<EnabledLogger> get_Debug();
    public static Nullable`1<EnabledLogger> get_Error();
    public static Nullable`1<EnabledLogger> get_Info();
    public static Nullable`1<EnabledLogger> get_Trace();
    public static Nullable`1<EnabledLogger> get_Warning();
    public static ILogContext get_Current();
    public static void set_Current(ILogContext value);
    public static void ConfigureCurrentLogContext(ILoggerFactory loggerFactory);
    public static void ConfigureCurrentLogContext(ILogger logger);
    public static ILogContext CreateLogContext(string categoryName);
    public static void ConfigureCurrentLogContextIfNull(IServiceProvider provider);
    public static void SetCurrentIfNull(ILogContext context);
    public static LogMessage`1<T1> Define(LogLevel logLevel, string formatString);
    public static LogMessage`2<T1, T2> Define(LogLevel logLevel, string formatString);
    public static LogMessage`2<T1, T2> DefineMessage(LogLevel logLevel, string formatString);
    public static LogMessage`3<T1, T2, T3> Define(LogLevel logLevel, string formatString);
    public static LogMessage`3<T1, T2, T3> DefineMessage(LogLevel logLevel, string formatString);
    public static LogMessage`4<T1, T2, T3, T4> Define(LogLevel logLevel, string formatString);
    public static LogMessage`4<T1, T2, T3, T4> DefineMessage(LogLevel logLevel, string formatString);
    public static LogMessage`5<T1, T2, T3, T4, T5> Define(LogLevel logLevel, string formatString);
    public static LogMessage`5<T1, T2, T3, T4, T5> DefineMessage(LogLevel logLevel, string formatString);
    private static ILogContext CreateDefaultLogContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Logging.BusLogContext : object {
    private ILoggerFactory _loggerFactory;
    private ILogContext _messageLogger;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    private ILogContext MassTransit.Logging.ILogContext.Messages { get; }
    public ILogger Logger { get; }
    public Nullable`1<EnabledLogger> Critical { get; }
    public Nullable`1<EnabledLogger> Debug { get; }
    public Nullable`1<EnabledLogger> Error { get; }
    public Nullable`1<EnabledLogger> Info { get; }
    public Nullable`1<EnabledLogger> Trace { get; }
    public Nullable`1<EnabledLogger> Warning { get; }
    public BusLogContext(ILoggerFactory loggerFactory);
    private BusLogContext(ILoggerFactory loggerFactory, ILogContext messageLogger, ILogger logger);
    private BusLogContext(ILoggerFactory loggerFactory, ILogger logger);
    private sealed virtual override ILogContext MassTransit.Logging.ILogContext.get_Messages();
    public sealed virtual ILogContext CreateLogContext(string categoryName);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    public sealed virtual Nullable`1<EnabledLogger> get_Critical();
    public sealed virtual Nullable`1<EnabledLogger> get_Debug();
    public sealed virtual Nullable`1<EnabledLogger> get_Error();
    public sealed virtual Nullable`1<EnabledLogger> get_Info();
    public sealed virtual Nullable`1<EnabledLogger> get_Trace();
    public sealed virtual Nullable`1<EnabledLogger> get_Warning();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Logging.DiagnosticActivityExtensions : object {
    private static void SetTag(Activity activity, string key, Nullable`1<Guid> value);
    private static void SetTag(Activity activity, string key, Uri value);
    [ExtensionAttribute]
public static void AddConsumeContextTags(Activity activity, ConsumeContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MassTransit.Logging.DiagnosticHeaders : object {
    public static string DefaultListenerName;
    public static string DiagnosticId;
    public static string ActivityId;
    public static string ActivityCorrelationContext;
    public static string MessageId;
    public static string CorrelationId;
    public static string InitiatorId;
    public static string RequestId;
    public static string SourceAddress;
    public static string DestinationAddress;
    public static string InputAddress;
    public static string TrackingNumber;
    public static string MessageTypes;
    public static string ConsumerType;
    public static string PeerAddress;
    public static string BeginState;
    public static string EndState;
    public static string SagaId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class MassTransit.Logging.EnabledLogger : ValueType {
    private ILogger _logger;
    private LogLevel _level;
    public EnabledLogger(ILogger logger, LogLevel level);
    public void Log(string message, Object[] args);
    public void Log(Exception exception, string message, Object[] args);
}
[NullableContextAttribute("1")]
public interface MassTransit.Logging.ILogContext {
    public ILogger Logger { get; }
    public ILogContext Messages { get; }
    public Nullable`1<EnabledLogger> Critical { get; }
    public Nullable`1<EnabledLogger> Debug { get; }
    public Nullable`1<EnabledLogger> Error { get; }
    public Nullable`1<EnabledLogger> Info { get; }
    public Nullable`1<EnabledLogger> Trace { get; }
    public Nullable`1<EnabledLogger> Warning { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual ILogContext get_Messages();
    public abstract virtual Nullable`1<EnabledLogger> get_Critical();
    public abstract virtual Nullable`1<EnabledLogger> get_Debug();
    public abstract virtual Nullable`1<EnabledLogger> get_Error();
    public abstract virtual Nullable`1<EnabledLogger> get_Info();
    public abstract virtual Nullable`1<EnabledLogger> get_Trace();
    public abstract virtual Nullable`1<EnabledLogger> get_Warning();
    public abstract virtual ILogContext CreateLogContext(string categoryName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MassTransit.Logging.LogCategoryName : object {
    public static string MassTransit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Logging.LogContextActivityExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartSendActivity(ILogContext logContext, SendTransportContext transportContext, SendContext`1<T> context, ValueTuple`2[] tags);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartOutboxSendActivity(ILogContext logContext, SendContext`1<T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartOutboxDeliverActivity(ILogContext logContext, OutboxMessageContext context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartReceiveActivity(ILogContext logContext, string name, string inputAddress, string endpointName, ReceiveContext context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartConsumerActivity(ILogContext logContext, ConsumeContext`1<T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartHandlerActivity(ILogContext logContext, ConsumeContext`1<T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartSagaActivity(ILogContext logContext, SagaConsumeContext`2<TSaga, T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartSagaStateMachineActivity(ILogContext logContext, BehaviorContext`2<TSaga, T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartExecuteActivity(ILogContext logContext, ConsumeContext`1<RoutingSlip> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartCompensateActivity(ILogContext logContext, ConsumeContext`1<RoutingSlip> context);
    [ExtensionAttribute]
public static Nullable`1<StartedActivity> StartGenericActivity(ILogContext logContext, string operationName);
    private static Nullable`1<StartedActivity> PopulateSendActivity(SendContext context, Activity activity, ValueTuple`2[] tags);
    private static ActivityContext GetParentActivityContext(Headers headers, bool isRemote);
    private static Nullable`1<StartedActivity> StartActivity(ConsumeContext context, Action`1<Activity> started);
}
[ExtensionAttribute]
public static class MassTransit.Logging.LogContextInstrumentationExtensions : object {
    private static ConcurrentDictionary`2<string, string> _labelCache;
    private static bool _isConfigured;
    private static Counter`1<long> _receiveTotal;
    private static Counter`1<long> _receiveFaultTotal;
    private static Counter`1<long> _receiveInProgress;
    private static Counter`1<long> _consumeTotal;
    private static Counter`1<long> _consumeFaultTotal;
    private static Counter`1<long> _consumeRetryTotal;
    private static Counter`1<long> _sagaTotal;
    private static Counter`1<long> _sagaFaultTotal;
    private static Counter`1<long> _sendTotal;
    private static Counter`1<long> _sendFaultTotal;
    private static Counter`1<long> _executeTotal;
    private static Counter`1<long> _executeFaultTotal;
    private static Counter`1<long> _compensateTotal;
    private static Counter`1<long> _compensateFaultTotal;
    private static Counter`1<long> _consumerInProgress;
    private static Counter`1<long> _handlerTotal;
    private static Counter`1<long> _handlerFaultTotal;
    private static Counter`1<long> _handlerInProgress;
    private static Counter`1<long> _sagaInProgress;
    private static Counter`1<long> _executeInProgress;
    private static Counter`1<long> _compensateInProgress;
    private static Counter`1<long> _outboxSendTotal;
    private static Counter`1<long> _outboxSendFaultTotal;
    private static Counter`1<long> _outboxDeliveryTotal;
    private static Counter`1<long> _outboxDeliveryFaultTotal;
    private static Histogram`1<double> _receiveDuration;
    private static Histogram`1<double> _consumeDuration;
    private static Histogram`1<double> _handlerDuration;
    private static Histogram`1<double> _sagaDuration;
    private static Histogram`1<double> _deliveryDuration;
    private static Histogram`1<double> _executeDuration;
    private static Histogram`1<double> _compensateDuration;
    private static Char[] _delimiters;
    private static Meter _meter;
    private static InstrumentationOptions _options;
    private static LogContextInstrumentationExtensions();
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartReceiveInstrument(ILogContext logContext, ReceiveContext context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartHandlerInstrument(ILogContext logContext, ConsumeContext`1<TMessage> context, Stopwatch stopwatch);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartSagaInstrument(ILogContext logContext, SagaConsumeContext`2<TSaga, T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartSagaStateMachineInstrument(ILogContext logContext, BehaviorContext`2<TSaga, T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartConsumeInstrument(ILogContext logContext, ConsumeContext`1<T> context, Stopwatch timer);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartActivityExecuteInstrument(ILogContext logContext, ConsumeContext`1<RoutingSlip> context, Stopwatch timer);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartActivityCompensateInstrument(ILogContext logContext, ConsumeContext`1<RoutingSlip> context, Stopwatch timer);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartSendInstrument(ILogContext logContext, SendTransportContext transportContext, SendContext`1<T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartOutboxSendInstrument(ILogContext logContext, SendContext`1<T> context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartOutboxDeliveryInstrument(ILogContext logContext, OutboxMessageContext context);
    [ExtensionAttribute]
public static Nullable`1<StartedInstrument> StartOutboxDeliveryInstrument(ILogContext logContext, OutboxConsumeContext consumeContext, OutboxMessageContext context);
    public static void TryConfigure(IServiceProvider provider);
    public static void TryConfigure(InstrumentationOptions options);
    private static void Configure(Meter meter, InstrumentationOptions options);
    private static void AddCustomTags(TagList& tags, PipeContext pipeContext);
    private static string GetConsumerTypeLabel(string messageLabel);
    private static string CleanupLabel(string label);
    private static string GetArgumentTypeLabel();
    private static string GetLogTypeLabel();
    private static string GetActivityTypeLabel();
    private static string GetEndpointLabel(Uri inputAddress);
    private static string GetMessageTypeLabel();
    private static string FormatTypeName(StringBuilder sb, Type type);
    [CompilerGeneratedAttribute]
internal static string <CleanupLabel>g__SimpleClean|53_0(string text);
}
public class MassTransit.Logging.LogMessage`1 : MulticastDelegate {
    public LogMessage`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, Exception exception);
    public virtual IAsyncResult BeginInvoke(T1 arg1, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class MassTransit.Logging.LogMessage`2 : MulticastDelegate {
    public LogMessage`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, Exception exception);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class MassTransit.Logging.LogMessage`3 : MulticastDelegate {
    public LogMessage`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, Exception exception);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Logging.LogMessage`4 : MulticastDelegate {
    [NullableContextAttribute("0")]
public LogMessage`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, Exception exception, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Logging.LogMessage`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public LogMessage`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, Exception exception, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MassTransit.Logging.OperationName : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Logging.SagaLogExtensions : object {
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logUsed;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logAdded;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logCreated;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logInserted;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logInsertFaulted;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logRemoved;
    private static LogMessage`3<string, Nullable`1<Guid>, string> _logFaulted;
    private static SagaLogExtensions();
    [ExtensionAttribute]
public static void LogUsed(SagaConsumeContext`2<TSaga, TMessage> context, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogAdded(SagaConsumeContext`2<TSaga, TMessage> context, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogCreated(SagaConsumeContext`2<TSaga, TMessage> context, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogInsert(ConsumeContext`1<TMessage> context, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogInsertFault(ConsumeContext`1<TMessage> context, Exception exception, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogRemoved(SagaConsumeContext`2<TSaga, TMessage> context, Nullable`1<Guid> correlationId);
    [ExtensionAttribute]
public static void LogFault(ConsumeContext`1<TMessage> context, Exception exception, Nullable`1<Guid> correlationId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Logging.SingleLoggerFactory : object {
    private ILogger _logger;
    public SingleLoggerFactory(ILogger logger);
    public sealed virtual ILogger CreateLogger(string name);
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class MassTransit.Logging.StartedActivity : ValueType {
    public Activity Activity;
    public StartedActivity(Activity activity);
    public void SetTag(string key, string value);
    public void Update(SendContext`1<T> context);
    public void AddExceptionEvent(Exception exception, bool escaped);
    public void Stop();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class MassTransit.Logging.StartedInstrument : ValueType {
    private Action`1<Exception> _onFault;
    [NullableAttribute("2")]
private Action _onStop;
    public StartedInstrument(Action`1<Exception> onFault, Action onStop);
    public void AddException(Exception exception);
    public void Stop();
}
public class MassTransit.Logging.TextWriterLogger : object {
    [NullableAttribute("1")]
private TextWriterLoggerFactory _factory;
    private LogLevel _logLevel;
    [NullableContextAttribute("1")]
public TextWriterLogger(TextWriterLoggerFactory factory, LogLevel logLevel);
    [NullableContextAttribute("1")]
public sealed virtual IDisposable BeginScope(TState state);
    [NullableContextAttribute("2")]
public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Logging.TextWriterLoggerFactory : object {
    private TextWriterLoggerOptions _options;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public TextWriter Writer { get; }
    public TextWriterLoggerFactory(TextWriter textWriter, IOptions`1<TextWriterLoggerOptions> options);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    public sealed virtual ILogger CreateLogger(string name);
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual void Dispose();
}
public class MassTransit.Logging.TextWriterLoggerOptions : object {
    private List`1<string> _disabled;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    public TextWriterLoggerOptions Disable(string name);
    public bool IsEnabled(string name);
}
public class MassTransit.MassTransitApplicationException : Exception {
    private Dictionary`2<string, object> _data;
    public IDictionary Data { get; }
    public IDictionary`2<string, object> ApplicationData { get; }
    public MassTransitApplicationException(Exception innerException);
    public MassTransitApplicationException(Exception innerException, object values);
    public MassTransitApplicationException(Exception innerException, IEnumerable`1<KeyValuePair`2<string, object>> values);
    public MassTransitApplicationException(string message, Exception innerException);
    public MassTransitApplicationException(string message, Exception innerException, object values);
    public MassTransitApplicationException(string message, Exception innerException, IEnumerable`1<KeyValuePair`2<string, object>> values);
    public virtual IDictionary get_Data();
    public IDictionary`2<string, object> get_ApplicationData();
    private void ImportExceptionData(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.MassTransitBus : object {
    private IBusObserver _busObservable;
    private IConsumePipe _consumePipe;
    private IHost _host;
    private ILogContext _logContext;
    private IPublishEndpoint _publishEndpoint;
    private IReceiveEndpoint _receiveEndpoint;
    [NullableAttribute("2")]
private Handle _busHandle;
    private BusState _busState;
    private string _healthMessage;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private IBusTopology <Topology>k__BackingField;
    public Uri Address { get; }
    public IBusTopology Topology { get; }
    public MassTransitBus(IHost host, IBusObserver busObservable, IReceiveEndpointConfiguration endpointConfiguration);
    private sealed virtual override ConnectHandle MassTransit.IConsumePipeConnector.ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    private sealed virtual override ConnectHandle MassTransit.IConsumePipeConnector.ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    private sealed virtual override ConnectHandle MassTransit.IRequestPipeConnector.ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(T message, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(T message, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(T message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object message, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object message, Type messageType, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object message, Type messageType, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object values, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object values, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.IPublishEndpoint.Publish(object values, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual IBusTopology get_Topology();
    private sealed virtual override Task`1<ISendEndpoint> MassTransit.ISendEndpointProvider.GetSendEndpoint(Uri address);
    [AsyncStateMachineAttribute("MassTransit.MassTransitBus/<StartAsync>d__30")]
public sealed virtual Task`1<BusHandle> StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MassTransitBus/<StopAsync>d__31")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual BusHealthResult CheckHealth();
    private sealed virtual override ConnectHandle MassTransit.IConsumeObserverConnector.ConnectConsumeObserver(IConsumeObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IConsumeMessageObserverConnector.ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IReceiveEndpointObserverConnector.ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IEndpointConfigurationObserverConnector.ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
    private sealed virtual override HostReceiveEndpointHandle MassTransit.IReceiveConnector.ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    private sealed virtual override HostReceiveEndpointHandle MassTransit.IReceiveConnector.ConnectReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.MassTransitHealthCheckOptionsExtensions : object {
    [ExtensionAttribute]
public static IBusRegistrationConfigurator ConfigureHealthCheckOptions(IBusRegistrationConfigurator configurator, Action`1<IHealthCheckOptionsConfigurator> callback);
    [ExtensionAttribute]
public static IBusRegistrationConfigurator ConfigureHealthCheckOptions(IBusRegistrationConfigurator`1<T> configurator, Action`1<IHealthCheckOptionsConfigurator> callback);
}
public class MassTransit.MassTransitHostedService : object {
    private IBusDepot _depot;
    private IOptions`1<MassTransitHostOptions> _options;
    private Task _startTask;
    private bool _stopped;
    public MassTransitHostedService(IBusDepot depot, IOptions`1<MassTransitHostOptions> options);
    [AsyncStateMachineAttribute("MassTransit.MassTransitHostedService/<DisposeAsync>d__5")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MassTransitHostedService/<StopAsync>d__7")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
}
public class MassTransit.MassTransitStateMachine`1 : object {
    private HashSet`1<string> _compositeEvents;
    private Dictionary`2<string, StateMachineEvent<TInstance>> _eventCache;
    private Dictionary`2<Event, EventCorrelation> _eventCorrelations;
    private EventObservable<TInstance> _eventObservers;
    private State`1<TInstance> _final;
    private State`1<TInstance> _initial;
    private Lazy`1<StateMachineRegistration[]> _registrations;
    private Dictionary`2<string, State`1<TInstance>> _stateCache;
    private StateObservable<TInstance> _stateObservers;
    private IStateAccessor`1<TInstance> _accessor;
    private List`1<FieldInfo> _backingFields;
    private Func`2<BehaviorContext`1<TInstance>, Task`1<bool>> _isCompleted;
    private string _name;
    private List`1<PropertyInfo> _stateMachineProperties;
    private UnhandledEventCallback`1<TInstance> _unhandledEventCallback;
    private IEnumerable`1<State`1<TInstance>> IntrospectionStates { get; }
    public IEnumerable`1<EventCorrelation> Correlations { get; }
    private string MassTransit.StateMachine.Name { get; }
    public IStateAccessor`1<TInstance> Accessor { get; }
    public State Initial { get; }
    public State Final { get; }
    public IEnumerable`1<State> States { get; }
    public IEnumerable`1<Event> Events { get; }
    private Type MassTransit.StateMachine.InstanceType { get; }
    [IteratorStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<get_IntrospectionStates>d__21")]
private IEnumerable`1<State`1<TInstance>> get_IntrospectionStates();
    [IteratorStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<get_Correlations>d__23")]
public sealed virtual IEnumerable`1<EventCorrelation> get_Correlations();
    private sealed virtual override Task`1<bool> MassTransit.SagaStateMachine<TInstance>.IsCompleted(BehaviorContext`1<TInstance> context);
    private sealed virtual override string MassTransit.StateMachine.get_Name();
    public sealed virtual IStateAccessor`1<TInstance> get_Accessor();
    public sealed virtual State get_Initial();
    public sealed virtual State get_Final();
    private sealed virtual override State MassTransit.StateMachine.GetState(string name);
    [AsyncStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<MassTransit-StateMachine<TInstance>-RaiseEvent>d__34")]
private sealed virtual override Task MassTransit.StateMachine<TInstance>.RaiseEvent(BehaviorContext`1<TInstance> context);
    [AsyncStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<MassTransit-StateMachine<TInstance>-RaiseEvent>d__35`1")]
private sealed virtual override Task MassTransit.StateMachine<TInstance>.RaiseEvent(BehaviorContext`2<TInstance, T> context);
    public sealed virtual State`1<TInstance> GetState(string name);
    public sealed virtual IEnumerable`1<State> get_States();
    private sealed virtual override Event MassTransit.StateMachine.GetEvent(string name);
    public sealed virtual IEnumerable`1<Event> get_Events();
    private sealed virtual override Type MassTransit.StateMachine.get_InstanceType();
    public sealed virtual IEnumerable`1<Event> NextEvents(State state);
    public sealed virtual bool IsCompositeEvent(Event event);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual IDisposable ConnectEventObserver(IEventObserver`1<TInstance> observer);
    public sealed virtual IDisposable ConnectEventObserver(Event event, IEventObserver`1<TInstance> observer);
    public sealed virtual IDisposable ConnectStateObserver(IStateObserver`1<TInstance> stateObserver);
    private bool TryGetState(string name, State`1& state);
    private Task DefaultUnhandledEventCallback(UnhandledEventContext`1<TInstance> context);
    protected internal void InstanceState(Expression`1<Func`2<TInstance, State>> instanceStateProperty);
    protected internal void InstanceState(Expression`1<Func`2<TInstance, string>> instanceStateProperty);
    protected internal void InstanceState(Expression`1<Func`2<TInstance, int>> instanceStateProperty, State[] states);
    protected internal void Name(string machineName);
    protected internal void Event(Expression`1<Func`1<Event>> propertyExpression);
    protected internal Event Event(string name);
    private Event DeclareTriggerEvent(string name);
    protected void SetCompleted(Func`2<TInstance, Task`1<bool>> completed);
    protected void SetCompleted(Func`2<BehaviorContext`1<TInstance>, Task`1<bool>> completed);
    protected void SetCompletedWhenFinalized();
    [AsyncStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<IsFinalized>d__63")]
private Task`1<bool> IsFinalized(BehaviorContext`1<TInstance> context);
    private Event`1<T> DeclareDataEvent(string name);
    private TEvent DeclarePropertyBasedEvent(Func`2<PropertyInfo, TEvent> ctor, PropertyInfo property);
    private TEvent DeclareEvent(Func`2<string, TEvent> ctor, string name);
    protected void Event(Expression`1<Func`1<Event`1<T>>> propertyExpression, Action`1<IEventCorrelationConfigurator`2<TInstance, T>> configureEventCorrelation);
    protected internal void Event(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, Event`1<T>>> eventPropertyExpression, Action`1<IEventCorrelationConfigurator`2<TInstance, T>> configureEventCorrelation);
    protected internal void Event(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, Event`1<T>>> eventPropertyExpression);
    protected internal void Event(Expression`1<Func`1<Event`1<T>>> propertyExpression);
    protected internal Event`1<T> Event(string name);
    protected internal Event`1<T> Event(string name, Action`1<IEventCorrelationConfigurator`2<TInstance, T>> configure);
    protected internal Event CompositeEvent(Expression`1<Func`1<Event>> propertyExpression, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(Expression`1<Func`1<Event>> propertyExpression, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    protected internal Event CompositeEvent(Expression`1<Func`1<Event>> propertyExpression, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(Expression`1<Func`1<Event>> propertyExpression, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    internal Event CompositeEvent(string name, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(string name, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    internal Event CompositeEvent(string name, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(string name, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    protected internal Event CompositeEvent(Event event, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(Event event, Expression`1<Func`2<TInstance, CompositeEventStatus>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    protected internal Event CompositeEvent(Event event, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, Event[] events);
    protected internal Event CompositeEvent(Event event, Expression`1<Func`2<TInstance, int>> trackingPropertyExpression, CompositeEventOptions options, Event[] events);
    private Event CompositeEvent(Expression`1<Func`1<Event>> propertyExpression, ICompositeEventStatusAccessor`1<TInstance> accessor, CompositeEventOptions options, Event[] events);
    private Event CompositeEvent(string name, ICompositeEventStatusAccessor`1<TInstance> accessor, CompositeEventOptions options, Event[] events);
    private Event CompositeEvent(Event event, ICompositeEventStatusAccessor`1<TInstance> accessor, CompositeEventOptions options, Event[] events);
    protected internal void State(Expression`1<Func`1<State>> propertyExpression);
    protected internal State`1<TInstance> State(string name);
    private void DeclareState(PropertyInfo property);
    protected internal void State(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression);
    private static StateMachineState<TInstance> GetStateProperty(PropertyInfo stateProperty, TProperty propertyValue);
    protected internal void SubState(Expression`1<Func`1<State>> propertyExpression, State superState);
    protected internal State`1<TInstance> SubState(string name, State superState);
    protected internal void SubState(Expression`1<Func`1<TProperty>> propertyExpression, Expression`1<Func`2<TProperty, State>> statePropertyExpression, State superState);
    private void SetState(string name, StateMachineState<TInstance> state);
    protected internal void During(State state, EventActivities`1[] activities);
    protected internal void During(State state1, State state2, EventActivities`1[] activities);
    protected internal void During(State state1, State state2, State state3, EventActivities`1[] activities);
    protected internal void During(State state1, State state2, State state3, State state4, EventActivities`1[] activities);
    protected internal void During(IEnumerable`1<State> states, EventActivities`1[] activities);
    private void BindActivitiesToState(State state, IActivityBinder`1[] eventActivities);
    protected internal void Initially(EventActivities`1[] activities);
    protected internal void DuringAny(EventActivities`1[] activities);
    protected internal void Finally(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    private void BindTransitionEvents(State`1<TInstance> state, IEnumerable`1<EventActivities`1<TInstance>> activities);
    protected internal EventActivityBinder`1<TInstance> When(Event event);
    protected internal EventActivityBinder`1<TInstance> When(Event event, StateMachineCondition`1<TInstance> filter);
    protected internal void WhenEnter(State state, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    protected internal void WhenEnterAny(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    protected internal void WhenLeaveAny(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    private void BindEveryTransitionEvent(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback, Func`2<State`1<TInstance>, Event> eventProvider);
    protected internal void BeforeEnterAny(Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    protected internal void AfterLeaveAny(Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    private void BindEveryTransitionEvent(Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback, Func`2<State`1<TInstance>, Event`1<State>> eventProvider);
    protected internal void WhenLeave(State state, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    protected internal void BeforeEnter(State state, Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    protected internal void AfterLeave(State state, Func`2<EventActivityBinder`2<TInstance, State>, EventActivityBinder`2<TInstance, State>> activityCallback);
    protected internal EventActivityBinder`2<TInstance, TMessage> When(Event`1<TMessage> event);
    protected internal EventActivityBinder`2<TInstance, TMessage> When(Event`1<TMessage> event, StateMachineCondition`2<TInstance, TMessage> filter);
    protected internal EventActivities`1<TInstance> Ignore(Event event);
    protected internal EventActivities`1<TInstance> Ignore(Event`1<TData> event);
    protected internal EventActivities`1<TInstance> Ignore(Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter);
    protected internal void OnUnhandledEvent(UnhandledEventCallback`1<TInstance> callback);
    private Task UnhandledEvent(BehaviorContext`1<TInstance> context, State state);
    protected void Request(Expression`1<Func`1<Request`3<TInstance, TRequest, TResponse>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, Action`1<IRequestConfigurator`3<TInstance, TRequest, TResponse>> configureRequest);
    protected void Request(Expression`1<Func`1<Request`3<TInstance, TRequest, TResponse>>> propertyExpression, Action`1<IRequestConfigurator`3<TInstance, TRequest, TResponse>> configureRequest);
    protected void Request(Expression`1<Func`1<Request`3<TInstance, TRequest, TResponse>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, RequestSettings`3<TInstance, TRequest, TResponse> settings);
    protected internal void Request(Expression`1<Func`1<Request`3<TInstance, TRequest, TResponse>>> propertyExpression, RequestSettings`3<TInstance, TRequest, TResponse> settings);
    protected void Request(Expression`1<Func`1<Request`4<TInstance, TRequest, TResponse, TResponse2>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, Action`1<IRequestConfigurator`4<TInstance, TRequest, TResponse, TResponse2>> configureRequest);
    protected void Request(Expression`1<Func`1<Request`4<TInstance, TRequest, TResponse, TResponse2>>> propertyExpression, Action`1<IRequestConfigurator`4<TInstance, TRequest, TResponse, TResponse2>> configureRequest);
    protected internal void Request(Expression`1<Func`1<Request`4<TInstance, TRequest, TResponse, TResponse2>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, RequestSettings`4<TInstance, TRequest, TResponse, TResponse2> settings);
    protected internal void Request(Expression`1<Func`1<Request`4<TInstance, TRequest, TResponse, TResponse2>>> propertyExpression, RequestSettings`4<TInstance, TRequest, TResponse, TResponse2> settings);
    protected void Request(Expression`1<Func`1<Request`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, Action`1<IRequestConfigurator`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>> configureRequest);
    protected void Request(Expression`1<Func`1<Request`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>>> propertyExpression, Action`1<IRequestConfigurator`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>> configureRequest);
    protected internal void Request(Expression`1<Func`1<Request`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> requestIdExpression, RequestSettings`5<TInstance, TRequest, TResponse, TResponse2, TResponse3> settings);
    protected internal void Request(Expression`1<Func`1<Request`5<TInstance, TRequest, TResponse, TResponse2, TResponse3>>> propertyExpression, RequestSettings`5<TInstance, TRequest, TResponse, TResponse2, TResponse3> settings);
    protected void Schedule(Expression`1<Func`1<Schedule`2<TInstance, TMessage>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> tokenIdExpression, Action`1<IScheduleConfigurator`2<TInstance, TMessage>> configureSchedule);
    protected internal void Schedule(Expression`1<Func`1<Schedule`2<TInstance, TMessage>>> propertyExpression, Expression`1<Func`2<TInstance, Nullable`1<Guid>>> tokenIdExpression, ScheduleSettings`2<TInstance, TMessage> settings);
    private static Task`1<bool> NotCompletedByDefault(BehaviorContext`1<TInstance> instance);
    private void InitializeSchedule(MassTransitStateMachine`1<TInstance> stateMachine, PropertyInfo property, Schedule`2<TInstance, T> schedule);
    private void InitializeRequest(MassTransitStateMachine`1<TInstance> stateMachine, PropertyInfo property, Request`3<TInstance, TRequest, TResponse> request);
    private void RegisterImplicit();
    private static EventRegistration<TInstance> GetEventRegistration(Event event, Type messageType);
    private static EventRegistration<TInstance> CreateRegistration(Type registrationType, Event event, Type messageType);
    private StateMachine`1<TInstance> Modify(Action`1<IStateMachineModifier`1<TInstance>> modifier);
    public static MassTransitStateMachine`1<TInstance> New(Action`1<IStateMachineModifier`1<TInstance>> modifier);
    private StateMachineRegistration[] GetRegistrations();
    private IEnumerable`1<PropertyInfo> GetStateMachineProperties();
    private bool TryGetBackingField(PropertyInfo property, FieldInfo& backingField);
    [IteratorStateMachineAttribute("MassTransit.MassTransitStateMachine`1/<GetBackingFields>d__151")]
private static IEnumerable`1<FieldInfo> GetBackingFields(Type type);
    private void InitializeState(MassTransitStateMachine`1<TInstance> stateMachine, PropertyInfo property, StateMachineState<TInstance> state);
    private void InitializeStateProperty(PropertyInfo stateProperty, TProperty propertyValue, StateMachineState<TInstance> state);
    private void InitializeEvent(MassTransitStateMachine`1<TInstance> stateMachine, PropertyInfo property, Event event);
    private void InitializeEventProperty(PropertyInfo eventProperty, TProperty propertyValue, Event event);
    [CompilerGeneratedAttribute]
private StateMachineRegistration[] <.ctor>b__19_0();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__19_1(BehaviorContext`1<TInstance> context, State state);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__19_2(BehaviorContext`1<TInstance> context, State state);
    [CompilerGeneratedAttribute]
private Event <Event>b__57_0(PropertyInfo prop);
    [CompilerGeneratedAttribute]
private Event`1<T> <Event>b__70_0(PropertyInfo prop);
    [CompilerGeneratedAttribute]
private Event <CompositeEvent>g__CreateEvent|85_0(<>c__DisplayClass85_0& );
    [CompilerGeneratedAttribute]
private Event <CompositeEvent>g__CreateEvent|86_0(<>c__DisplayClass86_0& );
    [CompilerGeneratedAttribute]
private Task <State>b__89_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private Task <DeclareState>b__90_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private Task <State>b__91_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private Task <SubState>b__93_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private Task <SubState>b__94_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private Task <SubState>b__95_0(BehaviorContext`1<TInstance> c, State s);
    [CompilerGeneratedAttribute]
private bool <DuringAny>b__104_1(State`1<TInstance> x);
    [CompilerGeneratedAttribute]
private bool <DuringAny>b__104_2(IActivityBinder`1<TInstance> binder);
    [CompilerGeneratedAttribute]
private bool <GetStateMachineProperties>b__149_0(PropertyInfo x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Mediator.Contexts.MediatorClientFactoryContext : object {
    private IConsumePipe _connector;
    private ISendEndpoint _endpoint;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestTimeout <DefaultTimeout>k__BackingField;
    public Uri ResponseAddress { get; }
    public RequestTimeout DefaultTimeout { get; }
    public MediatorClientFactoryContext(ISendEndpoint endpoint, IConsumePipe connector, Uri responseAddress, RequestTimeout defaultTimeout);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ResponseAddress();
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(ConsumeContext consumeContext);
    public sealed virtual IRequestSendEndpoint`1<T> GetRequestEndpoint(Uri destinationAddress, ConsumeContext consumeContext);
    [CompilerGeneratedAttribute]
public sealed virtual RequestTimeout get_DefaultTimeout();
}
public class MassTransit.Mediator.Contexts.MediatorPublishSendEndpoint : SendEndpointProxy {
    private PublishObservable _observers;
    private IPublishPipe _publishPipe;
    public MediatorPublishSendEndpoint(ISendEndpoint endpoint, IPublishPipe publishPipe);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    protected virtual IPipe`1<SendContext`1<T>> GetPipeProxy(IPipe`1<SendContext`1<T>> pipe);
}
internal static class MassTransit.Mediator.Contexts.MediatorReceiveContext : object {
    private static string ContentTypeHeaderValue;
    internal static ContentType ObjectContentType;
    private static MediatorReceiveContext();
}
public class MassTransit.Mediator.Contexts.MediatorReceiveContext`1 : ProxyPipeContext {
    private MediatorConsumeContext`1<TMessage> _consumeContext;
    private MessageIdMessageHeader _headers;
    private IReceiveObserver _observers;
    private PendingTaskCollection _receiveTasks;
    private Stopwatch _receiveTimer;
    [CompilerGeneratedAttribute]
private IPublishTopology <PublishTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendEndpointProvider <SendEndpointProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IPublishEndpointProvider <PublishEndpointProvider>k__BackingField;
    public IPublishTopology PublishTopology { get; }
    public bool IsDelivered { get; internal set; }
    public bool IsFaulted { get; private set; }
    public bool PublishFaults { get; }
    public MessageBody Body { get; }
    public Task ReceiveCompleted { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public bool Redelivered { get; }
    public Headers TransportHeaders { get; }
    public TimeSpan ElapsedTime { get; }
    public Uri InputAddress { get; }
    public ContentType ContentType { get; }
    public MediatorReceiveContext`1(SendContext`1<TMessage> sendContext, ISendEndpointProvider sendEndpointProvider, IPublishEndpointProvider publishEndpointProvider, IPublishTopology publishTopology, IReceiveObserver observers, IObjectDeserializer objectDeserializer);
    [CompilerGeneratedAttribute]
public IPublishTopology get_PublishTopology();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDelivered();
    [CompilerGeneratedAttribute]
internal void set_IsDelivered(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFaulted();
    [CompilerGeneratedAttribute]
private void set_IsFaulted(bool value);
    public sealed virtual bool get_PublishFaults();
    public sealed virtual MessageBody get_Body();
    public sealed virtual Task get_ReceiveCompleted();
    public sealed virtual void AddReceiveTask(Task task);
    [CompilerGeneratedAttribute]
public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IPublishEndpointProvider get_PublishEndpointProvider();
    public sealed virtual bool get_Redelivered();
    public sealed virtual Headers get_TransportHeaders();
    public sealed virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual Task NotifyFaulted(Exception exception);
    public sealed virtual TimeSpan get_ElapsedTime();
    public sealed virtual Uri get_InputAddress();
    public sealed virtual ContentType get_ContentType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private ConsumeContext <.ctor>b__5_0();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private ConsumeContext <.ctor>b__5_1(ConsumeContext existing);
}
public class MassTransit.Mediator.Contexts.MediatorRequestSendEndpoint`1 : RequestSendEndpoint`1<TRequest> {
    private ISendEndpoint _endpoint;
    public MediatorRequestSendEndpoint`1(ISendEndpoint endpoint, ConsumeContext consumeContext);
    protected virtual Task`1<ISendEndpoint> GetSendEndpoint();
}
public class MassTransit.Mediator.Contexts.MediatorSendEndpoint : object {
    private Uri _destinationAddress;
    private IReceivePipeDispatcher _dispatcher;
    private ILogContext _logContext;
    private IObjectDeserializer _objectDeserializer;
    private MediatorPublishSendEndpoint _publishSendEndpoint;
    private IPublishTopologyConfigurator _publishTopology;
    private ReceiveObservable _receiveObservers;
    private SendObservable _sendObservers;
    private ISendPipe _sendPipe;
    private Uri _sourceAddress;
    private MediatorSendEndpoint _sourceEndpoint;
    private MediatorSendEndpoint(IReceiveEndpointConfiguration configuration, IReceivePipeDispatcher dispatcher, ILogContext logContext, SendObservable sendObservers);
    public MediatorSendEndpoint(IReceiveEndpointConfiguration configuration, IReceivePipeDispatcher dispatcher, ILogContext logContext, SendObservable sendObservers, IReceiveEndpointConfiguration sourceConfiguration, IReceivePipeDispatcher sourceDispatcher);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Mediator.Contexts.MediatorSendEndpoint/<Send>d__24`1")]
public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Mediator.Contexts.MediatorSendEndpoint/<Send>d__25`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Mediator.Contexts.MediatorSendEndpoint/<Send>d__26`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Mediator.Contexts.MediatorSendEndpoint/<CreateSendContext>d__27`1")]
public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Mediator.Contexts.MediatorSendEndpoint/<SendMessage>d__28`1")]
private Task SendMessage(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
}
public class MassTransit.Mediator.Contexts.MediatorSerializationContext`1 : BaseSerializerContext {
    private TMessage _message;
    public MediatorSerializationContext`1(IObjectDeserializer deserializer, MessageContext context, TMessage message, String[] supportedMessageTypes);
    public virtual bool TryGetMessage(T& message);
    public virtual bool TryGetMessage(Type messageType, Object& message);
    public virtual IMessageSerializer GetMessageSerializer();
    public virtual IMessageSerializer GetMessageSerializer(MessageEnvelope envelope, T message);
    public virtual IMessageSerializer GetMessageSerializer(object message, String[] messageTypes);
    public virtual Dictionary`2<string, object> ToDictionary(T message);
}
public class MassTransit.Mediator.MassTransitMediator : object {
    private ClientFactory _clientFactory;
    private IReceivePipeDispatcher _dispatcher;
    private MediatorSendEndpoint _endpoint;
    private IReceivePipeDispatcher _responseDispatcher;
    public ClientFactoryContext Context { get; }
    public MassTransitMediator(ILogContext logContext, IReceiveEndpointConfiguration configuration, IReceivePipeDispatcher dispatcher, IReceiveEndpointConfiguration responseConfiguration, IReceivePipeDispatcher responseDispatcher);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual Task Publish(T message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual RequestHandle`1<T> CreateRequest(T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, T message, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual RequestHandle`1<T> CreateRequest(ConsumeContext consumeContext, Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual IRequestClient`1<T> CreateRequestClient(ConsumeContext consumeContext, Uri destinationAddress, RequestTimeout timeout);
    public sealed virtual ClientFactoryContext get_Context();
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    private Task PublishInternal(CancellationToken cancellationToken, T message, IPipe`1<PublishContext`1<T>> pipe);
    private Task PublishInternal(CancellationToken cancellationToken, object values, IPipe`1<PublishContext`1<T>> pipe);
}
[ExtensionAttribute]
public static class MassTransit.MediatorConfigurationExtensions : object {
    [ExtensionAttribute]
public static IMediator CreateMediator(IBusFactorySelector selector, Action`1<IMediatorConfigurator> configure);
}
public class MassTransit.MessageConsumeTopology`1 : object {
    private List`1<IMessageConsumeTopologyConvention`1<TMessage>> _conventions;
    private List`1<IMessageConsumeTopology`1<TMessage>> _delegateTopologies;
    private List`1<IMessageConsumeTopology`1<TMessage>> _topologies;
    [CompilerGeneratedAttribute]
private bool <ConfigureConsumeTopology>k__BackingField;
    protected bool IsBindableMessageType { get; }
    public bool ConfigureConsumeTopology { get; public set; }
    protected bool get_IsBindableMessageType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConfigureConsumeTopology();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConfigureConsumeTopology(bool value);
    public sealed virtual void Add(IMessageConsumeTopology`1<TMessage> consumeTopology);
    public sealed virtual void AddDelegate(IMessageConsumeTopology`1<TMessage> configuration);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    public sealed virtual bool TryAddConvention(IMessageConsumeTopologyConvention`1<TMessage> convention);
    public sealed virtual void UpdateConvention(Func`2<TConvention, TConvention> update);
    public sealed virtual void AddOrUpdateConvention(Func`1<TConvention> add, Func`2<TConvention, TConvention> update);
    public sealed virtual bool TryAddConvention(IConsumeTopologyConvention convention);
    public virtual IEnumerable`1<ValidationResult> Validate();
}
public static class MassTransit.MessageCorrelation : object {
    public static void UseCorrelationId(Func`2<T, Guid> getCorrelationId);
}
public class MassTransit.MessageData.Configuration.CourierMessageDataConfigurationObserver : ConfigurationObserver {
    private bool _includeMessages;
    private IMessageDataRepository _repository;
    public CourierMessageDataConfigurationObserver(IConsumePipeConfigurator configurator, IMessageDataRepository repository, bool includeMessages);
    public sealed virtual void MessageConfigured(IConsumePipeConfigurator configurator);
    public virtual void ActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator, Uri compensateAddress);
    public virtual void ExecuteActivityConfigured(IExecuteActivityConfigurator`2<TActivity, TArguments> configurator);
    public virtual void CompensateActivityConfigured(ICompensateActivityConfigurator`2<TActivity, TLog> configurator);
    public void Method4();
    public void Method5();
    public void Method6();
}
public class MassTransit.MessageData.Configuration.GetMessageDataObjectArrayTransformConfiguration`3 : object {
    private PropertyInfo _property;
    private GetMessageDataTransformSpecification`1<TElement> _transformConfigurator;
    public GetMessageDataObjectArrayTransformConfiguration`3(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.GetMessageDataObjectDictionaryTransformConfiguration`4 : object {
    private PropertyInfo _property;
    private GetMessageDataTransformSpecification`1<TValue> _transformConfigurator;
    public GetMessageDataObjectDictionaryTransformConfiguration`4(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.GetMessageDataObjectTransformConfiguration`2 : object {
    private PropertyInfo _property;
    private GetMessageDataTransformSpecification`1<TProperty> _transformConfigurator;
    public GetMessageDataObjectTransformConfiguration`2(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.GetMessageDataTransformConfiguration`2 : object {
    private PropertyInfo _property;
    private IMessageDataRepository _repository;
    public GetMessageDataTransformConfiguration`2(IMessageDataRepository repository, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.GetMessageDataTransformSpecification`1 : TransformSpecification`1<TMessage> {
    public GetMessageDataTransformSpecification`1(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.CompensateContext<TMessage>>.Apply(IPipeBuilder`1<CompensateContext`1<TMessage>> builder);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.ConsumeContext<TMessage>>.Apply(IPipeBuilder`1<ConsumeContext`1<TMessage>> builder);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.ExecuteContext<TMessage>>.Apply(IPipeBuilder`1<ExecuteContext`1<TMessage>> builder);
    public bool TryGetConsumeTopology(IMessageConsumeTopology`1& topology);
    public bool TryGetConverter(IPropertyConverter`2& converter);
    private void AddMessageDataProperties(IMessageDataRepository repository, ICollection`1<Type> knownTypes);
    private static bool IsUnknownObjectType(ICollection`1<Type> knownTypes, Type propertyType);
    [CompilerGeneratedAttribute]
private void <AddMessageDataProperties>g__ConfigureDictionary|6_0(Type keyType, Type valueType, <>c__DisplayClass6_0& , <>c__DisplayClass6_1& , <>c__DisplayClass6_2& );
    [CompilerGeneratedAttribute]
private void <AddMessageDataProperties>g__ConfigureArray|6_1(Type elementType, <>c__DisplayClass6_0& , <>c__DisplayClass6_1& , <>c__DisplayClass6_2& );
}
public interface MassTransit.MessageData.Configuration.IMessageDataTransformConfiguration`1 {
    public abstract virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
[ExtensionAttribute]
public static class MassTransit.MessageData.Configuration.MessageDataRepositorySelectorExtensions : object {
    [ExtensionAttribute]
public static IMessageDataRepository InMemory(IMessageDataRepositorySelector selector);
    [ExtensionAttribute]
public static IMessageDataRepository FileSystem(IMessageDataRepositorySelector selector, string path);
    [ExtensionAttribute]
public static IMessageDataRepository Encrypted(IMessageDataRepositorySelector selector, ICryptoStreamProvider streamProvider, Func`2<IMessageDataRepositorySelector, IMessageDataRepository> innerSelector);
}
public class MassTransit.MessageData.Configuration.PutMessageDataObjectArrayTransformConfiguration`3 : object {
    private PropertyInfo _property;
    private PutMessageDataTransformSpecification`1<TElement> _transformConfigurator;
    public PutMessageDataObjectArrayTransformConfiguration`3(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.PutMessageDataObjectDictionaryTransformConfiguration`4 : object {
    private PropertyInfo _property;
    private PutMessageDataTransformSpecification`1<TValue> _transformConfigurator;
    public PutMessageDataObjectDictionaryTransformConfiguration`4(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.PutMessageDataObjectTransformConfiguration`2 : object {
    private PropertyInfo _property;
    private PutMessageDataTransformSpecification`1<TProperty> _transformConfigurator;
    public PutMessageDataObjectTransformConfiguration`2(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.PutMessageDataTransformConfiguration`2 : object {
    private PropertyInfo _property;
    private IMessageDataRepository _repository;
    public PutMessageDataTransformConfiguration`2(IMessageDataRepository repository, PropertyInfo property);
    public sealed virtual void Apply(ITransformConfigurator`1<TInput> configurator);
}
public class MassTransit.MessageData.Configuration.PutMessageDataTransformSpecification`1 : TransformSpecification`1<TMessage> {
    public PutMessageDataTransformSpecification`1(IMessageDataRepository repository, IEnumerable`1<Type> knownTypes);
    private sealed virtual override void MassTransit.Configuration.IPipeSpecification<MassTransit.SendContext<TMessage>>.Apply(IPipeBuilder`1<SendContext`1<TMessage>> builder);
    public bool TryGetSendTopology(IMessageSendTopology`1& topology);
    public bool TryGetConverter(IPropertyConverter`2& converter);
    private void AddMessageDataProperties(IMessageDataRepository repository, ICollection`1<Type> knownTypes);
    private static bool IsUnknownObjectType(ICollection`1<Type> knownTypes, Type propertyType);
    [CompilerGeneratedAttribute]
private void <AddMessageDataProperties>g__ConfigureDictionary|4_0(Type keyType, Type valueType, <>c__DisplayClass4_0& , <>c__DisplayClass4_1& , <>c__DisplayClass4_2& );
    [CompilerGeneratedAttribute]
private void <AddMessageDataProperties>g__ConfigureArray|4_1(Type elementType, <>c__DisplayClass4_0& , <>c__DisplayClass4_1& , <>c__DisplayClass4_2& );
}
public interface MassTransit.MessageData.Conventions.IMessageDataMessageConsumeTopologyConvention`1 {
}
public interface MassTransit.MessageData.Conventions.IMessageDataMessageSendTopologyConvention`1 {
}
public class MassTransit.MessageData.Conventions.MessageDataConsumeTopologyConvention : object {
    private ITopologyConventionCache`1<IMessageConsumeTopologyConvention> _cache;
    public MessageDataConsumeTopologyConvention(IMessageDataRepository repository);
    public sealed virtual bool TryGetMessageConsumeTopologyConvention(IMessageConsumeTopologyConvention`1& convention);
}
public class MassTransit.MessageData.Conventions.MessageDataMessageConsumeTopology`1 : object {
    private TransformFilter`1<T> _transformFilter;
    public MessageDataMessageConsumeTopology`1(IMessageInitializer`1<T> initializer);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<ConsumeContext`1<T>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.MessageData.Conventions.MessageDataMessageConsumeTopologyConvention`1 : object {
    private IMessageDataRepository _repository;
    public MessageDataMessageConsumeTopologyConvention`1(IMessageDataRepository repository);
    private sealed virtual override bool MassTransit.Configuration.IMessageConsumeTopologyConvention.TryGetMessageConsumeTopologyConvention(IMessageConsumeTopologyConvention`1& convention);
    public sealed virtual bool TryGetMessageConsumeTopology(IMessageConsumeTopology`1& messageConsumeTopology);
}
public class MassTransit.MessageData.Conventions.MessageDataMessageSendTopology`1 : object {
    private TransformFilter`1<T> _transformFilter;
    public MessageDataMessageSendTopology`1(IMessageInitializer`1<T> initializer);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<SendContext`1<T>> builder);
}
public class MassTransit.MessageData.Conventions.MessageDataMessageSendTopologyConvention`1 : object {
    private IMessageDataRepository _repository;
    public MessageDataMessageSendTopologyConvention`1(IMessageDataRepository repository);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention.TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
    private sealed virtual override bool MassTransit.Configuration.IMessageSendTopologyConvention<TMessage>.TryGetMessageSendTopology(IMessageSendTopology`1& messageSendTopology);
}
public class MassTransit.MessageData.Conventions.MessageDataSendTopologyConvention : object {
    private ITopologyConventionCache`1<IMessageSendTopologyConvention> _cache;
    public MessageDataSendTopologyConvention(IMessageDataRepository repository);
    public sealed virtual bool TryGetMessageSendTopologyConvention(IMessageSendTopologyConvention`1& convention);
}
public class MassTransit.MessageData.Converters.ByteArrayMessageDataConverter : object {
    [AsyncStateMachineAttribute("MassTransit.MessageData.Converters.ByteArrayMessageDataConverter/<Convert>d__0")]
public sealed virtual Task`1<Byte[]> Convert(Stream stream, CancellationToken cancellationToken);
}
public static class MassTransit.MessageData.Converters.MessageDataConverter : object {
    public static IMessageDataConverter`1<string> String;
    public static IMessageDataConverter`1<Byte[]> ByteArray;
    public static IMessageDataConverter`1<Stream> Stream;
    private static MessageDataConverter();
}
public class MassTransit.MessageData.Converters.StreamMessageDataConverter : object {
    public sealed virtual Task`1<Stream> Convert(Stream stream, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.Converters.StringMessageDataConverter : object {
    [AsyncStateMachineAttribute("MassTransit.MessageData.Converters.StringMessageDataConverter/<Convert>d__0")]
public sealed virtual Task`1<string> Convert(Stream stream, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.Converters.SystemTextJsonObjectMessageDataConverter`1 : object {
    private JsonSerializerOptions _options;
    public SystemTextJsonObjectMessageDataConverter`1(JsonSerializerOptions options);
    [AsyncStateMachineAttribute("MassTransit.MessageData.Converters.SystemTextJsonObjectMessageDataConverter`1/<Convert>d__2")]
public sealed virtual Task`1<T> Convert(Stream stream, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.EncryptedMessageDataRepository : object {
    private IMessageDataRepository _repository;
    private ICryptoStreamProvider _streamProvider;
    public EncryptedMessageDataRepository(IMessageDataRepository repository, ICryptoStreamProvider streamProvider);
    [AsyncStateMachineAttribute("MassTransit.MessageData.EncryptedMessageDataRepository/<Get>d__3")]
public sealed virtual Task`1<Stream> Get(Uri address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageData.EncryptedMessageDataRepository/<Put>d__4")]
public sealed virtual Task`1<Uri> Put(Stream stream, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.FileSystemMessageDataRepository : object {
    private static int DefaultBufferSize;
    private static Char[] _separator;
    private DirectoryInfo _dataDirectory;
    public FileSystemMessageDataRepository(DirectoryInfo dataDirectory);
    private static FileSystemMessageDataRepository();
    private sealed virtual override Task`1<Stream> MassTransit.IMessageDataRepository.Get(Uri address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageData.FileSystemMessageDataRepository/<MassTransit-IMessageDataRepository-Put>d__5")]
private sealed virtual override Task`1<Uri> MassTransit.IMessageDataRepository.Put(Stream stream, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    private static void VerifyDirectory(string fullPath);
    private static string GenerateFilePath(Nullable`1<TimeSpan> timeToLive);
    private static string ParseFilePath(Uri address);
}
public interface MassTransit.MessageData.IInlineMessageData {
    public abstract virtual void Set(IMessageDataReference reference);
}
public interface MassTransit.MessageData.IMessageDataReference {
    unknown string Text {public set; }
    unknown Byte[] Data {public set; }
    public abstract virtual void set_Text(string value);
    public abstract virtual void set_Data(Byte[] value);
}
public class MassTransit.MessageData.InMemoryMessageDataId : object {
    private NewId _id;
    public Uri Uri { get; }
    public Uri get_Uri();
}
public class MassTransit.MessageData.InMemoryMessageDataRepository : object {
    private ConcurrentDictionary`2<Uri, Byte[]> _values;
    private sealed virtual override Task`1<Stream> MassTransit.IMessageDataRepository.Get(Uri address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageData.InMemoryMessageDataRepository/<MassTransit-IMessageDataRepository-Put>d__3")]
private sealed virtual override Task`1<Uri> MassTransit.IMessageDataRepository.Put(Stream stream, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.PropertyProviders.BytesMessageDataReader`1 : object {
    public sealed virtual MessageData`1<T> GetMessageData(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.PropertyProviders.GetMessageDataPropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, MessageData`1<TValue>> _inputProvider;
    private IMessageDataReader`1<TValue> _reader;
    private IMessageDataRepository _repository;
    public GetMessageDataPropertyProvider`2(IPropertyProvider`2<TInput, MessageData`1<TValue>> inputProvider, IMessageDataRepository repository);
    public sealed virtual Task`1<MessageData`1<TValue>> GetProperty(InitializeContext`2<T, TInput> context);
}
public interface MassTransit.MessageData.PropertyProviders.IMessageDataReader`1 {
    public abstract virtual MessageData`1<T> GetMessageData(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
public static class MassTransit.MessageData.PropertyProviders.MessageDataReaderFactory : object {
    public static IMessageDataReader`1<T> CreateReader();
}
public class MassTransit.MessageData.PropertyProviders.ObjectMessageDataReader`1 : object {
    private IMessageDataConverter`1<T> _converter;
    public sealed virtual MessageData`1<T> GetMessageData(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.PropertyProviders.PutMessageDataPropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, MessageData`1<TValue>> _inputProvider;
    private IMessageDataRepository _repository;
    public PutMessageDataPropertyProvider`2(IPropertyProvider`2<TInput, MessageData`1<TValue>> inputProvider, IMessageDataRepository repository);
    public sealed virtual Task`1<MessageData`1<TValue>> GetProperty(InitializeContext`2<T, TInput> context);
    [AsyncStateMachineAttribute("MassTransit.MessageData.PropertyProviders.PutMessageDataPropertyProvider`2/<Put>d__4")]
private Task`1<MessageData`1<TValue>> Put(PipeContext context, Task`1<TValue> valueTask);
}
public class MassTransit.MessageData.PropertyProviders.StreamMessageDataReader`1 : object {
    public sealed virtual MessageData`1<T> GetMessageData(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.PropertyProviders.StringMessageDataReader`1 : object {
    public sealed virtual MessageData`1<T> GetMessageData(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
public class MassTransit.MessageData.Values.BytesInlineMessageData : object {
    private Byte[] _value;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Byte[]> <Value>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<Byte[]> Value { get; }
    public BytesInlineMessageData(Byte[] value, Uri address);
    public sealed virtual void Set(IMessageDataReference reference);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Byte[]> get_Value();
}
public class MassTransit.MessageData.Values.BytesInlineMessageData`1 : object {
    private IMessageDataConverter`1<T> _converter;
    private Byte[] _value;
    private Lazy`1<Task`1<T>> _valueTask;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public BytesInlineMessageData`1(IMessageDataConverter`1<T> converter, Byte[] value, Uri address);
    public sealed virtual void Set(IMessageDataReference reference);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    public sealed virtual Task`1<T> get_Value();
    [AsyncStateMachineAttribute("MassTransit.MessageData.Values.BytesInlineMessageData`1/<GetValue>d__12")]
private Task`1<T> GetValue();
    [CompilerGeneratedAttribute]
private Task`1<T> <.ctor>b__3_0();
}
public class MassTransit.MessageData.Values.DeserializedMessageData`1 : object {
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public DeserializedMessageData`1(Uri address);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    public sealed virtual Task`1<T> get_Value();
}
public class MassTransit.MessageData.Values.EmptyMessageData`1 : object {
    public static MessageData`1<T> Instance;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    private static EmptyMessageData`1();
    public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    public sealed virtual Task`1<T> get_Value();
    private static Task`1<T> NoValue();
}
public class MassTransit.MessageData.Values.GetMessageData`1 : object {
    private CancellationToken _cancellationToken;
    private IMessageDataConverter`1<T> _converter;
    private IMessageDataRepository _repository;
    private Lazy`1<Task`1<T>> _value;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public GetMessageData`1(Uri address, IMessageDataRepository repository, IMessageDataConverter`1<T> converter, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    public sealed virtual Task`1<T> get_Value();
    [AsyncStateMachineAttribute("MassTransit.MessageData.Values.GetMessageData`1/<GetValue>d__12")]
private Task`1<T> GetValue();
}
public class MassTransit.MessageData.Values.InlineMessageData`1 : object {
    private IInlineMessageData _messageData;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<T> <Value>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public InlineMessageData`1(Uri address, T value, IInlineMessageData messageData);
    public sealed virtual void Set(IMessageDataReference reference);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<T> get_Value();
}
public class MassTransit.MessageData.Values.PutMessageData`1 : object {
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<T> <Value>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public PutMessageData`1(T value, bool hasValue);
    public sealed virtual Uri get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<T> get_Value();
}
public class MassTransit.MessageData.Values.StoredMessageData`1 : object {
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<T> <Value>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<T> Value { get; }
    public StoredMessageData`1(Uri address, T value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<T> get_Value();
}
public class MassTransit.MessageData.Values.StringInlineMessageData : object {
    private string _value;
    [CompilerGeneratedAttribute]
private Uri <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<string> <Value>k__BackingField;
    public Uri Address { get; }
    public bool HasValue { get; }
    public Task`1<string> Value { get; }
    public StringInlineMessageData(string value, Uri address);
    public sealed virtual void Set(IMessageDataReference reference);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Address();
    public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<string> get_Value();
}
[ExtensionAttribute]
public static class MassTransit.MessageDataConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseMessageData(IBusFactoryConfigurator configurator, IMessageDataRepository repository);
    [ExtensionAttribute]
public static IMessageDataRepository UseMessageData(IBusFactoryConfigurator configurator, Func`2<IMessageDataRepositorySelector, IMessageDataRepository> selector);
}
[ExtensionAttribute]
public static class MassTransit.MessageDataExtensions : object {
    [ExtensionAttribute]
public static Task`1<MessageData`1<string>> PutString(IMessageDataRepository repository, string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<PutString>d__1")]
[ExtensionAttribute]
public static Task`1<MessageData`1<string>> PutString(IMessageDataRepository repository, string value, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<MessageData`1<Byte[]>> PutBytes(IMessageDataRepository repository, Byte[] bytes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<PutBytes>d__3")]
[ExtensionAttribute]
public static Task`1<MessageData`1<Byte[]>> PutBytes(IMessageDataRepository repository, Byte[] bytes, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IMessageData> PutObject(IMessageDataRepository repository, object value, Type objectType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<PutObject>d__5")]
[ExtensionAttribute]
public static Task`1<IMessageData> PutObject(IMessageDataRepository repository, object value, Type objectType, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<MessageData`1<Stream>> PutStream(IMessageDataRepository repository, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<PutStream>d__7")]
[ExtensionAttribute]
public static Task`1<MessageData`1<Stream>> PutStream(IMessageDataRepository repository, Stream stream, Nullable`1<TimeSpan> timeToLive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<GetString>d__8")]
[ExtensionAttribute]
public static Task`1<MessageData`1<string>> GetString(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.MessageDataExtensions/<GetBytes>d__9")]
[ExtensionAttribute]
public static Task`1<MessageData`1<Byte[]>> GetBytes(IMessageDataRepository repository, Uri address, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.MessageRetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseMessageRetry(IConsumePipeConfigurator configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IConsumePipeConfigurator configurator, IBusFactoryConfigurator connector, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IConsumerConfigurator`1<TConsumer> configurator, IBusFactoryConfigurator busFactoryConfigurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(ISagaConfigurator`1<TSaga> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(ISagaConfigurator`1<TSaga> configurator, IBusFactoryConfigurator busFactoryConfigurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IHandlerConfigurator`1<TMessage> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IHandlerConfigurator`1<TMessage> configurator, IBusFactoryConfigurator busFactoryConfigurator, Action`1<IRetryConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.MessageSchedulerBusExtensions : object {
    [ExtensionAttribute]
public static IMessageScheduler CreateMessageScheduler(IBus bus, Uri schedulerEndpointAddress);
    [ExtensionAttribute]
public static IMessageScheduler CreateMessageScheduler(ISendEndpointProvider sendEndpointProvider, IBusTopology busTopology, Uri schedulerEndpointAddress);
    [ExtensionAttribute]
public static IMessageScheduler CreateMessageScheduler(IBus bus);
    [ExtensionAttribute]
public static IMessageScheduler CreateMessageScheduler(IPublishEndpoint publishEndpoint, IBusTopology busTopology);
    [ExtensionAttribute]
public static IMessageScheduler CreateDelayedMessageScheduler(IBus bus);
    [ExtensionAttribute]
public static IMessageScheduler CreateDelayedMessageScheduler(ISendEndpointProvider sendEndpointProvider, IBusTopology busTopology);
}
[ExtensionAttribute]
public static class MassTransit.MessageSchedulerExtensions : object {
    [ExtensionAttribute]
public static void UseMessageScheduler(IConsumePipeConfigurator configurator, Uri schedulerAddress);
    [ExtensionAttribute]
public static void UsePublishMessageScheduler(IConsumePipeConfigurator configurator);
}
[ExtensionAttribute]
public static class MassTransit.MessageSchedulerRegistrationExtensions : object {
    [ExtensionAttribute]
public static void AddMessageScheduler(IBusRegistrationConfigurator configurator, Uri schedulerEndpointAddress);
    [ExtensionAttribute]
public static void AddMessageScheduler(IBusRegistrationConfigurator`1<TBus> configurator, Uri schedulerEndpointAddress);
    [ExtensionAttribute]
public static void AddPublishMessageScheduler(IBusRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static void AddPublishMessageScheduler(IBusRegistrationConfigurator`1<TBus> configurator);
}
public interface MassTransit.Metadata.IMessageDataConverter`1 {
    public abstract virtual Task`1<T> Convert(Stream stream, CancellationToken cancellationToken);
}
public interface MassTransit.Metadata.ITypeMetadataCache`1 {
    public Type ImplementationType { get; }
    public abstract virtual Type get_ImplementationType();
}
public static class MassTransit.Metadata.RegistrationMetadata : object {
    public static bool IsConsumerOrDefinition(Type type);
    public static bool IsConsumer(Type type);
    public static bool IsSagaOrDefinition(Type type);
    public static bool IsSaga(Type type);
    public static bool IsSagaStateMachineOrDefinition(Type type);
    public static bool IsActivityOrDefinition(Type type);
    public static bool IsFutureOrDefinition(Type type);
}
public static class MassTransit.Metadata.TypeMetadataCache : object {
    private static object _builderLock;
    public static IImplementationBuilder ImplementationBuilder { get; }
    private static TypeMetadataCache();
    public static IImplementationBuilder get_ImplementationBuilder();
    public static Type GetImplementationType(Type type);
    public static string GetShortName(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static bool IsValidMessageType(Type type);
    public static bool IsTemporaryMessageType(Type type);
    public static Type[] GetMessageTypes(Type type);
    public static String[] GetMessageTypeNames(Type type);
    public static bool IsValidMessageDataType(Type type);
}
public class MassTransit.Metadata.TypeMetadataCache`1 : object {
    private Lazy`1<Type> _implementationType;
    public static Type ImplementationType { get; }
    public static string ShortName { get; }
    public static string DiagnosticAddress { get; }
    public static IEnumerable`1<PropertyInfo> Properties { get; }
    public static bool IsValidMessageType { get; }
    public static string InvalidMessageTypeReason { get; }
    public static bool IsTemporaryMessageType { get; }
    public static Type[] MessageTypes { get; }
    public static String[] MessageTypeNames { get; }
    private Type MassTransit.Metadata.ITypeMetadataCache<T>.ImplementationType { get; }
    public static Type get_ImplementationType();
    public static string get_ShortName();
    public static string get_DiagnosticAddress();
    public static IEnumerable`1<PropertyInfo> get_Properties();
    public static bool get_IsValidMessageType();
    public static string get_InvalidMessageTypeReason();
    public static bool get_IsTemporaryMessageType();
    public static Type[] get_MessageTypes();
    public static String[] get_MessageTypeNames();
    private sealed virtual override Type MassTransit.Metadata.ITypeMetadataCache<T>.get_ImplementationType();
}
public interface MassTransit.MetricsContext {
    public abstract virtual void Populate(TagList& tagList);
}
[ExtensionAttribute]
public static class MassTransit.MetricsContextExtensions : object {
    [ExtensionAttribute]
public static void AddMetricTags(PipeContext pipeContext, string key, object value);
    [ExtensionAttribute]
public static void SetMetricTags(PipeContext pipeContext, TagList tagList);
}
[ExtensionAttribute]
public static class MassTransit.Middleware.CircuitBreaker.CircuitBreakerEventExtensions : object {
    [ExtensionAttribute]
public static Task PublishCircuitBreakerOpened(IPipe`1<EventContext> pipe, Exception exception);
    [ExtensionAttribute]
public static Task PublishCircuitBreakerClosed(IPipe`1<EventContext> pipe);
}
public interface MassTransit.Middleware.CircuitBreaker.CircuitBreakerSettings {
    public TimeSpan TrackingPeriod { get; }
    public IEnumerable`1<TimeSpan> ResetTimeout { get; }
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public IPipeRouter Router { get; }
    public abstract virtual TimeSpan get_TrackingPeriod();
    public abstract virtual IEnumerable`1<TimeSpan> get_ResetTimeout();
    public abstract virtual int get_TripThreshold();
    public abstract virtual int get_ActiveThreshold();
    public abstract virtual IPipeRouter get_Router();
}
public class MassTransit.Middleware.CircuitBreaker.ClosedBehavior : object {
    private ICircuitBreaker _breaker;
    private Timer _timer;
    private int _attemptCount;
    private int _failureCount;
    private int _successCount;
    private bool IsActive { get; }
    public ClosedBehavior(ICircuitBreaker breaker);
    private bool get_IsActive();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    [AsyncStateMachineAttribute("MassTransit.Middleware.CircuitBreaker.ClosedBehavior/<MassTransit-Middleware-CircuitBreaker-ICircuitBreakerBehavior-SendFault>d__10")]
private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private bool TripThresholdExceeded(int failureCount);
    private void Reset(object state);
}
public class MassTransit.Middleware.CircuitBreaker.HalfOpenBehavior : object {
    private ICircuitBreaker _breaker;
    private Exception _exception;
    private IEnumerator`1<TimeSpan> _timeoutEnumerator;
    private int _attemptCount;
    private bool IsActive { get; }
    public HalfOpenBehavior(ICircuitBreaker breaker, Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private bool get_IsActive();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    [AsyncStateMachineAttribute("MassTransit.Middleware.CircuitBreaker.HalfOpenBehavior/<MassTransit-Middleware-CircuitBreaker-ICircuitBreakerBehavior-PostSend>d__8")]
private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public interface MassTransit.Middleware.CircuitBreaker.ICircuitBreaker {
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public TimeSpan OpenDuration { get; }
    public abstract virtual int get_TripThreshold();
    public abstract virtual int get_ActiveThreshold();
    public abstract virtual TimeSpan get_OpenDuration();
    public abstract virtual Task Open(Exception exception, ICircuitBreakerBehavior behavior, IEnumerator`1<TimeSpan> timeoutEnumerator);
    public abstract virtual Task ClosePartially(Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator, ICircuitBreakerBehavior behavior);
    public abstract virtual Task Close(ICircuitBreakerBehavior behavior);
}
public interface MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior {
    public abstract virtual Task PreSend();
    public abstract virtual Task PostSend();
    public abstract virtual Task SendFault(Exception exception);
}
public class MassTransit.Middleware.CircuitBreaker.OpenBehavior : object {
    private ICircuitBreaker _breaker;
    private Stopwatch _elapsed;
    private Exception _exception;
    private IEnumerator`1<TimeSpan> _timeoutEnumerator;
    private Timer _timer;
    public OpenBehavior(ICircuitBreaker breaker, Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private Timer GetTimer(IEnumerator`1<TimeSpan> timeoutEnumerator);
    private void PartiallyCloseCircuit(object state);
}
public class MassTransit.Middleware.CircuitBreakerFilter`1 : object {
    private IExceptionFilter _exceptionFilter;
    private CircuitBreakerSettings _settings;
    private ICircuitBreakerBehavior _behavior;
    public TimeSpan OpenDuration { get; }
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public CircuitBreakerFilter`1(CircuitBreakerSettings settings, IExceptionFilter exceptionFilter);
    public sealed virtual TimeSpan get_OpenDuration();
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreaker.Open(Exception exception, ICircuitBreakerBehavior behavior, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreaker.Close(ICircuitBreakerBehavior behavior);
    private sealed virtual override Task MassTransit.Middleware.CircuitBreaker.ICircuitBreaker.ClosePartially(Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator, ICircuitBreakerBehavior behavior);
    public sealed virtual int get_TripThreshold();
    public sealed virtual int get_ActiveThreshold();
    [AsyncStateMachineAttribute("MassTransit.Middleware.CircuitBreakerFilter`1/<Send>d__13")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Middleware.CompensateActivityFactoryFilter`2 : object {
    private ICompensateActivityFactory`2<TActivity, TLog> _factory;
    private IPipe`1<CompensateActivityContext`2<TActivity, TLog>> _pipe;
    public CompensateActivityFactoryFilter`2(ICompensateActivityFactory`2<TActivity, TLog> factory, IPipe`1<CompensateActivityContext`2<TActivity, TLog>> pipe);
    [AsyncStateMachineAttribute("MassTransit.Middleware.CompensateActivityFactoryFilter`2/<Send>d__3")]
public sealed virtual Task Send(CompensateContext`1<TLog> context, IPipe`1<CompensateContext`1<TLog>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.CompensateActivityFilter`2 : object {
    private ActivityObservable _observers;
    public CompensateActivityFilter`2(ActivityObservable observers);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.CompensateActivityFilter`2/<Send>d__3")]
public sealed virtual Task Send(CompensateActivityContext`2<TActivity, TLog> context, IPipe`1<CompensateActivityContext`2<TActivity, TLog>> next);
}
public class MassTransit.Middleware.ConcurrencyLimiter : object {
    private string _id;
    private SemaphoreSlim _limit;
    private int _concurrencyLimit;
    private DateTime _lastUpdated;
    private int MassTransit.Middleware.IConcurrencyLimiter.Available { get; }
    private int MassTransit.Middleware.IConcurrencyLimiter.Limit { get; }
    public ConcurrencyLimiter(int concurrencyLimit, string id);
    private sealed virtual override int MassTransit.Middleware.IConcurrencyLimiter.get_Available();
    private sealed virtual override int MassTransit.Middleware.IConcurrencyLimiter.get_Limit();
    public sealed virtual Task Wait(CancellationToken cancellationToken);
    public sealed virtual void Release();
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConcurrencyLimiter/<Consume>d__11")]
public sealed virtual Task Consume(ConsumeContext`1<SetConcurrencyLimit> context);
}
public class MassTransit.Middleware.ConcurrencyLimitFilter`1 : Agent {
    private int _concurrencyLimit;
    private SemaphoreSlim _limit;
    public ConcurrencyLimitFilter`1(int concurrencyLimit);
    public sealed virtual void Dispose();
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConcurrencyLimitFilter`1/<Send>d__5")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConcurrencyLimitFilter`1/<Send>d__6")]
public sealed virtual Task Send(CommandContext`1<SetConcurrencyLimit> context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConcurrencyLimitFilter`1/<StopAgent>d__7")]
protected virtual Task StopAgent(StopContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class MassTransit.Middleware.ConsumeConcurrencyLimitFilter`1 : object {
    private IConcurrencyLimiter _limiter;
    public ConsumeConcurrencyLimitFilter`1(IConcurrencyLimiter limiter);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConsumeConcurrencyLimitFilter`1/<Send>d__2")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ConsumeContextConverterFactory : object {
    public sealed virtual IPipeContextConverter`2<ConsumeContext, TOutput> GetConverter();
}
public class MassTransit.Middleware.ConsumeContextMessageTypeFilter : object {
    private IPipe`1<ConsumeContext> _empty;
    private ConsumeObservable _observers;
    private Dictionary`2<Type, IOutputFilter> _outputPipes;
    private IOutputFilter[] _outputPipeArray;
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConnectHandle ConnectMessagePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectMessagePipe(Guid key, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual Task Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    private OutputFilter`1<T> GetMessagePipe();
    private OutputFilter`1<T> CreateOutputPipe();
}
public class MassTransit.Middleware.ConsumeContextOutputMessageTypeFilter`1 : object {
    private ConsumeObservable _consumeObservers;
    private ConsumeMessageObservable`1<TMessage> _observers;
    private IRequestIdTeeFilter`1<TMessage> _output;
    public ConsumeContextOutputMessageTypeFilter`1(ConsumeObservable observers, IRequestIdTeeFilter`1<TMessage> output);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<TMessage> observer);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<ConsumeContext`1<TMessage>> pipe);
    public sealed virtual ConnectHandle ConnectPipe(Guid key, IPipe`1<ConsumeContext`1<TMessage>> pipe);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConsumeContextOutputMessageTypeFilter`1/<SendToOutput>d__9")]
private Task SendToOutput(IPipe`1<ConsumeContext> next, ConsumeContext`1<TMessage> pipeContext);
}
public class MassTransit.Middleware.ConsumePipe : object {
    private TaskCompletionSource`1<bool> _connected;
    private IConsumeContextMessageTypeFilter _filter;
    private ConcurrentDictionary`2<Type, IMessagePipe> _outputPipes;
    private IPipe`1<ConsumeContext> _pipe;
    private IConsumePipeSpecification _specification;
    public Task Connected { get; }
    public ConsumePipe(IConsumePipeSpecification specification, IConsumeContextMessageTypeFilter filter, IPipe`1<ConsumeContext> pipe, bool autoStart);
    public sealed virtual Task get_Connected();
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext context);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<TMessage> observer);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    private IPipe`1<ConsumeContext`1<T>> BuildMessagePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    [CompilerGeneratedAttribute]
private IMessagePipe <BuildMessagePipe>b__15_0(Type x);
}
public class MassTransit.Middleware.ConsumerMergePipe`2 : object {
    private IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _output;
    public ConsumerMergePipe`2(IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> output);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumerConsumeContext`1<TConsumer> context);
}
public class MassTransit.Middleware.ConsumerMessageFilter`2 : object {
    private IConsumerFactory`1<TConsumer> _consumerFactory;
    private IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _consumerPipe;
    public ConsumerMessageFilter`2(IConsumerFactory`1<TConsumer> consumerFactory, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> consumerPipe);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ConsumerMessageFilter`2/<MassTransit-IFilter<MassTransit-ConsumeContext<TMessage>>-Send>d__4")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext<TMessage>>.Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.ConsumerMessageMergePipe`2 : object {
    private ConsumerConsumeContext`2<TConsumer, TMessage> _context;
    private IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _output;
    public ConsumerMessageMergePipe`2(IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> output, ConsumerConsumeContext`2<TConsumer, TMessage> context);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context);
}
public class MassTransit.Middleware.ConsumerSplitFilter`2 : object {
    private IFilter`1<ConsumerConsumeContext`1<TConsumer>> _next;
    public ConsumerSplitFilter`2(IFilter`1<ConsumerConsumeContext`1<TConsumer>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ConsumerConsumeContext`2<TConsumer, TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
}
public class MassTransit.Middleware.ContextFilter`1 : object {
    private Func`2<TContext, Task`1<bool>> _filter;
    public ContextFilter`1(Func`2<TContext, Task`1<bool>> filter);
    public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.CorrelatedSagaFilter`2 : object {
    private IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> _messagePipe;
    private ISagaPolicy`2<TSaga, TMessage> _policy;
    private ISagaRepository`1<TSaga> _sagaRepository;
    public CorrelatedSagaFilter`2(ISagaRepository`1<TSaga> sagaRepository, ISagaPolicy`2<TSaga, TMessage> policy, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> messagePipe);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.CorrelatedSagaFilter`2/<Send>d__5")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.CorrelationIdMessageFilter`1 : object {
    private Func`2<ConsumeContext`1<TMessage>, Guid> _getCorrelationId;
    public CorrelationIdMessageFilter`1(Func`2<ConsumeContext`1<TMessage>, Guid> getCorrelationId);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.DeadLetterFilter : object {
    private IPipe`1<ReceiveContext> _deadLetterPipe;
    public DeadLetterFilter(IPipe`1<ReceiveContext> deadLetterPipe);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.DeadLetterFilter/<MassTransit-IFilter<MassTransit-ReceiveContext>-Send>d__3")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ReceiveContext>.Send(ReceiveContext context, IPipe`1<ReceiveContext> next);
}
public class MassTransit.Middleware.DeadLetterTransportFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.DeadLetterTransportFilter/<MassTransit-IFilter<MassTransit-ReceiveContext>-Send>d__1")]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ReceiveContext>.Send(ReceiveContext context, IPipe`1<ReceiveContext> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Middleware.DelayedMessageRedeliveryContext`1 : object {
    private ConsumeContext`1<TMessage> _context;
    private RedeliveryOptions _options;
    public DelayedMessageRedeliveryContext`1(ConsumeContext`1<TMessage> context, RedeliveryOptions options);
    [AsyncStateMachineAttribute("MassTransit.Middleware.DelayedMessageRedeliveryContext`1/<ScheduleRedelivery>d__3")]
public sealed virtual Task ScheduleRedelivery(TimeSpan delay, Action`2<ConsumeContext, SendContext> callback);
}
public class MassTransit.Middleware.DelayedMessageRedeliveryFilter`1 : object {
    private RedeliveryOptions _options;
    public DelayedMessageRedeliveryFilter`1(RedeliveryOptions options);
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.DelayedMessageSchedulerFilter : object {
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    private static IMessageScheduler SchedulerFactory(ConsumeContext context);
}
public class MassTransit.Middleware.DelaySendPipe`1 : object {
    private TimeSpan _delay;
    private IPipe`1<SendContext`1<T>> _pipe;
    public DelaySendPipe`1(IPipe`1<SendContext`1<T>> pipe, TimeSpan delay);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(SendContext`1<T> context);
}
public class MassTransit.Middleware.DeserializeFilter : object {
    private IPipe`1<ConsumeContext> _output;
    private ISerialization _serializers;
    public DeserializeFilter(ISerialization serializers, IPipe`1<ConsumeContext> output);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.DeserializeFilter/<Send>d__4")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ReceiveContext context, IPipe`1<ReceiveContext> next);
}
public class MassTransit.Middleware.DiscardDeadLetterFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.ReceiveContext>.Send(ReceiveContext context, IPipe`1<ReceiveContext> next);
}
public class MassTransit.Middleware.DiscardErrorTransportFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.ExceptionReceiveContext>.Send(ExceptionReceiveContext context, IPipe`1<ExceptionReceiveContext> next);
}
public class MassTransit.Middleware.DynamicFilter`1 : object {
    private IPipe`1<TInput> _empty;
    private Dictionary`2<Type, IOutputFilter<TInput>> _outputPipes;
    protected IPipeContextConverterFactory`1<TInput> ConverterFactory;
    protected FilterObservable Observers;
    private IOutputFilter[] _outputPipeArray;
    public DynamicFilter`1(IPipeContextConverterFactory`1<TInput> converterFactory);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver observer);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TInput context, IPipe`1<TInput> next);
    protected TResult GetPipe();
    protected IOutputFilter<TInput> GetPipe();
    protected virtual IOutputFilter<TInput> CreateOutputPipe();
}
public class MassTransit.Middleware.DynamicFilter`2 : DynamicFilter`1<TInput> {
    private KeyAccessor`2<TInput, TKey> _keyAccessor;
    public DynamicFilter`2(IPipeContextConverterFactory`1<TInput> converterFactory, KeyAccessor`2<TInput, TKey> keyAccessor);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    protected virtual IOutputFilter<TInput> CreateOutputPipe();
}
public class MassTransit.Middleware.DynamicRouter`1 : object {
    private IDynamicFilter`1<TContext> _filter;
    private IPipe`1<TContext> _pipe;
    public DynamicRouter`1(IPipeContextConverterFactory`1<TContext> converterFactory);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IPipe<TContext>.Send(TContext context);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver observer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_0(IPipeConfigurator`1<TContext> x);
}
public class MassTransit.Middleware.DynamicRouter`2 : object {
    private IDynamicFilter`2<TContext, TKey> _filter;
    private IPipe`1<TContext> _pipe;
    public DynamicRouter`2(IPipeContextConverterFactory`1<TContext> converterFactory, KeyAccessor`2<TContext, TKey> keyAccessor);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IPipe<TContext>.Send(TContext context);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector.ConnectObserver(IFilterObserver observer);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_0(IPipeConfigurator`1<TContext> x);
}
public class MassTransit.Middleware.ErrorTransportFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ErrorTransportFilter/<MassTransit-IFilter<MassTransit-ExceptionReceiveContext>-Send>d__1")]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ExceptionReceiveContext>.Send(ExceptionReceiveContext context, IPipe`1<ExceptionReceiveContext> next);
}
public class MassTransit.Middleware.ExecuteActivityFactoryFilter`2 : object {
    private IExecuteActivityFactory`2<TActivity, TArguments> _factory;
    private IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> _pipe;
    public ExecuteActivityFactoryFilter`2(IExecuteActivityFactory`2<TActivity, TArguments> factory, IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> pipe);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ExecuteActivityFactoryFilter`2/<Send>d__3")]
public sealed virtual Task Send(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteContext`1<TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ExecuteActivityFilter`2 : object {
    private ActivityObservable _observers;
    public ExecuteActivityFilter`2(ActivityObservable observers);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ExecuteActivityFilter`2/<Send>d__3")]
public sealed virtual Task Send(ExecuteActivityContext`2<TActivity, TArguments> context, IPipe`1<ExecuteActivityContext`2<TActivity, TArguments>> next);
}
public class MassTransit.Middleware.FaultDeadLetterFilter : object {
    public sealed virtual Task Send(ReceiveContext context, IPipe`1<ReceiveContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ForkFilter`1 : object {
    private IPipe`1<TContext> _pipe;
    public ForkFilter`1(IPipe`1<TContext> pipe);
    private sealed virtual override Task MassTransit.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Middleware.FutureRequestPipe`1 : object {
    private IPipe`1<SendContext`1<T>> _pipe;
    private Guid _requestId;
    private Uri _responseAddress;
    public FutureRequestPipe`1(IPipe`1<SendContext`1<T>> pipe, Uri responseAddress, Guid requestId);
    public sealed virtual Task Send(SendContext`1<T> context);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.FutureResultPipe`1 : object {
    private IPipe`1<SendContext`1<T>> _pipe;
    private Guid _requestId;
    public FutureResultPipe`1(IPipe`1<SendContext`1<T>> pipe, Guid requestId);
    public sealed virtual Task Send(SendContext`1<T> context);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.GenerateFaultFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.GenerateFaultFilter/<MassTransit-IFilter<MassTransit-ExceptionReceiveContext>-Send>d__1")]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ExceptionReceiveContext>.Send(ExceptionReceiveContext context, IPipe`1<ExceptionReceiveContext> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.GenerateFaultFilter/<GenerateFault>d__2")]
private static Task GenerateFault(ExceptionReceiveContext context);
}
public class MassTransit.Middleware.HandlerMessageFilter`1 : object {
    private MessageHandler`1<TMessage> _handler;
    private long _completed;
    private long _faulted;
    public HandlerMessageFilter`1(MessageHandler`1<TMessage> handler);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.HandlerMessageFilter`1/<MassTransit-IFilter<MassTransit-ConsumeContext<TMessage>>-Send>d__5")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext<TMessage>>.Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public interface MassTransit.Middleware.IConcurrencyLimiter {
    public int Available { get; }
    public int Limit { get; }
    public abstract virtual int get_Available();
    public abstract virtual int get_Limit();
    public abstract virtual Task Wait(CancellationToken cancellationToken);
    public abstract virtual void Release();
}
public interface MassTransit.Middleware.IConsumeContextMessageTypeFilter {
    public abstract virtual ConnectHandle ConnectMessagePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public abstract virtual ConnectHandle ConnectMessagePipe(Guid key, IPipe`1<ConsumeContext`1<T>> pipe);
}
public interface MassTransit.Middleware.IConsumeContextOutputMessageTypeFilter`1 {
    public abstract virtual ConnectHandle ConnectPipe(Guid key, IPipe`1<ConsumeContext`1<TMessage>> pipe);
}
public interface MassTransit.Middleware.IConsumerMessageFilter`2 {
}
public interface MassTransit.Middleware.IDynamicFilter`1 {
}
public interface MassTransit.Middleware.IDynamicFilter`2 {
}
public interface MassTransit.Middleware.IDynamicRouter`1 {
}
public interface MassTransit.Middleware.IDynamicRouter`2 {
}
public interface MassTransit.Middleware.IHashGenerator {
    public abstract virtual UInt32 Hash(Byte[] data);
}
public interface MassTransit.Middleware.IKeyPipeConnector`1 {
    public abstract virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
}
public interface MassTransit.Middleware.IKeyPipeConnector`2 {
    public abstract virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<ConsumeContext`1<TMessage>> pipe);
}
public interface MassTransit.Middleware.ILatestFilter`1 {
    public Task`1<T> Latest { get; }
    public abstract virtual Task`1<T> get_Latest();
}
public class MassTransit.Middleware.InitiatedByOrOrchestratesSagaMessageFilter`2 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InitiatedByOrOrchestratesSagaMessageFilter`2/<Send>d__1")]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.InitiatedBySagaMessageFilter`2 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InitiatedBySagaMessageFilter`2/<Send>d__1")]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.InlineFilter`1 : object {
    private InlineFilterMethod`1<TContext> _filterMethod;
    public InlineFilter`1(InlineFilterMethod`1<TContext> filterMethod);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxCompensateContext`1 : InMemoryOutboxCourierContextProxy {
    private CompensateContext`1<TLog> _context;
    private CompensationResult MassTransit.CompensateContext.Result { get; private set; }
    private TLog MassTransit.CompensateContext<TLog>.Log { get; }
    public InMemoryOutboxCompensateContext`1(CompensateContext`1<TLog> context);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(object values);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(IDictionary`2<string, object> variables);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed(Exception exception);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.get_Result();
    private sealed virtual override void MassTransit.CompensateContext.set_Result(CompensationResult value);
    private sealed virtual override TLog MassTransit.CompensateContext<TLog>.get_Log();
    private sealed virtual override CompensateActivityContext`2<TActivity, TLog> MassTransit.CompensateContext<TLog>.CreateActivityContext(TActivity activity);
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxConsumeContext : ConsumeContextProxy {
    private TaskCompletionSource`1<InMemoryOutboxConsumeContext> _clearToSend;
    private InMemoryOutboxMessageSchedulerContext _outboxSchedulerContext;
    private List`1<Func`1<Task>> _pendingActions;
    [CompilerGeneratedAttribute]
private ConsumeContext <CapturedContext>k__BackingField;
    public ConsumeContext CapturedContext { get; }
    public Task ClearToSend { get; }
    public InMemoryOutboxConsumeContext(ConsumeContext context);
    [CompilerGeneratedAttribute]
public ConsumeContext get_CapturedContext();
    public sealed virtual Task get_ClearToSend();
    public sealed virtual Task Add(Func`1<Task> method);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxConsumeContext/<ExecutePendingActions>d__10")]
public sealed virtual Task ExecutePendingActions(bool concurrentMessageDelivery);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxConsumeContext/<DiscardPendingActions>d__11")]
public sealed virtual Task DiscardPendingActions();
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxConsumeContext`1 : InMemoryOutboxConsumeContext {
    private ConsumeContext`1<T> _context;
    public T Message { get; }
    public InMemoryOutboxConsumeContext`1(ConsumeContext`1<T> context);
    public sealed virtual T get_Message();
    public virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public void Method1();
    public void Method2();
    public void Method3();
}
public abstract class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxCourierContextProxy : InMemoryOutboxConsumeContext`1<RoutingSlip> {
    private CourierContext _courierContext;
    private DateTime MassTransit.CourierContext.Timestamp { get; }
    private TimeSpan MassTransit.CourierContext.Elapsed { get; }
    private Guid MassTransit.CourierContext.TrackingNumber { get; }
    private Guid MassTransit.CourierContext.ExecutionId { get; }
    private string MassTransit.CourierContext.ActivityName { get; }
    protected InMemoryOutboxCourierContextProxy(CourierContext courierContext);
    private sealed virtual override DateTime MassTransit.CourierContext.get_Timestamp();
    private sealed virtual override TimeSpan MassTransit.CourierContext.get_Elapsed();
    private sealed virtual override Guid MassTransit.CourierContext.get_TrackingNumber();
    private sealed virtual override Guid MassTransit.CourierContext.get_ExecutionId();
    private sealed virtual override string MassTransit.CourierContext.get_ActivityName();
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxExecuteContext`1 : InMemoryOutboxCourierContextProxy {
    private ExecuteContext`1<TArguments> _context;
    public ExecutionResult Result { get; public set; }
    public TArguments Arguments { get; }
    public InMemoryOutboxExecuteContext`1(ExecuteContext`1<TArguments> context);
    public sealed virtual ExecutionResult Completed();
    public sealed virtual ExecutionResult CompletedWithVariables(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object variables);
    public sealed virtual ExecutionResult Completed(TLog log);
    public sealed virtual ExecutionResult Completed(object logValues);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object logValues, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult ReviseItinerary(Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, object variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult Terminate();
    public sealed virtual ExecutionResult Terminate(object variables);
    public sealed virtual ExecutionResult Terminate(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult Faulted();
    public sealed virtual ExecutionResult Faulted(Exception exception);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, object variables);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult get_Result();
    public sealed virtual void set_Result(ExecutionResult value);
    public sealed virtual TArguments get_Arguments();
    public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> CreateActivityContext(TActivity activity);
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext : object {
    private List`1<Func`1<Task>> _cancelMessages;
    private Task _clearToSend;
    private Uri _inputAddress;
    private object _listLock;
    private List`1<ScheduledMessage> _scheduledMessages;
    private Lazy`1<IMessageScheduler> _scheduler;
    [CompilerGeneratedAttribute]
private MessageSchedulerFactory <SchedulerFactory>k__BackingField;
    public MessageSchedulerFactory SchedulerFactory { get; }
    public InMemoryOutboxMessageSchedulerContext(ConsumeContext consumeContext, MessageSchedulerFactory schedulerFactory, Task clearToSend);
    [CompilerGeneratedAttribute]
public sealed virtual MessageSchedulerFactory get_SchedulerFactory();
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__10`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__11`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__12`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__13")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__14")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__15")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__16")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__17`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__18`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__19`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__20`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__21`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__22`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__23")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__24")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__25")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__26")]
public sealed virtual Task`1<ScheduledMessage> ScheduleSend(DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__27`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__28`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<ScheduleSend>d__29`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__30`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__31`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__32`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__33")]
public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__34")]
public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__35")]
public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__36")]
public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__37`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__38`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxMessageSchedulerContext/<SchedulePublish>d__39`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Type messageType, Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
    private void AddScheduledMessage(ScheduledMessage scheduledMessage);
    private Task AddCancelMessage(Func`1<Task> cancel);
    public Task CancelAllScheduledMessages();
    public Task ExecutePendingActions();
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxPublishEndpointProvider : object {
    private OutboxContext _outboxContext;
    private IPublishEndpointProvider _publishEndpointProvider;
    public InMemoryOutboxPublishEndpointProvider(OutboxContext outboxContext, IPublishEndpointProvider publishEndpointProvider);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxPublishEndpointProvider/<GetPublishSendEndpoint>d__4`1")]
public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxReceiveContext : ReceiveContextProxy {
    [CompilerGeneratedAttribute]
private IPublishEndpointProvider <PublishEndpointProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendEndpointProvider <SendEndpointProvider>k__BackingField;
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public InMemoryOutboxReceiveContext(OutboxContext outboxContext, ReceiveContext context);
    [CompilerGeneratedAttribute]
public virtual IPublishEndpointProvider get_PublishEndpointProvider();
    [CompilerGeneratedAttribute]
public virtual ISendEndpointProvider get_SendEndpointProvider();
}
public class MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxSendEndpointProvider : object {
    private OutboxContext _outboxContext;
    private ISendEndpointProvider _sendEndpointProvider;
    public InMemoryOutboxSendEndpointProvider(OutboxContext outboxContext, ISendEndpointProvider sendEndpointProvider);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutbox.InMemoryOutboxSendEndpointProvider/<GetSendEndpoint>d__4")]
public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
}
public interface MassTransit.Middleware.InMemoryOutbox.OutboxContext {
    public Task ClearToSend { get; }
    public abstract virtual Task get_ClearToSend();
    public abstract virtual Task Add(Func`1<Task> method);
    public abstract virtual Task ExecutePendingActions(bool concurrentMessageDelivery);
    public abstract virtual Task DiscardPendingActions();
}
public class MassTransit.Middleware.InMemoryOutbox.OutboxSendEndpoint : object {
    private ITransportSendEndpoint _endpoint;
    private OutboxContext _outboxContext;
    public ISendEndpoint Endpoint { get; }
    public OutboxSendEndpoint(OutboxContext outboxContext, ISendEndpoint endpoint);
    public ISendEndpoint get_Endpoint();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(T message, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object message, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object message, Type messageType, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object values, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    private sealed virtual override Task MassTransit.ISendEndpoint.Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
}
public class MassTransit.Middleware.InMemoryOutboxFilter`2 : object {
    private bool _concurrentMessageDelivery;
    private Func`2<TContext, TResult> _contextFactory;
    private ISetScopedConsumeContext _setter;
    public InMemoryOutboxFilter`2(ISetScopedConsumeContext setter, Func`2<TContext, TResult> contextFactory, bool concurrentMessageDelivery);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InMemoryOutboxFilter`2/<Send>d__4")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
    public void Method1();
    public void Method2();
    public void Method3();
}
public class MassTransit.Middleware.InstanceMessageFilter`2 : object {
    private TConsumer _instance;
    private IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> _instancePipe;
    public InstanceMessageFilter`2(TConsumer instance, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> instancePipe);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InstanceMessageFilter`2/<MassTransit-IFilter<MassTransit-ConsumeContext<TMessage>>-Send>d__4")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext<TMessage>>.Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.InterceptFilter`1 : object {
    private IPipe`1<TContext> _pipe;
    public InterceptFilter`1(IPipe`1<TContext> pipe);
    [AsyncStateMachineAttribute("MassTransit.Middleware.InterceptFilter`1/<MassTransit-IFilter<TContext>-Send>d__2")]
private sealed virtual override Task MassTransit.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
[ExtensionAttribute]
public static class MassTransit.Middleware.InternalOutboxExtensions : object {
    [ExtensionAttribute]
internal static ISendEndpoint SkipOutbox(ISendEndpoint endpoint);
    public static ConsumeContext SkipOutbox(ConsumeContext context);
}
public interface MassTransit.Middleware.IOutboxContextFactory`1 {
    public abstract virtual Task Send(ConsumeContext`1<T> context, OutboxConsumeOptions options, IPipe`1<OutboxConsumeContext`1<T>> next);
}
public interface MassTransit.Middleware.IOutputPipeFilter`2 {
}
public interface MassTransit.Middleware.IOutputPipeFilter`3 {
}
public interface MassTransit.Middleware.IPipeConnector {
    public abstract virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
}
public interface MassTransit.Middleware.IPipeConnector`1 {
    public abstract virtual ConnectHandle ConnectPipe(IPipe`1<TContext> pipe);
}
public interface MassTransit.Middleware.IPipeContextConverter`2 {
    public abstract virtual bool TryConvert(TInput input, TOutput& output);
}
public interface MassTransit.Middleware.IPipeContextConverterFactory`1 {
    public abstract virtual IPipeContextConverter`2<TInput, TOutput> GetConverter();
}
public interface MassTransit.Middleware.IPipeRouter {
}
public interface MassTransit.Middleware.IRequestIdTeeFilter`1 {
}
public interface MassTransit.Middleware.ISagaMessageFilter`2 {
}
public interface MassTransit.Middleware.ITeeFilter`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public interface MassTransit.Middleware.ITeeFilter`2 {
}
public class MassTransit.Middleware.JobConsumerMessageFilter`2 : object {
    private IRetryPolicy _retryPolicy;
    public JobConsumerMessageFilter`2(IRetryPolicy retryPolicy);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumerConsumeContext<TConsumer,TJob>>.Send(ConsumerConsumeContext`2<TConsumer, TJob> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TJob>> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.JobConsumerMessageFilter`2/<RunJob>d__4")]
private Task RunJob(PipeContext context, IJobConsumer`1<TJob> jobConsumer);
}
public class MassTransit.Middleware.KeyAccessor`2 : MulticastDelegate {
    public KeyAccessor`2(object object, IntPtr method);
    public virtual TKey Invoke(TContext context);
    public virtual IAsyncResult BeginInvoke(TContext context, AsyncCallback callback, object object);
    public virtual TKey EndInvoke(IAsyncResult result);
}
public class MassTransit.Middleware.KeyFilter`2 : object {
    private KeyAccessor`2<TContext, TKey> _keyAccessor;
    private ConcurrentDictionary`2<TKey, IPipe`1<TContext>> _pipes;
    public KeyFilter`2(KeyAccessor`2<TContext, TKey> keyAccessor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.KeyFilter`2/<Send>d__4")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    private void RemovePipe(TKey key);
}
public class MassTransit.Middleware.LatestFilter`1 : object {
    private TaskCompletionSource`1<bool> _hasValue;
    private T _latest;
    private Task`1<T> MassTransit.Middleware.ILatestFilter<T>.Latest { get; }
    private sealed virtual override Task MassTransit.IFilter<T>.Send(T context, IPipe`1<T> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task`1<T> MassTransit.Middleware.ILatestFilter<T>.get_Latest();
    [AsyncStateMachineAttribute("MassTransit.Middleware.LatestFilter`1/<GetLatest>d__7")]
private Task`1<T> GetLatest();
}
public class MassTransit.Middleware.MessageSchedulerFilter : object {
    private Uri _schedulerAddress;
    public MessageSchedulerFilter(Uri schedulerAddress);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    private IMessageScheduler SchedulerFactory(ConsumeContext context);
}
public class MassTransit.Middleware.MessageSplitFilter`2 : object {
    private IFilter`1<ConsumeContext`1<TMessage>> _next;
    public MessageSplitFilter`2(IFilter`1<ConsumeContext`1<TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ConsumerConsumeContext`2<TConsumer, TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
}
public class MassTransit.Middleware.MethodConsumerMessageFilter`2 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumerConsumeContext<TConsumer,TMessage>>.Send(ConsumerConsumeContext`2<TConsumer, TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
}
public class MassTransit.Middleware.MissingInstanceRedeliveryPipe`2 : object {
    private IPipe`1<ConsumeContext`1<TMessage>> _finalPipe;
    private RedeliveryOptions _options;
    private IRetryPolicy _retryPolicy;
    public MissingInstanceRedeliveryPipe`2(IRetryPolicy retryPolicy, IPipe`1<ConsumeContext`1<TMessage>> finalPipe, RedeliveryOptions options);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.MissingSagaPipe`2 : object {
    private IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> _next;
    private SagaRepositoryContext`2<TSaga, TMessage> _repositoryContext;
    public MissingSagaPipe`2(SagaRepositoryContext`2<TSaga, TMessage> repositoryContext, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.MissingSagaPipe`2/<Send>d__4")]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context);
}
public class MassTransit.Middleware.Murmur3UnsafeHashGenerator : object {
    private static UInt32 Seed;
    private static UInt32 C1;
    private static UInt32 C2;
    public sealed virtual UInt32 Hash(Byte[] data);
    public UInt32 Hash(string s);
    public UInt32 Hash(Byte[] data, int offset, UInt32 count, UInt32 seed);
    private static UInt32 Hash(Byte* data, UInt32 len, UInt32 seed);
    private static UInt32 Rotl32(UInt32 x, int r);
}
public class MassTransit.Middleware.ObserverMessageFilter`1 : object {
    private IObserver`1<ConsumeContext`1<TMessage>> _observer;
    private string _observerType;
    public ObserverMessageFilter`1(IObserver`1<ConsumeContext`1<TMessage>> observer);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ObserverMessageFilter`1/<MassTransit-IFilter<MassTransit-ConsumeContext<TMessage>>-Send>d__4")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext<TMessage>>.Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.ObservesSagaMessageFilter`2 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ObservesSagaMessageFilter`2/<Send>d__1")]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.OrchestratesSagaMessageFilter`2 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.OrchestratesSagaMessageFilter`2/<Send>d__1")]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.Outbox.BusOutboxNotification : object {
    private object _lock;
    private IOptions`1<OutboxDeliveryServiceOptions> _options;
    private CancellationTokenSource _cancellationTokenSource;
    public BusOutboxNotification(IOptions`1<OutboxDeliveryServiceOptions> options);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.BusOutboxNotification/<WaitForDelivery>d__4")]
public sealed virtual Task WaitForDelivery(CancellationToken cancellationToken);
    public sealed virtual void Delivered();
}
public interface MassTransit.Middleware.Outbox.IBusOutboxNotification {
    public abstract virtual Task WaitForDelivery(CancellationToken cancellationToken);
    public abstract virtual void Delivered();
}
public class MassTransit.Middleware.Outbox.InMemoryInboxMessage : object {
    private SemaphoreSlim _inUse;
    private List`1<InMemoryOutboxMessage> _outboxMessages;
    [CompilerGeneratedAttribute]
private Guid <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ConsumerId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Received>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Delivered>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LastSequenceNumber>k__BackingField;
    public Guid MessageId { get; }
    public Guid ConsumerId { get; }
    public DateTime Received { get; public set; }
    public int ReceiveCount { get; public set; }
    public Nullable`1<DateTime> ExpirationTime { get; public set; }
    public Nullable`1<DateTime> Consumed { get; public set; }
    public Nullable`1<DateTime> Delivered { get; public set; }
    public Nullable`1<long> LastSequenceNumber { get; public set; }
    public InMemoryInboxMessage(Guid messageId, Guid consumerId);
    [CompilerGeneratedAttribute]
public Guid get_MessageId();
    [CompilerGeneratedAttribute]
public Guid get_ConsumerId();
    [CompilerGeneratedAttribute]
public DateTime get_Received();
    [CompilerGeneratedAttribute]
public void set_Received(DateTime value);
    [CompilerGeneratedAttribute]
public int get_ReceiveCount();
    [CompilerGeneratedAttribute]
public void set_ReceiveCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Consumed();
    [CompilerGeneratedAttribute]
public void set_Consumed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Delivered();
    [CompilerGeneratedAttribute]
public void set_Delivered(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LastSequenceNumber();
    [CompilerGeneratedAttribute]
public void set_LastSequenceNumber(Nullable`1<long> value);
    public Task MarkInUse(CancellationToken cancellationToken);
    public void Release();
    public List`1<InMemoryOutboxMessage> GetOutboxMessages();
    public void RemoveOutboxMessages();
    public void AddOutboxMessage(InMemoryOutboxMessage outboxMessage);
}
[IsReadOnlyAttribute]
public class MassTransit.Middleware.Outbox.InMemoryInboxMessageKey : ValueType {
    public Guid MessageId;
    public Guid ConsumerId;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<InMemoryInboxMessageKey> <Comparer>k__BackingField;
    public static IEqualityComparer`1<InMemoryInboxMessageKey> Comparer { get; }
    public InMemoryInboxMessageKey(Guid messageId, Guid consumerId);
    private static InMemoryInboxMessageKey();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<InMemoryInboxMessageKey> get_Comparer();
}
public class MassTransit.Middleware.Outbox.InMemoryOutboxConsumeContext`1 : OutboxConsumeContextProxy`1<TMessage> {
    private InMemoryInboxMessage _inboxMessage;
    [CompilerGeneratedAttribute]
private bool <ContinueProcessing>k__BackingField;
    public bool ContinueProcessing { get; public set; }
    public bool IsMessageConsumed { get; }
    public bool IsOutboxDelivered { get; }
    public int ReceiveCount { get; }
    public Nullable`1<long> LastSequenceNumber { get; }
    private Guid InboxMessageId { get; }
    public InMemoryOutboxConsumeContext`1(ConsumeContext`1<TMessage> context, OutboxConsumeOptions options, IServiceProvider provider, InMemoryInboxMessage inboxMessage);
    [CompilerGeneratedAttribute]
public virtual bool get_ContinueProcessing();
    [CompilerGeneratedAttribute]
public virtual void set_ContinueProcessing(bool value);
    public virtual bool get_IsMessageConsumed();
    public virtual bool get_IsOutboxDelivered();
    public virtual int get_ReceiveCount();
    public virtual Nullable`1<long> get_LastSequenceNumber();
    private Guid get_InboxMessageId();
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxConsumeContext`1/<SetConsumed>d__16")]
public virtual Task SetConsumed();
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxConsumeContext`1/<SetDelivered>d__17")]
public virtual Task SetDelivered();
    public virtual Task`1<List`1<OutboxMessageContext>> LoadOutboxMessages();
    public virtual Task NotifyOutboxMessageDelivered(OutboxMessageContext message);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxConsumeContext`1/<RemoveOutboxMessages>d__20")]
public virtual Task RemoveOutboxMessages();
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxConsumeContext`1/<AddSend>d__21`1")]
public virtual Task AddSend(SendContext`1<T> context);
}
public class MassTransit.Middleware.Outbox.InMemoryOutboxContextFactory : object {
    private InMemoryOutboxMessageRepository _messageRepository;
    private IServiceProvider _provider;
    public InMemoryOutboxContextFactory(InMemoryOutboxMessageRepository messageRepository, IServiceProvider provider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxContextFactory/<Send>d__3`1")]
public sealed virtual Task Send(ConsumeContext`1<T> context, OutboxConsumeOptions options, IPipe`1<OutboxConsumeContext`1<T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Middleware.Outbox.InMemoryOutboxMessage : object {
    private Headers _headers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, object> _properties;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <EnqueueTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <SentTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <MessageId>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <MessageType>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <InitiatorId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <FaultAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    public Nullable`1<DateTime> EnqueueTime { get; public set; }
    public DateTime SentTime { get; public set; }
    public string Headers { get; public set; }
    public string Properties { get; public set; }
    public long SequenceNumber { get; public set; }
    public Guid MessageId { get; public set; }
    [NullableAttribute("1")]
public string ContentType { get; public set; }
    [NullableAttribute("1")]
public string MessageType { get; public set; }
    [NullableAttribute("1")]
public string Body { get; public set; }
    public Nullable`1<Guid> ConversationId { get; public set; }
    public Nullable`1<Guid> CorrelationId { get; public set; }
    public Nullable`1<Guid> InitiatorId { get; public set; }
    public Nullable`1<Guid> RequestId { get; public set; }
    public Uri SourceAddress { get; public set; }
    public Uri DestinationAddress { get; public set; }
    public Uri ResponseAddress { get; public set; }
    public Uri FaultAddress { get; public set; }
    public Nullable`1<DateTime> ExpirationTime { get; public set; }
    private Nullable`1<Guid> MassTransit.MessageContext.MessageId { get; }
    private Nullable`1<DateTime> MassTransit.MessageContext.SentTime { get; }
    [NullableAttribute("1")]
private Headers MassTransit.MessageContext.Headers { get; }
    [NullableAttribute("1")]
private HostInfo MassTransit.MessageContext.Host { get; }
    [NullableAttribute("1")]
private IReadOnlyDictionary`2<string, object> MassTransit.Middleware.OutboxMessageContext.Properties { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_EnqueueTime();
    [CompilerGeneratedAttribute]
public void set_EnqueueTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public DateTime get_SentTime();
    [CompilerGeneratedAttribute]
public void set_SentTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(string value);
    [CompilerGeneratedAttribute]
public string get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_SequenceNumber();
    [CompilerGeneratedAttribute]
public void set_SequenceNumber(long value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(Guid value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_MessageType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_MessageType(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Body();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ConversationId();
    [CompilerGeneratedAttribute]
public void set_ConversationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_InitiatorId();
    [CompilerGeneratedAttribute]
public void set_InitiatorId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_SourceAddress();
    [CompilerGeneratedAttribute]
public void set_SourceAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_DestinationAddress();
    [CompilerGeneratedAttribute]
public void set_DestinationAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ResponseAddress();
    [CompilerGeneratedAttribute]
public void set_ResponseAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_FaultAddress();
    [CompilerGeneratedAttribute]
public void set_FaultAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTime> value);
    private sealed virtual override Nullable`1<Guid> MassTransit.MessageContext.get_MessageId();
    private sealed virtual override Nullable`1<DateTime> MassTransit.MessageContext.get_SentTime();
    [NullableContextAttribute("1")]
private sealed virtual override Headers MassTransit.MessageContext.get_Headers();
    [NullableContextAttribute("1")]
private sealed virtual override HostInfo MassTransit.MessageContext.get_Host();
    [NullableContextAttribute("1")]
private sealed virtual override IReadOnlyDictionary`2<string, object> MassTransit.Middleware.OutboxMessageContext.get_Properties();
    [NullableContextAttribute("1")]
public void Deserialize(IObjectDeserializer deserializer);
    [NullableContextAttribute("1")]
private Headers DeserializerHeaders(IObjectDeserializer deserializer);
    [NullableContextAttribute("1")]
private IReadOnlyDictionary`2<string, object> DeserializerProperties(IObjectDeserializer deserializer);
}
public class MassTransit.Middleware.Outbox.InMemoryOutboxMessageRepository : object {
    private Dictionary`2<InMemoryInboxMessageKey, InMemoryInboxMessage> _dictionary;
    private SemaphoreSlim _inUse;
    public Task MarkInUse(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.InMemoryOutboxMessageRepository/<Lock>d__4")]
public Task`1<InMemoryInboxMessage> Lock(Guid messageId, Guid consumerId, CancellationToken cancellationToken);
    public void Release();
}
public abstract class MassTransit.Middleware.Outbox.OutboxConsumeContextProxy`1 : ConsumeContextProxy`1<TMessage> {
    private IServiceProvider _provider;
    [CompilerGeneratedAttribute]
private OutboxConsumeOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumeContext <CapturedContext>k__BackingField;
    protected OutboxConsumeOptions Options { get; }
    protected Guid ConsumerId { get; }
    public ConsumeContext CapturedContext { get; }
    public bool ContinueProcessing { get; public set; }
    public bool IsMessageConsumed { get; }
    public bool IsOutboxDelivered { get; }
    public int ReceiveCount { get; }
    public Nullable`1<long> LastSequenceNumber { get; }
    protected OutboxConsumeContextProxy`1(ConsumeContext`1<TMessage> context, OutboxConsumeOptions options, IServiceProvider provider);
    [CompilerGeneratedAttribute]
protected OutboxConsumeOptions get_Options();
    protected Guid get_ConsumerId();
    [CompilerGeneratedAttribute]
public sealed virtual ConsumeContext get_CapturedContext();
    public abstract virtual bool get_ContinueProcessing();
    public abstract virtual void set_ContinueProcessing(bool value);
    public abstract virtual bool get_IsMessageConsumed();
    public abstract virtual bool get_IsOutboxDelivered();
    public abstract virtual int get_ReceiveCount();
    public abstract virtual Nullable`1<long> get_LastSequenceNumber();
    public abstract virtual Task SetConsumed();
    public abstract virtual Task SetDelivered();
    public abstract virtual Task`1<List`1<OutboxMessageContext>> LoadOutboxMessages();
    public abstract virtual Task NotifyOutboxMessageDelivered(OutboxMessageContext message);
    public abstract virtual Task RemoveOutboxMessages();
    public abstract virtual Task AddSend(SendContext`1<T> context);
    public sealed virtual object GetService(Type serviceType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private MessageSchedulerContext <.ctor>b__1_1(MessageSchedulerContext existing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MassTransit.Middleware.Outbox.OutboxMessageStaticData : object {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<string, object> <Empty>k__BackingField;
    public static IReadOnlyDictionary`2<string, object> Empty { get; }
    private static OutboxMessageStaticData();
    [CompilerGeneratedAttribute]
public static IReadOnlyDictionary`2<string, object> get_Empty();
}
public class MassTransit.Middleware.Outbox.OutboxPublishEndpointProvider : object {
    private OutboxSendContext _context;
    private IPublishEndpointProvider _publishEndpointProvider;
    public OutboxPublishEndpointProvider(OutboxSendContext context, IPublishEndpointProvider publishEndpointProvider);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxPublishEndpointProvider/<GetPublishSendEndpoint>d__4`1")]
public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
}
public class MassTransit.Middleware.Outbox.OutboxReceiveContext : ReceiveContextProxy {
    [CompilerGeneratedAttribute]
private IPublishEndpointProvider <PublishEndpointProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendEndpointProvider <SendEndpointProvider>k__BackingField;
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public OutboxReceiveContext(OutboxSendContext outboxContext, ReceiveContext context);
    [CompilerGeneratedAttribute]
public virtual IPublishEndpointProvider get_PublishEndpointProvider();
    [CompilerGeneratedAttribute]
public virtual ISendEndpointProvider get_SendEndpointProvider();
}
public class MassTransit.Middleware.Outbox.OutboxSendEndpoint : object {
    private OutboxSendContext _context;
    private ITransportSendEndpoint _endpoint;
    public ISendEndpoint Endpoint { get; }
    public OutboxSendEndpoint(OutboxSendContext outboxContext, ISendEndpoint endpoint);
    public ISendEndpoint get_Endpoint();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__7`1")]
public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__8`1")]
public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__11`1")]
public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__14`1")]
public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__15`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<Send>d__16`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpoint/<AddSend>d__17`1")]
private Task AddSend(SendContext`1<T> context);
}
public class MassTransit.Middleware.Outbox.OutboxSendEndpointProvider : object {
    private OutboxSendContext _outboxContext;
    private ISendEndpointProvider _sendEndpointProvider;
    public OutboxSendEndpointProvider(OutboxSendContext outboxContext, ISendEndpointProvider sendEndpointProvider);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Outbox.OutboxSendEndpointProvider/<GetSendEndpoint>d__4")]
public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
}
public interface MassTransit.Middleware.OutboxConsumeContext {
    public ConsumeContext CapturedContext { get; }
    unknown bool ContinueProcessing {public set; }
    public bool IsMessageConsumed { get; }
    public bool IsOutboxDelivered { get; }
    public int ReceiveCount { get; }
    public Nullable`1<long> LastSequenceNumber { get; }
    public abstract virtual ConsumeContext get_CapturedContext();
    public abstract virtual void set_ContinueProcessing(bool value);
    public abstract virtual bool get_IsMessageConsumed();
    public abstract virtual bool get_IsOutboxDelivered();
    public abstract virtual int get_ReceiveCount();
    public abstract virtual Nullable`1<long> get_LastSequenceNumber();
    public abstract virtual Task SetConsumed();
    public abstract virtual Task SetDelivered();
    public abstract virtual Task`1<List`1<OutboxMessageContext>> LoadOutboxMessages();
    public abstract virtual Task NotifyOutboxMessageDelivered(OutboxMessageContext message);
    public abstract virtual Task RemoveOutboxMessages();
}
public interface MassTransit.Middleware.OutboxConsumeContext`1 {
}
public class MassTransit.Middleware.OutboxConsumeFilter`2 : object {
    private OutboxConsumeOptions _options;
    private IConsumeScopeProvider _scopeProvider;
    public OutboxConsumeFilter`2(IConsumeScopeProvider scopeProvider, OutboxConsumeOptions options);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.OutboxConsumeFilter`2/<Send>d__4")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.OutboxConsumeOptions : object {
    [CompilerGeneratedAttribute]
private Guid <ConsumerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageDeliveryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MessageDeliveryTimeout>k__BackingField;
    public Guid ConsumerId { get; public set; }
    public string ConsumerType { get; public set; }
    public int MessageDeliveryLimit { get; public set; }
    public TimeSpan MessageDeliveryTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_ConsumerId();
    [CompilerGeneratedAttribute]
public void set_ConsumerId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ConsumerType();
    [CompilerGeneratedAttribute]
public void set_ConsumerType(string value);
    [CompilerGeneratedAttribute]
public int get_MessageDeliveryLimit();
    [CompilerGeneratedAttribute]
public void set_MessageDeliveryLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MessageDeliveryTimeout();
    [CompilerGeneratedAttribute]
public void set_MessageDeliveryTimeout(TimeSpan value);
}
[NullableContextAttribute("1")]
public interface MassTransit.Middleware.OutboxMessageContext {
    public long SequenceNumber { get; }
    public Guid MessageId { get; }
    public string ContentType { get; }
    public string MessageType { get; }
    public string Body { get; }
    public IReadOnlyDictionary`2<string, object> Properties { get; }
    public abstract virtual long get_SequenceNumber();
    public abstract virtual Guid get_MessageId();
    public abstract virtual string get_ContentType();
    public abstract virtual string get_MessageType();
    public abstract virtual string get_Body();
    public abstract virtual IReadOnlyDictionary`2<string, object> get_Properties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Middleware.OutboxMessagePipe`1 : object {
    private IPipe`1<ConsumeContext`1<TMessage>> _next;
    private OutboxConsumeOptions _options;
    private IConsumeScopeContext`1<TMessage> _scopeContext;
    public OutboxMessagePipe`1(OutboxConsumeOptions options, IConsumeScopeContext`1<TMessage> scopeContext, IPipe`1<ConsumeContext`1<TMessage>> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.OutboxMessagePipe`1/<Send>d__4")]
public sealed virtual Task Send(OutboxConsumeContext`1<TMessage> context);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.OutboxMessagePipe`1/<DeliverOutboxMessages>d__6")]
private Task DeliverOutboxMessages(OutboxConsumeContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Middleware.OutboxMessageSendPipe : object {
    [NullableAttribute("2")]
private Uri _destinationAddress;
    private OutboxMessageContext _message;
    public OutboxMessageSendPipe(OutboxMessageContext message, Uri destinationAddress);
    public sealed virtual Task Send(SendContext context);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.Middleware.OutboxSendContext {
    public abstract virtual Task AddSend(SendContext`1<T> context);
}
public class MassTransit.Middleware.OutputPipeFilter`2 : object {
    private IPipeContextConverter`2<TInput, TOutput> _contextConverter;
    private FilterObservable`1<TOutput> _observers;
    private FilterObservable _outerObservers;
    private ITeeFilter`1<TOutput> _output;
    public OutputPipeFilter`2(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, ITeeFilter`1<TOutput> outputFilter);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IFilter<TInput>.Send(TInput context, IPipe`1<TInput> next);
    private sealed virtual override ConnectHandle MassTransit.IFilterObserverConnector<TOutput>.ConnectObserver(IFilterObserver`1<TOutput> observer);
    private sealed virtual override ConnectHandle MassTransit.Middleware.IPipeConnector<TOutput>.ConnectPipe(IPipe`1<TOutput> pipe);
    [AsyncStateMachineAttribute("MassTransit.Middleware.OutputPipeFilter`2/<SendToOutput>d__9")]
private Task SendToOutput(IPipe`1<TInput> next, TOutput pipeContext);
}
public class MassTransit.Middleware.OutputPipeFilter`3 : OutputPipeFilter`2<TInput, TOutput> {
    private ITeeFilter`2<TOutput, TKey> _outputFilter;
    public OutputPipeFilter`3(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, KeyAccessor`2<TInput, TKey> keyAccessor);
    protected OutputPipeFilter`3(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, ITeeFilter`2<TOutput, TKey> outputFilter);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
}
public class MassTransit.Middleware.Partition : object {
    private int _index;
    private SemaphoreSlim _limit;
    private long _attemptCount;
    private long _failureCount;
    private long _successCount;
    public Partition(int index);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Partition/<DisposeAsync>d__6")]
public sealed virtual ValueTask DisposeAsync();
    public void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Partition/<Send>d__8`1")]
public Task Send(T context, IPipe`1<T> next);
}
public class MassTransit.Middleware.Partitioner : object {
    private IHashGenerator _hashGenerator;
    private string _id;
    private int _partitionCount;
    private Partition[] _partitions;
    public Partitioner(int partitionCount, IHashGenerator hashGenerator);
    public sealed virtual IPartitioner`1<T> GetPartitioner(PartitionKeyProvider`1<T> keyProvider);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.Partitioner/<DisposeAsync>d__7")]
public sealed virtual ValueTask DisposeAsync();
    private Task Send(Byte[] key, T context, IPipe`1<T> next);
}
public class MassTransit.Middleware.PartitionFilter`1 : object {
    private IPartitioner`1<TContext> _partitioner;
    public PartitionFilter`1(PartitionKeyProvider`1<TContext> keyProvider, IPartitioner partitioner);
    private sealed virtual override Task MassTransit.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Middleware.PayloadFilter`2 : object {
    private TPayload _payload;
    public PayloadFilter`2(TPayload payload);
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private TPayload <Send>b__3_0();
}
public class MassTransit.Middleware.PipeContextConverterFactory : object {
    public sealed virtual IPipeContextConverter`2<PipeContext, TOutput> GetConverter();
}
public class MassTransit.Middleware.PipeContextSourceBindFilter`2 : object {
    private IPipe`1<BindContext`2<TLeft, TRight>> _output;
    private IPipeContextSource`2<TRight, TLeft> _source;
    public PipeContextSourceBindFilter`2(IPipe`1<BindContext`2<TLeft, TRight>> output, IPipeContextSource`2<TRight, TLeft> source);
    public sealed virtual Task Send(TLeft context, IPipe`1<TLeft> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.PipeRouter : DynamicRouter`1<PipeContext> {
}
public class MassTransit.Middleware.PublishMessageSchedulerFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext>.Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    private static IMessageScheduler SchedulerFactory(ConsumeContext context);
}
public class MassTransit.Middleware.QuerySagaFilter`2 : object {
    private IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> _messagePipe;
    private ISagaPolicy`2<TSaga, TMessage> _policy;
    private ISagaQueryFactory`2<TSaga, TMessage> _queryFactory;
    private ISagaRepository`1<TSaga> _sagaRepository;
    public QuerySagaFilter`2(ISagaRepository`1<TSaga> sagaRepository, ISagaPolicy`2<TSaga, TMessage> policy, ISagaQueryFactory`2<TSaga, TMessage> queryFactory, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> messagePipe);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.QuerySagaFilter`2/<Send>d__6")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.RateLimitFilter`1 : object {
    private TimeSpan _interval;
    private SemaphoreSlim _limit;
    private Timer _timer;
    private int _count;
    private int _rateLimit;
    public RateLimitFilter`1(int rateLimit, TimeSpan interval);
    public sealed virtual void Dispose();
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RateLimitFilter`1/<Send>d__9")]
public sealed virtual Task Send(CommandContext`1<SetRateLimit> context);
    private void Reset(object state);
}
public class MassTransit.Middleware.ReceiveEndpointDependencyFilter`1 : object {
    private ReceiveEndpointContext _context;
    public ReceiveEndpointDependencyFilter`1(ReceiveEndpointContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ReceiveEndpointDependencyFilter`1/<Send>d__2")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.RedeliveryRetryFilter`2 : object {
    private RetryObservable _observers;
    private IRetryPolicy _retryPolicy;
    public RedeliveryRetryFilter`2(IRetryPolicy retryPolicy, RetryObservable observers);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RedeliveryRetryFilter`2/<Send>d__4")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class MassTransit.Middleware.RequestIdFilter`1 : object {
    private ConcurrentDictionary`2<Guid, IPipe`1<ConsumeContext`1<TMessage>>> _pipes;
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RequestIdFilter`1/<Send>d__3")]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
    public sealed virtual ConnectHandle ConnectPipe(Guid key, IPipe`1<ConsumeContext`1<TMessage>> pipe);
    private void RemovePipe(Guid key);
}
public class MassTransit.Middleware.RequestIdTeeFilter`1 : TeeFilter`1<ConsumeContext`1<TMessage>> {
    private Lazy`1<IKeyPipeConnector`2<TMessage, Guid>> _keyConnections;
    public sealed virtual ConnectHandle ConnectPipe(Guid key, IPipe`1<ConsumeContext`1<TMessage>> pipe);
    private RequestIdFilter`1<TMessage> ConnectKeyFilter();
}
public class MassTransit.Middleware.Rescue.RescueExceptionConsumeContext : ConsumeContextProxy {
    private ExceptionInfo _exceptionInfo;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionInfo ExceptionInfo { get; }
    public RescueExceptionConsumeContext(ConsumeContext context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    public sealed virtual ExceptionInfo get_ExceptionInfo();
}
public class MassTransit.Middleware.Rescue.RescueExceptionConsumeContext`1 : ConsumeContextProxy`1<TMessage> {
    private ExceptionInfo _exceptionInfo;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionInfo ExceptionInfo { get; }
    public RescueExceptionConsumeContext`1(ConsumeContext`1<TMessage> context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    public sealed virtual ExceptionInfo get_ExceptionInfo();
}
public class MassTransit.Middleware.Rescue.RescueExceptionConsumerConsumeContext`1 : ConsumeContextProxy {
    private ConsumerConsumeContext`1<TConsumer> _context;
    private ExceptionInfo _exceptionInfo;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public TConsumer Consumer { get; }
    public Exception Exception { get; }
    public ExceptionInfo ExceptionInfo { get; }
    public RescueExceptionConsumerConsumeContext`1(ConsumerConsumeContext`1<TConsumer> context, Exception exception);
    public sealed virtual TConsumer get_Consumer();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    public sealed virtual ExceptionInfo get_ExceptionInfo();
}
public class MassTransit.Middleware.Rescue.RescueExceptionReceiveContext : ReceiveContextProxy {
    private ExceptionInfo _exceptionInfo;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExceptionTimestamp>k__BackingField;
    public Exception Exception { get; }
    public DateTime ExceptionTimestamp { get; }
    public ExceptionInfo ExceptionInfo { get; }
    public RescueExceptionReceiveContext(ReceiveContext context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ExceptionTimestamp();
    public sealed virtual ExceptionInfo get_ExceptionInfo();
}
public class MassTransit.Middleware.Rescue.RescueExceptionSagaConsumeContext`1 : ConsumeContextProxy {
    private SagaConsumeContext`1<TSaga> _context;
    private ExceptionInfo _exceptionInfo;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public TSaga Saga { get; }
    public bool IsCompleted { get; }
    public Exception Exception { get; }
    public ExceptionInfo ExceptionInfo { get; }
    public RescueExceptionSagaConsumeContext`1(SagaConsumeContext`1<TSaga> context, Exception exception);
    public sealed virtual TSaga get_Saga();
    public sealed virtual Task SetCompleted();
    public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    public sealed virtual ExceptionInfo get_ExceptionInfo();
}
public class MassTransit.Middleware.RescueContextFactory`2 : MulticastDelegate {
    public RescueContextFactory`2(object object, IntPtr method);
    public virtual TRescueContext Invoke(TContext context, Exception exception);
    public virtual IAsyncResult BeginInvoke(TContext context, Exception exception, AsyncCallback callback, object object);
    public virtual TRescueContext EndInvoke(IAsyncResult result);
}
public class MassTransit.Middleware.RescueFilter`2 : object {
    private IExceptionFilter _exceptionFilter;
    private RescueContextFactory`2<TContext, TRescueContext> _rescueContextFactory;
    private IPipe`1<TRescueContext> _rescuePipe;
    public RescueFilter`2(IPipe`1<TRescueContext> rescuePipe, IExceptionFilter exceptionFilter, RescueContextFactory`2<TContext, TRescueContext> rescueContextFactory);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RescueFilter`2/<MassTransit-IFilter<TContext>-Send>d__5")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
}
public class MassTransit.Middleware.RethrowErrorTransportFilter : object {
    [AsyncStateMachineAttribute("MassTransit.Middleware.RethrowErrorTransportFilter/<Send>d__0")]
public sealed virtual Task Send(ExceptionReceiveContext context, IPipe`1<ExceptionReceiveContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.RetryBusObserver : object {
    private CancellationTokenSource _stopping;
    public CancellationToken Stopping { get; }
    public CancellationToken get_Stopping();
    public sealed virtual void PostCreate(IBus bus);
    public sealed virtual void CreateFaulted(Exception exception);
    public sealed virtual Task PreStart(IBus bus);
    public sealed virtual Task PostStart(IBus bus, Task`1<BusReady> busReady);
    public sealed virtual Task StartFaulted(IBus bus, Exception exception);
    public sealed virtual Task PreStop(IBus bus);
    public sealed virtual Task PostStop(IBus bus);
    public sealed virtual Task StopFaulted(IBus bus, Exception exception);
}
public class MassTransit.Middleware.RetryFilter`1 : object {
    private RetryObservable _observers;
    private IRetryPolicy _retryPolicy;
    public RetryFilter`1(IRetryPolicy retryPolicy, RetryObservable observers);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RetryFilter`1/<MassTransit-IFilter<TContext>-Send>d__4")]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
private sealed virtual override Task MassTransit.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("MassTransit.Middleware.RetryFilter`1/<Attempt>d__5")]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
private Task Attempt(TContext context, RetryContext`1<TContext> retryContext, IPipe`1<TContext> next);
}
public class MassTransit.Middleware.SagaMergePipe`2 : object {
    private IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> _output;
    public SagaMergePipe`2(IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> output);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(SagaConsumeContext`1<TSaga> context);
}
public class MassTransit.Middleware.SagaMessageMergePipe`2 : object {
    private SagaConsumeContext`2<TSaga, TMessage> _context;
    private IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> _output;
    public SagaMessageMergePipe`2(IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> output, SagaConsumeContext`2<TSaga, TMessage> context);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context);
}
public class MassTransit.Middleware.SagaMessageSplitFilter`2 : object {
    private IFilter`1<ConsumeContext`1<TMessage>> _next;
    public SagaMessageSplitFilter`2(IFilter`1<ConsumeContext`1<TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.SagaSplitFilter`2 : object {
    private IFilter`1<SagaConsumeContext`1<TSaga>> _next;
    public SagaSplitFilter`2(IFilter`1<SagaConsumeContext`1<TSaga>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Send(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Middleware.ScheduleMessageRedeliveryFilter`1 : object {
    private RedeliveryOptions _options;
    public ScheduleMessageRedeliveryFilter`1(RedeliveryOptions options);
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumeContext`1<TMessage>> next);
}
public class MassTransit.Middleware.ScopeCompensateFilter`2 : object {
    private ICompensateActivityScopeProvider`2<TActivity, TLog> _scopeProvider;
    public ScopeCompensateFilter`2(ICompensateActivityScopeProvider`2<TActivity, TLog> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopeCompensateFilter`2/<Send>d__2")]
public sealed virtual Task Send(CompensateContext`1<TLog> context, IPipe`1<CompensateContext`1<TLog>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopeConsumeFilter : object {
    private IConsumeScopeProvider _scopeProvider;
    public ScopeConsumeFilter(IConsumeScopeProvider scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopeConsumeFilter/<Send>d__2")]
public sealed virtual Task Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopedCompensateFilter`3 : object {
    private ICompensateActivityScopeProvider`2<TActivity, TArguments> _scopeProvider;
    public ScopedCompensateFilter`3(ICompensateActivityScopeProvider`2<TActivity, TArguments> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopedCompensateFilter`3/<Send>d__2")]
public sealed virtual Task Send(CompensateContext`1<TArguments> context, IPipe`1<CompensateContext`1<TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopedConsumeFilter`2 : object {
    private IConsumeScopeProvider _scopeProvider;
    public ScopedConsumeFilter`2(IConsumeScopeProvider scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopedConsumeFilter`2/<Send>d__2")]
public sealed virtual Task Send(ConsumeContext`1<T> context, IPipe`1<ConsumeContext`1<T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopedExecuteFilter`3 : object {
    private IExecuteActivityScopeProvider`2<TActivity, TArguments> _scopeProvider;
    public ScopedExecuteFilter`3(IExecuteActivityScopeProvider`2<TActivity, TArguments> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopedExecuteFilter`3/<Send>d__2")]
public sealed virtual Task Send(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteContext`1<TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopedFilter`1 : object {
    private IFilterScopeProvider`1<TContext> _scopeProvider;
    public ScopedFilter`1(IFilterScopeProvider`1<TContext> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopedFilter`1/<Send>d__2")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopeExecuteFilter`2 : object {
    private IExecuteActivityScopeProvider`2<TActivity, TArguments> _scopeProvider;
    public ScopeExecuteFilter`2(IExecuteActivityScopeProvider`2<TActivity, TArguments> scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopeExecuteFilter`2/<Send>d__2")]
public sealed virtual Task Send(ExecuteContext`1<TArguments> context, IPipe`1<ExecuteContext`1<TArguments>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.ScopeMessageFilter`1 : object {
    private IConsumeScopeProvider _scopeProvider;
    public ScopeMessageFilter`1(IConsumeScopeProvider scopeProvider);
    [AsyncStateMachineAttribute("MassTransit.Middleware.ScopeMessageFilter`1/<Send>d__2")]
public sealed virtual Task Send(ConsumeContext`1<T> context, IPipe`1<ConsumeContext`1<T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.SendQuerySagaPipe`2 : object {
    private IPipe`1<SagaConsumeContext`2<TSaga, T>> _next;
    private ISagaPolicy`2<TSaga, T> _policy;
    public SendQuerySagaPipe`2(ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.SendQuerySagaPipe`2/<Send>d__4")]
public sealed virtual Task Send(SagaRepositoryQueryContext`2<TSaga, T> context);
}
public class MassTransit.Middleware.SendSagaPipe`2 : object {
    private Guid _correlationId;
    private IPipe`1<SagaConsumeContext`2<TSaga, T>> _next;
    private ISagaPolicy`2<TSaga, T> _policy;
    public SendSagaPipe`2(ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next, Guid correlationId);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.SendSagaPipe`2/<Send>d__5")]
public sealed virtual Task Send(SagaRepositoryContext`2<TSaga, T> context);
}
public class MassTransit.Middleware.SetCorrelationIdFilter`1 : object {
    private IMessageCorrelationId`1<T> _messageCorrelationId;
    public SetCorrelationIdFilter`1(IMessageCorrelationId`1<T> messageCorrelationId);
    public sealed virtual Task Send(SendContext`1<T> context, IPipe`1<SendContext`1<T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.SetPartitionKeyFilter`1 : object {
    private IMessagePartitionKeyFormatter`1<TMessage> _routingKeyFormatter;
    public SetPartitionKeyFilter`1(IMessagePartitionKeyFormatter`1<TMessage> routingKeyFormatter);
    public sealed virtual Task Send(SendContext`1<TMessage> context, IPipe`1<SendContext`1<TMessage>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.SetRoutingKeyFilter`1 : object {
    private IMessageRoutingKeyFormatter`1<TMessage> _routingKeyFormatter;
    public SetRoutingKeyFilter`1(IMessageRoutingKeyFormatter`1<TMessage> routingKeyFormatter);
    public sealed virtual Task Send(SendContext`1<TMessage> context, IPipe`1<SendContext`1<TMessage>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.SetSerializerFilter`1 : object {
    private ContentType _contentType;
    public SetSerializerFilter`1(ContentType contentType);
    public sealed virtual Task Send(SendContext`1<T> context, IPipe`1<SendContext`1<T>> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.StateMachineSagaMessageFilter`2 : object {
    private string _activityName;
    private Event`1<TMessage> _event;
    private SagaStateMachine`1<TInstance> _machine;
    public StateMachineSagaMessageFilter`2(SagaStateMachine`1<TInstance> machine, Event`1<TMessage> event);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.StateMachineSagaMessageFilter`2/<Send>d__5")]
public sealed virtual Task Send(SagaConsumeContext`2<TInstance, TMessage> context, IPipe`1<SagaConsumeContext`2<TInstance, TMessage>> next);
    [CompilerGeneratedAttribute]
private bool <MassTransit.IProbeSite.Probe>b__4_0(State`1<TInstance> x);
}
public class MassTransit.Middleware.TeeFilter`1 : object {
    private Connectable`1<IPipe`1<TContext>> _connections;
    public int Count { get; }
    public sealed virtual int get_Count();
    public sealed virtual void Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<TContext> pipe);
}
public class MassTransit.Middleware.TeeFilter`2 : TeeFilter`1<TContext> {
    private KeyAccessor`2<TContext, TKey> _keyAccessor;
    private Lazy`1<IKeyPipeConnector`1<TKey>> _keyConnections;
    public TeeFilter`2(KeyAccessor`2<TContext, TKey> keyAccessor);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    private IKeyPipeConnector`1<TKey> ConnectKeyFilter();
}
public class MassTransit.Middleware.Timeout.TimeoutCompensateContext`1 : TimeoutCourierContextProxy {
    private CompensateContext`1<TLog> _context;
    private CompensationResult MassTransit.CompensateContext.Result { get; private set; }
    private TLog MassTransit.CompensateContext<TLog>.Log { get; }
    public TimeoutCompensateContext`1(CompensateContext`1<TLog> context, CancellationToken cancellationToken);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(object values);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Compensated(IDictionary`2<string, object> variables);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed();
    private sealed virtual override CompensationResult MassTransit.CompensateContext.Failed(Exception exception);
    private sealed virtual override CompensationResult MassTransit.CompensateContext.get_Result();
    private sealed virtual override void MassTransit.CompensateContext.set_Result(CompensationResult value);
    private sealed virtual override TLog MassTransit.CompensateContext<TLog>.get_Log();
    private sealed virtual override CompensateActivityContext`2<TActivity, TLog> MassTransit.CompensateContext<TLog>.CreateActivityContext(TActivity activity);
}
public class MassTransit.Middleware.Timeout.TimeoutConsumeContext`1 : ConsumeContextProxy {
    private ConsumeContext`1<TMessage> _context;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public TMessage Message { get; }
    public TimeoutConsumeContext`1(ConsumeContext`1<TMessage> context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    public sealed virtual TMessage get_Message();
    [AsyncStateMachineAttribute("MassTransit.Middleware.Timeout.TimeoutConsumeContext`1/<NotifyFaulted>d__7`1")]
public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
}
public abstract class MassTransit.Middleware.Timeout.TimeoutCourierContextProxy : TimeoutConsumeContext`1<RoutingSlip> {
    private CourierContext _courierContext;
    private DateTime MassTransit.CourierContext.Timestamp { get; }
    private TimeSpan MassTransit.CourierContext.Elapsed { get; }
    private Guid MassTransit.CourierContext.TrackingNumber { get; }
    private Guid MassTransit.CourierContext.ExecutionId { get; }
    private string MassTransit.CourierContext.ActivityName { get; }
    protected TimeoutCourierContextProxy(CourierContext courierContext, CancellationToken cancellationToken);
    private sealed virtual override DateTime MassTransit.CourierContext.get_Timestamp();
    private sealed virtual override TimeSpan MassTransit.CourierContext.get_Elapsed();
    private sealed virtual override Guid MassTransit.CourierContext.get_TrackingNumber();
    private sealed virtual override Guid MassTransit.CourierContext.get_ExecutionId();
    private sealed virtual override string MassTransit.CourierContext.get_ActivityName();
}
public class MassTransit.Middleware.Timeout.TimeoutExecuteContext`1 : TimeoutCourierContextProxy {
    private ExecuteContext`1<TArguments> _context;
    public ExecutionResult Result { get; public set; }
    public TArguments Arguments { get; }
    public TimeoutExecuteContext`1(ExecuteContext`1<TArguments> context, CancellationToken cancellationToken);
    public sealed virtual ExecutionResult Completed();
    public sealed virtual ExecutionResult CompletedWithVariables(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object variables);
    public sealed virtual ExecutionResult Completed(TLog log);
    public sealed virtual ExecutionResult Completed(object logValues);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(object logValues, object variables);
    public sealed virtual ExecutionResult CompletedWithVariables(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult ReviseItinerary(Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, object variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult ReviseItinerary(TLog log, IEnumerable`1<KeyValuePair`2<string, object>> variables, Action`1<IItineraryBuilder> buildItinerary);
    public sealed virtual ExecutionResult Terminate();
    public sealed virtual ExecutionResult Terminate(object variables);
    public sealed virtual ExecutionResult Terminate(IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult Faulted();
    public sealed virtual ExecutionResult Faulted(Exception exception);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, object variables);
    public sealed virtual ExecutionResult FaultedWithVariables(Exception exception, IEnumerable`1<KeyValuePair`2<string, object>> variables);
    public sealed virtual ExecutionResult get_Result();
    public sealed virtual void set_Result(ExecutionResult value);
    public sealed virtual TArguments get_Arguments();
    public sealed virtual ExecuteActivityContext`2<TActivity, TArguments> CreateActivityContext(TActivity activity);
}
public class MassTransit.Middleware.TimeoutFilter`2 : object {
    private Func`3<TContext, CancellationToken, TResult> _contextFactory;
    private TimeSpan _timeout;
    public TimeoutFilter`2(Func`3<TContext, CancellationToken, TResult> contextFactory, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Middleware.TimeoutFilter`2/<Send>d__3")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.Middleware.TransactionFilter`1 : object {
    private TransactionOptions _options;
    public TransactionFilter`1(IsolationLevel isolationLevel, TimeSpan timeout);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.TransactionFilter`1/<Send>d__3")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(T context, IPipe`1<T> next);
}
public class MassTransit.Middleware.TransformFilter`1 : object {
    private IMessageInitializer`1<T> _initializer;
    public TransformFilter`1(IMessageInitializer`1<T> initializer);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.CompensateContext<T>>.Send(CompensateContext`1<T> context, IPipe`1<CompensateContext`1<T>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext<T>>.Send(ConsumeContext`1<T> context, IPipe`1<ConsumeContext`1<T>> next);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.ExecuteContext<T>>.Send(ExecuteContext`1<T> context, IPipe`1<ExecuteContext`1<T>> next);
    private sealed virtual override Task MassTransit.IFilter<MassTransit.SendContext<T>>.Send(SendContext`1<T> context, IPipe`1<SendContext`1<T>> next);
}
public class MassTransit.Middleware.TransportReadyFilter`1 : object {
    private ReceiveEndpointContext _context;
    public TransportReadyFilter`1(ReceiveEndpointContext context);
    [AsyncStateMachineAttribute("MassTransit.Middleware.TransportReadyFilter`1/<Send>d__2")]
public sealed virtual Task Send(T context, IPipe`1<T> next);
    public sealed virtual void Probe(ProbeContext context);
}
[ExtensionAttribute]
public static class MassTransit.MissingInstanceRedeliveryExtensions : object {
    [ExtensionAttribute]
public static IPipe`1<ConsumeContext`1<TData>> Redeliver(IMissingInstanceConfigurator`2<TInstance, TData> configurator, Action`1<IMissingInstanceRedeliveryConfigurator`2<TInstance, TData>> configure);
}
public class MassTransit.Monitoring.BusHealthCheck : object {
    private IBusInstance _busInstance;
    public BusHealthCheck(IBusInstance busInstance);
    public sealed virtual Task`1<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken);
}
public class MassTransit.Monitoring.ConfigureBusHealthCheckServiceOptions : object {
    private IEnumerable`1<IBusInstance> _busInstances;
    private IServiceProvider _provider;
    private String[] _tags;
    public ConfigureBusHealthCheckServiceOptions(IEnumerable`1<IBusInstance> busInstances, IServiceProvider provider);
    public sealed virtual void Configure(HealthCheckServiceOptions options);
}
public class MassTransit.Monitoring.ConfigureDefaultInstrumentationOptions : object {
    public sealed virtual void Configure(InstrumentationOptions options);
}
public class MassTransit.Monitoring.InstrumentationOptions : object {
    public static string MeterName;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerTypeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionTypeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTypeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityNameLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgumentTypeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogTypeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceNameLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumeTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumeFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumeRetryTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SagaTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SagaFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SagaDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandlerTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandlerFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandlerDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublishTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublishFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SendTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SendFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityExecuteTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityExecuteFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityExecuteDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityCompensateTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityCompensateFailureTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityCompensateDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BusInstances>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointInstances>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandlerInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SagaInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecuteInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompensateInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumeDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeliveryDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutboxSendTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutboxSendFaultTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutboxDeliveryTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutboxDeliveryFaultTotal>k__BackingField;
    public string ServiceName { get; public set; }
    public string EndpointLabel { get; public set; }
    public string ConsumerTypeLabel { get; public set; }
    public string ExceptionTypeLabel { get; public set; }
    public string MessageTypeLabel { get; public set; }
    public string ActivityNameLabel { get; public set; }
    public string ArgumentTypeLabel { get; public set; }
    public string LogTypeLabel { get; public set; }
    public string ServiceNameLabel { get; public set; }
    public string ReceiveTotal { get; public set; }
    public string ReceiveFaultTotal { get; public set; }
    public string ReceiveDuration { get; public set; }
    public string ReceiveInProgress { get; public set; }
    public string ConsumeTotal { get; public set; }
    public string ConsumeFaultTotal { get; public set; }
    public string ConsumeRetryTotal { get; public set; }
    public string SagaTotal { get; public set; }
    public string SagaFaultTotal { get; public set; }
    public string SagaDuration { get; public set; }
    public string HandlerTotal { get; public set; }
    public string HandlerFaultTotal { get; public set; }
    public string HandlerDuration { get; public set; }
    [ObsoleteAttribute]
public string PublishTotal { get; public set; }
    [ObsoleteAttribute]
public string PublishFaultTotal { get; public set; }
    public string SendTotal { get; public set; }
    public string SendFaultTotal { get; public set; }
    public string ActivityExecuteTotal { get; public set; }
    public string ActivityExecuteFaultTotal { get; public set; }
    public string ActivityExecuteDuration { get; public set; }
    public string ActivityCompensateTotal { get; public set; }
    public string ActivityCompensateFailureTotal { get; public set; }
    public string ActivityCompensateDuration { get; public set; }
    public string BusInstances { get; public set; }
    public string EndpointInstances { get; public set; }
    public string ConsumerInProgress { get; public set; }
    public string HandlerInProgress { get; public set; }
    public string SagaInProgress { get; public set; }
    public string ExecuteInProgress { get; public set; }
    public string CompensateInProgress { get; public set; }
    public string ConsumeDuration { get; public set; }
    public string DeliveryDuration { get; public set; }
    public string OutboxSendTotal { get; public set; }
    public string OutboxSendFaultTotal { get; public set; }
    public string OutboxDeliveryTotal { get; public set; }
    public string OutboxDeliveryFaultTotal { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointLabel();
    [CompilerGeneratedAttribute]
public void set_EndpointLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumerTypeLabel();
    [CompilerGeneratedAttribute]
public void set_ConsumerTypeLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ExceptionTypeLabel();
    [CompilerGeneratedAttribute]
public void set_ExceptionTypeLabel(string value);
    [CompilerGeneratedAttribute]
public string get_MessageTypeLabel();
    [CompilerGeneratedAttribute]
public void set_MessageTypeLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityNameLabel();
    [CompilerGeneratedAttribute]
public void set_ActivityNameLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ArgumentTypeLabel();
    [CompilerGeneratedAttribute]
public void set_ArgumentTypeLabel(string value);
    [CompilerGeneratedAttribute]
public string get_LogTypeLabel();
    [CompilerGeneratedAttribute]
public void set_LogTypeLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ServiceNameLabel();
    [CompilerGeneratedAttribute]
public void set_ServiceNameLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ReceiveTotal();
    [CompilerGeneratedAttribute]
public void set_ReceiveTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ReceiveFaultTotal();
    [CompilerGeneratedAttribute]
public void set_ReceiveFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ReceiveDuration();
    [CompilerGeneratedAttribute]
public void set_ReceiveDuration(string value);
    [CompilerGeneratedAttribute]
public string get_ReceiveInProgress();
    [CompilerGeneratedAttribute]
public void set_ReceiveInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumeTotal();
    [CompilerGeneratedAttribute]
public void set_ConsumeTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumeFaultTotal();
    [CompilerGeneratedAttribute]
public void set_ConsumeFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumeRetryTotal();
    [CompilerGeneratedAttribute]
public void set_ConsumeRetryTotal(string value);
    [CompilerGeneratedAttribute]
public string get_SagaTotal();
    [CompilerGeneratedAttribute]
public void set_SagaTotal(string value);
    [CompilerGeneratedAttribute]
public string get_SagaFaultTotal();
    [CompilerGeneratedAttribute]
public void set_SagaFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_SagaDuration();
    [CompilerGeneratedAttribute]
public void set_SagaDuration(string value);
    [CompilerGeneratedAttribute]
public string get_HandlerTotal();
    [CompilerGeneratedAttribute]
public void set_HandlerTotal(string value);
    [CompilerGeneratedAttribute]
public string get_HandlerFaultTotal();
    [CompilerGeneratedAttribute]
public void set_HandlerFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_HandlerDuration();
    [CompilerGeneratedAttribute]
public void set_HandlerDuration(string value);
    [CompilerGeneratedAttribute]
public string get_PublishTotal();
    [CompilerGeneratedAttribute]
public void set_PublishTotal(string value);
    [CompilerGeneratedAttribute]
public string get_PublishFaultTotal();
    [CompilerGeneratedAttribute]
public void set_PublishFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_SendTotal();
    [CompilerGeneratedAttribute]
public void set_SendTotal(string value);
    [CompilerGeneratedAttribute]
public string get_SendFaultTotal();
    [CompilerGeneratedAttribute]
public void set_SendFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityExecuteTotal();
    [CompilerGeneratedAttribute]
public void set_ActivityExecuteTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityExecuteFaultTotal();
    [CompilerGeneratedAttribute]
public void set_ActivityExecuteFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityExecuteDuration();
    [CompilerGeneratedAttribute]
public void set_ActivityExecuteDuration(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityCompensateTotal();
    [CompilerGeneratedAttribute]
public void set_ActivityCompensateTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityCompensateFailureTotal();
    [CompilerGeneratedAttribute]
public void set_ActivityCompensateFailureTotal(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityCompensateDuration();
    [CompilerGeneratedAttribute]
public void set_ActivityCompensateDuration(string value);
    [CompilerGeneratedAttribute]
public string get_BusInstances();
    [CompilerGeneratedAttribute]
public void set_BusInstances(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointInstances();
    [CompilerGeneratedAttribute]
public void set_EndpointInstances(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumerInProgress();
    [CompilerGeneratedAttribute]
public void set_ConsumerInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_HandlerInProgress();
    [CompilerGeneratedAttribute]
public void set_HandlerInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_SagaInProgress();
    [CompilerGeneratedAttribute]
public void set_SagaInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_ExecuteInProgress();
    [CompilerGeneratedAttribute]
public void set_ExecuteInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_CompensateInProgress();
    [CompilerGeneratedAttribute]
public void set_CompensateInProgress(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumeDuration();
    [CompilerGeneratedAttribute]
public void set_ConsumeDuration(string value);
    [CompilerGeneratedAttribute]
public string get_DeliveryDuration();
    [CompilerGeneratedAttribute]
public void set_DeliveryDuration(string value);
    [CompilerGeneratedAttribute]
public string get_OutboxSendTotal();
    [CompilerGeneratedAttribute]
public void set_OutboxSendTotal(string value);
    [CompilerGeneratedAttribute]
public string get_OutboxSendFaultTotal();
    [CompilerGeneratedAttribute]
public void set_OutboxSendFaultTotal(string value);
    [CompilerGeneratedAttribute]
public string get_OutboxDeliveryTotal();
    [CompilerGeneratedAttribute]
public void set_OutboxDeliveryTotal(string value);
    [CompilerGeneratedAttribute]
public string get_OutboxDeliveryFaultTotal();
    [CompilerGeneratedAttribute]
public void set_OutboxDeliveryFaultTotal(string value);
}
public abstract class MassTransit.Monitoring.Performance.BasePerformanceCounters : object {
    private Lazy`1<CounterData[]> _counterCreationData;
    protected CounterData[] Data { get; }
    protected CounterData[] get_Data();
    private void Initialize();
    protected abstract virtual IEnumerable`1<CounterData> GetCounterData();
    protected CounterData Convert(Counter counter, CounterType type);
    [CompilerGeneratedAttribute]
private CounterData[] <.ctor>b__1_0();
}
public static class MassTransit.Monitoring.Performance.BuiltInCounters : object {
}
public class MassTransit.Monitoring.Performance.ConsumerPerformanceCounter : object {
    private IPerformanceCounter _consumeRate;
    private IPerformanceCounter _duration;
    private IPerformanceCounter _durationBase;
    private IPerformanceCounter _faultPercentage;
    private IPerformanceCounter _faultPercentageBase;
    private IPerformanceCounter _totalFaults;
    private IPerformanceCounter _totalMessages;
    public ConsumerPerformanceCounter(ICounterFactory factory, string consumerType);
    public sealed virtual void Consumed(TimeSpan duration);
    public sealed virtual void Faulted();
    public sealed virtual void Dispose();
}
public class MassTransit.Monitoring.Performance.ConsumerPerformanceCounterCache : object {
    private ConcurrentDictionary`2<string, Lazy`1<ConsumerPerformanceCounter>> _types;
    public static IConsumerPerformanceCounter GetCounter(ICounterFactory factory, string consumerType);
}
public class MassTransit.Monitoring.Performance.ConsumerPerformanceCounters : BasePerformanceCounters {
    public static CounterData ConsumeRate { get; }
    public static CounterData TotalMessages { get; }
    public static CounterData Duration { get; }
    public static CounterData DurationBase { get; }
    public static CounterData TotalFaults { get; }
    public static CounterData FaultPercentage { get; }
    public static CounterData FaultPercentageBase { get; }
    public static CounterData get_ConsumeRate();
    public static CounterData get_TotalMessages();
    public static CounterData get_Duration();
    public static CounterData get_DurationBase();
    public static CounterData get_TotalFaults();
    public static CounterData get_FaultPercentage();
    public static CounterData get_FaultPercentageBase();
    public static void Install();
    [IteratorStateMachineAttribute("MassTransit.Monitoring.Performance.ConsumerPerformanceCounters/<GetCounterData>d__15")]
protected virtual IEnumerable`1<CounterData> GetCounterData();
}
public class MassTransit.Monitoring.Performance.Counter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    public string Name { get; }
    public string Help { get; }
    public Counter(string name, string help);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Help();
}
public class MassTransit.Monitoring.Performance.CounterCategory : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    public string Name { get; }
    public string Help { get; }
    public CounterCategory(string name, string help);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Help();
}
public class MassTransit.Monitoring.Performance.CounterData : object {
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterType <CounterType>k__BackingField;
    public string CounterName { get; public set; }
    public string CounterDescription { get; public set; }
    public CounterType CounterType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterDescription();
    [CompilerGeneratedAttribute]
public void set_CounterDescription(string value);
    [CompilerGeneratedAttribute]
public CounterType get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(CounterType value);
}
public enum MassTransit.Monitoring.Performance.CounterType : Enum {
    public int value__;
    public static CounterType NumberOfItems64;
    public static CounterType RateOfCountsPerSecond32;
    public static CounterType AverageCount64;
    public static CounterType AverageBase;
}
public class MassTransit.Monitoring.Performance.CreateCounterDelegate : MulticastDelegate {
    public CreateCounterDelegate(object object, IntPtr method);
    public virtual IPerformanceCounter Invoke(string name, string instanceName);
    public virtual IAsyncResult BeginInvoke(string name, string instanceName, AsyncCallback callback, object object);
    public virtual IPerformanceCounter EndInvoke(IAsyncResult result);
}
public interface MassTransit.Monitoring.Performance.IConsumerPerformanceCounter {
    public abstract virtual void Consumed(TimeSpan duration);
    public abstract virtual void Faulted();
}
public interface MassTransit.Monitoring.Performance.ICounterFactory {
    public abstract virtual IPerformanceCounter Create(CounterCategory category, string counterName, string instanceName);
}
public interface MassTransit.Monitoring.Performance.IMessagePerformanceCounter {
    public abstract virtual void Consumed(TimeSpan duration);
    public abstract virtual void ConsumeFaulted(TimeSpan duration);
    public abstract virtual void Sent();
    public abstract virtual void Published();
    public abstract virtual void PublishFaulted();
    public abstract virtual void SendFaulted();
}
public interface MassTransit.Monitoring.Performance.IPerformanceCounter {
    public abstract virtual void Increment();
    public abstract virtual void IncrementBy(long val);
    public abstract virtual void Set(long val);
}
public interface MassTransit.Monitoring.Performance.IPerformanceCounterInstaller {
    public abstract virtual void Install();
}
public interface MassTransit.Monitoring.Performance.ISendPerformanceCounter {
    public abstract virtual void Sent();
    public abstract virtual void Faulted();
}
public class MassTransit.Monitoring.Performance.MessagePerformanceCounter`1 : object {
    private IPerformanceCounter _consumedPerSecond;
    private IPerformanceCounter _consumeDuration;
    private IPerformanceCounter _consumeDurationBase;
    private IPerformanceCounter _faulted;
    private IPerformanceCounter _faultPercentage;
    private IPerformanceCounter _faultPercentageBase;
    private IPerformanceCounter _publishedPerSecond;
    private IPerformanceCounter _publishFaulted;
    private IPerformanceCounter _publishFaultPercentage;
    private IPerformanceCounter _publishFaultPercentageBase;
    private IPerformanceCounter _sendFaulted;
    private IPerformanceCounter _sendFaultPercentage;
    private IPerformanceCounter _sendFaultPercentageBase;
    private IPerformanceCounter _sentPerSecond;
    private IPerformanceCounter _totalConsumed;
    private IPerformanceCounter _totalPublished;
    private IPerformanceCounter _totalSent;
    public MessagePerformanceCounter`1(ICounterFactory factory);
    public sealed virtual void Dispose();
    public sealed virtual void Consumed(TimeSpan duration);
    public sealed virtual void ConsumeFaulted(TimeSpan duration);
    public sealed virtual void Sent();
    public sealed virtual void Published();
    public sealed virtual void PublishFaulted();
    public sealed virtual void SendFaulted();
}
public static class MassTransit.Monitoring.Performance.MessagePerformanceCounterCache`1 : object {
    private static Lazy`1<MessagePerformanceCounter`1<T>> _cache;
    public static IMessagePerformanceCounter Counter(ICounterFactory factory);
}
public class MassTransit.Monitoring.Performance.MessagePerformanceCounters : BasePerformanceCounters {
    public static CounterData ConsumedPerSecond { get; }
    public static CounterData TotalReceived { get; }
    public static CounterData ConsumeDuration { get; }
    public static CounterData ConsumeDurationBase { get; }
    public static CounterData ConsumeFaulted { get; }
    public static CounterData ConsumeFaultPercentage { get; }
    public static CounterData ConsumeFaultPercentageBase { get; }
    public static CounterData SentPerSecond { get; }
    public static CounterData TotalSent { get; }
    public static CounterData SendFaulted { get; }
    public static CounterData SendFaultPercentage { get; }
    public static CounterData SendFaultPercentageBase { get; }
    public static CounterData PublishedPerSecond { get; }
    public static CounterData TotalPublished { get; }
    public static CounterData PublishFaulted { get; }
    public static CounterData PublishFaultPercentage { get; }
    public static CounterData PublishFaultPercentageBase { get; }
    public static CounterData get_ConsumedPerSecond();
    public static CounterData get_TotalReceived();
    public static CounterData get_ConsumeDuration();
    public static CounterData get_ConsumeDurationBase();
    public static CounterData get_ConsumeFaulted();
    public static CounterData get_ConsumeFaultPercentage();
    public static CounterData get_ConsumeFaultPercentageBase();
    public static CounterData get_SentPerSecond();
    public static CounterData get_TotalSent();
    public static CounterData get_SendFaulted();
    public static CounterData get_SendFaultPercentage();
    public static CounterData get_SendFaultPercentageBase();
    public static CounterData get_PublishedPerSecond();
    public static CounterData get_TotalPublished();
    public static CounterData get_PublishFaulted();
    public static CounterData get_PublishFaultPercentage();
    public static CounterData get_PublishFaultPercentageBase();
    [IteratorStateMachineAttribute("MassTransit.Monitoring.Performance.MessagePerformanceCounters/<GetCounterData>d__34")]
protected virtual IEnumerable`1<CounterData> GetCounterData();
    public static void Install();
}
public class MassTransit.Monitoring.Performance.Null.NullCounterFactory : object {
    public sealed virtual IPerformanceCounter Create(CounterCategory category, string counterName, string instanceName);
}
public class MassTransit.Monitoring.Performance.Null.NullPerformanceCounter : object {
    public sealed virtual void Increment();
    public sealed virtual void IncrementBy(long val);
    public sealed virtual void Set(long val);
    public sealed virtual void Dispose();
}
public class MassTransit.Monitoring.Performance.PerformanceCounterBusObserver : object {
    private ICounterFactory _factory;
    public PerformanceCounterBusObserver(ICounterFactory factory);
    public sealed virtual void PostCreate(IBus bus);
    public sealed virtual void CreateFaulted(Exception exception);
    public sealed virtual Task PreStart(IBus bus);
    public sealed virtual Task PostStart(IBus bus, Task`1<BusReady> busReady);
    public sealed virtual Task StartFaulted(IBus bus, Exception exception);
    public sealed virtual Task PreStop(IBus bus);
    public sealed virtual Task PostStop(IBus bus);
    public sealed virtual Task StopFaulted(IBus bus, Exception exception);
}
public class MassTransit.Monitoring.Performance.PerformanceCounterPublishObserver : object {
    private ICounterFactory _factory;
    public PerformanceCounterPublishObserver(ICounterFactory factory);
    private sealed virtual override Task MassTransit.IPublishObserver.PrePublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PostPublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PublishFault(PublishContext`1<T> context, Exception exception);
}
public class MassTransit.Monitoring.Performance.PerformanceCounterReceiveObserver : object {
    private ICounterFactory _factory;
    public PerformanceCounterReceiveObserver(ICounterFactory factory);
    private sealed virtual override Task MassTransit.IReceiveObserver.PreReceive(ReceiveContext context);
    private sealed virtual override Task MassTransit.IReceiveObserver.PostReceive(ReceiveContext context);
    private sealed virtual override Task MassTransit.IReceiveObserver.PostConsume(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    private sealed virtual override Task MassTransit.IReceiveObserver.ConsumeFault(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    private sealed virtual override Task MassTransit.IReceiveObserver.ReceiveFault(ReceiveContext context, Exception exception);
}
public class MassTransit.Monitoring.Performance.PerformanceCounterSendObserver : object {
    private ICounterFactory _factory;
    public PerformanceCounterSendObserver(ICounterFactory factory);
    private sealed virtual override Task MassTransit.ISendObserver.PreSend(SendContext`1<T> context);
    private sealed virtual override Task MassTransit.ISendObserver.PostSend(SendContext`1<T> context);
    private sealed virtual override Task MassTransit.ISendObserver.SendFault(SendContext`1<T> context, Exception exception);
}
public class MassTransit.Monitoring.Performance.StatsD.StatsDConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    public string Hostname { get; public set; }
    public int Port { get; public set; }
    public StatsDConfiguration(string hostname, int port);
    [CompilerGeneratedAttribute]
public string get_Hostname();
    [CompilerGeneratedAttribute]
public void set_Hostname(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    public static StatsDConfiguration Defaults();
}
public class MassTransit.Monitoring.Performance.StatsD.StatsDCounterFactory : object {
    private StatsDConfiguration _config;
    public StatsDCounterFactory(StatsDConfiguration config);
    public sealed virtual IPerformanceCounter Create(CounterCategory category, string counterName, string instanceName);
}
public class MassTransit.Monitoring.Performance.StatsD.StatsDPerformanceCounter : object {
    private UdpClient _client;
    private string _fullName;
    private Byte[] _incrementPayload;
    public StatsDPerformanceCounter(StatsDConfiguration cfg, string category, string name, string instance);
    public sealed virtual void Increment();
    public sealed virtual void IncrementBy(long val);
    public sealed virtual void Set(long val);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class MassTransit.ObserverExtensions : object {
    [ExtensionAttribute]
public static void Observer(IReceiveEndpointConfigurator configurator, IObserver`1<ConsumeContext`1<T>> observer, Action`1<IObserverConfigurator`1<T>> configureCallback);
    [ExtensionAttribute]
public static ConnectHandle ConnectObserver(IBus bus, IObserver`1<ConsumeContext`1<T>> observer);
    [ExtensionAttribute]
public static ConnectHandle ConnectRequestObserver(IBus bus, Guid requestId, IObserver`1<ConsumeContext`1<T>> observer);
}
[ExtensionAttribute]
public static class MassTransit.ObserverRegistrationExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddBusObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddBusObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddReceiveEndpointObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddReceiveEndpointObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddReceiveObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddReceiveObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddConsumeObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddConsumeObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddSendObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddSendObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddPublishObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddPublishObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddEventObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddEventObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
    [ExtensionAttribute]
public static IServiceCollection AddStateObserver(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddStateObserver(IServiceCollection services, Func`2<IServiceProvider, T> factory);
}
public class MassTransit.OutboxDeliveryServiceOptions : object {
    [CompilerGeneratedAttribute]
private int <MessageDeliveryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MessageDeliveryTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <QueryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryMessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <QueryTimeout>k__BackingField;
    public int MessageDeliveryLimit { get; public set; }
    public TimeSpan MessageDeliveryTimeout { get; public set; }
    public TimeSpan QueryDelay { get; public set; }
    public int QueryMessageLimit { get; public set; }
    public TimeSpan QueryTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MessageDeliveryLimit();
    [CompilerGeneratedAttribute]
public void set_MessageDeliveryLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MessageDeliveryTimeout();
    [CompilerGeneratedAttribute]
public void set_MessageDeliveryTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_QueryDelay();
    [CompilerGeneratedAttribute]
public void set_QueryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_QueryMessageLimit();
    [CompilerGeneratedAttribute]
public void set_QueryMessageLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_QueryTimeout();
    [CompilerGeneratedAttribute]
public void set_QueryTimeout(TimeSpan value);
}
[ExtensionAttribute]
public static class MassTransit.PartitionerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseMessagePartitioner(IConsumePipeConfigurator configurator, int partitionCount);
    [ExtensionAttribute]
public static void UsePartitioner(IConsumePipeConfigurator configurator, IPartitioner partitioner, Func`2<ConsumeContext`1<T>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IPartitioner partitioner, Func`2<ConsumeContext`1<T>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, int partitionCount, Func`2<ConsumeContext`1<T>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ConsumerConsumeContext`1<TConsumer>> configurator, int partitionCount, Func`2<ConsumerConsumeContext`1<TConsumer>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ConsumerConsumeContext`1<TConsumer>> configurator, int partitionCount, Func`2<ConsumerConsumeContext`1<TConsumer>, string> keyProvider, Encoding encoding);
    private static void UseConsumerPartitioner(IPipeConfigurator`1<ConsumerConsumeContext`1<TConsumer>> configurator, int partitionCount, PartitionKeyProvider`1<ConsumerConsumeContext`1<TConsumer>> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<SagaConsumeContext`1<TSaga>> configurator, int partitionCount, Func`2<SagaConsumeContext`1<TSaga>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<SagaConsumeContext`1<TSaga>> configurator, int partitionCount, Func`2<SagaConsumeContext`1<TSaga>, string> keyProvider, Encoding encoding);
    private static void UseSagaPartitioner(IPipeConfigurator`1<SagaConsumeContext`1<TSaga>> configurator, int partitionCount, PartitionKeyProvider`1<SagaConsumeContext`1<TSaga>> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator, int partitionCount, Func`2<ExecuteActivityContext`2<TActivity, TArguments>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator, IPartitioner partitioner, Func`2<ExecuteActivityContext`2<TActivity, TArguments>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator, int partitionCount, Func`2<ExecuteActivityContext`2<TActivity, TArguments>, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<ExecuteActivityContext`2<TActivity, TArguments>> configurator, IPartitioner partitioner, Func`2<ExecuteActivityContext`2<TActivity, TArguments>, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator, int partitionCount, Func`2<CompensateActivityContext`2<TActivity, TLog>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator, IPartitioner partitioner, Func`2<CompensateActivityContext`2<TActivity, TLog>, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator, int partitionCount, Func`2<CompensateActivityContext`2<TActivity, TLog>, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<CompensateActivityContext`2<TActivity, TLog>> configurator, IPartitioner partitioner, Func`2<CompensateActivityContext`2<TActivity, TLog>, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static IPartitioner CreatePartitioner(IPipeConfigurator`1<T> _, int partitionCount);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, long> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, long> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, Byte[]> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, Byte[]> keyProvider);
}
[ExtensionAttribute]
public static class MassTransit.PartitionKeyConventionExtensions : object {
    [ExtensionAttribute]
public static void UsePartitionKeyFormatter(IMessageSendTopologyConfigurator`1<T> configurator, IMessagePartitionKeyFormatter`1<T> formatter);
    [ExtensionAttribute]
public static void UsePartitionKeyFormatter(ISendTopologyConfigurator configurator, IMessagePartitionKeyFormatter`1<T> formatter);
    [ExtensionAttribute]
public static void UsePartitionKeyFormatter(ISendTopologyConfigurator configurator, Func`2<SendContext`1<T>, string> formatter);
    [ExtensionAttribute]
public static void UsePartitionKeyFormatter(IMessageSendTopologyConfigurator`1<T> configurator, Func`2<SendContext`1<T>, string> formatter);
}
public class MassTransit.PartitionKeyProvider`1 : MulticastDelegate {
    public PartitionKeyProvider`1(object object, IntPtr method);
    public virtual Byte[] Invoke(TContext context);
    public virtual IAsyncResult BeginInvoke(TContext context, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class MassTransit.PendingFutureIdProvider`1 : MulticastDelegate {
    public PendingFutureIdProvider`1(object object, IntPtr method);
    public virtual Guid Invoke(T message);
    public virtual IAsyncResult BeginInvoke(T message, AsyncCallback callback, object object);
    public virtual Guid EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class MassTransit.PerformanceCounterExtensions : object {
    [ExtensionAttribute]
public static void EnableStatsdPerformanceCounters(IBusFactoryConfigurator configurator, Action`1<StatsDConfiguration> action);
}
public interface MassTransit.PipeContextHandle`1 {
    public bool IsDisposed { get; }
    public Task`1<TContext> Context { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual Task`1<TContext> get_Context();
}
[ExtensionAttribute]
public static class MassTransit.PublishEndpointRecurringSchedulerExtensions : object {
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(IPublishEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CancelScheduledRecurringSend(IPublishEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task CancelScheduledRecurringSend(IPublishEndpoint endpoint, string scheduleId, string scheduleGroup);
    [ExtensionAttribute]
public static Task PauseScheduledRecurringSend(IPublishEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task PauseScheduledRecurringSend(IPublishEndpoint endpoint, string scheduleId, string scheduleGroup);
    [ExtensionAttribute]
public static Task ResumeScheduledRecurringSend(IPublishEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task ResumeScheduledRecurringSend(IPublishEndpoint endpoint, string scheduleId, string scheduleGroup);
}
[ExtensionAttribute]
public static class MassTransit.PublishExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Publish(EventActivityBinder`1<TInstance> source, TMessage message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> PublishAsync(EventActivityBinder`1<TInstance> source, Task`1<TMessage> message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Publish(EventActivityBinder`1<TInstance> source, EventMessageFactory`2<TInstance, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> PublishAsync(EventActivityBinder`1<TInstance> source, AsyncEventMessageFactory`2<TInstance, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> PublishAsync(EventActivityBinder`1<TInstance> source, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Publish(EventActivityBinder`2<TInstance, TData> source, TMessage message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> PublishAsync(EventActivityBinder`2<TInstance, TData> source, Task`1<TMessage> message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Publish(EventActivityBinder`2<TInstance, TData> source, EventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> PublishAsync(EventActivityBinder`2<TInstance, TData> source, AsyncEventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> PublishAsync(EventActivityBinder`2<TInstance, TData> source, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Publish(ExceptionActivityBinder`2<TInstance, TException> source, TMessage message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> PublishAsync(ExceptionActivityBinder`2<TInstance, TException> source, Task`1<TMessage> message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Publish(ExceptionActivityBinder`2<TInstance, TException> source, EventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> PublishAsync(ExceptionActivityBinder`2<TInstance, TException> source, AsyncEventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> PublishAsync(ExceptionActivityBinder`2<TInstance, TException> source, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Publish(ExceptionActivityBinder`3<TInstance, TData, TException> source, TMessage message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> PublishAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Task`1<TMessage> message, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Publish(ExceptionActivityBinder`3<TInstance, TData, TException> source, EventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> PublishAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> PublishAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<PublishContext`1<TMessage>> callback);
    private static Action`1<SendContext`1<T>> Uplift(Action`1<PublishContext`1<T>> callback);
}
[ExtensionAttribute]
public static class MassTransit.RateLimitConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRateLimit(IPipeConfigurator`1<T> configurator, int rateLimit, IPipeRouter router);
    [ExtensionAttribute]
public static void UseRateLimit(IPipeConfigurator`1<T> configurator, int rateLimit, TimeSpan interval, IPipeRouter router);
    [ExtensionAttribute]
public static void UseRateLimit(IConsumePipeConfigurator configurator, int rateLimit, TimeSpan interval);
}
[ExtensionAttribute]
public static class MassTransit.RawJsonSerializerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRawJsonSerializer(IBusFactoryConfigurator configurator, RawSerializerOptions options, bool isDefault);
    [ExtensionAttribute]
public static void AddRawJsonSerializer(IBusFactoryConfigurator configurator, RawSerializerOptions options);
    [ExtensionAttribute]
public static void UseRawJsonDeserializer(IBusFactoryConfigurator configurator, RawSerializerOptions options, bool isDefault);
    [ExtensionAttribute]
public static void UseRawJsonSerializer(IReceiveEndpointConfigurator configurator, RawSerializerOptions options, bool isDefault);
    [ExtensionAttribute]
public static void UseRawJsonDeserializer(IReceiveEndpointConfigurator configurator, RawSerializerOptions options, bool isDefault);
}
[FlagsAttribute]
public enum MassTransit.RawSerializerOptions : Enum {
    public int value__;
    public static RawSerializerOptions AnyMessageType;
    public static RawSerializerOptions AddTransportHeaders;
    public static RawSerializerOptions CopyHeaders;
    public static RawSerializerOptions Default;
    public static RawSerializerOptions All;
}
[ExtensionAttribute]
public static class MassTransit.ReceiveEndpointConfigurationExtensions : object {
    [ExtensionAttribute]
public static void ReceiveEndpoint(IBusFactoryConfigurator configurator, Action`1<IReceiveEndpointConfigurator> configure);
    [ExtensionAttribute]
public static void ReceiveEndpoint(IBusFactoryConfigurator configurator, IEndpointDefinition definition, Action`1<IReceiveEndpointConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.ReceivePipeConfigurationExtensions : object {
    [ExtensionAttribute]
public static void ConfigureDefaultDeadLetterTransport(IReceivePipelineConfigurator configurator);
    [ExtensionAttribute]
public static void DiscardSkippedMessages(IReceivePipelineConfigurator configurator);
    [ExtensionAttribute]
public static void ConfigureDefaultErrorTransport(IReceivePipelineConfigurator configurator);
    [ExtensionAttribute]
public static void DiscardFaultedMessages(IReceivePipelineConfigurator configurator);
    [ExtensionAttribute]
public static void RethrowFaultedMessages(IReceivePipelineConfigurator configurator);
    [ExtensionAttribute]
public static void ThrowOnSkippedMessages(IReceivePipelineConfigurator configurator);
}
[ExtensionAttribute]
public static class MassTransit.RedeliverExtensions : object {
    [ExtensionAttribute]
public static Task Redeliver(ConsumeContext`1<T> context, TimeSpan delay, Action`2<ConsumeContext, SendContext> callback);
}
[ExtensionAttribute]
public static class MassTransit.RegistrationConfiguratorExtensions : object {
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator`1<T> AddConsumer(IRegistrationConfigurator configurator, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator`1<T> AddConsumer(IRegistrationConfigurator configurator, Type consumerDefinitionType, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSaga(IRegistrationConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSaga(IRegistrationConfigurator configurator, Type sagaDefinitionType, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(IRegistrationConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(IRegistrationConfigurator configurator, Type sagaDefinitionType, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(IRegistrationConfigurator configurator, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(IRegistrationConfigurator configurator, Type executeActivityDefinitionType, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(IRegistrationConfigurator configurator, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    [ExtensionAttribute]
public static IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(IRegistrationConfigurator configurator, Type activityDefinitionType, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator AddConsumer(IRegistrationConfigurator configurator, Type consumerType, Type consumerDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator AddSaga(IRegistrationConfigurator configurator, Type sagaType, Type sagaDefinitionType);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator AddSagaStateMachine(IRegistrationConfigurator configurator, Type sagaType, Type sagaDefinitionType);
    [ExtensionAttribute]
public static IActivityRegistrationConfigurator AddActivity(IRegistrationConfigurator configurator, Type activityType, Type activityDefinitionType);
    [ExtensionAttribute]
public static IExecuteActivityRegistrationConfigurator AddExecuteActivity(IRegistrationConfigurator configurator, Type activityType, Type activityDefinitionType);
    [ExtensionAttribute]
public static IFutureRegistrationConfigurator AddFuture(IRegistrationConfigurator configurator, Type futureType, Type futureDefinitionType);
}
[ExtensionAttribute]
public static class MassTransit.RegistrationContextExtensions : object {
    [ExtensionAttribute]
public static void ConfigureEndpoints(IBusFactoryConfigurator`1<T> configurator, IBusRegistrationContext registration, IEndpointNameFormatter endpointNameFormatter);
    [ExtensionAttribute]
public static void ConfigureEndpoints(IBusFactoryConfigurator`1<T> configurator, IBusRegistrationContext registration, Action`1<IRegistrationFilterConfigurator> configureFilter, IEndpointNameFormatter endpointNameFormatter);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static void ConfigureEndpoints(IServiceInstanceConfigurator`1<T> configurator, IBusRegistrationContext registration, IEndpointNameFormatter endpointNameFormatter);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static void ConfigureEndpoints(IServiceInstanceConfigurator`1<T> configurator, IBusRegistrationContext registration, Action`1<IRegistrationFilterConfigurator> configureFilter, IEndpointNameFormatter endpointNameFormatter);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static void ConfigureServiceEndpoints(IBusFactoryConfigurator`1<T> configurator, IBusRegistrationContext registration, Action`1<IRegistrationFilterConfigurator> configureFilter, ServiceInstanceOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Job Consumers no longer require a service instance. Visit https://masstransit.io/obsolete for details.")]
public static void ConfigureServiceEndpoints(IBusFactoryConfigurator`1<T> configurator, IBusRegistrationContext registration, ServiceInstanceOptions options);
    [ExtensionAttribute]
public static void ConfigureConsumer(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Type consumerType);
    [ExtensionAttribute]
public static void ConfigureConsumer(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void ConfigureConsumers(IReceiveEndpointConfigurator configurator, IRegistrationContext registration);
    [ExtensionAttribute]
public static void ConfigureSaga(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Type sagaType);
    [ExtensionAttribute]
public static void ConfigureSaga(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void ConfigureSagas(IReceiveEndpointConfigurator configurator, IRegistrationContext registration);
    [ExtensionAttribute]
public static void ConfigureActivity(IReceiveEndpointConfigurator configurator, IReceiveEndpointConfigurator compensateEndpointConfigurator, IRegistrationContext registration, Type activityType);
    [ExtensionAttribute]
public static void ConfigureExecuteActivity(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Type activityType);
    [ExtensionAttribute]
public static void ConfigureActivityExecute(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Type activityType, Uri compensateAddress);
    [ExtensionAttribute]
public static void ConfigureActivityCompensate(IReceiveEndpointConfigurator configurator, IRegistrationContext registration, Type activityType);
}
[ExtensionAttribute]
public static class MassTransit.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IConsumerRegistrationConfigurator`1<T> AddConsumer(IRegistrationConfigurator configurator, Action`1<IConsumerConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void AddConsumers(IRegistrationConfigurator configurator, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddConsumers(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddConsumersFromNamespaceContaining(IRegistrationConfigurator configurator, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddConsumersFromNamespaceContaining(IRegistrationConfigurator configurator, Type type, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddConsumers(IRegistrationConfigurator configurator, Type[] types);
    [ExtensionAttribute]
public static void AddConsumers(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Type[] types);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSaga(IRegistrationConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void AddSagas(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddSagas(IRegistrationConfigurator configurator, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddSagasFromNamespaceContaining(IRegistrationConfigurator configurator, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddSagasFromNamespaceContaining(IRegistrationConfigurator configurator, Type type, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddSagas(IRegistrationConfigurator configurator, Type[] types);
    [ExtensionAttribute]
public static void AddSagas(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Type[] types);
    [ExtensionAttribute]
public static ISagaRegistrationConfigurator`1<T> AddSagaStateMachine(IRegistrationConfigurator configurator, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void AddSagaStateMachines(IRegistrationConfigurator configurator, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddSagaStateMachinesFromNamespaceContaining(IRegistrationConfigurator configurator, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddSagaStateMachinesFromNamespaceContaining(IRegistrationConfigurator configurator, Type type, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddSagaStateMachines(IRegistrationConfigurator configurator, Type[] types);
    [ExtensionAttribute]
public static void AddSagaStateMachines(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Type[] types);
    [ExtensionAttribute]
public static IExecuteActivityRegistrationConfigurator`2<TActivity, TArguments> AddExecuteActivity(IRegistrationConfigurator configurator, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configure);
    [ExtensionAttribute]
public static IActivityRegistrationConfigurator`3<TActivity, TArguments, TLog> AddActivity(IRegistrationConfigurator configurator, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    [ExtensionAttribute]
public static void AddActivities(IRegistrationConfigurator configurator, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddActivitiesFromNamespaceContaining(IRegistrationConfigurator configurator, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddActivitiesFromNamespaceContaining(IRegistrationConfigurator configurator, Type type, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddActivities(IRegistrationConfigurator configurator, Type[] types);
    [ExtensionAttribute]
public static void AddActivities(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Type[] types);
    [ExtensionAttribute]
public static void SetDefaultEndpointNameFormatter(IRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static void SetSnakeCaseEndpointNameFormatter(IRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static void SetKebabCaseEndpointNameFormatter(IRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static IFutureRegistrationConfigurator`1<T> AddFuture(IRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static IFutureRegistrationConfigurator`1<TFuture> AddFutureRequestConsumer(IRegistrationConfigurator configurator, Action`1<IConsumerConfigurator`1<TConsumer>> configure);
    [ExtensionAttribute]
public static void AddFutures(IRegistrationConfigurator configurator, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddFutures(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Assembly[] assemblies);
    [ExtensionAttribute]
public static void AddFuturesFromNamespaceContaining(IRegistrationConfigurator configurator, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddFuturesFromNamespaceContaining(IRegistrationConfigurator configurator, Type type, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddFutures(IRegistrationConfigurator configurator, Type[] types);
    [ExtensionAttribute]
public static void AddFutures(IRegistrationConfigurator configurator, Func`2<Type, bool> filter, Type[] types);
    private static Type[] FindTypesInNamespace(Type type, Func`2<Type, bool> typeFilter);
}
public class MassTransit.RequestAddressProvider`1 : MulticastDelegate {
    public RequestAddressProvider`1(object object, IntPtr method);
    public virtual Uri Invoke(BehaviorContext`2<FutureState, TMessage> context);
    public virtual IAsyncResult BeginInvoke(BehaviorContext`2<FutureState, TMessage> context, AsyncCallback callback, object object);
    public virtual Uri EndInvoke(IAsyncResult result);
}
public class MassTransit.RequestConsumerFuture`2 : Future`2<TRequest, TResponse> {
    public RequestConsumerFuture`2(IFutureDefinition definition);
}
[ExtensionAttribute]
public static class MassTransit.RequestEventExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RequestStarted(EventActivityBinder`2<TInstance, TData> source);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RequestCompleted(EventActivityBinder`2<TInstance, TData> source);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RequestCompleted(EventActivityBinder`2<TInstance, TData> source, AsyncEventMessageFactory`3<TInstance, TData, TResponse> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RequestFaulted(EventActivityBinder`2<TInstance, TData> source, Event`1<TRequest> requestEvent);
}
[ExtensionAttribute]
public static class MassTransit.RequestExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__0`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(IBus bus, Uri destinationAddress, TRequest message, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__1`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(IBus bus, Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__2`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(IBus bus, TRequest message, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__3`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(IBus bus, object values, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__4`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(ConsumeContext consumeContext, IBus bus, Uri destinationAddress, TRequest message, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__5`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(ConsumeContext consumeContext, IBus bus, Uri destinationAddress, object values, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__6`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(ConsumeContext consumeContext, IBus bus, TRequest message, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
    [AsyncStateMachineAttribute("MassTransit.RequestExtensions/<Request>d__7`2")]
[ExtensionAttribute]
public static Task`1<Response`1<TResponse>> Request(ConsumeContext consumeContext, IBus bus, object values, CancellationToken cancellationToken, RequestTimeout timeout, Action`1<SendContext`1<TRequest>> callback);
}
[ExtensionAttribute]
public static class MassTransit.RescueConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<ReceiveContext> configurator, IPipe`1<ExceptionReceiveContext> rescuePipe, Action`1<IExceptionConfigurator> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<ConsumeContext> configurator, IPipe`1<ExceptionConsumeContext> rescuePipe, Action`1<IExceptionConfigurator> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IPipe`1<ExceptionConsumeContext`1<T>> rescuePipe, Action`1<IExceptionConfigurator> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<ConsumerConsumeContext`1<T>> configurator, IPipe`1<ExceptionConsumerConsumeContext`1<T>> rescuePipe, Action`1<IExceptionConfigurator> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<SagaConsumeContext`1<T>> configurator, IPipe`1<ExceptionSagaConsumeContext`1<T>> rescuePipe, Action`1<IExceptionConfigurator> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<TContext> configurator, IPipe`1<TRescue> rescuePipe, RescueContextFactory`2<TContext, TRescue> rescueContextFactory, Action`1<IRescueConfigurator`2<TContext, TRescue>> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<TContext> configurator, RescueContextFactory`2<TContext, TRescue> rescueContextFactory, Action`1<IRescueConfigurator`2<TContext, TRescue>> configure);
}
[ExtensionAttribute]
public static class MassTransit.RespondExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Respond(EventActivityBinder`2<TInstance, TData> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RespondAsync(EventActivityBinder`2<TInstance, TData> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Respond(EventActivityBinder`2<TInstance, TData> source, EventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RespondAsync(EventActivityBinder`2<TInstance, TData> source, AsyncEventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> RespondAsync(EventActivityBinder`2<TInstance, TData> source, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Respond(ExceptionActivityBinder`2<TInstance, TException> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> RespondAsync(ExceptionActivityBinder`2<TInstance, TException> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Respond(ExceptionActivityBinder`2<TInstance, TException> source, EventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> RespondAsync(ExceptionActivityBinder`2<TInstance, TException> source, AsyncEventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Respond(ExceptionActivityBinder`3<TInstance, TData, TException> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> RespondAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Respond(ExceptionActivityBinder`3<TInstance, TData, TException> source, EventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> RespondAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
}
[ExtensionAttribute]
public static class MassTransit.Retry : object {
    private static IExceptionFilter _all;
    [CompilerGeneratedAttribute]
private static IRetryPolicy <None>k__BackingField;
    public static IRetryPolicy None { get; }
    private static Retry();
    [CompilerGeneratedAttribute]
public static IRetryPolicy get_None();
    public static IRetryPolicy Immediate(int retryLimit);
    [ExtensionAttribute]
public static IRetryPolicy Immediate(IExceptionFilter filter, int retryLimit);
    public static IRetryPolicy Intervals(TimeSpan[] intervals);
    [ExtensionAttribute]
public static IRetryPolicy Intervals(IExceptionFilter filter, TimeSpan[] intervals);
    public static IRetryPolicy Intervals(Int32[] intervals);
    [ExtensionAttribute]
public static IRetryPolicy Intervals(IExceptionFilter filter, Int32[] intervals);
    public static IRetryPolicy Interval(int retryCount, TimeSpan interval);
    public static IRetryPolicy Interval(int retryCount, int interval);
    [ExtensionAttribute]
public static IRetryPolicy Interval(IExceptionFilter filter, int retryCount, TimeSpan interval);
    public static IRetryPolicy Exponential(int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    public static IRetryPolicy Exponential(TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    [ExtensionAttribute]
public static IRetryPolicy Exponential(IExceptionFilter filter, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    public static IRetryPolicy Incremental(int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
    [ExtensionAttribute]
public static IRetryPolicy Incremental(IExceptionFilter filter, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
    public static IRetryPolicy CreatePolicy(Action`1<IRetryConfigurator> configure);
    public static IExceptionFilter Except(Type[] exceptionTypes);
    public static IExceptionFilter Except();
    public static IExceptionFilter Except();
    public static IExceptionFilter Except();
    public static IExceptionFilter Selected(Type[] exceptionTypes);
    public static IExceptionFilter Selected();
    public static IExceptionFilter Selected();
    public static IExceptionFilter Selected();
    public static IExceptionFilter All();
    public static IExceptionFilter Filter(Func`2<T, bool> filter);
}
[ExtensionAttribute]
public static class MassTransit.RetryConfigurationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumeContext> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseMessageRetry(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IConsumePipeConfigurator configurator, Action`1<IRetryConfigurator> configure);
    private static RetryConsumeContext`1<T> Factory(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumerConsumeContext`1<TConsumer>> configurator, Action`1<IRetryConfigurator> configure);
    private static RetryConsumerConsumeContext`1<TConsumer> Factory(ConsumerConsumeContext`1<TConsumer> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<SagaConsumeContext`1<TSaga>> configurator, Action`1<IRetryConfigurator> configure);
    private static RetrySagaConsumeContext`1<TSaga> Factory(SagaConsumeContext`1<TSaga> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [ExtensionAttribute]
public static void UseRetry(IPipeConfigurator`1<T> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumeContext> configurator, IBusFactoryConfigurator connector, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IBusFactoryConfigurator configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IBusFactoryConfigurator connector, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<ConsumerConsumeContext`1<TConsumer>> configurator, IBusFactoryConfigurator connector, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
[ObsoleteAttribute("Use UseMessageRetry instead. Visit https://masstransit.io/obsolete for details.")]
public static void UseRetry(IPipeConfigurator`1<SagaConsumeContext`1<TSaga>> configurator, IBusFactoryConfigurator connector, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static IRetryConfigurator None(IRetryConfigurator configurator);
    [ExtensionAttribute]
public static IRetryConfigurator Immediate(IRetryConfigurator configurator, int retryLimit);
    [ExtensionAttribute]
public static IRetryConfigurator Intervals(IRetryConfigurator configurator, TimeSpan[] intervals);
    [ExtensionAttribute]
public static IRetryConfigurator Intervals(IRetryConfigurator configurator, Int32[] intervals);
    [ExtensionAttribute]
public static IRetryConfigurator Interval(IRetryConfigurator configurator, int retryCount, TimeSpan interval);
    [ExtensionAttribute]
public static IRetryConfigurator Interval(IRetryConfigurator configurator, int retryCount, int interval);
    [ExtensionAttribute]
public static IRetryConfigurator Exponential(IRetryConfigurator configurator, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    [ExtensionAttribute]
public static IRetryConfigurator Incremental(IRetryConfigurator configurator, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
}
public class MassTransit.RetryPolicies.BaseRetryContext`1 : object {
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    public TContext Context { get; }
    public CancellationToken CancellationToken { get; }
    public Exception Exception { get; }
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public Nullable`1<TimeSpan> Delay { get; }
    private Type MassTransit.RetryContext.ContextType { get; }
    protected BaseRetryContext`1(TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual TContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryCount();
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override Type MassTransit.RetryContext.get_ContextType();
    public virtual Task PreRetry();
    public virtual Task RetryFaulted(Exception exception);
}
public abstract class MassTransit.RetryPolicies.BaseRetryPolicyContext`1 : object {
    private IRetryPolicy _policy;
    private CancellationTokenSource _cancellationTokenSource;
    private CancellationTokenRegistration _registration;
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    protected CancellationToken CancellationToken { get; }
    public TContext Context { get; }
    protected BaseRetryPolicyContext`1(IRetryPolicy policy, TContext context);
    protected CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual TContext get_Context();
    public virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    private sealed virtual override Task MassTransit.RetryPolicyContext<TContext>.RetryFaulted(Exception exception);
    public sealed virtual void Cancel();
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
    private CancellationToken CreateCancellationToken();
}
public class MassTransit.RetryPolicies.ConsumeContextRetryContext : object {
    private RetryConsumeContext _context;
    private RetryContext`1<ConsumeContext> _retryContext;
    public CancellationToken CancellationToken { get; }
    public ConsumeContext Context { get; }
    public Exception Exception { get; }
    public int RetryCount { get; }
    public int RetryAttempt { get; }
    public Type ContextType { get; }
    public Nullable`1<TimeSpan> Delay { get; }
    public ConsumeContextRetryContext(RetryContext`1<ConsumeContext> retryContext, RetryConsumeContext context);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual ConsumeContext get_Context();
    public sealed virtual Exception get_Exception();
    public sealed virtual int get_RetryCount();
    public sealed virtual int get_RetryAttempt();
    public sealed virtual Type get_ContextType();
    public sealed virtual Nullable`1<TimeSpan> get_Delay();
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.ConsumeContextRetryContext/<PreRetry>d__17")]
public sealed virtual Task PreRetry();
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.ConsumeContextRetryContext/<RetryFaulted>d__18")]
public sealed virtual Task RetryFaulted(Exception exception);
    public sealed virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.ConsumeContextRetryContext`2 : object {
    private TContext _context;
    private RetryContext`1<TFilter> _retryContext;
    public CancellationToken CancellationToken { get; }
    public TFilter Context { get; }
    public Exception Exception { get; }
    public int RetryCount { get; }
    public int RetryAttempt { get; }
    public Type ContextType { get; }
    public Nullable`1<TimeSpan> Delay { get; }
    public ConsumeContextRetryContext`2(RetryContext`1<TFilter> retryContext, TContext context);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual TFilter get_Context();
    public sealed virtual Exception get_Exception();
    public sealed virtual int get_RetryCount();
    public sealed virtual int get_RetryAttempt();
    public sealed virtual Type get_ContextType();
    public sealed virtual Nullable`1<TimeSpan> get_Delay();
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.ConsumeContextRetryContext`2/<PreRetry>d__17")]
public sealed virtual Task PreRetry();
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.ConsumeContextRetryContext`2/<RetryFaulted>d__18")]
public sealed virtual Task RetryFaulted(Exception exception);
    public sealed virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.ConsumeContextRetryPolicy : object {
    private CancellationToken _cancellationToken;
    private IRetryPolicy _retryPolicy;
    public ConsumeContextRetryPolicy(IRetryPolicy retryPolicy, CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class MassTransit.RetryPolicies.ConsumeContextRetryPolicy`2 : object {
    private CancellationToken _cancellationToken;
    private Func`4<TFilter, IRetryPolicy, RetryContext, TContext> _contextFactory;
    private IRetryPolicy _retryPolicy;
    public ConsumeContextRetryPolicy`2(IRetryPolicy retryPolicy, CancellationToken cancellationToken, Func`4<TFilter, IRetryPolicy, RetryContext, TContext> contextFactory);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class MassTransit.RetryPolicies.ConsumeContextRetryPolicyContext : object {
    private RetryConsumeContext _context;
    private RetryPolicyContext`1<ConsumeContext> _policyContext;
    private CancellationToken _cancellationToken;
    private CancellationTokenRegistration _registration;
    public ConsumeContext Context { get; }
    public ConsumeContextRetryPolicyContext(RetryPolicyContext`1<ConsumeContext> policyContext, RetryConsumeContext context, CancellationToken cancellationToken);
    public sealed virtual void Cancel();
    public sealed virtual ConsumeContext get_Context();
    public sealed virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    public sealed virtual Task RetryFaulted(Exception exception);
    public sealed virtual void Dispose();
}
public class MassTransit.RetryPolicies.ConsumeContextRetryPolicyContext`2 : object {
    private TContext _context;
    private RetryPolicyContext`1<TFilter> _policyContext;
    private CancellationToken _cancellationToken;
    private CancellationTokenRegistration _registration;
    public TFilter Context { get; }
    public ConsumeContextRetryPolicyContext`2(RetryPolicyContext`1<TFilter> policyContext, TContext context, CancellationToken cancellationToken);
    public sealed virtual void Cancel();
    public sealed virtual TFilter get_Context();
    public sealed virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    public sealed virtual Task RetryFaulted(Exception exception);
    public sealed virtual void Dispose();
}
public class MassTransit.RetryPolicies.ExceptionFilters.AllExceptionFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool MassTransit.IExceptionFilter.Match(Exception exception);
}
public class MassTransit.RetryPolicies.ExceptionFilters.FilterExceptionFilter`1 : object {
    private Func`2<T, bool> _filter;
    public FilterExceptionFilter`1(Func`2<T, bool> filter);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool MassTransit.IExceptionFilter.Match(Exception exception);
}
public class MassTransit.RetryPolicies.ExceptionFilters.HandleExceptionFilter : object {
    private Type[] _exceptionTypes;
    public HandleExceptionFilter(Type[] exceptionTypes);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool MassTransit.IExceptionFilter.Match(Exception exception);
}
public class MassTransit.RetryPolicies.ExceptionFilters.IgnoreExceptionFilter : object {
    private Type[] _exceptionTypes;
    public IgnoreExceptionFilter(Type[] exceptionTypes);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool MassTransit.IExceptionFilter.Match(Exception exception);
}
public class MassTransit.RetryPolicies.ExponentialRetryContext`1 : BaseRetryContext`1<TContext> {
    private ExponentialRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public ExponentialRetryContext`1(ExponentialRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool MassTransit.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.ExponentialRetryPolicy : object {
    private IExceptionFilter _filter;
    private int _highInterval;
    private TimeSpan[] _intervals;
    private int _lowInterval;
    private int _maxInterval;
    private int _minInterval;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    public int RetryLimit { get; }
    public ExponentialRetryPolicy(IExceptionFilter filter, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
    public TimeSpan GetRetryInterval(int retryCount);
    [IteratorStateMachineAttribute("MassTransit.RetryPolicies.ExponentialRetryPolicy/<CalculateIntervals>d__14")]
private IEnumerable`1<TimeSpan> CalculateIntervals();
    public virtual string ToString();
}
public class MassTransit.RetryPolicies.ExponentialRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private ExponentialRetryPolicy _policy;
    public ExponentialRetryPolicyContext`1(ExponentialRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class MassTransit.RetryPolicies.ImmediateRetryContext`1 : BaseRetryContext`1<TContext> {
    private ImmediateRetryPolicy _policy;
    public ImmediateRetryContext`1(ImmediateRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    private sealed virtual override bool MassTransit.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.ImmediateRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    public int RetryLimit { get; }
    public ImmediateRetryPolicy(IExceptionFilter filter, int retryLimit);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class MassTransit.RetryPolicies.ImmediateRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private ImmediateRetryPolicy _policy;
    public ImmediateRetryPolicyContext`1(ImmediateRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class MassTransit.RetryPolicies.IncrementalRetryContext`1 : BaseRetryContext`1<TContext> {
    private TimeSpan _delay;
    private TimeSpan _delayIncrement;
    private IncrementalRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public IncrementalRetryContext`1(IncrementalRetryPolicy policy, TContext context, Exception exception, int retryCount, TimeSpan delay, TimeSpan delayIncrement, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool MassTransit.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.IncrementalRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InitialInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IntervalIncrement>k__BackingField;
    public int RetryLimit { get; }
    public TimeSpan InitialInterval { get; }
    public TimeSpan IntervalIncrement { get; }
    public IncrementalRetryPolicy(IExceptionFilter filter, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    [CompilerGeneratedAttribute]
public TimeSpan get_InitialInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_IntervalIncrement();
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class MassTransit.RetryPolicies.IncrementalRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private IncrementalRetryPolicy _policy;
    public IncrementalRetryPolicyContext`1(IncrementalRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class MassTransit.RetryPolicies.IntervalRetryContext`1 : BaseRetryContext`1<TContext> {
    private IntervalRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public IntervalRetryContext`1(IntervalRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool MassTransit.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.IntervalRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private TimeSpan[] <Intervals>k__BackingField;
    public TimeSpan[] Intervals { get; }
    public IntervalRetryPolicy(IExceptionFilter filter, TimeSpan[] intervals);
    public IntervalRetryPolicy(IExceptionFilter filter, Int32[] intervals);
    [CompilerGeneratedAttribute]
public TimeSpan[] get_Intervals();
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
    public virtual string ToString();
}
public class MassTransit.RetryPolicies.IntervalRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private IntervalRetryPolicy _policy;
    public IntervalRetryPolicyContext`1(IntervalRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.RetryPolicies.MessageRetryPolicyExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.MessageRetryPolicyExtensions/<Retry>d__0`1")]
[ExtensionAttribute]
public static Task Retry(IRetryPolicy retryPolicy, ConsumeContext`1<T> context, Func`2<ConsumeContext`1<T>, Task> retryMethod);
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.MessageRetryPolicyExtensions/<Attempt>d__1`1")]
private static Task Attempt(RetryContext`1<ConsumeContext`1<T>> retryContext, Func`2<ConsumeContext`1<T>, Task> retryMethod);
}
public class MassTransit.RetryPolicies.NoRetryContext`1 : BaseRetryContext`1<TContext> {
    public NoRetryContext`1(TContext context, Exception exception, CancellationToken cancellationToken);
    private sealed virtual override bool MassTransit.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class MassTransit.RetryPolicies.NoRetryPolicy : object {
    private IExceptionFilter _filter;
    public NoRetryPolicy(IExceptionFilter filter);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> MassTransit.IRetryPolicy.CreatePolicyContext(T context);
    private sealed virtual override bool MassTransit.IRetryPolicy.IsHandled(Exception exception);
    public virtual string ToString();
}
public class MassTransit.RetryPolicies.NoRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    public NoRetryPolicyContext`1(IRetryPolicy policy, TContext context);
    public virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.RetryPolicies.PipeRetryExtensions : object {
    [ExtensionAttribute]
public static Task Retry(IRetryPolicy retryPolicy, Func`1<Task> retryMethod, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.PipeRetryExtensions/<Retry>d__1")]
[ExtensionAttribute]
public static Task Retry(IRetryPolicy retryPolicy, Func`1<Task> retryMethod, bool log, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> Retry(IRetryPolicy retryPolicy, Func`1<Task`1<T>> retryMethod, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.PipeRetryExtensions/<Retry>d__3`1")]
[ExtensionAttribute]
public static Task`1<T> Retry(IRetryPolicy retryPolicy, Func`1<Task`1<T>> retryMethod, bool log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.PipeRetryExtensions/<Attempt>d__4`1")]
private static Task Attempt(T context, RetryContext`1<T> retryContext, Func`1<Task> retryMethod, bool log);
    [AsyncStateMachineAttribute("MassTransit.RetryPolicies.PipeRetryExtensions/<Attempt>d__5`2")]
private static Task`1<TResult> Attempt(T context, RetryContext`1<T> retryContext, Func`1<Task`1<TResult>> retryMethod, bool log);
}
public class MassTransit.RetryPolicies.RedeliveryRetryConsumeContext`1 : RetryConsumeContext`1<T> {
    public RedeliveryRetryConsumeContext`1(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    public virtual TContext CreateNext(RetryContext retryContext);
}
public class MassTransit.RetryPolicies.RetryConsumeContext : ConsumeContextScope {
    private ConsumeContext _context;
    private PendingFaultCollection _pendingFaults;
    [CompilerGeneratedAttribute]
private IRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    protected IRetryPolicy RetryPolicy { get; }
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public RetryConsumeContext(ConsumeContext context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [CompilerGeneratedAttribute]
protected IRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryCount();
    public virtual TContext CreateNext(RetryContext retryContext);
    public sealed virtual Task NotifyPendingFaults();
    public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public RetryConsumeContext CreateNext(RetryContext retryContext);
}
public class MassTransit.RetryPolicies.RetryConsumeContext`1 : RetryConsumeContext {
    private ConsumeContext`1<T> _context;
    private T MassTransit.ConsumeContext<T>.Message { get; }
    public RetryConsumeContext`1(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    private sealed virtual override T MassTransit.ConsumeContext<T>.get_Message();
    public sealed virtual Task NotifyConsumed(TimeSpan duration, string consumerType);
    public sealed virtual Task NotifyFaulted(TimeSpan duration, string consumerType, Exception exception);
    public virtual TContext CreateNext(RetryContext retryContext);
}
public class MassTransit.RetryPolicies.RetryConsumerConsumeContext`1 : RetryConsumeContext {
    private ConsumerConsumeContext`1<TConsumer> _context;
    public TConsumer Consumer { get; }
    public RetryConsumerConsumeContext`1(ConsumerConsumeContext`1<TConsumer> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    public sealed virtual TConsumer get_Consumer();
    public virtual TContext CreateNext(RetryContext retryContext);
}
public class MassTransit.RetryPolicies.RetrySagaConsumeContext`1 : RetryConsumeContext {
    private SagaConsumeContext`1<TSaga> _context;
    public TSaga Saga { get; }
    public bool IsCompleted { get; }
    public RetrySagaConsumeContext`1(SagaConsumeContext`1<TSaga> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    public sealed virtual TSaga get_Saga();
    private sealed virtual override Task MassTransit.SagaConsumeContext<TSaga>.SetCompleted();
    public sealed virtual bool get_IsCompleted();
    public virtual TContext CreateNext(RetryContext retryContext);
}
[ExtensionAttribute]
public static class MassTransit.RoutingKeyConventionExtensions : object {
    [ExtensionAttribute]
public static void UseRoutingKeyFormatter(IMessageSendTopologyConfigurator`1<T> configurator, IMessageRoutingKeyFormatter`1<T> formatter);
    [ExtensionAttribute]
public static void UseRoutingKeyFormatter(ISendTopologyConfigurator configurator, IMessageRoutingKeyFormatter`1<T> formatter);
    [ExtensionAttribute]
public static void UseRoutingKeyFormatter(ISendTopologyConfigurator configurator, Func`2<SendContext`1<T>, string> formatter);
    [ExtensionAttribute]
public static void UseRoutingKeyFormatter(IMessageSendTopologyConfigurator`1<T> configurator, Func`2<SendContext`1<T>, string> formatter);
}
public class MassTransit.RoutingSlipBuilder : object {
    public static IDictionary`2<string, object> NoArguments;
    private List`1<ActivityException> _activityExceptions;
    private List`1<ActivityLog> _activityLogs;
    private List`1<CompensateLog> _compensateLogs;
    private DateTime _createTimestamp;
    private List`1<Activity> _itinerary;
    private List`1<Activity> _sourceItinerary;
    private List`1<Subscription> _subscriptions;
    private IDictionary`2<string, object> _variables;
    [CompilerGeneratedAttribute]
private Guid <TrackingNumber>k__BackingField;
    public IList`1<Activity> SourceItinerary { get; }
    public Guid TrackingNumber { get; }
    public RoutingSlipBuilder(Guid trackingNumber);
    public RoutingSlipBuilder(RoutingSlip routingSlip, Func`2<IEnumerable`1<Activity>, IEnumerable`1<Activity>> activitySelector);
    public RoutingSlipBuilder(RoutingSlip routingSlip, IEnumerable`1<Activity> itinerary, IEnumerable`1<Activity> sourceItinerary);
    public RoutingSlipBuilder(RoutingSlip routingSlip, IEnumerable`1<CompensateLog> compensateLogs);
    private static RoutingSlipBuilder();
    public IList`1<Activity> get_SourceItinerary();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_TrackingNumber();
    public sealed virtual void AddActivity(string name, Uri executeAddress);
    public sealed virtual void AddActivity(string name, Uri executeAddress, object arguments);
    public sealed virtual void AddActivity(string name, Uri executeAddress, IDictionary`2<string, object> arguments);
    public sealed virtual void AddVariable(string key, string value);
    public sealed virtual void AddVariable(string key, object value);
    public sealed virtual void SetVariables(object values);
    public sealed virtual void SetVariables(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public sealed virtual int AddActivitiesFromSourceItinerary();
    public sealed virtual void AddSubscription(Uri address, RoutingSlipEvents events);
    public sealed virtual void AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents);
    public sealed virtual void AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents, string activityName);
    public sealed virtual Task AddSubscription(Uri address, RoutingSlipEvents events, Func`2<ISendEndpoint, Task> callback);
    public sealed virtual Task AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents, Func`2<ISendEndpoint, Task> callback);
    public sealed virtual Task AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents, string activityName, Func`2<ISendEndpoint, Task> callback);
    public sealed virtual RoutingSlip Build();
    private sealed virtual override void MassTransit.Courier.IRoutingSlipSendEndpointTarget.AddSubscription(Uri address, RoutingSlipEvents events, RoutingSlipEventContents contents, string activityName, MessageEnvelope message);
    public void AddActivityLog(HostInfo host, string name, Guid activityTrackingNumber, DateTime timestamp, TimeSpan duration);
    public void AddCompensateLog(Guid activityTrackingNumber, Uri compensateAddress, object logObject);
    public void AddCompensateLog(Guid activityTrackingNumber, Uri compensateAddress, IDictionary`2<string, object> data);
    public void AddActivityException(HostInfo host, string name, Guid activityTrackingNumber, DateTime timestamp, TimeSpan elapsed, Exception exception);
    public void AddActivityException(HostInfo host, string name, Guid activityTrackingNumber, DateTime timestamp, TimeSpan elapsed, ExceptionInfo exceptionInfo);
    public void AddActivityException(ActivityException activityException);
    private void SetVariablesFromDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public static IDictionary`2<string, object> GetObjectAsDictionary(object values);
}
[ExtensionAttribute]
public static class MassTransit.RoutingSlipEventExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlip> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlip> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetResult(ConsumeContext`1<RoutingSlipActivityCompensated> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetResult(ConsumeContext`1<RoutingSlipActivityCompensated> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipActivityCompensated> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipActivityCompensated> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetResult(ConsumeContext`1<RoutingSlipActivityCompensationFailed> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetResult(ConsumeContext`1<RoutingSlipActivityCompensationFailed> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipActivityCompensationFailed> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipActivityCompensationFailed> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetArgument(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetArgument(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetResult(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetResult(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipActivityCompleted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetArgument(ConsumeContext`1<RoutingSlipActivityFaulted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetArgument(ConsumeContext`1<RoutingSlipActivityFaulted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipActivityFaulted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipActivityFaulted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipCompensationFailed> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipCompensationFailed> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipCompleted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipCompleted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipFaulted> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipFaulted> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetVariable(ConsumeContext`1<RoutingSlipTerminated> context, string key, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> GetVariable(ConsumeContext`1<RoutingSlipTerminated> context, string key, Nullable`1<T> defaultValue);
    [NullableContextAttribute("1")]
private static T GetDictionaryValue(IObjectDeserializer context, IDictionary`2<string, object> arguments, IDictionary`2<string, object> variables, string key, T defaultValue);
    private static Nullable`1<T> GetDictionaryValue(IObjectDeserializer context, IDictionary`2<string, object> arguments, IDictionary`2<string, object> variables, string key, Nullable`1<T> defaultValue);
}
public class MassTransit.Saga.AnyExistingSagaPolicy`2 : object {
    private IPipe`1<ConsumeContext`1<TMessage>> _missingPipe;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public bool IsReadOnly { get; }
    public AnyExistingSagaPolicy`2(IPipe`1<ConsumeContext`1<TMessage>> missingPipe, bool readOnly);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool PreInsertInstance(ConsumeContext`1<TMessage> context, TSaga& instance);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Existing(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Missing(ConsumeContext`1<TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Saga.DefaultSagaRepositoryQueryContext`1 : ProxyPipeContext {
    private QuerySagaRepositoryContext`1<TSaga> _queryContext;
    private IList`1<Guid> _results;
    public int Count { get; }
    public DefaultSagaRepositoryQueryContext`1(QuerySagaRepositoryContext`1<TSaga> queryContext, IList`1<Guid> results);
    public sealed virtual int get_Count();
    public sealed virtual Task`1<SagaRepositoryQueryContext`1<TSaga>> Query(ISagaQuery`1<TSaga> query, CancellationToken cancellationToken);
    public sealed virtual IEnumerator`1<Guid> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MassTransit.Saga.DefaultSagaRepositoryQueryContext`2 : ConsumeContextProxy`1<TMessage> {
    private SagaRepositoryContext`2<TSaga, TMessage> _context;
    private IList`1<Guid> _results;
    public int Count { get; }
    public DefaultSagaRepositoryQueryContext`2(SagaRepositoryContext`2<TSaga, TMessage> context, IList`1<Guid> results);
    public sealed virtual int get_Count();
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Add(TSaga instance);
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Insert(TSaga instance);
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Load(Guid correlationId);
    public sealed virtual Task Save(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Discard(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Undo(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Update(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Delete(SagaConsumeContext`1<TSaga> context);
    public sealed virtual IEnumerator`1<Guid> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public class MassTransit.Saga.ExpressionSagaQueryFactory`2 : object {
    private Expression`1<Func`3<TSaga, TMessage, bool>> _filterExpression;
    public ExpressionSagaQueryFactory`2(Expression`1<Func`3<TSaga, TMessage, bool>> filterExpression);
    private sealed virtual override bool MassTransit.ISagaQueryFactory<TSaga,TMessage>.TryCreateQuery(ConsumeContext`1<TMessage> context, ISagaQuery`1& query);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Saga.FactoryMethodSagaFactory`2 : object {
    private SagaFactoryMethod`2<TSaga, TMessage> _factoryMethod;
    public FactoryMethodSagaFactory`2(SagaFactoryMethod`2<TSaga, TMessage> factoryMethod);
    public sealed virtual TSaga Create(ConsumeContext`1<TMessage> context);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
[DefaultMemberAttribute("Item")]
public interface MassTransit.Saga.IIndexedSagaProperty`1 {
    public SagaInstance`1<TSaga> Item { get; }
    public int Count { get; }
    public abstract virtual SagaInstance`1<TSaga> get_Item(object key);
    public abstract virtual int get_Count();
    public abstract virtual void Add(SagaInstance`1<TSaga> newItem);
    public abstract virtual void Remove(SagaInstance`1<TSaga> item);
    public abstract virtual IEnumerable`1<SagaInstance`1<TSaga>> Where(Func`2<TSaga, bool> filter);
    public abstract virtual IEnumerable`1<SagaInstance`1<TSaga>> Where(object key, Func`2<TSaga, bool> filter);
    public abstract virtual IEnumerable`1<TResult> Select(Func`2<TSaga, TResult> transformer);
}
public interface MassTransit.Saga.ILoadSagaRepositoryContextFactory`1 {
    public abstract virtual Task`1<T> Execute(Func`2<LoadSagaRepositoryContext`1<TSaga>, Task`1<T>> asyncMethod, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Saga.IndexedSagaDictionary`1 : object {
    private IIndexedSagaProperty`1<TSaga> _indexById;
    private Dictionary`2<string, IIndexedSagaProperty`1<TSaga>> _indices;
    private SemaphoreSlim _inUse;
    private object _lock;
    public SagaInstance`1<TSaga> Item { get; }
    public int Count { get; }
    public SagaInstance`1<TSaga> get_Item(Guid sagaId);
    public int get_Count();
    public Task MarkInUse(CancellationToken cancellationToken);
    public void Release();
    public void Add(SagaInstance`1<TSaga> instance);
    public void Remove(SagaInstance`1<TSaga> item);
    public IEnumerable`1<SagaInstance`1<TSaga>> Where(ISagaQuery`1<TSaga> query);
    public IEnumerable`1<TResult> Select(Func`2<TSaga, TResult> transformer);
    private IIndexedSagaProperty`1<TSaga> HasIndexFor(Expression`1<Func`2<TSaga, bool>> expression);
    private void BuildIndices();
    private static object GetRightValue(Expression`1<Func`2<TSaga, bool>> right);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Saga.IndexedSagaProperty`2 : object {
    private Func`2<TSaga, TProperty> _getProperty;
    private IDictionary`2<TProperty, HashSet`1<SagaInstance`1<TSaga>>> _values;
    public int Count { get; }
    public SagaInstance`1<TSaga> Item { get; }
    public IndexedSagaProperty`2(PropertyInfo propertyInfo);
    public sealed virtual int get_Count();
    public sealed virtual SagaInstance`1<TSaga> get_Item(object key);
    public sealed virtual void Add(SagaInstance`1<TSaga> newItem);
    public sealed virtual void Remove(SagaInstance`1<TSaga> instance);
    public sealed virtual IEnumerable`1<SagaInstance`1<TSaga>> Where(Func`2<TSaga, bool> filter);
    public sealed virtual IEnumerable`1<SagaInstance`1<TSaga>> Where(object key, Func`2<TSaga, bool> filter);
    public sealed virtual IEnumerable`1<TResult> Select(Func`2<TSaga, TResult> transformer);
    private static Func`2<TSaga, TProperty> GetGetMethod(PropertyInfo property);
}
public class MassTransit.Saga.InMemorySagaConsumeContext`2 : DefaultSagaConsumeContext`2<TSaga, TMessage> {
    private SagaInstance`1<TSaga> _saga;
    public InMemorySagaConsumeContext`2(ConsumeContext`1<TMessage> context, SagaInstance`1<TSaga> saga);
    public sealed virtual void Dispose();
}
public class MassTransit.Saga.InMemorySagaConsumeContextFactory`1 : object {
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaConsumeContextFactory`1/<CreateSagaConsumeContext>d__0`1")]
public sealed virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(IndexedSagaDictionary`1<TSaga> context, ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public class MassTransit.Saga.InMemorySagaRepositoryContext`1 : BasePipeContext {
    private IndexedSagaDictionary`1<TSaga> _sagas;
    public InMemorySagaRepositoryContext`1(IndexedSagaDictionary`1<TSaga> sagas, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`1/<Load>d__2")]
public sealed virtual Task`1<TSaga> Load(Guid correlationId);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`1/<Query>d__3")]
public sealed virtual Task`1<SagaRepositoryQueryContext`1<TSaga>> Query(ISagaQuery`1<TSaga> query, CancellationToken cancellationToken);
}
public class MassTransit.Saga.InMemorySagaRepositoryContext`2 : ConsumeContextScope`1<TMessage> {
    private ConsumeContext`1<TMessage> _context;
    private ISagaConsumeContextFactory`2<IndexedSagaDictionary`1<TSaga>, TSaga> _factory;
    private IndexedSagaDictionary`1<TSaga> _sagas;
    private bool _sagasLocked;
    public InMemorySagaRepositoryContext`2(IndexedSagaDictionary`1<TSaga> sagas, ISagaConsumeContextFactory`2<IndexedSagaDictionary`1<TSaga>, TSaga> factory, ConsumeContext`1<TMessage> context);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`2/<Add>d__6")]
public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Add(TSaga instance);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`2/<Insert>d__7")]
public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Insert(TSaga instance);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`2/<Load>d__8")]
public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Load(Guid correlationId);
    public sealed virtual Task Save(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Update(SagaConsumeContext`1<TSaga> context);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContext`2/<Delete>d__11")]
public sealed virtual Task Delete(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Discard(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Undo(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public class MassTransit.Saga.InMemorySagaRepositoryContextFactory`1 : object {
    private ISagaConsumeContextFactory`2<IndexedSagaDictionary`1<TSaga>, TSaga> _factory;
    private IndexedSagaDictionary`1<TSaga> _sagas;
    public InMemorySagaRepositoryContextFactory`1(IndexedSagaDictionary`1<TSaga> sagas, ISagaConsumeContextFactory`2<IndexedSagaDictionary`1<TSaga>, TSaga> factory);
    public sealed virtual Task`1<T> Execute(Func`2<LoadSagaRepositoryContext`1<TSaga>, Task`1<T>> asyncMethod, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> Execute(Func`2<QuerySagaRepositoryContext`1<TSaga>, Task`1<T>> asyncMethod, CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContextFactory`1/<Send>d__6`1")]
public sealed virtual Task Send(ConsumeContext`1<T> context, IPipe`1<SagaRepositoryContext`2<TSaga, T>> next);
    [AsyncStateMachineAttribute("MassTransit.Saga.InMemorySagaRepositoryContextFactory`1/<SendQuery>d__7`1")]
public sealed virtual Task SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, IPipe`1<SagaRepositoryQueryContext`2<TSaga, T>> next);
    private Task`1<T> ExecuteAsyncMethod(Func`2<InMemorySagaRepositoryContext`1<TSaga>, Task`1<T>> asyncMethod, CancellationToken cancellationToken);
}
public interface MassTransit.Saga.IQuerySagaRepositoryContextFactory`1 {
    public abstract virtual Task`1<T> Execute(Func`2<QuerySagaRepositoryContext`1<TSaga>, Task`1<T>> asyncMethod, CancellationToken cancellationToken);
}
public interface MassTransit.Saga.ISagaConsumeContextFactory`1 {
    public abstract virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public interface MassTransit.Saga.ISagaConsumeContextFactory`2 {
    public abstract virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(TContext context, ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public interface MassTransit.Saga.ISagaRepositoryContextFactory`1 {
    public abstract virtual Task Send(ConsumeContext`1<T> context, IPipe`1<SagaRepositoryContext`2<TSaga, T>> next);
    public abstract virtual Task SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, IPipe`1<SagaRepositoryQueryContext`2<TSaga, T>> next);
}
public class MassTransit.Saga.LoadedSagaRepositoryQueryContext`1 : BasePipeContext {
    private IDictionary`2<Guid, TSaga> _index;
    private QuerySagaRepositoryContext`1<TSaga> _querySagaRepositoryContext;
    public int Count { get; }
    public LoadedSagaRepositoryQueryContext`1(QuerySagaRepositoryContext`1<TSaga> querySagaRepositoryContext, IEnumerable`1<TSaga> instances);
    public sealed virtual int get_Count();
    public sealed virtual Task`1<SagaRepositoryQueryContext`1<TSaga>> Query(ISagaQuery`1<TSaga> query, CancellationToken cancellationToken);
    public sealed virtual IEnumerator`1<Guid> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MassTransit.Saga.LoadedSagaRepositoryQueryContext`2 : ConsumeContextProxy`1<TMessage> {
    private IDictionary`2<Guid, TSaga> _index;
    private SagaRepositoryContext`2<TSaga, TMessage> _repositoryContext;
    public int Count { get; }
    public LoadedSagaRepositoryQueryContext`2(SagaRepositoryContext`2<TSaga, TMessage> repositoryContext, IEnumerable`1<TSaga> instances);
    public sealed virtual int get_Count();
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Add(TSaga instance);
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Insert(TSaga instance);
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Load(Guid correlationId);
    public sealed virtual Task Save(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Discard(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Undo(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Update(SagaConsumeContext`1<TSaga> context);
    public sealed virtual Task Delete(SagaConsumeContext`1<TSaga> context);
    public sealed virtual IEnumerator`1<Guid> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public class MassTransit.Saga.LoadSagaRepository`1 : object {
    private ILoadSagaRepositoryContextFactory`1<TSaga> _repositoryContextFactory;
    public LoadSagaRepository`1(ILoadSagaRepositoryContextFactory`1<TSaga> repositoryContextFactory);
    public sealed virtual Task`1<TSaga> Load(Guid correlationId);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.Saga.LoadSagaRepositoryContext`1 {
    public abstract virtual Task`1<TSaga> Load(Guid correlationId);
}
public class MassTransit.Saga.NewOrExistingSagaPolicy`2 : object {
    private bool _insertOnInitial;
    private ISagaFactory`2<TSaga, TMessage> _sagaFactory;
    public bool IsReadOnly { get; }
    public NewOrExistingSagaPolicy`2(ISagaFactory`2<TSaga, TMessage> sagaFactory, bool insertOnInitial);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool PreInsertInstance(ConsumeContext`1<TMessage> context, TSaga& instance);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Existing(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Missing(ConsumeContext`1<TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Saga.NewSagaPolicy`2 : object {
    private bool _insertOnInitial;
    private ISagaFactory`2<TSaga, TMessage> _sagaFactory;
    public bool IsReadOnly { get; }
    public NewSagaPolicy`2(ISagaFactory`2<TSaga, TMessage> sagaFactory, bool insertOnInitial);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool PreInsertInstance(ConsumeContext`1<TMessage> context, TSaga& instance);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Existing(SagaConsumeContext`2<TSaga, TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
    private sealed virtual override Task MassTransit.ISagaPolicy<TSaga,TMessage>.Missing(ConsumeContext`1<TMessage> context, IPipe`1<SagaConsumeContext`2<TSaga, TMessage>> next);
}
public class MassTransit.Saga.PropertyExpressionSagaQueryFactory`3 : object {
    private Expression`1<Func`2<TInstance, TProperty>> _propertyExpression;
    private ISagaQueryPropertySelector`2<TData, TProperty> _selector;
    public PropertyExpressionSagaQueryFactory`3(Expression`1<Func`2<TInstance, TProperty>> propertyExpression, ISagaQueryPropertySelector`2<TData, TProperty> selector);
    private sealed virtual override bool MassTransit.ISagaQueryFactory<TInstance,TData>.TryCreateQuery(ConsumeContext`1<TData> context, ISagaQuery`1& query);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private Expression`1<Func`2<TInstance, bool>> CreateExpression(TProperty propertyValue);
}
public class MassTransit.Saga.QuerySagaRepository`1 : object {
    private IQuerySagaRepositoryContextFactory`1<TSaga> _repositoryContextFactory;
    public QuerySagaRepository`1(IQuerySagaRepositoryContextFactory`1<TSaga> repositoryContextFactory);
    public sealed virtual Task`1<IEnumerable`1<Guid>> Find(ISagaQuery`1<TSaga> query);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.Saga.QuerySagaRepositoryContext`1 {
    public abstract virtual Task`1<SagaRepositoryQueryContext`1<TSaga>> Query(ISagaQuery`1<TSaga> query, CancellationToken cancellationToken);
}
public class MassTransit.Saga.SagaConsumeContextFactory`2 : object {
    public sealed virtual Task`1<SagaConsumeContext`2<TSaga, T>> CreateSagaConsumeContext(TContext context, ConsumeContext`1<T> consumeContext, TSaga instance, SagaConsumeContextMode mode);
}
public enum MassTransit.Saga.SagaConsumeContextMode : Enum {
    public int value__;
    public static SagaConsumeContextMode Load;
    public static SagaConsumeContextMode Add;
    public static SagaConsumeContextMode Insert;
}
public class MassTransit.Saga.SagaFilterExpressionConverter`2 : ExpressionVisitor {
    private TMessage _message;
    public SagaFilterExpressionConverter`2(TMessage message);
    public Expression`1<Func`2<TSaga, bool>> Convert(Expression`1<Func`3<TSaga, TMessage, bool>> expression);
    protected virtual Expression VisitMember(MemberExpression m);
    private static Expression`1<Func`2<TSaga, bool>> RemoveMessageParameter(LambdaExpression lambda);
    private Expression EvaluateMemberAccess(MemberExpression exp);
}
public class MassTransit.Saga.SagaInstance`1 : object {
    private SemaphoreSlim _inUse;
    [CompilerGeneratedAttribute]
private TSaga <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemoved>k__BackingField;
    public TSaga Instance { get; }
    public bool IsRemoved { get; public set; }
    public SagaInstance`1(TSaga instance);
    [CompilerGeneratedAttribute]
public TSaga get_Instance();
    [CompilerGeneratedAttribute]
public bool get_IsRemoved();
    [CompilerGeneratedAttribute]
public void set_IsRemoved(bool value);
    public sealed virtual bool Equals(SagaInstance`1<TSaga> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Task MarkInUse(CancellationToken cancellationToken);
    public void Release();
    public void Remove();
}
public class MassTransit.Saga.SagaInstanceFactoryMethod`1 : MulticastDelegate {
    public SagaInstanceFactoryMethod`1(object object, IntPtr method);
    public virtual TSaga Invoke(Guid correlationId);
    public virtual IAsyncResult BeginInvoke(Guid correlationId, AsyncCallback callback, object object);
    public virtual TSaga EndInvoke(IAsyncResult result);
}
public class MassTransit.Saga.SagaQuery`1 : object {
    private Lazy`1<Func`2<TSaga, bool>> _filter;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TSaga, bool>> <FilterExpression>k__BackingField;
    public Expression`1<Func`2<TSaga, bool>> FilterExpression { get; }
    public SagaQuery`1(Expression`1<Func`2<TSaga, bool>> filterExpression);
    public sealed virtual Func`2<TSaga, bool> GetFilter();
    [CompilerGeneratedAttribute]
public sealed virtual Expression`1<Func`2<TSaga, bool>> get_FilterExpression();
}
public class MassTransit.Saga.SagaRepository`1 : object {
    private ILoadSagaRepository`1<TSaga> _loadSagaRepository;
    private QuerySagaRepository`1<TSaga> _querySagaRepository;
    private ISagaRepositoryContextFactory`1<TSaga> _repositoryContextFactory;
    public SagaRepository`1(ISagaRepositoryContextFactory`1<TSaga> repositoryContextFactory, IQuerySagaRepositoryContextFactory`1<TSaga> queryRepositoryContextFactory, ILoadSagaRepositoryContextFactory`1<TSaga> loadSagaRepositoryContextFactory);
    public sealed virtual Task`1<TSaga> Load(Guid correlationId);
    public sealed virtual Task`1<IEnumerable`1<Guid>> Find(ISagaQuery`1<TSaga> query);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Send(ConsumeContext`1<T> context, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
    public sealed virtual Task SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
}
public interface MassTransit.Saga.SagaRepositoryContext`2 {
    public abstract virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Add(TSaga instance);
    public abstract virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Insert(TSaga instance);
    public abstract virtual Task`1<SagaConsumeContext`2<TSaga, TMessage>> Load(Guid correlationId);
    public abstract virtual Task Save(SagaConsumeContext`1<TSaga> context);
    public abstract virtual Task Update(SagaConsumeContext`1<TSaga> context);
    public abstract virtual Task Delete(SagaConsumeContext`1<TSaga> context);
    public abstract virtual Task Discard(SagaConsumeContext`1<TSaga> context);
    public abstract virtual Task Undo(SagaConsumeContext`1<TSaga> context);
}
public interface MassTransit.Saga.SagaRepositoryQueryContext`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public interface MassTransit.Saga.SagaRepositoryQueryContext`2 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public class MassTransit.Saga.StateExpressionVisitor`1 : ExpressionVisitor {
    private Expression _expressionBody;
    private ParameterExpression _instanceParameter;
    public StateExpressionVisitor`1(Expression`1<Func`2<TInstance, bool>> expression);
    private Expression`1<Func`2<TInstance, bool>> Combine(Expression`1<Func`2<TInstance, bool>> stateExpression, bool not);
    protected virtual Expression VisitParameter(ParameterExpression node);
    public static Expression`1<Func`2<TInstance, bool>> Combine(Expression`1<Func`2<TInstance, bool>> expression, Expression`1<Func`2<TInstance, bool>> stateExpression);
}
[ExtensionAttribute]
public static class MassTransit.SagaExtensions : object {
    [ExtensionAttribute]
public static void Saga(IReceiveEndpointConfigurator configurator, ISagaRepository`1<T> sagaRepository, Action`1<ISagaConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectSaga(IConsumePipeConnector connector, ISagaRepository`1<T> sagaRepository, IPipeSpecification`1[] pipeSpecifications);
}
[ExtensionAttribute]
public static class MassTransit.SagaPipeConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseFilter(IPipeConfigurator`1<SagaConsumeContext`2<TSaga, T>> configurator, IFilter`1<SagaConsumeContext`1<TSaga>> filter);
}
public class MassTransit.SagaStateMachine.ActionActivity`1 : object {
    private Action`1<BehaviorContext`1<TSaga>> _action;
    public ActionActivity`1(Action`1<BehaviorContext`1<TSaga>> action);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ActionActivity`1/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ActionActivity`1/<Execute>d__5`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ActionActivity`2 : object {
    private Action`1<BehaviorContext`2<TSaga, TMessage>> _action;
    public ActionActivity`2(Action`1<BehaviorContext`2<TSaga, TMessage>> action);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ActionActivity`2/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.ActivityBehavior`1 : object {
    private IStateMachineActivity`1<TSaga> _activity;
    private IBehavior`1<TSaga> _next;
    public ActivityBehavior`1(IStateMachineActivity`1<TSaga> activity, IBehavior`1<TSaga> next);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ActivityBehavior`1/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ActivityBehavior`1/<Execute>d__6`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
public class MassTransit.SagaStateMachine.ActivityBehaviorBuilder`1 : object {
    private List`1<IStateMachineActivity`1<TSaga>> _activities;
    private Lazy`1<IBehavior`1<TSaga>> _behavior;
    public IBehavior`1<TSaga> Behavior { get; }
    public IBehavior`1<TSaga> get_Behavior();
    public sealed virtual void Add(IStateMachineActivity`1<TSaga> activity);
    private IBehavior`1<TSaga> CreateBehavior();
}
public class MassTransit.SagaStateMachine.AllStateEventFilter`1 : object {
    public sealed virtual bool Filter(BehaviorContext`1<TSaga> context);
    public sealed virtual bool Filter(BehaviorContext`2<TSaga, T> context);
}
public class MassTransit.SagaStateMachine.AsyncActivity`1 : object {
    private Func`2<BehaviorContext`1<TSaga>, Task> _asyncAction;
    public AsyncActivity`1(Func`2<BehaviorContext`1<TSaga>, Task> asyncAction);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncActivity`1/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncActivity`1/<Execute>d__5`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.AsyncActivity`2 : object {
    private Func`2<BehaviorContext`2<TInstance, TData>, Task> _asyncAction;
    public AsyncActivity`2(Func`2<BehaviorContext`2<TInstance, TData>, Task> asyncAction);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncActivity`2/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TInstance, TData> context, IBehavior`2<TInstance, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, TData, TException> context, IBehavior`2<TInstance, TData> next);
}
public class MassTransit.SagaStateMachine.AsyncFactoryActivity`1 : object {
    private Func`2<BehaviorContext`1<TSaga>, Task`1<IStateMachineActivity`1<TSaga>>> _activityFactory;
    public AsyncFactoryActivity`1(Func`2<BehaviorContext`1<TSaga>, Task`1<IStateMachineActivity`1<TSaga>>> activityFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`1/<MassTransit-IStateMachineActivity<TSaga>-Execute>d__4")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`1/<MassTransit-IStateMachineActivity<TSaga>-Execute>d__5`1")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`1/<MassTransit-IStateMachineActivity<TSaga>-Faulted>d__6`1")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`1/<MassTransit-IStateMachineActivity<TSaga>-Faulted>d__7`2")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.AsyncFactoryActivity`2 : object {
    private Func`2<BehaviorContext`2<TSaga, TMessage>, Task`1<IStateMachineActivity`2<TSaga, TMessage>>> _activityFactory;
    public AsyncFactoryActivity`2(Func`2<BehaviorContext`2<TSaga, TMessage>, Task`1<IStateMachineActivity`2<TSaga, TMessage>>> activityFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`2/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFactoryActivity`2/<Faulted>d__5`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.AsyncFaultedActionActivity`2 : object {
    private Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task> _asyncAction;
    public AsyncFaultedActionActivity`2(Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task> asyncAction);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFaultedActionActivity`2/<Faulted>d__6`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFaultedActionActivity`2/<Faulted>d__7`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.AsyncFaultedActionActivity`3 : object {
    private Func`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, Task> _asyncAction;
    public AsyncFaultedActionActivity`3(Func`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, Task> asyncAction);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.AsyncFaultedActionActivity`3/<Faulted>d__5`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, T> context, IBehavior`2<TSaga, TMessage> next);
}
public static class MassTransit.SagaStateMachine.Behavior : object {
    public static IBehavior`1<TSaga> Empty();
    public static IBehavior`2<TSaga, TMessage> Empty();
    public static IBehavior`1<TSaga> Faulted();
    public static IBehavior`2<TSaga, TMessage> Faulted();
}
public class MassTransit.SagaStateMachine.CancelRequestTimeoutActivity`4 : object {
    private Request`3<TSaga, TRequest, TResponse> _request;
    public CancelRequestTimeoutActivity`4(Request`3<TSaga, TRequest, TResponse> request);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CancelRequestTimeoutActivity`4/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.CatchActivityBinder`2 : object {
    private EventActivities`1<TInstance> _activities;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public CatchActivityBinder`2(Event event, EventActivities`1<TInstance> activities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.CatchBehaviorBuilder`1 : object {
    private List`1<IStateMachineActivity`1<TSaga>> _activities;
    private Lazy`1<IBehavior`1<TSaga>> _behavior;
    public IBehavior`1<TSaga> Behavior { get; }
    public IBehavior`1<TSaga> get_Behavior();
    public sealed virtual void Add(IStateMachineActivity`1<TSaga> activity);
    private IBehavior`1<TSaga> CreateBehavior();
}
public class MassTransit.SagaStateMachine.CatchExceptionActivityBinder`2 : object {
    private IActivityBinder`1[] _activities;
    private StateMachine`1<TInstance> _machine;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public StateMachine`1<TInstance> StateMachine { get; }
    public CatchExceptionActivityBinder`2(StateMachine`1<TInstance> machine, Event event);
    private CatchExceptionActivityBinder`2(StateMachine`1<TInstance> machine, Event event, IActivityBinder`1[] activities, IActivityBinder`1[] appendActivity);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual IEnumerable`1<IActivityBinder`1<TInstance>> GetStateActivityBinders();
    public sealed virtual StateMachine`1<TInstance> get_StateMachine();
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> Add(IStateMachineActivity`1<TInstance> activity);
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> Catch(Func`2<ExceptionActivityBinder`2<TInstance, T>, ExceptionActivityBinder`2<TInstance, T>> activityCallback);
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> If(StateMachineExceptionCondition`2<TInstance, TException> condition, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> activityCallback);
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> IfAsync(StateMachineAsyncExceptionCondition`2<TInstance, TException> condition, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> activityCallback);
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> IfElse(StateMachineExceptionCondition`2<TInstance, TException> condition, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> elseActivityCallback);
    public sealed virtual ExceptionActivityBinder`2<TInstance, TException> IfElseAsync(StateMachineAsyncExceptionCondition`2<TInstance, TException> condition, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> elseActivityCallback);
    private ExceptionActivityBinder`2<TInstance, TException> GetBinder(Func`2<ExceptionActivityBinder`2<TInstance, TException>, ExceptionActivityBinder`2<TInstance, TException>> callback);
}
public class MassTransit.SagaStateMachine.CatchExceptionActivityBinder`3 : object {
    private IActivityBinder`1[] _activities;
    private StateMachine`1<TInstance> _machine;
    [CompilerGeneratedAttribute]
private Event`1<TData> <Event>k__BackingField;
    public Event`1<TData> Event { get; }
    public StateMachine`1<TInstance> StateMachine { get; }
    public CatchExceptionActivityBinder`3(StateMachine`1<TInstance> machine, Event`1<TData> event);
    private CatchExceptionActivityBinder`3(StateMachine`1<TInstance> machine, Event`1<TData> event, IActivityBinder`1[] activities, IActivityBinder`1[] appendActivity);
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<TData> get_Event();
    public sealed virtual IEnumerable`1<IActivityBinder`1<TInstance>> GetStateActivityBinders();
    public sealed virtual StateMachine`1<TInstance> get_StateMachine();
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> Add(IStateMachineActivity`1<TInstance> activity);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> Add(IStateMachineActivity`2<TInstance, TData> activity);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> Catch(Func`2<ExceptionActivityBinder`3<TInstance, TData, T>, ExceptionActivityBinder`3<TInstance, TData, T>> activityCallback);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> If(StateMachineExceptionCondition`3<TInstance, TData, TException> condition, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> activityCallback);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> IfAsync(StateMachineAsyncExceptionCondition`3<TInstance, TData, TException> condition, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> activityCallback);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> IfElse(StateMachineExceptionCondition`3<TInstance, TData, TException> condition, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> elseActivityCallback);
    public sealed virtual ExceptionActivityBinder`3<TInstance, TData, TException> IfElseAsync(StateMachineAsyncExceptionCondition`3<TInstance, TData, TException> condition, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> thenActivityCallback, Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> elseActivityCallback);
    private ExceptionActivityBinder`3<TInstance, TData, TException> GetBinder(Func`2<ExceptionActivityBinder`3<TInstance, TData, TException>, ExceptionActivityBinder`3<TInstance, TData, TException>> callback);
}
public class MassTransit.SagaStateMachine.CatchFaultActivity`2 : object {
    private IBehavior`1<TSaga> _behavior;
    public CatchFaultActivity`2(IBehavior`1<TSaga> behavior);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CatchFaultActivity`2/<Faulted>d__6`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CatchFaultActivity`2/<Faulted>d__7`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, T> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.ClearRequestActivity`4 : object {
    private Request`3<TSaga, TRequest, TResponse> _request;
    public ClearRequestActivity`4(Request`3<TSaga, TRequest, TResponse> request);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.CompleteRequestActivity : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CompleteRequestActivity/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<RequestState, RequestCompleted> context, IBehavior`2<RequestState, RequestCompleted> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<RequestState, RequestCompleted, TException> context, IBehavior`2<RequestState, RequestCompleted> next);
}
public class MassTransit.SagaStateMachine.CompositeEventActivity`1 : object {
    private ICompositeEventStatusAccessor`1<TSaga> _accessor;
    private CompositeEventStatus _complete;
    private int _flag;
    private CompositeEventOptions _options;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public CompositeEventActivity`1(ICompositeEventStatusAccessor`1<TSaga> accessor, int flag, CompositeEventStatus complete, Event event, CompositeEventOptions options);
    [CompilerGeneratedAttribute]
public Event get_Event();
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CompositeEventActivity`1/<Execute>d__10")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.CompositeEventActivity`1/<Execute>d__11`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    private Task Execute(BehaviorContext`1<TSaga> context);
    private Task RaiseCompositeEvent(BehaviorContext`1<TSaga> context);
}
public class MassTransit.SagaStateMachine.ConditionActivity`1 : object {
    private StateMachineAsyncCondition`1<TSaga> _condition;
    private IBehavior`1<TSaga> _elseBehavior;
    private IBehavior`1<TSaga> _thenBehavior;
    public ConditionActivity`1(StateMachineAsyncCondition`1<TSaga> condition, IBehavior`1<TSaga> thenBehavior, IBehavior`1<TSaga> elseBehavior);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionActivity`1/<Execute>d__6")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionActivity`1/<Execute>d__7`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ConditionActivity`2 : object {
    private StateMachineAsyncCondition`2<TSaga, TMessage> _condition;
    private IBehavior`1<TSaga> _elseBehavior;
    private IBehavior`1<TSaga> _thenBehavior;
    public ConditionActivity`2(StateMachineAsyncCondition`2<TSaga, TMessage> condition, IBehavior`1<TSaga> thenBehavior, IBehavior`1<TSaga> elseBehavior);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionActivity`2/<Execute>d__7`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ConditionalActivityBinder`1 : object {
    private StateMachineAsyncCondition`1<TSaga> _condition;
    private EventActivities`1<TSaga> _elseActivities;
    private EventActivities`1<TSaga> _thenActivities;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public ConditionalActivityBinder`1(Event event, StateMachineCondition`1<TSaga> condition, EventActivities`1<TSaga> thenActivities, EventActivities`1<TSaga> elseActivities);
    public ConditionalActivityBinder`1(Event event, StateMachineAsyncCondition`1<TSaga> condition, EventActivities`1<TSaga> thenActivities, EventActivities`1<TSaga> elseActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TSaga> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TSaga> builder);
    private static IBehavior`1<TSaga> GetBehavior(EventActivities`1<TSaga> activities);
}
public class MassTransit.SagaStateMachine.ConditionalActivityBinder`2 : object {
    private StateMachineAsyncCondition`2<TSaga, TMessage> _condition;
    private EventActivities`1<TSaga> _elseActivities;
    private EventActivities`1<TSaga> _thenActivities;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public ConditionalActivityBinder`2(Event event, StateMachineCondition`2<TSaga, TMessage> condition, EventActivities`1<TSaga> thenActivities, EventActivities`1<TSaga> elseActivities);
    public ConditionalActivityBinder`2(Event event, StateMachineAsyncCondition`2<TSaga, TMessage> condition, EventActivities`1<TSaga> thenActivities, EventActivities`1<TSaga> elseActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TSaga> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TSaga> builder);
    private static IBehavior`1<TSaga> GetBehavior(EventActivities`1<TSaga> activities);
}
public class MassTransit.SagaStateMachine.ConditionalExceptionActivityBinder`2 : object {
    private StateMachineAsyncExceptionCondition`2<TInstance, TException> _condition;
    private EventActivities`1<TInstance> _elseActivities;
    private EventActivities`1<TInstance> _thenActivities;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public ConditionalExceptionActivityBinder`2(Event event, StateMachineExceptionCondition`2<TInstance, TException> condition, EventActivities`1<TInstance> thenActivities, EventActivities`1<TInstance> elseActivities);
    public ConditionalExceptionActivityBinder`2(Event event, StateMachineAsyncExceptionCondition`2<TInstance, TException> condition, EventActivities`1<TInstance> thenActivities, EventActivities`1<TInstance> elseActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
    private static IBehavior`1<TInstance> GetBehavior(EventActivities`1<TInstance> activities);
}
public class MassTransit.SagaStateMachine.ConditionalExceptionActivityBinder`3 : object {
    private StateMachineAsyncExceptionCondition`3<TInstance, TData, TException> _condition;
    private EventActivities`1<TInstance> _elseActivities;
    private EventActivities`1<TInstance> _thenActivities;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public ConditionalExceptionActivityBinder`3(Event event, StateMachineExceptionCondition`3<TInstance, TData, TException> condition, EventActivities`1<TInstance> thenActivities, EventActivities`1<TInstance> elseActivities);
    public ConditionalExceptionActivityBinder`3(Event event, StateMachineAsyncExceptionCondition`3<TInstance, TData, TException> condition, EventActivities`1<TInstance> thenActivities, EventActivities`1<TInstance> elseActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
    private static IBehavior`1<TInstance> GetBehavior(EventActivities`1<TInstance> activities);
}
public class MassTransit.SagaStateMachine.ConditionExceptionActivity`2 : object {
    private StateMachineAsyncExceptionCondition`2<TSaga, TConditionException> _condition;
    private IBehavior`1<TSaga> _elseBehavior;
    private IBehavior`1<TSaga> _thenBehavior;
    public ConditionExceptionActivity`2(StateMachineAsyncExceptionCondition`2<TSaga, TConditionException> condition, IBehavior`1<TSaga> thenBehavior, IBehavior`1<TSaga> elseBehavior);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionExceptionActivity`2/<Faulted>d__8`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionExceptionActivity`2/<Faulted>d__9`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ConditionExceptionActivity`3 : object {
    private StateMachineAsyncExceptionCondition`3<TSaga, TMessage, TConditionException> _condition;
    private IBehavior`1<TSaga> _elseBehavior;
    private IBehavior`1<TSaga> _thenBehavior;
    public ConditionExceptionActivity`3(StateMachineAsyncExceptionCondition`3<TSaga, TMessage, TConditionException> condition, IBehavior`1<TSaga> thenBehavior, IBehavior`1<TSaga> elseBehavior);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ConditionExceptionActivity`3/<Faulted>d__9`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ContainerFactoryActivity`2 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.ContainerFactoryActivity`3 : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual void Accept(StateMachineVisitor visitor);
}
public class MassTransit.SagaStateMachine.ContextMessageFactory`2 : object {
    private Func`2<TContext, Task`1<SendTuple`1<T>>> _messageFactory;
    public ContextMessageFactory`2(Func`2<TContext, Task`1<SendTuple`1<T>>> messageFactory);
    public Task`1<SendTuple`1<T>> GetMessage(TContext context);
    public Task Use(TContext context, Func`3<TContext, SendTuple`1<T>, Task> callback);
    public Task`1<TResult> Use(TContext context, Func`3<TContext, SendTuple`1<T>, Task`1<TResult>> callback);
    public static ContextMessageFactory`2<TContext, T> op_Implicit(TaskMessageFactory`1<T> factory);
}
public class MassTransit.SagaStateMachine.DataBehavior`2 : object {
    private IBehavior`1<TSaga> _behavior;
    public DataBehavior`2(IBehavior`1<TSaga> behavior);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga,TMessage>.Execute(BehaviorContext`2<TSaga, TMessage> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga,TMessage>.Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context);
}
public class MassTransit.SagaStateMachine.DataConverterActivity`2 : object {
    private IStateMachineActivity`2<TSaga, TMessage> _activity;
    public DataConverterActivity`2(IStateMachineActivity`2<TSaga, TMessage> activity);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.DataEventActivityBinder`2 : object {
    private IActivityBinder`1[] _activities;
    private Event`1<TData> _event;
    private StateMachineCondition`2<TInstance, TData> _filter;
    private StateMachine`1<TInstance> _machine;
    private Event`1<TData> MassTransit.EventActivityBinder<TInstance,TData>.Event { get; }
    private StateMachine`1<TInstance> MassTransit.EventActivityBinder<TInstance,TData>.StateMachine { get; }
    public DataEventActivityBinder`2(StateMachine`1<TInstance> machine, Event`1<TData> event, IActivityBinder`1[] activities);
    public DataEventActivityBinder`2(StateMachine`1<TInstance> machine, Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter, IActivityBinder`1[] activities);
    private DataEventActivityBinder`2(StateMachine`1<TInstance> machine, Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter, IActivityBinder`1[] activities, IActivityBinder`1[] appendActivity);
    private sealed virtual override Event`1<TData> MassTransit.EventActivityBinder<TInstance,TData>.get_Event();
    private sealed virtual override EventActivityBinder`2<TInstance, TData> MassTransit.EventActivityBinder<TInstance,TData>.Add(IStateMachineActivity`1<TInstance> activity);
    private sealed virtual override EventActivityBinder`2<TInstance, TData> MassTransit.EventActivityBinder<TInstance,TData>.Add(IStateMachineActivity`2<TInstance, TData> activity);
    private sealed virtual override EventActivityBinder`2<TInstance, TData> MassTransit.EventActivityBinder<TInstance,TData>.Catch(Func`2<ExceptionActivityBinder`3<TInstance, TData, T>, ExceptionActivityBinder`3<TInstance, TData, T>> activityCallback);
    public sealed virtual EventActivityBinder`2<TInstance, TData> Retry(Action`1<IRetryConfigurator> configure, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> activityCallback);
    private sealed virtual override EventActivityBinder`2<TInstance, TData> MassTransit.EventActivityBinder<TInstance,TData>.If(StateMachineCondition`2<TInstance, TData> condition, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> activityCallback);
    private sealed virtual override EventActivityBinder`2<TInstance, TData> MassTransit.EventActivityBinder<TInstance,TData>.IfAsync(StateMachineAsyncCondition`2<TInstance, TData> condition, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> activityCallback);
    public sealed virtual EventActivityBinder`2<TInstance, TData> IfElse(StateMachineCondition`2<TInstance, TData> condition, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> thenActivityCallback, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> elseActivityCallback);
    public sealed virtual EventActivityBinder`2<TInstance, TData> IfElseAsync(StateMachineAsyncCondition`2<TInstance, TData> condition, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> thenActivityCallback, Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> elseActivityCallback);
    private sealed virtual override StateMachine`1<TInstance> MassTransit.EventActivityBinder<TInstance,TData>.get_StateMachine();
    public sealed virtual IEnumerable`1<IActivityBinder`1<TInstance>> GetStateActivityBinders();
    private EventActivityBinder`2<TInstance, TData> GetBinder(Func`2<EventActivityBinder`2<TInstance, TData>, EventActivityBinder`2<TInstance, TData>> activityCallback);
    private IActivityBinder`1<TInstance> CreateStateActivityBinder(IStateMachineActivity`2<TInstance, TData> activity);
    private IActivityBinder`1<TInstance> CreateConditionalActivityBinder();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <CreateConditionalActivityBinder>b__22_0(BehaviorContext`2<TInstance, TData> context);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.SagaStateMachine.Edge : object {
    [CompilerGeneratedAttribute]
private Vertex <To>k__BackingField;
    [CompilerGeneratedAttribute]
private Vertex <From>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public Vertex To { get; }
    public Vertex From { get; }
    private string Title { get; }
    public string DebuggerDisplay { get; }
    public Edge(Vertex from, Vertex to, string title);
    [CompilerGeneratedAttribute]
public Vertex get_To();
    [CompilerGeneratedAttribute]
public Vertex get_From();
    [CompilerGeneratedAttribute]
private string get_Title();
    public string get_DebuggerDisplay();
    public sealed virtual bool Equals(Edge other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MassTransit.SagaStateMachine.EmptyBehavior`1 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
public class MassTransit.SagaStateMachine.EmptyBehavior`2 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context);
}
public class MassTransit.SagaStateMachine.EventCorrelationExpressionConverter`2 : ExpressionVisitor {
    private ConsumeContext`1<TMessage> _context;
    public EventCorrelationExpressionConverter`2(ConsumeContext`1<TMessage> context);
    public Expression`1<Func`2<TInstance, bool>> Convert(Expression`1<Func`3<TInstance, ConsumeContext`1<TMessage>, bool>> expression);
    private static Expression`1<Func`2<TInstance, bool>> RemoveMessageParameter(LambdaExpression lambda);
    protected virtual Expression VisitMember(MemberExpression m);
    private Expression EvaluateConsumeContextAccess(MemberExpression exp);
}
public static class MassTransit.SagaStateMachine.ExceptionTypeCache : object {
    private static CachedConfigurator GetOrAdd(Type type);
    public static Task Faulted(IBehavior`1<TSaga> behavior, BehaviorContext`1<TSaga> context, Exception exception);
    public static Task Faulted(IBehavior`2<TSaga, TMessage> behavior, BehaviorContext`2<TSaga, TMessage> context, Exception exception);
}
public class MassTransit.SagaStateMachine.ExecuteActivityBinder`1 : object {
    private IStateMachineActivity`1<TInstance> _activity;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public ExecuteActivityBinder`1(Event event, IStateMachineActivity`1<TInstance> activity);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.ExecuteOnFaultedActivity`1 : object {
    private IStateMachineActivity`1<TSaga> _activity;
    public ExecuteOnFaultedActivity`1(IStateMachineActivity`1<TSaga> activity);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.ExecuteOnFaultedBehavior`2 : object {
    private BehaviorExceptionContext`2<TSaga, TException> _context;
    private IBehavior`1<TSaga> _next;
    public ExecuteOnFaultedBehavior`2(IBehavior`1<TSaga> next, BehaviorExceptionContext`2<TSaga, TException> context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`1<TSaga> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`2<TSaga, T> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, T> context);
}
public class MassTransit.SagaStateMachine.ExecuteOnFaultedBehavior`3 : object {
    private BehaviorExceptionContext`3<TSaga, TMessage, TException> _context;
    private IBehavior`2<TSaga, TMessage> _next;
    public ExecuteOnFaultedBehavior`3(IBehavior`2<TSaga, TMessage> next, BehaviorExceptionContext`3<TSaga, TMessage, TException> context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`1<TSaga> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`2<TSaga, T> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, TD, T> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, T> context);
}
public class MassTransit.SagaStateMachine.ExpressionCorrelationSagaQueryFactory`2 : object {
    private Expression`1<Func`3<TInstance, ConsumeContext`1<TData>, bool>> _correlationExpression;
    public ExpressionCorrelationSagaQueryFactory`2(Expression`1<Func`3<TInstance, ConsumeContext`1<TData>, bool>> correlationExpression);
    public sealed virtual bool TryCreateQuery(ConsumeContext`1<TData> context, ISagaQuery`1& query);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.FactoryActivity`1 : object {
    private Func`2<BehaviorContext`1<TSaga>, IStateMachineActivity`1<TSaga>> _activityFactory;
    public FactoryActivity`1(Func`2<BehaviorContext`1<TSaga>, IStateMachineActivity`1<TSaga>> activityFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.FactoryActivity`2 : object {
    private Func`2<BehaviorContext`2<TSaga, TMessage>, IStateMachineActivity`2<TSaga, TMessage>> _activityFactory;
    public FactoryActivity`2(Func`2<BehaviorContext`2<TSaga, TMessage>, IStateMachineActivity`2<TSaga, TMessage>> activityFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TMessage>.Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TMessage>.Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.FaultedActionActivity`2 : object {
    private Action`1<BehaviorExceptionContext`2<TSaga, TException>> _action;
    public FaultedActionActivity`2(Action`1<BehaviorExceptionContext`2<TSaga, TException>> action);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedActionActivity`3 : object {
    private Action`1<BehaviorExceptionContext`3<TSaga, TMessage, TException>> _action;
    public FaultedActionActivity`3(Action`1<BehaviorExceptionContext`3<TSaga, TMessage, TException>> action);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, T> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.FaultedBehavior`1 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
public class MassTransit.SagaStateMachine.FaultedBehavior`2 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context);
}
public class MassTransit.SagaStateMachine.FaultedContainerFactoryActivity`3 : object {
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedContainerFactoryActivity`3/<Faulted>d__3`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TOtherException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.FaultedContainerFactoryActivity`4 : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, T> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual void Accept(StateMachineVisitor visitor);
}
public class MassTransit.SagaStateMachine.FaultedPublishActivity`3 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> _messageFactory;
    public FaultedPublishActivity`3(ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedPublishActivity`3/<Faulted>d__5`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedPublishActivity`3/<Faulted>d__6`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.FaultedPublishActivity`4 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> _messageFactory;
    public FaultedPublishActivity`4(ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedPublishActivity`4/<Faulted>d__5`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedRequestActivity`4 : RequestActivityImpl`3<TSaga, TRequest, TResponse> {
    private ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TRequest> _messageFactory;
    private ServiceAddressExceptionProvider`2<TSaga, TException> _serviceAddressProvider;
    public FaultedRequestActivity`4(Request`3<TSaga, TRequest, TResponse> request, ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TRequest> messageFactory);
    public FaultedRequestActivity`4(Request`3<TSaga, TRequest, TResponse> request, ServiceAddressExceptionProvider`2<TSaga, TException> serviceAddressProvider, ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TRequest> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRequestActivity`4/<Faulted>d__7`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRequestActivity`4/<MassTransit-IStateMachineActivity<TSaga>-Faulted>d__8`2")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.FaultedRequestActivity`5 : RequestActivityImpl`3<TInstance, TRequest, TResponse> {
    private ContextMessageFactory`2<BehaviorExceptionContext`3<TInstance, TData, TException>, TRequest> _messageFactory;
    private ServiceAddressExceptionProvider`3<TInstance, TData, TException> _serviceAddressProvider;
    public FaultedRequestActivity`5(Request`3<TInstance, TRequest, TResponse> request, ContextMessageFactory`2<BehaviorExceptionContext`3<TInstance, TData, TException>, TRequest> messageFactory);
    public FaultedRequestActivity`5(Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`3<TInstance, TData, TException> serviceAddressProvider, ContextMessageFactory`2<BehaviorExceptionContext`3<TInstance, TData, TException>, TRequest> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`2<TInstance, TData> context, IBehavior`2<TInstance, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRequestActivity`5/<Faulted>d__6`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, TData, T> context, IBehavior`2<TInstance, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedRespondActivity`3 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> _messageFactory;
    public FaultedRespondActivity`3(ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRespondActivity`3/<MassTransit-IStateMachineActivity<TSaga>-Faulted>d__6`1")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRespondActivity`3/<MassTransit-IStateMachineActivity<TSaga>-Faulted>d__7`2")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.FaultedRespondActivity`4 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> _messageFactory;
    public FaultedRespondActivity`4(ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TData>.Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedRespondActivity`4/<MassTransit-IStateMachineActivity<TSaga,TData>-Faulted>d__5`1")]
private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TData>.Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedScheduleActivity`3 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> _messageFactory;
    private Schedule`2<TSaga, TMessage> _schedule;
    private ScheduleTimeExceptionProvider`2<TSaga, TException> _timeProvider;
    public FaultedScheduleActivity`3(Schedule`2<TSaga, TMessage> schedule, ScheduleTimeExceptionProvider`2<TSaga, TException> timeProvider, ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedScheduleActivity`3/<Faulted>d__8`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedScheduleActivity`3/<Faulted>d__9`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedScheduleActivity`3/<Schedule>d__10`1")]
private Task Schedule(BehaviorExceptionContext`2<TSaga, T> context, BehaviorExceptionContext`2<TSaga, TException> exceptionContext);
}
public class MassTransit.SagaStateMachine.FaultedScheduleActivity`4 : object {
    private ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> _messageFactory;
    private Schedule`2<TSaga, TMessage> _schedule;
    private ScheduleTimeExceptionProvider`3<TSaga, TData, TException> _timeProvider;
    public FaultedScheduleActivity`4(Schedule`2<TSaga, TMessage> schedule, ScheduleTimeExceptionProvider`3<TSaga, TData, TException> timeProvider, ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedScheduleActivity`4/<Faulted>d__7`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedSendActivity`3 : object {
    private DestinationAddressProvider`1<TSaga> _destinationAddressProvider;
    private ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> _messageFactory;
    public FaultedSendActivity`3(DestinationAddressProvider`1<TSaga> destinationAddressProvider, ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedSendActivity`3/<Faulted>d__7`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, T> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedSendActivity`3/<Faulted>d__8`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TOtherException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedSendActivity`3/<Send>d__9")]
private Task Send(BehaviorExceptionContext`2<TSaga, TException> exceptionContext);
}
public class MassTransit.SagaStateMachine.FaultedSendActivity`4 : object {
    private DestinationAddressProvider`2<TSaga, TData> _destinationAddressProvider;
    private ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> _messageFactory;
    public FaultedSendActivity`4(DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TData, TException>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedSendActivity`4/<Faulted>d__6`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, T> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.FaultedUnscheduleActivity`1 : object {
    private Schedule`1<TSaga> _schedule;
    public FaultedUnscheduleActivity`1(Schedule`1<TSaga> schedule);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedUnscheduleActivity`1/<Faulted>d__6`1")]
public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedUnscheduleActivity`1/<Faulted>d__7`2")]
public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultedUnscheduleActivity`1/<Faulted>d__8")]
private Task Faulted(SagaConsumeContext`1<TSaga> context);
}
public class MassTransit.SagaStateMachine.FaultRequestActivity : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.FaultRequestActivity/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<RequestState, RequestFaulted> context, IBehavior`2<RequestState, RequestFaulted> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<RequestState, RequestFaulted, TException> context, IBehavior`2<RequestState, RequestFaulted> next);
}
[ExtensionAttribute]
public static class MassTransit.SagaStateMachine.GraphStateMachineExtensions : object {
    [ExtensionAttribute]
public static StateMachineGraph GetGraph(StateMachine`1<TSaga> machine);
}
public class MassTransit.SagaStateMachine.GraphStateMachineVisitor`1 : object {
    private HashSet`1<Edge> _edges;
    private Dictionary`2<Event, Vertex> _events;
    private StateMachine`1<TSaga> _machine;
    private Dictionary`2<State, Vertex> _states;
    private Edge _currentEdge;
    private Vertex _currentEvent;
    private Vertex _currentState;
    public StateMachineGraph Graph { get; }
    public GraphStateMachineVisitor`1(StateMachine`1<TSaga> machine);
    public StateMachineGraph get_Graph();
    public sealed virtual void Visit(State state, Action`1<State> next);
    public sealed virtual void Visit(Event event, Action`1<Event> next);
    public sealed virtual void Visit(Event`1<TData> event, Action`1<Event`1<TData>> next);
    public sealed virtual void Visit(IStateMachineActivity activity);
    public sealed virtual void Visit(IBehavior`1<T> behavior);
    public sealed virtual void Visit(IBehavior`1<T> behavior, Action`1<IBehavior`1<T>> next);
    public sealed virtual void Visit(IBehavior`2<T, TData> behavior);
    public sealed virtual void Visit(IBehavior`2<T, TData> behavior, Action`1<IBehavior`2<T, TData>> next);
    public sealed virtual void Visit(IStateMachineActivity activity, Action`1<IStateMachineActivity> next);
    private void AddCurrentEdge();
    private void InspectTransitionActivity(TransitionActivity`1<TSaga> transitionActivity);
    private void InspectCompositeEventActivity(CompositeEventActivity`1<TSaga> compositeActivity);
    private Vertex GetStateVertex(State state);
    private Vertex GetEventVertex(Event state);
    private static Vertex CreateStateVertex(State state);
    private Vertex CreateEventVertex(Event event);
    private static Vertex CreateEventVertex(Type exceptionType);
}
public interface MassTransit.SagaStateMachine.IActivityBinder`1 {
    public Event Event { get; }
    public abstract virtual Event get_Event();
    public abstract virtual bool IsStateTransitionEvent(State state);
    public abstract virtual void Bind(State`1<TSaga> state);
    public abstract virtual void Bind(IBehaviorBuilder`1<TSaga> builder);
}
public interface MassTransit.SagaStateMachine.IBehaviorBuilder`1 {
    public abstract virtual void Add(IStateMachineActivity`1<TInstance> activity);
}
public interface MassTransit.SagaStateMachine.ICompositeEventStatusAccessor`1 {
    public abstract virtual CompositeEventStatus Get(TSaga instance);
    public abstract virtual void Set(TSaga instance, CompositeEventStatus status);
}
public class MassTransit.SagaStateMachine.IgnoreEventActivityBinder`1 : object {
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public IgnoreEventActivityBinder`1(Event event);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.IgnoreEventActivityBinder`2 : object {
    private Event`1<TData> _event;
    private StateMachineCondition`2<TInstance, TData> _filter;
    public Event Event { get; }
    public IgnoreEventActivityBinder`2(Event`1<TData> event, StateMachineCondition`2<TInstance, TData> filter);
    public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.IntCompositeEventStatusAccessor`1 : object {
    private string _name;
    private IReadProperty`2<TSaga, int> _read;
    private IWriteProperty`2<TSaga, int> _write;
    public IntCompositeEventStatusAccessor`1(PropertyInfo propertyInfo);
    public sealed virtual CompositeEventStatus Get(TSaga instance);
    public sealed virtual void Set(TSaga instance, CompositeEventStatus status);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.SagaStateMachine.IStateEventFilter`1 {
    public abstract virtual bool Filter(BehaviorContext`1<TSaga> context);
    public abstract virtual bool Filter(BehaviorContext`2<TSaga, T> context);
}
public class MassTransit.SagaStateMachine.LastBehavior`1 : object {
    private IStateMachineActivity`1<TSaga> _activity;
    public LastBehavior`1(IStateMachineActivity`1<TSaga> activity);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
public class MassTransit.SagaStateMachine.LastCatchBehavior`1 : object {
    private IStateMachineActivity`1<TSaga> _activity;
    public LastCatchBehavior`1(IStateMachineActivity`1<TSaga> activity);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task Execute(BehaviorContext`1<TSaga> context);
    public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
public class MassTransit.SagaStateMachine.MessageEvent`1 : TriggerEvent {
    public static Event`1<TMessage> Instance;
    public MessageEvent`1(string name);
    private static MessageEvent`1();
    public virtual void Accept(StateMachineVisitor visitor);
    public virtual void Probe(ProbeContext context);
    public sealed virtual bool Equals(MessageEvent`1<TMessage> other);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class MassTransit.SagaStateMachine.MessageEventCorrelation`2 : object {
    private Lazy`1<bool> _includesInitial;
    private bool _insertOnInitial;
    private SagaStateMachine`1<TSaga> _machine;
    private IPipe`1<ConsumeContext`1<TMessage>> _missingPipe;
    private Lazy`1<ISagaPolicy`2<TSaga, TMessage>> _policy;
    private bool _readOnly;
    private ISagaFactory`2<TSaga, TMessage> _sagaFactory;
    [CompilerGeneratedAttribute]
private bool <ConfigureConsumeTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaFilterFactory`2<TSaga, TMessage> <FilterFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Event`1<TMessage> <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private IFilter`1<ConsumeContext`1<TMessage>> <MessageFilter>k__BackingField;
    public bool ConfigureConsumeTopology { get; }
    public SagaFilterFactory`2<TSaga, TMessage> FilterFactory { get; }
    public Event`1<TMessage> Event { get; }
    public Type DataType { get; }
    public IFilter`1<ConsumeContext`1<TMessage>> MessageFilter { get; }
    public ISagaPolicy`2<TSaga, TMessage> Policy { get; }
    public MessageEventCorrelation`2(SagaStateMachine`1<TSaga> machine, Event`1<TMessage> event, SagaFilterFactory`2<TSaga, TMessage> sagaFilterFactory, IFilter`1<ConsumeContext`1<TMessage>> messageFilter, IPipe`1<ConsumeContext`1<TMessage>> missingPipe, ISagaFactory`2<TSaga, TMessage> sagaFactory, bool insertOnInitial, bool readOnly, bool configureConsumeTopology);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConfigureConsumeTopology();
    [CompilerGeneratedAttribute]
public sealed virtual SagaFilterFactory`2<TSaga, TMessage> get_FilterFactory();
    [CompilerGeneratedAttribute]
public sealed virtual Event`1<TMessage> get_Event();
    public sealed virtual Type get_DataType();
    [CompilerGeneratedAttribute]
public sealed virtual IFilter`1<ConsumeContext`1<TMessage>> get_MessageFilter();
    public sealed virtual ISagaPolicy`2<TSaga, TMessage> get_Policy();
    [IteratorStateMachineAttribute("MassTransit.SagaStateMachine.MessageEventCorrelation`2/<Validate>d__24")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private ISagaPolicy`2<TSaga, TMessage> GetSagaPolicy();
    private bool IncludesInitial();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__7_0();
}
public static class MassTransit.SagaStateMachine.MessageFactory`1 : object {
    public static TaskMessageFactory`1<T> Create(T message);
    public static TaskMessageFactory`1<T> Create(T message, IPipe`1<SendContext`1<T>> pipe);
    public static TaskMessageFactory`1<T> Create(T message, Action`1<SendContext`1<T>> callback);
    public static TaskMessageFactory`1<T> Create(Task`1<T> factory);
    public static TaskMessageFactory`1<T> Create(Task`1<T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static TaskMessageFactory`1<T> Create(Task`1<T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(T message, SendContextCallback`3<TSaga, TMessage, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(Task`1<T> factory, SendContextCallback`3<TSaga, TMessage, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(Func`2<BehaviorContext`2<TSaga, TMessage>, Task`1<SendTuple`1<T>>> factory);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(Func`2<BehaviorContext`2<TSaga, TMessage>, Task`1<SendTuple`1<T>>> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(Func`2<BehaviorContext`2<TSaga, TMessage>, Task`1<SendTuple`1<T>>> factory, SendContextCallback`3<TSaga, TMessage, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(AsyncEventMessageFactory`3<TSaga, TMessage, T> factory);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(AsyncEventMessageFactory`3<TSaga, TMessage, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(AsyncEventMessageFactory`3<TSaga, TMessage, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(AsyncEventMessageFactory`3<TSaga, TMessage, T> factory, SendContextCallback`3<TSaga, TMessage, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(EventMessageFactory`3<TSaga, TMessage, T> factory);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(EventMessageFactory`3<TSaga, TMessage, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(EventMessageFactory`3<TSaga, TMessage, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> Create(EventMessageFactory`3<TSaga, TMessage, T> factory, SendContextCallback`3<TSaga, TMessage, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(T message, SendExceptionContextCallback`4<TSaga, TMessage, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(Task`1<T> factory, SendExceptionContextCallback`4<TSaga, TMessage, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(Func`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, Task`1<SendTuple`1<T>>> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(Func`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, Task`1<SendTuple`1<T>>> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(Func`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, Task`1<SendTuple`1<T>>> factory, SendExceptionContextCallback`4<TSaga, TMessage, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(AsyncEventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(AsyncEventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(AsyncEventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(AsyncEventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, SendExceptionContextCallback`4<TSaga, TMessage, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(EventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(EventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(EventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`3<TSaga, TMessage, TException>, T> Create(EventExceptionMessageFactory`4<TSaga, TMessage, TException, T> factory, SendExceptionContextCallback`4<TSaga, TMessage, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(T message, SendContextCallback`2<TSaga, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(Task`1<T> factory, SendContextCallback`2<TSaga, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(T message, SendExceptionContextCallback`3<TSaga, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(Task`1<T> factory, SendExceptionContextCallback`3<TSaga, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<T>>> factory);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<T>>> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<T>>> factory, SendContextCallback`2<TSaga, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(AsyncEventMessageFactory`2<TSaga, T> factory);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(AsyncEventMessageFactory`2<TSaga, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(AsyncEventMessageFactory`2<TSaga, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(AsyncEventMessageFactory`2<TSaga, T> factory, SendContextCallback`2<TSaga, T> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(EventMessageFactory`2<TSaga, T> factory);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(EventMessageFactory`2<TSaga, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(EventMessageFactory`2<TSaga, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorContext`1<TSaga>, T> Create(EventMessageFactory`2<TSaga, T> factory, SendContextCallback`2<TSaga, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<T>>> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<T>>> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<T>>> factory, SendExceptionContextCallback`3<TSaga, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(AsyncEventExceptionMessageFactory`3<TSaga, TException, T> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(AsyncEventExceptionMessageFactory`3<TSaga, TException, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(AsyncEventExceptionMessageFactory`3<TSaga, TException, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(AsyncEventExceptionMessageFactory`3<TSaga, TException, T> factory, SendExceptionContextCallback`3<TSaga, TException, T> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(EventExceptionMessageFactory`3<TSaga, TException, T> factory);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(EventExceptionMessageFactory`3<TSaga, TException, T> factory, IPipe`1<SendContext`1<T>> pipe);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(EventExceptionMessageFactory`3<TSaga, TException, T> factory, Action`1<SendContext`1<T>> callback);
    public static ContextMessageFactory`2<BehaviorExceptionContext`2<TSaga, TException>, T> Create(EventExceptionMessageFactory`3<TSaga, TException, T> factory, SendExceptionContextCallback`3<TSaga, TException, T> callback);
}
public class MassTransit.SagaStateMachine.PublishActivity`2 : object {
    private ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> _messageFactory;
    public PublishActivity`2(ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.PublishActivity`2/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.PublishActivity`2/<Execute>d__5`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
}
public class MassTransit.SagaStateMachine.PublishActivity`3 : object {
    private ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> _messageFactory;
    public PublishActivity`3(ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.PublishActivity`3/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RequestActivity`3 : RequestActivityImpl`3<TInstance, TRequest, TResponse> {
    private ContextMessageFactory`2<BehaviorContext`1<TInstance>, TRequest> _messageFactory;
    private ServiceAddressProvider`1<TInstance> _serviceAddressProvider;
    public RequestActivity`3(Request`3<TInstance, TRequest, TResponse> request, ContextMessageFactory`2<BehaviorContext`1<TInstance>, TRequest> messageFactory);
    public RequestActivity`3(Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`1<TInstance> serviceAddressProvider, ContextMessageFactory`2<BehaviorContext`1<TInstance>, TRequest> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestActivity`3/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`1<TInstance> context, IBehavior`1<TInstance> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestActivity`3/<Execute>d__6`1")]
public sealed virtual Task Execute(BehaviorContext`2<TInstance, T> context, IBehavior`2<TInstance, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TInstance, TException> context, IBehavior`1<TInstance> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, T, TException> context, IBehavior`2<TInstance, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestActivity`3/<Execute>d__9")]
private Task Execute(BehaviorContext`1<TInstance> context);
}
public class MassTransit.SagaStateMachine.RequestActivity`4 : RequestActivityImpl`3<TInstance, TRequest, TResponse> {
    private ContextMessageFactory`2<BehaviorContext`2<TInstance, TData>, TRequest> _messageFactory;
    private ServiceAddressProvider`2<TInstance, TData> _serviceAddressProvider;
    public RequestActivity`4(Request`3<TInstance, TRequest, TResponse> request, ContextMessageFactory`2<BehaviorContext`2<TInstance, TData>, TRequest> messageFactory);
    public RequestActivity`4(Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`2<TInstance, TData> serviceAddressProvider, ContextMessageFactory`2<BehaviorContext`2<TInstance, TData>, TRequest> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestActivity`4/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`2<TInstance, TData> context, IBehavior`2<TInstance, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, TData, TException> context, IBehavior`2<TInstance, TData> next);
}
public abstract class MassTransit.SagaStateMachine.RequestActivityImpl`3 : object {
    private Request`3<TInstance, TRequest, TResponse> _request;
    protected RequestActivityImpl`3(Request`3<TInstance, TRequest, TResponse> request);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestActivityImpl`3/<SendRequest>d__2")]
protected Task SendRequest(BehaviorContext`1<TInstance> context, SendTuple`1<TRequest> sendTuple, Uri serviceAddress);
    public virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.RequestCompletedActivity`2 : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestCompletedActivity`2/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RequestCompletedActivity`3 : object {
    private AsyncEventMessageFactory`3<TSaga, TMessage, TResponse> _messageFactory;
    public RequestCompletedActivity`3(AsyncEventMessageFactory`3<TSaga, TMessage, TResponse> messageFactory);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestCompletedActivity`3/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RequestFaultedActivity`3 : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestFaultedActivity`3/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RequestStartedActivity`2 : object {
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestStartedActivity`2/<Execute>d__2")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RequestStateMessagePipe : object {
    private BehaviorContext`1<RequestState> _context;
    private object _message;
    private String[] _messageType;
    public RequestStateMessagePipe(BehaviorContext`1<RequestState> context, object message, String[] messageType);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RequestStateMessagePipe/<Send>d__5")]
public sealed virtual Task Send(SendContext context);
}
public class MassTransit.SagaStateMachine.RespondActivity`3 : object {
    private ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> _messageFactory;
    public RespondActivity`3(ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RespondActivity`3/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.RetryActivity`1 : object {
    private IBehavior`1<TInstance> _retryBehavior;
    private IRetryPolicy _retryPolicy;
    public RetryActivity`1(IRetryPolicy retryPolicy, IBehavior`1<TInstance> retryBehavior);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RetryActivity`1/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`1<TInstance> context, IBehavior`1<TInstance> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RetryActivity`1/<Execute>d__6`1")]
public sealed virtual Task Execute(BehaviorContext`2<TInstance, T> context, IBehavior`2<TInstance, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TInstance, TException> context, IBehavior`1<TInstance> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, T, TException> context, IBehavior`2<TInstance, T> next);
}
public class MassTransit.SagaStateMachine.RetryActivity`2 : object {
    private IBehavior`1<TInstance> _retryBehavior;
    private IRetryPolicy _retryPolicy;
    public RetryActivity`2(IRetryPolicy retryPolicy, IBehavior`1<TInstance> retryBehavior);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual Task Execute(BehaviorContext`1<TInstance> context, IBehavior`1<TInstance> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.RetryActivity`2/<Execute>d__6`1")]
public sealed virtual Task Execute(BehaviorContext`2<TInstance, T> context, IBehavior`2<TInstance, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TInstance, TException> context, IBehavior`1<TInstance> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TInstance, T, TException> context, IBehavior`2<TInstance, T> next);
}
public class MassTransit.SagaStateMachine.RetryActivityBinder`1 : object {
    private IStateMachineActivity`1<TInstance> _activity;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public RetryActivityBinder`1(Event event, IRetryPolicy retryPolicy, EventActivities`1<TInstance> retryActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.RetryActivityBinder`2 : object {
    private IStateMachineActivity`1<TInstance> _activity;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    public RetryActivityBinder`2(Event event, IRetryPolicy retryPolicy, EventActivities`1<TInstance> retryActivities);
    [CompilerGeneratedAttribute]
public sealed virtual Event get_Event();
    public sealed virtual bool IsStateTransitionEvent(State state);
    public sealed virtual void Bind(State`1<TInstance> state);
    public sealed virtual void Bind(IBehaviorBuilder`1<TInstance> builder);
}
public class MassTransit.SagaStateMachine.ScheduleActivity`2 : object {
    private ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> _messageFactory;
    private Schedule`1<TSaga> _schedule;
    private ScheduleTimeProvider`1<TSaga> _timeProvider;
    public ScheduleActivity`2(Schedule`1<TSaga> schedule, ScheduleTimeProvider`1<TSaga> timeProvider, ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ScheduleActivity`2/<Execute>d__6")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ScheduleActivity`2/<Execute>d__7`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ScheduleActivity`2/<Execute>d__10")]
private Task Execute(BehaviorContext`1<TSaga> context);
}
public class MassTransit.SagaStateMachine.ScheduleActivity`3 : object {
    private ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> _messageFactory;
    private Schedule`2<TSaga, T> _schedule;
    private ScheduleTimeProvider`2<TSaga, TMessage> _timeProvider;
    public ScheduleActivity`3(Schedule`2<TSaga, T> schedule, ScheduleTimeProvider`2<TSaga, TMessage> timeProvider, ContextMessageFactory`2<BehaviorContext`2<TSaga, TMessage>, T> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.ScheduleActivity`3/<Execute>d__6")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.SelectedStateEventFilter`2 : object {
    private StateMachineCondition`2<TSaga, TMessage> _filter;
    public SelectedStateEventFilter`2(StateMachineCondition`2<TSaga, TMessage> filter);
    public sealed virtual bool Filter(BehaviorContext`2<TSaga, T> context);
    public sealed virtual bool Filter(BehaviorContext`1<TSaga> context);
}
public class MassTransit.SagaStateMachine.SendActivity`2 : object {
    private DestinationAddressProvider`1<TSaga> _destinationAddressProvider;
    private ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> _messageFactory;
    public SendActivity`2(DestinationAddressProvider`1<TSaga> destinationAddressProvider, ContextMessageFactory`2<BehaviorContext`1<TSaga>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.SendActivity`2/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.SendActivity`2/<Execute>d__6`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.SendActivity`2/<Execute>d__9")]
private Task Execute(BehaviorContext`1<TSaga> context);
}
public class MassTransit.SagaStateMachine.SendActivity`3 : object {
    private DestinationAddressProvider`2<TSaga, TData> _destinationAddressProvider;
    private ContextMessageFactory`2<BehaviorContext`2<TSaga, TData>, TMessage> _messageFactory;
    public SendActivity`3(DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, ContextMessageFactory`2<BehaviorContext`2<TSaga, TData>, TMessage> messageFactory);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.SendActivity`3/<Execute>d__5")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, TData, TException> context, IBehavior`2<TSaga, TData> next);
}
public class MassTransit.SagaStateMachine.SlimActivity`2 : object {
    private IStateMachineActivity`1<TSaga> _activity;
    public SlimActivity`2(IStateMachineActivity`1<TSaga> activity);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TMessage>.Execute(BehaviorContext`2<TSaga, TMessage> context, IBehavior`2<TSaga, TMessage> behavior);
    private sealed virtual override Task MassTransit.IStateMachineActivity<TSaga,TMessage>.Faulted(BehaviorExceptionContext`3<TSaga, TMessage, TException> context, IBehavior`2<TSaga, TMessage> next);
}
public class MassTransit.SagaStateMachine.StateMachineActivitySelector`1 : object {
    private EventActivityBinder`1<TSaga> _binder;
    public StateMachineActivitySelector`1(EventActivityBinder`1<TSaga> binder);
    public sealed virtual EventActivityBinder`1<TSaga> OfType();
}
public class MassTransit.SagaStateMachine.StateMachineActivitySelector`2 : object {
    private EventActivityBinder`2<TSaga, TMessage> _binder;
    public StateMachineActivitySelector`2(EventActivityBinder`2<TSaga, TMessage> binder);
    public sealed virtual EventActivityBinder`2<TSaga, TMessage> OfType();
    public sealed virtual EventActivityBinder`2<TSaga, TMessage> OfInstanceType();
}
public class MassTransit.SagaStateMachine.StateMachineFaultedActivitySelector`2 : object {
    private ExceptionActivityBinder`2<TSaga, TException> _binder;
    public StateMachineFaultedActivitySelector`2(ExceptionActivityBinder`2<TSaga, TException> binder);
    public sealed virtual ExceptionActivityBinder`2<TSaga, TException> OfType();
}
public class MassTransit.SagaStateMachine.StateMachineFaultedActivitySelector`3 : object {
    private ExceptionActivityBinder`3<TSaga, TMessage, TException> _binder;
    public StateMachineFaultedActivitySelector`3(ExceptionActivityBinder`3<TSaga, TMessage, TException> binder);
    public sealed virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> OfType();
    public sealed virtual ExceptionActivityBinder`3<TSaga, TMessage, TException> OfInstanceType();
}
public class MassTransit.SagaStateMachine.StateMachineGraph : object {
    private Edge[] _edges;
    private Vertex[] _vertices;
    public IEnumerable`1<Vertex> Vertices { get; }
    public IEnumerable`1<Edge> Edges { get; }
    public StateMachineGraph(IEnumerable`1<Vertex> vertices, IEnumerable`1<Edge> edges);
    public IEnumerable`1<Vertex> get_Vertices();
    public IEnumerable`1<Edge> get_Edges();
}
public class MassTransit.SagaStateMachine.StateMachineUnhandledEventCallback`1 : MulticastDelegate {
    public StateMachineUnhandledEventCallback`1(object object, IntPtr method);
    public virtual Task Invoke(BehaviorContext`1<TSaga> context, State state);
    public virtual IAsyncResult BeginInvoke(BehaviorContext`1<TSaga> context, State state, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class MassTransit.SagaStateMachine.StructCompositeEventStatusAccessor`1 : object {
    private string _name;
    private IReadProperty`2<TSaga, CompositeEventStatus> _read;
    private IWriteProperty`2<TSaga, CompositeEventStatus> _write;
    public StructCompositeEventStatusAccessor`1(PropertyInfo propertyInfo);
    public sealed virtual CompositeEventStatus Get(TSaga instance);
    public sealed virtual void Set(TSaga instance, CompositeEventStatus status);
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SagaStateMachine.TaskMessageFactory`1 : object {
    private Task`1<SendTuple`1<T>> _messageFactory;
    public TaskMessageFactory`1(Task`1<SendTuple`1<T>> messageFactory);
    public Task`1<SendTuple`1<T>> GetMessage();
    public Task Use(Func`2<SendTuple`1<T>, Task> callback);
}
public class MassTransit.SagaStateMachine.TransitionActivity`1 : object {
    private IStateAccessor`1<TSaga> _currentStateAccessor;
    private State`1<TSaga> _toState;
    public State ToState { get; }
    public TransitionActivity`1(State`1<TSaga> toState, IStateAccessor`1<TSaga> currentStateAccessor);
    public State get_ToState();
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<Execute>d__7")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<Execute>d__8`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, TData> context, IBehavior`2<TSaga, TData> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<Transition>d__11")]
private Task Transition(BehaviorContext`1<TSaga> context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<RaiseBeforeEnterEvents>d__12")]
private Task RaiseBeforeEnterEvents(BehaviorContext`1<TSaga> context, State`1<TSaga> currentState, State`1<TSaga> toState);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<RaiseAfterLeaveEvents>d__13")]
private Task RaiseAfterLeaveEvents(BehaviorContext`1<TSaga> context, State`1<TSaga> fromState, State`1<TSaga> toState);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.TransitionActivity`1/<RaiseCurrentStateLeaveEvents>d__14")]
private Task RaiseCurrentStateLeaveEvents(BehaviorContext`1<TSaga> context, State`1<TSaga> fromState);
}
public class MassTransit.SagaStateMachine.TriggerEvent : object {
    private string _name;
    public string Name { get; }
    public TriggerEvent(string name);
    public sealed virtual string get_Name();
    public virtual void Accept(StateMachineVisitor visitor);
    public virtual void Probe(ProbeContext context);
    public sealed virtual int CompareTo(Event other);
    public bool Equals(TriggerEvent other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MassTransit.SagaStateMachine.TriggerEventActivityBinder`1 : object {
    private IActivityBinder`1[] _activities;
    private StateMachineCondition`1<TInstance> _filter;
    private StateMachine`1<TInstance> _machine;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    public Event Event { get; }
    private Event MassTransit.EventActivityBinder<TInstance>.Event { get; }
    private StateMachine`1<TInstance> MassTransit.EventActivityBinder<TInstance>.StateMachine { get; }
    public TriggerEventActivityBinder`1(StateMachine`1<TInstance> machine, Event event, IActivityBinder`1[] activities);
    public TriggerEventActivityBinder`1(StateMachine`1<TInstance> machine, Event event, StateMachineCondition`1<TInstance> filter, IActivityBinder`1[] activities);
    private TriggerEventActivityBinder`1(StateMachine`1<TInstance> machine, Event event, StateMachineCondition`1<TInstance> filter, IActivityBinder`1[] activities, IActivityBinder`1[] appendActivity);
    [CompilerGeneratedAttribute]
public Event get_Event();
    private sealed virtual override Event MassTransit.EventActivityBinder<TInstance>.get_Event();
    private sealed virtual override EventActivityBinder`1<TInstance> MassTransit.EventActivityBinder<TInstance>.Add(IStateMachineActivity`1<TInstance> activity);
    private sealed virtual override EventActivityBinder`1<TInstance> MassTransit.EventActivityBinder<TInstance>.Catch(Func`2<ExceptionActivityBinder`2<TInstance, T>, ExceptionActivityBinder`2<TInstance, T>> activityCallback);
    public sealed virtual EventActivityBinder`1<TInstance> Retry(Action`1<IRetryConfigurator> configure, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    private sealed virtual override EventActivityBinder`1<TInstance> MassTransit.EventActivityBinder<TInstance>.If(StateMachineCondition`1<TInstance> condition, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    private sealed virtual override EventActivityBinder`1<TInstance> MassTransit.EventActivityBinder<TInstance>.IfAsync(StateMachineAsyncCondition`1<TInstance> condition, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    public sealed virtual EventActivityBinder`1<TInstance> IfElse(StateMachineCondition`1<TInstance> condition, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> thenActivityCallback, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> elseActivityCallback);
    public sealed virtual EventActivityBinder`1<TInstance> IfElseAsync(StateMachineAsyncCondition`1<TInstance> condition, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> thenActivityCallback, Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> elseActivityCallback);
    private sealed virtual override StateMachine`1<TInstance> MassTransit.EventActivityBinder<TInstance>.get_StateMachine();
    public sealed virtual IEnumerable`1<IActivityBinder`1<TInstance>> GetStateActivityBinders();
    private EventActivityBinder`1<TInstance> GetBinder(Func`2<EventActivityBinder`1<TInstance>, EventActivityBinder`1<TInstance>> activityCallback);
    private IActivityBinder`1<TInstance> CreateConditionalActivityBinder();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <CreateConditionalActivityBinder>b__22_0(BehaviorContext`1<TInstance> context);
}
public class MassTransit.SagaStateMachine.UnscheduleActivity`1 : object {
    private Schedule`1<TSaga> _schedule;
    public UnscheduleActivity`1(Schedule`1<TSaga> schedule);
    public sealed virtual void Accept(StateMachineVisitor inspector);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.UnscheduleActivity`1/<Execute>d__4")]
public sealed virtual Task Execute(BehaviorContext`1<TSaga> context, IBehavior`1<TSaga> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.UnscheduleActivity`1/<Execute>d__5`1")]
public sealed virtual Task Execute(BehaviorContext`2<TSaga, T> context, IBehavior`2<TSaga, T> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`2<TSaga, TException> context, IBehavior`1<TSaga> next);
    public sealed virtual Task Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context, IBehavior`2<TSaga, T> next);
    [AsyncStateMachineAttribute("MassTransit.SagaStateMachine.UnscheduleActivity`1/<Execute>d__8")]
private Task Execute(SagaConsumeContext`1<TSaga> context);
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.SagaStateMachine.Vertex : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <VertexType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComposite>k__BackingField;
    public string Title { get; }
    public Type VertexType { get; }
    public Type TargetType { get; }
    public bool IsComposite { get; }
    public string DebuggerDisplay { get; }
    public Vertex(Type type, Type targetType, string title, bool isComposite);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public Type get_VertexType();
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public bool get_IsComposite();
    public string get_DebuggerDisplay();
    public sealed virtual bool Equals(Vertex other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MassTransit.SagaStateMachine.WidenBehavior`2 : object {
    private Event`1<TMessage> _event;
    private TMessage _message;
    private IBehavior`2<TSaga, TMessage> _next;
    public WidenBehavior`2(IBehavior`2<TSaga, TMessage> next, BehaviorContext`2<TSaga, TMessage> context);
    public sealed virtual void Accept(StateMachineVisitor visitor);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`1<TSaga> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Execute(BehaviorContext`2<TSaga, T> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`3<TSaga, T, TException> context);
    private sealed virtual override Task MassTransit.IBehavior<TSaga>.Faulted(BehaviorExceptionContext`2<TSaga, TException> context);
}
[ExtensionAttribute]
public static class MassTransit.SagaStateMachineExtensions : object {
    [ExtensionAttribute]
public static ISagaQuery`1<TInstance> CreateSagaQuery(StateMachine`1<TInstance> machine, Expression`1<Func`2<TInstance, bool>> expression, State[] states);
    [ExtensionAttribute]
public static Func`2<TInstance, bool> CreateSagaFilter(StateMachine`1<TInstance> machine, Expression`1<Func`2<TInstance, bool>> expression, State[] states);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.SagaStateMachineReceiveEndpointExtensions : object {
    [ExtensionAttribute]
public static void StateMachineSaga(IReceiveEndpointConfigurator configurator, SagaStateMachine`1<TInstance> stateMachine, ISagaRepository`1<TInstance> repository, Action`1<ISagaConfigurator`1<TInstance>> configure);
    [ExtensionAttribute]
public static ConnectHandle ConnectStateMachineSaga(IConsumePipeConnector bus, SagaStateMachine`1<TInstance> stateMachine, ISagaRepository`1<TInstance> repository, Action`1<ISagaConfigurator`1<TInstance>> configure);
}
[ExtensionAttribute]
public static class MassTransit.ScheduleDateTimeExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Schedule(EventActivityBinder`1<TInstance> source, Schedule`2<TInstance, TMessage> schedule, TMessage message, ScheduleTimeProvider`1<TInstance> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Schedule(EventActivityBinder`1<TInstance> source, Schedule`2<TInstance, TMessage> schedule, Task`1<TMessage> message, ScheduleTimeProvider`1<TInstance> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Schedule(EventActivityBinder`1<TInstance> source, Schedule`2<TInstance, TMessage> schedule, EventMessageFactory`2<TInstance, TMessage> messageFactory, ScheduleTimeProvider`1<TInstance> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Schedule(EventActivityBinder`1<TInstance> source, Schedule`2<TInstance, TMessage> schedule, AsyncEventMessageFactory`2<TInstance, TMessage> messageFactory, ScheduleTimeProvider`1<TInstance> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Schedule(EventActivityBinder`1<TInstance> source, Schedule`2<TInstance, TMessage> schedule, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleTimeProvider`1<TInstance> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Schedule(EventActivityBinder`2<TInstance, TData> source, Schedule`2<TInstance, TMessage> schedule, TMessage message, ScheduleTimeProvider`2<TInstance, TData> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Schedule(EventActivityBinder`2<TInstance, TData> source, Schedule`2<TInstance, TMessage> schedule, Task`1<TMessage> message, ScheduleTimeProvider`2<TInstance, TData> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Schedule(EventActivityBinder`2<TInstance, TData> source, Schedule`2<TInstance, TMessage> schedule, EventMessageFactory`3<TInstance, TData, TMessage> messageFactory, ScheduleTimeProvider`2<TInstance, TData> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Schedule(EventActivityBinder`2<TInstance, TData> source, Schedule`2<TInstance, TMessage> schedule, AsyncEventMessageFactory`3<TInstance, TData, TMessage> messageFactory, ScheduleTimeProvider`2<TInstance, TData> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Schedule(EventActivityBinder`2<TInstance, TData> source, Schedule`2<TInstance, TMessage> schedule, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleTimeProvider`2<TInstance, TData> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Schedule(ExceptionActivityBinder`2<TInstance, TException> source, Schedule`2<TInstance, TMessage> schedule, TMessage message, ScheduleTimeExceptionProvider`2<TInstance, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Schedule(ExceptionActivityBinder`2<TInstance, TException> source, Schedule`2<TInstance, TMessage> schedule, Task`1<TMessage> message, ScheduleTimeExceptionProvider`2<TInstance, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Schedule(ExceptionActivityBinder`2<TInstance, TException> source, Schedule`2<TInstance, TMessage> schedule, EventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, ScheduleTimeExceptionProvider`2<TInstance, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Schedule(ExceptionActivityBinder`2<TInstance, TException> source, Schedule`2<TInstance, TMessage> schedule, AsyncEventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, ScheduleTimeExceptionProvider`2<TInstance, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Schedule(ExceptionActivityBinder`2<TInstance, TException> source, Schedule`2<TInstance, TMessage> schedule, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleTimeExceptionProvider`2<TInstance, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Schedule(ExceptionActivityBinder`3<TInstance, TData, TException> source, Schedule`2<TInstance, TMessage> schedule, TMessage message, ScheduleTimeExceptionProvider`3<TInstance, TData, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Schedule(ExceptionActivityBinder`3<TInstance, TData, TException> source, Schedule`2<TInstance, TMessage> schedule, Task`1<TMessage> message, ScheduleTimeExceptionProvider`3<TInstance, TData, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Schedule(ExceptionActivityBinder`3<TInstance, TData, TException> source, Schedule`2<TInstance, TMessage> schedule, EventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, ScheduleTimeExceptionProvider`3<TInstance, TData, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Schedule(ExceptionActivityBinder`3<TInstance, TData, TException> source, Schedule`2<TInstance, TMessage> schedule, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, ScheduleTimeExceptionProvider`3<TInstance, TData, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Schedule(ExceptionActivityBinder`3<TInstance, TData, TException> source, Schedule`2<TInstance, TMessage> schedule, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleTimeExceptionProvider`3<TInstance, TData, TException> timeProvider, Action`1<SendContext`1<TMessage>> callback);
}
[ExtensionAttribute]
public static class MassTransit.ScheduledRedeliveryConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseScheduledRedelivery(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseScheduledRedelivery(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, IRetryPolicy retryPolicy);
    private static RetryConsumeContext`1<T> Factory(ConsumeContext`1<T> context, IRetryPolicy retryPolicy, RetryContext retryContext);
    [ExtensionAttribute]
public static void UseScheduledRedelivery(IConsumePipeConfigurator configurator, Action`1<IRetryConfigurator> configureRetry);
    [ExtensionAttribute]
public static void UseScheduledRedelivery(IConsumerConfigurator`1<TConsumer> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseScheduledRedelivery(ISagaConfigurator`1<TSaga> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static void UseScheduledRedelivery(IHandlerConfigurator`1<TMessage> configurator, Action`1<IRetryConfigurator> configure);
}
[ExtensionAttribute]
public static class MassTransit.ScheduleTimeSpanExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, ScheduleDelayProvider`1<TSaga> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, ScheduleDelayProvider`1<TSaga> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, EventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, EventMessageFactory`2<TSaga, TMessage> messageFactory, ScheduleDelayProvider`1<TSaga> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, ScheduleDelayProvider`1<TSaga> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Schedule(EventActivityBinder`1<TSaga> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleDelayProvider`1<TSaga> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, ScheduleDelayProvider`2<TSaga, TData> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, ScheduleDelayProvider`2<TSaga, TData> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, ScheduleDelayProvider`2<TSaga, TData> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, ScheduleDelayProvider`2<TSaga, TData> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Schedule(EventActivityBinder`2<TSaga, TData> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleDelayProvider`2<TSaga, TData> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, ScheduleDelayExceptionProvider`2<TSaga, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, ScheduleDelayExceptionProvider`2<TSaga, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, ScheduleDelayExceptionProvider`2<TSaga, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, ScheduleDelayExceptionProvider`2<TSaga, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Schedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleDelayExceptionProvider`2<TSaga, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, TMessage message, ScheduleDelayExceptionProvider`3<TSaga, TData, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, Task`1<TMessage> message, ScheduleDelayExceptionProvider`3<TSaga, TData, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, ScheduleDelayExceptionProvider`3<TSaga, TData, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, ScheduleDelayExceptionProvider`3<TSaga, TData, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Schedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`2<TSaga, TMessage> schedule, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, ScheduleDelayExceptionProvider`3<TSaga, TData, TException> delayProvider, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Unschedule(EventActivityBinder`2<TSaga, TData> source, Schedule`1<TSaga> schedule);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Unschedule(ExceptionActivityBinder`3<TSaga, TData, TException> source, Schedule`1<TSaga> schedule);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Unschedule(EventActivityBinder`1<TSaga> source, Schedule`1<TSaga> schedule);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Unschedule(ExceptionActivityBinder`2<TSaga, TException> source, Schedule`1<TSaga> schedule);
}
public abstract class MassTransit.Scheduling.BaseScheduleMessageProvider : object {
    [AsyncStateMachineAttribute("MassTransit.Scheduling.BaseScheduleMessageProvider/<ScheduleSend>d__0`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
    protected abstract virtual Task ScheduleSend(ScheduleMessage message, IPipe`1<SendContext`1<ScheduleMessage>> pipe, CancellationToken cancellationToken);
    protected abstract virtual Task CancelScheduledSend(Guid tokenId, Uri destinationAddress, CancellationToken cancellationToken);
}
public class MassTransit.Scheduling.CancelScheduledMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TokenId>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public Guid TokenId { get; public set; }
    public CancelScheduledMessageCommand(Guid tokenId);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_TokenId();
    [CompilerGeneratedAttribute]
public void set_TokenId(Guid value);
}
public class MassTransit.Scheduling.CancelScheduledRecurringMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleGroup>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string ScheduleId { get; public set; }
    public string ScheduleGroup { get; public set; }
    public CancelScheduledRecurringMessageCommand(string scheduleId, string scheduleGroup);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleId();
    [CompilerGeneratedAttribute]
public void set_ScheduleId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleGroup();
    [CompilerGeneratedAttribute]
public void set_ScheduleGroup(string value);
}
public abstract class MassTransit.Scheduling.DefaultRecurringSchedule : object {
    [CompilerGeneratedAttribute]
private MissedEventPolicy <MisfirePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeZoneId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CronExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public MissedEventPolicy MisfirePolicy { get; protected set; }
    public string TimeZoneId { get; protected set; }
    public DateTimeOffset StartTime { get; protected set; }
    public Nullable`1<DateTimeOffset> EndTime { get; protected set; }
    public string ScheduleId { get; private set; }
    public string ScheduleGroup { get; private set; }
    public string CronExpression { get; protected set; }
    public string Description { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual MissedEventPolicy get_MisfirePolicy();
    [CompilerGeneratedAttribute]
protected void set_MisfirePolicy(MissedEventPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TimeZoneId();
    [CompilerGeneratedAttribute]
protected void set_TimeZoneId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_StartTime();
    [CompilerGeneratedAttribute]
protected void set_StartTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_EndTime();
    [CompilerGeneratedAttribute]
protected void set_EndTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleId();
    [CompilerGeneratedAttribute]
private void set_ScheduleId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleGroup();
    [CompilerGeneratedAttribute]
private void set_ScheduleGroup(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CronExpression();
    [CompilerGeneratedAttribute]
protected void set_CronExpression(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
protected void set_Description(string value);
}
public class MassTransit.Scheduling.DelayedScheduleMessageProvider : object {
    private ISendEndpointProvider _sendEndpointProvider;
    public DelayedScheduleMessageProvider(ISendEndpointProvider sendEndpointProvider);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.DelayedScheduleMessageProvider/<ScheduleSend>d__2`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Scheduling.EndpointRecurringMessageScheduler : object {
    [NullableAttribute("2")]
private IBusTopology _busTopology;
    private Func`1<Task`1<ISendEndpoint>> _schedulerEndpoint;
    public EndpointRecurringMessageScheduler(ISendEndpointProvider sendEndpointProvider, Uri schedulerAddress, IBusTopology busTopology);
    public EndpointRecurringMessageScheduler(ISendEndpoint sendEndpoint, IBusTopology busTopology);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringSend>d__11`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringSend>d__12`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringSend>d__13`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringPublish>d__21`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringPublish>d__22`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ScheduleRecurringPublish>d__23`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<CancelScheduledRecurringSend>d__24")]
public sealed virtual Task CancelScheduledRecurringSend(string scheduleId, string scheduleGroup);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<PauseScheduledRecurringSend>d__25")]
public sealed virtual Task PauseScheduledRecurringSend(string scheduleId, string scheduleGroup);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<ResumeScheduledRecurringSend>d__26")]
public sealed virtual Task ResumeScheduledRecurringSend(string scheduleId, string scheduleGroup);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<Schedule>d__27`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<Schedule>d__28`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointRecurringMessageScheduler/<Schedule>d__29`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    private static ScheduleRecurringMessage CreateCommand(Uri destinationAddress, RecurringSchedule schedule, T message);
    private Uri GetPublishAddress();
    private Uri GetPublishAddress(Type messageType);
}
public class MassTransit.Scheduling.EndpointScheduleMessageProvider : BaseScheduleMessageProvider {
    private Func`1<Task`1<ISendEndpoint>> _schedulerEndpoint;
    public EndpointScheduleMessageProvider(Func`1<Task`1<ISendEndpoint>> schedulerEndpoint);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointScheduleMessageProvider/<ScheduleSend>d__2")]
protected virtual Task ScheduleSend(ScheduleMessage message, IPipe`1<SendContext`1<ScheduleMessage>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.EndpointScheduleMessageProvider/<CancelScheduledSend>d__3")]
protected virtual Task CancelScheduledSend(Guid tokenId, Uri destinationAddress, CancellationToken cancellationToken);
}
public interface MassTransit.Scheduling.IScheduleTokenIdCache`1 {
    public abstract virtual bool TryGetTokenId(T message, Guid& tokenId);
}
public class MassTransit.Scheduling.MessageScheduler : object {
    private IBusTopology _busTopology;
    private IScheduleMessageProvider _provider;
    public MessageScheduler(IScheduleMessageProvider provider, IBusTopology busTopology);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.MessageScheduler/<ScheduleSend>d__10`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.MessageScheduler/<ScheduleSend>d__11`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.MessageScheduler/<ScheduleSend>d__12`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage> SchedulePublish(DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledMessage`1<T>> SchedulePublish(DateTime scheduledTime, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledPublish(Type messageType, Guid tokenId, CancellationToken cancellationToken);
    private Uri GetPublishAddress();
    private Uri GetPublishAddress(Type messageType);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Scheduling.MessageSchedulerConverterCache : object {
    private ConcurrentDictionary`2<Type, Lazy`1<IMessageSchedulerConverter>> _types;
    private IMessageSchedulerConverter Item { get; }
    private IMessageSchedulerConverter get_Item(Type type);
    public static Task`1<ScheduledMessage> ScheduleSend(IMessageScheduler scheduler, Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, CancellationToken cancellationToken);
    public static Task`1<ScheduledMessage> ScheduleSend(IMessageScheduler scheduler, Uri destinationAddress, DateTime scheduledTime, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IRecurringMessageScheduler scheduler, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(IRecurringMessageScheduler scheduler, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    private static Lazy`1<IMessageSchedulerConverter> CreateTypeConverter(Type type);
    private static IMessageSchedulerConverter CreateConverter(Type type);
}
public class MassTransit.Scheduling.PauseScheduledRecurringMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleGroup>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string ScheduleId { get; public set; }
    public string ScheduleGroup { get; public set; }
    public PauseScheduledRecurringMessageCommand(string scheduleId, string scheduleGroup);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleId();
    [CompilerGeneratedAttribute]
public void set_ScheduleId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleGroup();
    [CompilerGeneratedAttribute]
public void set_ScheduleGroup(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Scheduling.PublishRecurringMessageScheduler : object {
    [NullableAttribute("2")]
private IBusTopology _busTopology;
    private IPublishEndpoint _publishEndpoint;
    public PublishRecurringMessageScheduler(IPublishEndpoint publishEndpoint, IBusTopology busTopology);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringSend>d__10`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringSend>d__11`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringSend>d__12`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<ScheduledRecurringMessage> ScheduleRecurringPublish(RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringPublish>d__20`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringPublish>d__21`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<ScheduleRecurringPublish>d__22`1")]
public sealed virtual Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringPublish(RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledRecurringSend(string scheduleId, string scheduleGroup);
    public sealed virtual Task PauseScheduledRecurringSend(string scheduleId, string scheduleGroup);
    public sealed virtual Task ResumeScheduledRecurringSend(string scheduleId, string scheduleGroup);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<Schedule>d__26`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<Schedule>d__27`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.PublishRecurringMessageScheduler/<Schedule>d__28`1")]
private Task`1<ScheduledRecurringMessage`1<T>> Schedule(Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    private static ScheduleRecurringMessage CreateCommand(Uri destinationAddress, RecurringSchedule schedule, T message);
    private Uri GetPublishAddress();
    private Uri GetPublishAddress(Type messageType);
}
public class MassTransit.Scheduling.PublishScheduleMessageProvider : BaseScheduleMessageProvider {
    private IPublishEndpoint _publishEndpoint;
    public PublishScheduleMessageProvider(IPublishEndpoint publishEndpoint);
    protected virtual Task ScheduleSend(ScheduleMessage message, IPipe`1<SendContext`1<ScheduleMessage>> pipe, CancellationToken cancellationToken);
    protected virtual Task CancelScheduledSend(Guid tokenId, Uri destinationAddress, CancellationToken cancellationToken);
}
public class MassTransit.Scheduling.ResumeScheduledRecurringMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScheduleGroup>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string ScheduleId { get; public set; }
    public string ScheduleGroup { get; public set; }
    public ResumeScheduledRecurringMessageCommand(string scheduleId, string scheduleGroup);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleId();
    [CompilerGeneratedAttribute]
public void set_ScheduleId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ScheduleGroup();
    [CompilerGeneratedAttribute]
public void set_ScheduleGroup(string value);
}
public class MassTransit.Scheduling.ScheduledMessageHandle`1 : object {
    [CompilerGeneratedAttribute]
private Guid <TokenId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Payload>k__BackingField;
    public Guid TokenId { get; }
    public DateTime ScheduledTime { get; }
    public Uri Destination { get; }
    public T Payload { get; }
    public ScheduledMessageHandle`1(Guid tokenId, DateTime scheduledTime, Uri destination, T payload);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_TokenId();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ScheduledTime();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Payload();
}
public class MassTransit.Scheduling.ScheduledRecurringMessageHandle`1 : object {
    [CompilerGeneratedAttribute]
private RecurringSchedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Payload>k__BackingField;
    public RecurringSchedule Schedule { get; private set; }
    public Uri Destination { get; private set; }
    public T Payload { get; private set; }
    public ScheduledRecurringMessageHandle`1(RecurringSchedule schedule, Uri destination, T payload);
    [CompilerGeneratedAttribute]
public sealed virtual RecurringSchedule get_Schedule();
    [CompilerGeneratedAttribute]
private void set_Schedule(RecurringSchedule value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
private void set_Destination(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Payload();
    [CompilerGeneratedAttribute]
private void set_Payload(T value);
}
public class MassTransit.Scheduling.ScheduleMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledTime>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PayloadType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Payload>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime ScheduledTime { get; public set; }
    public String[] PayloadType { get; public set; }
    public Uri Destination { get; public set; }
    public object Payload { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ScheduledTime();
    [CompilerGeneratedAttribute]
public void set_ScheduledTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PayloadType();
    [CompilerGeneratedAttribute]
public void set_PayloadType(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(object value);
}
public class MassTransit.Scheduling.ScheduleMessageCommand`1 : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledTime>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PayloadType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Payload>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public DateTime ScheduledTime { get; public set; }
    public String[] PayloadType { get; public set; }
    public Uri Destination { get; public set; }
    public object Payload { get; public set; }
    public ScheduleMessageCommand`1(DateTime scheduledTime, Uri destination, T payload, Guid tokenId);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ScheduledTime();
    [CompilerGeneratedAttribute]
public void set_ScheduledTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PayloadType();
    [CompilerGeneratedAttribute]
public void set_PayloadType(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(object value);
}
internal class MassTransit.Scheduling.ScheduleMessageContextPipe`1 : object {
    private T _payload;
    private IPipe`1<SendContext`1<T>> _pipe;
    private SendContext _context;
    private Nullable`1<Guid> _scheduledMessageId;
    public Nullable`1<Guid> ScheduledMessageId { get; public set; }
    public ScheduleMessageContextPipe`1(T payload, IPipe`1<SendContext`1<T>> pipe);
    public Nullable`1<Guid> get_ScheduledMessageId();
    public void set_ScheduledMessageId(Nullable`1<Guid> value);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.ScheduleMessageContextPipe`1/<Send>d__8")]
public sealed virtual Task Send(SendContext`1<ScheduleMessage> context);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Scheduling.ScheduleRecurringMessageCommand : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private RecurringSchedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PayloadType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Payload>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public RecurringSchedule Schedule { get; public set; }
    public String[] PayloadType { get; public set; }
    public Uri Destination { get; public set; }
    public object Payload { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual RecurringSchedule get_Schedule();
    [CompilerGeneratedAttribute]
public void set_Schedule(RecurringSchedule value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PayloadType();
    [CompilerGeneratedAttribute]
public void set_PayloadType(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(object value);
}
public class MassTransit.Scheduling.ScheduleRecurringMessageCommand`1 : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private RecurringSchedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PayloadType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Payload>k__BackingField;
    public Guid CorrelationId { get; private set; }
    public RecurringSchedule Schedule { get; private set; }
    public String[] PayloadType { get; private set; }
    public Uri Destination { get; private set; }
    public object Payload { get; private set; }
    public ScheduleRecurringMessageCommand`1(RecurringSchedule schedule, Uri destination, T payload);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
private void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual RecurringSchedule get_Schedule();
    [CompilerGeneratedAttribute]
private void set_Schedule(RecurringSchedule value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PayloadType();
    [CompilerGeneratedAttribute]
private void set_PayloadType(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Destination();
    [CompilerGeneratedAttribute]
private void set_Destination(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Payload();
    [CompilerGeneratedAttribute]
private void set_Payload(object value);
    public virtual string ToString();
}
public class MassTransit.Scheduling.ScheduleSendPipe`1 : SendContextPipeAdapter`1<TMessage> {
    private DateTime _scheduledTime;
    private SendContext _context;
    private Nullable`1<Guid> _scheduledMessageId;
    public Nullable`1<Guid> ScheduledMessageId { get; public set; }
    public Nullable`1<Guid> MessageId { get; }
    public ScheduleSendPipe`1(IPipe`1<SendContext`1<TMessage>> pipe, DateTime scheduledTime);
    public Nullable`1<Guid> get_ScheduledMessageId();
    public void set_ScheduledMessageId(Nullable`1<Guid> value);
    public Nullable`1<Guid> get_MessageId();
    protected virtual void Send(SendContext`1<TMessage> context);
    protected virtual void Send(SendContext`1<T> context);
}
public static class MassTransit.Scheduling.ScheduleTokenId : object {
    public static void UseTokenId(TokenIdSelector<T> tokenIdSelector);
}
public class MassTransit.Scheduling.ScheduleTokenIdCache`1 : object {
    private TokenIdSelector<T> _selector;
    private ScheduleTokenIdCache`1(TokenIdSelector<T> selector);
    public sealed virtual bool TryGetTokenId(T message, Guid& tokenId);
    public static Guid GetTokenId(T message, Nullable`1<Guid> defaultValue);
    internal static void UseTokenId(TokenIdSelector<T> tokenIdSelector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Scheduling.SqlScheduleMessageProvider : object {
    private Func`3<Func`2<ClientContext, Task>, CancellationToken, Task> _cancel;
    [NullableAttribute("2")]
private ConsumeContext _context;
    [NullableAttribute("2")]
private ISqlHostConfiguration _hostConfiguration;
    private ISendEndpointProvider _sendEndpointProvider;
    public SqlScheduleMessageProvider(ConsumeContext context);
    public SqlScheduleMessageProvider(ISqlHostConfiguration hostConfiguration, ISendEndpointProvider sendEndpointProvider);
    [AsyncStateMachineAttribute("MassTransit.Scheduling.SqlScheduleMessageProvider/<ScheduleSend>d__6`1")]
public sealed virtual Task`1<ScheduledMessage`1<T>> ScheduleSend(Uri destinationAddress, DateTime scheduledTime, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task CancelScheduledSend(Uri destinationAddress, Guid tokenId, CancellationToken cancellationToken);
    private Task RetryUsingContext(Func`2<ClientContext, Task> callback, CancellationToken cancellationToken);
    private Task RetryUsingHostConfiguration(Func`2<ClientContext, Task> callback, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.SendByConventionExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Send(EventActivityBinder`1<TInstance> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Send(EventActivityBinder`1<TInstance> source, EventMessageFactory`2<TInstance, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, AsyncEventMessageFactory`2<TInstance, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Send(EventActivityBinder`2<TInstance, TData> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Send(EventActivityBinder`2<TInstance, TData> source, EventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, AsyncEventMessageFactory`3<TInstance, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Send(ExceptionActivityBinder`2<TInstance, TException> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Send(ExceptionActivityBinder`2<TInstance, TException> source, EventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, AsyncEventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Send(ExceptionActivityBinder`3<TInstance, TData, TException> source, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Send(ExceptionActivityBinder`3<TInstance, TData, TException> source, EventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Send(EventActivityBinder`1<TInstance> source, TMessage message, SendContextCallback`2<TInstance, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, Task`1<TMessage> message, SendContextCallback`2<TInstance, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Send(EventActivityBinder`1<TInstance> source, EventMessageFactory`2<TInstance, TMessage> messageFactory, SendContextCallback`2<TInstance, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, AsyncEventMessageFactory`2<TInstance, TMessage> messageFactory, SendContextCallback`2<TInstance, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> SendAsync(EventActivityBinder`1<TInstance> source, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`2<TInstance, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Send(EventActivityBinder`2<TInstance, TData> source, TMessage message, SendContextCallback`3<TInstance, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, Task`1<TMessage> message, SendContextCallback`3<TInstance, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Send(EventActivityBinder`2<TInstance, TData> source, EventMessageFactory`3<TInstance, TData, TMessage> messageFactory, SendContextCallback`3<TInstance, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, AsyncEventMessageFactory`3<TInstance, TData, TMessage> messageFactory, SendContextCallback`3<TInstance, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> SendAsync(EventActivityBinder`2<TInstance, TData> source, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`3<TInstance, TData, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Send(ExceptionActivityBinder`2<TInstance, TException> source, TMessage message, SendExceptionContextCallback`3<TInstance, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, Task`1<TMessage> message, SendExceptionContextCallback`3<TInstance, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Send(ExceptionActivityBinder`2<TInstance, TException> source, EventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TInstance, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, AsyncEventExceptionMessageFactory`3<TInstance, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TInstance, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> SendAsync(ExceptionActivityBinder`2<TInstance, TException> source, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`3<TInstance, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Send(ExceptionActivityBinder`3<TInstance, TData, TException> source, TMessage message, SendExceptionContextCallback`4<TInstance, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Task`1<TMessage> message, SendExceptionContextCallback`4<TInstance, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Send(ExceptionActivityBinder`3<TInstance, TData, TException> source, EventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TInstance, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TInstance, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> SendAsync(ExceptionActivityBinder`3<TInstance, TData, TException> source, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`4<TInstance, TData, TException, TMessage> callback);
    private static Uri GetDestinationAddress();
}
[ExtensionAttribute]
public static class MassTransit.SendCallbackExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, Uri destinationAddress, TMessage message, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, Task`1<TMessage> message, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, TMessage message, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Task`1<TMessage> message, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, Uri destinationAddress, EventMessageFactory`2<TSaga, TMessage> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, EventMessageFactory`2<TSaga, TMessage> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`2<TSaga, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, TMessage message, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, Task`1<TMessage> message, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, TMessage message, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Task`1<TMessage> message, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendContextCallback`3<TSaga, TData, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, TMessage message, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, Task`1<TMessage> message, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, TMessage message, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Task`1<TMessage> message, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`3<TSaga, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, TMessage message, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, Task`1<TMessage> message, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, TMessage message, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Task`1<TMessage> message, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, SendExceptionContextCallback`4<TSaga, TData, TException, TMessage> callback);
}
[ExtensionAttribute]
public static class MassTransit.SendEndpointRecurringSchedulerExtensions : object {
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ScheduledRecurringMessage`1<T>> ScheduleRecurringSend(ISendEndpoint endpoint, Uri destinationAddress, RecurringSchedule schedule, object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task CancelScheduledRecurringSend(ISendEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task CancelScheduledRecurringSend(ISendEndpoint endpoint, string scheduleId, string scheduleGroup);
    [ExtensionAttribute]
public static Task PauseScheduledRecurringSend(ISendEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task PauseScheduledRecurringSend(ISendEndpoint endpoint, string scheduleId, string scheduleGroup);
    [ExtensionAttribute]
public static Task ResumeScheduledRecurringSend(ISendEndpoint endpoint, ScheduledRecurringMessage`1<T> message);
    [ExtensionAttribute]
public static Task ResumeScheduledRecurringSend(ISendEndpoint endpoint, string scheduleId, string scheduleGroup);
}
[ExtensionAttribute]
public static class MassTransit.SendExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, Uri destinationAddress, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, Uri destinationAddress, EventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, Uri destinationAddress, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Send(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, EventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, AsyncEventMessageFactory`2<TSaga, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> SendAsync(EventActivityBinder`1<TSaga> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Func`2<BehaviorContext`1<TSaga>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, Uri destinationAddress, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Send(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, EventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, AsyncEventMessageFactory`3<TSaga, TData, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> SendAsync(EventActivityBinder`2<TSaga, TData> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, Uri destinationAddress, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Send(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, EventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, AsyncEventExceptionMessageFactory`3<TSaga, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> SendAsync(ExceptionActivityBinder`2<TSaga, TException> source, DestinationAddressProvider`1<TSaga> destinationAddressProvider, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, TMessage message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Task`1<TMessage> message, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Send(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, EventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, Uri destinationAddress, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, AsyncEventExceptionMessageFactory`4<TSaga, TData, TException, TMessage> messageFactory, Action`1<SendContext`1<TMessage>> callback);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> SendAsync(ExceptionActivityBinder`3<TSaga, TData, TException> source, DestinationAddressProvider`2<TSaga, TData> destinationAddressProvider, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task`1<SendTuple`1<TMessage>>> messageFactory, Action`1<SendContext`1<TMessage>> callback);
}
public class MassTransit.Serialization.AesCryptoStreamProvider : object {
    private string _defaultKeyId;
    private ISymmetricKeyProvider _keyProvider;
    private PaddingMode _paddingMode;
    public AesCryptoStreamProvider(ISymmetricKeyProvider keyProvider, string defaultKeyId, PaddingMode paddingMode);
    private sealed virtual override Stream MassTransit.Serialization.ICryptoStreamProvider.GetEncryptStream(Stream stream, string keyId, CryptoStreamMode streamMode);
    private sealed virtual override Stream MassTransit.Serialization.ICryptoStreamProvider.GetDecryptStream(Stream stream, string keyId, CryptoStreamMode streamMode);
    public sealed virtual void Probe(ProbeContext context);
    private ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    private Aes CreateAes();
}
public class MassTransit.Serialization.AesCryptoStreamProviderV2 : object {
    private PaddingMode _paddingMode;
    private ISecureKeyProvider _secureKeyProvider;
    public AesCryptoStreamProviderV2(ISecureKeyProvider secureKeyProvider, PaddingMode paddingMode);
    public sealed virtual Stream GetDecryptStream(Stream stream, Headers headers);
    public sealed virtual Stream GetEncryptStream(Stream stream, Headers headers);
    public sealed virtual void Probe(ProbeContext context);
    private ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    private Byte[] GenerateIv();
    private ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    private Aes CreateAes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Serialization.BaseSerializerContext : object {
    private MessageContext _context;
    private IObjectDeserializer _deserializer;
    private Nullable`1<Guid> _conversationId;
    private Nullable`1<Guid> _correlationId;
    [NullableAttribute("2")]
private Uri _destinationAddress;
    [NullableAttribute("2")]
private Uri _faultAddress;
    [NullableAttribute("2")]
private Headers _headers;
    private Nullable`1<Guid> _initiatorId;
    private Nullable`1<Guid> _messageId;
    private Nullable`1<Guid> _requestId;
    [NullableAttribute("2")]
private Uri _responseAddress;
    [NullableAttribute("2")]
private Uri _sourceAddress;
    [CompilerGeneratedAttribute]
private String[] <SupportedMessageTypes>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    [NullableAttribute("2")]
public Uri SourceAddress { get; }
    [NullableAttribute("2")]
public Uri DestinationAddress { get; }
    [NullableAttribute("2")]
public Uri ResponseAddress { get; }
    [NullableAttribute("2")]
public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public String[] SupportedMessageTypes { get; }
    protected BaseSerializerContext(IObjectDeserializer deserializer, MessageContext context, String[] supportedMessageTypes);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    [NullableContextAttribute("2")]
public sealed virtual Uri get_SourceAddress();
    [NullableContextAttribute("2")]
public sealed virtual Uri get_DestinationAddress();
    [NullableContextAttribute("2")]
public sealed virtual Uri get_ResponseAddress();
    [NullableContextAttribute("2")]
public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SupportedMessageTypes();
    [NullableContextAttribute("2")]
public sealed virtual T DeserializeObject(object value, T defaultValue);
    [NullableContextAttribute("0")]
public sealed virtual Nullable`1<T> DeserializeObject(object value, Nullable`1<T> defaultValue);
    public sealed virtual MessageBody SerializeObject(object value);
    public abstract virtual bool TryGetMessage(T& message);
    public abstract virtual bool TryGetMessage(Type messageType, Object& message);
    public abstract virtual IMessageSerializer GetMessageSerializer();
    public abstract virtual IMessageSerializer GetMessageSerializer(MessageEnvelope envelope, T message);
    public abstract virtual IMessageSerializer GetMessageSerializer(object message, String[] messageTypes);
    public abstract virtual Dictionary`2<string, object> ToDictionary(T message);
    public virtual bool IsSupportedMessageType();
    public virtual bool IsSupportedMessageType(Type messageType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.BodyConsumeContext : DeserializerConsumeContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<Type, ConsumeContext> _messageTypes;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public IEnumerable`1<string> SupportedMessageTypes { get; }
    public BodyConsumeContext(ReceiveContext receiveContext, SerializerContext serializerContext);
    public virtual Nullable`1<Guid> get_MessageId();
    public virtual Nullable`1<Guid> get_RequestId();
    public virtual Nullable`1<Guid> get_CorrelationId();
    public virtual Nullable`1<Guid> get_ConversationId();
    public virtual Nullable`1<Guid> get_InitiatorId();
    public virtual Nullable`1<DateTime> get_ExpirationTime();
    public virtual Uri get_SourceAddress();
    public virtual Uri get_DestinationAddress();
    public virtual Uri get_ResponseAddress();
    public virtual Uri get_FaultAddress();
    public virtual Nullable`1<DateTime> get_SentTime();
    public virtual Headers get_Headers();
    public virtual HostInfo get_Host();
    public virtual IEnumerable`1<string> get_SupportedMessageTypes();
    public virtual bool HasMessageType(Type messageType);
    public virtual bool TryGetMessage(ConsumeContext`1& message);
}
public class MassTransit.Serialization.ConstantSecureKeyProvider : object {
    private Byte[] _key;
    public ConstantSecureKeyProvider(Byte[] key);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Byte[] GetKey(Headers headers);
}
public class MassTransit.Serialization.CopyBodySerializer : object {
    private MessageBody _body;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    public ContentType ContentType { get; }
    public CopyBodySerializer(ContentType contentType, MessageBody body);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_ContentType();
    public sealed virtual MessageBody GetMessageBody(SendContext`1<T> context);
}
[ExtensionAttribute]
public static class MassTransit.Serialization.DeserializeVariableExtensions : object {
    [ExtensionAttribute]
public static bool TryGetValue(IDictionary`2<string, object> dictionary, string key, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(IDictionary`2<string, object> dictionary, string key, Nullable`1& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.DictionarySendHeaders : object {
    private IDictionary`2<string, object> _headers;
    public DictionarySendHeaders(IDictionary`2<string, object> headers);
    public sealed virtual void Set(string key, string value);
    public sealed virtual void Set(string key, object value, bool overwrite);
    public sealed virtual bool TryGetHeader(string key, Object& value);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAll();
    public sealed virtual T Get(string key, T defaultValue);
    [NullableContextAttribute("0")]
public sealed virtual Nullable`1<T> Get(string key, Nullable`1<T> defaultValue);
    public sealed virtual IEnumerator`1<HeaderValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MassTransit.Serialization.DisposingCryptoStream : CryptoStream {
    private Stream _stream;
    private ICryptoTransform _transform;
    internal DisposingCryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Serialization.EnvelopeMessageContext : object {
    [NullableAttribute("1")]
private MessageEnvelope _envelope;
    [NullableAttribute("1")]
private IObjectDeserializer _objectDeserializer;
    private Nullable`1<Guid> _conversationId;
    private Nullable`1<Guid> _correlationId;
    private Uri _destinationAddress;
    private Uri _faultAddress;
    private Headers _headers;
    private Nullable`1<Guid> _initiatorId;
    private Nullable`1<Guid> _messageId;
    private Nullable`1<Guid> _requestId;
    private Uri _responseAddress;
    private Uri _sourceAddress;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    [NullableAttribute("1")]
public Headers Headers { get; }
    [NullableAttribute("1")]
public HostInfo Host { get; }
    [NullableContextAttribute("1")]
public EnvelopeMessageContext(MessageEnvelope envelope, IObjectDeserializer objectDeserializer);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    [NullableContextAttribute("1")]
public sealed virtual Headers get_Headers();
    [NullableContextAttribute("1")]
public sealed virtual HostInfo get_Host();
    [NullableContextAttribute("1")]
private Headers GetHeaders();
    private static Nullable`1<Guid> ConvertIdToGuid(string id);
    private static Uri ConvertToUri(string uri);
}
public class MassTransit.Serialization.ForwardMessagePipe`1 : object {
    private ConsumeContext`1<TMessage> _context;
    private IPipe`1<SendContext`1<TMessage>> _pipe;
    public ForwardMessagePipe`1(ConsumeContext`1<TMessage> context, IPipe`1<SendContext`1<TMessage>> pipe);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Serialization.ForwardMessagePipe`1/<Send>d__4")]
public sealed virtual Task Send(SendContext`1<TMessage> context);
    public sealed virtual Task Send(SendContext`1<T> context);
}
public interface MassTransit.Serialization.ICryptoStreamProvider {
    public abstract virtual Stream GetEncryptStream(Stream stream, string keyId, CryptoStreamMode streamMode);
    public abstract virtual Stream GetDecryptStream(Stream stream, string keyId, CryptoStreamMode streamMode);
}
public interface MassTransit.Serialization.ICryptoStreamProviderV2 {
    public abstract virtual Stream GetDecryptStream(Stream stream, Headers headers);
    public abstract virtual Stream GetEncryptStream(Stream stream, Headers headers);
}
public interface MassTransit.Serialization.ISecureKeyProvider {
    public abstract virtual Byte[] GetKey(Headers headers);
}
public interface MassTransit.Serialization.ISymmetricKeyProvider {
    public abstract virtual bool TryGetKey(string id, SymmetricKey& key);
}
public class MassTransit.Serialization.JsonConverters.CaseInsensitiveDictionaryJsonConverter`2 : JsonConverter`1<T> {
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    protected T ReadInternal(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.CaseInsensitiveDictionaryStringObjectJsonConverter`1 : JsonConverter`1<T> {
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    private static void Write(Utf8JsonWriter writer, IEnumerable`1<KeyValuePair`2<string, object>> values, JsonSerializerOptions options);
    private static void WriteValue(Utf8JsonWriter writer, string key, object objectValue, JsonSerializerOptions options);
    private static Dictionary`2<string, object> ReadObject(Utf8JsonReader& reader, JsonSerializerOptions options);
    private static Dictionary`2<string, object> ReadArray(Utf8JsonReader& reader, JsonSerializerOptions options);
    private static object ReadPropertyValue(Utf8JsonReader& reader, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.CustomMessageTypeJsonConverter`1 : JsonConverter`1<T> {
    private JsonSerializerOptions _options;
    public CustomMessageTypeJsonConverter`1(JsonSerializerOptions options);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.InterfaceJsonConverter`2 : JsonConverter`1<TType> {
    public virtual TType Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TType value, JsonSerializerOptions options);
}
[ExtensionAttribute]
internal static class MassTransit.Serialization.JsonConverters.JsonConverterFactoryExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<Type, Func`1<JsonConverter>> Add(IDictionary`2<Type, Func`1<JsonConverter>> dictionary);
}
public class MassTransit.Serialization.JsonConverters.StringDecimalJsonConverter : JsonConverter`1<decimal> {
    private static NumberStyles StringDecimalStyle;
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.SystemTextJsonConverterFactory : JsonConverterFactory {
    private static IDictionary`2<Type, Func`1<JsonConverter>> _converterFactory;
    private static IDictionary`2<Type, Type> _openTypeFactory;
    private static SystemTextJsonConverterFactory();
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private static bool IsConvertibleInterfaceType(Type typeToConvert);
}
public class MassTransit.Serialization.JsonConverters.SystemTextJsonMessageDataConverter : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.SystemTextMessageDataReference : object {
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [JsonPropertyNameAttribute("data-ref")]
public Uri Reference { get; public set; }
    [JsonPropertyNameAttribute("text")]
public string Text { get; public set; }
    [JsonPropertyNameAttribute("data")]
public Byte[] Data { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    [CompilerGeneratedAttribute]
public void set_Reference(Uri value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Data(Byte[] value);
}
public class MassTransit.Serialization.JsonConverters.TypeMappingJsonConverter`2 : JsonConverter`1<TType> {
    public virtual TType Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TType value, JsonSerializerOptions options);
}
public class MassTransit.Serialization.JsonConverters.UriDictionarySystemTextJsonConverter`2 : JsonConverter`1<T> {
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    protected T ReadInternal(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.Serialization.JsonMessageEnvelope : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _headers;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitiatorId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FaultAddress>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SentTime>k__BackingField;
    [CompilerGeneratedAttribute]
private HostInfo <Host>k__BackingField;
    public string MessageId { get; public set; }
    public string RequestId { get; public set; }
    public string CorrelationId { get; public set; }
    public string ConversationId { get; public set; }
    public string InitiatorId { get; public set; }
    public string SourceAddress { get; public set; }
    public string DestinationAddress { get; public set; }
    public string ResponseAddress { get; public set; }
    public string FaultAddress { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] MessageType { get; public set; }
    public object Message { get; public set; }
    public Nullable`1<DateTime> ExpirationTime { get; public set; }
    public Nullable`1<DateTime> SentTime { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Headers { get; public set; }
    public HostInfo Host { get; public set; }
    [NullableContextAttribute("1")]
public JsonMessageEnvelope(SendContext context, object message);
    [NullableContextAttribute("1")]
public JsonMessageEnvelope(MessageContext context, object message, String[] messageTypeNames);
    [NullableContextAttribute("1")]
public JsonMessageEnvelope(MessageEnvelope envelope);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConversationId();
    [CompilerGeneratedAttribute]
public void set_ConversationId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InitiatorId();
    [CompilerGeneratedAttribute]
public void set_InitiatorId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceAddress();
    [CompilerGeneratedAttribute]
public void set_SourceAddress(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DestinationAddress();
    [CompilerGeneratedAttribute]
public void set_DestinationAddress(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResponseAddress();
    [CompilerGeneratedAttribute]
public void set_ResponseAddress(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FaultAddress();
    [CompilerGeneratedAttribute]
public void set_FaultAddress(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_SentTime();
    [CompilerGeneratedAttribute]
public void set_SentTime(Nullable`1<DateTime> value);
    public sealed virtual Dictionary`2<string, object> get_Headers();
    public void set_Headers(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual HostInfo get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(HostInfo value);
    [NullableContextAttribute("1")]
public void Update(SendContext context);
}
public class MassTransit.Serialization.MemoryMessageBody : object {
    private ReadOnlyMemory`1<byte> _memory;
    private Byte[] _bytes;
    private string _string;
    public Nullable`1<long> Length { get; }
    public MemoryMessageBody(ReadOnlyMemory`1<byte> memory);
    public sealed virtual Nullable`1<long> get_Length();
    public sealed virtual Stream GetStream();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual string GetString();
}
public class MassTransit.Serialization.MessageIdMessageHeader : object {
    private Guid _messageId;
    public MessageIdMessageHeader(Guid messageId);
    [IteratorStateMachineAttribute("MassTransit.Serialization.MessageIdMessageHeader/<GetAll>d__2")]
public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAll();
    public sealed virtual bool TryGetHeader(string key, Object& value);
    private sealed virtual override T MassTransit.Headers.Get(string key, T defaultValue);
    public sealed virtual Nullable`1<T> Get(string key, Nullable`1<T> defaultValue);
    [IteratorStateMachineAttribute("MassTransit.Serialization.MessageIdMessageHeader/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<HeaderValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MassTransit.Serialization.NotSupportedMessageBody : object {
    public Nullable`1<long> Length { get; }
    public sealed virtual Nullable`1<long> get_Length();
    public sealed virtual Stream GetStream();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual string GetString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class MassTransit.Serialization.ObjectDeserializer : object {
    private static IObjectDeserializer _serializer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static AsyncLocal`1<IObjectDeserializer> _currentSerializer;
    unknown static IObjectDeserializer Default {public set; }
    [NullableAttribute("1")]
unknown static IObjectDeserializer Current {public set; }
    private static ObjectDeserializer();
    public static void set_Default(IObjectDeserializer value);
    [NullableContextAttribute("1")]
public static void set_Current(IObjectDeserializer value);
    public static string Serialize(object value);
    public static T Deserialize(object value, T defaultValue);
    [NullableContextAttribute("0")]
public static Nullable`1<T> Deserialize(object value, Nullable`1<T> defaultValue);
}
public class MassTransit.Serialization.RawMessageContext : object {
    private RawSerializerOptions _options;
    private Headers _transportHeaders;
    private Nullable`1<Guid> _conversationId;
    private Nullable`1<Guid> _correlationId;
    private Uri _faultAddress;
    private Headers _headers;
    private HostInfo _host;
    private Nullable`1<Guid> _initiatorId;
    private Nullable`1<Guid> _messageId;
    private Nullable`1<Guid> _requestId;
    private Uri _responseAddress;
    private Nullable`1<DateTime> _sentTime;
    private Uri _sourceAddress;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DestinationAddress>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public RawMessageContext(Headers headers, Uri destinationAddress, RawSerializerOptions options);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    private Nullable`1<DateTime> GetSentTime();
    private HostInfo GetHostInfo();
}
public abstract class MassTransit.Serialization.RawMessageSerializer : object {
    protected virtual void SetRawMessageHeaders(SendContext context);
}
public class MassTransit.Serialization.ReadOnlyDictionaryHeaders : object {
    private IObjectDeserializer _deserializer;
    private IReadOnlyDictionary`2<string, object> _headers;
    public ReadOnlyDictionaryHeaders(IObjectDeserializer deserializer, IReadOnlyDictionary`2<string, object> headers);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAll();
    public sealed virtual bool TryGetHeader(string key, Object& value);
    public sealed virtual T Get(string key, T defaultValue);
    public sealed virtual Nullable`1<T> Get(string key, Nullable`1<T> defaultValue);
    public sealed virtual IEnumerator`1<HeaderValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.Serialization : object {
    private IMessageDeserializer _defaultDeserializer;
    private IMessageSerializer _defaultSerializer;
    private IDictionary`2<string, IMessageDeserializer> _deserializers;
    private IDictionary`2<string, IMessageSerializer> _serializers;
    [CompilerGeneratedAttribute]
private ContentType <DefaultContentType>k__BackingField;
    public ContentType DefaultContentType { get; }
    public Serialization(IEnumerable`1<IMessageSerializer> serializers, ContentType serializerContentType, IEnumerable`1<IMessageDeserializer> deserializers, ContentType defaultContentType);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_DefaultContentType();
    public sealed virtual IMessageSerializer GetMessageSerializer(ContentType contentType);
    public sealed virtual bool TryGetMessageSerializer(ContentType contentType, IMessageSerializer& serializer);
    public sealed virtual IMessageDeserializer GetMessageDeserializer(ContentType contentType);
    public sealed virtual bool TryGetMessageDeserializer(ContentType contentType, IMessageDeserializer& deserializer);
    public sealed virtual void Probe(ProbeContext context);
}
public interface MassTransit.Serialization.SerializedMessage {
    public Uri Destination { get; }
    public string ContentType { get; }
    public string ExpirationTime { get; }
    public string ResponseAddress { get; }
    public string FaultAddress { get; }
    public string Body { get; }
    public string MessageId { get; }
    public string RequestId { get; }
    public string CorrelationId { get; }
    public string ConversationId { get; }
    public string InitiatorId { get; }
    public string HeadersAsJson { get; }
    public string PayloadMessageHeadersAsJson { get; }
    public abstract virtual Uri get_Destination();
    public abstract virtual string get_ContentType();
    public abstract virtual string get_ExpirationTime();
    public abstract virtual string get_ResponseAddress();
    public abstract virtual string get_FaultAddress();
    public abstract virtual string get_Body();
    public abstract virtual string get_MessageId();
    public abstract virtual string get_RequestId();
    public abstract virtual string get_CorrelationId();
    public abstract virtual string get_ConversationId();
    public abstract virtual string get_InitiatorId();
    public abstract virtual string get_HeadersAsJson();
    public abstract virtual string get_PayloadMessageHeadersAsJson();
}
public class MassTransit.Serialization.SerializedMessageBody : object {
}
public interface MassTransit.Serialization.SymmetricKey {
    public Byte[] Key { get; }
    public Byte[] IV { get; }
    public abstract virtual Byte[] get_Key();
    public abstract virtual Byte[] get_IV();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonBodyMessageSerializer : RawMessageSerializer {
    [NullableAttribute("2")]
private JsonMessageEnvelope _envelope;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private String[] _messageTypes;
    private JsonSerializerOptions _options;
    private Nullable`1<RawSerializerOptions> _rawOptions;
    [NullableAttribute("2")]
private object _message;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    public ContentType ContentType { get; }
    public SystemTextJsonBodyMessageSerializer(MessageEnvelope envelope, ContentType contentType, JsonSerializerOptions options, String[] messageTypes);
    public SystemTextJsonBodyMessageSerializer(object message, ContentType contentType, JsonSerializerOptions options, RawSerializerOptions rawOptions, String[] messageTypes);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_ContentType();
    public sealed virtual MessageBody GetMessageBody(SendContext`1<T> context);
    public void Overlay(object message);
    private static JsonNode Merge(JsonElement original, JsonElement overlay);
    private static JsonNode MergeObject(JsonElement original, JsonElement overlay);
    private static JsonNode MergeArray(JsonElement original, JsonElement overlay);
    [NullableContextAttribute("2")]
private static JsonNode ToNode(JsonElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonMessageBody`1 : object {
    private SendContext`1<TMessage> _context;
    private JsonSerializerOptions _options;
    [NullableAttribute("2")]
private Byte[] _bytes;
    [NullableAttribute("2")]
private MessageEnvelope _envelope;
    [NullableAttribute("2")]
private string _string;
    public Nullable`1<long> Length { get; }
    public SystemTextJsonMessageBody`1(SendContext`1<TMessage> context, JsonSerializerOptions options, MessageEnvelope envelope);
    public sealed virtual Nullable`1<long> get_Length();
    public sealed virtual Stream GetStream();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual string GetString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonMessageSerializer : object {
    public static ContentType JsonContentType;
    public static JsonSerializerOptions Options;
    public static SystemTextJsonMessageSerializer Instance;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    public ContentType ContentType { get; }
    private static SystemTextJsonMessageSerializer();
    [NullableContextAttribute("2")]
public SystemTextJsonMessageSerializer(ContentType contentType);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_ContentType();
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConsumeContext Deserialize(ReceiveContext receiveContext);
    public sealed virtual SerializerContext Deserialize(MessageBody body, Headers headers, Uri destinationAddress);
    public sealed virtual MessageBody GetMessageBody(string text);
    public sealed virtual MessageBody GetMessageBody(SendContext`1<T> context);
    [NullableContextAttribute("2")]
public sealed virtual T DeserializeObject(object value, T defaultValue);
    [NullableContextAttribute("0")]
public sealed virtual Nullable`1<T> DeserializeObject(object value, Nullable`1<T> defaultValue);
    public sealed virtual MessageBody SerializeObject(object value);
    private static T GetObject(JsonElement jsonElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonObjectMessageBody : object {
    private JsonSerializerOptions _options;
    private object _value;
    [NullableAttribute("2")]
private Byte[] _bytes;
    [NullableAttribute("2")]
private string _string;
    public Nullable`1<long> Length { get; }
    public SystemTextJsonObjectMessageBody(object value, JsonSerializerOptions options);
    public sealed virtual Nullable`1<long> get_Length();
    public sealed virtual Stream GetStream();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual string GetString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonRawMessageBody`1 : object {
    [NullableAttribute("2")]
private object _message;
    private JsonSerializerOptions _options;
    [NullableAttribute("2")]
private Byte[] _bytes;
    [NullableAttribute("2")]
private string _string;
    public Nullable`1<long> Length { get; }
    public SystemTextJsonRawMessageBody`1(SendContext`1<TMessage> context, JsonSerializerOptions options, object message);
    public sealed virtual Nullable`1<long> get_Length();
    public sealed virtual Stream GetStream();
    public sealed virtual Byte[] GetBytes();
    public sealed virtual string GetString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonRawMessageSerializer : RawMessageSerializer {
    public static ContentType JsonContentType;
    private RawSerializerOptions _options;
    public ContentType ContentType { get; }
    public SystemTextJsonRawMessageSerializer(RawSerializerOptions options);
    private static SystemTextJsonRawMessageSerializer();
    public sealed virtual ContentType get_ContentType();
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConsumeContext Deserialize(ReceiveContext receiveContext);
    public sealed virtual SerializerContext Deserialize(MessageBody body, Headers headers, Uri destinationAddress);
    public sealed virtual MessageBody GetMessageBody(string text);
    public sealed virtual MessageBody GetMessageBody(SendContext`1<T> context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonRawSerializerContext : SystemTextJsonSerializerContext {
    private RawSerializerOptions _rawOptions;
    public SystemTextJsonRawSerializerContext(IObjectDeserializer objectDeserializer, JsonSerializerOptions options, ContentType contentType, MessageContext messageContext, String[] messageTypes, RawSerializerOptions rawOptions, JsonElement message);
    public virtual IMessageSerializer GetMessageSerializer();
    public virtual bool IsSupportedMessageType();
    public virtual bool IsSupportedMessageType(Type messageType);
    public virtual IMessageSerializer GetMessageSerializer(object message, String[] messageTypes);
    public virtual IMessageSerializer GetMessageSerializer(MessageEnvelope envelope, T message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Serialization.SystemTextJsonSerializerContext : BaseSerializerContext {
    [NullableAttribute("2")]
private MessageEnvelope _envelope;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    protected object Message { get; }
    protected ContentType ContentType { get; }
    protected JsonSerializerOptions Options { get; }
    public SystemTextJsonSerializerContext(IObjectDeserializer objectDeserializer, JsonSerializerOptions options, ContentType contentType, MessageContext messageContext, String[] messageTypes, MessageEnvelope envelope, object message);
    [CompilerGeneratedAttribute]
protected object get_Message();
    [CompilerGeneratedAttribute]
protected ContentType get_ContentType();
    [CompilerGeneratedAttribute]
protected JsonSerializerOptions get_Options();
    public virtual bool TryGetMessage(T& message);
    public virtual bool TryGetMessage(Type messageType, Object& message);
    public virtual IMessageSerializer GetMessageSerializer();
    public virtual IMessageSerializer GetMessageSerializer(MessageEnvelope envelope, T message);
    public virtual IMessageSerializer GetMessageSerializer(object message, String[] messageTypes);
    public virtual Dictionary`2<string, object> ToDictionary(T message);
    private static JsonElement GetJsonElement(object message);
}
[ExtensionAttribute]
public static class MassTransit.ServiceInstanceConfigurationExtensions : object {
    [ExtensionAttribute]
public static void ServiceInstance(IBusFactoryConfigurator`1<TEndpointConfigurator> configurator, Action`1<IServiceInstanceConfigurator`1<TEndpointConfigurator>> configure);
    [ExtensionAttribute]
public static void ServiceInstance(IBusFactoryConfigurator`1<TEndpointConfigurator> configurator, ServiceInstanceOptions options, Action`1<IServiceInstanceConfigurator`1<TEndpointConfigurator>> configure);
}
public class MassTransit.ServiceInstanceOptions : OptionsSet {
    [CompilerGeneratedAttribute]
private IEndpointNameFormatter <EndpointNameFormatter>k__BackingField;
    public IEndpointNameFormatter EndpointNameFormatter { get; private set; }
    [CompilerGeneratedAttribute]
public IEndpointNameFormatter get_EndpointNameFormatter();
    [CompilerGeneratedAttribute]
private void set_EndpointNameFormatter(IEndpointNameFormatter value);
    public ServiceInstanceOptions EnableJobServiceEndpoints();
    public ServiceInstanceOptions SetEndpointNameFormatter(IEndpointNameFormatter endpointNameFormatter);
}
[ExtensionAttribute]
public static class MassTransit.SetSerializerSendConventionExtensions : object {
    [ExtensionAttribute]
public static void UseSerializer(IMessageSendTopologyConfigurator`1<T> configurator, ContentType contentType);
    [ExtensionAttribute]
public static void UseSerializer(IMessageSendTopologyConfigurator`1<T> configurator, string contentType);
}
public class MassTransit.SnakeCaseEndpointNameFormatter : DefaultEndpointNameFormatter {
    protected static char SnakeCaseSeparator;
    private static Regex _pattern;
    private char _separator;
    [CompilerGeneratedAttribute]
private static IEndpointNameFormatter <Instance>k__BackingField;
    public static IEndpointNameFormatter Instance { get; }
    public SnakeCaseEndpointNameFormatter(bool includeNamespace);
    public SnakeCaseEndpointNameFormatter(string prefix, bool includeNamespace);
    public SnakeCaseEndpointNameFormatter(string prefix);
    public SnakeCaseEndpointNameFormatter(char separator, string prefix, bool includeNamespace);
    private static SnakeCaseEndpointNameFormatter();
    [CompilerGeneratedAttribute]
public static IEndpointNameFormatter get_Instance();
    public virtual string SanitizeName(string name);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private string <SanitizeName>b__11_0(Match m);
}
public static class MassTransit.SqlBusFactory : object {
    public static IBusControl Create(Action`1<ISqlBusFactoryConfigurator> configure);
    public static IMessageTopologyConfigurator CreateMessageTopology();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.SqlEndpointAddress : ValueType {
    private static string InstanceNameKey;
    private static string AutoDeleteKey;
    private static string TypeKey;
    private static ITypeConverter`2<AddressType, string> _parseConverter;
    public string Scheme;
    public string Host;
    [NullableAttribute("2")]
public string InstanceName;
    public Nullable`1<int> Port;
    public string VirtualHost;
    [NullableAttribute("2")]
public string Area;
    public string Name;
    public Nullable`1<TimeSpan> AutoDeleteOnIdle;
    public AddressType Type;
    private Uri DebuggerDisplay { get; }
    public SqlEndpointAddress(Uri hostAddress, Uri address, AddressType type);
    public SqlEndpointAddress(Uri hostAddress, string name, Nullable`1<TimeSpan> autoDeleteOnIdle, AddressType type);
    private static SqlEndpointAddress();
    private static void ParseLeft(Uri address, String& scheme, String& host, String& instanceName, Nullable`1& port, String& virtualHost, String& area);
    public static Uri op_Implicit(SqlEndpointAddress& address);
    private Uri get_DebuggerDisplay();
    [IteratorStateMachineAttribute("MassTransit.SqlEndpointAddress/<GetQueryStringOptions>d__20")]
private IEnumerable`1<string> GetQueryStringOptions();
}
public class MassTransit.SqlEndpointAddressException : AbstractUriException {
    public SqlEndpointAddressException(Uri address, string message);
    public SqlEndpointAddressException(Uri address, string message, Exception innerException);
    public SqlEndpointAddressException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class MassTransit.SqlHostAddress : ValueType {
    public static string DbScheme;
    private static string InstanceNameKey;
    public string Scheme;
    public string Host;
    public Nullable`1<int> Port;
    [NullableAttribute("2")]
public string InstanceName;
    public string VirtualHost;
    [NullableAttribute("2")]
public string Area;
    private Uri DebuggerDisplay { get; }
    public SqlHostAddress(Uri address);
    public SqlHostAddress(string host, string instanceName, Nullable`1<int> port, string virtualHost, string area);
    internal static void ParseLeft(Uri address, String& scheme, String& host, Nullable`1& port, String& virtualHost, String& area);
    private static ValueTuple`2<string, string> GetVirtualHostAndArea(Uri address);
    public static Uri op_Implicit(SqlHostAddress& address);
    private Uri get_DebuggerDisplay();
    [IteratorStateMachineAttribute("MassTransit.SqlHostAddress/<GetQueryStringOptions>d__15")]
private IEnumerable`1<string> GetQueryStringOptions();
    [NullableContextAttribute("2")]
private static bool IsValidSymbol(string className);
}
[NullableContextAttribute("2")]
public interface MassTransit.SqlHostSettings {
    [NullableAttribute("1")]
public Uri HostAddress { get; }
    public string ConnectionTag { get; }
    public string VirtualHost { get; }
    public string Area { get; }
    public IsolationLevel IsolationLevel { get; }
    public int ConnectionLimit { get; }
    public TimeSpan MaintenanceInterval { get; }
    public TimeSpan QueueCleanupInterval { get; }
    public int MaintenanceBatchSize { get; }
    [NullableContextAttribute("1")]
public abstract virtual Uri get_HostAddress();
    public abstract virtual string get_ConnectionTag();
    public abstract virtual string get_VirtualHost();
    public abstract virtual string get_Area();
    public abstract virtual IsolationLevel get_IsolationLevel();
    public abstract virtual int get_ConnectionLimit();
    public abstract virtual TimeSpan get_MaintenanceInterval();
    public abstract virtual TimeSpan get_QueueCleanupInterval();
    public abstract virtual int get_MaintenanceBatchSize();
    [NullableContextAttribute("1")]
public abstract virtual ConnectionContextFactory CreateConnectionContextFactory(ISqlHostConfiguration configuration);
    public abstract virtual LicenseInfo GetLicenseInfo();
}
public interface MassTransit.SqlMessageContext {
    public SqlTransportMessage TransportMessage { get; }
    public Guid TransportMessageId { get; }
    public long DeliveryMessageId { get; }
    public string QueueName { get; }
    public Nullable`1<Guid> ConsumerId { get; }
    public Nullable`1<Guid> LockId { get; }
    public short Priority { get; }
    public DateTime EnqueueTime { get; }
    public int DeliveryCount { get; }
    public abstract virtual SqlTransportMessage get_TransportMessage();
    public abstract virtual Guid get_TransportMessageId();
    public abstract virtual long get_DeliveryMessageId();
    public abstract virtual string get_QueueName();
    public abstract virtual Nullable`1<Guid> get_ConsumerId();
    public abstract virtual Nullable`1<Guid> get_LockId();
    public abstract virtual short get_Priority();
    public abstract virtual DateTime get_EnqueueTime();
    public abstract virtual int get_DeliveryCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.SqlPublishTopologyConfigurationExtensions : object {
    [ExtensionAttribute]
public static void AddPublishMessageTypesFromNamespaceContaining(ISqlBusFactoryConfigurator configurator, Action`2<ISqlMessagePublishTopologyConfigurator, Type> configure, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddPublishMessageTypesFromNamespaceContaining(ISqlBusFactoryConfigurator configurator, Type type, Action`2<ISqlMessagePublishTopologyConfigurator, Type> configure, Func`2<Type, bool> filter);
    [ExtensionAttribute]
public static void AddPublishMessageTypes(ISqlBusFactoryConfigurator configurator, IEnumerable`1<Type> messageTypes, Action`2<ISqlMessagePublishTopologyConfigurator, Type> configure);
}
public enum MassTransit.SqlQueueType : Enum {
    public int value__;
    public static SqlQueueType Queue;
    public static SqlQueueType ErrorQueue;
    public static SqlQueueType DeadLetterQueue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.SqlReceiveEndpointConfigurationExtensions : object {
    [ExtensionAttribute]
public static void ReceiveEndpoint(ISqlBusFactoryConfigurator configurator, Action`1<ISqlReceiveEndpointConfigurator> configure);
    [ExtensionAttribute]
public static void ReceiveEndpoint(ISqlBusFactoryConfigurator configurator, IEndpointDefinition definition, Action`1<ISqlReceiveEndpointConfigurator> configure);
}
public enum MassTransit.SqlReceiveMode : Enum {
    public int value__;
    public static SqlReceiveMode Normal;
    public static SqlReceiveMode Partitioned;
    public static SqlReceiveMode PartitionedConcurrent;
    public static SqlReceiveMode PartitionedOrdered;
    public static SqlReceiveMode PartitionedOrderedConcurrent;
}
[ExtensionAttribute]
public static class MassTransit.SqlScheduleMessageExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use the renamed UseSqlMessageScheduler instead")]
public static void UseDbMessageScheduler(IBusFactoryConfigurator configurator);
    [ExtensionAttribute]
public static void UseSqlMessageScheduler(IBusFactoryConfigurator configurator);
    [ExtensionAttribute]
public static void AddSqlMessageScheduler(IBusRegistrationConfigurator configurator);
    [ExtensionAttribute]
public static void AddSqlMessageScheduler(IBusRegistrationConfigurator`1<TBus> configurator);
}
public interface MassTransit.SqlSendContext {
    public Guid TransportMessageId { get; }
    unknown Nullable`1<short> Priority {public set; }
    public abstract virtual Guid get_TransportMessageId();
    public abstract virtual void set_Priority(Nullable`1<short> value);
}
public interface MassTransit.SqlSendContext`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.SqlSendContextExtensions : object {
    [ExtensionAttribute]
public static void SetPriority(SendContext context, short priority);
    [ExtensionAttribute]
public static bool TrySetPriority(SendContext context, short priority);
}
public enum MassTransit.SqlSubscriptionType : Enum {
    public int value__;
    public static SqlSubscriptionType All;
    public static SqlSubscriptionType RoutingKey;
    public static SqlSubscriptionType Pattern;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.SqlTopologyException : MassTransitException {
    public SqlTopologyException(string message);
    public SqlTopologyException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected SqlTopologyException(SerializationInfo info, StreamingContext context);
}
public interface MassTransit.SqlTransport.ClientContext {
    public ConnectionContext ConnectionContext { get; }
    public abstract virtual ConnectionContext get_ConnectionContext();
    public abstract virtual Task`1<long> CreateQueue(Queue queue);
    public abstract virtual Task`1<long> CreateTopic(Topic topic);
    public abstract virtual Task`1<long> CreateTopicSubscription(TopicToTopicSubscription subscription);
    public abstract virtual Task`1<long> CreateQueueSubscription(TopicToQueueSubscription subscription);
    public abstract virtual Task`1<long> PurgeQueue(string queueName, CancellationToken cancellationToken);
    public abstract virtual Task Send(string queueName, SqlMessageSendContext`1<T> context);
    public abstract virtual Task Publish(string topicName, SqlMessageSendContext`1<T> context);
    public abstract virtual Task`1<IEnumerable`1<SqlTransportMessage>> ReceiveMessages(string queueName, SqlReceiveMode mode, int messageLimit, int concurrentCount, TimeSpan lockDuration);
    public abstract virtual Task`1<bool> DeleteMessage(Guid lockId, long messageDeliveryId);
    public abstract virtual Task`1<bool> DeleteScheduledMessage(Guid tokenId, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> MoveMessage(Guid lockId, long messageDeliveryId, string queueName, SqlQueueType queueType, SendHeaders sendHeaders);
    public abstract virtual Task`1<bool> RenewLock(Guid lockId, long messageDeliveryId, TimeSpan duration);
    public abstract virtual Task`1<bool> Unlock(Guid lockId, long messageDeliveryId, TimeSpan delay, SendHeaders sendHeaders);
}
public class MassTransit.SqlTransport.ClientContextSupervisor : TransportPipeContextSupervisor`1<ClientContext> {
    public ClientContextSupervisor(IConnectionContextSupervisor connectionContextSupervisor);
    public ClientContextSupervisor(IClientContextSupervisor clientContextSupervisor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class MassTransit.SqlTransport.Configuration.ConfigurationSqlHostSettings : object {
    [NullableAttribute("1")]
private Lazy`1<Uri> _hostAddress;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolationLevel <IsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaintenanceInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <QueueCleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaintenanceBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VirtualHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Area>k__BackingField;
    public string Host { get; public set; }
    public string InstanceName { get; public set; }
    public Nullable`1<int> Port { get; public set; }
    public string Database { get; public set; }
    public string Schema { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string License { get; public set; }
    public string LicenseFile { get; public set; }
    public IsolationLevel IsolationLevel { get; public set; }
    public int ConnectionLimit { get; public set; }
    public TimeSpan MaintenanceInterval { get; public set; }
    public TimeSpan QueueCleanupInterval { get; public set; }
    public int MaintenanceBatchSize { get; public set; }
    public string ConnectionTag { get; public set; }
    public string VirtualHost { get; public set; }
    public string Area { get; public set; }
    [NullableAttribute("1")]
public Uri HostAddress { get; }
    [NullableContextAttribute("1")]
protected ConfigurationSqlHostSettings(Uri address);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public string get_InstanceName();
    [CompilerGeneratedAttribute]
public void set_InstanceName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public void set_License(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseFile();
    [CompilerGeneratedAttribute]
public void set_LicenseFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IsolationLevel get_IsolationLevel();
    [CompilerGeneratedAttribute]
public void set_IsolationLevel(IsolationLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ConnectionLimit();
    [CompilerGeneratedAttribute]
public void set_ConnectionLimit(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_MaintenanceInterval();
    [CompilerGeneratedAttribute]
public void set_MaintenanceInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_QueueCleanupInterval();
    [CompilerGeneratedAttribute]
public void set_QueueCleanupInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaintenanceBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaintenanceBatchSize(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConnectionTag();
    [CompilerGeneratedAttribute]
public void set_ConnectionTag(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VirtualHost();
    [CompilerGeneratedAttribute]
public void set_VirtualHost(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Area();
    [CompilerGeneratedAttribute]
public void set_Area(string value);
    [NullableContextAttribute("1")]
public abstract virtual ConnectionContextFactory CreateConnectionContextFactory(ISqlHostConfiguration configuration);
    public sealed virtual LicenseInfo GetLicenseInfo();
    [NullableContextAttribute("1")]
public sealed virtual Uri get_HostAddress();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.ConfigurationSqlHostSettings/<Validate>d__75")]
public virtual IEnumerable`1<ValidationResult> Validate();
    [NullableContextAttribute("1")]
private static string UriDecode(string uri);
    [NullableContextAttribute("1")]
private Uri FormatHostAddress();
}
public class MassTransit.SqlTransport.Configuration.InvalidSqlConsumeTopologySpecification : object {
    private string _key;
    private string _message;
    public InvalidSqlConsumeTopologySpecification(string key, string message);
    [IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.InvalidSqlConsumeTopologySpecification/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.SqlTransport.Configuration.ISqlBusConfiguration {
    public ISqlHostConfiguration HostConfiguration { get; }
    public ISqlEndpointConfiguration BusEndpointConfiguration { get; }
    public ISqlTopologyConfiguration Topology { get; }
    public abstract virtual ISqlHostConfiguration get_HostConfiguration();
    public abstract virtual ISqlEndpointConfiguration get_BusEndpointConfiguration();
    public abstract virtual ISqlTopologyConfiguration get_Topology();
    public abstract virtual ISqlEndpointConfiguration CreateEndpointConfiguration(bool isBusEndpoint);
}
public interface MassTransit.SqlTransport.Configuration.ISqlConsumeTopologySpecification {
    public abstract virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.SqlTransport.Configuration.ISqlEndpointConfiguration {
    public ISqlTopologyConfiguration Topology { get; }
    public abstract virtual ISqlTopologyConfiguration get_Topology();
}
[NullableContextAttribute("1")]
public interface MassTransit.SqlTransport.Configuration.ISqlHostConfiguration {
    public IConnectionContextSupervisor ConnectionContextSupervisor { get; }
    public SqlHostSettings Settings { get; public set; }
    public ISqlBusTopology Topology { get; }
    public abstract virtual IConnectionContextSupervisor get_ConnectionContextSupervisor();
    public abstract virtual SqlHostSettings get_Settings();
    public abstract virtual void set_Settings(SqlHostSettings value);
    public abstract virtual ISqlBusTopology get_Topology();
    public abstract virtual void ApplyEndpointDefinition(ISqlReceiveEndpointConfigurator configurator, IEndpointDefinition definition);
    public abstract virtual ISqlReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<ISqlReceiveEndpointConfigurator> configure);
    public abstract virtual ISqlReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(SqlReceiveSettings settings, ISqlEndpointConfiguration endpointConfiguration, Action`1<ISqlReceiveEndpointConfigurator> configure);
}
public interface MassTransit.SqlTransport.Configuration.ISqlPublishTopologySpecification {
    public abstract virtual void Apply(IPublishEndpointBrokerTopologyBuilder builder);
}
public interface MassTransit.SqlTransport.Configuration.ISqlReceiveEndpointConfiguration {
    public ReceiveSettings Settings { get; }
    public abstract virtual ReceiveSettings get_Settings();
    public abstract virtual void Build(IHost host);
}
public interface MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration {
    public ISqlPublishTopologyConfigurator Publish { get; }
    public ISqlSendTopologyConfigurator Send { get; }
    public ISqlConsumeTopologyConfigurator Consume { get; }
    public abstract virtual ISqlPublishTopologyConfigurator get_Publish();
    public abstract virtual ISqlSendTopologyConfigurator get_Send();
    public abstract virtual ISqlConsumeTopologyConfigurator get_Consume();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Configuration.QueueSubscriptionConsumeTopologySpecification : SqlTopicSubscriptionConfigurator {
    public QueueSubscriptionConsumeTopologySpecification(string topicName, SqlSubscriptionType subscriptionType, string routingKey);
    public QueueSubscriptionConsumeTopologySpecification(Topic topic, SqlSubscriptionType subscriptionType, string routingKey);
    [IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.QueueSubscriptionConsumeTopologySpecification/<Validate>d__2")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
}
public class MassTransit.SqlTransport.Configuration.SqlBusConfiguration : SqlEndpointConfiguration {
    private BusObservable _busObservers;
    [CompilerGeneratedAttribute]
private ISqlEndpointConfiguration <BusEndpointConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlHostConfiguration <HostConfiguration>k__BackingField;
    private IHostConfiguration MassTransit.Configuration.IBusConfiguration.HostConfiguration { get; }
    private IEndpointConfiguration MassTransit.Configuration.IBusConfiguration.BusEndpointConfiguration { get; }
    private IBusObserver MassTransit.Configuration.IBusConfiguration.BusObservers { get; }
    public ISqlEndpointConfiguration BusEndpointConfiguration { get; }
    public ISqlHostConfiguration HostConfiguration { get; }
    public SqlBusConfiguration(ISqlTopologyConfiguration topologyConfiguration);
    private sealed virtual override IHostConfiguration MassTransit.Configuration.IBusConfiguration.get_HostConfiguration();
    private sealed virtual override IEndpointConfiguration MassTransit.Configuration.IBusConfiguration.get_BusEndpointConfiguration();
    private sealed virtual override IBusObserver MassTransit.Configuration.IBusConfiguration.get_BusObservers();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlEndpointConfiguration get_BusEndpointConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlHostConfiguration get_HostConfiguration();
    public sealed virtual ConnectHandle ConnectBusObserver(IBusObserver observer);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
}
public class MassTransit.SqlTransport.Configuration.SqlBusFactoryConfigurator : BusFactoryConfigurator {
    [NullableAttribute("1")]
private ISqlBusConfiguration _busConfiguration;
    [NullableAttribute("1")]
private ISqlHostConfiguration _hostConfiguration;
    [NullableAttribute("1")]
private SqlReceiveSettings _settings;
    unknown Nullable`1<TimeSpan> AutoDeleteOnIdle {public set; }
    unknown TimeSpan PollingInterval {public set; }
    unknown TimeSpan LockDuration {public set; }
    unknown TimeSpan MaxLockDuration {public set; }
    unknown int MaxDeliveryCount {public set; }
    unknown bool PurgeOnStartup {public set; }
    [NullableAttribute("1")]
public ISqlSendTopologyConfigurator SendTopology { get; }
    [NullableAttribute("1")]
public ISqlPublishTopologyConfigurator PublishTopology { get; }
    [NullableContextAttribute("1")]
public SqlBusFactoryConfigurator(ISqlBusConfiguration busConfiguration);
    [NullableContextAttribute("1")]
public sealed virtual IReceiveEndpointConfiguration CreateBusEndpointConfiguration(Action`1<IReceiveEndpointConfigurator> configure);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.SqlBusFactoryConfigurator/<Validate>d__5")]
public virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void set_AutoDeleteOnIdle(Nullable`1<TimeSpan> value);
    public sealed virtual void set_PollingInterval(TimeSpan value);
    public sealed virtual void set_LockDuration(TimeSpan value);
    public sealed virtual void set_MaxLockDuration(TimeSpan value);
    public sealed virtual void set_MaxDeliveryCount(int value);
    public sealed virtual void set_PurgeOnStartup(bool value);
    [NullableContextAttribute("1")]
public sealed virtual void Host(SqlHostSettings settings);
    [NullableContextAttribute("1")]
public sealed virtual void Send(Action`1<ISqlMessageSendTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public sealed virtual void Publish(Action`1<ISqlMessagePublishTopologyConfigurator`1<T>> configureTopology);
    [NullableContextAttribute("1")]
public sealed virtual void Publish(Type messageType, Action`1<ISqlMessagePublishTopologyConfigurator> configure);
    [NullableContextAttribute("1")]
public sealed virtual ISqlSendTopologyConfigurator get_SendTopology();
    [NullableContextAttribute("1")]
public sealed virtual ISqlPublishTopologyConfigurator get_PublishTopology();
    [NullableContextAttribute("1")]
public sealed virtual void OverrideDefaultBusEndpointQueueName(string queueName);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<ISqlReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(string queueName, Action`1<ISqlReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void ReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationResult> <>n__0();
}
public class MassTransit.SqlTransport.Configuration.SqlEndpointConfiguration : EndpointConfiguration {
    [CompilerGeneratedAttribute]
private ISqlTopologyConfiguration <Topology>k__BackingField;
    public ISqlTopologyConfiguration Topology { get; }
    public SqlEndpointConfiguration(ISqlTopologyConfiguration topologyConfiguration);
    private SqlEndpointConfiguration(IEndpointConfiguration parentConfiguration, ISqlTopologyConfiguration topologyConfiguration, bool isBusEndpoint);
    [CompilerGeneratedAttribute]
public sealed virtual ISqlTopologyConfiguration get_Topology();
    public sealed virtual ISqlEndpointConfiguration CreateEndpointConfiguration(bool isBusEndpoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.Configuration.SqlHostConfiguration : BaseHostConfiguration`2<ISqlReceiveEndpointConfiguration, ISqlReceiveEndpointConfigurator> {
    private ISqlBusConfiguration _busConfiguration;
    private Recycle`1<IConnectionContextSupervisor> _connectionContext;
    private ISqlBusTopology _topology;
    [NullableAttribute("2")]
private SqlHostSettings _hostSettings;
    [NullableAttribute("2")]
private LicenseInfo _licenseInfo;
    [CompilerGeneratedAttribute]
private IRetryPolicy <ReceiveTransportRetryPolicy>k__BackingField;
    public IConnectionContextSupervisor ConnectionContextSupervisor { get; }
    public Uri HostAddress { get; }
    private ISqlBusTopology MassTransit.SqlTransport.Configuration.ISqlHostConfiguration.Topology { get; }
    public IRetryPolicy ReceiveTransportRetryPolicy { get; }
    public IBusTopology Topology { get; }
    public SqlHostSettings Settings { get; public set; }
    public SqlHostConfiguration(ISqlBusConfiguration busConfiguration, ISqlTopologyConfiguration topologyConfiguration);
    public sealed virtual IConnectionContextSupervisor get_ConnectionContextSupervisor();
    public virtual Uri get_HostAddress();
    private sealed virtual override ISqlBusTopology MassTransit.SqlTransport.Configuration.ISqlHostConfiguration.get_Topology();
    [CompilerGeneratedAttribute]
public virtual IRetryPolicy get_ReceiveTransportRetryPolicy();
    public virtual IBusTopology get_Topology();
    public sealed virtual SqlHostSettings get_Settings();
    public sealed virtual void set_Settings(SqlHostSettings value);
    public sealed virtual void ApplyEndpointDefinition(ISqlReceiveEndpointConfigurator configurator, IEndpointDefinition definition);
    public sealed virtual ISqlReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<ISqlReceiveEndpointConfigurator> configure);
    public sealed virtual ISqlReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(SqlReceiveSettings settings, ISqlEndpointConfiguration endpointConfiguration, Action`1<ISqlReceiveEndpointConfigurator> configure);
    public virtual void ReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<ISqlReceiveEndpointConfigurator> configureEndpoint);
    public virtual void ReceiveEndpoint(string queueName, Action`1<ISqlReceiveEndpointConfigurator> configureEndpoint);
    [IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.SqlHostConfiguration/<Validate>d__25")]
public virtual IEnumerable`1<ValidationResult> Validate();
    public virtual IReceiveEndpointConfiguration CreateReceiveEndpointConfiguration(string queueName, Action`1<IReceiveEndpointConfigurator> configure);
    public virtual IHost Build();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationResult> <>n__0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class MassTransit.SqlTransport.Configuration.SqlHostConfigurator : object {
    [NullableAttribute("1")]
private ConfigurationSqlHostSettings _settings;
    unknown string ConnectionString {public set; }
    unknown string ConnectionTag {public set; }
    unknown string Host {public set; }
    unknown string InstanceName {public set; }
    unknown Nullable`1<int> Port {public set; }
    unknown string Database {public set; }
    unknown string Schema {public set; }
    unknown string Username {public set; }
    unknown string Password {public set; }
    unknown string VirtualHost {public set; }
    unknown string Area {public set; }
    unknown IsolationLevel IsolationLevel {public set; }
    unknown int ConnectionLimit {public set; }
    unknown TimeSpan MaintenanceInterval {public set; }
    unknown TimeSpan QueueCleanupInterval {public set; }
    unknown int MaintenanceBatchSize {public set; }
    [NullableContextAttribute("1")]
protected SqlHostConfigurator(ConfigurationSqlHostSettings settings);
    public abstract virtual void set_ConnectionString(string value);
    public sealed virtual void set_ConnectionTag(string value);
    public sealed virtual void set_Host(string value);
    public sealed virtual void set_InstanceName(string value);
    public sealed virtual void set_Port(Nullable`1<int> value);
    public sealed virtual void set_Database(string value);
    public sealed virtual void set_Schema(string value);
    public sealed virtual void set_Username(string value);
    public sealed virtual void set_Password(string value);
    public sealed virtual void set_VirtualHost(string value);
    public sealed virtual void set_Area(string value);
    public sealed virtual void set_IsolationLevel(IsolationLevel value);
    public sealed virtual void set_ConnectionLimit(int value);
    public sealed virtual void set_MaintenanceInterval(TimeSpan value);
    public sealed virtual void set_QueueCleanupInterval(TimeSpan value);
    public sealed virtual void set_MaintenanceBatchSize(int value);
    [NullableContextAttribute("1")]
public sealed virtual void UseLicense(string license);
    [NullableContextAttribute("1")]
public sealed virtual void UseLicenseFile(string path);
}
public class MassTransit.SqlTransport.Configuration.SqlMessageSchedulerSpecification : object {
    public sealed virtual void Apply(IPipeBuilder`1<ConsumeContext> builder);
    [IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.SqlMessageSchedulerSpecification/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.SqlTransport.Configuration.SqlQueueConfigurator : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <AutoDeleteOnIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    public Nullable`1<TimeSpan> AutoDeleteOnIdle { get; public set; }
    public string QueueName { get; public set; }
    protected SqlQueueConfigurator(string queueName, Nullable`1<TimeSpan> autoDeleteOnIdle);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_AutoDeleteOnIdle();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AutoDeleteOnIdle(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_QueueName();
    [CompilerGeneratedAttribute]
public void set_QueueName(string value);
    protected SqlEndpointAddress GetEndpointAddress(Uri hostAddress);
}
public class MassTransit.SqlTransport.Configuration.SqlQueueSubscriptionConfigurator : SqlTopicSubscriptionConfigurator {
    [NullableContextAttribute("1")]
protected SqlQueueSubscriptionConfigurator(string topicName, SqlSubscriptionType subscriptionType, Nullable`1<TimeSpan> autoDeleteOnIdle, string routingKey);
}
public class MassTransit.SqlTransport.Configuration.SqlReceiveEndpointBuilder : ReceiveEndpointBuilder {
    private ISqlReceiveEndpointConfiguration _configuration;
    private ISqlHostConfiguration _hostConfiguration;
    public SqlReceiveEndpointBuilder(ISqlHostConfiguration hostConfiguration, ISqlReceiveEndpointConfiguration configuration);
    public virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public SqlReceiveEndpointContext CreateReceiveEndpointContext();
    private IErrorTransport CreateErrorTransport();
    private IDeadLetterTransport CreateDeadLetterTransport();
    private BrokerTopology BuildTopology(ReceiveSettings settings);
}
public class MassTransit.SqlTransport.Configuration.SqlReceiveEndpointConfiguration : ReceiveEndpointConfiguration {
    [NullableAttribute("1")]
private static Regex _regex;
    [NullableAttribute("1")]
private IBuildPipeConfigurator`1<ClientContext> _clientConfigurator;
    [NullableAttribute("1")]
private ISqlEndpointConfiguration _endpointConfiguration;
    [NullableAttribute("1")]
private ISqlHostConfiguration _hostConfiguration;
    [NullableAttribute("1")]
private Lazy`1<Uri> _inputAddress;
    [NullableAttribute("1")]
private SqlReceiveSettings _settings;
    [NullableAttribute("1")]
public ReceiveSettings Settings { get; }
    [NullableAttribute("1")]
public Uri HostAddress { get; }
    [NullableAttribute("1")]
public Uri InputAddress { get; }
    [NullableAttribute("1")]
private ISqlTopologyConfiguration MassTransit.SqlTransport.Configuration.ISqlEndpointConfiguration.Topology { get; }
    unknown Nullable`1<TimeSpan> AutoDeleteOnIdle {public set; }
    unknown TimeSpan PollingInterval {public set; }
    unknown TimeSpan LockDuration {public set; }
    unknown TimeSpan MaxLockDuration {public set; }
    unknown int MaxDeliveryCount {public set; }
    unknown bool PurgeOnStartup {public set; }
    unknown Nullable`1<TimeSpan> UnlockDelay {public set; }
    unknown int ConcurrentDeliveryLimit {public set; }
    [NullableContextAttribute("1")]
public SqlReceiveEndpointConfiguration(ISqlHostConfiguration hostConfiguration, SqlReceiveSettings settings, ISqlEndpointConfiguration endpointConfiguration);
    private static SqlReceiveEndpointConfiguration();
    [NullableContextAttribute("1")]
public sealed virtual ReceiveSettings get_Settings();
    [NullableContextAttribute("1")]
public virtual Uri get_HostAddress();
    [NullableContextAttribute("1")]
public virtual Uri get_InputAddress();
    [NullableContextAttribute("1")]
public virtual ReceiveEndpointContext CreateReceiveEndpointContext();
    [NullableContextAttribute("1")]
private sealed virtual override ISqlTopologyConfiguration MassTransit.SqlTransport.Configuration.ISqlEndpointConfiguration.get_Topology();
    [NullableContextAttribute("1")]
public sealed virtual void Build(IHost host);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.SqlReceiveEndpointConfiguration/<Validate>d__17")]
public virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void set_AutoDeleteOnIdle(Nullable`1<TimeSpan> value);
    public sealed virtual void set_PollingInterval(TimeSpan value);
    public sealed virtual void set_LockDuration(TimeSpan value);
    public sealed virtual void set_MaxLockDuration(TimeSpan value);
    public sealed virtual void set_MaxDeliveryCount(int value);
    public sealed virtual void set_PurgeOnStartup(bool value);
    [NullableContextAttribute("1")]
public sealed virtual void Subscribe(string topicName, Action`1<ISqlTopicSubscriptionConfigurator> callback);
    public sealed virtual void set_UnlockDelay(Nullable`1<TimeSpan> value);
    public sealed virtual void set_ConcurrentDeliveryLimit(int value);
    [NullableContextAttribute("1")]
public sealed virtual void Subscribe(Action`1<ISqlTopicSubscriptionConfigurator> callback);
    public sealed virtual void SetReceiveMode(SqlReceiveMode mode, Nullable`1<int> concurrentDeliveryLimit);
    public sealed virtual void ConfigureClient(Action`1<IPipeConfigurator`1<ClientContext>> configure);
    [NullableContextAttribute("1")]
private static bool IsValidEntityName(string name);
    [NullableContextAttribute("1")]
private SqlReceiveEndpointContext CreateDbReceiveEndpointContext();
    [NullableContextAttribute("1")]
private Uri FormatInputAddress();
    protected virtual bool IsAlreadyConfigured();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValidationResult> <>n__0();
}
public class MassTransit.SqlTransport.Configuration.SqlReceiveSettings : SqlQueueConfigurator {
    private ISqlEndpointConfiguration _configuration;
    private int _concurrentDeliveryLimit;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueId>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlReceiveMode <ReceiveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PurgeOnStartup>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LockDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PollingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <UnlockDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxLockDuration>k__BackingField;
    public Nullable`1<long> QueueId { get; public set; }
    public int PrefetchCount { get; }
    public int ConcurrentMessageLimit { get; }
    public int ConcurrentDeliveryLimit { get; public set; }
    public SqlReceiveMode ReceiveMode { get; public set; }
    public bool PurgeOnStartup { get; public set; }
    public TimeSpan LockDuration { get; public set; }
    public int MaxDeliveryCount { get; public set; }
    public TimeSpan PollingInterval { get; public set; }
    public Nullable`1<TimeSpan> UnlockDelay { get; public set; }
    public TimeSpan MaxLockDuration { get; public set; }
    public string EntityName { get; }
    public SqlReceiveSettings(ISqlEndpointConfiguration configuration, string queueName, Nullable`1<TimeSpan> autoDeleteOnIdle);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_QueueId();
    [CompilerGeneratedAttribute]
public void set_QueueId(Nullable`1<long> value);
    public sealed virtual int get_PrefetchCount();
    public sealed virtual int get_ConcurrentMessageLimit();
    public sealed virtual int get_ConcurrentDeliveryLimit();
    public void set_ConcurrentDeliveryLimit(int value);
    [CompilerGeneratedAttribute]
public sealed virtual SqlReceiveMode get_ReceiveMode();
    [CompilerGeneratedAttribute]
public void set_ReceiveMode(SqlReceiveMode value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PurgeOnStartup();
    [CompilerGeneratedAttribute]
public void set_PurgeOnStartup(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_LockDuration();
    [CompilerGeneratedAttribute]
public void set_LockDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxDeliveryCount();
    [CompilerGeneratedAttribute]
public void set_MaxDeliveryCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_PollingInterval();
    [CompilerGeneratedAttribute]
public void set_PollingInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_UnlockDelay();
    [CompilerGeneratedAttribute]
public void set_UnlockDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_MaxLockDuration();
    [CompilerGeneratedAttribute]
public void set_MaxLockDuration(TimeSpan value);
    public sealed virtual string get_EntityName();
    public Uri GetInputAddress(Uri hostAddress);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.Configuration.SqlRegistrationBusFactory : TransportRegistrationBusFactory`1<ISqlReceiveEndpointConfigurator> {
    private SqlBusConfiguration _busConfiguration;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<IBusRegistrationContext, ISqlBusFactoryConfigurator> _configure;
    public SqlRegistrationBusFactory(Action`2<IBusRegistrationContext, ISqlBusFactoryConfigurator> configure);
    private SqlRegistrationBusFactory(SqlBusConfiguration busConfiguration, Action`2<IBusRegistrationContext, ISqlBusFactoryConfigurator> configure);
    public virtual IBusInstance CreateBus(IBusRegistrationContext context, IEnumerable`1<IBusInstanceSpecification> specifications, string busName);
}
public class MassTransit.SqlTransport.Configuration.SqlTopicConfigurator : object {
    [CompilerGeneratedAttribute]
private string <TopicName>k__BackingField;
    public string TopicName { get; }
    public SqlTopicConfigurator(string topicName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TopicName();
    public SqlEndpointAddress GetEndpointAddress(Uri hostAddress);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class MassTransit.SqlTransport.Configuration.SqlTopicSubscriptionConfigurator : SqlTopicConfigurator {
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlSubscriptionType <SubscriptionType>k__BackingField;
    public string RoutingKey { get; public set; }
    public SqlSubscriptionType SubscriptionType { get; public set; }
    [NullableContextAttribute("1")]
protected SqlTopicSubscriptionConfigurator(string topicName, SqlSubscriptionType subscriptionType, string routingKey);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RoutingKey(string value);
    [CompilerGeneratedAttribute]
public SqlSubscriptionType get_SubscriptionType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionType(SqlSubscriptionType value);
}
public class MassTransit.SqlTransport.Configuration.SqlTopologyConfiguration : object {
    private ISqlConsumeTopologyConfigurator _consumeTopology;
    private IMessageTopologyConfigurator _messageTopology;
    private ISqlPublishTopologyConfigurator _publishTopology;
    private ISqlSendTopologyConfigurator _sendTopology;
    private IMessageTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Message { get; }
    private ISendTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Send { get; }
    private IPublishTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Publish { get; }
    private IConsumeTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.Consume { get; }
    private ISqlPublishTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.Publish { get; }
    private ISqlSendTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.Send { get; }
    private ISqlConsumeTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.Consume { get; }
    public SqlTopologyConfiguration(IMessageTopologyConfigurator messageTopology);
    public SqlTopologyConfiguration(ISqlTopologyConfiguration topologyConfiguration);
    private sealed virtual override IMessageTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Message();
    private sealed virtual override ISendTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Send();
    private sealed virtual override IPublishTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Publish();
    private sealed virtual override IConsumeTopologyConfigurator MassTransit.Configuration.ITopologyConfiguration.get_Consume();
    private sealed virtual override ISqlPublishTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.get_Publish();
    private sealed virtual override ISqlSendTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.get_Send();
    private sealed virtual override ISqlConsumeTopologyConfigurator MassTransit.SqlTransport.Configuration.ISqlTopologyConfiguration.get_Consume();
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.SqlTransport.Configuration.TopicSubscriptionPublishTopologySpecification : SqlTopicSubscriptionConfigurator {
    [NullableContextAttribute("1")]
public TopicSubscriptionPublishTopologySpecification(string topicName, SqlSubscriptionType subscriptionType, string routingKey);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MassTransit.SqlTransport.Configuration.TopicSubscriptionPublishTopologySpecification/<Validate>d__1")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(IPublishEndpointBrokerTopologyBuilder builder);
}
[NullableContextAttribute("1")]
public interface MassTransit.SqlTransport.ConnectionContext {
    public Uri HostAddress { get; }
    [NullableAttribute("2")]
public string Schema { get; }
    public IsolationLevel IsolationLevel { get; }
    public abstract virtual Uri get_HostAddress();
    [NullableContextAttribute("2")]
public abstract virtual string get_Schema();
    public abstract virtual IsolationLevel get_IsolationLevel();
    public abstract virtual ClientContext CreateClientContext(CancellationToken cancellationToken);
    public abstract virtual Task`1<ISqlTransportConnection> CreateConnection(CancellationToken cancellationToken);
    public abstract virtual Task DelayUntilMessageReady(long queueId, TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> Query(Func`3<IDbConnection, IDbTransaction, Task`1<T>> callback, CancellationToken cancellationToken);
}
public abstract class MassTransit.SqlTransport.ConnectionContextFactory : object {
    public sealed virtual IPipeContextAgent`1<ConnectionContext> CreateContext(ISupervisor supervisor);
    public sealed virtual IActivePipeContextAgent`1<ConnectionContext> CreateActiveContext(ISupervisor supervisor, PipeContextHandle`1<ConnectionContext> context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.ConnectionContextFactory/<CreateSharedConnection>d__2")]
private static Task`1<ConnectionContext> CreateSharedConnection(Task`1<ConnectionContext> context, CancellationToken cancellationToken);
    protected abstract virtual ConnectionContext CreateConnection(ITransportSupervisor`1<ConnectionContext> supervisor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.ConnectionContextSupervisor : TransportPipeContextSupervisor`1<ConnectionContext> {
    private ISqlHostConfiguration _hostConfiguration;
    private ISqlTopologyConfiguration _topologyConfiguration;
    public ConnectionContextSupervisor(ISqlHostConfiguration hostConfiguration, ISqlTopologyConfiguration topologyConfiguration, IPipeContextFactory`1<ConnectionContext> connectionContextFactory);
    public sealed virtual Uri NormalizeAddress(Uri address);
    public sealed virtual Task`1<ISendTransport> CreatePublishTransport(SqlReceiveEndpointContext context, Uri publishAddress);
    public sealed virtual Task`1<ISendTransport> CreateSendTransport(SqlReceiveEndpointContext context, Uri address);
    private Task`1<ISendTransport> CreateSendTransport(Uri address, SendTransportContext`1<ClientContext> transportContext);
}
public interface MassTransit.SqlTransport.DeadLetterSettings {
    public abstract virtual BrokerTopology GetBrokerTopology();
}
[EditorBrowsableAttribute("1")]
public static class MassTransit.SqlTransport.Defaults : object {
    [CompilerGeneratedAttribute]
private static TimeSpan <LockDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultMessageTimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <ErrorQueueTimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <AutoDeleteOnIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <TemporaryAutoDeleteOnIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <MaxAutoRenewDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <SessionIdleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <ShutdownTimeout>k__BackingField;
    public static TimeSpan LockDuration { get; public set; }
    public static TimeSpan DefaultMessageTimeToLive { get; public set; }
    public static TimeSpan ErrorQueueTimeToLive { get; public set; }
    public static TimeSpan AutoDeleteOnIdle { get; public set; }
    public static TimeSpan TemporaryAutoDeleteOnIdle { get; public set; }
    public static TimeSpan MaxAutoRenewDuration { get; public set; }
    public static TimeSpan SessionIdleTimeout { get; public set; }
    public static TimeSpan ShutdownTimeout { get; public set; }
    private static Defaults();
    [CompilerGeneratedAttribute]
public static TimeSpan get_LockDuration();
    [CompilerGeneratedAttribute]
public static void set_LockDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_DefaultMessageTimeToLive();
    [CompilerGeneratedAttribute]
public static void set_DefaultMessageTimeToLive(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_ErrorQueueTimeToLive();
    [CompilerGeneratedAttribute]
public static void set_ErrorQueueTimeToLive(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_AutoDeleteOnIdle();
    [CompilerGeneratedAttribute]
public static void set_AutoDeleteOnIdle(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_TemporaryAutoDeleteOnIdle();
    [CompilerGeneratedAttribute]
public static void set_TemporaryAutoDeleteOnIdle(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_MaxAutoRenewDuration();
    [CompilerGeneratedAttribute]
public static void set_MaxAutoRenewDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_SessionIdleTimeout();
    [CompilerGeneratedAttribute]
public static void set_SessionIdleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_ShutdownTimeout();
    [CompilerGeneratedAttribute]
public static void set_ShutdownTimeout(TimeSpan value);
}
public interface MassTransit.SqlTransport.EntitySettings {
    public string EntityName { get; }
    public Nullable`1<TimeSpan> AutoDeleteOnIdle { get; }
    public abstract virtual string get_EntityName();
    public abstract virtual Nullable`1<TimeSpan> get_AutoDeleteOnIdle();
}
public interface MassTransit.SqlTransport.ErrorSettings {
    public abstract virtual BrokerTopology GetBrokerTopology();
}
public static class MassTransit.SqlTransport.HostInfoCache : object {
    private static Lazy`1<string> _hostInfoJson;
    public static string HostInfoJson { get; }
    private static HostInfoCache();
    public static string get_HostInfoJson();
}
public interface MassTransit.SqlTransport.IClientContextSupervisor {
}
public interface MassTransit.SqlTransport.IConnectionContextSupervisor {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ISendTransport> CreateSendTransport(SqlReceiveEndpointContext context, Uri address);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ISendTransport> CreatePublishTransport(SqlReceiveEndpointContext context, Uri publishAddress);
    [NullableContextAttribute("1")]
public abstract virtual Uri NormalizeAddress(Uri address);
}
public interface MassTransit.SqlTransport.IQueueNotificationListener {
    public abstract virtual Task MessageReady(string queueName);
}
public interface MassTransit.SqlTransport.ISqlHost {
}
public interface MassTransit.SqlTransport.ISqlTransportConnection {
    public IDbConnection Connection { get; }
    public abstract virtual IDbConnection get_Connection();
    public abstract virtual Task Open(CancellationToken cancellationToken);
    public abstract virtual Task Close();
}
public interface MassTransit.SqlTransport.ISqlTransportDatabaseMigrator {
    public abstract virtual Task CreateDatabase(SqlTransportOptions options, CancellationToken cancellationToken);
    public abstract virtual Task CreateInfrastructure(SqlTransportOptions options, CancellationToken cancellationToken);
    public abstract virtual Task DeleteDatabase(SqlTransportOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.MessageDelivery : object {
    [CompilerGeneratedAttribute]
private int <QueueId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <EnqueueTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConsumerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TransportMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastDelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SessionNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyToSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <GroupSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransportHeaders>k__BackingField;
    public int QueueId { get; public set; }
    public int Priority { get; public set; }
    public DateTimeOffset EnqueueTime { get; public set; }
    public Nullable`1<Guid> ConsumerId { get; public set; }
    public Guid TransportMessageId { get; public set; }
    public Nullable`1<DateTimeOffset> ExpirationTime { get; public set; }
    public int DeliveryCount { get; public set; }
    public int MaxDeliveryCount { get; public set; }
    public Nullable`1<DateTimeOffset> LastDelivered { get; public set; }
    public long SessionNumber { get; public set; }
    public string ReplyToSessionId { get; public set; }
    public string GroupId { get; public set; }
    public Nullable`1<int> GroupSequenceNumber { get; public set; }
    public string TransportHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public int get_QueueId();
    [CompilerGeneratedAttribute]
public void set_QueueId(int value);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_EnqueueTime();
    [CompilerGeneratedAttribute]
public void set_EnqueueTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ConsumerId();
    [CompilerGeneratedAttribute]
public void set_ConsumerId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Guid get_TransportMessageId();
    [CompilerGeneratedAttribute]
public void set_TransportMessageId(Guid value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public int get_DeliveryCount();
    [CompilerGeneratedAttribute]
public void set_DeliveryCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDeliveryCount();
    [CompilerGeneratedAttribute]
public void set_MaxDeliveryCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastDelivered();
    [CompilerGeneratedAttribute]
public void set_LastDelivered(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public long get_SessionNumber();
    [CompilerGeneratedAttribute]
public void set_SessionNumber(long value);
    [CompilerGeneratedAttribute]
public string get_ReplyToSessionId();
    [CompilerGeneratedAttribute]
public void set_ReplyToSessionId(string value);
    [CompilerGeneratedAttribute]
public string get_GroupId();
    [CompilerGeneratedAttribute]
public void set_GroupId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_GroupSequenceNumber();
    [CompilerGeneratedAttribute]
public void set_GroupSequenceNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_TransportHeaders();
    [CompilerGeneratedAttribute]
public void set_TransportHeaders(string value);
}
public interface MassTransit.SqlTransport.MessageLockContext {
    public abstract virtual Task Complete();
    public abstract virtual Task Abandon(Exception exception);
    public abstract virtual Task DeadLetter();
    public abstract virtual Task DeadLetter(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Middleware.ConfigureSqlTopologyFilter`1 : object {
    private BrokerTopology _brokerTopology;
    [NullableAttribute("2")]
private SqlReceiveEndpointContext _context;
    private TSettings _settings;
    public ConfigureSqlTopologyFilter`1(TSettings settings, BrokerTopology brokerTopology, SqlReceiveEndpointContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.ConfigureSqlTopologyFilter`1/<Send>d__4")]
public sealed virtual Task Send(ClientContext context, IPipe`1<ClientContext> next);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.ConfigureSqlTopologyFilter`1/<ConfigureTopology>d__6")]
private Task ConfigureTopology(ClientContext context);
    private static Task CreateTopic(ClientContext context, Topic topic);
    private static Task CreateQueueSubscription(ClientContext context, TopicToQueueSubscription subscription);
    private static Task CreateTopicSubscription(ClientContext context, TopicToTopicSubscription subscription);
    private static Task`1<long> CreateQueue(ClientContext context, Queue queue);
}
public interface MassTransit.SqlTransport.Middleware.ConfigureTopologyContext`1 {
}
public class MassTransit.SqlTransport.Middleware.PurgeOnStartupFilter : object {
    private string _queueName;
    private bool _queueAlreadyPurged;
    public PurgeOnStartupFilter(string queueName);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.PurgeOnStartupFilter/<MassTransit-IFilter<MassTransit-SqlTransport-ClientContext>-Send>d__4")]
private sealed virtual override Task MassTransit.IFilter<MassTransit.SqlTransport.ClientContext>.Send(ClientContext context, IPipe`1<ClientContext> next);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.PurgeOnStartupFilter/<PurgeIfRequested>d__5")]
private Task PurgeIfRequested(ClientContext context, string queueName);
}
public class MassTransit.SqlTransport.Middleware.SqlConsumerFilter : object {
    private SqlReceiveEndpointContext _context;
    public SqlConsumerFilter(SqlReceiveEndpointContext context);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.SqlConsumerFilter/<MassTransit-IFilter<MassTransit-SqlTransport-ClientContext>-Send>d__3")]
private sealed virtual override Task MassTransit.IFilter<MassTransit.SqlTransport.ClientContext>.Send(ClientContext context, IPipe`1<ClientContext> next);
}
public class MassTransit.SqlTransport.Middleware.SqlMessageReceiver : ConsumerAgent`1<Guid> {
    private ClientContext _client;
    private SqlReceiveEndpointContext _context;
    private IChannelExecutorPool`1<SqlTransportMessage> _executorPool;
    private ReceiveSettings _receiveSettings;
    public SqlMessageReceiver(ClientContext client, SqlReceiveEndpointContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.SqlMessageReceiver/<ActiveAndActualAgentsCompleted>d__5")]
protected virtual Task ActiveAndActualAgentsCompleted(StopContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.SqlMessageReceiver/<Consume>d__6")]
private Task Consume();
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.SqlMessageReceiver/<HandleMessage>d__7")]
private Task HandleMessage(SqlTransportMessage message, SqlReceiveLockContext lockContext);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.Middleware.SqlMessageReceiver/<ReceiveMessages>d__8")]
private Task`1<IEnumerable`1<SqlTransportMessage>> ReceiveMessages(int messageLimit, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
    [CompilerGeneratedAttribute]
private Task <Consume>g__Handle|6_0(SqlTransportMessage message, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<SqlTransportMessage>> <Consume>b__6_1(int messageLimit, CancellationToken token);
    [CompilerGeneratedAttribute]
private Task <Consume>b__6_2(SqlTransportMessage m, CancellationToken c);
}
public class MassTransit.SqlTransport.Middleware.SqlMessageSchedulerFilter : object {
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
private sealed virtual override Task MassTransit.IFilter<MassTransit.ConsumeContext>.Send(ConsumeContext context, IPipe`1<ConsumeContext> next);
    private static IMessageScheduler SchedulerFactory(ConsumeContext context);
}
public interface MassTransit.SqlTransport.NotificationContext {
    public abstract virtual ConnectHandle ConnectNotificationSink(string queueName, IQueueNotificationListener listener);
}
public class MassTransit.SqlTransport.QueueSendTransportContext : BaseSendTransportContext {
    private IPipe`1<ClientContext> _configureTopologyPipe;
    private ISqlHostConfiguration _hostConfiguration;
    private IClientContextSupervisor _supervisor;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    public string EntityName { get; }
    public string ActivitySystem { get; }
    public QueueSendTransportContext(ISqlHostConfiguration hostConfiguration, ReceiveEndpointContext receiveEndpointContext, IClientContextSupervisor supervisor, IPipe`1<ClientContext> configureTopologyPipe, string entityName);
    [CompilerGeneratedAttribute]
public virtual string get_EntityName();
    public virtual string get_ActivitySystem();
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.QueueSendTransportContext/<CreateSendContext>d__10`1")]
public virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public virtual IEnumerable`1<IAgent> GetAgentHandles();
    public sealed virtual Task Send(IPipe`1<ClientContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(ClientContext context, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.QueueSendTransportContext/<Send>d__14`1")]
public sealed virtual Task Send(ClientContext clientContext, SendContext`1<T> sendContext);
    private static void CopyIncomingIdentifiersIfPresent(SqlMessageSendContext`1<T> context);
}
public class MassTransit.SqlTransport.QueueSqlReceiveEndpointContext : BaseReceiveEndpointContext {
    private Recycle`1<IClientContextSupervisor> _clientContext;
    private ISqlReceiveEndpointConfiguration _configuration;
    private ISqlHostConfiguration _hostConfiguration;
    [CompilerGeneratedAttribute]
private BrokerTopology <BrokerTopology>k__BackingField;
    public IClientContextSupervisor ClientContextSupervisor { get; }
    public BrokerTopology BrokerTopology { get; }
    public QueueSqlReceiveEndpointContext(ISqlHostConfiguration hostConfiguration, ISqlReceiveEndpointConfiguration configuration, BrokerTopology brokerTopology);
    public sealed virtual IClientContextSupervisor get_ClientContextSupervisor();
    [CompilerGeneratedAttribute]
public sealed virtual BrokerTopology get_BrokerTopology();
    public virtual void AddSendAgent(IAgent agent);
    public virtual void AddConsumeAgent(IAgent agent);
    public virtual Exception ConvertException(Exception exception, string message);
    public virtual void Probe(ProbeContext context);
    protected virtual ISendTransportProvider CreateSendTransportProvider();
    protected virtual IPublishTransportProvider CreatePublishTransportProvider();
    [CompilerGeneratedAttribute]
private IClientContextSupervisor <.ctor>b__3_0();
}
public interface MassTransit.SqlTransport.ReceiveSettings {
    public string QueueName { get; }
    public Nullable`1<long> QueueId { get; }
    public int PrefetchCount { get; }
    public int ConcurrentMessageLimit { get; }
    public int ConcurrentDeliveryLimit { get; }
    public SqlReceiveMode ReceiveMode { get; }
    public bool PurgeOnStartup { get; }
    public TimeSpan LockDuration { get; }
    public TimeSpan MaxLockDuration { get; }
    public int MaxDeliveryCount { get; }
    public TimeSpan PollingInterval { get; }
    public Nullable`1<TimeSpan> UnlockDelay { get; }
    public abstract virtual string get_QueueName();
    public abstract virtual Nullable`1<long> get_QueueId();
    public abstract virtual int get_PrefetchCount();
    public abstract virtual int get_ConcurrentMessageLimit();
    public abstract virtual int get_ConcurrentDeliveryLimit();
    public abstract virtual SqlReceiveMode get_ReceiveMode();
    public abstract virtual bool get_PurgeOnStartup();
    public abstract virtual TimeSpan get_LockDuration();
    public abstract virtual TimeSpan get_MaxLockDuration();
    public abstract virtual int get_MaxDeliveryCount();
    public abstract virtual TimeSpan get_PollingInterval();
    public abstract virtual Nullable`1<TimeSpan> get_UnlockDelay();
}
public class MassTransit.SqlTransport.ScopeClientContext : ScopePipeContext {
    private ClientContext _context;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public ConnectionContext ConnectionContext { get; }
    public ScopeClientContext(ClientContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    public sealed virtual ConnectionContext get_ConnectionContext();
    public sealed virtual Task`1<long> CreateQueue(Queue queue);
    public sealed virtual Task`1<long> CreateTopic(Topic topic);
    public sealed virtual Task`1<long> CreateTopicSubscription(TopicToTopicSubscription subscription);
    public sealed virtual Task`1<long> CreateQueueSubscription(TopicToQueueSubscription subscription);
    public sealed virtual Task`1<long> PurgeQueue(string queueName, CancellationToken cancellationToken);
    public sealed virtual Task Send(string queueName, SqlMessageSendContext`1<T> context);
    public sealed virtual Task Publish(string topicName, SqlMessageSendContext`1<T> context);
    public sealed virtual Task`1<bool> RenewLock(Guid lockId, long messageDeliveryId, TimeSpan duration);
    public sealed virtual Task`1<bool> Unlock(Guid lockId, long messageDeliveryId, TimeSpan delay, SendHeaders sendHeaders);
    public sealed virtual Task`1<IEnumerable`1<SqlTransportMessage>> ReceiveMessages(string queueName, SqlReceiveMode mode, int messageLimit, int concurrentLimit, TimeSpan lockDuration);
    public sealed virtual Task`1<bool> DeleteMessage(Guid lockId, long messageDeliveryId);
    public sealed virtual Task`1<bool> DeleteScheduledMessage(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> MoveMessage(Guid lockId, long messageDeliveryId, string queueName, SqlQueueType queueType, SendHeaders sendHeaders);
}
public class MassTransit.SqlTransport.ScopeClientContextFactory : object {
    private IConnectionContextSupervisor _connectionContextSupervisor;
    public ScopeClientContextFactory(IConnectionContextSupervisor connectionContextSupervisor);
    private sealed virtual override IPipeContextAgent`1<ClientContext> MassTransit.Agents.IPipeContextFactory<MassTransit.SqlTransport.ClientContext>.CreateContext(ISupervisor supervisor);
    private sealed virtual override IActivePipeContextAgent`1<ClientContext> MassTransit.Agents.IPipeContextFactory<MassTransit.SqlTransport.ClientContext>.CreateActiveContext(ISupervisor supervisor, PipeContextHandle`1<ClientContext> context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.ScopeClientContextFactory/<CreateSharedClientContext>d__4")]
private static Task`1<ClientContext> CreateSharedClientContext(Task`1<ClientContext> context, CancellationToken cancellationToken);
    private void CreateClientContext(IAsyncPipeContextAgent`1<ClientContext> asyncContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static Task`1<ClientContext> <CreateClientContext>g__Create|5_0(ConnectionContext connectionContext, CancellationToken createCancellationToken);
}
public interface MassTransit.SqlTransport.SendSettings {
    public abstract virtual SqlEndpointAddress GetSendAddress(Uri hostAddress);
    public abstract virtual BrokerTopology GetBrokerTopology();
}
public class MassTransit.SqlTransport.SharedClientContext : ProxyPipeContext {
    private ClientContext _context;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public ConnectionContext ConnectionContext { get; }
    public SharedClientContext(ClientContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    public sealed virtual ConnectionContext get_ConnectionContext();
    public sealed virtual Task`1<long> CreateQueue(Queue queue);
    public sealed virtual Task`1<long> CreateTopic(Topic topic);
    public sealed virtual Task`1<long> CreateTopicSubscription(TopicToTopicSubscription subscription);
    public sealed virtual Task`1<long> CreateQueueSubscription(TopicToQueueSubscription subscription);
    public sealed virtual Task`1<long> PurgeQueue(string queueName, CancellationToken cancellationToken);
    public sealed virtual Task Send(string queueName, SqlMessageSendContext`1<T> context);
    public sealed virtual Task Publish(string topicName, SqlMessageSendContext`1<T> context);
    public sealed virtual Task`1<bool> RenewLock(Guid lockId, long messageDeliveryId, TimeSpan duration);
    public sealed virtual Task`1<bool> Unlock(Guid lockId, long messageDeliveryId, TimeSpan delay, SendHeaders sendHeaders);
    public sealed virtual Task`1<IEnumerable`1<SqlTransportMessage>> ReceiveMessages(string queueName, SqlReceiveMode mode, int messageLimit, int concurrentLimit, TimeSpan lockDuration);
    public sealed virtual Task`1<bool> DeleteMessage(Guid lockId, long messageDeliveryId);
    public sealed virtual Task`1<bool> DeleteScheduledMessage(Guid tokenId, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> MoveMessage(Guid lockId, long messageDeliveryId, string queueName, SqlQueueType queueType, SendHeaders sendHeaders);
}
public class MassTransit.SqlTransport.SharedClientContextFactory : object {
    private IClientContextSupervisor _supervisor;
    public SharedClientContextFactory(IClientContextSupervisor supervisor);
    private sealed virtual override IPipeContextAgent`1<ClientContext> MassTransit.Agents.IPipeContextFactory<MassTransit.SqlTransport.ClientContext>.CreateContext(ISupervisor supervisor);
    private sealed virtual override IActivePipeContextAgent`1<ClientContext> MassTransit.Agents.IPipeContextFactory<MassTransit.SqlTransport.ClientContext>.CreateActiveContext(ISupervisor supervisor, PipeContextHandle`1<ClientContext> context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SharedClientContextFactory/<CreateScopeContext>d__4")]
private static Task`1<ClientContext> CreateScopeContext(Task`1<ClientContext> context, CancellationToken cancellationToken);
    private void CreateClientContext(IAsyncPipeContextAgent`1<ClientContext> asyncContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static Task`1<ClientContext> <CreateClientContext>g__Create|5_0(ClientContext context, CancellationToken createCancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SharedConnectionContext : ProxyPipeContext {
    private ConnectionContext _context;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public Uri HostAddress { get; }
    [NullableAttribute("2")]
public string Schema { get; }
    public IsolationLevel IsolationLevel { get; }
    public SharedConnectionContext(ConnectionContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    public sealed virtual Uri get_HostAddress();
    [NullableContextAttribute("2")]
public sealed virtual string get_Schema();
    public sealed virtual IsolationLevel get_IsolationLevel();
    public sealed virtual ClientContext CreateClientContext(CancellationToken cancellationToken);
    public sealed virtual Task`1<ISqlTransportConnection> CreateConnection(CancellationToken cancellationToken);
    public sealed virtual Task DelayUntilMessageReady(long queueId, TimeSpan timeout, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> Query(Func`3<IDbConnection, IDbTransaction, Task`1<T>> callback, CancellationToken cancellationToken);
}
public abstract class MassTransit.SqlTransport.SqlClientContext : ScopePipeContext {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionContext <ConnectionContext>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public ConnectionContext ConnectionContext { get; }
    protected SqlClientContext(ConnectionContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual ConnectionContext get_ConnectionContext();
    public abstract virtual Task`1<long> CreateQueue(Queue queue);
    public abstract virtual Task`1<long> CreateTopic(Topic topic);
    public abstract virtual Task`1<long> CreateTopicSubscription(TopicToTopicSubscription subscription);
    public abstract virtual Task`1<long> CreateQueueSubscription(TopicToQueueSubscription subscription);
    public abstract virtual Task`1<long> PurgeQueue(string queueName, CancellationToken cancellationToken);
    public abstract virtual Task Send(string queueName, SqlMessageSendContext`1<T> context);
    public abstract virtual Task Publish(string topicName, SqlMessageSendContext`1<T> context);
    public abstract virtual Task`1<IEnumerable`1<SqlTransportMessage>> ReceiveMessages(string queueName, SqlReceiveMode mode, int messageLimit, int concurrentLimit, TimeSpan lockDuration);
    public abstract virtual Task`1<bool> DeleteMessage(Guid lockId, long messageDeliveryId);
    public abstract virtual Task`1<bool> DeleteScheduledMessage(Guid tokenId, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> MoveMessage(Guid lockId, long messageDeliveryId, string queueName, SqlQueueType queueType, SendHeaders sendHeaders);
    public abstract virtual Task`1<bool> RenewLock(Guid lockId, long messageDeliveryId, TimeSpan duration);
    public abstract virtual Task`1<bool> Unlock(Guid lockId, long messageDeliveryId, TimeSpan delay, SendHeaders sendHeaders);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlHeaderProvider : object {
    private SqlTransportMessage _message;
    public SqlHeaderProvider(SqlTransportMessage message);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAll();
    public sealed virtual bool TryGetHeader(string key, Object& value);
}
public class MassTransit.SqlTransport.SqlHost : BaseHost {
    [NullableAttribute("1")]
private ISqlHostConfiguration _hostConfiguration;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ISqlBusTopology <Topology>k__BackingField;
    [NullableAttribute("1")]
public ISqlBusTopology Topology { get; }
    [NullableContextAttribute("1")]
public SqlHost(ISqlHostConfiguration hostConfiguration, ISqlBusTopology busTopology);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ISqlBusTopology get_Topology();
    [NullableContextAttribute("1")]
public virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<ISqlReceiveEndpointConfigurator> configureEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<ISqlReceiveEndpointConfigurator> configure);
    [NullableContextAttribute("1")]
protected virtual void Probe(ProbeContext context);
    [NullableContextAttribute("1")]
protected virtual IAgent[] GetAgentHandles();
}
public static class MassTransit.SqlTransport.SqlLogMessages : object {
    public static LogMessage`1<TopicToTopicSubscription> CreateTopicSubscription;
    public static LogMessage`1<TopicToQueueSubscription> CreateQueueSubscription;
    public static LogMessage`1<Topic> CreateTopic;
    public static LogMessage`1<Queue> CreateQueue;
    private static SqlLogMessages();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.SqlMessageSendContext`1 : MessageSendContext`1<T> {
    [CompilerGeneratedAttribute]
private Guid <TransportMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public Guid TransportMessageId { get; }
    public string PartitionKey { get; public set; }
    public Nullable`1<short> Priority { get; public set; }
    public string RoutingKey { get; public set; }
    [NullableContextAttribute("1")]
public SqlMessageSendContext`1(T message, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_TransportMessageId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PartitionKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<short> get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(Nullable`1<short> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RoutingKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RoutingKey(string value);
    [NullableContextAttribute("1")]
public virtual void ReadPropertiesFrom(IReadOnlyDictionary`2<string, object> properties);
    [NullableContextAttribute("1")]
public virtual void WritePropertiesTo(IDictionary`2<string, object> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlPublishTransportProvider : object {
    private IConnectionContextSupervisor _connectionContextSupervisor;
    private SqlReceiveEndpointContext _context;
    public SqlPublishTransportProvider(IConnectionContextSupervisor connectionContextSupervisor, SqlReceiveEndpointContext context);
    public sealed virtual Task`1<ISendTransport> GetPublishTransport(Uri publishAddress);
}
public class MassTransit.SqlTransport.SqlQueueDeadLetterTransport : SqlQueueMoveTransport {
    [NullableContextAttribute("1")]
public SqlQueueDeadLetterTransport(string queueName, SqlQueueType queueType);
    [NullableContextAttribute("1")]
public sealed virtual Task Send(ReceiveContext context, string reason);
}
public class MassTransit.SqlTransport.SqlQueueErrorTransport : SqlQueueMoveTransport {
    public SqlQueueErrorTransport(string queueName, SqlQueueType queueType);
    public sealed virtual Task Send(ExceptionReceiveContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlQueueMoveTransport : object {
    private string _queueName;
    private SqlQueueType _queueType;
    protected SqlQueueMoveTransport(string queueName, SqlQueueType queueType);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlQueueMoveTransport/<Move>d__3")]
protected Task Move(ReceiveContext context, Action`2<SqlTransportMessage, SendHeaders> preSend);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlReceiveContext : BaseReceiveContext {
    [NullableAttribute("2")]
private IHeaderProvider _headerProvider;
    [CompilerGeneratedAttribute]
private MessageBody <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlTransportMessage <TransportMessage>k__BackingField;
    public MessageBody Body { get; }
    protected IHeaderProvider HeaderProvider { get; }
    public SqlTransportMessage TransportMessage { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public Guid TransportMessageId { get; }
    public Nullable`1<Guid> ConsumerId { get; }
    public Nullable`1<Guid> LockId { get; }
    public string QueueName { get; }
    public short Priority { get; }
    public long DeliveryMessageId { get; }
    public DateTime EnqueueTime { get; }
    public int DeliveryCount { get; }
    [NullableAttribute("2")]
public string PartitionKey { get; }
    public SqlReceiveContext(SqlTransportMessage message, bool redelivered, SqlReceiveEndpointContext context, ReceiveSettings settings, ClientContext clientContext, ConnectionContext connectionContext, SqlReceiveLockContext lockContext);
    [CompilerGeneratedAttribute]
public virtual MessageBody get_Body();
    protected virtual IHeaderProvider get_HeaderProvider();
    [CompilerGeneratedAttribute]
public sealed virtual SqlTransportMessage get_TransportMessage();
    [NullableContextAttribute("2")]
public sealed virtual string get_RoutingKey();
    public sealed virtual Guid get_TransportMessageId();
    public sealed virtual Nullable`1<Guid> get_ConsumerId();
    public sealed virtual Nullable`1<Guid> get_LockId();
    public sealed virtual string get_QueueName();
    public sealed virtual short get_Priority();
    public sealed virtual long get_DeliveryMessageId();
    public sealed virtual DateTime get_EnqueueTime();
    public sealed virtual int get_DeliveryCount();
    [NullableContextAttribute("2")]
public sealed virtual string get_PartitionKey();
    public sealed virtual IDictionary`2<string, object> GetTransportProperties();
}
public interface MassTransit.SqlTransport.SqlReceiveEndpointContext {
    public IClientContextSupervisor ClientContextSupervisor { get; }
    public BrokerTopology BrokerTopology { get; }
    public abstract virtual IClientContextSupervisor get_ClientContextSupervisor();
    public abstract virtual BrokerTopology get_BrokerTopology();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlReceiveLockContext : object {
    private CancellationTokenSource _activeTokenSource;
    private ClientContext _clientContext;
    private Uri _inputAddress;
    private SqlTransportMessage _message;
    [NullableAttribute("2")]
private Task _renewLockTask;
    private ReceiveSettings _settings;
    private DateTime _startedAt;
    private bool _locked;
    public SqlReceiveLockContext(Uri inputAddress, SqlTransportMessage message, ReceiveSettings settings, ClientContext clientContext);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlReceiveLockContext/<ScheduleRedelivery>d__9")]
public sealed virtual Task ScheduleRedelivery(TimeSpan delay, Action`2<ConsumeContext, SendContext> callback);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlReceiveLockContext/<Complete>d__10")]
public sealed virtual Task Complete();
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlReceiveLockContext/<Faulted>d__11")]
public sealed virtual Task Faulted(Exception exception);
    public sealed virtual Task ValidateLockStatus();
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlReceiveLockContext/<RenewLock>d__13")]
private Task RenewLock();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__8_0();
    [CompilerGeneratedAttribute]
internal static TimeSpan <RenewLock>g__CalculateDelay|13_0(TimeSpan timeout);
}
public class MassTransit.SqlTransport.SqlSendTransportProvider : object {
    private IConnectionContextSupervisor _connectionContextSupervisor;
    private SqlReceiveEndpointContext _context;
    public SqlSendTransportProvider(IConnectionContextSupervisor connectionContextSupervisor, SqlReceiveEndpointContext context);
    public sealed virtual Uri NormalizeAddress(Uri address);
    public sealed virtual Task`1<ISendTransport> GetSendTransport(Uri address);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.SqlTransportMessage : object {
    private SendHeaders _headers;
    private SendHeaders _transportHeaders;
    [CompilerGeneratedAttribute]
private Guid <TransportMessageId>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MessageDeliveryId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConsumerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <LockId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EnqueueTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransportHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BinaryBody>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ConversationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <InitiatorId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResponseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <FaultAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SentTime>k__BackingField;
    public Guid TransportMessageId { get; public set; }
    [NullableAttribute("1")]
public string QueueName { get; public set; }
    public short Priority { get; public set; }
    public long MessageDeliveryId { get; public set; }
    public Nullable`1<Guid> ConsumerId { get; public set; }
    public Nullable`1<Guid> LockId { get; public set; }
    public DateTime EnqueueTime { get; public set; }
    public int DeliveryCount { get; public set; }
    public string PartitionKey { get; public set; }
    public string RoutingKey { get; public set; }
    public string TransportHeaders { get; public set; }
    public string ContentType { get; public set; }
    public string MessageType { get; public set; }
    public string Body { get; public set; }
    public Byte[] BinaryBody { get; public set; }
    public string Headers { get; public set; }
    public string Host { get; public set; }
    public Nullable`1<Guid> MessageId { get; public set; }
    public Nullable`1<Guid> RequestId { get; public set; }
    public Nullable`1<Guid> CorrelationId { get; public set; }
    public Nullable`1<Guid> ConversationId { get; public set; }
    public Nullable`1<Guid> InitiatorId { get; public set; }
    public Nullable`1<DateTime> ExpirationTime { get; public set; }
    public Uri SourceAddress { get; public set; }
    public Uri DestinationAddress { get; public set; }
    public Uri ResponseAddress { get; public set; }
    public Uri FaultAddress { get; public set; }
    public Nullable`1<DateTime> SentTime { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_TransportMessageId();
    [CompilerGeneratedAttribute]
public void set_TransportMessageId(Guid value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_QueueName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_QueueName(string value);
    [CompilerGeneratedAttribute]
public short get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(short value);
    [CompilerGeneratedAttribute]
public long get_MessageDeliveryId();
    [CompilerGeneratedAttribute]
public void set_MessageDeliveryId(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ConsumerId();
    [CompilerGeneratedAttribute]
public void set_ConsumerId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_LockId();
    [CompilerGeneratedAttribute]
public void set_LockId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public DateTime get_EnqueueTime();
    [CompilerGeneratedAttribute]
public void set_EnqueueTime(DateTime value);
    [CompilerGeneratedAttribute]
public int get_DeliveryCount();
    [CompilerGeneratedAttribute]
public void set_DeliveryCount(int value);
    [CompilerGeneratedAttribute]
public string get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
    [CompilerGeneratedAttribute]
public string get_TransportHeaders();
    [CompilerGeneratedAttribute]
public void set_TransportHeaders(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_BinaryBody();
    [CompilerGeneratedAttribute]
public void set_BinaryBody(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(string value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ConversationId();
    [CompilerGeneratedAttribute]
public void set_ConversationId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_InitiatorId();
    [CompilerGeneratedAttribute]
public void set_InitiatorId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public void set_ExpirationTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Uri get_SourceAddress();
    [CompilerGeneratedAttribute]
public void set_SourceAddress(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_DestinationAddress();
    [CompilerGeneratedAttribute]
public void set_DestinationAddress(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_ResponseAddress();
    [CompilerGeneratedAttribute]
public void set_ResponseAddress(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_FaultAddress();
    [CompilerGeneratedAttribute]
public void set_FaultAddress(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_SentTime();
    [CompilerGeneratedAttribute]
public void set_SentTime(Nullable`1<DateTime> value);
    [NullableContextAttribute("1")]
public SendHeaders GetHeaders();
    [NullableContextAttribute("1")]
public SendHeaders GetTransportHeaders();
    [NullableContextAttribute("1")]
public static SendHeaders DeserializeHeaders(string jsonHeaders);
    private HostInfo GetHost();
    private static Uri ToUri(string value);
}
public class MassTransit.SqlTransport.SqlTransportMigrationHostedService : object {
    private ILogger`1<SqlTransportMigrationHostedService> _logger;
    private ISqlTransportDatabaseMigrator _migrator;
    private SqlTransportMigrationOptions _options;
    private SqlTransportOptions _transportOptions;
    public SqlTransportMigrationHostedService(ISqlTransportDatabaseMigrator migrator, ILogger`1<SqlTransportMigrationHostedService> logger, IOptions`1<SqlTransportMigrationOptions> options, IOptions`1<SqlTransportOptions> dbOptions);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlTransportMigrationHostedService/<StartAsync>d__5")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.SqlTransportMigrationHostedService/<StopAsync>d__6")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
}
internal static class MassTransit.SqlTransport.SqlTransportPropertyNames : object {
    public static string PartitionKey;
    public static string Priority;
    public static string RoutingKey;
}
public class MassTransit.SqlTransport.TopicSendTransportContext : BaseSendTransportContext {
    private IPipe`1<ClientContext> _configureTopologyPipe;
    private ISqlHostConfiguration _hostConfiguration;
    private IClientContextSupervisor _supervisor;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    public string EntityName { get; }
    public string ActivitySystem { get; }
    public TopicSendTransportContext(ISqlHostConfiguration hostConfiguration, ReceiveEndpointContext receiveEndpointContext, IClientContextSupervisor supervisor, IPipe`1<ClientContext> configureTopologyPipe, string entityName);
    [CompilerGeneratedAttribute]
public virtual string get_EntityName();
    public virtual string get_ActivitySystem();
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.TopicSendTransportContext/<CreateSendContext>d__10`1")]
public virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public virtual IEnumerable`1<IAgent> GetAgentHandles();
    public sealed virtual Task Send(IPipe`1<ClientContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(ClientContext context, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.SqlTransport.TopicSendTransportContext/<Send>d__14`1")]
public sealed virtual Task Send(ClientContext clientContext, SendContext`1<T> sendContext);
}
public interface MassTransit.SqlTransport.Topology.BrokerTopology {
    public Topic[] Topics { get; }
    public Queue[] Queues { get; }
    public TopicToTopicSubscription[] TopicSubscriptions { get; }
    public TopicToQueueSubscription[] QueueSubscriptions { get; }
    public abstract virtual Topic[] get_Topics();
    public abstract virtual Queue[] get_Queues();
    public abstract virtual TopicToTopicSubscription[] get_TopicSubscriptions();
    public abstract virtual TopicToQueueSubscription[] get_QueueSubscriptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.SqlTransport.Topology.BrokerTopologyBuilder : object {
    private NamedEntityCollection`2<QueueEntity, QueueHandle> _queues;
    private EntityCollection`2<QueueSubscriptionEntity, QueueSubscriptionHandle> _queueSubscriptions;
    private NamedEntityCollection`2<TopicEntity, TopicHandle> _topics;
    private EntityCollection`2<TopicSubscriptionEntity, TopicSubscriptionHandle> _topicSubscriptions;
    private long _nextId;
    private long GetNextId();
    public sealed virtual TopicHandle CreateTopic(string name);
    public sealed virtual TopicSubscriptionHandle CreateTopicSubscription(TopicHandle source, TopicHandle destination, SqlSubscriptionType subscriptionType, string routingKey);
    public sealed virtual QueueHandle CreateQueue(string name, Nullable`1<TimeSpan> autoDeleteOnIdle);
    public sealed virtual QueueSubscriptionHandle CreateQueueSubscription(TopicHandle topic, QueueHandle queue, SqlSubscriptionType subscriptionType, string routingKey);
    public BrokerTopology BuildBrokerTopology();
}
[NullableContextAttribute("1")]
public interface MassTransit.SqlTransport.Topology.IBrokerTopologyBuilder {
    public abstract virtual TopicHandle CreateTopic(string name);
    public abstract virtual TopicSubscriptionHandle CreateTopicSubscription(TopicHandle source, TopicHandle destination, SqlSubscriptionType subscriptionType, string routingKey);
    public abstract virtual QueueHandle CreateQueue(string name, Nullable`1<TimeSpan> autoDeleteOnIdle);
    public abstract virtual QueueSubscriptionHandle CreateQueueSubscription(TopicHandle topic, QueueHandle queue, SqlSubscriptionType subscriptionType, string routingKey);
}
[NullableContextAttribute("2")]
public interface MassTransit.SqlTransport.Topology.IPublishEndpointBrokerTopologyBuilder {
    public TopicHandle Topic { get; public set; }
    public abstract virtual TopicHandle get_Topic();
    public abstract virtual void set_Topic(TopicHandle value);
    [NullableContextAttribute("1")]
public abstract virtual IPublishEndpointBrokerTopologyBuilder CreateImplementedBuilder();
}
public interface MassTransit.SqlTransport.Topology.IReceiveEndpointBrokerTopologyBuilder {
    public QueueHandle Queue { get; }
    public abstract virtual QueueHandle get_Queue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Topology.PublishEndpointBrokerTopologyBuilder : BrokerTopologyBuilder {
    [CompilerGeneratedAttribute]
private TopicHandle <Topic>k__BackingField;
    public TopicHandle Topic { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TopicHandle get_Topic();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Topic(TopicHandle value);
    [NullableContextAttribute("1")]
public sealed virtual IPublishEndpointBrokerTopologyBuilder CreateImplementedBuilder();
}
public interface MassTransit.SqlTransport.Topology.Queue {
    public string QueueName { get; }
    public Nullable`1<TimeSpan> AutoDeleteOnIdle { get; }
    public abstract virtual string get_QueueName();
    public abstract virtual Nullable`1<TimeSpan> get_AutoDeleteOnIdle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Topology.QueueEntity : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<QueueEntity> <NameComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<QueueEntity> <QueueComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <AutoDeleteOnIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public static IEqualityComparer`1<QueueEntity> NameComparer { get; }
    public static IEqualityComparer`1<QueueEntity> QueueComparer { get; }
    public string QueueName { get; }
    public Nullable`1<TimeSpan> AutoDeleteOnIdle { get; }
    public long Id { get; }
    public Queue Queue { get; }
    public QueueEntity(long id, string name, Nullable`1<TimeSpan> autoDeleteOnIdle);
    private static QueueEntity();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<QueueEntity> get_NameComparer();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<QueueEntity> get_QueueComparer();
    [CompilerGeneratedAttribute]
public sealed virtual string get_QueueName();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_AutoDeleteOnIdle();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Id();
    public sealed virtual Queue get_Queue();
    public virtual string ToString();
}
public interface MassTransit.SqlTransport.Topology.QueueHandle {
    public Queue Queue { get; }
    public abstract virtual Queue get_Queue();
}
public class MassTransit.SqlTransport.Topology.QueueSendSettings : SqlQueueConfigurator {
    public string EntityName { get; }
    public QueueSendSettings(SqlEndpointAddress address);
    public QueueSendSettings(EntitySettings settings, string queueName);
    public sealed virtual SqlEndpointAddress GetSendAddress(Uri hostAddress);
    public sealed virtual BrokerTopology GetBrokerTopology();
    public sealed virtual string get_EntityName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Topology.QueueSubscriptionEntity : object {
    private QueueEntity _queue;
    private TopicEntity _topic;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<QueueSubscriptionEntity> <EntityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlSubscriptionType <SubscriptionType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public static IEqualityComparer`1<QueueSubscriptionEntity> EntityComparer { get; }
    public long Id { get; }
    public TopicToQueueSubscription Subscription { get; }
    public SqlSubscriptionType SubscriptionType { get; }
    public Topic Source { get; }
    public Queue Destination { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public QueueSubscriptionEntity(long id, TopicEntity topic, QueueEntity queue, SqlSubscriptionType subscriptionType, string routingKey);
    private static QueueSubscriptionEntity();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<QueueSubscriptionEntity> get_EntityComparer();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Id();
    public sealed virtual TopicToQueueSubscription get_Subscription();
    [CompilerGeneratedAttribute]
public sealed virtual SqlSubscriptionType get_SubscriptionType();
    public sealed virtual Topic get_Source();
    public sealed virtual Queue get_Destination();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_RoutingKey();
    public virtual string ToString();
}
public interface MassTransit.SqlTransport.Topology.QueueSubscriptionHandle {
    public TopicToQueueSubscription Subscription { get; }
    public abstract virtual TopicToQueueSubscription get_Subscription();
}
public class MassTransit.SqlTransport.Topology.ReceiveEndpointBrokerTopologyBuilder : BrokerTopologyBuilder {
    [CompilerGeneratedAttribute]
private QueueHandle <Queue>k__BackingField;
    public QueueHandle Queue { get; }
    public ReceiveEndpointBrokerTopologyBuilder(ReceiveSettings settings);
    [CompilerGeneratedAttribute]
public sealed virtual QueueHandle get_Queue();
}
public class MassTransit.SqlTransport.Topology.SqlBrokerTopology : object {
    [CompilerGeneratedAttribute]
private Topic[] <Topics>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue[] <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private TopicToTopicSubscription[] <TopicSubscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TopicToQueueSubscription[] <QueueSubscriptions>k__BackingField;
    public Topic[] Topics { get; }
    public Queue[] Queues { get; }
    public TopicToTopicSubscription[] TopicSubscriptions { get; }
    public TopicToQueueSubscription[] QueueSubscriptions { get; }
    public SqlBrokerTopology(IEnumerable`1<Topic> topics, IEnumerable`1<TopicToTopicSubscription> topicSubscriptions, IEnumerable`1<Queue> queues, IEnumerable`1<TopicToQueueSubscription> queueSubscriptions);
    [CompilerGeneratedAttribute]
public sealed virtual Topic[] get_Topics();
    [CompilerGeneratedAttribute]
public sealed virtual Queue[] get_Queues();
    [CompilerGeneratedAttribute]
public sealed virtual TopicToTopicSubscription[] get_TopicSubscriptions();
    [CompilerGeneratedAttribute]
public sealed virtual TopicToQueueSubscription[] get_QueueSubscriptions();
    public sealed virtual void Probe(ProbeContext context);
}
public class MassTransit.SqlTransport.Topology.SqlBusTopology : BusTopology {
    private ISqlTopologyConfiguration _configuration;
    private ISqlPublishTopology MassTransit.ISqlBusTopology.PublishTopology { get; }
    private ISqlSendTopology MassTransit.ISqlBusTopology.SendTopology { get; }
    public SqlBusTopology(ISqlHostConfiguration hostConfiguration, ISqlTopologyConfiguration configuration);
    private sealed virtual override ISqlPublishTopology MassTransit.ISqlBusTopology.get_PublishTopology();
    private sealed virtual override ISqlSendTopology MassTransit.ISqlBusTopology.get_SendTopology();
    private sealed virtual override ISqlMessagePublishTopology`1<T> MassTransit.ISqlBusTopology.Publish();
    private sealed virtual override ISqlMessageSendTopology`1<T> MassTransit.ISqlBusTopology.Send();
}
public class MassTransit.SqlTransport.Topology.SqlConsumeTopology : ConsumeTopology {
    [NullableAttribute("1")]
private ISqlPublishTopology _publishTopology;
    [NullableAttribute("1")]
private List`1<ISqlConsumeTopologySpecification> _specifications;
    [NullableContextAttribute("1")]
public SqlConsumeTopology(ISqlPublishTopology publishTopology);
    private sealed virtual override ISqlMessageConsumeTopology`1<T> MassTransit.ISqlConsumeTopology.GetMessageTopology();
    [NullableContextAttribute("1")]
public sealed virtual void AddSpecification(ISqlConsumeTopologySpecification specification);
    [NullableContextAttribute("1")]
private sealed virtual override ISqlMessageConsumeTopologyConfigurator`1<T> MassTransit.ISqlConsumeTopologyConfigurator.GetMessageTopology();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
    [NullableContextAttribute("1")]
public sealed virtual void Subscribe(string topicName, Action`1<ISqlTopicSubscriptionConfigurator> configure);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<ValidationResult> Validate();
    protected virtual IMessageConsumeTopologyConfigurator CreateMessageTopology();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.Topology.SqlMessageConsumeTopology`1 : MessageConsumeTopology`1<TMessage> {
    private ISqlMessagePublishTopology`1<TMessage> _publishTopology;
    private List`1<ISqlConsumeTopologySpecification> _specifications;
    public SqlMessageConsumeTopology`1(ISqlMessagePublishTopology`1<TMessage> publishTopology);
    public sealed virtual void Apply(IReceiveEndpointBrokerTopologyBuilder builder);
    public sealed virtual void Subscribe(Action`1<ISqlTopicSubscriptionConfigurator> configure);
    public virtual IEnumerable`1<ValidationResult> Validate();
}
public class MassTransit.SqlTransport.Topology.SqlMessageNameFormatter : object {
    [NullableAttribute("1")]
private IMessageNameFormatter _formatter;
    [NullableContextAttribute("2")]
public SqlMessageNameFormatter(string namespaceSeparator);
    [NullableContextAttribute("1")]
public sealed virtual string GetMessageName(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MassTransit.SqlTransport.Topology.SqlMessagePublishTopology`1 : MessagePublishTopology`1<TMessage> {
    private List`1<ISqlMessagePublishTopology> _implementedMessageTypes;
    private SqlTopicConfigurator _topic;
    public Topic Topic { get; }
    public SqlMessagePublishTopology`1(ISqlPublishTopology publishTopology, IMessageTopology`1<TMessage> messageTopology);
    public sealed virtual Topic get_Topic();
    public sealed virtual void Apply(IPublishEndpointBrokerTopologyBuilder builder);
    public virtual bool TryGetPublishAddress(Uri baseAddress, Uri& publishAddress);
    public sealed virtual BrokerTopology GetBrokerTopology();
    public sealed virtual SendSettings GetSendSettings(Uri hostAddress);
    public void AddImplementedMessageConfigurator(ISqlMessagePublishTopologyConfigurator`1<T> configurator, bool direct);
}
public class MassTransit.SqlTransport.Topology.SqlMessageSendTopology`1 : MessageSendTopology`1<TMessage> {
}
public class MassTransit.SqlTransport.Topology.SqlPublishTopology : PublishTopology {
    private IMessageTopology _messageTopology;
    public SqlPublishTopology(IMessageTopology messageTopology);
    private sealed virtual override ISqlMessagePublishTopology`1<T> MassTransit.ISqlPublishTopology.GetMessageTopology();
    private sealed virtual override ISqlMessagePublishTopologyConfigurator MassTransit.ISqlPublishTopologyConfigurator.GetMessageTopology(Type messageType);
    public sealed virtual BrokerTopology GetPublishBrokerTopology();
    private sealed virtual override ISqlMessagePublishTopologyConfigurator`1<T> MassTransit.ISqlPublishTopologyConfigurator.GetMessageTopology();
    protected virtual IMessagePublishTopologyConfigurator CreateMessageTopology();
}
public class MassTransit.SqlTransport.Topology.SqlSendTopology : SendTopology {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ISqlQueueConfigurator> <ConfigureErrorSettings>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ISqlQueueConfigurator> <ConfigureDeadLetterSettings>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<ISqlQueueConfigurator> ConfigureErrorSettings { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<ISqlQueueConfigurator> ConfigureDeadLetterSettings { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<ISqlQueueConfigurator> get_ConfigureErrorSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConfigureErrorSettings(Action`1<ISqlQueueConfigurator> value);
    [CompilerGeneratedAttribute]
public Action`1<ISqlQueueConfigurator> get_ConfigureDeadLetterSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConfigureDeadLetterSettings(Action`1<ISqlQueueConfigurator> value);
    [NullableContextAttribute("1")]
public sealed virtual ISqlMessageSendTopologyConfigurator`1<T> GetMessageTopology();
    [NullableContextAttribute("1")]
public sealed virtual SendSettings GetSendSettings(SqlEndpointAddress address);
    [NullableContextAttribute("1")]
public sealed virtual SendSettings GetErrorSettings(ReceiveSettings settings);
    [NullableContextAttribute("1")]
public sealed virtual SendSettings GetDeadLetterSettings(ReceiveSettings settings);
    [NullableContextAttribute("1")]
protected virtual IMessageSendTopologyConfigurator CreateMessageTopology(Type type);
}
public interface MassTransit.SqlTransport.Topology.Topic {
    public string TopicName { get; }
    public abstract virtual string get_TopicName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Topology.TopicEntity : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<TopicEntity> <NameComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<TopicEntity> <EntityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TopicName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public static IEqualityComparer`1<TopicEntity> NameComparer { get; }
    public static IEqualityComparer`1<TopicEntity> EntityComparer { get; }
    public string TopicName { get; }
    public long Id { get; }
    public Topic Topic { get; }
    public TopicEntity(long id, string name);
    private static TopicEntity();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<TopicEntity> get_NameComparer();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<TopicEntity> get_EntityComparer();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TopicName();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Id();
    public sealed virtual Topic get_Topic();
    public virtual string ToString();
}
public interface MassTransit.SqlTransport.Topology.TopicHandle {
    public Topic Topic { get; }
    public abstract virtual Topic get_Topic();
}
public class MassTransit.SqlTransport.Topology.TopicSendSettings : SqlTopicConfigurator {
    public string EntityName { get; }
    public Nullable`1<TimeSpan> AutoDeleteOnIdle { get; }
    public TopicSendSettings(SqlEndpointAddress address);
    public sealed virtual SqlEndpointAddress GetSendAddress(Uri hostAddress);
    public sealed virtual BrokerTopology GetBrokerTopology();
    public sealed virtual string get_EntityName();
    public sealed virtual Nullable`1<TimeSpan> get_AutoDeleteOnIdle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.SqlTransport.Topology.TopicSubscriptionEntity : object {
    private TopicEntity _destination;
    private TopicEntity _source;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<TopicSubscriptionEntity> <EntityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlSubscriptionType <SubscriptionType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public static IEqualityComparer`1<TopicSubscriptionEntity> EntityComparer { get; }
    public long Id { get; }
    public TopicToTopicSubscription Subscription { get; }
    public SqlSubscriptionType SubscriptionType { get; }
    public Topic Source { get; }
    public Topic Destination { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public TopicSubscriptionEntity(long id, TopicEntity source, TopicEntity destination, SqlSubscriptionType subscriptionType, string routingKey);
    private static TopicSubscriptionEntity();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<TopicSubscriptionEntity> get_EntityComparer();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Id();
    public sealed virtual TopicToTopicSubscription get_Subscription();
    [CompilerGeneratedAttribute]
public sealed virtual SqlSubscriptionType get_SubscriptionType();
    public sealed virtual Topic get_Source();
    public sealed virtual Topic get_Destination();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_RoutingKey();
    public virtual string ToString();
}
public interface MassTransit.SqlTransport.Topology.TopicSubscriptionHandle {
    public TopicToTopicSubscription Subscription { get; }
    public abstract virtual TopicToTopicSubscription get_Subscription();
}
[NullableContextAttribute("1")]
public interface MassTransit.SqlTransport.Topology.TopicToQueueSubscription {
    public Topic Source { get; }
    public Queue Destination { get; }
    public SqlSubscriptionType SubscriptionType { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public abstract virtual Topic get_Source();
    public abstract virtual Queue get_Destination();
    public abstract virtual SqlSubscriptionType get_SubscriptionType();
    [NullableContextAttribute("2")]
public abstract virtual string get_RoutingKey();
}
[NullableContextAttribute("1")]
public interface MassTransit.SqlTransport.Topology.TopicToTopicSubscription {
    public Topic Source { get; }
    public Topic Destination { get; }
    public SqlSubscriptionType SubscriptionType { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public abstract virtual Topic get_Source();
    public abstract virtual Topic get_Destination();
    public abstract virtual SqlSubscriptionType get_SubscriptionType();
    [NullableContextAttribute("2")]
public abstract virtual string get_RoutingKey();
}
[ExtensionAttribute]
public static class MassTransit.SqlTransport.Topology.TopologyLayoutExtensions : object {
    [ExtensionAttribute]
public static void LogResult(BrokerTopology layout);
}
public class MassTransit.SqlTransportMigrationOptions : object {
    [CompilerGeneratedAttribute]
private bool <CreateDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateInfrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteDatabase>k__BackingField;
    public bool CreateDatabase { get; public set; }
    public bool CreateInfrastructure { get; public set; }
    public bool DeleteDatabase { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CreateDatabase();
    [CompilerGeneratedAttribute]
public void set_CreateDatabase(bool value);
    [CompilerGeneratedAttribute]
public bool get_CreateInfrastructure();
    [CompilerGeneratedAttribute]
public void set_CreateInfrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteDatabase();
    [CompilerGeneratedAttribute]
public void set_DeleteDatabase(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MassTransit.SqlTransportOptions : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdminUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdminPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConnectionLimit>k__BackingField;
    public string Host { get; public set; }
    public Nullable`1<int> Port { get; public set; }
    public string Database { get; public set; }
    public string Schema { get; public set; }
    public string Role { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string AdminUsername { get; public set; }
    public string AdminPassword { get; public set; }
    public string ConnectionString { get; public set; }
    public Nullable`1<int> ConnectionLimit { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
public void set_Role(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_AdminUsername();
    [CompilerGeneratedAttribute]
public void set_AdminUsername(string value);
    [CompilerGeneratedAttribute]
public string get_AdminPassword();
    [CompilerGeneratedAttribute]
public void set_AdminPassword(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConnectionLimit();
    [CompilerGeneratedAttribute]
public void set_ConnectionLimit(Nullable`1<int> value);
}
[ExtensionAttribute]
public static class MassTransit.StateMachineExtensions : object {
    [ExtensionAttribute]
public static Task TransitionToState(BehaviorContext`1<TSaga> context, State state);
}
[ExtensionAttribute]
public static class MassTransit.StateMachineIntrospectionExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.StateMachineIntrospectionExtensions/<NextEvents>d__0`1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<Event>> NextEvents(BehaviorContext`1<TInstance> context);
}
[ExtensionAttribute]
public static class MassTransit.StateMachineRequestExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, EventMessageFactory`3<TInstance, TData, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, AsyncEventMessageFactory`3<TInstance, TData, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`2<TInstance, TData> serviceAddressProvider, EventMessageFactory`3<TInstance, TData, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`2<TInstance, TData> serviceAddressProvider, AsyncEventMessageFactory`3<TInstance, TData, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> Request(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`2<TInstance, TData> serviceAddressProvider, Func`2<BehaviorContext`2<TInstance, TData>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, EventExceptionMessageFactory`3<TInstance, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, AsyncEventExceptionMessageFactory`3<TInstance, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`2<TInstance, TException> serviceAddressProvider, EventExceptionMessageFactory`3<TInstance, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`2<TInstance, TException> serviceAddressProvider, AsyncEventExceptionMessageFactory`3<TInstance, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TInstance, TException> Request(ExceptionActivityBinder`2<TInstance, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`2<TInstance, TException> serviceAddressProvider, Func`2<BehaviorExceptionContext`2<TInstance, TException>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, EventExceptionMessageFactory`4<TInstance, TData, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`3<TInstance, TData, TException> serviceAddressProvider, EventExceptionMessageFactory`4<TInstance, TData, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`3<TInstance, TData, TException> serviceAddressProvider, AsyncEventExceptionMessageFactory`4<TInstance, TData, TException, TRequest> messageFactory);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TInstance, TData, TException> Request(ExceptionActivityBinder`3<TInstance, TData, TException> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressExceptionProvider`3<TInstance, TData, TException> serviceAddressProvider, Func`2<BehaviorExceptionContext`3<TInstance, TData, TException>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, EventMessageFactory`2<TInstance, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, AsyncEventMessageFactory`2<TInstance, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`1<TInstance> serviceAddressProvider, EventMessageFactory`2<TInstance, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`1<TInstance> serviceAddressProvider, AsyncEventMessageFactory`2<TInstance, TRequest> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TInstance> Request(EventActivityBinder`1<TInstance> binder, Request`3<TInstance, TRequest, TResponse> request, ServiceAddressProvider`1<TInstance> serviceAddressProvider, Func`2<BehaviorContext`1<TInstance>, Task`1<SendTuple`1<TRequest>>> messageFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> CancelRequestTimeout(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request);
    [ExtensionAttribute]
public static EventActivityBinder`2<TInstance, TData> ClearRequest(EventActivityBinder`2<TInstance, TData> binder, Request`3<TInstance, TRequest, TResponse> request);
}
[ExtensionAttribute]
public static class MassTransit.SupervisorExtensions : object {
    [ExtensionAttribute]
public static IPipeContextAgent`1<T> AddContext(ISupervisor supervisor, T context);
    [ExtensionAttribute]
public static IPipeContextAgent`1<T> AddContext(ISupervisor supervisor, Task`1<T> context);
    [ExtensionAttribute]
public static IActivePipeContextAgent`1<T> AddActiveContext(ISupervisor supervisor, PipeContextHandle`1<T> contextHandle, Task`1<T> context);
    [ExtensionAttribute]
public static IActivePipeContextAgent`1<T> AddActiveContext(ISupervisor supervisor, PipeContextHandle`1<T> contextHandle, T context);
    [ExtensionAttribute]
public static IAsyncPipeContextAgent`1<T> AddAsyncContext(ISupervisor supervisor);
    [AsyncStateMachineAttribute("MassTransit.SupervisorExtensions/<CreateAgent>d__5`2")]
[ExtensionAttribute]
public static Task`1<TAgent> CreateAgent(ISupervisor`1<T> supervisor, IAsyncPipeContextAgent`1<TAgent> asyncContext, Func`3<T, CancellationToken, Task`1<TAgent>> agentFactory, CancellationToken cancellationToken);
}
public class MassTransit.TestHarnessOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TestInactivityTimeout>k__BackingField;
    public TimeSpan TestTimeout { get; public set; }
    public TimeSpan TestInactivityTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
public void set_TestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TestInactivityTimeout();
    [CompilerGeneratedAttribute]
public void set_TestInactivityTimeout(TimeSpan value);
}
public class MassTransit.Testing.ActivityTestHarness`3 : object {
    private IActivityFactory`3<TActivity, TArguments, TLog> _activityFactory;
    private Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> _configureCompensate;
    private Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> _configureExecute;
    [CompilerGeneratedAttribute]
private string <ExecuteQueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompensateQueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CompensateAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ExecuteAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IReceiveEndpointConfigurator> OnConfigureExecuteReceiveEndpoint;
    [CompilerGeneratedAttribute]
private Action`1<IReceiveEndpointConfigurator> OnConfigureCompensateReceiveEndpoint;
    public string ExecuteQueueName { get; private set; }
    public string CompensateQueueName { get; private set; }
    public Uri CompensateAddress { get; private set; }
    public string Name { get; private set; }
    public Uri ExecuteAddress { get; private set; }
    public ActivityTestHarness`3(BusTestHarness testHarness, IActivityFactory`3<TActivity, TArguments, TLog> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute, Action`1<ICompensateActivityConfigurator`2<TActivity, TLog>> configureCompensate);
    [CompilerGeneratedAttribute]
public string get_ExecuteQueueName();
    [CompilerGeneratedAttribute]
private void set_ExecuteQueueName(string value);
    [CompilerGeneratedAttribute]
public string get_CompensateQueueName();
    [CompilerGeneratedAttribute]
private void set_CompensateQueueName(string value);
    [CompilerGeneratedAttribute]
public Uri get_CompensateAddress();
    [CompilerGeneratedAttribute]
private void set_CompensateAddress(Uri value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_ExecuteAddress();
    [CompilerGeneratedAttribute]
private void set_ExecuteAddress(Uri value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureExecuteReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureExecuteReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureCompensateReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureCompensateReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    private void ConfigureBus(IBusFactoryConfigurator configurator);
    private static string GetActivityName();
    private string BuildQueueName(string prefix);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureBus>b__30_0(IReceiveEndpointConfigurator x);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureBus>b__30_1(IReceiveEndpointConfigurator x);
}
[ExtensionAttribute]
public static class MassTransit.Testing.ActivityTestHarnessExtensions : object {
    [ExtensionAttribute]
public static ActivityTestHarness`3<TActivity, TArguments, TLog> Activity(BusTestHarness harness);
    [ExtensionAttribute]
public static ActivityTestHarness`3<TActivity, TArguments, TLog> Activity(BusTestHarness harness, Func`2<TArguments, TActivity> executeFactoryMethod, Func`2<TLog, TActivity> compensateFactoryMethod);
    [ExtensionAttribute]
public static ExecuteActivityTestHarness`2<TActivity, TArguments> ExecuteActivity(BusTestHarness harness);
    [ExtensionAttribute]
public static ExecuteActivityTestHarness`2<TActivity, TArguments> ExecuteActivity(BusTestHarness harness, Func`2<TArguments, TActivity> executeFactoryMethod);
}
[ExtensionAttribute]
public static class MassTransit.Testing.AsyncElementListExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<First>d__0`1")]
[ExtensionAttribute]
public static Task`1<TElement> First(IAsyncEnumerable`1<TElement> elements);
    [AsyncStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<Count>d__1`1")]
[ExtensionAttribute]
public static Task`1<int> Count(IAsyncEnumerable`1<TElement> elements);
    [ExtensionAttribute]
public static int Count(IAsyncElementList`1<TElement> elements, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<Take>d__3`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<TElement> Take(IAsyncEnumerable`1<TElement> elements, int quantity);
    [AsyncStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<FirstOrDefault>d__4`1")]
[ExtensionAttribute]
public static Task`1<TElement> FirstOrDefault(IAsyncEnumerable`1<TElement> elements);
    [AsyncStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<Any>d__5`1")]
[ExtensionAttribute]
public static Task`1<bool> Any(IAsyncEnumerable`1<TElement> elements);
    [AsyncIteratorStateMachineAttribute("MassTransit.Testing.AsyncElementListExtensions/<Select>d__6`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<TResult> Select(IAsyncEnumerable`1<TElement> elements);
    [ExtensionAttribute]
public static void Deconstruct(ISentMessage sent, Object& message, SendContext& context);
    [ExtensionAttribute]
public static void Deconstruct(ISentMessage`1<TMessage> sent, TMessage& message, SendContext& context);
}
public abstract class MassTransit.Testing.AsyncTestHarness : object {
    private Lazy`1<AsyncInactivityObserver> _inactivityObserver;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private Task`1<bool> _cancelledTask;
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TestInactivityTimeout>k__BackingField;
    public Task TestCancelledTask { get; }
    public CancellationToken TestCancellationToken { get; }
    public Task InactivityTask { get; }
    public CancellationToken InactivityToken { get; }
    public IInactivityObserver InactivityObserver { get; }
    public TimeSpan TestTimeout { get; public set; }
    public TimeSpan TestInactivityTimeout { get; public set; }
    public Task get_TestCancelledTask();
    public CancellationToken get_TestCancellationToken();
    public sealed virtual Task get_InactivityTask();
    public sealed virtual CancellationToken get_InactivityToken();
    public IInactivityObserver get_InactivityObserver();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TestInactivityTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TestInactivityTimeout(TimeSpan value);
    public virtual void Dispose();
    public sealed virtual void Cancel();
    public sealed virtual void ForceInactive();
    public TaskCompletionSource`1<T> GetTask();
    public TestConsumeMessageObserver`1<T> GetConsumeObserver();
    public TestConsumeObserver GetConsumeObserver();
    [CompilerGeneratedAttribute]
private AsyncInactivityObserver <.ctor>b__4_0();
}
public abstract class MassTransit.Testing.BusTestHarness : AsyncTestHarness {
    private BusHandle _busHandle;
    private BusTestConsumeObserver _consumed;
    private BusTestPublishObserver _published;
    private BusTestReceiveObserver _received;
    private BusTestSendObserver _sent;
    [CompilerGeneratedAttribute]
private IBusControl <BusControl>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendEndpoint <BusSendEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ISendEndpoint <InputQueueSendEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<BusTestHarness> PreCreateBus;
    [CompilerGeneratedAttribute]
private Action`1<IReceiveEndpointConfigurator> OnConfigureReceiveEndpoint;
    [CompilerGeneratedAttribute]
private Action`1<IBusFactoryConfigurator> OnConfigureBus;
    [CompilerGeneratedAttribute]
private Action`1<IBusFactoryConfigurator> OnBusConfigured;
    [CompilerGeneratedAttribute]
private Action`1<IBus> OnConnectObservers;
    public IBusControl BusControl { get; private set; }
    public Uri BusAddress { get; }
    public string InputQueueName { get; }
    public Uri InputQueueAddress { get; }
    public ISendEndpoint BusSendEndpoint { get; private set; }
    public ISendEndpoint InputQueueSendEndpoint { get; private set; }
    public IBus Bus { get; }
    public ISentMessageList Sent { get; }
    public CancellationToken CancellationToken { get; }
    public IReceivedMessageList Consumed { get; }
    public IPublishedMessageList Published { get; }
    [CompilerGeneratedAttribute]
public IBusControl get_BusControl();
    [CompilerGeneratedAttribute]
private void set_BusControl(IBusControl value);
    public Uri get_BusAddress();
    public abstract virtual string get_InputQueueName();
    public abstract virtual Uri get_InputQueueAddress();
    [CompilerGeneratedAttribute]
public ISendEndpoint get_BusSendEndpoint();
    [CompilerGeneratedAttribute]
private void set_BusSendEndpoint(ISendEndpoint value);
    [CompilerGeneratedAttribute]
public ISendEndpoint get_InputQueueSendEndpoint();
    [CompilerGeneratedAttribute]
private void set_InputQueueSendEndpoint(ISendEndpoint value);
    public IBus get_Bus();
    public sealed virtual ISentMessageList get_Sent();
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual IReceivedMessageList get_Consumed();
    public sealed virtual IPublishedMessageList get_Published();
    protected abstract virtual IBusControl CreateBus();
    public virtual IRequestClient`1<TRequest> CreateRequestClient();
    public virtual IRequestClient`1<TRequest> CreateRequestClient(Uri destinationAddress);
    protected virtual void ConnectObservers(IBus bus);
    protected virtual void ConfigureBus(IBusFactoryConfigurator configurator);
    protected virtual void ConfigureReceiveEndpoint(IReceiveEndpointConfigurator configurator);
    protected virtual void BusConfigured(IBusFactoryConfigurator configurator);
    [CompilerGeneratedAttribute]
public void add_PreCreateBus(Action`1<BusTestHarness> value);
    [CompilerGeneratedAttribute]
public void remove_PreCreateBus(Action`1<BusTestHarness> value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureBus(Action`1<IBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureBus(Action`1<IBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnBusConfigured(Action`1<IBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnBusConfigured(Action`1<IBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnConnectObservers(Action`1<IBus> value);
    [CompilerGeneratedAttribute]
public void remove_OnConnectObservers(Action`1<IBus> value);
    [AsyncStateMachineAttribute("MassTransit.Testing.BusTestHarness/<Start>d__55")]
public virtual Task Start(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Testing.BusTestHarness/<Stop>d__56")]
public virtual Task Stop();
    [AsyncStateMachineAttribute("MassTransit.Testing.BusTestHarness/<Clean>d__57")]
public virtual Task Clean();
    [AsyncStateMachineAttribute("MassTransit.Testing.BusTestHarness/<GetSendEndpoint>d__58")]
public Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public Task`1<ConsumeContext`1<T>> SubscribeHandler();
    public Task`1<ConsumeContext`1<T>> SubscribeHandler(Func`2<ConsumeContext`1<T>, bool> filter);
    public Task`1<ConsumeContext`1<T>> Handled(IReceiveEndpointConfigurator configurator);
    public Task`1<ConsumeContext`1<T>> Handled(IReceiveEndpointConfigurator configurator, Func`2<ConsumeContext`1<T>, bool> filter);
    public Task`1<ConsumeContext`1<T>> Handled(IReceiveEndpointConfigurator configurator, int expectedCount);
    public Task`1<ConsumeContext`1<T>> Handler(IReceiveEndpointConfigurator configurator, MessageHandler`1<T> handler);
    public Task`1<ConsumeContext`1<T>> HandledByConsumer(IReceiveEndpointConfigurator configurator);
}
public class MassTransit.Testing.ConsumerTestHarness`1 : object {
    private Action`1<IConsumerConfigurator`1<TConsumer>> _configure;
    private ReceivedMessageList _consumed;
    private IConsumerFactory`1<TConsumer> _consumerFactory;
    public IReceivedMessageList Consumed { get; }
    public ConsumerTestHarness`1(BusTestHarness testHarness, IConsumerFactory`1<TConsumer> consumerFactory, Action`1<IConsumerConfigurator`1<TConsumer>> configure, string queueName);
    public ConsumerTestHarness`1(BusTestHarness testHarness, IConsumerFactory`1<TConsumer> consumerFactory, string queueName);
    public ConsumerTestHarness`1(BusTestHarness testHarness, IConsumerFactory`1<TConsumer> consumerFactory, Action`1<IConsumerConfigurator`1<TConsumer>> configure);
    public ConsumerTestHarness`1(BusTestHarness testHarness, IConsumerFactory`1<TConsumer> consumerFactory);
    public sealed virtual IReceivedMessageList get_Consumed();
    protected virtual void ConfigureReceiveEndpoint(IReceiveEndpointConfigurator configurator);
    protected virtual void ConfigureNamedReceiveEndpoint(IBusFactoryConfigurator configurator, string queueName);
    [CompilerGeneratedAttribute]
private void <ConfigureReceiveEndpoint>b__9_0(IConsumerConfigurator`1<TConsumer> c);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureNamedReceiveEndpoint>b__10_0(IReceiveEndpointConfigurator x);
    [CompilerGeneratedAttribute]
private void <ConfigureNamedReceiveEndpoint>b__10_1(IConsumerConfigurator`1<TConsumer> c);
}
[ExtensionAttribute]
public static class MassTransit.Testing.ConsumerTestHarnessExtensions : object {
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, string queueName);
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, Action`1<IConsumerConfigurator`1<T>> configure, string queueName);
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, IConsumerFactory`1<T> consumerFactory, string queueName);
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, IConsumerFactory`1<T> consumerFactory, Action`1<IConsumerConfigurator`1<T>> configure, string queueName);
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, Func`1<T> consumerFactoryMethod, string queueName);
    [ExtensionAttribute]
public static ConsumerTestHarness`1<T> Consumer(BusTestHarness harness, Func`1<T> consumerFactoryMethod, Action`1<IConsumerConfigurator`1<T>> configure, string queueName);
}
public class MassTransit.Testing.ExecuteActivityTestHarness`2 : object {
    private IExecuteActivityFactory`2<TActivity, TArguments> _activityFactory;
    private Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> _configureExecute;
    [CompilerGeneratedAttribute]
private string <ExecuteQueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ExecuteAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IReceiveEndpointConfigurator> OnConfigureExecuteReceiveEndpoint;
    public string ExecuteQueueName { get; private set; }
    public string Name { get; private set; }
    public Uri ExecuteAddress { get; private set; }
    public ExecuteActivityTestHarness`2(BusTestHarness testHarness, IExecuteActivityFactory`2<TActivity, TArguments> activityFactory, Action`1<IExecuteActivityConfigurator`2<TActivity, TArguments>> configureExecute);
    [CompilerGeneratedAttribute]
public string get_ExecuteQueueName();
    [CompilerGeneratedAttribute]
private void set_ExecuteQueueName(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_ExecuteAddress();
    [CompilerGeneratedAttribute]
private void set_ExecuteAddress(Uri value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureExecuteReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureExecuteReceiveEndpoint(Action`1<IReceiveEndpointConfigurator> value);
    private void ConfigureBus(IBusFactoryConfigurator configurator);
    private static string GetActivityName();
    private string BuildQueueName(string prefix);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureBus>b__18_0(IReceiveEndpointConfigurator x);
}
[ExtensionAttribute]
public static class MassTransit.Testing.ExtensionMethodsForBuses : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use the InactivityTask on the test harness instead")]
public static IBusActivityMonitor CreateBusActivityMonitor(IBus bus);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the InactivityTask on the test harness instead")]
public static IBusActivityMonitor CreateBusActivityMonitor(IBus bus, TimeSpan inactivityTimeout);
    private static IBusActivityMonitor CreateBusActivityMonitorInternal(IBus bus, BusActivityReceiveIndicator receiveIndicator, BusActivityConsumeIndicator consumeIndicator, BusActivitySendIndicator sendIndicator, BusActivityPublishIndicator publishIndicator);
}
[ExtensionAttribute]
public static class MassTransit.Testing.ExtensionMethodsForSagas : object {
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(ISagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldContainSaga>d__1`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(ILoadSagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldContainSaga>d__2`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(IQuerySagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(ISagaRepository`1<TSaga> repository, Guid correlationId, Func`2<TSaga, bool> condition, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldContainSaga>d__4`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(ILoadSagaRepository`1<TSaga> repository, Guid correlationId, Func`2<TSaga, bool> condition, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldNotContainSaga(ISagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldNotContainSaga>d__6`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldNotContainSaga(ILoadSagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldNotContainSaga>d__7`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldNotContainSaga(IQuerySagaRepository`1<TSaga> repository, Guid correlationId, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(ISagaRepository`1<TSaga> repository, Expression`1<Func`2<TSaga, bool>> filter, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.ExtensionMethodsForSagas/<ShouldContainSaga>d__9`1")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSaga(IQuerySagaRepository`1<TSaga> repository, Expression`1<Func`2<TSaga, bool>> filter, TimeSpan timeout);
}
public class MassTransit.Testing.FilterDelegate`1 : MulticastDelegate {
    public FilterDelegate`1(object object, IntPtr method);
    public virtual bool Invoke(TContext context);
    public virtual IAsyncResult BeginInvoke(TContext context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class MassTransit.Testing.FilterSet`1 : object {
    private List`1<FilterDelegate`1<T>> _list;
    private FilterDelegate`1<T> _all;
    private FilterDelegate`1<T> _any;
    private FilterDelegate`1<T> _notAny;
    protected FilterSet`1<T> Add(FilterDelegate`1<T> filter);
    public bool All(T target);
    public bool Any(T target);
    public bool NotAny(T target);
    public bool None(T target);
    [CompilerGeneratedAttribute]
private bool <Add>b__5_0(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__5_1(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__5_2(T x);
}
public class MassTransit.Testing.HandlerTestHarness`1 : object {
    private ReceivedMessageList`1<TMessage> _consumed;
    private MessageHandler`1<TMessage> _handler;
    public IReceivedMessageList`1<TMessage> Consumed { get; }
    public HandlerTestHarness`1(BusTestHarness testHarness, MessageHandler`1<TMessage> handler);
    public IReceivedMessageList`1<TMessage> get_Consumed();
    private void ConfigureReceiveEndpoint(IReceiveEndpointConfigurator configurator);
    [AsyncStateMachineAttribute("MassTransit.Testing.HandlerTestHarness`1/<HandleMessage>d__6")]
private Task HandleMessage(ConsumeContext`1<TMessage> context);
}
[ExtensionAttribute]
public static class MassTransit.Testing.HandlerTestHarnessExtensions : object {
    [ExtensionAttribute]
public static HandlerTestHarness`1<T> Handler(BusTestHarness harness, MessageHandler`1<T> handler);
    [ExtensionAttribute]
public static HandlerTestHarness`1<T> Handler(BusTestHarness harness);
}
public interface MassTransit.Testing.IAsyncElementList`1 {
    public abstract virtual IEnumerable`1<TElement> Select(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<TElement> SelectAsync(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
}
public interface MassTransit.Testing.IAsyncListElement {
    public Nullable`1<Guid> ElementId { get; }
    public abstract virtual Nullable`1<Guid> get_ElementId();
}
public interface MassTransit.Testing.IBaseTestHarness {
    public TimeSpan TestTimeout { get; public set; }
    public TimeSpan TestInactivityTimeout { get; public set; }
    public CancellationToken CancellationToken { get; }
    public CancellationToken InactivityToken { get; }
    public Task InactivityTask { get; }
    public IReceivedMessageList Consumed { get; }
    public IPublishedMessageList Published { get; }
    public ISentMessageList Sent { get; }
    public abstract virtual TimeSpan get_TestTimeout();
    public abstract virtual void set_TestTimeout(TimeSpan value);
    public abstract virtual TimeSpan get_TestInactivityTimeout();
    public abstract virtual void set_TestInactivityTimeout(TimeSpan value);
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual CancellationToken get_InactivityToken();
    public abstract virtual Task get_InactivityTask();
    public abstract virtual IReceivedMessageList get_Consumed();
    public abstract virtual IPublishedMessageList get_Published();
    public abstract virtual ISentMessageList get_Sent();
    public abstract virtual void Cancel();
    public abstract virtual void ForceInactive();
}
public interface MassTransit.Testing.IConsumedMessage {
    public ConsumeContext Context { get; }
    public Exception Exception { get; }
    public Type MessageType { get; }
    public abstract virtual ConsumeContext get_Context();
    public abstract virtual Exception get_Exception();
    public abstract virtual Type get_MessageType();
}
public interface MassTransit.Testing.IConsumedMessage`1 {
    public ConsumeContext`1<T> Context { get; }
    public abstract virtual ConsumeContext`1<T> get_Context();
}
public interface MassTransit.Testing.IConsumerTestHarness`1 {
    public IReceivedMessageList Consumed { get; }
    public abstract virtual IReceivedMessageList get_Consumed();
}
public abstract class MassTransit.Testing.Implementations.AsyncElementList`1 : object {
    private Connectable`1<Channel`1<TElement>> _channels;
    private IDictionary`2<Guid, TElement> _messageLookup;
    private List`1<TElement> _messages;
    private CancellationToken _testCompleted;
    private TimeSpan _timeout;
    protected AsyncElementList`1(TimeSpan timeout, CancellationToken testCompleted);
    [AsyncIteratorStateMachineAttribute("MassTransit.Testing.Implementations.AsyncElementList`1/<SelectAsync>d__6")]
public sealed virtual IAsyncEnumerable`1<TElement> SelectAsync(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.AsyncElementList`1/<Any>d__7")]
public sealed virtual Task`1<bool> Any(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("MassTransit.Testing.Implementations.AsyncElementList`1/<Select>d__8")]
public sealed virtual IEnumerable`1<TElement> Select(FilterDelegate`1<TElement> filter, CancellationToken cancellationToken);
    protected void Add(TElement context);
}
public class MassTransit.Testing.Implementations.AsyncInactivityObserver : object {
    private Lazy`1<Task> _inactivityTask;
    private TaskCompletionSource`1<bool> _inactivityTaskSource;
    private CancellationTokenSource _inactivityTokenSource;
    private HashSet`1<IInactivityObservationSource> _sources;
    public Task InactivityTask { get; }
    public CancellationToken InactivityToken { get; }
    public AsyncInactivityObserver(TimeSpan timeout, CancellationToken cancellationToken);
    public Task get_InactivityTask();
    public CancellationToken get_InactivityToken();
    public sealed virtual void Connected(IInactivityObservationSource source);
    public sealed virtual Task NoActivity();
    public sealed virtual void ForceInactive();
    private Task`1<bool> CheckSourceActivity();
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.AsyncInactivityObserver/<TimeoutTask>d__13")]
private Task TimeoutTask(TimeSpan timeout, CancellationToken cancellationToken);
}
public abstract class MassTransit.Testing.Implementations.BaseBusActivityIndicatorConnectable : Connectable`1<IConditionObserver> {
    public bool IsMet { get; }
    public sealed virtual ConnectHandle ConnectConditionObserver(IConditionObserver observer);
    public abstract virtual bool get_IsMet();
    protected Task ConditionUpdated();
}
public abstract class MassTransit.Testing.Implementations.BaseSagaTestHarness`1 : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IQuerySagaRepository`1<TSaga> <QuerySagaRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoadSagaRepository`1<TSaga> <LoadSagaRepository>k__BackingField;
    protected TimeSpan TestTimeout { get; }
    protected IQuerySagaRepository`1<TSaga> QuerySagaRepository { get; }
    protected ILoadSagaRepository`1<TSaga> LoadSagaRepository { get; }
    protected BaseSagaTestHarness`1(IQuerySagaRepository`1<TSaga> querySagaRepository, ILoadSagaRepository`1<TSaga> loadSagaRepository, TimeSpan testTimeout);
    [CompilerGeneratedAttribute]
protected TimeSpan get_TestTimeout();
    [CompilerGeneratedAttribute]
protected IQuerySagaRepository`1<TSaga> get_QuerySagaRepository();
    [CompilerGeneratedAttribute]
protected ILoadSagaRepository`1<TSaga> get_LoadSagaRepository();
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.BaseSagaTestHarness`1/<Exists>d__10")]
public sealed virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.BaseSagaTestHarness`1/<Match>d__11")]
public sealed virtual Task`1<IList`1<Guid>> Match(Expression`1<Func`2<TSaga, bool>> filter, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.BaseSagaTestHarness`1/<NotExists>d__12")]
public sealed virtual Task`1<Nullable`1<Guid>> NotExists(Guid correlationId, Nullable`1<TimeSpan> timeout);
}
public class MassTransit.Testing.Implementations.BusActivityConsumeIndicator : BaseBusActivityIndicatorConnectable {
    private ISignalResource _signalResource;
    private int _messagesInFlight;
    public bool IsMet { get; }
    public BusActivityConsumeIndicator(ISignalResource signalResource);
    public virtual bool get_IsMet();
    private sealed virtual override Task MassTransit.IConsumeObserver.PreConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.PostConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.ConsumeFault(ConsumeContext`1<T> context, Exception exception);
    public sealed virtual void Signal();
}
public class MassTransit.Testing.Implementations.BusActivityMonitor : object {
    private SemaphoreSlim _activityEvent;
    private sealed virtual override Task MassTransit.Testing.Implementations.IBusActivityMonitor.AwaitBusInactivity();
    private sealed virtual override Task`1<bool> MassTransit.Testing.Implementations.IBusActivityMonitor.AwaitBusInactivity(TimeSpan timeout);
    private sealed virtual override Task MassTransit.Testing.Implementations.IBusActivityMonitor.AwaitBusInactivity(CancellationToken cancellationToken);
    private sealed virtual override void MassTransit.Testing.Implementations.ISignalResource.Signal();
}
public class MassTransit.Testing.Implementations.BusActivityPublishIndicator : BaseBusActivityIndicatorConnectable {
    private RollingTimer _receiveIdleTimer;
    private ISignalResource _signalResource;
    private int _activityStarted;
    public bool IsMet { get; }
    public BusActivityPublishIndicator(ISignalResource signalResource, TimeSpan receiveIdleTimeout);
    public BusActivityPublishIndicator(ISignalResource signalResource);
    public BusActivityPublishIndicator(TimeSpan receiveIdleTimeout);
    public virtual bool get_IsMet();
    public sealed virtual void Signal();
    public Task PrePublish(PublishContext`1<T> context);
    public Task PostPublish(PublishContext`1<T> context);
    public Task PublishFault(PublishContext`1<T> context, Exception exception);
    private void SignalInactivity(object state);
}
public class MassTransit.Testing.Implementations.BusActivityReceiveIndicator : BaseBusActivityIndicatorConnectable {
    private RollingTimer _receiveIdleTimer;
    private ISignalResource _signalResource;
    private int _activityStarted;
    public bool IsMet { get; }
    public BusActivityReceiveIndicator(ISignalResource signalResource, TimeSpan receiveIdleTimeout);
    public BusActivityReceiveIndicator(ISignalResource signalResource);
    public BusActivityReceiveIndicator(TimeSpan receiveIdleTimeout);
    public virtual bool get_IsMet();
    private sealed virtual override Task MassTransit.IReceiveObserver.PreReceive(ReceiveContext context);
    private sealed virtual override Task MassTransit.IReceiveObserver.PostReceive(ReceiveContext context);
    private sealed virtual override Task MassTransit.IReceiveObserver.PostConsume(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    private sealed virtual override Task MassTransit.IReceiveObserver.ConsumeFault(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    private sealed virtual override Task MassTransit.IReceiveObserver.ReceiveFault(ReceiveContext context, Exception exception);
    public sealed virtual void Signal();
    private void SignalInactivity(object state);
}
public class MassTransit.Testing.Implementations.BusActivitySendIndicator : BaseBusActivityIndicatorConnectable {
    private RollingTimer _receiveIdleTimer;
    private ISignalResource _signalResource;
    private int _activityStarted;
    public bool IsMet { get; }
    public BusActivitySendIndicator(ISignalResource signalResource, TimeSpan receiveIdleTimeout);
    public BusActivitySendIndicator(ISignalResource signalResource);
    public BusActivitySendIndicator(TimeSpan receiveIdleTimeout);
    public virtual bool get_IsMet();
    public sealed virtual void Signal();
    public Task PreSend(SendContext`1<T> context);
    public Task PostSend(SendContext`1<T> context);
    public Task SendFault(SendContext`1<T> context, Exception exception);
    private void SignalInactivity(object state);
}
public class MassTransit.Testing.Implementations.BusTestConsumeObserver : InactivityTestObserver {
    private ReceivedMessageList _messages;
    private int _activeCount;
    public IReceivedMessageList Messages { get; }
    public bool IsInactive { get; }
    public BusTestConsumeObserver(TimeSpan timeout, CancellationToken testCompleted);
    public IReceivedMessageList get_Messages();
    public virtual bool get_IsInactive();
    public sealed virtual Task PreConsume(ConsumeContext`1<T> context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context);
    public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.Implementations.BusTestPublishObserver : InactivityTestObserver {
    private PublishedMessageList _messages;
    public IPublishedMessageList Messages { get; }
    public BusTestPublishObserver(TimeSpan timeout, TimeSpan inactivityTimout, CancellationToken testCompleted);
    public IPublishedMessageList get_Messages();
    private sealed virtual override Task MassTransit.IPublishObserver.PrePublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PostPublish(PublishContext`1<T> context);
    private sealed virtual override Task MassTransit.IPublishObserver.PublishFault(PublishContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.Implementations.BusTestReceiveObserver : InactivityTestObserver {
    public BusTestReceiveObserver(TimeSpan inactivityTimout);
    public sealed virtual Task PreReceive(ReceiveContext context);
    public sealed virtual Task PostReceive(ReceiveContext context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public sealed virtual Task ReceiveFault(ReceiveContext context, Exception exception);
}
public class MassTransit.Testing.Implementations.BusTestSendObserver : InactivityTestObserver {
    private SentMessageList _messages;
    public ISentMessageList Messages { get; }
    public BusTestSendObserver(TimeSpan timeout, TimeSpan inactivityTimout, CancellationToken testCompleted);
    public ISentMessageList get_Messages();
    public sealed virtual Task PreSend(SendContext`1<T> context);
    public sealed virtual Task PostSend(SendContext`1<T> context);
    public sealed virtual Task SendFault(SendContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.Implementations.ConditionExpression : object {
    private List`1<IObservableCondition[]> _conditionBlocks;
    private ISignalResource _resource;
    public ConditionExpression(ISignalResource resource);
    public sealed virtual Task ConditionUpdated();
    public void AddConditionBlock(IObservableCondition[] conditions);
    public void ClearAllConditions();
    public bool CheckCondition();
}
public interface MassTransit.Testing.Implementations.IBusActivityMonitor {
    public abstract virtual Task AwaitBusInactivity();
    public abstract virtual Task`1<bool> AwaitBusInactivity(TimeSpan timeout);
    public abstract virtual Task AwaitBusInactivity(CancellationToken cancellationToken);
}
public interface MassTransit.Testing.Implementations.ICondition {
    public bool IsMet { get; }
    public abstract virtual bool get_IsMet();
}
public interface MassTransit.Testing.Implementations.IConditionObserver {
    public abstract virtual Task ConditionUpdated();
}
public interface MassTransit.Testing.Implementations.IInactivityObservationSource {
    public bool IsInactive { get; }
    public abstract virtual bool get_IsInactive();
    public abstract virtual ConnectHandle ConnectInactivityObserver(IInactivityObserver observer);
}
public interface MassTransit.Testing.Implementations.IInactivityObserver {
    public abstract virtual void Connected(IInactivityObservationSource source);
    public abstract virtual Task NoActivity();
    public abstract virtual void ForceInactive();
}
public abstract class MassTransit.Testing.Implementations.InactivityTestObserver : Connectable`1<IInactivityObserver> {
    private int _activityDetected;
    private RollingTimer _inactivityTimer;
    public bool IsInactive { get; }
    public sealed virtual void Dispose();
    public sealed virtual ConnectHandle ConnectInactivityObserver(IInactivityObserver observer);
    public virtual bool get_IsInactive();
    protected void StartTimer(TimeSpan inactivityTimout);
    protected Task RestartTimer(bool activityDetected);
    protected Task NotifyInactive();
    private void OnActivityTimeout(object state);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <OnActivityTimeout>b__9_0();
}
public class MassTransit.Testing.Implementations.InMemoryTestHarnessBusInstance : object {
    private IBusRegistrationContext _busRegistrationContext;
    [CompilerGeneratedAttribute]
private InMemoryTestHarness <Harness>k__BackingField;
    public InMemoryTestHarness Harness { get; }
    public string Name { get; }
    public Type InstanceType { get; }
    public IBus Bus { get; }
    public IBusControl BusControl { get; }
    public IHostConfiguration HostConfiguration { get; }
    public InMemoryTestHarnessBusInstance(InMemoryTestHarness testHarness, IBusRegistrationContext busRegistrationContext);
    [CompilerGeneratedAttribute]
public InMemoryTestHarness get_Harness();
    public sealed virtual string get_Name();
    public sealed virtual Type get_InstanceType();
    public sealed virtual IBus get_Bus();
    public sealed virtual IBusControl get_BusControl();
    public sealed virtual IHostConfiguration get_HostConfiguration();
    public sealed virtual void Connect(IRiderControl riderControl);
    public sealed virtual TRider GetRider();
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
}
public interface MassTransit.Testing.Implementations.IObservableCondition {
    public abstract virtual ConnectHandle ConnectConditionObserver(IConditionObserver observer);
}
public interface MassTransit.Testing.Implementations.ISignalResource {
    public abstract virtual void Signal();
}
public class MassTransit.Testing.Implementations.RegistrationConsumerTestHarness`1 : object {
    private ReceivedMessageList _consumed;
    public IReceivedMessageList Consumed { get; }
    public RegistrationConsumerTestHarness`1(IConsumerFactoryDecoratorRegistration`1<TConsumer> registration);
    public sealed virtual IReceivedMessageList get_Consumed();
}
public class MassTransit.Testing.Implementations.RegistrationSagaStateMachineTestHarness`2 : BaseSagaTestHarness`1<TInstance> {
    [CompilerGeneratedAttribute]
private IReceivedMessageList <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private ISagaList`1<TInstance> <Sagas>k__BackingField;
    [CompilerGeneratedAttribute]
private ISagaList`1<TInstance> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private TStateMachine <StateMachine>k__BackingField;
    public IReceivedMessageList Consumed { get; }
    public ISagaList`1<TInstance> Sagas { get; }
    public ISagaList`1<TInstance> Created { get; }
    public TStateMachine StateMachine { get; }
    public RegistrationSagaStateMachineTestHarness`2(ISagaRepositoryDecoratorRegistration`1<TInstance> registration, IQuerySagaRepository`1<TInstance> querySagaRepository, ILoadSagaRepository`1<TInstance> loadSagaRepository, TStateMachine stateMachine);
    [CompilerGeneratedAttribute]
public sealed virtual IReceivedMessageList get_Consumed();
    [CompilerGeneratedAttribute]
public sealed virtual ISagaList`1<TInstance> get_Sagas();
    [CompilerGeneratedAttribute]
public sealed virtual ISagaList`1<TInstance> get_Created();
    [CompilerGeneratedAttribute]
public sealed virtual TStateMachine get_StateMachine();
    public sealed virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.RegistrationSagaStateMachineTestHarness`2/<Exists>d__14")]
public sealed virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, State state, Nullable`1<TimeSpan> timeout);
    public sealed virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.RegistrationSagaStateMachineTestHarness`2/<Exists>d__16")]
public sealed virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, State state, Nullable`1<TimeSpan> timeout);
}
public class MassTransit.Testing.Implementations.RegistrationSagaTestHarness`1 : BaseSagaTestHarness`1<TSaga> {
    [CompilerGeneratedAttribute]
private IReceivedMessageList <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private ISagaList`1<TSaga> <Sagas>k__BackingField;
    [CompilerGeneratedAttribute]
private ISagaList`1<TSaga> <Created>k__BackingField;
    public IReceivedMessageList Consumed { get; }
    public ISagaList`1<TSaga> Sagas { get; }
    public ISagaList`1<TSaga> Created { get; }
    public RegistrationSagaTestHarness`1(ISagaRepositoryDecoratorRegistration`1<TSaga> registration, ISagaRepository`1<TSaga> repository, ILoadSagaRepository`1<TSaga> loadRepository, IQuerySagaRepository`1<TSaga> queryRepository);
    [CompilerGeneratedAttribute]
public sealed virtual IReceivedMessageList get_Consumed();
    [CompilerGeneratedAttribute]
public sealed virtual ISagaList`1<TSaga> get_Sagas();
    [CompilerGeneratedAttribute]
public sealed virtual ISagaList`1<TSaga> get_Created();
}
public class MassTransit.Testing.Implementations.SagaInstance`1 : object {
    [CompilerGeneratedAttribute]
private T <Saga>k__BackingField;
    public T Saga { get; }
    public Nullable`1<Guid> ElementId { get; }
    public SagaInstance`1(T saga);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Saga();
    public sealed virtual Nullable`1<Guid> get_ElementId();
}
public class MassTransit.Testing.Implementations.SagaList`1 : AsyncElementList`1<ISagaInstance`1<T>> {
    public SagaList`1(TimeSpan timeout, CancellationToken testCompleted);
    public sealed virtual IEnumerable`1<ISagaInstance`1<T>> Select(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
    public sealed virtual T Contains(Guid sagaId);
    public sealed virtual IAsyncEnumerable`1<ISagaInstance`1<T>> SelectAsync(CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<ISagaInstance`1<T>> SelectAsync(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
    public void Add(SagaConsumeContext`1<T> context);
}
public class MassTransit.Testing.Implementations.StateMachineSagaTestHarness`2 : SagaTestHarness`1<TInstance> {
    [CompilerGeneratedAttribute]
private TStateMachine <StateMachine>k__BackingField;
    public TStateMachine StateMachine { get; }
    public StateMachineSagaTestHarness`2(BusTestHarness testHarness, ISagaRepository`1<TInstance> repository, IQuerySagaRepository`1<TInstance> querySagaRepository, ILoadSagaRepository`1<TInstance> loadSagaRepository, TStateMachine stateMachine, string queueName);
    [CompilerGeneratedAttribute]
public sealed virtual TStateMachine get_StateMachine();
    public sealed virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.StateMachineSagaTestHarness`2/<Exists>d__5")]
public sealed virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, State state, Nullable`1<TimeSpan> timeout);
    public sealed virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.Implementations.StateMachineSagaTestHarness`2/<Exists>d__7")]
public sealed virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, State state, Nullable`1<TimeSpan> timeout);
    protected virtual void ConfigureReceiveEndpoint(IReceiveEndpointConfigurator configurator);
    protected virtual void ConfigureNamedReceiveEndpoint(IBusFactoryConfigurator configurator, string queueName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureNamedReceiveEndpoint>b__9_0(IReceiveEndpointConfigurator x);
}
public class MassTransit.Testing.Implementations.TestConsumeMessageObserver`1 : object {
    private TaskCompletionSource`1<T> _consumeFaulted;
    private TaskCompletionSource`1<T> _postConsumed;
    private TaskCompletionSource`1<T> _preConsumed;
    public Task`1<T> PreConsumed { get; }
    public Task`1<T> PostConsumed { get; }
    public Task`1<T> ConsumeFaulted { get; }
    public TestConsumeMessageObserver`1(TaskCompletionSource`1<T> preConsumed, TaskCompletionSource`1<T> postConsumed, TaskCompletionSource`1<T> consumeFaulted);
    public Task`1<T> get_PreConsumed();
    public Task`1<T> get_PostConsumed();
    public Task`1<T> get_ConsumeFaulted();
    private sealed virtual override Task MassTransit.IConsumeMessageObserver<T>.PreConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeMessageObserver<T>.PostConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeMessageObserver<T>.ConsumeFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.Implementations.TestConsumeObserver : object {
    private ReceivedMessageList _messages;
    public IReceivedMessageList Messages { get; }
    public TestConsumeObserver(TimeSpan timeout, CancellationToken inactivityToken);
    public IReceivedMessageList get_Messages();
    private sealed virtual override Task MassTransit.IConsumeObserver.PreConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.PostConsume(ConsumeContext`1<T> context);
    private sealed virtual override Task MassTransit.IConsumeObserver.ConsumeFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.Implementations.TestConsumerFactoryDecorator`1 : object {
    private IConsumerFactory`1<TConsumer> _consumerFactory;
    private ReceivedMessageList _received;
    public TestConsumerFactoryDecorator`1(IConsumerFactory`1<TConsumer> consumerFactory, ReceivedMessageList received);
    public sealed virtual Task Send(ConsumeContext`1<TMessage> context, IPipe`1<ConsumerConsumeContext`2<TConsumer, TMessage>> next);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
}
public class MassTransit.Testing.Implementations.TestReceiveEndpointObserver : object {
    private IPublishObserver _publishObserver;
    public TestReceiveEndpointObserver(IPublishObserver publishObserver);
    public sealed virtual Task Ready(ReceiveEndpointReady ready);
    public sealed virtual Task Stopping(ReceiveEndpointStopping stopping);
    public sealed virtual Task Completed(ReceiveEndpointCompleted completed);
    public sealed virtual Task Faulted(ReceiveEndpointFaulted faulted);
}
public class MassTransit.Testing.InMemoryTestHarness : BusTestHarness {
    private InMemoryBusConfiguration _busConfiguration;
    private string _inputQueueName;
    private IEnumerable`1<IBusInstanceSpecification> _specifications;
    [CompilerGeneratedAttribute]
private Uri <BaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InputQueueAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IInMemoryBusFactoryConfigurator> OnConfigureInMemoryBus;
    [CompilerGeneratedAttribute]
private Action`1<IInMemoryReceiveEndpointConfigurator> OnConfigureInMemoryReceiveEndpoint;
    [CompilerGeneratedAttribute]
private Action`1<IInMemoryBusFactoryConfigurator> OnInMemoryBusConfigured;
    public Uri BaseAddress { get; }
    public Uri InputQueueAddress { get; }
    public string InputQueueName { get; }
    internal IHostConfiguration HostConfiguration { get; }
    public InMemoryTestHarness(string virtualHost);
    public InMemoryTestHarness(string virtualHost, IEnumerable`1<IBusInstanceSpecification> specifications);
    [CompilerGeneratedAttribute]
public Uri get_BaseAddress();
    [CompilerGeneratedAttribute]
public virtual Uri get_InputQueueAddress();
    public virtual string get_InputQueueName();
    internal IHostConfiguration get_HostConfiguration();
    [CompilerGeneratedAttribute]
public void add_OnConfigureInMemoryBus(Action`1<IInMemoryBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureInMemoryBus(Action`1<IInMemoryBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureInMemoryReceiveEndpoint(Action`1<IInMemoryReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureInMemoryReceiveEndpoint(Action`1<IInMemoryReceiveEndpointConfigurator> value);
    [CompilerGeneratedAttribute]
public void add_OnInMemoryBusConfigured(Action`1<IInMemoryBusFactoryConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnInMemoryBusConfigured(Action`1<IInMemoryBusFactoryConfigurator> value);
    protected virtual void ConfigureInMemoryBus(IInMemoryBusFactoryConfigurator configurator);
    protected virtual void ConfigureInMemoryReceiveEndpoint(IInMemoryReceiveEndpointConfigurator configurator);
    protected virtual void InMemoryBusConfigured(IInMemoryBusFactoryConfigurator configurator);
    public virtual Task`1<IRequestClient`1<TRequest>> ConnectRequestClient();
    public virtual Task`1<IRequestClient`1<TRequest>> ConnectRequestClient(Uri destinationAddress);
    protected virtual IBusControl CreateBus();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CreateBus>b__29_0(IInMemoryReceiveEndpointConfigurator e);
}
public interface MassTransit.Testing.IPublishedMessage {
    public SendContext Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    public Exception Exception { get; }
    public Type MessageType { get; }
    public string ShortTypeName { get; }
    public object MessageObject { get; }
    public abstract virtual SendContext get_Context();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual TimeSpan get_ElapsedTime();
    public abstract virtual Exception get_Exception();
    public abstract virtual Type get_MessageType();
    public abstract virtual string get_ShortTypeName();
    public abstract virtual object get_MessageObject();
}
public interface MassTransit.Testing.IPublishedMessage`1 {
    public PublishContext`1<T> Context { get; }
    public abstract virtual PublishContext`1<T> get_Context();
}
public interface MassTransit.Testing.IPublishedMessageList {
    public abstract virtual IEnumerable`1<IPublishedMessage`1<T>> Select(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<IPublishedMessage`1<T>> Select(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IPublishedMessage> SelectAsync(Action`1<PublishedMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IPublishedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IPublishedMessage`1<T>> SelectAsync(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(Action`1<PublishedMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
}
public interface MassTransit.Testing.IReceivedMessage {
    public ConsumeContext Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    public Exception Exception { get; }
    public Type MessageType { get; }
    public string ShortTypeName { get; }
    public object MessageObject { get; }
    public abstract virtual ConsumeContext get_Context();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual TimeSpan get_ElapsedTime();
    public abstract virtual Exception get_Exception();
    public abstract virtual Type get_MessageType();
    public abstract virtual string get_ShortTypeName();
    public abstract virtual object get_MessageObject();
}
public interface MassTransit.Testing.IReceivedMessage`1 {
    public ConsumeContext`1<T> Context { get; }
    public abstract virtual ConsumeContext`1<T> get_Context();
}
public interface MassTransit.Testing.IReceivedMessageList {
    public abstract virtual IEnumerable`1<IReceivedMessage`1<T>> Select(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<IReceivedMessage`1<T>> Select(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IReceivedMessage> SelectAsync(Action`1<ReceivedMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(Action`1<ReceivedMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
}
public interface MassTransit.Testing.IReceivedMessageList`1 {
    public abstract virtual IEnumerable`1<IReceivedMessage`1<T>> Select(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(CancellationToken cancellationToken);
}
public interface MassTransit.Testing.ISagaInstance`1 {
    public T Saga { get; }
    public abstract virtual T get_Saga();
}
public interface MassTransit.Testing.ISagaList`1 {
    public abstract virtual IEnumerable`1<ISagaInstance`1<T>> Select(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
    public abstract virtual T Contains(Guid sagaId);
    public abstract virtual IAsyncEnumerable`1<ISagaInstance`1<T>> SelectAsync(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<ISagaInstance`1<T>> SelectAsync(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(FilterDelegate`1<T> filter, CancellationToken cancellationToken);
}
public interface MassTransit.Testing.ISagaStateMachineTestHarness`2 {
    public TStateMachine StateMachine { get; }
    public abstract virtual TStateMachine get_StateMachine();
    public abstract virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, State state, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, Func`2<TStateMachine, State> stateSelector, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<IList`1<Guid>> Exists(Expression`1<Func`2<TInstance, bool>> expression, State state, Nullable`1<TimeSpan> timeout);
}
public interface MassTransit.Testing.ISagaTestHarness`1 {
    public IReceivedMessageList Consumed { get; }
    public ISagaList`1<TSaga> Sagas { get; }
    public ISagaList`1<TSaga> Created { get; }
    public abstract virtual IReceivedMessageList get_Consumed();
    public abstract virtual ISagaList`1<TSaga> get_Sagas();
    public abstract virtual ISagaList`1<TSaga> get_Created();
    public abstract virtual Task`1<Nullable`1<Guid>> Exists(Guid correlationId, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<IList`1<Guid>> Match(Expression`1<Func`2<TSaga, bool>> filter, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<Nullable`1<Guid>> NotExists(Guid correlationId, Nullable`1<TimeSpan> timeout);
}
public interface MassTransit.Testing.ISentMessage {
    public SendContext Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    public Exception Exception { get; }
    public Type MessageType { get; }
    public string ShortTypeName { get; }
    public object MessageObject { get; }
    public abstract virtual SendContext get_Context();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual TimeSpan get_ElapsedTime();
    public abstract virtual Exception get_Exception();
    public abstract virtual Type get_MessageType();
    public abstract virtual string get_ShortTypeName();
    public abstract virtual object get_MessageObject();
}
public interface MassTransit.Testing.ISentMessage`1 {
    public SendContext`1<TMessage> Context { get; }
    public abstract virtual SendContext`1<TMessage> get_Context();
}
public interface MassTransit.Testing.ISentMessageList {
    public abstract virtual IEnumerable`1<ISentMessage`1<T>> Select(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISentMessage`1<T>> Select(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<ISentMessage> SelectAsync(Action`1<SentMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<ISentMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<ISentMessage`1<T>> SelectAsync(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(Action`1<SentMessageFilter> apply, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> Any(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use ISagaStateMachineTestHarness<TStateMachine, TInstance> instead")]
public interface MassTransit.Testing.IStateMachineSagaTestHarness`2 {
}
public interface MassTransit.Testing.ITestHarness {
    public IBus Bus { get; }
    public IServiceScope Scope { get; }
    public IServiceProvider Provider { get; }
    public IEndpointNameFormatter EndpointNameFormatter { get; }
    public abstract virtual IBus get_Bus();
    public abstract virtual IServiceScope get_Scope();
    public abstract virtual IServiceProvider get_Provider();
    public abstract virtual IEndpointNameFormatter get_EndpointNameFormatter();
    public abstract virtual TaskCompletionSource`1<T> GetTask();
    public abstract virtual IConsumerTestHarness`1<T> GetConsumerHarness();
    public abstract virtual ISagaTestHarness`1<T> GetSagaHarness();
    public abstract virtual ISagaStateMachineTestHarness`2<TStateMachine, T> GetSagaStateMachineHarness();
    public abstract virtual IRequestClient`1<T> GetRequestClient();
    public abstract virtual Task`1<ISendEndpoint> GetConsumerEndpoint();
    public abstract virtual Task`1<ISendEndpoint> GetHandlerEndpoint();
    public abstract virtual Uri GetConsumerAddress();
    public abstract virtual Uri GetHandlerAddress();
    public abstract virtual Task`1<ISendEndpoint> GetSagaEndpoint();
    public abstract virtual Uri GetSagaAddress();
    public abstract virtual Task`1<ISendEndpoint> GetExecuteActivityEndpoint();
    public abstract virtual Uri GetExecuteActivityAddress();
    public abstract virtual Task Start();
}
public class MassTransit.Testing.MediatorTestHarness : AsyncTestHarness {
    private BusTestConsumeObserver _consumed;
    private BusTestPublishObserver _published;
    private BusTestSendObserver _sent;
    [CompilerGeneratedAttribute]
private IMediator <Mediator>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IMediatorConfigurator> OnConfigureMediator;
    public IMediator Mediator { get; private set; }
    [CompilerGeneratedAttribute]
public IMediator get_Mediator();
    [CompilerGeneratedAttribute]
private void set_Mediator(IMediator value);
    [CompilerGeneratedAttribute]
public void add_OnConfigureMediator(Action`1<IMediatorConfigurator> value);
    [CompilerGeneratedAttribute]
public void remove_OnConfigureMediator(Action`1<IMediatorConfigurator> value);
    [AsyncStateMachineAttribute("MassTransit.Testing.MediatorTestHarness/<Start>d__11")]
public virtual Task Start();
    protected virtual void ConfigureMediator(IMediatorConfigurator configurator);
    public virtual IRequestClient`1<TRequest> CreateRequestClient();
    private IMediator CreateMediator();
    [CompilerGeneratedAttribute]
private void <CreateMediator>b__14_0(IMediatorConfigurator configurator);
}
public class MassTransit.Testing.MultiTestConsumer : object {
    private List`1<IConsumerConfigurator> _configures;
    private ReceivedMessageList _received;
    private CancellationToken _testCompleted;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public IReceivedMessageList Received { get; }
    public TimeSpan Timeout { get; }
    public MultiTestConsumer(TimeSpan timeout, CancellationToken testCompleted);
    public IReceivedMessageList get_Received();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    public ReceivedMessageList`1<T> Consume();
    public ReceivedMessageList`1<T> Fault();
    public ConnectHandle Connect(IConsumePipeConnector bus);
    public void Configure(IReceiveEndpointConfigurator configurator);
}
public class MassTransit.Testing.PublishedMessage`1 : object {
    private PublishContext`1<T> _context;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ElementId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Nullable`1<Guid> ElementId { get; }
    private SendContext MassTransit.Testing.IPublishedMessage.Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    public Exception Exception { get; }
    public Type MessageType { get; }
    public string ShortTypeName { get; }
    private object MassTransit.Testing.IPublishedMessage.MessageObject { get; }
    private PublishContext`1<T> MassTransit.Testing.IPublishedMessage<T>.Context { get; }
    public PublishedMessage`1(PublishContext`1<T> context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ElementId();
    private sealed virtual override SendContext MassTransit.Testing.IPublishedMessage.get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    public sealed virtual Type get_MessageType();
    public sealed virtual string get_ShortTypeName();
    private sealed virtual override object MassTransit.Testing.IPublishedMessage.get_MessageObject();
    private sealed virtual override PublishContext`1<T> MassTransit.Testing.IPublishedMessage<T>.get_Context();
}
public class MassTransit.Testing.PublishedMessageFilter : object {
    private PublishedMessageFilterSet _excludes;
    private PublishedMessageFilterSet _includes;
    public PublishedMessageFilterSet Includes { get; public set; }
    public PublishedMessageFilterSet Excludes { get; public set; }
    public PublishedMessageFilterSet get_Includes();
    public void set_Includes(PublishedMessageFilterSet value);
    public PublishedMessageFilterSet get_Excludes();
    public void set_Excludes(PublishedMessageFilterSet value);
    public bool Any(IPublishedMessage element);
    public bool None(IPublishedMessage element);
}
public class MassTransit.Testing.PublishedMessageFilterSet : FilterSet`1<IPublishedMessage> {
    public PublishedMessageFilterSet Add();
    public PublishedMessageFilterSet Add(FilterDelegate`1<IPublishedMessage`1<T>> filter);
    [CompilerGeneratedAttribute]
internal static bool <Add>g__Filter|0_0(IPublishedMessage element);
}
public class MassTransit.Testing.PublishedMessageList : AsyncElementList`1<IPublishedMessage> {
    public PublishedMessageList(TimeSpan timeout, CancellationToken testCompleted);
    public sealed virtual IEnumerable`1<IPublishedMessage`1<T>> Select(CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<IPublishedMessage`1<T>> Select(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IPublishedMessage> SelectAsync(Action`1<PublishedMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IPublishedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IPublishedMessage`1<T>> SelectAsync(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(Action`1<PublishedMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(FilterDelegate`1<IPublishedMessage`1<T>> filter, CancellationToken cancellationToken);
    public void Add(PublishContext`1<T> context);
    public void Add(PublishContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.ReceivedMessage`1 : object {
    private ConsumeContext`1<T> _context;
    private Exception _exception;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ElementId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    public Nullable`1<Guid> ElementId { get; }
    private ConsumeContext MassTransit.Testing.IReceivedMessage.Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    private Exception MassTransit.Testing.IReceivedMessage.Exception { get; }
    private Type MassTransit.Testing.IReceivedMessage.MessageType { get; }
    private string MassTransit.Testing.IReceivedMessage.ShortTypeName { get; }
    private object MassTransit.Testing.IReceivedMessage.MessageObject { get; }
    private ConsumeContext`1<T> MassTransit.Testing.IReceivedMessage<T>.Context { get; }
    public ReceivedMessage`1(ConsumeContext`1<T> context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ElementId();
    private sealed virtual override ConsumeContext MassTransit.Testing.IReceivedMessage.get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ElapsedTime();
    private sealed virtual override Exception MassTransit.Testing.IReceivedMessage.get_Exception();
    private sealed virtual override Type MassTransit.Testing.IReceivedMessage.get_MessageType();
    private sealed virtual override string MassTransit.Testing.IReceivedMessage.get_ShortTypeName();
    private sealed virtual override object MassTransit.Testing.IReceivedMessage.get_MessageObject();
    private sealed virtual override ConsumeContext`1<T> MassTransit.Testing.IReceivedMessage<T>.get_Context();
}
public class MassTransit.Testing.ReceivedMessageFilter : object {
    private ReceivedMessageFilterSet _excludes;
    private ReceivedMessageFilterSet _includes;
    public ReceivedMessageFilterSet Includes { get; public set; }
    public ReceivedMessageFilterSet Excludes { get; public set; }
    public ReceivedMessageFilterSet get_Includes();
    public void set_Includes(ReceivedMessageFilterSet value);
    public ReceivedMessageFilterSet get_Excludes();
    public void set_Excludes(ReceivedMessageFilterSet value);
    public bool Any(IReceivedMessage element);
    public bool None(IReceivedMessage element);
}
public class MassTransit.Testing.ReceivedMessageFilterSet : FilterSet`1<IReceivedMessage> {
    public ReceivedMessageFilterSet Add();
    public ReceivedMessageFilterSet Add(FilterDelegate`1<IReceivedMessage`1<T>> filter);
    [CompilerGeneratedAttribute]
internal static bool <Add>g__Filter|0_0(IReceivedMessage element);
}
public class MassTransit.Testing.ReceivedMessageList : AsyncElementList`1<IReceivedMessage> {
    public ReceivedMessageList(TimeSpan timeout, CancellationToken testCompleted);
    public sealed virtual IEnumerable`1<IReceivedMessage`1<T>> Select(CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<IReceivedMessage`1<T>> Select(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IReceivedMessage> SelectAsync(Action`1<ReceivedMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(Action`1<ReceivedMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(FilterDelegate`1<IReceivedMessage`1<T>> filter, CancellationToken cancellationToken);
    public void Add(ConsumeContext`1<T> context);
    public void Add(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.ReceivedMessageList`1 : AsyncElementList`1<IReceivedMessage`1<T>> {
    public ReceivedMessageList`1(TimeSpan timeout, CancellationToken testCompleted);
    public sealed virtual IEnumerable`1<IReceivedMessage`1<T>> Select(CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<IReceivedMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public void Add(ConsumeContext`1<T> context);
    public void Add(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Testing.SagaTestHarness`1 : BaseSagaTestHarness`1<TSaga> {
    private ReceivedMessageList _consumed;
    private SagaList`1<TSaga> _created;
    private SagaList`1<TSaga> _sagas;
    [CompilerGeneratedAttribute]
private TestSagaRepositoryDecorator`1<TSaga> <TestRepository>k__BackingField;
    protected TestSagaRepositoryDecorator`1<TSaga> TestRepository { get; }
    public IReceivedMessageList Consumed { get; }
    public ISagaList`1<TSaga> Sagas { get; }
    public ISagaList`1<TSaga> Created { get; }
    public SagaTestHarness`1(BusTestHarness testHarness, ISagaRepository`1<TSaga> repository, IQuerySagaRepository`1<TSaga> querySagaRepository, ILoadSagaRepository`1<TSaga> loadSagaRepository, string queueName);
    [CompilerGeneratedAttribute]
protected TestSagaRepositoryDecorator`1<TSaga> get_TestRepository();
    public sealed virtual IReceivedMessageList get_Consumed();
    public sealed virtual ISagaList`1<TSaga> get_Sagas();
    public sealed virtual ISagaList`1<TSaga> get_Created();
    protected virtual void ConfigureReceiveEndpoint(IReceiveEndpointConfigurator configurator);
    protected virtual void ConfigureNamedReceiveEndpoint(IBusFactoryConfigurator configurator, string queueName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <ConfigureNamedReceiveEndpoint>b__14_0(IReceiveEndpointConfigurator x);
}
[ExtensionAttribute]
public static class MassTransit.Testing.SagaTestHarnessExtensions : object {
    [ExtensionAttribute]
public static SagaTestHarness`1<T> Saga(BusTestHarness harness, string queueName);
    [ExtensionAttribute]
public static SagaTestHarness`1<T> Saga(BusTestHarness harness, ISagaRepository`1<T> repository, string queueName);
}
public class MassTransit.Testing.SentMessage`1 : object {
    private SendContext`1<T> _context;
    private Exception _exception;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ElementId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    public Nullable`1<Guid> ElementId { get; }
    private SendContext MassTransit.Testing.ISentMessage.Context { get; }
    public DateTime StartTime { get; }
    public TimeSpan ElapsedTime { get; }
    private object MassTransit.Testing.ISentMessage.MessageObject { get; }
    private Exception MassTransit.Testing.ISentMessage.Exception { get; }
    private Type MassTransit.Testing.ISentMessage.MessageType { get; }
    public string ShortTypeName { get; }
    private SendContext`1<T> MassTransit.Testing.ISentMessage<T>.Context { get; }
    public SentMessage`1(SendContext`1<T> context, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Guid> get_ElementId();
    private sealed virtual override SendContext MassTransit.Testing.ISentMessage.get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ElapsedTime();
    private sealed virtual override object MassTransit.Testing.ISentMessage.get_MessageObject();
    private sealed virtual override Exception MassTransit.Testing.ISentMessage.get_Exception();
    private sealed virtual override Type MassTransit.Testing.ISentMessage.get_MessageType();
    public sealed virtual string get_ShortTypeName();
    private sealed virtual override SendContext`1<T> MassTransit.Testing.ISentMessage<T>.get_Context();
}
public class MassTransit.Testing.SentMessageFilter : object {
    private SentMessageFilterSet _excludes;
    private SentMessageFilterSet _includes;
    public SentMessageFilterSet Includes { get; public set; }
    public SentMessageFilterSet Excludes { get; public set; }
    public SentMessageFilterSet get_Includes();
    public void set_Includes(SentMessageFilterSet value);
    public SentMessageFilterSet get_Excludes();
    public void set_Excludes(SentMessageFilterSet value);
    public bool Any(ISentMessage element);
    public bool None(ISentMessage element);
}
public class MassTransit.Testing.SentMessageFilterSet : FilterSet`1<ISentMessage> {
    public SentMessageFilterSet Add();
    public SentMessageFilterSet Add(FilterDelegate`1<ISentMessage`1<T>> filter);
    [CompilerGeneratedAttribute]
internal static bool <Add>g__Filter|0_0(ISentMessage element);
}
public class MassTransit.Testing.SentMessageList : AsyncElementList`1<ISentMessage> {
    public SentMessageList(TimeSpan timeout, CancellationToken testCompleted);
    public sealed virtual IEnumerable`1<ISentMessage`1<T>> Select(CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISentMessage`1<T>> Select(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<ISentMessage> SelectAsync(Action`1<SentMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<ISentMessage`1<T>> SelectAsync(CancellationToken cancellationToken);
    public sealed virtual IAsyncEnumerable`1<ISentMessage`1<T>> SelectAsync(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(Action`1<SentMessageFilter> apply, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> Any(FilterDelegate`1<ISentMessage`1<T>> filter, CancellationToken cancellationToken);
    public void Add(SendContext`1<T> context);
    public void Add(SendContext`1<T> context, Exception exception);
}
[ExtensionAttribute]
public static class MassTransit.Testing.ServiceProviderTestExtensions : object {
    [ExtensionAttribute]
public static Task`1<T> GetTask(IServiceProvider provider);
    [ExtensionAttribute]
public static Task`1[] GetTasks(IServiceProvider provider);
}
[ExtensionAttribute]
public static class MassTransit.Testing.StateMachineSagaTestHarnessExtensions : object {
    [ExtensionAttribute]
public static ISagaStateMachineTestHarness`2<TStateMachine, TInstance> StateMachineSaga(BusTestHarness harness, TStateMachine stateMachine, string queueName);
    [ExtensionAttribute]
public static ISagaStateMachineTestHarness`2<TStateMachine, TInstance> StateMachineSaga(BusTestHarness harness, TStateMachine stateMachine, ISagaRepository`1<TInstance> repository, string queueName);
    [ExtensionAttribute]
public static TInstance ContainsInState(ISagaList`1<TInstance> sagas, Guid correlationId, TStateMachine machine, Func`2<TStateMachine, State> stateSelector);
    [ExtensionAttribute]
public static T ContainsInState(ISagaList`1<T> sagas, Guid correlationId, SagaStateMachine`1<T> machine, State state);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSagaInState(ISagaRepository`1<TInstance> repository, Guid correlationId, TStateMachine machine, Func`2<TStateMachine, State> stateSelector, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSagaInState(ISagaRepository`1<TInstance> repository, Guid correlationId, TStateMachine machine, State state, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSagaInState(ISagaRepository`1<TInstance> repository, Expression`1<Func`2<TInstance, bool>> expression, TStateMachine machine, Func`2<TStateMachine, State> stateSelector, TimeSpan timeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.StateMachineSagaTestHarnessExtensions/<ShouldContainSagaInState>d__7`2")]
[ExtensionAttribute]
public static Task`1<Nullable`1<Guid>> ShouldContainSagaInState(ISagaRepository`1<TInstance> repository, Expression`1<Func`2<TInstance, bool>> expression, TStateMachine machine, State state, TimeSpan timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Testing.TelemetryMonitorExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Testing.TelemetryMonitorExtensions/<Wait>d__0")]
[ExtensionAttribute]
public static Task Wait(IPublishEndpoint publishEndpoint, Func`2<IPublishEndpoint, Task> callback, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.TelemetryMonitorExtensions/<Wait>d__1")]
[ExtensionAttribute]
public static Task Wait(ISendEndpoint sendEndpoint, Func`2<ISendEndpoint, Task> callback, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.TelemetryMonitorExtensions/<Wait>d__2`2")]
[ExtensionAttribute]
public static Task`1<Response`1<T1>> Wait(IRequestClient`1<T> client, Func`2<IRequestClient`1<T>, Task`1<Response`1<T1>>> callback, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.TelemetryMonitorExtensions/<Wait>d__3`3")]
[ExtensionAttribute]
public static Task`1<Response`2<T1, T2>> Wait(IRequestClient`1<T> client, Func`2<IRequestClient`1<T>, Task`1<Response`2<T1, T2>>> callback, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    [AsyncStateMachineAttribute("MassTransit.Testing.TelemetryMonitorExtensions/<Wait>d__4`4")]
[ExtensionAttribute]
public static Task`1<Response`3<T1, T2, T3>> Wait(IRequestClient`1<T> client, Func`2<IRequestClient`1<T>, Task`1<Response`3<T1, T2, T3>>> callback, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    [NullableContextAttribute("2")]
private static string GetTestMethodInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Testing.TestActivityListener : object {
    private static ActivitySource _source;
    [NullableAttribute("2")]
private string _className;
    private bool _includeDetails;
    private ActivityListener _listener;
    [NullableAttribute("2")]
private Activity _testActivity;
    private ConcurrentDictionary`2<string, TraceInfo> _traces;
    private TextWriter _writer;
    [NullableContextAttribute("2")]
public TestActivityListener(TextWriter writer, string methodName, string className, bool includeDetails);
    private static TestActivityListener();
    [AsyncStateMachineAttribute("MassTransit.Testing.TestActivityListener/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("MassTransit.Testing.TestActivityListener/<GenerateOutput>d__9")]
private Task GenerateOutput();
    [NullableContextAttribute("0")]
private static ActivitySamplingResult Sample(ActivityCreationOptions`1& options);
    private void ActivityStarted(Activity activity);
    private void ActivityStopped(Activity activity);
    private SpanInfo GetSpan(Activity activity);
    private static string FormatDetailsColumn(SpanInfo span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Testing.TestingServiceProviderExtensions : object {
    [ExtensionAttribute]
public static ITestHarness GetTestHarness(IServiceProvider provider);
    [AsyncStateMachineAttribute("MassTransit.Testing.TestingServiceProviderExtensions/<StartTestHarness>d__1")]
[ExtensionAttribute]
public static Task`1<ITestHarness> StartTestHarness(IServiceProvider provider);
    [AsyncStateMachineAttribute("MassTransit.Testing.TestingServiceProviderExtensions/<ConnectPublishHandler>d__2`1")]
[ExtensionAttribute]
public static Task`1<Task`1<ConsumeContext`1<T>>> ConnectPublishHandler(ITestHarness harness, Func`2<ConsumeContext`1<T>, bool> filter);
    [ExtensionAttribute]
public static void AddTaskCompletionSource(IBusRegistrationConfigurator configurator);
    [AsyncStateMachineAttribute("MassTransit.Testing.TestingServiceProviderExtensions/<Stop>d__4")]
[ExtensionAttribute]
public static Task Stop(ITestHarness harness, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void AddSagaInstance(ITestHarness harness, Nullable`1<Guid> correlationId, Action`1<T> callback);
}
public class MassTransit.Testing.TestSagaRepositoryDecorator`1 : object {
    private SagaList`1<TSaga> _created;
    private ReceivedMessageList _received;
    private ISagaRepository`1<TSaga> _sagaRepository;
    private SagaList`1<TSaga> _sagas;
    public TestSagaRepositoryDecorator`1(ISagaRepository`1<TSaga> sagaRepository, ReceivedMessageList received, SagaList`1<TSaga> created, SagaList`1<TSaga> sagas);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.ISagaRepository<TSaga>.Send(ConsumeContext`1<T> context, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
    private sealed virtual override Task MassTransit.ISagaRepository<TSaga>.SendQuery(ConsumeContext`1<T> context, ISagaQuery`1<TSaga> query, ISagaPolicy`2<TSaga, T> policy, IPipe`1<SagaConsumeContext`2<TSaga, T>> next);
}
[ExtensionAttribute]
public static class MassTransit.Testing.TimelineExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Testing.TimelineExtensions/<OutputTimeline>d__0")]
[ExtensionAttribute]
public static Task OutputTimeline(IBaseTestHarness harness, TextWriter textWriter, Action`1<OutputTimelineOptions> configure);
    private static void AddConsumers(ConversationThread conversation, ChartTable chart, OutputTimelineOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MassTransit.Testing.TrackedActivity : object {
    private static ActivitySource _source;
    private TaskCompletionSource`1<bool> _completed;
    private TimeSpan _idleTimeout;
    private ActivityListener _listener;
    [NullableAttribute("2")]
private Activity _testActivity;
    private TimeSpan _timeout;
    private RollingTimer _timer;
    private TraceInfo _traceInfo;
    [NullableContextAttribute("2")]
public TrackedActivity(string methodName, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> idleTimeout);
    private static TrackedActivity();
    [AsyncStateMachineAttribute("MassTransit.Testing.TrackedActivity/<DisposeAsync>d__9")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
private void OnTimeout(object state);
    [NullableContextAttribute("0")]
private static ActivitySamplingResult Sample(ActivityCreationOptions`1& options);
    private void ActivityStarted(Activity activity);
    private void ActivityStopped(Activity activity);
    private SpanInfo GetSpan(Activity activity);
}
[ExtensionAttribute]
public static class MassTransit.ThenExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Then(EventActivityBinder`1<TSaga> binder, Action`1<BehaviorContext`1<TSaga>> action);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Then(ExceptionActivityBinder`2<TSaga, TException> binder, Action`1<BehaviorExceptionContext`2<TSaga, TException>> action);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> ThenAsync(ExceptionActivityBinder`2<TSaga, TException> binder, Func`2<BehaviorExceptionContext`2<TSaga, TException>, Task> asyncAction);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> ThenAsync(EventActivityBinder`1<TSaga> binder, Func`2<BehaviorContext`1<TSaga>, Task> action);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Then(EventActivityBinder`2<TSaga, TData> binder, Action`1<BehaviorContext`2<TSaga, TData>> action);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> Then(ExceptionActivityBinder`3<TSaga, TData, TException> binder, Action`1<BehaviorExceptionContext`3<TSaga, TData, TException>> action);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TData, TException> ThenAsync(ExceptionActivityBinder`3<TSaga, TData, TException> binder, Func`2<BehaviorExceptionContext`3<TSaga, TData, TException>, Task> asyncAction);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> ThenAsync(EventActivityBinder`2<TSaga, TData> binder, Func`2<BehaviorContext`2<TSaga, TData>, Task> action);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Execute(EventActivityBinder`1<TSaga> binder, Func`2<BehaviorContext`1<TSaga>, IStateMachineActivity`1<TSaga>> activityFactory);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Execute(EventActivityBinder`1<TSaga> binder, IStateMachineActivity`1<TSaga> activity);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> ExecuteAsync(EventActivityBinder`1<TSaga> binder, Func`2<BehaviorContext`1<TSaga>, Task`1<IStateMachineActivity`1<TSaga>>> activityFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Execute(EventActivityBinder`2<TSaga, TData> binder, Func`2<BehaviorContext`2<TSaga, TData>, IStateMachineActivity`2<TSaga, TData>> activityFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> ExecuteAsync(EventActivityBinder`2<TSaga, TData> binder, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<IStateMachineActivity`2<TSaga, TData>>> activityFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> Execute(EventActivityBinder`2<TSaga, TData> binder, Func`2<BehaviorContext`2<TSaga, TData>, IStateMachineActivity`1<TSaga>> activityFactory);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TData> ExecuteAsync(EventActivityBinder`2<TSaga, TData> binder, Func`2<BehaviorContext`2<TSaga, TData>, Task`1<IStateMachineActivity`1<TSaga>>> activityFactory);
}
[ExtensionAttribute]
public static class MassTransit.TimeoutConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseTimeout(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<ITimeoutConfigurator> configure);
    [ExtensionAttribute]
public static void UseTimeout(IConsumePipeConfigurator configurator, Action`1<ITimeoutConfigurator> configure);
    [ExtensionAttribute]
public static void UseTimeout(IConsumerConfigurator`1<TConsumer> configurator, Action`1<ITimeoutConfigurator> configure);
    [ExtensionAttribute]
public static void UseTimeout(ISagaConfigurator`1<TSaga> configurator, Action`1<ITimeoutConfigurator> configure);
    [ExtensionAttribute]
public static void UseTimeout(IHandlerConfigurator`1<TMessage> configurator, Action`1<ITimeoutConfigurator> configure);
}
public class MassTransit.Topology.CorrelatedByMessageCorrelationId`1 : object {
    public sealed virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public class MassTransit.Topology.DelegateMessageCorrelationId`1 : object {
    private Func`2<T, Guid> _getCorrelationId;
    public DelegateMessageCorrelationId`1(Func`2<T, Guid> getCorrelationId);
    public sealed virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public class MassTransit.Topology.EntityCollection`2 : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<TEntity, TEntity> <Entities>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<long, TEntity> <EntityIds>k__BackingField;
    protected IDictionary`2<TEntity, TEntity> Entities { get; }
    protected IDictionary`2<long, TEntity> EntityIds { get; }
    public EntityCollection`2(IEqualityComparer`1<TEntity> entityComparer);
    [CompilerGeneratedAttribute]
protected IDictionary`2<TEntity, TEntity> get_Entities();
    [CompilerGeneratedAttribute]
protected IDictionary`2<long, TEntity> get_EntityIds();
    public sealed virtual IEnumerator`1<TEntity> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual THandle GetOrAdd(TEntity entity);
    public virtual TEntity Get(THandle entityHandle);
}
public interface MassTransit.Topology.EntityHandle {
    public long Id { get; }
    public abstract virtual long get_Id();
}
public class MassTransit.Topology.NamedEntityCollection`2 : EntityCollection`2<TEntity, THandle> {
    private IDictionary`2<TEntity, TEntity> _entityNames;
    public NamedEntityCollection`2(IEqualityComparer`1<TEntity> entityComparer, IEqualityComparer`1<TEntity> nameComparer);
    public virtual THandle GetOrAdd(TEntity entity);
}
public class MassTransit.Topology.NullableDelegateMessageCorrelationId`1 : object {
    private Func`2<T, Nullable`1<Guid>> _getCorrelationId;
    public NullableDelegateMessageCorrelationId`1(Func`2<T, Nullable`1<Guid>> getCorrelationId);
    public sealed virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public class MassTransit.Topology.NullablePropertyMessageCorrelationId`1 : object {
    private IReadProperty`2<T, Nullable`1<Guid>> _property;
    public NullablePropertyMessageCorrelationId`1(IReadProperty`2<T, Nullable`1<Guid>> property);
    public sealed virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public class MassTransit.Topology.PropertyMessageCorrelationId`1 : object {
    private IReadProperty`2<T, Guid> _property;
    public PropertyMessageCorrelationId`1(IReadProperty`2<T, Guid> property);
    public sealed virtual bool TryGetCorrelationId(T message, Guid& correlationId);
}
public class MassTransit.Topology.SetCorrelationIdMessageSendTopology`1 : object {
    private IFilter`1<SendContext`1<T>> _filter;
    public SetCorrelationIdMessageSendTopology`1(IMessageCorrelationId`1<T> messageCorrelationId);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<SendContext`1<T>> builder);
}
public class MassTransit.Topology.SetSerializerMessageSendTopology`1 : object {
    private IFilter`1<SendContext`1<T>> _filter;
    public SetSerializerMessageSendTopology`1(ContentType contentType);
    public sealed virtual void Apply(ITopologyPipeBuilder`1<SendContext`1<T>> builder);
}
[ExtensionAttribute]
public static class MassTransit.TransactionConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void UseTransaction(IPipeConfigurator`1<T> configurator, Action`1<ITransactionConfigurator> configure);
}
public interface MassTransit.TransactionContext {
    public Transaction Transaction { get; }
    public abstract virtual Transaction get_Transaction();
    public abstract virtual Task Commit();
    public abstract virtual void Rollback();
    public abstract virtual void Rollback(Exception exception);
}
[ExtensionAttribute]
public static class MassTransit.TransactionContextExtensions : object {
    [ExtensionAttribute]
public static TransactionScope CreateTransactionScope(PipeContext context);
    [ExtensionAttribute]
public static TransactionScope CreateTransactionScope(PipeContext context, TimeSpan scopeTimeout);
    [ExtensionAttribute]
public static TransactionScope CreateTransactionScope(PipeContext context, TimeSpan scopeTimeout, TransactionScopeAsyncFlowOption asyncFlowOptions);
}
public abstract class MassTransit.Transactions.BaseTransactionalBus : object {
    private IBus _bus;
    private IPublishEndpoint _publishEndpoint;
    private TransactionalBusPublishEndpointProvider _publishEndpointProvider;
    public Uri Address { get; }
    public IBusTopology Topology { get; }
    protected BaseTransactionalBus(IBus bus);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual Task Publish(T message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(T message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, Type messageType, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext`1<T>> publishPipe, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object values, IPipe`1<PublishContext> publishPipe, CancellationToken cancellationToken);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Transactions.BaseTransactionalBus/<GetSendEndpoint>d__17")]
public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Uri get_Address();
    public sealed virtual IBusTopology get_Topology();
    public abstract virtual Task Add(Func`1<Task> action);
}
public interface MassTransit.Transactions.ITransactionalBus {
    public abstract virtual Task Release();
}
public class MassTransit.Transactions.TransactionalBus : BaseTransactionalBus {
    private ConcurrentBag`1<Func`1<Task>> _pendingActions;
    public TransactionalBus(IBus bus);
    [AsyncStateMachineAttribute("MassTransit.Transactions.TransactionalBus/<Release>d__2")]
public sealed virtual Task Release();
    public virtual Task Add(Func`1<Task> action);
}
public class MassTransit.Transactions.TransactionalBusPublishEndpointProvider : object {
    private BaseTransactionalBus _bus;
    private IPublishEndpointProvider _publishEndpointProvider;
    public TransactionalBusPublishEndpointProvider(BaseTransactionalBus bus, IPublishEndpointProvider publishEndpointProvider);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Transactions.TransactionalBusPublishEndpointProvider/<GetPublishSendEndpoint>d__4`1")]
public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
}
public class MassTransit.Transactions.TransactionalBusSendEndpoint : object {
    private ITransportSendEndpoint _endpoint;
    private BaseTransactionalBus _outboxBus;
    public TransactionalBusSendEndpoint(BaseTransactionalBus outboxBus, ISendEndpoint endpoint);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
}
public class MassTransit.Transactions.TransactionalEnlistmentBus : BaseTransactionalBus {
    private ConcurrentDictionary`2<Transaction, TransactionalEnlistmentNotification> _pendingActions;
    public TransactionalEnlistmentBus(IBus bus);
    public sealed virtual Task Release();
    private void ClearTransaction(Transaction transaction);
    public virtual Task Add(Func`1<Task> action);
    private TransactionalEnlistmentNotification GetOrCreateEnlistment();
    private void TransactionCompleted(object sender, TransactionEventArgs e);
    [CompilerGeneratedAttribute]
private TransactionalEnlistmentNotification <GetOrCreateEnlistment>b__5_0(Transaction transaction);
}
public class MassTransit.Transactions.TransactionalEnlistmentNotification : object {
    private List`1<Func`1<Task>> _pendingActions;
    public sealed virtual void Prepare(PreparingEnlistment preparingEnlistment);
    public sealed virtual void Commit(Enlistment enlistment);
    public sealed virtual void Rollback(Enlistment enlistment);
    public sealed virtual void InDoubt(Enlistment enlistment);
    public void Add(Func`1<Task> method);
    private void ExecutePendingActions();
    private void DiscardPendingActions();
}
public class MassTransit.Transformation.ConsumeTransformContext`1 : ProxyPipeContext {
    private ConsumeContext _context;
    [CompilerGeneratedAttribute]
private TInput <Input>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public bool HasInput { get; }
    public TInput Input { get; }
    public ConsumeTransformContext`1(ConsumeContext context, TInput input);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    public sealed virtual bool get_HasInput();
    [CompilerGeneratedAttribute]
public sealed virtual TInput get_Input();
}
public class MassTransit.Transformation.DelegatePropertyProvider`2 : object {
    private IPropertyProvider`2<TInput, TProperty> _inputProvider;
    private Func`2<TransformPropertyContext`2<TProperty, TInput>, Task`1<TProperty>> _valueProvider;
    public DelegatePropertyProvider`2(IPropertyProvider`2<TInput, TProperty> inputProvider, Func`2<TransformPropertyContext`2<TProperty, TInput>, Task`1<TProperty>> valueProvider);
    public sealed virtual Task`1<TProperty> GetProperty(InitializeContext`2<T, TInput> context);
}
public class MassTransit.Transformation.MessageTransformConvention`1 : object {
    private IDictionary`2<string, IPropertyInitializer`2<TMessage, TMessage>> _initializers;
    public int Count { get; }
    public int get_Count();
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetPropertyInitializer(PropertyInfo propertyInfo, IPropertyInitializer`2& initializer);
    public sealed virtual bool TryGetHeaderInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public sealed virtual bool TryGetHeadersInitializer(PropertyInfo propertyInfo, IHeaderInitializer`2& initializer);
    public void Add(string propertyName, IPropertyInitializer`2<TMessage, TMessage> initializer);
}
public class MassTransit.Transformation.MessageTransformPropertyContext`2 : ProxyPipeContext {
    private TransformContext`1<TInput> _context;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <Value>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public bool HasInput { get; }
    public TInput Input { get; }
    public bool HasValue { get; }
    public TProperty Value { get; }
    public MessageTransformPropertyContext`2(TransformContext`1<TInput> context, TProperty value);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    public sealed virtual bool get_HasInput();
    public sealed virtual TInput get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual TProperty get_Value();
}
public class MassTransit.Transformation.PropertyTransformContext`2 : ProxyPipeContext {
    private TransformContext`1<TMessage> _context;
    [CompilerGeneratedAttribute]
private TProperty <Input>k__BackingField;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public bool HasInput { get; }
    public TProperty Input { get; }
    public PropertyTransformContext`2(TransformContext`1<TMessage> context, TProperty property);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    public sealed virtual bool get_HasInput();
    [CompilerGeneratedAttribute]
public sealed virtual TProperty get_Input();
}
public class MassTransit.Transformation.ReplaceMessageFactory`1 : object {
    public sealed virtual InitializeContext`1<TMessage> Create(InitializeContext context);
}
public class MassTransit.Transformation.SendTransformContext`1 : ProxyPipeContext {
    private SendContext`1<TMessage> _context;
    public Nullable`1<Guid> MessageId { get; }
    public Nullable`1<Guid> RequestId { get; }
    public Nullable`1<Guid> CorrelationId { get; }
    public Nullable`1<Guid> ConversationId { get; }
    public Nullable`1<Guid> InitiatorId { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public Uri SourceAddress { get; }
    public Uri DestinationAddress { get; }
    public Uri ResponseAddress { get; }
    public Uri FaultAddress { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Headers Headers { get; }
    public HostInfo Host { get; }
    public bool HasInput { get; }
    public TMessage Input { get; }
    public SendTransformContext`1(SendContext`1<TMessage> context);
    public sealed virtual Nullable`1<Guid> get_MessageId();
    public sealed virtual Nullable`1<Guid> get_RequestId();
    public sealed virtual Nullable`1<Guid> get_CorrelationId();
    public sealed virtual Nullable`1<Guid> get_ConversationId();
    public sealed virtual Nullable`1<Guid> get_InitiatorId();
    public sealed virtual Nullable`1<DateTime> get_ExpirationTime();
    public sealed virtual Uri get_SourceAddress();
    public sealed virtual Uri get_DestinationAddress();
    public sealed virtual Uri get_ResponseAddress();
    public sealed virtual Uri get_FaultAddress();
    public sealed virtual Nullable`1<DateTime> get_SentTime();
    public sealed virtual Headers get_Headers();
    public sealed virtual HostInfo get_Host();
    public sealed virtual bool get_HasInput();
    public sealed virtual TMessage get_Input();
}
public interface MassTransit.Transformation.TransformPropertyContext`2 {
    public bool HasValue { get; }
    public TProperty Value { get; }
    public abstract virtual bool get_HasValue();
    public abstract virtual TProperty get_Value();
}
public class MassTransit.Transformation.TransformPropertyConverter`1 : object {
    private IMessageInitializer`1<TProperty> _initializer;
    public TransformPropertyConverter`1(IMessageInitializer`1<TProperty> initializer);
    public sealed virtual Task`1<TProperty> Convert(InitializeContext`1<TMessage> context, TProperty input);
}
public class MassTransit.Transformation.TransformPropertyInitializer`3 : object {
    private IWriteProperty`2<TMessage, TProperty> _messageProperty;
    private IPropertyProvider`2<TInput, TProperty> _propertyProvider;
    public TransformPropertyInitializer`3(IPropertyProvider`2<TInput, TProperty> propertyProvider, PropertyInfo propertyInfo);
    public sealed virtual Task Apply(InitializeContext`2<TMessage, TInput> context);
}
[ExtensionAttribute]
public static class MassTransit.TransformConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseTransform(IConsumePipeConfigurator configurator, Action`1<ITransformConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void UseTransform(IConsumePipeConfigurator configurator, Func`2<ITransformSpecificationConfigurator`1<T>, IConsumeTransformSpecification`1<T>> getSpecification);
    [ExtensionAttribute]
public static void UseTransform(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Action`1<ITransformConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void UseTransform(IPipeConfigurator`1<ConsumeContext`1<T>> configurator, Func`2<ITransformSpecificationConfigurator`1<T>, IConsumeTransformSpecification`1<T>> getSpecification);
    [ExtensionAttribute]
public static void UseTransform(ISendPipeConfigurator configurator, Action`1<ITransformConfigurator`1<T>> configure);
    [ExtensionAttribute]
public static void UseTransform(IPublishPipeConfigurator configurator, Action`1<ITransformConfigurator`1<T>> configure);
}
[ExtensionAttribute]
public static class MassTransit.TransitionExtensions : object {
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> TransitionTo(EventActivityBinder`1<TSaga> source, State toState);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> TransitionTo(ExceptionActivityBinder`2<TSaga, TException> source, State toState);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TMessage> TransitionTo(EventActivityBinder`2<TSaga, TMessage> source, State toState);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TMessage, TException> TransitionTo(ExceptionActivityBinder`3<TSaga, TMessage, TException> source, State toState);
    [ExtensionAttribute]
public static EventActivityBinder`2<TSaga, TMessage> Finalize(EventActivityBinder`2<TSaga, TMessage> source);
    [ExtensionAttribute]
public static EventActivityBinder`1<TSaga> Finalize(EventActivityBinder`1<TSaga> source);
    [ExtensionAttribute]
public static ExceptionActivityBinder`3<TSaga, TMessage, TException> Finalize(ExceptionActivityBinder`3<TSaga, TMessage, TException> source);
    [ExtensionAttribute]
public static ExceptionActivityBinder`2<TSaga, TException> Finalize(ExceptionActivityBinder`2<TSaga, TException> source);
}
public class MassTransit.Transports.AddressEqualityComparer : object {
    public static IEqualityComparer`1<Uri> Comparer;
    private static AddressEqualityComparer();
    public sealed virtual bool Equals(Uri x, Uri y);
    public sealed virtual int GetHashCode(Uri obj);
}
public class MassTransit.Transports.AllowTransportHeader : MulticastDelegate {
    public AllowTransportHeader(object object, IntPtr method);
    public virtual bool Invoke(HeaderValue`1<string> headerValue);
    public virtual IAsyncResult BeginInvoke(HeaderValue`1<string> headerValue, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class MassTransit.Transports.BaseHost : object {
    private IHostConfiguration _hostConfiguration;
    private HostHandle _handle;
    [CompilerGeneratedAttribute]
private IReceiveEndpointCollection <ReceiveEndpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private IRiderCollection <Riders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBusTopology <Topology>k__BackingField;
    protected IReceiveEndpointCollection ReceiveEndpoints { get; }
    private IRiderCollection Riders { get; }
    public Uri Address { get; }
    public IBusTopology Topology { get; }
    protected BaseHost(IHostConfiguration hostConfiguration, IBusTopology busTopology);
    [CompilerGeneratedAttribute]
protected IReceiveEndpointCollection get_ReceiveEndpoints();
    [CompilerGeneratedAttribute]
private IRiderCollection get_Riders();
    public sealed virtual Uri get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual IBusTopology get_Topology();
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    public abstract virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`1<IReceiveEndpointConfigurator> configureEndpoint);
    private sealed virtual override ConnectHandle MassTransit.IConsumeMessageObserverConnector.ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    private sealed virtual override ConnectHandle MassTransit.IConsumeObserverConnector.ConnectConsumeObserver(IConsumeObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IReceiveObserverConnector.ConnectReceiveObserver(IReceiveObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IReceiveEndpointObserverConnector.ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual ConnectHandle ConnectEndpointConfigurationObserver(IEndpointConfigurationObserver observer);
    private sealed virtual override ConnectHandle MassTransit.IPublishObserverConnector.ConnectPublishObserver(IPublishObserver observer);
    private sealed virtual override ConnectHandle MassTransit.ISendObserverConnector.ConnectSendObserver(ISendObserver observer);
    public sealed virtual HostHandle Start(CancellationToken cancellationToken);
    public sealed virtual void AddReceiveEndpoint(string endpointName, ReceiveEndpoint receiveEndpoint);
    public sealed virtual IRider GetRider(string name);
    public sealed virtual void AddRider(string name, IRiderControl riderControl);
    public sealed virtual BusHealthResult CheckHealth(BusState busState, string healthMessage);
    private sealed virtual override void MassTransit.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Transports.BaseHost/<Stop>d__29")]
public Task Stop(CancellationToken cancellationToken);
    protected abstract virtual void Probe(ProbeContext context);
    protected virtual IAgent[] GetAgentHandles();
}
public abstract class MassTransit.Transports.BaseReceiveContext : ScopePipeContext {
    private CancellationTokenSource _cancellationTokenSource;
    private Lazy`1<ContentType> _contentType;
    private Lazy`1<Headers> _headers;
    private Lazy`1<IPublishEndpointProvider> _publishEndpointProvider;
    private ReceiveEndpointContext _receiveEndpointContext;
    private PendingTaskCollection _receiveTasks;
    private Stopwatch _receiveTimer;
    private Lazy`1<ISendEndpointProvider> _sendEndpointProvider;
    [CompilerGeneratedAttribute]
private bool <IsDelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFaulted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Redelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    protected IHeaderProvider HeaderProvider { get; }
    public CancellationToken CancellationToken { get; }
    public bool IsDelivered { get; private set; }
    public bool IsFaulted { get; private set; }
    public bool PublishFaults { get; }
    public MessageBody Body { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public Task ReceiveCompleted { get; }
    public bool Redelivered { get; }
    public Headers TransportHeaders { get; }
    public TimeSpan ElapsedTime { get; }
    public Uri InputAddress { get; protected set; }
    public ContentType ContentType { get; }
    protected BaseReceiveContext(bool redelivered, ReceiveEndpointContext receiveEndpointContext, Object[] payloads);
    protected abstract virtual IHeaderProvider get_HeaderProvider();
    public virtual void Dispose();
    public virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDelivered();
    [CompilerGeneratedAttribute]
private void set_IsDelivered(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFaulted();
    [CompilerGeneratedAttribute]
private void set_IsFaulted(bool value);
    public sealed virtual bool get_PublishFaults();
    public abstract virtual MessageBody get_Body();
    public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    public sealed virtual IPublishEndpointProvider get_PublishEndpointProvider();
    public sealed virtual Task get_ReceiveCompleted();
    public sealed virtual void AddReceiveTask(Task task);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Redelivered();
    public sealed virtual Headers get_TransportHeaders();
    public virtual Task NotifyConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    public virtual Task NotifyFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    public virtual Task NotifyFaulted(Exception exception);
    public sealed virtual TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
protected void set_InputAddress(Uri value);
    public sealed virtual ContentType get_ContentType();
    protected virtual ISendEndpointProvider GetSendEndpointProvider();
    protected virtual IPublishEndpointProvider GetPublishEndpointProvider();
    protected virtual ContentType GetContentType();
    public void Cancel();
    protected static ContentType ConvertToContentType(string text);
    [CompilerGeneratedAttribute]
private Headers <.ctor>b__8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Transports.BaseReceiveEndpointContext : BasePipeContext {
    private ReceiveEndpointObservable _endpointObservers;
    private IHostConfiguration _hostConfiguration;
    private PublishObservable _publishObservers;
    private Lazy`1<IPublishPipe> _publishPipe;
    private IPublishTopologyConfigurator _publishTopology;
    private ReceiveObservable _receiveObservers;
    private Lazy`1<IReceivePipe> _receivePipe;
    private SendObservable _sendObservers;
    private Lazy`1<ISendPipe> _sendPipe;
    private ReceiveTransportObservable _transportObservers;
    private Lazy`1<IPublishEndpointProvider> _publishEndpointProvider;
    private Lazy`1<IPublishTransportProvider> _publishTransportProvider;
    private Lazy`1<ISendEndpointProvider> _sendEndpointProvider;
    private Lazy`1<ISendTransportProvider> _sendTransportProvider;
    [CompilerGeneratedAttribute]
private Uri <HostAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBusEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <DependenciesReady>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <DependentsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublishFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PrefetchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConcurrentMessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerialization <Serialization>k__BackingField;
    private Uri HostAddress { get; }
    public bool IsBusEndpoint { get; }
    public IReceiveObserver ReceiveObservers { get; }
    public IReceiveTransportObserver TransportObservers { get; }
    public IReceiveEndpointObserver EndpointObservers { get; }
    public Nullable`1<TimeSpan> ConsumerStopTimeout { get; }
    public Uri InputAddress { get; }
    public Task DependenciesReady { get; }
    public Task DependentsCompleted { get; }
    public bool PublishFaults { get; }
    public int PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public ILogContext LogContext { get; }
    public IPublishTopology Publish { get; }
    public IReceivePipe ReceivePipe { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public ISerialization Serialization { get; }
    protected BaseReceiveEndpointContext(IHostConfiguration hostConfiguration, IReceiveEndpointConfiguration configuration);
    [CompilerGeneratedAttribute]
private Uri get_HostAddress();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBusEndpoint();
    public sealed virtual IReceiveObserver get_ReceiveObservers();
    public sealed virtual IReceiveTransportObserver get_TransportObservers();
    public sealed virtual IReceiveEndpointObserver get_EndpointObservers();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveTransportObserver(IReceiveTransportObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual Nullable`1<TimeSpan> get_ConsumerStopTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public sealed virtual Task get_DependenciesReady();
    [CompilerGeneratedAttribute]
public sealed virtual Task get_DependentsCompleted();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PublishFaults();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PrefetchCount();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public sealed virtual ILogContext get_LogContext();
    public sealed virtual IPublishTopology get_Publish();
    public sealed virtual IReceivePipe get_ReceivePipe();
    public sealed virtual ISendEndpointProvider get_SendEndpointProvider();
    public sealed virtual IPublishEndpointProvider get_PublishEndpointProvider();
    public sealed virtual IReceivePipeDispatcher CreateReceivePipeDispatcher();
    public sealed virtual void Reset();
    public abstract virtual void AddSendAgent(IAgent agent);
    public abstract virtual void AddConsumeAgent(IAgent agent);
    public virtual void Probe(ProbeContext context);
    public abstract virtual Exception ConvertException(Exception exception, string message);
    [CompilerGeneratedAttribute]
public sealed virtual ISerialization get_Serialization();
    protected virtual ISendEndpointProvider CreateSendEndpointProvider();
    protected virtual IPublishEndpointProvider CreatePublishEndpointProvider();
    protected abstract virtual ISendTransportProvider CreateSendTransportProvider();
    protected abstract virtual IPublishTransportProvider CreatePublishTransportProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Transports.BaseSendTransportContext : BasePipeContext {
    private Lazy`1<string> _activityName;
    private Lazy`1<string> _destination;
    private IHostConfiguration _hostConfiguration;
    [CompilerGeneratedAttribute]
private SendObservable <SendObservers>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerialization <Serialization>k__BackingField;
    public string EntityName { get; }
    public ILogContext LogContext { get; }
    public string ActivityName { get; }
    public string ActivityDestination { get; }
    public string ActivitySystem { get; }
    public SendObservable SendObservers { get; }
    public ISerialization Serialization { get; }
    protected BaseSendTransportContext(IHostConfiguration hostConfiguration, ISerialization serialization);
    public abstract virtual string get_EntityName();
    public sealed virtual ILogContext get_LogContext();
    public sealed virtual string get_ActivityName();
    public sealed virtual string get_ActivityDestination();
    public abstract virtual string get_ActivitySystem();
    [CompilerGeneratedAttribute]
public sealed virtual SendObservable get_SendObservers();
    [CompilerGeneratedAttribute]
public sealed virtual ISerialization get_Serialization();
    public abstract virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public virtual IEnumerable`1<IAgent> GetAgentHandles();
    [CompilerGeneratedAttribute]
private string <.ctor>b__3_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__3_1();
}
public class MassTransit.Transports.BusDepot : object {
    private IDictionary`2<Type, IBusInstance> _instances;
    private ILogger`1<BusDepot> _logger;
    public BusDepot(IEnumerable`1<IBusInstance> instances, ILogger`1<BusDepot> logger);
    public sealed virtual Task Start(CancellationToken cancellationToken);
    public sealed virtual Task Stop(CancellationToken cancellationToken);
}
public enum MassTransit.Transports.BusState : Enum {
    public int value__;
    public static BusState Created;
    public static BusState Started;
    public static BusState Faulted;
    public static BusState Stopped;
}
public abstract class MassTransit.Transports.BusTopology : object {
    private IHostConfiguration _hostConfiguration;
    private ITopologyConfiguration _topologyConfiguration;
    public IPublishTopology PublishTopology { get; }
    public ISendTopology SendTopology { get; }
    protected BusTopology(IHostConfiguration hostConfiguration, ITopologyConfiguration topologyConfiguration);
    public sealed virtual IPublishTopology get_PublishTopology();
    public sealed virtual ISendTopology get_SendTopology();
    public sealed virtual IMessagePublishTopology`1<T> Publish();
    public sealed virtual IMessageSendTopology`1<T> Send();
    public sealed virtual IMessageTopology`1<T> Message();
    public virtual bool TryGetPublishAddress(Type messageType, Uri& publishAddress);
    public virtual bool TryGetPublishAddress(Uri& publishAddress);
}
public class MassTransit.Transports.CachedSendEndpoint`1 : object {
    private ITransportSendEndpoint _endpoint;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Action Used;
    public TKey Key { get; }
    public CachedSendEndpoint`1(TKey key, ISendEndpoint endpoint);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Used(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Used(Action value);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
}
public interface MassTransit.Transports.Components.IKillSwitch {
    public ILogContext LogContext { get; }
    public int ActivationThreshold { get; }
    public int TripThreshold { get; }
    public TimeSpan TrackingPeriod { get; }
    public TimeSpan RestartTimeout { get; }
    public IExceptionFilter ExceptionFilter { get; }
    public abstract virtual ILogContext get_LogContext();
    public abstract virtual int get_ActivationThreshold();
    public abstract virtual int get_TripThreshold();
    public abstract virtual TimeSpan get_TrackingPeriod();
    public abstract virtual TimeSpan get_RestartTimeout();
    public abstract virtual IExceptionFilter get_ExceptionFilter();
    public abstract virtual void Stop(Exception exception, IKillSwitchState previousState);
    public abstract virtual void Restart(Exception exception, IKillSwitchState previousState);
    public abstract virtual void Started(IKillSwitchState previousState);
}
public interface MassTransit.Transports.Components.IKillSwitchState {
}
public class MassTransit.Transports.Components.KillSwitch : object {
    private ILogContext _logContext;
    private KillSwitchOptions _options;
    private ConnectHandle _consumeConnectHandle;
    private IReceiveEndpoint _receiveEndpoint;
    private IKillSwitchState _state;
    private ILogContext MassTransit.Transports.Components.IKillSwitch.LogContext { get; }
    public int ActivationThreshold { get; }
    public int TripThreshold { get; }
    public TimeSpan TrackingPeriod { get; }
    public TimeSpan RestartTimeout { get; }
    public IExceptionFilter ExceptionFilter { get; }
    public KillSwitch(KillSwitchOptions options);
    public sealed virtual Task PreExecute(ExecuteActivityContext`2<TActivity, TArguments> context);
    public sealed virtual Task PostExecute(ExecuteActivityContext`2<TActivity, TArguments> context);
    public sealed virtual Task ExecuteFault(ExecuteActivityContext`2<TActivity, TArguments> context, Exception exception);
    public sealed virtual Task PreCompensate(CompensateActivityContext`2<TActivity, TLog> context);
    public sealed virtual Task PostCompensate(CompensateActivityContext`2<TActivity, TLog> context);
    public sealed virtual Task CompensateFail(CompensateActivityContext`2<TActivity, TLog> context, Exception exception);
    public sealed virtual Task PreConsume(ConsumeContext`1<T> context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context);
    public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, Exception exception);
    private sealed virtual override ILogContext MassTransit.Transports.Components.IKillSwitch.get_LogContext();
    public sealed virtual int get_ActivationThreshold();
    public sealed virtual int get_TripThreshold();
    public sealed virtual TimeSpan get_TrackingPeriod();
    public sealed virtual TimeSpan get_RestartTimeout();
    public sealed virtual IExceptionFilter get_ExceptionFilter();
    public sealed virtual void Started(IKillSwitchState previousState);
    public sealed virtual void Restart(Exception exception, IKillSwitchState previousState);
    public sealed virtual void Stop(Exception exception, IKillSwitchState previousState);
    public sealed virtual Task Ready(ReceiveEndpointReady ready);
    public sealed virtual Task Stopping(ReceiveEndpointStopping stopping);
    public sealed virtual Task Completed(ReceiveEndpointCompleted completed);
    public sealed virtual Task Faulted(ReceiveEndpointFaulted faulted);
    [AsyncStateMachineAttribute("MassTransit.Transports.Components.KillSwitch/<StopReceiveEndpoint>d__34")]
private Task StopReceiveEndpoint(StoppedKillSwitchState state);
    [AsyncStateMachineAttribute("MassTransit.Transports.Components.KillSwitch/<RestartReceiveEndpoint>d__35")]
private Task RestartReceiveEndpoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <Restart>b__28_0();
}
public class MassTransit.Transports.Components.KillSwitchOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TrackingPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RestartTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TripThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActivationThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private IExceptionFilter <ExceptionFilter>k__BackingField;
    public TimeSpan TrackingPeriod { get; public set; }
    public TimeSpan RestartTimeout { get; public set; }
    public int TripThreshold { get; public set; }
    public int ActivationThreshold { get; public set; }
    public IExceptionFilter ExceptionFilter { get; private set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_TrackingPeriod();
    [CompilerGeneratedAttribute]
public void set_TrackingPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RestartTimeout();
    [CompilerGeneratedAttribute]
public void set_RestartTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_TripThreshold();
    [CompilerGeneratedAttribute]
public void set_TripThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_ActivationThreshold();
    [CompilerGeneratedAttribute]
public void set_ActivationThreshold(int value);
    [CompilerGeneratedAttribute]
public IExceptionFilter get_ExceptionFilter();
    [CompilerGeneratedAttribute]
private void set_ExceptionFilter(IExceptionFilter value);
    [IteratorStateMachineAttribute("MassTransit.Transports.Components.KillSwitchOptions/<Validate>d__21")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public KillSwitchOptions SetActivationThreshold(int value);
    public KillSwitchOptions SetTripThreshold(int value);
    public KillSwitchOptions SetTripThreshold(double percentage);
    public KillSwitchOptions SetTrackingPeriod(TimeSpan value);
    public KillSwitchOptions SetTrackingPeriod(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public KillSwitchOptions SetRestartTimeout(TimeSpan value);
    public KillSwitchOptions SetRestartTimeout(Nullable`1<int> d, Nullable`1<int> h, Nullable`1<int> m, Nullable`1<int> s, Nullable`1<int> ms);
    public KillSwitchOptions SetExceptionFilter(Action`1<IExceptionConfigurator> configure);
}
internal class MassTransit.Transports.Components.RestartingKillSwitchState : object {
    private Exception _exception;
    private IKillSwitch _killSwitch;
    private int _attemptCount;
    private bool IsActive { get; }
    public RestartingKillSwitchState(IKillSwitch killSwitch, Exception exception);
    private bool get_IsActive();
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task PreConsume(ConsumeContext`1<T> context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context);
    public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, Exception exception);
}
public class MassTransit.Transports.Components.StartedKillSwitchState : object {
    private IKillSwitch _killSwitch;
    private int _attemptCount;
    private int _failureCount;
    private int _successCount;
    private Timer _timer;
    private bool IsActive { get; }
    public StartedKillSwitchState(IKillSwitch killSwitch);
    private bool get_IsActive();
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task PreConsume(ConsumeContext`1<T> context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context);
    [AsyncStateMachineAttribute("MassTransit.Transports.Components.StartedKillSwitchState/<ConsumeFault>d__11`1")]
public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, Exception exception);
    public void LogThreshold();
    public void Activate();
    private bool TripThresholdExceeded(int failureCount);
    private void Reset(object state);
}
public class MassTransit.Transports.Components.StoppedKillSwitchState : object {
    private Exception _exception;
    private IKillSwitch _killSwitch;
    private Stopwatch _elapsed;
    private Timer _timer;
    public StoppedKillSwitchState(IKillSwitch killSwitch, Exception exception);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Task PreConsume(ConsumeContext`1<T> context);
    public sealed virtual Task PostConsume(ConsumeContext`1<T> context);
    public sealed virtual Task ConsumeFault(ConsumeContext`1<T> context, Exception exception);
    public void Activate();
    private void Restart(object state);
}
public abstract class MassTransit.Transports.ConsumerAgent`1 : Agent {
    private ReceiveEndpointContext _context;
    private TaskCompletionSource`1<bool> _deliveryComplete;
    private IReceivePipeDispatcher _dispatcher;
    private object _lock;
    private ConcurrentDictionary`2<TKey, PendingReceiveLockContext> _pending;
    private Task _consumeTask;
    private TaskCompletionSource`1<bool> _consumeTaskSource;
    [CompilerGeneratedAttribute]
private bool <IsGracefulShutdown>k__BackingField;
    protected bool IsIdle { get; }
    protected long ActiveDispatchCount { get; }
    protected bool IsGracefulShutdown { get; private set; }
    public long DeliveryCount { get; }
    public int ConcurrentDeliveryCount { get; }
    protected ConsumerAgent`1(ReceiveEndpointContext context, IEqualityComparer`1<TKey> equalityComparer);
    protected bool get_IsIdle();
    protected long get_ActiveDispatchCount();
    [CompilerGeneratedAttribute]
protected bool get_IsGracefulShutdown();
    [CompilerGeneratedAttribute]
private void set_IsGracefulShutdown(bool value);
    public sealed virtual long get_DeliveryCount();
    public sealed virtual int get_ConcurrentDeliveryCount();
    private Task HandleDeliveryComplete();
    protected void TrySetManualConsumeTask();
    protected void TrySetConsumeTask(Task consumeTask);
    private void SetConsumeTask(Task consumeTask);
    protected virtual Task StopAgent(StopContext context);
    private void CancelPendingConsumers();
    protected void TrySetConsumeCompleted();
    protected void TrySetConsumeCanceled(CancellationToken cancellationToken);
    protected void TrySetConsumeException(Exception exception);
    [AsyncStateMachineAttribute("MassTransit.Transports.ConsumerAgent`1/<ActiveAndActualAgentsCompleted>d__29")]
protected virtual Task ActiveAndActualAgentsCompleted(StopContext context);
    protected virtual bool IsTrackable(TKey key);
    protected Task Dispatch(TKey key, TContext context, ReceiveLockContext receiveLockContext);
    [AsyncStateMachineAttribute("MassTransit.Transports.ConsumerAgent`1/<<SetConsumeTask>g__TryStop|23_0>d")]
[CompilerGeneratedAttribute]
private Task <SetConsumeTask>g__TryStop|23_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <SetConsumeTask>b__23_1();
    [CompilerGeneratedAttribute]
private Task <SetConsumeTask>b__23_2(Task _);
}
public class MassTransit.Transports.ConsumerReceiveEndpointDispatcher`1 : object {
    public sealed virtual IReceiveEndpointDispatcher Create(IReceiveEndpointDispatcherFactory factory, IEndpointNameFormatter formatter);
}
public class MassTransit.Transports.ConsumeSendEndpoint : SendEndpointProxy {
    private ConsumeContext _context;
    private Nullable`1<Guid> _requestId;
    public ConsumeSendEndpoint(ISendEndpoint endpoint, ConsumeContext context, Nullable`1<Guid> requestId);
    public virtual Task Send(T message, CancellationToken cancellationToken);
    public virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    protected virtual IPipe`1<SendContext`1<T>> GetPipeProxy(IPipe`1<SendContext`1<T>> pipe);
    private Task ConsumeTask(Task task);
}
public class MassTransit.Transports.ConsumeSendPipeAdapter`1 : SendContextPipeAdapter`1<TMessage> {
    private ConsumeContext _consumeContext;
    private Nullable`1<Guid> _requestId;
    public ConsumeSendPipeAdapter`1(ConsumeContext consumeContext, IPipe`1<SendContext`1<TMessage>> pipe, Nullable`1<Guid> requestId);
    protected virtual void Send(SendContext`1<T> context);
    protected virtual void Send(SendContext`1<TMessage> context);
}
public class MassTransit.Transports.DefaultMessageNameFormatter : object {
    private ConcurrentDictionary`2<Type, string> _cache;
    private string _genericArgumentSeparator;
    private string _genericTypeSeparator;
    private string _namespaceSeparator;
    private string _nestedTypeSeparator;
    public DefaultMessageNameFormatter(string genericArgumentSeparator, string genericTypeSeparator, string namespaceSeparator, string nestedTypeSeparator);
    public sealed virtual string GetMessageName(Type type);
    private string CreateMessageName(Type type);
    private string GetMessageName(StringBuilder sb, Type type, string scope);
}
public class MassTransit.Transports.DelegatePartitionKeyFormatter`1 : object {
    private Func`2<SendContext`1<TMessage>, string> _formatter;
    public DelegatePartitionKeyFormatter`1(Func`2<SendContext`1<TMessage>, string> formatter);
    public sealed virtual string FormatPartitionKey(SendContext`1<TMessage> context);
}
public class MassTransit.Transports.DelegateRoutingKeyFormatter`1 : object {
    private Func`2<SendContext`1<TMessage>, string> _formatter;
    public DelegateRoutingKeyFormatter`1(Func`2<SendContext`1<TMessage>, string> formatter);
    public sealed virtual string FormatRoutingKey(SendContext`1<TMessage> context);
}
public interface MassTransit.Transports.DeliveryMetrics {
    public long DeliveryCount { get; }
    public int ConcurrentDeliveryCount { get; }
    public abstract virtual long get_DeliveryCount();
    public abstract virtual int get_ConcurrentDeliveryCount();
}
public class MassTransit.Transports.ExecuteActivityReceiveEndpointDispatcher`2 : object {
    public sealed virtual IReceiveEndpointDispatcher Create(IReceiveEndpointDispatcherFactory factory, IEndpointNameFormatter formatter);
}
[ExtensionAttribute]
internal static class MassTransit.Transports.Fabric.ArrayExtensions : object {
    [ExtensionAttribute]
public static T[] Copy(T[] array);
    [ExtensionAttribute]
public static T[] Shuffle(T[] array);
}
public class MassTransit.Transports.Fabric.Counter : Metric {
    private long _count;
    public void Add();
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.Fabric.DeliveryContext`1 {
    public CancellationToken CancellationToken { get; }
    public T Message { get; }
    [NullableAttribute("2")]
public string RoutingKey { get; }
    public Nullable`1<DateTime> EnqueueTime { get; }
    public Nullable`1<long> ReceiverId { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual T get_Message();
    [NullableContextAttribute("2")]
public abstract virtual string get_RoutingKey();
    public abstract virtual Nullable`1<DateTime> get_EnqueueTime();
    public abstract virtual Nullable`1<long> get_ReceiverId();
    public abstract virtual bool WasAlreadyDelivered(IMessageSink`1<T> sink);
    public abstract virtual void Delivered(IMessageSink`1<T> sink);
}
public enum MassTransit.Transports.Fabric.ExchangeType : Enum {
    public int value__;
    public static ExchangeType FanOut;
    public static ExchangeType Direct;
    public static ExchangeType Topic;
}
public class MassTransit.Transports.Fabric.Gauge : Metric {
    private long _activeCount;
    private long _concurrentActiveCount;
    [CompilerGeneratedAttribute]
private ZeroActiveHandler ZeroActive;
    [CompilerGeneratedAttribute]
public void add_ZeroActive(ZeroActiveHandler value);
    [CompilerGeneratedAttribute]
public void remove_ZeroActive(ZeroActiveHandler value);
    public void Add();
    public void Remove();
    private static Task NotifyZeroActivity(ZeroActiveHandler zeroActivity);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.Fabric.IMessageExchange`1 {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface MassTransit.Transports.Fabric.IMessageFabric`2 {
    public abstract virtual void ExchangeDeclare(TContext context, string name, ExchangeType exchangeType);
    public abstract virtual void ExchangeBind(TContext context, string source, string destination, string routingKey);
    public abstract virtual void QueueDeclare(TContext context, string name);
    public abstract virtual void QueueBind(TContext context, string source, string destination);
    public abstract virtual IMessageExchange`1<T> GetExchange(TContext context, string name, ExchangeType exchangeType);
    public abstract virtual IMessageQueue`2<TContext, T> GetQueue(TContext context, string name);
}
public interface MassTransit.Transports.Fabric.IMessageFabricObserver`1 {
    public abstract virtual void ExchangeDeclared(TContext context, string name, ExchangeType exchangeType);
    public abstract virtual void ExchangeBindingCreated(TContext context, string source, string destination, string routingKey);
    public abstract virtual void QueueDeclared(TContext context, string name);
    public abstract virtual void QueueBindingCreated(TContext context, string source, string destination);
    public abstract virtual TopologyHandle ConsumerConnected(TContext context, TopologyHandle handle, string queueName);
}
public interface MassTransit.Transports.Fabric.IMessageFabricObserverConnector`1 {
    public abstract virtual ConnectHandle ConnectMessageFabricObserver(IMessageFabricObserver`1<TContext> observer);
}
public interface MassTransit.Transports.Fabric.IMessageQueue`2 {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual TopologyHandle ConnectMessageReceiver(TContext nodeContext, IMessageReceiver`1<T> receiver);
}
public interface MassTransit.Transports.Fabric.IMessageReceiver`1 {
    public abstract virtual Task Deliver(T message, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.Fabric.IMessageSink`1 {
    public abstract virtual Task Deliver(DeliveryContext`1<T> context);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.Fabric.IMessageSource`1 {
    public IEnumerable`1<IMessageSink`1<T>> Sinks { get; }
    public abstract virtual IEnumerable`1<IMessageSink`1<T>> get_Sinks();
    public abstract virtual ConnectHandle Connect(IMessageSink`1<T> sink, string routingKey);
}
public interface MassTransit.Transports.Fabric.IReceiverLoadBalancer`1 {
    public abstract virtual IMessageReceiver`1<T> SelectReceiver(T message);
}
public class MassTransit.Transports.Fabric.LoadBalancerFactory`1 : MulticastDelegate {
    public LoadBalancerFactory`1(object object, IntPtr method);
    public virtual IReceiverLoadBalancer`1<T> Invoke(IMessageReceiver`1[] consumers);
    public virtual IAsyncResult BeginInvoke(IMessageReceiver`1[] consumers, AsyncCallback callback, object object);
    public virtual IReceiverLoadBalancer`1<T> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Transports.Fabric.MessageDirectExchange`1 : object {
    private ConcurrentDictionary`2<string, Connectable`1<IMessageSink`1<T>>> _sinks;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IEnumerable`1<IMessageSink`1<T>> Sinks { get; }
    public string Name { get; }
    public MessageDirectExchange`1(string name, StringComparer comparer);
    public sealed virtual IEnumerable`1<IMessageSink`1<T>> get_Sinks();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("MassTransit.Transports.Fabric.MessageDirectExchange`1/<Deliver>d__7")]
public sealed virtual Task Deliver(DeliveryContext`1<T> context);
    public sealed virtual ConnectHandle Connect(IMessageSink`1<T> sink, string routingKey);
    public sealed virtual void Probe(ProbeContext context);
    public virtual string ToString();
}
public class MassTransit.Transports.Fabric.MessageFabric`2 : Supervisor {
    private ConcurrentDictionary`2<string, IMessageExchange`1<T>> _exchanges;
    private MessageFabricObservable`1<TContext> _observers;
    private ConcurrentDictionary`2<string, IMessageQueue`2<TContext, T>> _queues;
    public sealed virtual void ExchangeDeclare(TContext context, string name, ExchangeType exchangeType);
    public sealed virtual void ExchangeBind(TContext context, string source, string destination, string routingKey);
    public sealed virtual void QueueDeclare(TContext context, string name);
    public sealed virtual void QueueBind(TContext context, string source, string destination);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual IMessageExchange`1<T> GetExchange(TContext context, string name, ExchangeType exchangeType);
    public sealed virtual IMessageQueue`2<TContext, T> GetQueue(TContext context, string name);
    public sealed virtual ConnectHandle ConnectMessageFabricObserver(IMessageFabricObserver`1<TContext> observer);
    private IMessageQueue`2<TContext, T> GetOrAddQueue(TContext context, string name);
    private IMessageExchange`1<T> GetOrAddExchange(TContext context, string name, ExchangeType exchangeType);
    private void ValidateBinding(IMessageSink`1<T> destination, IMessageSink`1<T> sourceExchange);
}
public class MassTransit.Transports.Fabric.MessageFabricConsumeTopologyBuilder`2 : object {
    private TContext _context;
    private IMessageFabric`2<TContext, T> _fabric;
    [CompilerGeneratedAttribute]
private string <Exchange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Exchange { get; public set; }
    public string Queue { get; public set; }
    public MessageFabricConsumeTopologyBuilder`2(TContext context, IMessageFabric`2<TContext, T> fabric);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exchange();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exchange(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Queue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Queue(string value);
    public sealed virtual void ExchangeBind(string source, string destination, string routingKey);
    public sealed virtual void QueueBind(string source, string destination);
    public sealed virtual void ExchangeDeclare(string name, ExchangeType exchangeType);
    public sealed virtual void QueueDeclare(string name);
}
public class MassTransit.Transports.Fabric.MessageFabricObservable`1 : Connectable`1<IMessageFabricObserver`1<TContext>> {
    public sealed virtual void ExchangeDeclared(TContext context, string name, ExchangeType exchangeType);
    public sealed virtual void ExchangeBindingCreated(TContext context, string source, string destination, string routingKey);
    public sealed virtual void QueueDeclared(TContext context, string name);
    public sealed virtual void QueueBindingCreated(TContext context, string source, string destination);
    public sealed virtual TopologyHandle ConsumerConnected(TContext context, TopologyHandle handle, string queueName);
}
public class MassTransit.Transports.Fabric.MessageFabricPublishTopologyBuilder`2 : object {
    private TContext _context;
    private IMessageFabric`2<TContext, T> _messageFabric;
    [CompilerGeneratedAttribute]
private string <ExchangeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExchangeType <ExchangeType>k__BackingField;
    public string ExchangeName { get; public set; }
    public ExchangeType ExchangeType { get; public set; }
    public MessageFabricPublishTopologyBuilder`2(TContext context, IMessageFabric`2<TContext, T> messageFabric);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExchangeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExchangeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ExchangeType get_ExchangeType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExchangeType(ExchangeType value);
    public sealed virtual IMessageFabricPublishTopologyBuilder CreateImplementedBuilder();
    public sealed virtual void ExchangeBind(string source, string destination, string routingKey);
    public sealed virtual void QueueBind(string source, string destination);
    public sealed virtual void ExchangeDeclare(string name, ExchangeType exchangeType);
    public sealed virtual void QueueDeclare(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Transports.Fabric.MessageFanOutExchange`1 : object {
    private Connectable`1<IMessageSink`1<T>> _sinks;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IEnumerable`1<IMessageSink`1<T>> Sinks { get; }
    public string Name { get; }
    public MessageFanOutExchange`1(string name);
    public sealed virtual IEnumerable`1<IMessageSink`1<T>> get_Sinks();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual Task Deliver(DeliveryContext`1<T> context);
    public sealed virtual ConnectHandle Connect(IMessageSink`1<T> sink, string routingKey);
    public sealed virtual void Probe(ProbeContext context);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Transports.Fabric.MessageQueue`2 : Agent {
    private Channel`1<DeliveryContext`1<T>> _channel;
    private Task _dispatcher;
    private QueueMetric _metrics;
    private IMessageFabricObserver`1<TContext> _observer;
    private MessageReceiverCollection`1<T> _receivers;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public MessageQueue`2(IMessageFabricObserver`1<TContext> observer, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual TopologyHandle ConnectMessageReceiver(TContext nodeContext, IMessageReceiver`1<T> receiver);
    [AsyncStateMachineAttribute("MassTransit.Transports.Fabric.MessageQueue`2/<Deliver>d__10")]
public sealed virtual Task Deliver(DeliveryContext`1<T> context);
    public sealed virtual void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("MassTransit.Transports.Fabric.MessageQueue`2/<StopAgent>d__12")]
protected virtual Task StopAgent(StopContext context);
    private void DeliverWithDelay(DeliveryContext`1<T> context);
    [AsyncStateMachineAttribute("MassTransit.Transports.Fabric.MessageQueue`2/<StartDispatcher>d__14")]
private Task StartDispatcher();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__5_1();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class MassTransit.Transports.Fabric.MessageReceiverCollection`1 : object {
    private LoadBalancerFactory`1<T> _balancerFactory;
    private Dictionary`2<long, IMessageReceiver`1<T>> _receivers;
    private TaskCompletionSource`1<IReceiverLoadBalancer`1<T>> _balancer;
    private long _nextId;
    public MessageReceiverCollection`1(LoadBalancerFactory`1<T> balancerFactory);
    public sealed virtual void Probe(ProbeContext context);
    public TopologyHandle Connect(IMessageReceiver`1<T> receiver);
    public Task`1<IMessageReceiver`1<T>> Next(T message, CancellationToken cancellationToken);
    public bool TryGetReceiver(long id, IMessageReceiver`1& consumer);
    private void Disconnect(long id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MassTransit.Transports.Fabric.MessageTopicExchange`1 : object {
    private TopicNode`1<T> _root;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IEnumerable`1<IMessageSink`1<T>> Sinks { get; }
    public string Name { get; }
    public MessageTopicExchange`1(string name, StringComparer comparer);
    public sealed virtual IEnumerable`1<IMessageSink`1<T>> get_Sinks();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual Task Deliver(DeliveryContext`1<T> context);
    public sealed virtual ConnectHandle Connect(IMessageSink`1<T> sink, string routingKey);
    public sealed virtual void Probe(ProbeContext context);
    public virtual string ToString();
}
public abstract class MassTransit.Transports.Fabric.Metric : object {
}
public class MassTransit.Transports.Fabric.QueueMetric : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <DeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Gauge <ActiveDeliveryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Gauge <DelayedMessageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Gauge <MessageCount>k__BackingField;
    public string Name { get; }
    public Counter DeliveryCount { get; }
    public Gauge ActiveDeliveryCount { get; }
    public Gauge DelayedMessageCount { get; }
    public Gauge MessageCount { get; }
    public QueueMetric(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Counter get_DeliveryCount();
    [CompilerGeneratedAttribute]
public Gauge get_ActiveDeliveryCount();
    [CompilerGeneratedAttribute]
public Gauge get_DelayedMessageCount();
    [CompilerGeneratedAttribute]
public Gauge get_MessageCount();
}
public class MassTransit.Transports.Fabric.RoundRobinReceiverLoadBalancer`1 : object {
    private Receiver<T> _current;
    public RoundRobinReceiverLoadBalancer`1(IMessageReceiver`1[] receivers);
    public sealed virtual IMessageReceiver`1<T> SelectReceiver(T message);
    private static Receiver<T> BuildList(IReadOnlyList`1<IMessageReceiver`1<T>> receivers);
}
public class MassTransit.Transports.Fabric.SingleReceiverLoadBalancer`1 : object {
    private IMessageReceiver`1<T> _receiver;
    public SingleReceiverLoadBalancer`1(IMessageReceiver`1<T> receiver);
    public sealed virtual IMessageReceiver`1<T> SelectReceiver(T message);
}
public class MassTransit.Transports.Fabric.TopicNode`1 : object {
    private ConcurrentDictionary`2<string, TopicNode`1<T>> _children;
    private StringComparer _comparer;
    private Connectable`1<IMessageSink`1<T>> _sinks;
    public IEnumerable`1<IMessageSink`1<T>> Sinks { get; }
    public TopicNode`1(StringComparer comparer);
    public IEnumerable`1<IMessageSink`1<T>> get_Sinks();
    public sealed virtual void Probe(ProbeContext context);
    public ConnectHandle Add(IMessageSink`1<T> sink, string pattern);
    [AsyncStateMachineAttribute("MassTransit.Transports.Fabric.TopicNode`1/<Deliver>d__8")]
public Task Deliver(DeliveryContext`1<T> context, string routingKey);
    private ConnectHandle Add(IMessageSink`1<T> sink, string pattern, int offset);
    private TopicNode`1<T> GetChild(string word);
    private ConnectHandle Bind(IMessageSink`1<T> sink);
    [CompilerGeneratedAttribute]
private TopicNode`1<T> <GetChild>b__10_0(string _);
}
public interface MassTransit.Transports.Fabric.TopologyHandle {
    public long Id { get; }
    public abstract virtual long get_Id();
    public abstract virtual void Disconnect();
}
public class MassTransit.Transports.Fabric.ZeroActiveHandler : MulticastDelegate {
    public ZeroActiveHandler(object object, IntPtr method);
    public virtual Task Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class MassTransit.Transports.HealthResultReceiveEndpointObserver : object {
    private ReceiveEndpoint _endpoint;
    public HealthResultReceiveEndpointObserver(ReceiveEndpoint endpoint);
    public sealed virtual Task Ready(ReceiveEndpointReady ready);
    public sealed virtual Task Stopping(ReceiveEndpointStopping stopping);
    public sealed virtual Task Completed(ReceiveEndpointCompleted completed);
    public sealed virtual Task Faulted(ReceiveEndpointFaulted faulted);
}
[ExtensionAttribute]
public static class MassTransit.Transports.HostConfigurationRetryExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Transports.HostConfigurationRetryExtensions/<Retry>d__0")]
[ExtensionAttribute]
public static Task Retry(IHostConfiguration hostConfiguration, Func`1<Task> factory, CancellationToken cancellationToken, CancellationToken stoppingToken);
}
public interface MassTransit.Transports.HostHandle {
    public Task`1<HostReady> Ready { get; }
    public abstract virtual Task`1<HostReady> get_Ready();
    public abstract virtual Task Stop(CancellationToken cancellationToken);
}
public interface MassTransit.Transports.IBusInstance {
    public string Name { get; }
    public Type InstanceType { get; }
    public IBus Bus { get; }
    public IBusControl BusControl { get; }
    public IHostConfiguration HostConfiguration { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_InstanceType();
    public abstract virtual IBus get_Bus();
    public abstract virtual IBusControl get_BusControl();
    public abstract virtual IHostConfiguration get_HostConfiguration();
    public abstract virtual void Connect(IRiderControl riderControl);
    public abstract virtual TRider GetRider();
}
public interface MassTransit.Transports.IBusInstance`1 {
    public TBus Bus { get; }
    public IBusInstance BusInstance { get; }
    public abstract virtual TBus get_Bus();
    public abstract virtual IBusInstance get_BusInstance();
}
public interface MassTransit.Transports.IDispatchMetrics {
    public int ActiveDispatchCount { get; }
    public long DispatchCount { get; }
    public int MaxConcurrentDispatchCount { get; }
    public abstract virtual int get_ActiveDispatchCount();
    public abstract virtual long get_DispatchCount();
    public abstract virtual int get_MaxConcurrentDispatchCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ZeroActivity(ZeroActiveDispatchHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ZeroActivity(ZeroActiveDispatchHandler value);
    public abstract virtual DeliveryMetrics GetMetrics();
}
public interface MassTransit.Transports.IHost {
    public Uri Address { get; }
    public IBusTopology Topology { get; }
    public abstract virtual Uri get_Address();
    public abstract virtual IBusTopology get_Topology();
    public abstract virtual HostHandle Start(CancellationToken cancellationToken);
    public abstract virtual void AddReceiveEndpoint(string endpointName, ReceiveEndpoint receiveEndpoint);
    public abstract virtual IRider GetRider(string name);
    public abstract virtual void AddRider(string name, IRiderControl riderControl);
    public abstract virtual BusHealthResult CheckHealth(BusState busState, string healthMessage);
}
public interface MassTransit.Transports.IHost`1 {
}
public interface MassTransit.Transports.IMessagePartitionKeyFormatter`1 {
    public abstract virtual string FormatPartitionKey(SendContext`1<TMessage> context);
}
public interface MassTransit.Transports.IMessageRoutingKeyFormatter`1 {
    public abstract virtual string FormatRoutingKey(SendContext`1<TMessage> context);
}
public interface MassTransit.Transports.IPartitionKeyFormatter {
    public abstract virtual string FormatPartitionKey(SendContext`1<T> context);
}
public interface MassTransit.Transports.IReceiveEndpointCollection {
    public abstract virtual void Add(string endpointName, ReceiveEndpoint endpoint);
    public abstract virtual HostReceiveEndpointHandle[] StartEndpoints(CancellationToken cancellationToken);
    public abstract virtual HostReceiveEndpointHandle Start(string endpointName, CancellationToken cancellationToken);
    public abstract virtual Task StopEndpoints(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<EndpointHealthResult> CheckEndpointHealth();
}
public interface MassTransit.Transports.IReceiveEndpointDispatcher {
    public Uri InputAddress { get; }
    public abstract virtual Uri get_InputAddress();
    public abstract virtual Task Dispatch(Byte[] body, IReadOnlyDictionary`2<string, object> headers, CancellationToken cancellationToken, Object[] payloads);
}
public interface MassTransit.Transports.IReceiveEndpointDispatcher`1 {
}
public interface MassTransit.Transports.IReceiveEndpointDispatcherFactory {
    public abstract virtual IReceiveEndpointDispatcher CreateReceiver(string queueName);
    public abstract virtual IReceiveEndpointDispatcher CreateConsumerReceiver(string queueName);
    public abstract virtual IReceiveEndpointDispatcher CreateSagaReceiver(string queueName);
    public abstract virtual IReceiveEndpointDispatcher CreateExecuteActivityReceiver(string queueName);
}
public interface MassTransit.Transports.IReceivePipeDispatcher {
    public abstract virtual Task Dispatch(ReceiveContext context, ReceiveLockContext receiveLock);
}
public interface MassTransit.Transports.IReceiveTransport {
    public abstract virtual ReceiveTransportHandle Start();
}
public interface MassTransit.Transports.IRiderCollection {
    public abstract virtual IRider Get(string name);
    public abstract virtual void Add(string name, IRiderControl rider);
    public abstract virtual HostRiderHandle[] StartRiders(CancellationToken cancellationToken);
    public abstract virtual HostRiderHandle StartRider(string name, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<EndpointHealthResult> CheckEndpointHealth();
}
public interface MassTransit.Transports.IRoutingKeyFormatter {
    public abstract virtual string FormatRoutingKey(SendContext`1<T> context);
}
public interface MassTransit.Transports.ISendEndpointCache`1 {
    public abstract virtual Task`1<ISendEndpoint> GetSendEndpoint(TKey key, SendEndpointFactory`1<TKey> factory);
}
public interface MassTransit.Transports.ITransportSendEndpoint {
    public abstract virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
}
public interface MassTransit.Transports.ITypeReceiveEndpointDispatcherFactory {
    public abstract virtual IReceiveEndpointDispatcher Create(IReceiveEndpointDispatcherFactory factory, IEndpointNameFormatter formatter);
}
public class MassTransit.Transports.JsonTransportHeaders : object {
    private IHeaderProvider _provider;
    public JsonTransportHeaders(IHeaderProvider provider);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, object>> GetAll();
    public sealed virtual bool TryGetHeader(string key, Object& value);
    public sealed virtual T Get(string key, T defaultValue);
    public sealed virtual Nullable`1<T> Get(string key, Nullable`1<T> defaultValue);
    public sealed virtual IEnumerator`1<HeaderValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MassTransit.Transports.MessagePartitionKeyFormatter`1 : object {
    private IPartitionKeyFormatter _formatter;
    public MessagePartitionKeyFormatter`1(IPartitionKeyFormatter formatter);
    public sealed virtual string FormatPartitionKey(SendContext`1<TMessage> context);
}
public class MassTransit.Transports.MessageRoutingKeyFormatter`1 : object {
    private IRoutingKeyFormatter _formatter;
    public MessageRoutingKeyFormatter`1(IRoutingKeyFormatter formatter);
    public sealed virtual string FormatRoutingKey(SendContext`1<TMessage> context);
}
public class MassTransit.Transports.MultiBusInstance`1 : object {
    private TBus _bus;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IBusInstance <BusInstance>k__BackingField;
    public string Name { get; }
    public Type InstanceType { get; }
    public IBus Bus { get; }
    public IBusInstance BusInstance { get; }
    public IBusControl BusControl { get; }
    public IHostConfiguration HostConfiguration { get; }
    private TBus MassTransit.Transports.IBusInstance<TBus>.Bus { get; }
    public MultiBusInstance`1(TBus bus, IBusInstance instance);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual Type get_InstanceType();
    public sealed virtual IBus get_Bus();
    [CompilerGeneratedAttribute]
public sealed virtual IBusInstance get_BusInstance();
    public sealed virtual IBusControl get_BusControl();
    public sealed virtual IHostConfiguration get_HostConfiguration();
    private sealed virtual override TBus MassTransit.Transports.IBusInstance<TBus>.get_Bus();
    public sealed virtual void Connect(IRiderControl riderControl);
    public sealed virtual TRider GetRider();
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    private static string FormatBusName();
}
public class MassTransit.Transports.PendingReceiveLockContext : object {
    private Nullable`1<Lock> _lockContext;
    private Queue`1<Lock> _pending;
    public bool IsEmpty { get; }
    public bool get_IsEmpty();
    public sealed virtual Task Complete();
    public sealed virtual Task Faulted(Exception exception);
    public sealed virtual Task ValidateLockStatus();
    public bool Enqueue(BaseReceiveContext receiveContext, ReceiveLockContext receiveLockContext);
    [AsyncStateMachineAttribute("MassTransit.Transports.PendingReceiveLockContext/<Execute>d__8")]
private Task Execute(Func`2<ReceiveLockContext, Task> action, bool clearLockContext);
    private bool TryDequeue();
    public void Cancel();
}
public class MassTransit.Transports.PublishEndpointProvider : object {
    private ISendEndpointCache`1<Type> _cache;
    private ReceiveEndpointContext _context;
    private Uri _hostAddress;
    private PublishObservable _publishObservers;
    private IPublishTopology _publishTopology;
    private ISendPipe _sendPipe;
    private IPublishTransportProvider _transportProvider;
    public PublishEndpointProvider(IPublishTransportProvider transportProvider, Uri hostAddress, PublishObservable publishObservers, ReceiveEndpointContext context, IPublishPipe publishPipe, IPublishTopology publishTopology);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    private Task`1<ISendEndpoint> CreateSendEndpoint();
    [CompilerGeneratedAttribute]
private Task`1<ISendEndpoint> <GetPublishSendEndpoint>b__8_0(Type type);
}
public class MassTransit.Transports.ReceiveEndpoint : object {
    private ReceiveEndpointContext _context;
    private TaskCompletionSource`1<ReceiveEndpointReady> _started;
    private StartObserver _startObserver;
    private IReceiveTransport _transport;
    private EndpointHandle _handle;
    [CompilerGeneratedAttribute]
private State <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointHealthResult <HealthResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InputAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectHandle <ObserverHandle>k__BackingField;
    public State CurrentState { get; public set; }
    public string Message { get; public set; }
    public EndpointHealthResult HealthResult { get; public set; }
    public bool IsBusEndpoint { get; }
    public Uri InputAddress { get; public set; }
    public Task`1<ReceiveEndpointReady> Started { get; }
    public ConnectHandle ObserverHandle { get; public set; }
    public ReceiveEndpoint(IReceiveTransport transport, ReceiveEndpointContext context);
    [CompilerGeneratedAttribute]
public State get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(State value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EndpointHealthResult get_HealthResult();
    [CompilerGeneratedAttribute]
public void set_HealthResult(EndpointHealthResult value);
    public bool get_IsBusEndpoint();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_InputAddress();
    [CompilerGeneratedAttribute]
public void set_InputAddress(Uri value);
    public sealed virtual Task`1<ReceiveEndpointReady> get_Started();
    [CompilerGeneratedAttribute]
public ConnectHandle get_ObserverHandle();
    [CompilerGeneratedAttribute]
public void set_ObserverHandle(ConnectHandle value);
    public sealed virtual ReceiveEndpointHandle Start(CancellationToken cancellationToken);
    public sealed virtual Task Stop(CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public sealed virtual Task`1<ISendEndpoint> GetPublishSendEndpoint();
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public bool IsStarted();
    [AsyncStateMachineAttribute("MassTransit.Transports.ReceiveEndpoint/<Stop>d__46")]
public Task Stop(bool removed, CancellationToken cancellationToken);
}
public class MassTransit.Transports.ReceiveEndpointCollection : object {
    private SingleThreadedDictionary`2<string, ReceiveEndpoint> _endpoints;
    private ReceiveEndpointObservable _receiveEndpointObservers;
    private bool _started;
    public sealed virtual void Add(string endpointName, ReceiveEndpoint endpoint);
    public sealed virtual HostReceiveEndpointHandle[] StartEndpoints(CancellationToken cancellationToken);
    public sealed virtual HostReceiveEndpointHandle Start(string endpointName, CancellationToken cancellationToken);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConnectHandle ConnectReceiveEndpointObserver(IReceiveEndpointObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public sealed virtual IEnumerable`1<EndpointHealthResult> CheckEndpointHealth();
    [AsyncStateMachineAttribute("MassTransit.Transports.ReceiveEndpointCollection/<StopEndpoints>d__11")]
public sealed virtual Task StopEndpoints(CancellationToken cancellationToken);
    private HostReceiveEndpointHandle StartEndpoint(string endpointName, ReceiveEndpoint endpoint, CancellationToken cancellationToken);
    private void Remove(string endpointName);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.ReceiveEndpointContext {
    public Nullable`1<TimeSpan> ConsumerStopTimeout { get; }
    public Uri InputAddress { get; }
    public bool IsBusEndpoint { get; }
    public IReceiveEndpointObserver EndpointObservers { get; }
    public IReceiveObserver ReceiveObservers { get; }
    public IReceiveTransportObserver TransportObservers { get; }
    public ILogContext LogContext { get; }
    public IPublishTopology Publish { get; }
    public IReceivePipe ReceivePipe { get; }
    public IPublishEndpointProvider PublishEndpointProvider { get; }
    public ISendEndpointProvider SendEndpointProvider { get; }
    public Task DependenciesReady { get; }
    public Task DependentsCompleted { get; }
    public bool PublishFaults { get; }
    public int PrefetchCount { get; }
    public Nullable`1<int> ConcurrentMessageLimit { get; }
    public ISerialization Serialization { get; }
    public abstract virtual Nullable`1<TimeSpan> get_ConsumerStopTimeout();
    public abstract virtual Uri get_InputAddress();
    public abstract virtual bool get_IsBusEndpoint();
    public abstract virtual IReceiveEndpointObserver get_EndpointObservers();
    public abstract virtual IReceiveObserver get_ReceiveObservers();
    public abstract virtual IReceiveTransportObserver get_TransportObservers();
    public abstract virtual ILogContext get_LogContext();
    public abstract virtual IPublishTopology get_Publish();
    public abstract virtual IReceivePipe get_ReceivePipe();
    public abstract virtual IPublishEndpointProvider get_PublishEndpointProvider();
    public abstract virtual ISendEndpointProvider get_SendEndpointProvider();
    public abstract virtual Task get_DependenciesReady();
    public abstract virtual Task get_DependentsCompleted();
    public abstract virtual bool get_PublishFaults();
    public abstract virtual int get_PrefetchCount();
    public abstract virtual Nullable`1<int> get_ConcurrentMessageLimit();
    public abstract virtual ISerialization get_Serialization();
    public abstract virtual Exception ConvertException(Exception exception, string message);
    public abstract virtual IReceivePipeDispatcher CreateReceivePipeDispatcher();
    public abstract virtual void Reset();
    public abstract virtual void AddConsumeAgent(IAgent agent);
    public abstract virtual void AddSendAgent(IAgent agent);
}
public class MassTransit.Transports.ReceiveEndpointDispatcher : object {
    private ReceiveEndpointContext _context;
    private IReceivePipeDispatcher _dispatcher;
    public int ActiveDispatchCount { get; }
    public long DispatchCount { get; }
    public int MaxConcurrentDispatchCount { get; }
    public Uri InputAddress { get; }
    public ReceiveEndpointDispatcher(ReceiveEndpointContext context);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual int get_ActiveDispatchCount();
    public sealed virtual long get_DispatchCount();
    public sealed virtual int get_MaxConcurrentDispatchCount();
    public sealed virtual void add_ZeroActivity(ZeroActiveDispatchHandler value);
    public sealed virtual void remove_ZeroActivity(ZeroActiveDispatchHandler value);
    public sealed virtual DeliveryMetrics GetMetrics();
    public sealed virtual Uri get_InputAddress();
    [AsyncStateMachineAttribute("MassTransit.Transports.ReceiveEndpointDispatcher/<Dispatch>d__21")]
public sealed virtual Task Dispatch(Byte[] body, IReadOnlyDictionary`2<string, object> headers, CancellationToken cancellationToken, Object[] payloads);
}
public class MassTransit.Transports.ReceiveEndpointDispatcher`1 : object {
    private IReceiveEndpointDispatcher _dispatcher;
    public int ActiveDispatchCount { get; }
    public long DispatchCount { get; }
    public int MaxConcurrentDispatchCount { get; }
    public Uri InputAddress { get; }
    public ReceiveEndpointDispatcher`1(IReceiveEndpointDispatcherFactory factory);
    public ReceiveEndpointDispatcher`1(IReceiveEndpointDispatcherFactory factory, IEndpointNameFormatter formatter);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T1> observer);
    public sealed virtual int get_ActiveDispatchCount();
    public sealed virtual long get_DispatchCount();
    public sealed virtual int get_MaxConcurrentDispatchCount();
    public sealed virtual void add_ZeroActivity(ZeroActiveDispatchHandler value);
    public sealed virtual void remove_ZeroActivity(ZeroActiveDispatchHandler value);
    public sealed virtual DeliveryMetrics GetMetrics();
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual Uri get_InputAddress();
    public sealed virtual Task Dispatch(Byte[] body, IReadOnlyDictionary`2<string, object> headers, CancellationToken cancellationToken, Object[] payloads);
    [CompilerGeneratedAttribute]
internal static IReceiveEndpointDispatcher <.ctor>g__CreateDispatcher|2_0(Type dispatcherType, <>c__DisplayClass2_0& );
}
public class MassTransit.Transports.ReceiveEndpointDispatcherFactory : object {
    private ConcurrentDictionary`2<string, Lazy`1<IReceiveEndpointDispatcher>> _dispatchers;
    private IHostConfiguration _hostConfiguration;
    private IBusRegistrationContext _registration;
    public ReceiveEndpointDispatcherFactory(IBusRegistrationContext registration, IBusInstance busInstance);
    public sealed virtual IReceiveEndpointDispatcher CreateReceiver(string queueName);
    public sealed virtual IReceiveEndpointDispatcher CreateConsumerReceiver(string queueName);
    public sealed virtual IReceiveEndpointDispatcher CreateSagaReceiver(string queueName);
    public sealed virtual IReceiveEndpointDispatcher CreateExecuteActivityReceiver(string queueName);
    public sealed virtual ValueTask DisposeAsync();
    private IReceiveEndpointDispatcher CreateMessageReceiver(string queueName, Action`1<IReceiveEndpointConfigurator> configure);
    [CompilerGeneratedAttribute]
private void <CreateReceiver>b__4_0(IReceiveEndpointConfigurator cfg);
    [CompilerGeneratedAttribute]
private void <CreateConsumerReceiver>b__5_0(IReceiveEndpointConfigurator cfg);
    [CompilerGeneratedAttribute]
private void <CreateSagaReceiver>b__6_0(IReceiveEndpointConfigurator cfg);
    [CompilerGeneratedAttribute]
private void <CreateExecuteActivityReceiver>b__7_0(IReceiveEndpointConfigurator cfg);
}
public class MassTransit.Transports.ReceiveEndpointDispatcherReceiveContext : BaseReceiveContext {
    [CompilerGeneratedAttribute]
private IHeaderProvider <HeaderProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageBody <Body>k__BackingField;
    protected IHeaderProvider HeaderProvider { get; }
    public MessageBody Body { get; }
    public ReceiveEndpointDispatcherReceiveContext(ReceiveEndpointContext receiveEndpointContext, Byte[] body, IReadOnlyDictionary`2<string, object> headers, Object[] payloads);
    [CompilerGeneratedAttribute]
protected virtual IHeaderProvider get_HeaderProvider();
    [CompilerGeneratedAttribute]
public virtual MessageBody get_Body();
    private static bool IsRedelivered(IReadOnlyDictionary`2<string, object> headers);
}
[ExtensionAttribute]
public static class MassTransit.Transports.ReceiveEndpointLoggingExtensions : object {
    private static LogMessage`5<Uri, Nullable`1<Guid>, string, string, TimeSpan> _logConsumed;
    private static LogMessage`5<Uri, Nullable`1<Guid>, string, string, TimeSpan> _logConsumeFault;
    private static LogMessage`5<Uri, Nullable`1<Guid>, string, string, TimeSpan> _logConsumeCanceled;
    private static LogMessage`4<Uri, string, string, string> _logMoved;
    private static LogMessage`3<Uri, string, TimeSpan> _logReceiveFault;
    private static LogMessage`3<Uri, string, object> _logReceiveDupe;
    private static LogMessage`3<Uri, Nullable`1<Guid>, string> _logSent;
    private static LogMessage`3<Uri, Nullable`1<Guid>, string> _logSendFault;
    private static LogMessage`2<Uri, string> _logSkipped;
    private static LogMessage`3<Uri, Nullable`1<Guid>, string> _logRetry;
    private static LogMessage`2<Uri, string> _logFault;
    private static LogMessage`5<Uri, Nullable`1<Guid>, string, DateTime, Nullable`1<Guid>> _logScheduled;
    private static LogMessage`3<Uri, long, int> _logConsumerCompleted;
    private static LogMessage`4<Uri, long, int, string> _logConsumerCompletedTag;
    private static ReceiveEndpointLoggingExtensions();
    [ExtensionAttribute]
public static void LogSkipped(ReceiveContext context);
    [ExtensionAttribute]
public static void LogMoved(ReceiveContext context, string destination, string reason);
    [ExtensionAttribute]
public static void LogConsumed(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    [ExtensionAttribute]
public static void LogFaulted(ConsumeContext`1<T> context, TimeSpan duration, string consumerType, Exception exception);
    [ExtensionAttribute]
public static void LogCanceled(ConsumeContext`1<T> context, TimeSpan duration, string consumerType);
    [ExtensionAttribute]
public static void LogFaulted(ReceiveContext context, Exception exception);
    [ExtensionAttribute]
public static void LogTransportDupe(ReceiveContext context, TTransportMessageId transportMessageId);
    [ExtensionAttribute]
public static void LogTransportFaulted(ReceiveContext context, Exception exception);
    [ExtensionAttribute]
public static void LogRetry(ConsumeContext context, Exception exception);
    [ExtensionAttribute]
public static void LogRetry(TContext context, Exception exception);
    [ExtensionAttribute]
public static void LogFaulted(SendContext`1<T> context, Exception exception);
    [ExtensionAttribute]
public static void LogSent(SendContext`1<T> context);
    [ExtensionAttribute]
public static void LogConsumerCompleted(ReceiveEndpointContext context, long deliveryCount, int concurrentDeliveryCount);
    [ExtensionAttribute]
public static void LogConsumerCompleted(ReceiveEndpointContext context, long deliveryCount, int concurrentDeliveryCount, string tag);
    [ExtensionAttribute]
public static void LogScheduled(SendContext`1<T> context, DateTime deliveryTime);
    private static string GetMessageId(ReceiveContext context);
}
public interface MassTransit.Transports.ReceiveLockContext {
    public abstract virtual Task Complete();
    public abstract virtual Task Faulted(Exception exception);
    public abstract virtual Task ValidateLockStatus();
}
public class MassTransit.Transports.ReceivePipeDispatcher : object {
    private string _activityName;
    private string _endpointName;
    private IHostConfiguration _hostConfiguration;
    private string _inputAddress;
    private ReceiveObservable _observers;
    private IReceivePipe _receivePipe;
    private int _activeDispatchCount;
    private long _dispatchCount;
    private int _maxConcurrentDispatchCount;
    [CompilerGeneratedAttribute]
private ZeroActiveDispatchHandler ZeroActivity;
    public int ActiveDispatchCount { get; }
    public long DispatchCount { get; }
    public int MaxConcurrentDispatchCount { get; }
    public ReceivePipeDispatcher(IReceivePipe receivePipe, ReceiveObservable observers, IHostConfiguration hostConfiguration, Uri inputAddress);
    public sealed virtual int get_ActiveDispatchCount();
    public sealed virtual long get_DispatchCount();
    public sealed virtual int get_MaxConcurrentDispatchCount();
    public sealed virtual DeliveryMetrics GetMetrics();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ZeroActivity(ZeroActiveDispatchHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ZeroActivity(ZeroActiveDispatchHandler value);
    [AsyncStateMachineAttribute("MassTransit.Transports.ReceivePipeDispatcher/<Dispatch>d__20")]
public sealed virtual Task Dispatch(ReceiveContext context, ReceiveLockContext receiveLock);
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumePipe(IPipe`1<ConsumeContext`1<T>> pipe, ConnectPipeOptions options);
    public sealed virtual ConnectHandle ConnectRequestPipe(Guid requestId, IPipe`1<ConsumeContext`1<T>> pipe);
    public sealed virtual ConnectHandle ConnectConsumeObserver(IConsumeObserver observer);
    public sealed virtual ConnectHandle ConnectConsumeMessageObserver(IConsumeMessageObserver`1<T> observer);
    private ActiveDispatch StartDispatch();
    [AsyncStateMachineAttribute("MassTransit.Transports.ReceivePipeDispatcher/<DispatchComplete>d__29")]
private Task DispatchComplete(long id);
}
public class MassTransit.Transports.ReceiveTransport`1 : object {
    private ReceiveEndpointContext _context;
    private IHostConfiguration _hostConfiguration;
    private Func`1<ITransportSupervisor`1<TContext>> _supervisorFactory;
    private IPipe`1<TContext> _transportPipe;
    [CompilerGeneratedAttribute]
private IPipe`1<TContext> <PreStartPipe>k__BackingField;
    public IPipe`1<TContext> PreStartPipe { get; public set; }
    public ReceiveTransport`1(IHostConfiguration hostConfiguration, ReceiveEndpointContext context, Func`1<ITransportSupervisor`1<TContext>> supervisorFactory, IPipe`1<TContext> transportPipe);
    [CompilerGeneratedAttribute]
public IPipe`1<TContext> get_PreStartPipe();
    [CompilerGeneratedAttribute]
public void set_PreStartPipe(IPipe`1<TContext> value);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual ReceiveTransportHandle Start();
    public sealed virtual ConnectHandle ConnectReceiveObserver(IReceiveObserver observer);
    public sealed virtual ConnectHandle ConnectReceiveTransportObserver(IReceiveTransportObserver observer);
    public sealed virtual ConnectHandle ConnectPublishObserver(IPublishObserver observer);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
}
public interface MassTransit.Transports.ReceiveTransportHandle {
    public abstract virtual Task Stop(CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MassTransit.Transports.ReceiveTransportObserverExtensions : object {
    [ExtensionAttribute]
public static Task NotifyReady(IReceiveTransportObserver observer, Uri inputAddress, bool isStarted);
    [ExtensionAttribute]
public static Task NotifyCompleted(IReceiveTransportObserver observer, Uri inputAddress, DeliveryMetrics metrics);
    [ExtensionAttribute]
public static Task NotifyFaulted(IReceiveTransportObserver observer, Uri inputAddress, Exception exception);
}
public class MassTransit.Transports.RiderCollection : Agent {
    private Dictionary`2<string, Handle> _handles;
    private object _mutateLock;
    private Dictionary`2<string, IRiderControl> _riders;
    public sealed virtual IRider Get(string name);
    public sealed virtual void Add(string name, IRiderControl rider);
    public sealed virtual HostRiderHandle[] StartRiders(CancellationToken cancellationToken);
    public sealed virtual HostRiderHandle StartRider(string name, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<EndpointHealthResult> CheckEndpointHealth();
    private HostRiderHandle StartRider(string name, IRiderControl rider, CancellationToken cancellationToken);
    private void Remove(string name);
    [AsyncStateMachineAttribute("MassTransit.Transports.RiderCollection/<StopAgent>d__11")]
protected virtual Task StopAgent(StopContext context);
    [AsyncStateMachineAttribute("MassTransit.Transports.RiderCollection/<<StartRider>g__Ready|9_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<RiderReady> <StartRider>g__Ready|9_0(RiderHandle r, string n);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class MassTransit.Transports.SagaReceiveEndpointDispatcher`1 : object {
    public sealed virtual IReceiveEndpointDispatcher Create(IReceiveEndpointDispatcherFactory factory, IEndpointNameFormatter formatter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Transports.SendContextPipeAdapter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IPipe`1<SendContext`1<TMessage>> _pipe;
    protected SendContextPipeAdapter`1(IPipe`1<SendContext`1<TMessage>> pipe);
    public sealed virtual void Probe(ProbeContext context);
    private sealed virtual override Task MassTransit.IPipe<MassTransit.SendContext<TMessage>>.Send(SendContext`1<TMessage> context);
    private sealed virtual override Task MassTransit.Transports.ISendContextPipe.Send(SendContext`1<T> context);
    protected abstract virtual void Send(SendContext`1<TMessage> context);
    protected abstract virtual void Send(SendContext`1<T> context);
}
public class MassTransit.Transports.SendEndpoint : object {
    private ConnectHandle _observerHandle;
    private ISendPipe _sendPipe;
    private ISendTransport _transport;
    [CompilerGeneratedAttribute]
private Uri <DestinationAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageSerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerialization <Serialization>k__BackingField;
    private Uri DestinationAddress { get; }
    private Uri SourceAddress { get; }
    private IMessageSerializer Serializer { get; }
    private ISerialization Serialization { get; }
    public SendEndpoint(ISendTransport transport, ReceiveEndpointContext context, Uri destinationAddress, ISendPipe sendPipe, ConnectHandle observerHandle);
    [CompilerGeneratedAttribute]
private Uri get_DestinationAddress();
    [CompilerGeneratedAttribute]
private Uri get_SourceAddress();
    [CompilerGeneratedAttribute]
private IMessageSerializer get_Serializer();
    [CompilerGeneratedAttribute]
private ISerialization get_Serialization();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpoint/<Send>d__26`1")]
public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpoint/<Send>d__27`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpoint/<Send>d__28`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
}
public class MassTransit.Transports.SendEndpointCache`1 : object {
    private ICache`3<TKey, CachedSendEndpoint`1<TKey>, ITimeToLiveCacheValue`1<CachedSendEndpoint`1<TKey>>> _cache;
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointCache`1/<GetSendEndpoint>d__2")]
public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(TKey key, SendEndpointFactory`1<TKey> factory);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointCache`1/<GetSendEndpointFromFactory>d__3")]
private static Task`1<CachedSendEndpoint`1<TKey>> GetSendEndpointFromFactory(TKey address, SendEndpointFactory`1<TKey> factory);
}
public static class MassTransit.Transports.SendEndpointCacheDefaults : object {
    [CompilerGeneratedAttribute]
private static int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <MinAge>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <MaxAge>k__BackingField;
    public static int Capacity { get; public set; }
    public static TimeSpan MinAge { get; public set; }
    public static TimeSpan MaxAge { get; public set; }
    private static SendEndpointCacheDefaults();
    [CompilerGeneratedAttribute]
public static int get_Capacity();
    [CompilerGeneratedAttribute]
public static void set_Capacity(int value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_MinAge();
    [CompilerGeneratedAttribute]
public static void set_MinAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public static void set_MaxAge(TimeSpan value);
}
public class MassTransit.Transports.SendEndpointFactory`1 : MulticastDelegate {
    public SendEndpointFactory`1(object object, IntPtr method);
    public virtual Task`1<ISendEndpoint> Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual Task`1<ISendEndpoint> EndInvoke(IAsyncResult result);
}
public class MassTransit.Transports.SendEndpointProvider : object {
    private ISendEndpointCache`1<Uri> _cache;
    private ReceiveEndpointContext _context;
    private SendObservable _observers;
    private ISendTransportProvider _provider;
    private ISendPipe _sendPipe;
    public SendEndpointProvider(ISendTransportProvider provider, SendObservable observers, ReceiveEndpointContext context, ISendPipe sendPipe);
    public sealed virtual Task`1<ISendEndpoint> GetSendEndpoint(Uri address);
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointProvider/<CreateSendEndpoint>d__8")]
private Task`1<ISendEndpoint> CreateSendEndpoint(Uri address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MassTransit.Transports.SendEndpointProxy : object {
    private ISendEndpoint _endpoint;
    [NullableAttribute("2")]
private ITransportSendEndpoint _transportEndpoint;
    public ISendEndpoint Endpoint { get; }
    protected SendEndpointProxy(ISendEndpoint endpoint);
    public ISendEndpoint get_Endpoint();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public virtual Task Send(T message, CancellationToken cancellationToken);
    public virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public virtual Task Send(T message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, Type messageType, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointProxy/<Send>d__14`1")]
public sealed virtual Task Send(object values, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointProxy/<Send>d__15`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendEndpointProxy/<Send>d__16`1")]
public sealed virtual Task Send(object values, IPipe`1<SendContext> pipe, CancellationToken cancellationToken);
    protected abstract virtual IPipe`1<SendContext`1<T>> GetPipeProxy(IPipe`1<SendContext`1<T>> pipe);
}
public class MassTransit.Transports.SendTransport`1 : Supervisor {
    private SendTransportContext`1<TContext> _context;
    public SendTransport`1(SendTransportContext`1<TContext> context);
    [AsyncStateMachineAttribute("MassTransit.Transports.SendTransport`1/<DisposeAsync>d__2")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual ConnectHandle ConnectSendObserver(ISendObserver observer);
    public sealed virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public sealed virtual Task Send(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    protected virtual Task StopSupervisor(StopSupervisorContext context);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.SendTransportContext {
    public ILogContext LogContext { get; }
    public string EntityName { get; }
    public string ActivityName { get; }
    public string ActivityDestination { get; }
    public string ActivitySystem { get; }
    public SendObservable SendObservers { get; }
    public ISerialization Serialization { get; }
    public abstract virtual ILogContext get_LogContext();
    public abstract virtual string get_EntityName();
    public abstract virtual string get_ActivityName();
    public abstract virtual string get_ActivityDestination();
    public abstract virtual string get_ActivitySystem();
    public abstract virtual SendObservable get_SendObservers();
    public abstract virtual ISerialization get_Serialization();
    public abstract virtual Task`1<SendContext`1<T>> CreateSendContext(T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface MassTransit.Transports.SendTransportContext`1 {
    public abstract virtual IEnumerable`1<IAgent> GetAgentHandles();
    public abstract virtual Task`1<SendContext`1<T>> CreateSendContext(TContext context, T message, IPipe`1<SendContext`1<T>> pipe, CancellationToken cancellationToken);
    public abstract virtual Task Send(TContext transportContext, SendContext`1<T> sendContext);
}
public class MassTransit.Transports.StartHostHandle : object {
    private HostReceiveEndpointHandle[] _handles;
    private BaseHost _host;
    private HostRiderHandle[] _riderHandles;
    private Task`1<HostReady> MassTransit.Transports.HostHandle.Ready { get; }
    public StartHostHandle(BaseHost host, HostReceiveEndpointHandle[] handles, HostRiderHandle[] riderHandles);
    private sealed virtual override Task`1<HostReady> MassTransit.Transports.HostHandle.get_Ready();
    private sealed virtual override Task MassTransit.Transports.HostHandle.Stop(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Transports.StartHostHandle/<ReadyOrNot>d__7")]
private Task`1<HostReady> ReadyOrNot(Task`1[] endpoints, Task`1[] riders);
    [AsyncStateMachineAttribute("MassTransit.Transports.StartHostHandle/<EndpointsReady>d__8")]
private static Task`1<ReceiveEndpointReady[]> EndpointsReady(Task`1[] endpoints);
    [AsyncStateMachineAttribute("MassTransit.Transports.StartHostHandle/<RidersReady>d__9")]
private static Task`1<RiderReady[]> RidersReady(Task`1[] riders);
}
public class MassTransit.Transports.TransportBusInstance`1 : object {
    private IHost`1<TEndpointConfigurator> _host;
    [CompilerGeneratedAttribute]
private IBusRegistrationContext <RegistrationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IBusControl <BusControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IHostConfiguration <HostConfiguration>k__BackingField;
    protected IBusRegistrationContext RegistrationContext { get; }
    public string Name { get; }
    public Type InstanceType { get; }
    public IBus Bus { get; }
    public IBusControl BusControl { get; }
    public IHostConfiguration HostConfiguration { get; }
    public TransportBusInstance`1(IBusControl busControl, IHost`1<TEndpointConfigurator> host, IHostConfiguration hostConfiguration, IBusRegistrationContext busRegistrationContext);
    [CompilerGeneratedAttribute]
protected IBusRegistrationContext get_RegistrationContext();
    public sealed virtual string get_Name();
    public sealed virtual Type get_InstanceType();
    public sealed virtual IBus get_Bus();
    [CompilerGeneratedAttribute]
public sealed virtual IBusControl get_BusControl();
    [CompilerGeneratedAttribute]
public sealed virtual IHostConfiguration get_HostConfiguration();
    public sealed virtual void Connect(IRiderControl riderControl);
    public sealed virtual TRider GetRider();
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, IReceiveEndpointConfigurator> configure);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(IEndpointDefinition definition, IEndpointNameFormatter endpointNameFormatter, Action`2<IBusRegistrationContext, TEndpointConfigurator> configure);
    public sealed virtual HostReceiveEndpointHandle ConnectReceiveEndpoint(string queueName, Action`2<IBusRegistrationContext, TEndpointConfigurator> configure);
    private static string GetRiderName();
}
public static class MassTransit.Transports.TransportLogMessages : object {
    public static LogMessage`1<string> ConnectHost;
    public static LogMessage`1<string> ConnectedHost;
    public static LogMessage`1<string> DisconnectHost;
    public static LogMessage`1<string> DisconnectedHost;
    public static LogMessage`1<string> StoppingSendTransport;
    public static LogMessage`1<Uri> ConnectReceiveEndpoint;
    public static LogMessage`2<Uri, string> ConnectSubscriptionEndpoint;
    public static LogMessage`1<Uri> CreateReceiveTransport;
    public static LogMessage`1<Uri> CreatePublishTransport;
    public static LogMessage`1<string> CreateExchange;
    public static LogMessage`1<string> CreateQueue;
    public static LogMessage`1<string> CreateTopic;
    public static LogMessage`1<Uri> CreateSendTransport;
    public static LogMessage`1<string> DeleteQueue;
    public static LogMessage`2<string, string> DeleteSubscription;
    public static LogMessage`1<string> DeleteTopic;
    private static TransportLogMessages();
}
public class MassTransit.Transports.TransportPipeContextSupervisor`1 : PipeContextSupervisor`1<T> {
    private ISupervisor _consumeSupervisor;
    private ISupervisor _sendSupervisor;
    public CancellationToken ConsumeStopping { get; }
    public CancellationToken SendStopping { get; }
    protected TransportPipeContextSupervisor`1(IPipeContextFactory`1<T> factory);
    public sealed virtual CancellationToken get_ConsumeStopping();
    public sealed virtual CancellationToken get_SendStopping();
    public sealed virtual void AddSendAgent(TAgent agent);
    public sealed virtual void AddConsumeAgent(TAgent agent);
    [AsyncStateMachineAttribute("MassTransit.Transports.TransportPipeContextSupervisor`1/<StopSupervisor>d__9")]
protected virtual Task StopSupervisor(StopSupervisorContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopSupervisorContext context);
}
[ExtensionAttribute]
public static class MassTransit.Transports.TransportStartExtensions : object {
    [AsyncStateMachineAttribute("MassTransit.Transports.TransportStartExtensions/<OnTransportStartup>d__0`1")]
[ExtensionAttribute]
public static Task OnTransportStartup(ReceiveEndpointContext context, ITransportSupervisor`1<T> supervisor, CancellationToken cancellationToken);
}
public class MassTransit.Transports.ZeroActiveDispatchHandler : MulticastDelegate {
    public ZeroActiveDispatchHandler(object object, IntPtr method);
    public virtual Task Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public static class MassTransit.Util.AssemblyTypeCache : object {
    public static void Clear();
    public static void ThrowIfAnyTypeScanFailures();
    public static IEnumerable`1<AssemblyScanTypeInfo> FailedAssemblies();
    public static Task`1<AssemblyScanTypeInfo> ForAssembly(Assembly assembly);
    public static Task`1<TypeSet> FindTypes(IEnumerable`1<Assembly> assemblies, Func`2<Type, bool> filter);
    public static Task`1<IEnumerable`1<Type>> FindTypes(IEnumerable`1<Assembly> assemblies, TypeClassification classification, Func`2<Type, bool> filter);
    public static Task`1<IEnumerable`1<Type>> FindTypes(Assembly assembly, TypeClassification classification, Func`2<Type, bool> filter);
    public static IEnumerable`1<Type> FindTypesInNamespace(Type type, Func`2<Type, bool> typeFilter, TypeClassification typeClassification);
}
public class MassTransit.Util.ChannelExecutor : object {
    private Channel`1<IFuture> _channel;
    private int _concurrencyLimit;
    private SemaphoreSlim _limit;
    private Task _readerTask;
    private object _syncLock;
    private bool _disposed;
    public ChannelExecutor(int prefetchCount, int concurrencyLimit);
    public ChannelExecutor(int concurrencyLimit, bool allowSynchronousContinuations);
    [AsyncStateMachineAttribute("MassTransit.Util.ChannelExecutor/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
    public void PushWithWait(Func`1<Task> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.ChannelExecutor/<Push>d__10")]
public Task Push(Func`1<Task> method, CancellationToken cancellationToken);
    public Task Run(Func`1<Task> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.ChannelExecutor/<Run>d__12`1")]
public Task`1<T> Run(Func`1<Task`1<T>> method, CancellationToken cancellationToken);
    public Task Run(Action method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.ChannelExecutor/<Run>d__14`1")]
public Task`1<T> Run(Func`1<T> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.ChannelExecutor/<ReadFromChannel>d__15")]
private Task ReadFromChannel();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__6_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__7_0();
}
public class MassTransit.Util.ChartRow : object {
    private Object[] _columns;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Timeline>k__BackingField;
    public string Title { get; }
    public string Duration { get; }
    public string Timeline { get; }
    public ChartRow(string title, string duration, string timeline, Object[] columns);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_Duration();
    [CompilerGeneratedAttribute]
public string get_Timeline();
    public object GetColumn(int column);
}
public class MassTransit.Util.ChartTable : object {
    private int _chartWidth;
    private List`1<Line> _lines;
    public ChartTable(int chartWidth);
    public ChartTable Add(string text, DateTime startTime, Nullable`1<TimeSpan> duration, Object[] columns);
    [IteratorStateMachineAttribute("MassTransit.Util.ChartTable/<GetRows>d__4")]
public IEnumerable`1<ChartRow> GetRows();
    public ValueTuple`2<DateTime, DateTime> CalculateRange();
}
public static class MassTransit.Util.ConvertObject : object {
    public static Dictionary`2<string, object> ToDictionary(object values);
    private static void AddPropertyToDictionary(PropertyInfo property, object source, IDictionary`2<string, object> dictionary);
}
[ExtensionAttribute]
public static class MassTransit.Util.DisposeAsyncExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<T> DisposeAsync(Exception exception, Func`1<Task> disposeCallback);
    [ExtensionAttribute]
public static ValueTask`1<T> DisposeAsync(Exception exception, Func`1<ValueTask> disposeCallback);
}
public static class MassTransit.Util.FormatUtil : object {
    public static INewIdFormatter Formatter;
    private static FormatUtil();
}
public interface MassTransit.Util.IChannelExecutorPool`1 {
    public abstract virtual Task Push(TPartition partition, Func`1<Task> method, CancellationToken cancellationToken);
    public abstract virtual Task Run(TPartition partition, Func`1<Task> method, CancellationToken cancellationToken);
}
public enum MassTransit.Util.NumberAlignment : Enum {
    public int value__;
    public static NumberAlignment Left;
    public static NumberAlignment Right;
}
public class MassTransit.Util.ObservableObserver`1 : object {
    private Connectable`1<IObserver`1<T>> _observers;
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
}
public class MassTransit.Util.PartitionChannelExecutorPool`1 : object {
    private IHashGenerator _hashGenerator;
    private PartitionKeyProvider`1<T> _partitionKeyProvider;
    private Lazy`1[] _partitions;
    public PartitionChannelExecutorPool`1(PartitionKeyProvider`1<T> partitionKeyProvider, IHashGenerator hashGenerator, int concurrencyLimit, int concurrentDeliveryLimit);
    [AsyncStateMachineAttribute("MassTransit.Util.PartitionChannelExecutorPool`1/<DisposeAsync>d__4")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task Push(T partition, Func`1<Task> method, CancellationToken cancellationToken);
    public sealed virtual Task Run(T partition, Func`1<Task> method, CancellationToken cancellationToken);
    private TaskExecutor GetChannelExecutor(T partition);
}
public class MassTransit.Util.Recycle`1 : object {
    private Lazy`1<T> _supervisor;
    public T Supervisor { get; }
    public Recycle`1(Func`1<T> supervisorFactory);
    public T get_Supervisor();
}
public class MassTransit.Util.RollingTimer : object {
    private TimerCallback _callback;
    private object _lock;
    private object _state;
    private TimeSpan _timeout;
    private Timer _timer;
    private int _triggered;
    public bool Triggered { get; }
    public RollingTimer(TimerCallback callback, TimeSpan timeout, object state);
    public bool get_Triggered();
    public sealed virtual void Dispose();
    public void Start();
    public void Stop();
    public void Restart(Nullable`1<TimeSpan> timeout);
    private void StartInternal();
    private void Set();
    private void Reset();
}
public class MassTransit.Util.Scanning.AssemblyFinder : object {
    public static IEnumerable`1<Assembly> FindAssemblies(AssemblyLoadFailure loadFailure, bool includeExeFiles, AssemblyFilter filter);
    [IteratorStateMachineAttribute("MassTransit.Util.Scanning.AssemblyFinder/<FindAssemblies>d__3")]
public static IEnumerable`1<Assembly> FindAssemblies(string assemblyPath, AssemblyLoadFailure loadFailure, bool includeExeFiles, AssemblyFilter filter);
}
public class MassTransit.Util.Scanning.AssemblyScanner : object {
    private List`1<Assembly> _assemblies;
    private CompositeFilter`1<string> _assemblyFilter;
    private CompositeFilter`1<Type> _filter;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public int Count { get; }
    public string Description { get; public set; }
    public int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    public sealed virtual void Assembly(Assembly assembly);
    public sealed virtual void Assembly(string assemblyName);
    public sealed virtual void AssemblyContainingType();
    public sealed virtual void AssemblyContainingType(Type type);
    public sealed virtual void Exclude(Func`2<Type, bool> exclude);
    public sealed virtual void ExcludeNamespace(string nameSpace);
    public sealed virtual void ExcludeNamespaceContainingType();
    public sealed virtual void Include(Func`2<Type, bool> predicate);
    public sealed virtual void IncludeNamespace(string nameSpace);
    public sealed virtual void IncludeNamespaceContainingType();
    public sealed virtual void ExcludeType();
    public sealed virtual void AssembliesFromApplicationBaseDirectory();
    public sealed virtual void AssembliesAndExecutablesFromPath(string path);
    public sealed virtual void AssembliesFromPath(string path);
    public sealed virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void ExcludeFileNameStartsWith(String[] startsWith);
    public sealed virtual void IncludeFileNameStartsWith(String[] startsWith);
    public sealed virtual void AssembliesAndExecutablesFromApplicationBaseDirectory();
    public sealed virtual Task`1<TypeSet> ScanForTypes();
    public sealed virtual void TheCallingAssembly();
    private static void OnAssemblyLoadFailure(string assemblyName, Exception exception);
    public bool Contains(string assemblyName);
    public bool HasAssemblies();
    private static Assembly FindTheCallingAssembly();
}
public class MassTransit.Util.Scanning.AssemblyScanRecord : object {
    public Exception LoadException;
    public string Name;
    public virtual string ToString();
}
public class MassTransit.Util.Scanning.AssemblyScanTypeInfo : object {
    public AssemblyTypeList ClosedTypes;
    public AssemblyTypeList OpenTypes;
    [CompilerGeneratedAttribute]
private AssemblyScanRecord <Record>k__BackingField;
    public AssemblyScanRecord Record { get; }
    public AssemblyScanTypeInfo(Assembly assembly);
    public AssemblyScanTypeInfo(string name, Func`1<IEnumerable`1<Type>> source);
    [CompilerGeneratedAttribute]
public AssemblyScanRecord get_Record();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    private IEnumerable`1<Type> SelectTypes(IList`1[] lists);
    private IEnumerable`1<IList`1<Type>> SelectGroups(TypeClassification classification);
    [IteratorStateMachineAttribute("MassTransit.Util.Scanning.AssemblyScanTypeInfo/<SelectLists>d__10")]
private IEnumerable`1<AssemblyTypeList> SelectLists(TypeClassification classification);
}
public class MassTransit.Util.Scanning.AssemblyTypeList : object {
    public List`1<Type> Abstract;
    public List`1<Type> Concrete;
    public List`1<Type> Interface;
    [IteratorStateMachineAttribute("MassTransit.Util.Scanning.AssemblyTypeList/<SelectTypes>d__3")]
public IEnumerable`1<IList`1<Type>> SelectTypes(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
    public void Add(Type type);
}
public interface MassTransit.Util.Scanning.IAssemblyScanner {
    public string Description { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual void Assembly(Assembly assembly);
    public abstract virtual void Assembly(string assemblyName);
    public abstract virtual void AssemblyContainingType();
    public abstract virtual void AssemblyContainingType(Type type);
    public abstract virtual void Exclude(Func`2<Type, bool> exclude);
    public abstract virtual void ExcludeNamespace(string nameSpace);
    public abstract virtual void ExcludeNamespaceContainingType();
    public abstract virtual void Include(Func`2<Type, bool> predicate);
    public abstract virtual void IncludeNamespace(string nameSpace);
    public abstract virtual void IncludeNamespaceContainingType();
    public abstract virtual void ExcludeType();
    public abstract virtual void TheCallingAssembly();
    public abstract virtual void AssembliesFromApplicationBaseDirectory();
    public abstract virtual void AssembliesAndExecutablesFromPath(string path);
    public abstract virtual void AssembliesFromPath(string path);
    public abstract virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void ExcludeFileNameStartsWith(String[] startsWith);
    public abstract virtual void IncludeFileNameStartsWith(String[] startsWith);
    public abstract virtual void AssembliesAndExecutablesFromApplicationBaseDirectory();
    public abstract virtual Task`1<TypeSet> ScanForTypes();
}
public class MassTransit.Util.Scanning.TypeQuery : object {
    private TypeClassification _classification;
    public Func`2<Type, bool> Filter;
    public TypeQuery(TypeClassification classification, Func`2<Type, bool> filter);
    public IEnumerable`1<Type> Find(AssemblyScanTypeInfo assembly);
}
[DefaultMemberAttribute("Item")]
public class MassTransit.Util.SingleThreadedDictionary`2 : object {
    private IEqualityComparer`1<TKey> _comparer;
    private object _lock;
    private IDictionary`2<TKey, TValue> _dictionary;
    public int Count { get; }
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public SingleThreadedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public void Clear();
    public bool TryAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public bool TryRemove(TKey key, TValue& value);
}
public class MassTransit.Util.TaskExecutor : object {
    private Task _readerTask;
    private Channel`1<IFuture> _taskChannel;
    private bool _disposed;
    public TaskExecutor(int concurrencyLimit);
    public TaskExecutor(int prefetchCount, int concurrencyLimit);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<DisposeAsync>d__5")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Run>d__6")]
public Task Run(Action method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Run>d__7")]
public Task Run(Func`1<Task> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Push>d__8")]
public Task Push(Action method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Push>d__9")]
public Task Push(Func`1<Task> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Run>d__10`1")]
public Task`1<T> Run(Func`1<T> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<Run>d__11`1")]
public Task`1<T> Run(Func`1<Task`1<T>> method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<MultipleReader>d__12")]
private Task MultipleReader();
    [AsyncStateMachineAttribute("MassTransit.Util.TaskExecutor/<SingleReader>d__13")]
private Task SingleReader();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__3_0();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__3_1(int _);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__3_2();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__4_1(int _);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__4_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MassTransit.Util.TaskUtil : object {
    internal static Task Canceled { get; }
    public static Task Completed { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<bool> True { get; }
    internal static Task get_Canceled();
    public static Task get_Completed();
    public static Task`1<bool> get_False();
    public static Task`1<bool> get_True();
    [NullableContextAttribute("2")]
public static Task`1<T> Default();
    public static Task`1<T> Faulted(Exception exception);
    public static Task`1<T> Cancelled();
    public static TaskCompletionSource`1<T> GetTask(TaskCreationOptions options);
    public static TaskCompletionSource`1<bool> GetTask(TaskCreationOptions options);
    [ExtensionAttribute]
public static CancellationTokenRegistration RegisterTask(CancellationToken cancellationToken, Task& cancelTask);
    [NullableContextAttribute("2")]
private static void SetCompleted(object obj);
    [ExtensionAttribute]
public static CancellationTokenRegistration RegisterIfCanBeCanceled(CancellationToken cancellationToken, CancellationTokenSource source);
    [NullableContextAttribute("2")]
private static void Cancel(object obj);
    [ExtensionAttribute]
public static void SetCompleted(TaskCompletionSource`1<bool> source);
    public static void Await(Func`1<Task> taskFactory, CancellationToken cancellationToken);
    public static void Await(Task task, CancellationToken cancellationToken);
    public static T Await(Func`1<Task`1<T>> taskFactory, CancellationToken cancellationToken);
    private static void ContinueOnSameSynchronizationContext(AwaitAdapter awaiter, Action continuation);
    [NullableContextAttribute("2")]
private static IDisposable InitializeExecutionEnvironment();
    [NullableContextAttribute("2")]
private static void SetSynchronizationContext(SynchronizationContext syncContext);
}
public class MassTransit.Util.TextTable : object {
    private static HashSet`1<Type> NumericTypes;
    private List`1<object> _columns;
    private List`1<Object[]> _rows;
    private Type[] _columnTypes;
    [CompilerGeneratedAttribute]
private TextTableOptions <Options>k__BackingField;
    public TextTableOptions Options { get; }
    public TextTable(String[] columns);
    public TextTable(TextTableOptions options);
    private static TextTable();
    [CompilerGeneratedAttribute]
public TextTableOptions get_Options();
    public TextTable AddColumns(String[] names);
    public TextTable AddColumns(IEnumerable`1<string> names);
    public TextTable AddRow(Object[] values);
    public TextTable Configure(Action`1<TextTableOptions> action);
    public static TextTable Create(IEnumerable`1<T> rows);
    public virtual string ToString();
    private string GetNumberAlignment(int column);
    private List`1<int> CalculateColumnWidths();
    public void Write();
    public TextTable SetColumn(int column, string name, Type columnType);
    public TextTable HideRowSeparator();
    public TextTable EnableCount(bool enabled);
    public TextTable SetRightNumberAlignment();
    public TextTable OutputTo(TextWriter textWriter);
    [CompilerGeneratedAttribute]
private int <CalculateColumnWidths>b__16_0(object t, int i);
}
public class MassTransit.Util.TextTableOptions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCount>k__BackingField;
    [CompilerGeneratedAttribute]
private NumberAlignment <NumberAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowRowSeparator>k__BackingField;
    public IEnumerable`1<string> Columns { get; public set; }
    public bool EnableCount { get; public set; }
    public NumberAlignment NumberAlignment { get; public set; }
    public TextWriter Out { get; public set; }
    public bool ShowRowSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_EnableCount();
    [CompilerGeneratedAttribute]
public void set_EnableCount(bool value);
    [CompilerGeneratedAttribute]
public NumberAlignment get_NumberAlignment();
    [CompilerGeneratedAttribute]
public void set_NumberAlignment(NumberAlignment value);
    [CompilerGeneratedAttribute]
public TextWriter get_Out();
    [CompilerGeneratedAttribute]
public void set_Out(TextWriter value);
    [CompilerGeneratedAttribute]
public bool get_ShowRowSeparator();
    [CompilerGeneratedAttribute]
public void set_ShowRowSeparator(bool value);
}
[FlagsAttribute]
public enum MassTransit.Util.TypeClassification : Enum {
    public short value__;
    public static TypeClassification All;
    public static TypeClassification Open;
    public static TypeClassification Closed;
    public static TypeClassification Interface;
    public static TypeClassification Abstract;
    public static TypeClassification Concrete;
}
public class MassTransit.Util.TypeSet : object {
    private IEnumerable`1<AssemblyScanTypeInfo> _allTypes;
    private Func`2<Type, bool> _filter;
    public IEnumerable`1<AssemblyScanRecord> Records { get; }
    public TypeSet(IEnumerable`1<AssemblyScanTypeInfo> allTypes, Func`2<Type, bool> filter);
    public IEnumerable`1<AssemblyScanRecord> get_Records();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
