public static class MathNet.Numerics.AppSwitches : object {
    private static string AppSwitchDisableNativeProviderProbing;
    private static string AppSwitchDisableNativeProviders;
    private static string AppSwitchDisableMklNativeProvider;
    private static string AppSwitchDisableCudaNativeProvider;
    private static string AppSwitchDisableOpenBlasNativeProvider;
    public static bool DisableNativeProviderProbing { get; public set; }
    public static bool DisableNativeProviders { get; public set; }
    public static bool DisableMklNativeProvider { get; public set; }
    public static bool DisableCudaNativeProvider { get; public set; }
    public static bool DisableOpenBlasNativeProvider { get; public set; }
    private static void SetSwitch(string switchName, bool isEnabled);
    private static bool IsEnabled(string switchName);
    public static bool get_DisableNativeProviderProbing();
    public static void set_DisableNativeProviderProbing(bool value);
    public static bool get_DisableNativeProviders();
    public static void set_DisableNativeProviders(bool value);
    public static bool get_DisableMklNativeProvider();
    public static void set_DisableMklNativeProvider(bool value);
    public static bool get_DisableCudaNativeProvider();
    public static void set_DisableCudaNativeProvider(bool value);
    public static bool get_DisableOpenBlasNativeProvider();
    public static void set_DisableOpenBlasNativeProvider(bool value);
}
[ExtensionAttribute]
internal static class MathNet.Numerics.ArrayExtensions : object {
    [ExtensionAttribute]
public static void Copy(Double[] source, Double[] dest);
    [ExtensionAttribute]
public static void Copy(Single[] source, Single[] dest);
    [ExtensionAttribute]
public static void Copy(Complex[] source, Complex[] dest);
    [ExtensionAttribute]
public static void Copy(Complex32[] source, Complex32[] dest);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Combinatorics : object {
    public static double Variations(int n, int k);
    public static double VariationsWithRepetition(int n, int k);
    public static double Combinations(int n, int k);
    public static double CombinationsWithRepetition(int n, int k);
    public static double Permutations(int n);
    public static Int32[] GeneratePermutation(int n, Random randomSource);
    public static void SelectPermutationInplace(T[] data, Random randomSource);
    [IteratorStateMachineAttribute("MathNet.Numerics.Combinatorics/<SelectPermutation>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectPermutation(IEnumerable`1<T> data, Random randomSource);
    public static Boolean[] GenerateCombination(int n, Random randomSource);
    public static Boolean[] GenerateCombination(int n, int k, Random randomSource);
    [IteratorStateMachineAttribute("MathNet.Numerics.Combinatorics/<SelectCombination>d__10`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectCombination(IEnumerable`1<T> data, int elementsToChoose, Random randomSource);
    public static Int32[] GenerateCombinationWithRepetition(int n, int k, Random randomSource);
    [IteratorStateMachineAttribute("MathNet.Numerics.Combinatorics/<SelectCombinationWithRepetition>d__12`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectCombinationWithRepetition(IEnumerable`1<T> data, int elementsToChoose, Random randomSource);
    public static Int32[] GenerateVariation(int n, int k, Random randomSource);
    public static BigInteger[] GenerateVariation(BigInteger n, int k, Random randomSource);
    [IteratorStateMachineAttribute("MathNet.Numerics.Combinatorics/<SelectVariation>d__15`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectVariation(IEnumerable`1<T> data, int elementsToChoose, Random randomSource);
    public static Int32[] GenerateVariationWithRepetition(int n, int k, Random randomSource);
    [IteratorStateMachineAttribute("MathNet.Numerics.Combinatorics/<SelectVariationWithRepetition>d__17`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectVariationWithRepetition(IEnumerable`1<T> data, int elementsToChoose, Random randomSource);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
public class MathNet.Numerics.Complex32 : ValueType {
    [DataMemberAttribute]
private float _real;
    [DataMemberAttribute]
private float _imag;
    public static Complex32 Zero;
    public static Complex32 One;
    public static Complex32 ImaginaryOne;
    public static Complex32 PositiveInfinity;
    public static Complex32 NaN;
    public float Real { get; }
    public float Imaginary { get; }
    public float Phase { get; }
    public float Magnitude { get; }
    public float MagnitudeSquared { get; }
    public Complex32 Sign { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public Complex32(float real, float imaginary);
    private static Complex32();
    public static Complex32 FromPolarCoordinates(float magnitude, float phase);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public float get_Real();
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public float get_Imaginary();
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public float get_Phase();
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public float get_Magnitude();
    public float get_MagnitudeSquared();
    public Complex32 get_Sign();
    public bool IsZero();
    public bool IsOne();
    public bool IsImaginaryOne();
    public bool IsNaN();
    public bool IsInfinity();
    public bool IsReal();
    public bool IsRealNonNegative();
    public Complex32 Exponential();
    public Complex32 NaturalLogarithm();
    public Complex32 CommonLogarithm();
    public Complex32 Logarithm(float baseValue);
    public Complex32 Power(Complex32 exponent);
    public Complex32 Root(Complex32 rootExponent);
    public Complex32 Square();
    public Complex32 SquareRoot();
    public ValueTuple`2<Complex32, Complex32> SquareRoots();
    public ValueTuple`3<Complex32, Complex32, Complex32> CubicRoots();
    public static bool op_Equality(Complex32 complex1, Complex32 complex2);
    public static bool op_Inequality(Complex32 complex1, Complex32 complex2);
    public static Complex32 op_UnaryPlus(Complex32 summand);
    public static Complex32 op_UnaryNegation(Complex32 subtrahend);
    public static Complex32 op_Addition(Complex32 summand1, Complex32 summand2);
    public static Complex32 op_Subtraction(Complex32 minuend, Complex32 subtrahend);
    public static Complex32 op_Addition(Complex32 summand1, float summand2);
    public static Complex32 op_Subtraction(Complex32 minuend, float subtrahend);
    public static Complex32 op_Addition(float summand1, Complex32 summand2);
    public static Complex32 op_Subtraction(float minuend, Complex32 subtrahend);
    public static Complex32 op_Multiply(Complex32 multiplicand, Complex32 multiplier);
    public static Complex32 op_Multiply(float multiplicand, Complex32 multiplier);
    public static Complex32 op_Multiply(Complex32 multiplicand, float multiplier);
    public static Complex32 op_Division(Complex32 dividend, Complex32 divisor);
    private static Complex32 InternalDiv(float a, float b, float c, float d, bool swapped);
    public static Complex32 op_Division(float dividend, Complex32 divisor);
    public static Complex32 op_Division(Complex32 dividend, float divisor);
    public Complex32 Conjugate();
    public Complex32 Reciprocal();
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool Equals(Complex32 other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Complex32 Parse(string value, IFormatProvider formatProvider);
    private static float ParsePart(LinkedListNode`1& token, Boolean& imaginary, IFormatProvider format);
    public static bool TryParse(string value, Complex32& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, Complex32& result);
    public static Complex32 op_Explicit(decimal value);
    public static Complex32 op_Explicit(Complex value);
    public static Complex32 op_Implicit(byte value);
    public static Complex32 op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static Complex32 op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static Complex32 op_Implicit(ushort value);
    public static Complex32 op_Implicit(int value);
    public static Complex32 op_Implicit(BigInteger value);
    public static Complex32 op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static Complex32 op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Complex32 op_Implicit(ulong value);
    public static Complex32 op_Implicit(float value);
    public static Complex32 op_Explicit(double value);
    public Complex ToComplex();
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Negate(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Conjugate(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Add(Complex32 left, Complex32 right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Subtract(Complex32 left, Complex32 right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Multiply(Complex32 left, Complex32 right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Divide(Complex32 dividend, Complex32 divisor);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Reciprocal(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Sqrt(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double Abs(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Exp(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Pow(Complex32 value, Complex32 power);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Pow(Complex32 value, float power);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Log(Complex32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Log(Complex32 value, float baseValue);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex32 Log10(Complex32 value);
    public static Complex32 Sin(Complex32 value);
    public static Complex32 Cos(Complex32 value);
    public static Complex32 Tan(Complex32 value);
    public static Complex32 Asin(Complex32 value);
    public static Complex32 Acos(Complex32 value);
    public static Complex32 Atan(Complex32 value);
    public static Complex32 Sinh(Complex32 value);
    public static Complex32 Cosh(Complex32 value);
    public static Complex32 Tanh(Complex32 value);
}
[ExtensionAttribute]
public static class MathNet.Numerics.ComplexExtensions : object {
    [ExtensionAttribute]
public static double MagnitudeSquared(Complex32 complex);
    [ExtensionAttribute]
public static double MagnitudeSquared(Complex complex);
    [ExtensionAttribute]
public static Complex Sign(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Conjugate(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Reciprocal(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Exp(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Ln(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Log10(Complex complex);
    [ExtensionAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Complex Log(Complex complex, double baseValue);
    [ExtensionAttribute]
public static Complex Power(Complex complex, Complex exponent);
    [ExtensionAttribute]
public static Complex Root(Complex complex, Complex rootExponent);
    [ExtensionAttribute]
public static Complex Square(Complex complex);
    [ExtensionAttribute]
public static Complex SquareRoot(Complex complex);
    [ExtensionAttribute]
public static ValueTuple`2<Complex, Complex> SquareRoots(Complex complex);
    [ExtensionAttribute]
public static ValueTuple`3<Complex, Complex, Complex> CubicRoots(Complex complex);
    [ExtensionAttribute]
public static bool IsZero(Complex complex);
    [ExtensionAttribute]
public static bool IsOne(Complex complex);
    [ExtensionAttribute]
public static bool IsImaginaryOne(Complex complex);
    [ExtensionAttribute]
public static bool IsNaN(Complex complex);
    [ExtensionAttribute]
public static bool IsInfinity(Complex complex);
    [ExtensionAttribute]
public static bool IsReal(Complex complex);
    [ExtensionAttribute]
public static bool IsRealNonNegative(Complex complex);
    [ExtensionAttribute]
public static double Norm(Complex complex);
    [ExtensionAttribute]
public static double Norm(Complex32 complex);
    [ExtensionAttribute]
public static double NormOfDifference(Complex complex, Complex otherValue);
    [ExtensionAttribute]
public static double NormOfDifference(Complex32 complex, Complex32 otherValue);
    [ExtensionAttribute]
public static Complex ToComplex(string value);
    [ExtensionAttribute]
public static Complex ToComplex(string value, IFormatProvider formatProvider);
    private static double ParsePart(LinkedListNode`1& token, Boolean& imaginary, IFormatProvider format);
    [ExtensionAttribute]
public static bool TryToComplex(string value, Complex& result);
    [ExtensionAttribute]
public static bool TryToComplex(string value, IFormatProvider formatProvider, Complex& result);
    [ExtensionAttribute]
public static Complex32 ToComplex32(string value);
    [ExtensionAttribute]
public static Complex32 ToComplex32(string value, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static bool TryToComplex32(string value, Complex32& result);
    [ExtensionAttribute]
public static bool TryToComplex32(string value, IFormatProvider formatProvider, Complex32& result);
}
public static class MathNet.Numerics.Constants : object {
    public static double E;
    public static double Log2E;
    public static double Log10E;
    public static double Ln2;
    public static double Ln10;
    public static double LnPi;
    public static double Ln2PiOver2;
    public static double InvE;
    public static double SqrtE;
    public static double Sqrt2;
    public static double Sqrt3;
    public static double Sqrt1Over2;
    public static double HalfSqrt3;
    public static double Pi;
    public static double Pi2;
    public static double PiOver2;
    public static double Pi3Over2;
    public static double PiOver4;
    public static double SqrtPi;
    public static double Sqrt2Pi;
    public static double SqrtPiOver2;
    public static double Sqrt2PiE;
    public static double LogSqrt2Pi;
    public static double LogSqrt2PiE;
    public static double LogTwoSqrtEOverPi;
    public static double InvPi;
    public static double TwoInvPi;
    public static double InvSqrtPi;
    public static double InvSqrt2Pi;
    public static double TwoInvSqrtPi;
    public static double TwoSqrtEOverPi;
    public static double Degree;
    public static double Grad;
    public static double PowerDecibel;
    public static double NeutralDecibel;
    public static double Catalan;
    public static double EulerMascheroni;
    public static double GoldenRatio;
    public static double Glaisher;
    public static double Khinchin;
    public static int SizeOfDouble;
    public static int SizeOfInt;
    public static int SizeOfFloat;
    public static int SizeOfComplex;
    public static int SizeOfComplex32;
    public static double SpeedOfLight;
    public static double MagneticPermeability;
    public static double ElectricPermittivity;
    public static double CharacteristicImpedanceVacuum;
    public static double GravitationalConstant;
    public static double PlancksConstant;
    public static double DiracsConstant;
    public static double PlancksMass;
    public static double PlancksTemperature;
    public static double PlancksLength;
    public static double PlancksTime;
    public static double ElementaryCharge;
    public static double MagneticFluxQuantum;
    public static double ConductanceQuantum;
    public static double JosephsonConstant;
    public static double VonKlitzingConstant;
    public static double BohrMagneton;
    public static double NuclearMagneton;
    public static double FineStructureConstant;
    public static double RydbergConstant;
    public static double BohrRadius;
    public static double HartreeEnergy;
    public static double QuantumOfCirculation;
    public static double FermiCouplingConstant;
    public static double WeakMixingAngle;
    public static double ElectronMass;
    public static double ElectronMassEnergyEquivalent;
    public static double ElectronMolarMass;
    public static double ComptonWavelength;
    public static double ClassicalElectronRadius;
    public static double ThomsonCrossSection;
    public static double ElectronMagneticMoment;
    public static double ElectronGFactor;
    public static double MuonMass;
    public static double MuonMassEnegryEquivalent;
    public static double MuonMolarMass;
    public static double MuonComptonWavelength;
    public static double MuonMagneticMoment;
    public static double MuonGFactor;
    public static double TauMass;
    public static double TauMassEnergyEquivalent;
    public static double TauMolarMass;
    public static double TauComptonWavelength;
    public static double ProtonMass;
    public static double ProtonMassEnergyEquivalent;
    public static double ProtonMolarMass;
    public static double ProtonComptonWavelength;
    public static double ProtonMagneticMoment;
    public static double ProtonGFactor;
    public static double ShieldedProtonMagneticMoment;
    public static double ProtonGyromagneticRatio;
    public static double ShieldedProtonGyromagneticRatio;
    public static double NeutronMass;
    public static double NeutronMassEnegryEquivalent;
    public static double NeutronMolarMass;
    public static double NeutronComptonWavelength;
    public static double NeutronMagneticMoment;
    public static double NeutronGFactor;
    public static double NeutronGyromagneticRatio;
    public static double DeuteronMass;
    public static double DeuteronMassEnegryEquivalent;
    public static double DeuteronMolarMass;
    public static double DeuteronMagneticMoment;
    public static double HelionMass;
    public static double HelionMassEnegryEquivalent;
    public static double HelionMolarMass;
    public static double Avogadro;
    public static double Yotta;
    public static double Zetta;
    public static double Exa;
    public static double Peta;
    public static double Tera;
    public static double Giga;
    public static double Mega;
    public static double Kilo;
    public static double Hecto;
    public static double Deca;
    public static double Deci;
    public static double Centi;
    public static double Milli;
    public static double Micro;
    public static double Nano;
    public static double Pico;
    public static double Femto;
    public static double Atto;
    public static double Zepto;
    public static double Yocto;
}
public static class MathNet.Numerics.ContourIntegrate : object {
    public static Complex DoubleExponential(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, double targetAbsoluteError);
    public static Complex GaussLegendre(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, int order);
    public static Complex GaussKronrod(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, double targetRelativeError, int maximumDepth, int order);
    public static Complex GaussKronrod(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, Double& error, Double& L1Norm, double targetRelativeError, int maximumDepth, int order);
}
public static class MathNet.Numerics.Control : object {
    private static int _maxDegreeOfParallelism;
    private static int _parallelizeOrder;
    private static int _parallelizeElements;
    private static string _nativeProviderHintPath;
    [CompilerGeneratedAttribute]
private static bool <CheckDistributionParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <ThreadSafeRandomNumberGenerators>k__BackingField;
    [CompilerGeneratedAttribute]
private static TaskScheduler <TaskScheduler>k__BackingField;
    public static bool CheckDistributionParameters { get; public set; }
    public static bool ThreadSafeRandomNumberGenerators { get; public set; }
    public static string NativeProviderPath { get; public set; }
    public static int MaxDegreeOfParallelism { get; public set; }
    public static TaskScheduler TaskScheduler { get; public set; }
    internal static int ParallelizeOrder { get; internal set; }
    internal static int ParallelizeElements { get; internal set; }
    private static Control();
    public static void ConfigureAuto();
    public static void UseManaged();
    public static void UseDefaultProviders();
    public static void UseBestProviders();
    public static void UseNativeMKL();
    public static bool TryUseNativeMKL();
    public static void UseNativeCUDA();
    public static bool TryUseNativeCUDA();
    public static void UseNativeOpenBLAS();
    public static bool TryUseNativeOpenBLAS();
    public static bool TryUseNative();
    public static void FreeResources();
    public static void UseSingleThread();
    public static void UseMultiThreading();
    [CompilerGeneratedAttribute]
public static bool get_CheckDistributionParameters();
    [CompilerGeneratedAttribute]
public static void set_CheckDistributionParameters(bool value);
    [CompilerGeneratedAttribute]
public static bool get_ThreadSafeRandomNumberGenerators();
    [CompilerGeneratedAttribute]
public static void set_ThreadSafeRandomNumberGenerators(bool value);
    public static string get_NativeProviderPath();
    public static void set_NativeProviderPath(string value);
    public static int get_MaxDegreeOfParallelism();
    public static void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public static TaskScheduler get_TaskScheduler();
    [CompilerGeneratedAttribute]
public static void set_TaskScheduler(TaskScheduler value);
    internal static int get_ParallelizeOrder();
    internal static void set_ParallelizeOrder(int value);
    internal static int get_ParallelizeElements();
    internal static void set_ParallelizeElements(int value);
    public static string Describe();
}
public static class MathNet.Numerics.Differentiate : object {
    public static NumericalDerivative Points(int points, int center);
    public static NumericalDerivative Order(int order);
    public static double Derivative(Func`2<double, double> f, double x, int order);
    public static Func`2<double, double> DerivativeFunc(Func`2<double, double> f, int order);
    public static double FirstDerivative(Func`2<double, double> f, double x);
    public static Func`2<double, double> FirstDerivativeFunc(Func`2<double, double> f);
    public static double SecondDerivative(Func`2<double, double> f, double x);
    public static Func`2<double, double> SecondDerivativeFunc(Func`2<double, double> f);
    public static double PartialDerivative(Func`2<Double[], double> f, Double[] x, int parameterIndex, int order);
    public static Func`2<Double[], double> PartialDerivativeFunc(Func`2<Double[], double> f, int parameterIndex, int order);
    public static double FirstPartialDerivative(Func`2<Double[], double> f, Double[] x, int parameterIndex);
    public static Func`2<Double[], double> FirstPartialDerivativeFunc(Func`2<Double[], double> f, int parameterIndex);
    public static double PartialDerivative2(Func`3<double, double, double> f, double x, double y, int parameterIndex, int order);
    public static Func`3<double, double, double> PartialDerivative2Func(Func`3<double, double, double> f, int parameterIndex, int order);
    public static double FirstPartialDerivative2(Func`3<double, double, double> f, double x, double y, int parameterIndex);
    public static Func`3<double, double, double> FirstPartialDerivative2Func(Func`3<double, double, double> f, int parameterIndex);
}
public class MathNet.Numerics.Differentiation.FiniteDifferenceCoefficients : object {
    private Double[0...,0...][] _coefficients;
    private int _points;
    public int Points { get; public set; }
    public FiniteDifferenceCoefficients(int points);
    public int get_Points();
    public void set_Points(int value);
    public Double[] GetCoefficients(int center, int order);
    public Double[0...,0...] GetCoefficientsForAllOrders(int center);
    private void CalculateCoefficients(int points);
}
public class MathNet.Numerics.Differentiation.NumericalDerivative : object {
    private int _points;
    private int _center;
    private double _stepSize;
    private double _epsilon;
    private double _baseStepSize;
    private FiniteDifferenceCoefficients _coefficients;
    [CompilerGeneratedAttribute]
private int <Evaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private StepType <StepType>k__BackingField;
    public double StepSize { get; public set; }
    public double BaseStepSize { get; public set; }
    public double Epsilon { get; public set; }
    public int Center { get; public set; }
    public int Evaluations { get; private set; }
    public StepType StepType { get; public set; }
    public NumericalDerivative(int points, int center);
    public double get_StepSize();
    public void set_StepSize(double value);
    public double get_BaseStepSize();
    public void set_BaseStepSize(double value);
    public double get_Epsilon();
    public void set_Epsilon(double value);
    public int get_Center();
    public void set_Center(int value);
    [CompilerGeneratedAttribute]
public int get_Evaluations();
    [CompilerGeneratedAttribute]
private void set_Evaluations(int value);
    [CompilerGeneratedAttribute]
public StepType get_StepType();
    [CompilerGeneratedAttribute]
public void set_StepType(StepType value);
    public double EvaluateDerivative(Double[] points, int order, double stepSize);
    public double EvaluateDerivative(Func`2<double, double> f, double x, int order, Nullable`1<double> currentValue);
    public Func`2<double, double> CreateDerivativeFunctionHandle(Func`2<double, double> f, int order);
    public double EvaluatePartialDerivative(Func`2<Double[], double> f, Double[] x, int parameterIndex, int order, Nullable`1<double> currentValue);
    public Double[] EvaluatePartialDerivative(Func`2[] f, Double[] x, int parameterIndex, int order, Nullable`1[] currentValue);
    public Func`2<Double[], double> CreatePartialDerivativeFunctionHandle(Func`2<Double[], double> f, int parameterIndex, int order);
    public Func`2<Double[], Double[]> CreatePartialDerivativeFunctionHandle(Func`2[] f, int parameterIndex, int order);
    public double EvaluateMixedPartialDerivative(Func`2<Double[], double> f, Double[] x, Int32[] parameterIndex, int order, Nullable`1<double> currentValue);
    public Double[] EvaluateMixedPartialDerivative(Func`2[] f, Double[] x, Int32[] parameterIndex, int order, Nullable`1[] currentValue);
    public Func`2<Double[], double> CreateMixedPartialDerivativeFunctionHandle(Func`2<Double[], double> f, Int32[] parameterIndex, int order);
    public Func`2<Double[], Double[]> CreateMixedPartialDerivativeFunctionHandle(Func`2[] f, Int32[] parameterIndex, int order);
    public void ResetEvaluations();
    private double CalculateStepSize(int points, double x, double order);
}
public class MathNet.Numerics.Differentiation.NumericalHessian : object {
    private NumericalDerivative _df;
    public int FunctionEvaluations { get; }
    public NumericalHessian(int points, int center);
    public int get_FunctionEvaluations();
    public Double[] Evaluate(Func`2<double, double> f, double x);
    public Double[0...,0...] Evaluate(Func`2<Double[], double> f, Double[] x);
    public void ResetFunctionEvaluations();
}
public class MathNet.Numerics.Differentiation.NumericalJacobian : object {
    private NumericalDerivative _df;
    public int FunctionEvaluations { get; }
    public NumericalJacobian(int points, int center);
    public int get_FunctionEvaluations();
    public Double[] Evaluate(Func`2<double, double> f, double x);
    public Double[] Evaluate(Func`2<Double[], double> f, Double[] x);
    public Double[] Evaluate(Func`2<Double[], double> f, Double[] x, double currentValue);
    public Double[0...,0...] Evaluate(Func`2[] f, Double[] x);
    public Double[0...,0...] Evaluate(Func`2[] f, Double[] x, Double[] currentValues);
    public void ResetFunctionEvaluations();
}
public enum MathNet.Numerics.Differentiation.StepType : Enum {
    public int value__;
    public static StepType Absolute;
    public static StepType RelativeX;
    public static StepType Relative;
}
public static class MathNet.Numerics.DifferIntegrate : object {
    public static double DoubleExponential(Func`2<double, double> f, double x, double order, double x0, double targetAbsoluteError);
    public static double GaussLegendre(Func`2<double, double> f, double x, double order, double x0, int gaussLegendrePoints);
    public static double GaussKronrod(Func`2<double, double> f, double x, double order, double x0, double targetRelativeError, int gaussKronrodPoints);
}
public static class MathNet.Numerics.Distance : object {
    public static double SAD(Vector`1<T> a, Vector`1<T> b);
    public static double SAD(Double[] a, Double[] b);
    public static float SAD(Single[] a, Single[] b);
    public static double MAE(Vector`1<T> a, Vector`1<T> b);
    public static double MAE(Double[] a, Double[] b);
    public static float MAE(Single[] a, Single[] b);
    public static double SSD(Vector`1<T> a, Vector`1<T> b);
    public static double SSD(Double[] a, Double[] b);
    public static float SSD(Single[] a, Single[] b);
    public static double MSE(Vector`1<T> a, Vector`1<T> b);
    public static double MSE(Double[] a, Double[] b);
    public static float MSE(Single[] a, Single[] b);
    public static double Euclidean(Vector`1<T> a, Vector`1<T> b);
    public static double Euclidean(Double[] a, Double[] b);
    public static float Euclidean(Single[] a, Single[] b);
    public static double Manhattan(Vector`1<T> a, Vector`1<T> b);
    public static double Manhattan(Double[] a, Double[] b);
    public static float Manhattan(Single[] a, Single[] b);
    public static double Chebyshev(Vector`1<T> a, Vector`1<T> b);
    public static double Chebyshev(Double[] a, Double[] b);
    public static float Chebyshev(Single[] a, Single[] b);
    public static double Minkowski(double p, Vector`1<T> a, Vector`1<T> b);
    public static double Minkowski(double p, Double[] a, Double[] b);
    public static float Minkowski(double p, Single[] a, Single[] b);
    public static double Canberra(Double[] a, Double[] b);
    public static float Canberra(Single[] a, Single[] b);
    public static double Cosine(Double[] a, Double[] b);
    public static float Cosine(Single[] a, Single[] b);
    public static double Hamming(Double[] a, Double[] b);
    public static float Hamming(Single[] a, Single[] b);
    public static double Pearson(IEnumerable`1<double> a, IEnumerable`1<double> b);
    public static double Jaccard(Double[] a, Double[] b);
    public static double Jaccard(Single[] a, Single[] b);
}
public class MathNet.Numerics.Distributions.Bernoulli : object {
    private Random _random;
    private double _p;
    public double P { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Mode { get; }
    public Int32[] Modes { get; }
    public double Median { get; }
    public Bernoulli(double p);
    public Bernoulli(double p, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double p);
    public double get_P();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual int get_Mode();
    public Int32[] get_Modes();
    public sealed virtual double get_Median();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double p, int k);
    public static double PMFLn(double p, int k);
    public static double CDF(double p, double x);
    private static int SampleUnchecked(Random rnd, double p);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double p);
    private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double p);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Bernoulli/<Samples>d__42")]
public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double p);
    public static IEnumerable`1<int> Samples(Random rnd, double p);
    public static void Samples(Random rnd, Int32[] values, double p);
    public static int Sample(double p);
    public static IEnumerable`1<int> Samples(double p);
    public static void Samples(Int32[] values, double p);
}
public class MathNet.Numerics.Distributions.Beta : object {
    private Random _random;
    private double _shapeA;
    private double _shapeB;
    public double A { get; }
    public double B { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Beta(double a, double b);
    public Beta(double a, double b, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double a, double b);
    public double get_A();
    public double get_B();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    internal static double SampleUnchecked(Random rnd, double a, double b);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double a, double b);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Beta/<SamplesUnchecked>d__41")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double a, double b);
    public static double PDF(double a, double b, double x);
    public static double PDFLn(double a, double b, double x);
    public static double CDF(double a, double b, double x);
    public static double InvCDF(double a, double b, double p);
    public static double Sample(Random rnd, double a, double b);
    public static IEnumerable`1<double> Samples(Random rnd, double a, double b);
    public static void Samples(Random rnd, Double[] values, double a, double b);
    public static double Sample(double a, double b);
    public static IEnumerable`1<double> Samples(double a, double b);
    public static void Samples(Double[] values, double a, double b);
}
public class MathNet.Numerics.Distributions.BetaBinomial : object {
    private Random _random;
    private int _n;
    private double _a;
    private double _b;
    public int N { get; }
    public double A { get; }
    public double B { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    private double MathNet.Numerics.Distributions.IUnivariateDistribution.Entropy { get; }
    public double Skewness { get; }
    private int MathNet.Numerics.Distributions.IDiscreteDistribution.Mode { get; }
    private double MathNet.Numerics.Distributions.IUnivariateDistribution.Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public BetaBinomial(int n, double a, double b);
    public BetaBinomial(int n, double a, double b, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(int n, double a, double b);
    public static bool IsValidParameterSet(int n, double a, double b, int k);
    public int get_N();
    public double get_A();
    public double get_B();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    private sealed virtual override double MathNet.Numerics.Distributions.IUnivariateDistribution.get_Entropy();
    public sealed virtual double get_Skewness();
    private sealed virtual override int MathNet.Numerics.Distributions.IDiscreteDistribution.get_Mode();
    private sealed virtual override double MathNet.Numerics.Distributions.IUnivariateDistribution.get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(int n, double a, double b, int k);
    public static double PMFLn(int n, double a, double b, int k);
    public static double CDF(int n, double a, double b, int x);
    private static int SampleUnchecked(Random rnd, int n, double a, double b);
    private static void SamplesUnchecked(Random rnd, Int32[] values, int n, double a, double b);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.BetaBinomial/<SamplesUnchecked>d__44")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, int n, double a, double b);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public int Sample(Random rnd, int n, double a, double b);
    public void Samples(Random rnd, Int32[] values, int n, double a, double b);
    public IEnumerable`1<int> Samples(int n, double a, double b);
    public void Samples(Int32[] values, int n, double a, double b);
}
public class MathNet.Numerics.Distributions.BetaScaled : object {
    private Random _random;
    private double _shapeA;
    private double _shapeB;
    private double _location;
    private double _scale;
    public double A { get; }
    public double B { get; }
    public double Location { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public BetaScaled(double a, double b, double location, double scale);
    public BetaScaled(double a, double b, double location, double scale, Random randomSource);
    public static BetaScaled PERT(double min, double max, double likely, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double a, double b, double location, double scale);
    public double get_A();
    public double get_B();
    public double get_Location();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double a, double b, double location, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double a, double b, double location, double scale);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.BetaScaled/<SamplesUnchecked>d__48")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double a, double b, double location, double scale);
    public static double PDF(double a, double b, double location, double scale, double x);
    public static double PDFLn(double a, double b, double location, double scale, double x);
    public static double CDF(double a, double b, double location, double scale, double x);
    public static double InvCDF(double a, double b, double location, double scale, double p);
    public static double Sample(Random rnd, double a, double b, double location, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double a, double b, double location, double scale);
    public static void Samples(Random rnd, Double[] values, double a, double b, double location, double scale);
    public static double Sample(double a, double b, double location, double scale);
    public static IEnumerable`1<double> Samples(double a, double b, double location, double scale);
    public static void Samples(Double[] values, double a, double b, double location, double scale);
}
public class MathNet.Numerics.Distributions.Binomial : object {
    private Random _random;
    private double _p;
    private int _trials;
    public double P { get; }
    public int N { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Mode { get; }
    public Int32[] Modes { get; }
    public double Median { get; }
    public Binomial(double p, int n);
    public Binomial(double p, int n, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double p, int n);
    public double get_P();
    public int get_N();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual int get_Mode();
    public Int32[] get_Modes();
    public sealed virtual double get_Median();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double p, int n, int k);
    public static double PMFLn(double p, int n, int k);
    public static double CDF(double p, int n, double x);
    internal static int SampleUnchecked(Random rnd, double p, int n);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double p, int n);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Binomial/<SamplesUnchecked>d__42")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double p, int n);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double p, int n);
    public static IEnumerable`1<int> Samples(Random rnd, double p, int n);
    public static void Samples(Random rnd, Int32[] values, double p, int n);
    public static int Sample(double p, int n);
    public static IEnumerable`1<int> Samples(double p, int n);
    public static void Samples(Int32[] values, double p, int n);
}
public class MathNet.Numerics.Distributions.Burr : object {
    private Random _random;
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <C>k__BackingField;
    [CompilerGeneratedAttribute]
private double <K>k__BackingField;
    public double A { get; }
    public double C { get; }
    public double K { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Mode { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Median { get; }
    public Burr(double a, double c, double k, Random randomSource);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
public double get_C();
    [CompilerGeneratedAttribute]
public double get_K();
    public virtual string ToString();
    public static bool IsValidParameterSet(double a, double c, double k);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Median();
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    public static double Sample(Random rnd, double a, double c, double k);
    public static void Samples(Random rnd, Double[] values, double a, double c, double k);
    public static IEnumerable`1<double> Samples(Random rnd, double a, double c, double k);
    private static double SampleUnchecked(Random rnd, double a, double c, double k);
    private static void SamplesUnchecked(Random rnd, Double[] values, double a, double c, double k);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Burr/<SamplesUnchecked>d__42")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double a, double c, double k);
    public double GetMoment(double n);
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PDF(double a, double c, double k, double x);
    public static double PDFLn(double a, double c, double k, double x);
    public static double CDF(double a, double c, double k, double x);
    private static double DensityImpl(double a, double c, double k, double x);
    private static double DensityLnImpl(double a, double c, double k, double x);
    private static double CumulativeDistributionImpl(double a, double c, double k, double x);
}
public class MathNet.Numerics.Distributions.Categorical : object {
    private Random _random;
    private Double[] _pmfNormalized;
    private Double[] _cdfUnnormalized;
    public Double[] P { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Mode { get; }
    public double Median { get; }
    public Categorical(Double[] probabilityMass);
    public Categorical(Double[] probabilityMass, Random randomSource);
    public Categorical(Histogram histogram);
    public virtual string ToString();
    public static bool IsValidProbabilityMass(Double[] p);
    public static bool IsValidCumulativeDistribution(Double[] cdf);
    public Double[] get_P();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public int InverseCumulativeDistribution(double probability);
    public static double PMF(Double[] probabilityMass, int k);
    public static double PMFLn(Double[] probabilityMass, int k);
    public static double CDF(Double[] probabilityMass, double x);
    public static int InvCDF(Double[] probabilityMass, double probability);
    public static int InvCDFWithCumulativeDistribution(Double[] cdfUnnormalized, double probability);
    internal static Double[] ProbabilityMassToCumulativeDistribution(Double[] probabilityMass);
    internal static int SampleUnchecked(Random rnd, Double[] cdfUnnormalized);
    private static void SamplesUnchecked(Random rnd, Int32[] values, Double[] cdfUnnormalized);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Categorical/<SamplesUnchecked>d__44")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, Double[] cdfUnnormalized);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, Double[] probabilityMass);
    public static IEnumerable`1<int> Samples(Random rnd, Double[] probabilityMass);
    public static void Samples(Random rnd, Int32[] values, Double[] probabilityMass);
    public static int Sample(Double[] probabilityMass);
    public static IEnumerable`1<int> Samples(Double[] probabilityMass);
    public static void Samples(Int32[] values, Double[] probabilityMass);
    public static int SampleWithCumulativeDistribution(Random rnd, Double[] cdfUnnormalized);
    public static IEnumerable`1<int> SamplesWithCumulativeDistribution(Random rnd, Double[] cdfUnnormalized);
    public static void SamplesWithCumulativeDistribution(Random rnd, Int32[] values, Double[] cdfUnnormalized);
    public static int SampleWithCumulativeDistribution(Double[] cdfUnnormalized);
    public static IEnumerable`1<int> SamplesWithCumulativeDistribution(Double[] cdfUnnormalized);
    public static void SamplesWithCumulativeDistribution(Int32[] values, Double[] cdfUnnormalized);
}
public class MathNet.Numerics.Distributions.Cauchy : object {
    private Random _random;
    private double _location;
    private double _scale;
    public double Location { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Cauchy(double location, double scale);
    public Cauchy(double location, double scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double location, double scale);
    public double get_Location();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double location, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double location, double scale);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Cauchy/<SamplesUnchecked>d__42")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale);
    public static double PDF(double location, double scale, double x);
    public static double PDFLn(double location, double scale, double x);
    public static double CDF(double location, double scale, double x);
    public static double InvCDF(double location, double scale, double p);
    public static double Sample(Random rnd, double location, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double location, double scale);
    public static void Samples(Random rnd, Double[] values, double location, double scale);
    public static double Sample(double location, double scale);
    public static IEnumerable`1<double> Samples(double location, double scale);
    public static void Samples(Double[] values, double location, double scale);
}
public class MathNet.Numerics.Distributions.Chi : object {
    private Random _random;
    private double _freedom;
    public double DegreesOfFreedom { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Chi(double freedom);
    public Chi(double freedom, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double freedom);
    public double get_DegreesOfFreedom();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, int freedom);
    private static void SamplesUnchecked(Random rnd, Double[] values, int freedom);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Chi/<SamplesUnchecked>d__37")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, int freedom);
    public static double PDF(double freedom, double x);
    public static double PDFLn(double freedom, double x);
    public static double CDF(double freedom, double x);
    public static double Sample(Random rnd, int freedom);
    public static IEnumerable`1<double> Samples(Random rnd, int freedom);
    public static void Samples(Random rnd, Double[] values, int freedom);
    public static double Sample(int freedom);
    public static IEnumerable`1<double> Samples(int freedom);
    public static void Samples(Double[] values, int freedom);
}
public class MathNet.Numerics.Distributions.ChiSquared : object {
    private Random _random;
    private double _freedom;
    public double DegreesOfFreedom { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public ChiSquared(double freedom);
    public ChiSquared(double freedom, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double freedom);
    public double get_DegreesOfFreedom();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double freedom);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double freedom);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.ChiSquared/<SamplesUnchecked>d__38")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double freedom);
    public static double PDF(double freedom, double x);
    public static double PDFLn(double freedom, double x);
    public static double CDF(double freedom, double x);
    public static double InvCDF(double freedom, double p);
    public static double Sample(Random rnd, double freedom);
    public static IEnumerable`1<double> Samples(Random rnd, double freedom);
    public static void Samples(Random rnd, Double[] values, double freedom);
    public static double Sample(double freedom);
    public static IEnumerable`1<double> Samples(double freedom);
    public static void Samples(Double[] values, double freedom);
}
public class MathNet.Numerics.Distributions.ContinuousUniform : object {
    private Random _random;
    private double _lower;
    private double _upper;
    public double LowerBound { get; }
    public double UpperBound { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public ContinuousUniform(double lower, double upper);
    public ContinuousUniform(double lower, double upper, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double lower, double upper);
    public double get_LowerBound();
    public double get_UpperBound();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double lower, double upper);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.ContinuousUniform/<SamplesUnchecked>d__41")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double lower, double upper);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double lower, double upper);
    public static double PDF(double lower, double upper, double x);
    public static double PDFLn(double lower, double upper, double x);
    public static double CDF(double lower, double upper, double x);
    public static double InvCDF(double lower, double upper, double p);
    public static double Sample(Random rnd, double lower, double upper);
    public static IEnumerable`1<double> Samples(Random rnd, double lower, double upper);
    public static void Samples(Random rnd, Double[] values, double lower, double upper);
    public static double Sample(double lower, double upper);
    public static IEnumerable`1<double> Samples(double lower, double upper);
    public static void Samples(Double[] values, double lower, double upper);
}
public class MathNet.Numerics.Distributions.ConwayMaxwellPoisson : object {
    private Random _random;
    private double _lambda;
    private double _nu;
    private double _mean;
    private double _variance;
    private double _z;
    private static double Tolerance;
    public double Lambda { get; }
    public double Nu { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Mode { get; }
    public double Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    private double Z { get; }
    public ConwayMaxwellPoisson(double lambda, double nu);
    public ConwayMaxwellPoisson(double lambda, double nu, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double lambda, double nu);
    public double get_Lambda();
    public double get_Nu();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double lambda, double nu, int k);
    public static double PMFLn(double lambda, double nu, int k);
    public static double CDF(double lambda, double nu, double x);
    private double get_Z();
    private static double Normalization(double lambda, double nu);
    private static int SampleUnchecked(Random rnd, double lambda, double nu, double z);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double lambda, double nu, double z);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.ConwayMaxwellPoisson/<SamplesUnchecked>d__47")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double lambda, double nu, double z);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double lambda, double nu);
    public static IEnumerable`1<int> Samples(Random rnd, double lambda, double nu);
    public static void Samples(Random rnd, Int32[] values, double lambda, double nu);
    public static int Sample(double lambda, double nu);
    public static IEnumerable`1<int> Samples(double lambda, double nu);
    public static void Samples(Int32[] values, double lambda, double nu);
}
public class MathNet.Numerics.Distributions.Dirichlet : object {
    private Random _random;
    private Double[] _alpha;
    public Double[] Alpha { get; }
    public Random RandomSource { get; public set; }
    public int Dimension { get; }
    private double AlphaSum { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public double Entropy { get; }
    public Dirichlet(Double[] alpha);
    public Dirichlet(Double[] alpha, Random randomSource);
    public Dirichlet(double alpha, int k);
    public Dirichlet(double alpha, int k, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(Double[] alpha);
    public Double[] get_Alpha();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public int get_Dimension();
    private double get_AlphaSum();
    public Double[] get_Mean();
    public Double[] get_Variance();
    public double get_Entropy();
    public double Density(Double[] x);
    public double DensityLn(Double[] x);
    public Double[] Sample();
    public static Double[] Sample(Random rnd, Double[] alpha);
}
public class MathNet.Numerics.Distributions.DiscreteUniform : object {
    private Random _random;
    private int _lower;
    private int _upper;
    public int LowerBound { get; }
    public int UpperBound { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Mode { get; }
    public double Median { get; }
    public DiscreteUniform(int lower, int upper);
    public DiscreteUniform(int lower, int upper, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(int lower, int upper);
    public int get_LowerBound();
    public int get_UpperBound();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(int lower, int upper, int k);
    public static double PMFLn(int lower, int upper, int k);
    public static double CDF(int lower, int upper, double x);
    private static int SampleUnchecked(Random rnd, int lower, int upper);
    private static void SamplesUnchecked(Random rnd, Int32[] values, int lower, int upper);
    private static IEnumerable`1<int> SamplesUnchecked(Random rnd, int lower, int upper);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, int lower, int upper);
    public static IEnumerable`1<int> Samples(Random rnd, int lower, int upper);
    public static void Samples(Random rnd, Int32[] values, int lower, int upper);
    public static int Sample(int lower, int upper);
    public static IEnumerable`1<int> Samples(int lower, int upper);
    public static void Samples(Int32[] values, int lower, int upper);
}
public class MathNet.Numerics.Distributions.Erlang : object {
    private Random _random;
    private int _shape;
    private double _rate;
    public int Shape { get; }
    public double Rate { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Erlang(int shape, double rate);
    public Erlang(int shape, double rate, Random randomSource);
    public static Erlang WithShapeScale(int shape, double scale, Random randomSource);
    public static Erlang WithShapeRate(int shape, double rate, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(int shape, double rate);
    public int get_Shape();
    public double get_Rate();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Erlang/<Samples>d__41")]
public sealed virtual IEnumerable`1<double> Samples();
    public static double PDF(int shape, double rate, double x);
    public static double PDFLn(int shape, double rate, double x);
    public static double CDF(int shape, double rate, double x);
    public static double Sample(Random rnd, int shape, double rate);
    public static IEnumerable`1<double> Samples(Random rnd, int shape, double rate);
    public static void Samples(Random rnd, Double[] values, int shape, double rate);
    public static double Sample(int shape, double rate);
    public static IEnumerable`1<double> Samples(int shape, double rate);
    public static void Samples(Double[] values, int shape, double rate);
}
public class MathNet.Numerics.Distributions.Exponential : object {
    private Random _random;
    private double _rate;
    public double Rate { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Exponential(double rate);
    public Exponential(double rate, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double rate);
    public double get_Rate();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double rate);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double rate);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double rate);
    public static double PDF(double rate, double x);
    public static double PDFLn(double rate, double x);
    public static double CDF(double rate, double x);
    public static double InvCDF(double rate, double p);
    public static double Sample(Random rnd, double rate);
    public static void Samples(Random rnd, Double[] values, double rate);
    public static IEnumerable`1<double> Samples(Random rnd, double rate);
    public static double Sample(double rate);
    public static void Samples(Double[] values, double rate);
    public static IEnumerable`1<double> Samples(double rate);
}
public class MathNet.Numerics.Distributions.FisherSnedecor : object {
    private Random _random;
    private double _freedom1;
    private double _freedom2;
    public double DegreesOfFreedom1 { get; }
    public double DegreesOfFreedom2 { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public FisherSnedecor(double d1, double d2);
    public FisherSnedecor(double d1, double d2, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double d1, double d2);
    public double get_DegreesOfFreedom1();
    public double get_DegreesOfFreedom2();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double d1, double d2);
    private static void SamplesUnchecked(Random rnd, Double[] values, double d1, double d2);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.FisherSnedecor/<SamplesUnchecked>d__41")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double d1, double d2);
    public static double PDF(double d1, double d2, double x);
    public static double PDFLn(double d1, double d2, double x);
    public static double CDF(double d1, double d2, double x);
    public static double InvCDF(double d1, double d2, double p);
    public static double Sample(Random rnd, double d1, double d2);
    public static IEnumerable`1<double> Samples(Random rnd, double d1, double d2);
    public static void Samples(Random rnd, Double[] values, double d1, double d2);
    public static double Sample(double d1, double d2);
    public static IEnumerable`1<double> Samples(double d1, double d2);
    public static void Samples(Double[] values, double d1, double d2);
}
public class MathNet.Numerics.Distributions.Gamma : object {
    private Random _random;
    private double _shape;
    private double _rate;
    public double Shape { get; }
    public double Rate { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Gamma(double shape, double rate);
    public Gamma(double shape, double rate, Random randomSource);
    public static Gamma WithShapeScale(double shape, double scale, Random randomSource);
    public static Gamma WithShapeRate(double shape, double rate, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double shape, double rate);
    public double get_Shape();
    public double get_Rate();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    internal static double SampleUnchecked(Random rnd, double shape, double rate);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double shape, double rate);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Gamma/<SamplesUnchecked>d__45")]
internal static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale);
    public static double PDF(double shape, double rate, double x);
    public static double PDFLn(double shape, double rate, double x);
    public static double CDF(double shape, double rate, double x);
    public static double InvCDF(double shape, double rate, double p);
    public static double Sample(Random rnd, double shape, double rate);
    public static IEnumerable`1<double> Samples(Random rnd, double shape, double rate);
    public static void Samples(Random rnd, Double[] values, double shape, double rate);
    public static double Sample(double shape, double rate);
    public static IEnumerable`1<double> Samples(double shape, double rate);
    public static void Samples(Double[] values, double shape, double rate);
}
public class MathNet.Numerics.Distributions.Geometric : object {
    private Random _random;
    private double _p;
    public double P { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Mode { get; }
    public double Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public Geometric(double p);
    public Geometric(double p, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double p);
    public double get_P();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double p, int k);
    public static double PMFLn(double p, int k);
    public static double CDF(double p, double x);
    private static int SampleUnchecked(Random rnd, double p);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double p);
    private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double p);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double p);
    public static IEnumerable`1<int> Samples(Random rnd, double p);
    public static void Samples(Random rnd, Int32[] values, double p);
    public static int Sample(double p);
    public static IEnumerable`1<int> Samples(double p);
    public static void Samples(Int32[] values, double p);
}
public class MathNet.Numerics.Distributions.Hypergeometric : object {
    private Random _random;
    private int _population;
    private int _success;
    private int _draws;
    public Random RandomSource { get; public set; }
    public int Population { get; }
    public int Draws { get; }
    public int Success { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Mode { get; }
    public double Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public Hypergeometric(int population, int success, int draws);
    public Hypergeometric(int population, int success, int draws, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(int population, int success, int draws);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public int get_Population();
    public int get_Draws();
    public int get_Success();
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(int population, int success, int draws, int k);
    public static double PMFLn(int population, int success, int draws, int k);
    public static double CDF(int population, int success, int draws, double x);
    private static int SampleUnchecked(Random rnd, int population, int success, int draws);
    private static void SamplesUnchecked(Random rnd, Int32[] values, int population, int success, int draws);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Hypergeometric/<SamplesUnchecked>d__43")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, int population, int success, int draws);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, int population, int success, int draws);
    public static IEnumerable`1<int> Samples(Random rnd, int population, int success, int draws);
    public static void Samples(Random rnd, Int32[] values, int population, int success, int draws);
    public static int Sample(int population, int success, int draws);
    public static IEnumerable`1<int> Samples(int population, int success, int draws);
    public static void Samples(Int32[] values, int population, int success, int draws);
}
public interface MathNet.Numerics.Distributions.IContinuousDistribution {
    public double Mode { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public abstract virtual double get_Mode();
    public abstract virtual double get_Minimum();
    public abstract virtual double get_Maximum();
    public abstract virtual double Density(double x);
    public abstract virtual double DensityLn(double x);
    public abstract virtual double Sample();
    public abstract virtual void Samples(Double[] values);
    public abstract virtual IEnumerable`1<double> Samples();
}
public interface MathNet.Numerics.Distributions.IDiscreteDistribution {
    public int Mode { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public abstract virtual int get_Mode();
    public abstract virtual int get_Minimum();
    public abstract virtual int get_Maximum();
    public abstract virtual double Probability(int k);
    public abstract virtual double ProbabilityLn(int k);
    public abstract virtual int Sample();
    public abstract virtual void Samples(Int32[] values);
    public abstract virtual IEnumerable`1<int> Samples();
}
public interface MathNet.Numerics.Distributions.IDistribution {
    public Random RandomSource { get; public set; }
    public abstract virtual Random get_RandomSource();
    public abstract virtual void set_RandomSource(Random value);
}
public class MathNet.Numerics.Distributions.InverseGamma : object {
    private Random _random;
    private double _shape;
    private double _scale;
    public double Shape { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public InverseGamma(double shape, double scale);
    public InverseGamma(double shape, double scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double shape, double scale);
    public double get_Shape();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double shape, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double shape, double scale);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double shape, double scale);
    public static double PDF(double shape, double scale, double x);
    public static double PDFLn(double shape, double scale, double x);
    public static double CDF(double shape, double scale, double x);
    public static double Sample(Random rnd, double shape, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double shape, double scale);
    public static void Samples(Random rnd, Double[] values, double shape, double scale);
    public static double Sample(double shape, double scale);
    public static IEnumerable`1<double> Samples(double shape, double scale);
    public static void Samples(Double[] values, double shape, double scale);
}
public class MathNet.Numerics.Distributions.InverseGaussian : object {
    private Random _random;
    [CompilerGeneratedAttribute]
private double <Mu>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Lambda>k__BackingField;
    public double Mu { get; }
    public double Lambda { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public InverseGaussian(double mu, double lambda, Random randomSource);
    [CompilerGeneratedAttribute]
public double get_Mu();
    [CompilerGeneratedAttribute]
public double get_Lambda();
    public virtual string ToString();
    public static bool IsValidParameterSet(double mu, double lambda);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Skewness();
    public double get_Kurtosis();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Entropy();
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    public static double Sample(Random rnd, double mu, double lambda);
    public static void Samples(Random rnd, Double[] values, double mu, double lambda);
    public static IEnumerable`1<double> Samples(Random rnd, double mu, double lambda);
    private static double SampleUnchecked(Random rnd, double mu, double lambda);
    private static void SamplesUnchecked(Random rnd, Double[] values, double mu, double lambda);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.InverseGaussian/<SamplesUnchecked>d__41")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double mu, double lambda);
    private static double InverseGaussianSampleImpl(double mu, double lambda, double normalSample, double uniformSample);
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InvCDF(double p);
    public static double PDF(double mu, double lambda, double x);
    public static double PDFLn(double mu, double lambda, double x);
    public static double CDF(double mu, double lambda, double x);
    public static double InvCDF(double mu, double lambda, double p);
    public static InverseGaussian Estimate(IEnumerable`1<double> samples, Random randomSource);
    private static double DensityImpl(double mu, double lambda, double x);
    private static double DensityLnImpl(double mu, double lambda, double x);
    private static double CumulativeDistributionImpl(double mu, double lambda, double x);
}
public class MathNet.Numerics.Distributions.InverseWishart : object {
    private Random _random;
    private double _freedom;
    private Matrix`1<double> _scale;
    private Cholesky`1<double> _chol;
    public double DegreesOfFreedom { get; }
    public Matrix`1<double> Scale { get; }
    public Random RandomSource { get; public set; }
    public Matrix`1<double> Mean { get; }
    public Matrix`1<double> Mode { get; }
    public Matrix`1<double> Variance { get; }
    public InverseWishart(double degreesOfFreedom, Matrix`1<double> scale);
    public InverseWishart(double degreesOfFreedom, Matrix`1<double> scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double degreesOfFreedom, Matrix`1<double> scale);
    public double get_DegreesOfFreedom();
    public Matrix`1<double> get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public Matrix`1<double> get_Mean();
    public Matrix`1<double> get_Mode();
    public Matrix`1<double> get_Variance();
    public double Density(Matrix`1<double> x);
    public Matrix`1<double> Sample();
    public static Matrix`1<double> Sample(Random rnd, double degreesOfFreedom, Matrix`1<double> scale);
    [CompilerGeneratedAttribute]
private double <get_Variance>b__20_0(int i, int j);
}
public interface MathNet.Numerics.Distributions.IUnivariateDistribution {
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Median { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_StdDev();
    public abstract virtual double get_Entropy();
    public abstract virtual double get_Skewness();
    public abstract virtual double get_Median();
    public abstract virtual double CumulativeDistribution(double x);
}
public class MathNet.Numerics.Distributions.Laplace : object {
    private Random _random;
    private double _location;
    private double _scale;
    public double Location { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Laplace(double location, double scale);
    public Laplace(double location, double scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double location, double scale);
    public double get_Location();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double location, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double location, double scale);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Laplace/<SamplesUnchecked>d__41")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale);
    public static double PDF(double location, double scale, double x);
    public static double PDFLn(double location, double scale, double x);
    public static double CDF(double location, double scale, double x);
    public static double Sample(Random rnd, double location, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double location, double scale);
    public static void Samples(Random rnd, Double[] values, double location, double scale);
    public static double Sample(double location, double scale);
    public static IEnumerable`1<double> Samples(double location, double scale);
    public static void Samples(Double[] values, double location, double scale);
}
public class MathNet.Numerics.Distributions.Logistic : object {
    private Random _random;
    private double _mean;
    private double _scale;
    public double Scale { get; }
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Precision { get; }
    public Random RandomSource { get; public set; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Logistic(Random randomSource);
    public Logistic(double mean, double scale);
    public Logistic(double mean, double scale, Random randomSource);
    public static Logistic WithMeanScale(double mean, double scale, Random randomSource);
    public static Logistic WithMeanStdDev(double mean, double stddev, Random randomSource);
    public static Logistic WithMeanVariance(double mean, double var, Random randomSource);
    public static Logistic WithMeanPrecision(double mean, double precision, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double mean, double scale);
    public double get_Scale();
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public double get_Precision();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double mean, double scale);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Logistic/<SamplesUnchecked>d__46")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double mean, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double mean, double scale);
    public static double PDF(double mean, double scale, double x);
    public static double PDFLn(double mean, double scale, double x);
    public static double CDF(double mean, double scale, double x);
    public static double InvCDF(double mean, double scale, double p);
    public static double Sample(Random rnd, double mean, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double mean, double scale);
    public static void Samples(Random rnd, Double[] values, double mean, double scale);
    public static double Sample(double mean, double scale);
    public static IEnumerable`1<double> Samples(double mean, double scale);
    public static void Samples(Double[] values, double mean, double scale);
}
public class MathNet.Numerics.Distributions.LogNormal : object {
    private Random _random;
    private double _mu;
    private double _sigma;
    public double Mu { get; }
    public double Sigma { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public LogNormal(double mu, double sigma);
    public LogNormal(double mu, double sigma, Random randomSource);
    public static LogNormal WithMuSigma(double mu, double sigma, Random randomSource);
    public static LogNormal WithMeanVariance(double mean, double var, Random randomSource);
    public static LogNormal Estimate(IEnumerable`1<double> samples, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double mu, double sigma);
    public double get_Mu();
    public double get_Sigma();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double mu, double sigma);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double mu, double sigma);
    private static void SamplesUnchecked(Random rnd, Double[] values, double mu, double sigma);
    public static double PDF(double mu, double sigma, double x);
    public static double PDFLn(double mu, double sigma, double x);
    public static double CDF(double mu, double sigma, double x);
    public static double InvCDF(double mu, double sigma, double p);
    public static double Sample(Random rnd, double mu, double sigma);
    public static IEnumerable`1<double> Samples(Random rnd, double mu, double sigma);
    public static void Samples(Random rnd, Double[] values, double mu, double sigma);
    public static double Sample(double mu, double sigma);
    public static IEnumerable`1<double> Samples(double mu, double sigma);
    public static void Samples(Double[] values, double mu, double sigma);
}
public class MathNet.Numerics.Distributions.MatrixNormal : object {
    private Random _random;
    private Matrix`1<double> _m;
    private Matrix`1<double> _v;
    private Matrix`1<double> _k;
    public Matrix`1<double> Mean { get; }
    public Matrix`1<double> RowCovariance { get; }
    public Matrix`1<double> ColumnCovariance { get; }
    public Random RandomSource { get; public set; }
    public MatrixNormal(Matrix`1<double> m, Matrix`1<double> v, Matrix`1<double> k);
    public MatrixNormal(Matrix`1<double> m, Matrix`1<double> v, Matrix`1<double> k, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(Matrix`1<double> m, Matrix`1<double> v, Matrix`1<double> k);
    public Matrix`1<double> get_Mean();
    public Matrix`1<double> get_RowCovariance();
    public Matrix`1<double> get_ColumnCovariance();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public double Density(Matrix`1<double> x);
    public Matrix`1<double> Sample();
    public static Matrix`1<double> Sample(Random rnd, Matrix`1<double> m, Matrix`1<double> v, Matrix`1<double> k);
    private static Vector`1<double> SampleVectorNormal(Random rnd, Vector`1<double> mean, Matrix`1<double> covariance);
}
public class MathNet.Numerics.Distributions.MeanPrecisionPair : ValueType {
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Precision>k__BackingField;
    public double Mean { get; public set; }
    public double Precision { get; public set; }
    public MeanPrecisionPair(double m, double p);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(double value);
}
public class MathNet.Numerics.Distributions.Multinomial : object {
    private Random _random;
    private Double[] _p;
    private int _trials;
    public Double[] P { get; }
    public int N { get; }
    public Random RandomSource { get; public set; }
    public Vector`1<double> Mean { get; }
    public Vector`1<double> Variance { get; }
    public Vector`1<double> Skewness { get; }
    public Multinomial(Double[] p, int n);
    public Multinomial(Double[] p, int n, Random randomSource);
    public Multinomial(Histogram h, int n);
    public virtual string ToString();
    public static bool IsValidParameterSet(IEnumerable`1<double> p, int n);
    public Double[] get_P();
    public int get_N();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public Vector`1<double> get_Mean();
    public Vector`1<double> get_Variance();
    public Vector`1<double> get_Skewness();
    public double Probability(Int32[] x);
    public double ProbabilityLn(Int32[] x);
    public Int32[] Sample();
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Multinomial/<Samples>d__24")]
public IEnumerable`1<Int32[]> Samples();
    public static Int32[] Sample(Random rnd, Double[] p, int n);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Multinomial/<Samples>d__26")]
public static IEnumerable`1<Int32[]> Samples(Random rnd, Double[] p, int n);
    [CompilerGeneratedAttribute]
private double <ProbabilityLn>b__22_0(int t, int i);
}
public class MathNet.Numerics.Distributions.NegativeBinomial : object {
    private Random _random;
    private double _r;
    private double _p;
    public double R { get; }
    public double P { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Mode { get; }
    public double Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public NegativeBinomial(double r, double p);
    public NegativeBinomial(double r, double p, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double r, double p);
    public double get_R();
    public double get_P();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double r, double p, int k);
    public static double PMFLn(double r, double p, int k);
    public static double CDF(double r, double p, double x);
    private static int SampleUnchecked(Random rnd, double r, double p);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double r, double p);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.NegativeBinomial/<SamplesUnchecked>d__40")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double r, double p);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double r, double p);
    public static IEnumerable`1<int> Samples(Random rnd, double r, double p);
    public static void Samples(Random rnd, Int32[] values, double r, double p);
    public static int Sample(double r, double p);
    public static IEnumerable`1<int> Samples(double r, double p);
    public static void Samples(Int32[] values, double r, double p);
}
public class MathNet.Numerics.Distributions.Normal : object {
    private Random _random;
    private double _mean;
    private double _stdDev;
    public double Mean { get; }
    public double StdDev { get; }
    public double Variance { get; }
    public double Precision { get; }
    public Random RandomSource { get; public set; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Normal(Random randomSource);
    public Normal(double mean, double stddev);
    public Normal(double mean, double stddev, Random randomSource);
    public static Normal WithMeanStdDev(double mean, double stddev, Random randomSource);
    public static Normal WithMeanVariance(double mean, double var, Random randomSource);
    public static Normal WithMeanPrecision(double mean, double precision, Random randomSource);
    public static Normal Estimate(IEnumerable`1<double> samples, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double mean, double stddev);
    public sealed virtual double get_Mean();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Variance();
    public double get_Precision();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    internal static double SampleUnchecked(Random rnd, double mean, double stddev);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Normal/<SamplesUnchecked>d__44")]
internal static IEnumerable`1<double> SamplesUnchecked(Random rnd, double mean, double stddev);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double mean, double stddev);
    private static bool PolarTransform(double a, double b, Double& x, Double& y);
    public static double PDF(double mean, double stddev, double x);
    public static double PDFLn(double mean, double stddev, double x);
    public static double CDF(double mean, double stddev, double x);
    public static double InvCDF(double mean, double stddev, double p);
    public static double Sample(Random rnd, double mean, double stddev);
    public static IEnumerable`1<double> Samples(Random rnd, double mean, double stddev);
    public static void Samples(Random rnd, Double[] values, double mean, double stddev);
    public static double Sample(double mean, double stddev);
    public static IEnumerable`1<double> Samples(double mean, double stddev);
    public static void Samples(Double[] values, double mean, double stddev);
}
public class MathNet.Numerics.Distributions.NormalGamma : object {
    private Random _random;
    private double _meanLocation;
    private double _meanScale;
    private double _precisionShape;
    private double _precisionInvScale;
    public double MeanLocation { get; }
    public double MeanScale { get; }
    public double PrecisionShape { get; }
    public double PrecisionInverseScale { get; }
    public Random RandomSource { get; public set; }
    public MeanPrecisionPair Mean { get; }
    public MeanPrecisionPair Variance { get; }
    public NormalGamma(double meanLocation, double meanScale, double precisionShape, double precisionInverseScale);
    public NormalGamma(double meanLocation, double meanScale, double precisionShape, double precisionInverseScale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double meanLocation, double meanScale, double precShape, double precInvScale);
    public double get_MeanLocation();
    public double get_MeanScale();
    public double get_PrecisionShape();
    public double get_PrecisionInverseScale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public StudentT MeanMarginal();
    public Gamma PrecisionMarginal();
    public MeanPrecisionPair get_Mean();
    public MeanPrecisionPair get_Variance();
    public double Density(MeanPrecisionPair mp);
    public double Density(double mean, double prec);
    public double DensityLn(MeanPrecisionPair mp);
    public double DensityLn(double mean, double prec);
    public MeanPrecisionPair Sample();
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.NormalGamma/<Samples>d__31")]
public IEnumerable`1<MeanPrecisionPair> Samples();
    public static MeanPrecisionPair Sample(Random rnd, double meanLocation, double meanScale, double precisionShape, double precisionInverseScale);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.NormalGamma/<Samples>d__33")]
public static IEnumerable`1<MeanPrecisionPair> Samples(Random rnd, double meanLocation, double meanScale, double precisionShape, double precisionInvScale);
}
public class MathNet.Numerics.Distributions.Pareto : object {
    private Random _random;
    private double _scale;
    private double _shape;
    public double Scale { get; }
    public double Shape { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Pareto(double scale, double shape);
    public Pareto(double scale, double shape, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double scale, double shape);
    public double get_Scale();
    public double get_Shape();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double scale, double shape);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double scale, double shape);
    private static void SamplesUnchecked(Random rnd, Double[] values, double scale, double shape);
    public static double PDF(double scale, double shape, double x);
    public static double PDFLn(double scale, double shape, double x);
    public static double CDF(double scale, double shape, double x);
    public static double InvCDF(double scale, double shape, double p);
    public static double Sample(Random rnd, double scale, double shape);
    public static IEnumerable`1<double> Samples(Random rnd, double scale, double shape);
    public static void Samples(Random rnd, Double[] values, double scale, double shape);
    public static double Sample(double scale, double shape);
    public static IEnumerable`1<double> Samples(double scale, double shape);
    public static void Samples(Double[] values, double scale, double shape);
}
public class MathNet.Numerics.Distributions.Poisson : object {
    private Random _random;
    private double _lambda;
    public double Lambda { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Mode { get; }
    public double Median { get; }
    public Poisson(double lambda);
    public Poisson(double lambda, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double lambda);
    public double get_Lambda();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double lambda, int k);
    public static double PMFLn(double lambda, int k);
    public static double CDF(double lambda, double x);
    private static int SampleUnchecked(Random rnd, double lambda);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double lambda);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Poisson/<SamplesUnchecked>d__37")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double lambda);
    private static int DoSampleShort(Random rnd, double lambda);
    private static int DoSampleLarge(Random rnd, double lambda);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double lambda);
    public static IEnumerable`1<int> Samples(Random rnd, double lambda);
    public static void Samples(Random rnd, Int32[] values, double lambda);
    public static int Sample(double lambda);
    public static IEnumerable`1<int> Samples(double lambda);
    public static void Samples(Int32[] values, double lambda);
}
public class MathNet.Numerics.Distributions.Rayleigh : object {
    private Random _random;
    private double _scale;
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Rayleigh(double scale);
    public Rayleigh(double scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double scale);
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double scale);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double scale);
    public static double PDF(double scale, double x);
    public static double PDFLn(double scale, double x);
    public static double CDF(double scale, double x);
    public static double InvCDF(double scale, double p);
    public static double Sample(Random rnd, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double scale);
    public static void Samples(Random rnd, Double[] values, double scale);
    public static double Sample(double scale);
    public static IEnumerable`1<double> Samples(double scale);
    public static void Samples(Double[] values, double scale);
}
public class MathNet.Numerics.Distributions.SkewedGeneralizedError : object {
    private Random _random;
    private double _skewness;
    [CompilerGeneratedAttribute]
private double <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Skew>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P>k__BackingField;
    public Random RandomSource { get; public set; }
    public double Location { get; }
    public double Scale { get; }
    public double Skew { get; }
    public double P { get; }
    public double Mode { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Median { get; }
    public SkewedGeneralizedError(double location, double scale, double skew, double p);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public virtual string ToString();
    public static bool IsValidParameterSet(double location, double scale, double skew, double p);
    [CompilerGeneratedAttribute]
public double get_Location();
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public double get_Skew();
    [CompilerGeneratedAttribute]
public double get_P();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Median();
    private double CalculateSkewness();
    private static double AdjustScale(double scale, double skew, double p);
    private static double AdjustX(double x, double scale, double skew, double p);
    private static double AdjustAddend(double scale, double skew, double p);
    public static double PDF(double location, double scale, double skew, double p, double x);
    public static double PDFLn(double location, double scale, double skew, double p, double x);
    public static double CDF(double location, double scale, double skew, double p, double x);
    public static double InvCDF(double location, double scale, double skew, double p, double pr);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double location, double scale, double skew, double p);
    private static void SamplesUnchecked(Random rnd, Double[] values, double location, double scale, double skew, double p);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.SkewedGeneralizedError/<SamplesUnchecked>d__56")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale, double skew, double p);
    public static double Sample(Random rnd, double location, double scale, double skew, double p);
    public static IEnumerable`1<double> Samples(Random rnd, double location, double scale, double skew, double p);
    public static void Samples(Random rnd, Double[] values, double location, double scale, double skew, double p);
    public static double Sample(double location, double scale, double skew, double p);
    public static IEnumerable`1<double> Samples(double location, double scale, double skew, double p);
    public static void Samples(Double[] values, double location, double scale, double skew, double p);
}
public class MathNet.Numerics.Distributions.SkewedGeneralizedT : object {
    private Random _random;
    private IContinuousDistribution _d;
    private double _skewness;
    [CompilerGeneratedAttribute]
private double <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Skew>k__BackingField;
    [CompilerGeneratedAttribute]
private double <P>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Q>k__BackingField;
    public Random RandomSource { get; public set; }
    public double Location { get; }
    public double Scale { get; }
    public double Skew { get; }
    public double P { get; }
    public double Q { get; }
    public double Mode { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Median { get; }
    public SkewedGeneralizedT(double location, double scale, double skew, double p, double q);
    public static IContinuousDistribution FindSpecializedDistribution(double location, double scale, double skew, double p, double q);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public virtual string ToString();
    public static bool IsValidParameterSet(double location, double scale, double skew, double p, double q);
    [CompilerGeneratedAttribute]
public double get_Location();
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public double get_Skew();
    [CompilerGeneratedAttribute]
public double get_P();
    [CompilerGeneratedAttribute]
public double get_Q();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Median();
    private double CalculateSkewness();
    private static double AdjustScale(double scale, double skew, double p, double q);
    private static double AdjustX(double x, double scale, double skew, double p, double q);
    private static double AdjustAddend(double scale, double skew, double p, double q);
    public static double PDF(double location, double scale, double skew, double p, double q, double x);
    public static double PDFLn(double location, double scale, double skew, double p, double q, double x);
    private static double PDFull(double location, double scale, double skew, double p, double q, double x);
    private static double PDFullLn(double location, double scale, double skew, double p, double q, double x);
    private static Func`2<double, double> PDFunc(double location, double scale, double skew, double p, double q, bool ln);
    public static double CDF(double location, double scale, double skew, double p, double q, double x);
    public static double InvCDF(double location, double scale, double skew, double p, double q, double pr);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double location, double scale, double skew, double p, double q);
    private static void SamplesUnchecked(Random rnd, Double[] values, double location, double scale, double skew, double p, double q);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.SkewedGeneralizedT/<SamplesUnchecked>d__64")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale, double skew, double p, double q);
    public static double Sample(Random rnd, double location, double scale, double skew, double p, double q);
    public static IEnumerable`1<double> Samples(Random rnd, double location, double scale, double skew, double p, double q);
    public static void Samples(Random rnd, Double[] values, double location, double scale, double skew, double p, double q);
    public static double Sample(double location, double scale, double skew, double p, double q);
    public static IEnumerable`1<double> Samples(double location, double scale, double skew, double p, double q);
    public static void Samples(Double[] values, double location, double scale, double skew, double p, double q);
}
public class MathNet.Numerics.Distributions.Stable : object {
    private Random _random;
    private double _alpha;
    private double _beta;
    private double _scale;
    private double _location;
    public double Alpha { get; }
    public double Beta { get; }
    public double Scale { get; }
    public double Location { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Stable(double alpha, double beta, double scale, double location);
    public Stable(double alpha, double beta, double scale, double location, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double alpha, double beta, double scale, double location);
    public double get_Alpha();
    public double get_Beta();
    public double get_Scale();
    public double get_Location();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    private static double SampleUnchecked(Random rnd, double alpha, double beta, double scale, double location);
    private static void SamplesUnchecked(Random rnd, Double[] values, double alpha, double beta, double scale, double location);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Stable/<SamplesUnchecked>d__43")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double alpha, double beta, double scale, double location);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    public static double PDF(double alpha, double beta, double scale, double location, double x);
    public static double PDFLn(double alpha, double beta, double scale, double location, double x);
    public static double CDF(double alpha, double beta, double scale, double location, double x);
    public static double Sample(Random rnd, double alpha, double beta, double scale, double location);
    public static IEnumerable`1<double> Samples(Random rnd, double alpha, double beta, double scale, double location);
    public static void Samples(Random rnd, Double[] values, double alpha, double beta, double scale, double location);
    public static double Sample(double alpha, double beta, double scale, double location);
    public static IEnumerable`1<double> Samples(double alpha, double beta, double scale, double location);
    public static void Samples(Double[] values, double alpha, double beta, double scale, double location);
}
public class MathNet.Numerics.Distributions.StudentT : object {
    private Random _random;
    private double _location;
    private double _scale;
    private double _freedom;
    public double Location { get; }
    public double Scale { get; }
    public double DegreesOfFreedom { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public StudentT(double location, double scale, double freedom);
    public StudentT(double location, double scale, double freedom, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double location, double scale, double freedom);
    public double get_Location();
    public double get_Scale();
    public double get_DegreesOfFreedom();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    private static double SampleUnchecked(Random rnd, double location, double scale, double freedom);
    private static void SamplesUnchecked(Random rnd, Double[] values, double location, double scale, double freedom);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.StudentT/<SamplesUnchecked>d__42")]
private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double location, double scale, double freedom);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    public static double PDF(double location, double scale, double freedom, double x);
    public static double PDFLn(double location, double scale, double freedom, double x);
    public static double CDF(double location, double scale, double freedom, double x);
    public static double InvCDF(double location, double scale, double freedom, double p);
    public static double Sample(Random rnd, double location, double scale, double freedom);
    public static IEnumerable`1<double> Samples(Random rnd, double location, double scale, double freedom);
    public static void Samples(Random rnd, Double[] values, double location, double scale, double freedom);
    public static double Sample(double location, double scale, double freedom);
    public static IEnumerable`1<double> Samples(double location, double scale, double freedom);
    public static void Samples(Double[] values, double location, double scale, double freedom);
}
public class MathNet.Numerics.Distributions.Triangular : object {
    private Random _random;
    private double _lower;
    private double _upper;
    private double _mode;
    public double LowerBound { get; }
    public double UpperBound { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Triangular(double lower, double upper, double mode);
    public Triangular(double lower, double upper, double mode, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double lower, double upper, double mode);
    public double get_LowerBound();
    public double get_UpperBound();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InverseCumulativeDistribution(double p);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double lower, double upper, double mode);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double lower, double upper, double mode);
    private static void SamplesUnchecked(Random rnd, Double[] values, double lower, double upper, double mode);
    public static double PDF(double lower, double upper, double mode, double x);
    public static double PDFLn(double lower, double upper, double mode, double x);
    public static double CDF(double lower, double upper, double mode, double x);
    public static double InvCDF(double lower, double upper, double mode, double p);
    public static double Sample(Random rnd, double lower, double upper, double mode);
    public static IEnumerable`1<double> Samples(Random rnd, double lower, double upper, double mode);
    public static void Samples(Random rnd, Double[] values, double lower, double upper, double mode);
    public static double Sample(double lower, double upper, double mode);
    public static IEnumerable`1<double> Samples(double lower, double upper, double mode);
    public static void Samples(Double[] values, double lower, double upper, double mode);
}
public class MathNet.Numerics.Distributions.TruncatedPareto : object {
    private Random _random;
    [CompilerGeneratedAttribute]
private double <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Truncation>k__BackingField;
    public Random RandomSource { get; public set; }
    public double Scale { get; }
    public double Shape { get; }
    public double Truncation { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Mode { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Median { get; }
    public TruncatedPareto(double scale, double shape, double truncation, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double scale, double shape, double truncation);
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public double get_Shape();
    [CompilerGeneratedAttribute]
public double get_Truncation();
    public double GetMoment(int n);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Median();
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    public static double Sample(Random rnd, double scale, double shape, double truncation);
    public static void Samples(Random rnd, Double[] values, double scale, double shape, double truncation);
    public static IEnumerable`1<double> Samples(Random rnd, double scale, double shape, double truncation);
    internal static double SampleUnchecked(Random rnd, double scale, double shape, double truncation);
    internal static void SamplesUnchecked(Random rnd, Double[] values, double scale, double shape, double truncation);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.TruncatedPareto/<SamplesUnchecked>d__43")]
internal static IEnumerable`1<double> SamplesUnchecked(Random rnd, double scale, double shape, double truncation);
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public double InvCDF(double p);
    public static double InvCDF(double scale, double shape, double truncation, double p);
    public static double PDF(double scale, double shape, double truncation, double x);
    public static double PDFLn(double scale, double shape, double truncation, double x);
    public static double CDF(double scale, double shape, double truncation, double x);
    private static double DensityImpl(double scale, double shape, double truncation, double x);
    private static double DensityLnImpl(double scale, double shape, double truncation, double x);
    private static double CumulativeDistributionImpl(double scale, double shape, double truncation, double x);
    private static double InvCDFUncheckedImpl(double scale, double shape, double truncation, double p);
}
public class MathNet.Numerics.Distributions.Weibull : object {
    private Random _random;
    private double _shape;
    private double _scale;
    private double _scalePowShapeInv;
    public double Shape { get; }
    public double Scale { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public Weibull(double shape, double scale);
    public Weibull(double shape, double scale, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double shape, double scale);
    public double get_Shape();
    public double get_Scale();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double Density(double x);
    public sealed virtual double DensityLn(double x);
    public sealed virtual double CumulativeDistribution(double x);
    public sealed virtual double Sample();
    public sealed virtual void Samples(Double[] values);
    public sealed virtual IEnumerable`1<double> Samples();
    private static double SampleUnchecked(Random rnd, double shape, double scale);
    private static IEnumerable`1<double> SamplesUnchecked(Random rnd, double shape, double scale);
    private static void SamplesUnchecked(Random rnd, Double[] values, double shape, double scale);
    public static double PDF(double shape, double scale, double x);
    public static double PDFLn(double shape, double scale, double x);
    public static double CDF(double shape, double scale, double x);
    public static Weibull Estimate(IEnumerable`1<double> samples, Random randomSource);
    public static double Sample(Random rnd, double shape, double scale);
    public static IEnumerable`1<double> Samples(Random rnd, double shape, double scale);
    public static void Samples(Random rnd, Double[] values, double shape, double scale);
    public static double Sample(double shape, double scale);
    public static IEnumerable`1<double> Samples(double shape, double scale);
    public static void Samples(Double[] values, double shape, double scale);
}
public class MathNet.Numerics.Distributions.Wishart : object {
    private Random _random;
    private double _degreesOfFreedom;
    private Matrix`1<double> _scale;
    private Cholesky`1<double> _chol;
    public double DegreesOfFreedom { get; }
    public Matrix`1<double> Scale { get; }
    public Random RandomSource { get; public set; }
    public Matrix`1<double> Mean { get; }
    public Matrix`1<double> Mode { get; }
    public Matrix`1<double> Variance { get; }
    public Wishart(double degreesOfFreedom, Matrix`1<double> scale);
    public Wishart(double degreesOfFreedom, Matrix`1<double> scale, Random randomSource);
    public static bool IsValidParameterSet(double degreesOfFreedom, Matrix`1<double> scale);
    public double get_DegreesOfFreedom();
    public Matrix`1<double> get_Scale();
    public virtual string ToString();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public Matrix`1<double> get_Mean();
    public Matrix`1<double> get_Mode();
    public Matrix`1<double> get_Variance();
    public double Density(Matrix`1<double> x);
    public Matrix`1<double> Sample();
    public static Matrix`1<double> Sample(Random rnd, double degreesOfFreedom, Matrix`1<double> scale);
    private static Matrix`1<double> DoSample(Random rnd, double degreesOfFreedom, Matrix`1<double> scale, Cholesky`1<double> chol);
    [CompilerGeneratedAttribute]
private double <get_Variance>b__20_0(int i, int j);
}
public class MathNet.Numerics.Distributions.Zipf : object {
    private Random _random;
    private double _s;
    private int _n;
    public double S { get; }
    public int N { get; }
    public Random RandomSource { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double StdDev { get; }
    public double Entropy { get; }
    public double Skewness { get; }
    public int Mode { get; }
    public double Median { get; }
    public int Minimum { get; }
    public int Maximum { get; }
    public Zipf(double s, int n);
    public Zipf(double s, int n, Random randomSource);
    public virtual string ToString();
    public static bool IsValidParameterSet(double s, int n);
    public double get_S();
    public int get_N();
    public sealed virtual Random get_RandomSource();
    public sealed virtual void set_RandomSource(Random value);
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StdDev();
    public sealed virtual double get_Entropy();
    public sealed virtual double get_Skewness();
    public sealed virtual int get_Mode();
    public sealed virtual double get_Median();
    public sealed virtual int get_Minimum();
    public sealed virtual int get_Maximum();
    public sealed virtual double Probability(int k);
    public sealed virtual double ProbabilityLn(int k);
    public sealed virtual double CumulativeDistribution(double x);
    public static double PMF(double s, int n, int k);
    public static double PMFLn(double s, int n, int k);
    public static double CDF(double s, int n, double x);
    private static int SampleUnchecked(Random rnd, double s, int n);
    private static void SamplesUnchecked(Random rnd, Int32[] values, double s, int n);
    [IteratorStateMachineAttribute("MathNet.Numerics.Distributions.Zipf/<SamplesUnchecked>d__40")]
private static IEnumerable`1<int> SamplesUnchecked(Random rnd, double s, int n);
    public sealed virtual int Sample();
    public sealed virtual void Samples(Int32[] values);
    public sealed virtual IEnumerable`1<int> Samples();
    public static int Sample(Random rnd, double s, int n);
    public static IEnumerable`1<int> Samples(Random rnd, double s, int n);
    public static void Samples(Random rnd, Int32[] values, double s, int n);
    public static int Sample(double s, int n);
    public static IEnumerable`1<int> Samples(double s, int n);
    public static void Samples(Int32[] values, double s, int n);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Euclid : object {
    private static Int32[] MultiplyDeBruijnBitPosition;
    private static Euclid();
    public static double Modulus(double dividend, double divisor);
    public static float Modulus(float dividend, float divisor);
    public static int Modulus(int dividend, int divisor);
    public static long Modulus(long dividend, long divisor);
    public static BigInteger Modulus(BigInteger dividend, BigInteger divisor);
    public static double Remainder(double dividend, double divisor);
    public static float Remainder(float dividend, float divisor);
    public static int Remainder(int dividend, int divisor);
    public static long Remainder(long dividend, long divisor);
    public static BigInteger Remainder(BigInteger dividend, BigInteger divisor);
    [ExtensionAttribute]
public static bool IsEven(int number);
    [ExtensionAttribute]
public static bool IsEven(long number);
    [ExtensionAttribute]
public static bool IsOdd(int number);
    [ExtensionAttribute]
public static bool IsOdd(long number);
    [ExtensionAttribute]
public static bool IsPowerOfTwo(int number);
    [ExtensionAttribute]
public static bool IsPowerOfTwo(long number);
    [ExtensionAttribute]
public static bool IsPerfectSquare(int number);
    [ExtensionAttribute]
public static bool IsPerfectSquare(long number);
    [ExtensionAttribute]
public static int PowerOfTwo(int exponent);
    [ExtensionAttribute]
public static long PowerOfTwo(long exponent);
    [ExtensionAttribute]
public static int Log2(int number);
    [ExtensionAttribute]
public static int CeilingToPowerOfTwo(int number);
    [ExtensionAttribute]
public static long CeilingToPowerOfTwo(long number);
    public static long GreatestCommonDivisor(long a, long b);
    public static long GreatestCommonDivisor(IList`1<long> integers);
    public static long GreatestCommonDivisor(Int64[] integers);
    public static long ExtendedGreatestCommonDivisor(long a, long b, Int64& x, Int64& y);
    public static long LeastCommonMultiple(long a, long b);
    public static long LeastCommonMultiple(IList`1<long> integers);
    public static long LeastCommonMultiple(Int64[] integers);
    public static BigInteger GreatestCommonDivisor(BigInteger a, BigInteger b);
    public static BigInteger GreatestCommonDivisor(IList`1<BigInteger> integers);
    public static BigInteger GreatestCommonDivisor(BigInteger[] integers);
    public static BigInteger ExtendedGreatestCommonDivisor(BigInteger a, BigInteger b, BigInteger& x, BigInteger& y);
    public static BigInteger LeastCommonMultiple(BigInteger a, BigInteger b);
    public static BigInteger LeastCommonMultiple(IList`1<BigInteger> integers);
    public static BigInteger LeastCommonMultiple(BigInteger[] integers);
}
internal static class MathNet.Numerics.Evaluate : object {
    internal static double ChebyshevA(Double[] coefficients, double x);
    internal static double ChebyshevSum(int n, Double[] coefficients, double x);
}
public static class MathNet.Numerics.ExcelFunctions : object {
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double NormSDist(double z);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double NormSInv(double probability);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double NormDist(double x, double mean, double standardDev, bool cumulative);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double NormInv(double probability, double mean, double standardDev);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double TDist(double x, int degreesFreedom, int tails);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double TInv(double probability, int degreesFreedom);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double FDist(double x, int degreesFreedom1, int degreesFreedom2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double FInv(double probability, int degreesFreedom1, int degreesFreedom2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double BetaDist(double x, double alpha, double beta);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double BetaInv(double probability, double alpha, double beta);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double GammaDist(double x, double alpha, double beta, bool cumulative);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double GammaInv(double probability, double alpha, double beta);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double Quartile(Double[] array, int quant);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double Percentile(Double[] array, double k);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static double PercentRank(Double[] array, double x);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Financial.AbsoluteReturnMeasures : object {
    [ExtensionAttribute]
public static double CompoundReturn(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double GainMean(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double LossMean(IEnumerable`1<double> data);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Financial.AbsoluteRiskMeasures : object {
    [ExtensionAttribute]
public static double GainStandardDeviation(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double LossStandardDeviation(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double DownsideDeviation(IEnumerable`1<double> data, double minimalAcceptableReturn);
    [ExtensionAttribute]
public static double SemiDeviation(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double GainLossRatio(IEnumerable`1<double> data);
}
public static class MathNet.Numerics.FindMinimum : object {
    public static double OfScalarFunctionConstrained(Func`2<double, double> function, double lowerBound, double upperBound, double tolerance, int maxIterations);
    public static double OfScalarFunction(Func`2<double, double> function, double initialGuess, double tolerance, int maxIterations);
    public static ValueTuple`2<double, double> OfFunction(Func`3<double, double, double> function, double initialGuess0, double initialGuess1, double tolerance, int maxIterations);
    public static ValueTuple`3<double, double, double> OfFunction(Func`4<double, double, double, double> function, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance, int maxIterations);
    public static ValueTuple`4<double, double, double, double> OfFunction(Func`5<double, double, double, double, double> function, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double tolerance, int maxIterations);
    public static ValueTuple`5<double, double, double, double, double> OfFunction(Func`6<double, double, double, double, double, double> function, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double initialGuess4, double tolerance, int maxIterations);
    public static Vector`1<double> OfFunction(Func`2<Vector`1<double>, double> function, Vector`1<double> initialGuess, double tolerance, int maxIterations);
    public static Vector`1<double> OfFunctionConstrained(Func`2<Vector`1<double>, double> function, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> initialGuess, double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradient(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient, Vector`1<double> initialGuess, double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradient(Func`2<Vector`1<double>, ValueTuple`2<double, Vector`1<double>>> functionGradient, Vector`1<double> initialGuess, double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradientConstrained(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> initialGuess, double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradientConstrained(Func`2<Vector`1<double>, ValueTuple`2<double, Vector`1<double>>> functionGradient, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> initialGuess, double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradientHessian(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient, Func`2<Vector`1<double>, Matrix`1<double>> hessian, Vector`1<double> initialGuess, double gradientTolerance, int maxIterations);
    public static Vector`1<double> OfFunctionGradientHessian(Func`2<Vector`1<double>, ValueTuple`3<double, Vector`1<double>, Matrix`1<double>>> functionGradientHessian, Vector`1<double> initialGuess, double gradientTolerance, int maxIterations);
}
public static class MathNet.Numerics.FindRoots : object {
    public static double OfFunction(Func`2<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static double OfFunctionDerivative(Func`2<double, double> f, Func`2<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static ValueTuple`2<Complex, Complex> Quadratic(double c, double b, double a);
    public static ValueTuple`3<Complex, Complex, Complex> Cubic(double d, double c, double b, double a);
    public static Complex[] Polynomial(Double[] coefficients);
    public static Complex[] Polynomial(Polynomial polynomial);
    public static Double[] ChebychevPolynomialFirstKind(int degree, double intervalBegin, double intervalEnd);
    public static Double[] ChebychevPolynomialSecondKind(int degree, double intervalBegin, double intervalEnd);
}
public static class MathNet.Numerics.Fit : object {
    public static ValueTuple`2<double, double> Line(Double[] x, Double[] y);
    public static Func`2<double, double> LineFunc(Double[] x, Double[] y);
    public static double LineThroughOrigin(Double[] x, Double[] y);
    public static Func`2<double, double> LineThroughOriginFunc(Double[] x, Double[] y);
    public static ValueTuple`2<double, double> Exponential(Double[] x, Double[] y, DirectRegressionMethod method);
    public static Func`2<double, double> ExponentialFunc(Double[] x, Double[] y, DirectRegressionMethod method);
    public static ValueTuple`2<double, double> Logarithm(Double[] x, Double[] y, DirectRegressionMethod method);
    public static Func`2<double, double> LogarithmFunc(Double[] x, Double[] y, DirectRegressionMethod method);
    public static ValueTuple`2<double, double> Power(Double[] x, Double[] y, DirectRegressionMethod method);
    public static Func`2<double, double> PowerFunc(Double[] x, Double[] y, DirectRegressionMethod method);
    public static Double[] Polynomial(Double[] x, Double[] y, int order, DirectRegressionMethod method);
    public static Func`2<double, double> PolynomialFunc(Double[] x, Double[] y, int order, DirectRegressionMethod method);
    public static Double[] PolynomialWeighted(Double[] x, Double[] y, Double[] w, int order);
    public static Double[] LinearCombination(Double[] x, Double[] y, Func`2[] functions);
    public static Func`2<double, double> LinearCombinationFunc(Double[] x, Double[] y, Func`2[] functions);
    public static Double[] LinearCombination(Double[] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static Func`2<double, double> LinearCombinationFunc(Double[] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static Double[] MultiDim(Double[][] x, Double[] y, bool intercept, DirectRegressionMethod method);
    public static Func`2<Double[], double> MultiDimFunc(Double[][] x, Double[] y, bool intercept, DirectRegressionMethod method);
    public static Double[] MultiDimWeighted(Double[][] x, Double[] y, Double[] w);
    public static Double[] LinearMultiDim(Double[][] x, Double[] y, Func`2[] functions);
    public static Func`2<Double[], double> LinearMultiDimFunc(Double[][] x, Double[] y, Func`2[] functions);
    public static Double[] LinearMultiDim(Double[][] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static Func`2<Double[], double> LinearMultiDimFunc(Double[][] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static Double[] LinearGeneric(T[] x, Double[] y, Func`2[] functions);
    public static Func`2<T, double> LinearGenericFunc(T[] x, Double[] y, Func`2[] functions);
    public static Double[] LinearGeneric(T[] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static Func`2<T, double> LinearGenericFunc(T[] x, Double[] y, DirectRegressionMethod method, Func`2[] functions);
    public static double Curve(Double[] x, Double[] y, Func`3<double, double, double> f, double initialGuess, double tolerance, int maxIterations);
    public static ValueTuple`2<double, double> Curve(Double[] x, Double[] y, Func`4<double, double, double, double> f, double initialGuess0, double initialGuess1, double tolerance, int maxIterations);
    public static ValueTuple`3<double, double, double> Curve(Double[] x, Double[] y, Func`5<double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance, int maxIterations);
    public static ValueTuple`4<double, double, double, double> Curve(Double[] x, Double[] y, Func`6<double, double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double tolerance, int maxIterations);
    public static ValueTuple`5<double, double, double, double, double> Curve(Double[] x, Double[] y, Func`7<double, double, double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double initialGuess4, double tolerance, int maxIterations);
    public static Func`2<double, double> CurveFunc(Double[] x, Double[] y, Func`3<double, double, double> f, double initialGuess, double tolerance, int maxIterations);
    public static Func`2<double, double> CurveFunc(Double[] x, Double[] y, Func`4<double, double, double, double> f, double initialGuess0, double initialGuess1, double tolerance, int maxIterations);
    public static Func`2<double, double> CurveFunc(Double[] x, Double[] y, Func`5<double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double tolerance, int maxIterations);
    public static Func`2<double, double> CurveFunc(Double[] x, Double[] y, Func`6<double, double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double tolerance, int maxIterations);
    public static Func`2<double, double> CurveFunc(Double[] x, Double[] y, Func`7<double, double, double, double, double, double, double> f, double initialGuess0, double initialGuess1, double initialGuess2, double initialGuess3, double initialGuess4, double tolerance, int maxIterations);
}
public static class MathNet.Numerics.Generate : object {
    public static T[] Map(TA[] points, Func`2<TA, T> map);
    public static IEnumerable`1<T> MapSequence(IEnumerable`1<TA> points, Func`2<TA, T> map);
    public static T[] Map2(TA[] pointsA, TB[] pointsB, Func`3<TA, TB, T> map);
    public static IEnumerable`1<T> Map2Sequence(IEnumerable`1<TA> pointsA, IEnumerable`1<TB> pointsB, Func`3<TA, TB, T> map);
    public static Double[] LinearSpaced(int length, double start, double stop);
    public static T[] LinearSpacedMap(int length, double start, double stop, Func`2<double, T> map);
    public static Double[] LogSpaced(int length, double startExponent, double stopExponent);
    public static T[] LogSpacedMap(int length, double startExponent, double stopExponent, Func`2<double, T> map);
    public static Double[] LinearRange(int start, int stop);
    public static Int32[] LinearRangeInt32(int start, int stop);
    public static Double[] LinearRange(int start, int step, int stop);
    public static Int32[] LinearRangeInt32(int start, int step, int stop);
    public static Double[] LinearRange(double start, double step, double stop);
    public static T[] LinearRangeMap(double start, double step, double stop, Func`2<double, T> map);
    public static Double[] Periodic(int length, double samplingRate, double frequency, double amplitude, double phase, int delay);
    public static T[] PeriodicMap(int length, Func`2<double, T> map, double samplingRate, double frequency, double amplitude, double phase, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<PeriodicSequence>d__16")]
public static IEnumerable`1<double> PeriodicSequence(double samplingRate, double frequency, double amplitude, double phase, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<PeriodicMapSequence>d__17`1")]
public static IEnumerable`1<T> PeriodicMapSequence(Func`2<double, T> map, double samplingRate, double frequency, double amplitude, double phase, int delay);
    public static Double[] Sinusoidal(int length, double samplingRate, double frequency, double amplitude, double mean, double phase, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<SinusoidalSequence>d__19")]
public static IEnumerable`1<double> SinusoidalSequence(double samplingRate, double frequency, double amplitude, double mean, double phase, int delay);
    public static Double[] Square(int length, int highDuration, int lowDuration, double lowValue, double highValue, int delay);
    public static IEnumerable`1<double> SquareSequence(int highDuration, int lowDuration, double lowValue, double highValue, int delay);
    public static Double[] Triangle(int length, int raiseDuration, int fallDuration, double lowValue, double highValue, int delay);
    public static IEnumerable`1<double> TriangleSequence(int raiseDuration, int fallDuration, double lowValue, double highValue, int delay);
    public static Double[] Sawtooth(int length, int period, double lowValue, double highValue, int delay);
    public static IEnumerable`1<double> SawtoothSequence(int period, double lowValue, double highValue, int delay);
    public static T[] Repeat(int length, T value);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<RepeatSequence>d__27`1")]
public static IEnumerable`1<T> RepeatSequence(T value);
    public static Double[] Step(int length, double amplitude, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<StepSequence>d__29")]
public static IEnumerable`1<double> StepSequence(double amplitude, int delay);
    public static Double[] Impulse(int length, double amplitude, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<ImpulseSequence>d__31")]
public static IEnumerable`1<double> ImpulseSequence(double amplitude, int delay);
    public static Double[] PeriodicImpulse(int length, int period, double amplitude, int delay);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<PeriodicImpulseSequence>d__33")]
public static IEnumerable`1<double> PeriodicImpulseSequence(int period, double amplitude, int delay);
    public static T[] Unfold(int length, Func`2<TState, Tuple`2<T, TState>> f, TState state);
    public static T[] Unfold(int length, Func`2<TState, ValueTuple`2<T, TState>> f, TState state);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<UnfoldSequence>d__36`2")]
public static IEnumerable`1<T> UnfoldSequence(Func`2<TState, Tuple`2<T, TState>> f, TState state);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<UnfoldSequence>d__37`2")]
public static IEnumerable`1<T> UnfoldSequence(Func`2<TState, ValueTuple`2<T, TState>> f, TState state);
    public static BigInteger[] Fibonacci(int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<FibonacciSequence>d__39")]
public static IEnumerable`1<BigInteger> FibonacciSequence();
    public static Double[] Uniform(int length);
    public static IEnumerable`1<double> UniformSequence();
    public static T[] UniformMap(int length, Func`2<double, T> map);
    public static IEnumerable`1<T> UniformMapSequence(Func`2<double, T> map);
    public static T[] UniformMap2(int length, Func`3<double, double, T> map);
    [IteratorStateMachineAttribute("MathNet.Numerics.Generate/<UniformMap2Sequence>d__45`1")]
public static IEnumerable`1<T> UniformMap2Sequence(Func`3<double, double, T> map);
    public static Double[] Standard(int length);
    public static IEnumerable`1<double> StandardSequence();
    public static Double[] Normal(int length, double mean, double standardDeviation);
    public static IEnumerable`1<double> NormalSequence(double mean, double standardDeviation);
    public static Double[] Random(int length, IContinuousDistribution distribution);
    public static IEnumerable`1<double> Random(IContinuousDistribution distribution);
    public static Single[] RandomSingle(int length, IContinuousDistribution distribution);
    public static IEnumerable`1<float> RandomSingle(IContinuousDistribution distribution);
    public static Complex[] RandomComplex(int length, IContinuousDistribution distribution);
    public static IEnumerable`1<Complex> RandomComplex(IContinuousDistribution distribution);
    public static Complex32[] RandomComplex32(int length, IContinuousDistribution distribution);
    public static IEnumerable`1<Complex32> RandomComplex32(IContinuousDistribution distribution);
    public static T[] RandomMap(int length, IContinuousDistribution distribution, Func`2<double, T> map);
    public static IEnumerable`1<T> RandomMapSequence(IContinuousDistribution distribution, Func`2<double, T> map);
    public static T[] RandomMap2(int length, IContinuousDistribution distribution, Func`3<double, double, T> map);
    public static IEnumerable`1<T> RandomMap2Sequence(IContinuousDistribution distribution, Func`3<double, double, T> map);
}
[ExtensionAttribute]
internal static class MathNet.Numerics.GlobalizationHelper : object {
    [ExtensionAttribute]
internal static CultureInfo GetCultureInfo(IFormatProvider formatProvider);
    [ExtensionAttribute]
internal static NumberFormatInfo GetNumberFormatInfo(IFormatProvider formatProvider);
    [ExtensionAttribute]
internal static TextInfo GetTextInfo(IFormatProvider formatProvider);
    internal static void Tokenize(LinkedListNode`1<string> node, String[] keywords, int skip);
    internal static double ParseDouble(LinkedListNode`1& token, CultureInfo culture);
    internal static float ParseSingle(LinkedListNode`1& token, CultureInfo culture);
}
public static class MathNet.Numerics.GoodnessOfFit : object {
    public static double RSquared(IEnumerable`1<double> modelledValues, IEnumerable`1<double> observedValues);
    public static double R(IEnumerable`1<double> modelledValues, IEnumerable`1<double> observedValues);
    public static double PopulationStandardError(IEnumerable`1<double> modelledValues, IEnumerable`1<double> observedValues);
    public static double StandardError(IEnumerable`1<double> modelledValues, IEnumerable`1<double> observedValues, int degreesOfFreedom);
    public static double CoefficientOfDetermination(IEnumerable`1<double> modelledValues, IEnumerable`1<double> observedValues);
}
public static class MathNet.Numerics.IntegralTransforms.Fourier : object {
    public static void Forward(Complex32[] samples);
    public static void Forward(Complex[] samples);
    public static void Forward(Complex32[] samples, FourierOptions options);
    public static void Forward(Complex[] samples, FourierOptions options);
    public static void Forward(Single[] real, Single[] imaginary, FourierOptions options);
    public static void Forward(Double[] real, Double[] imaginary, FourierOptions options);
    public static void ForwardReal(Single[] data, int n, FourierOptions options);
    public static void ForwardReal(Double[] data, int n, FourierOptions options);
    public static void ForwardMultiDim(Complex32[] samples, Int32[] dimensions, FourierOptions options);
    public static void ForwardMultiDim(Complex[] samples, Int32[] dimensions, FourierOptions options);
    public static void Forward2D(Complex32[] samplesRowWise, int rows, int columns, FourierOptions options);
    public static void Forward2D(Complex[] samplesRowWise, int rows, int columns, FourierOptions options);
    public static void Forward2D(Matrix`1<Complex32> samples, FourierOptions options);
    public static void Forward2D(Matrix`1<Complex> samples, FourierOptions options);
    public static void Inverse(Complex32[] spectrum);
    public static void Inverse(Complex[] spectrum);
    public static void Inverse(Complex32[] spectrum, FourierOptions options);
    public static void Inverse(Complex[] spectrum, FourierOptions options);
    public static void Inverse(Single[] real, Single[] imaginary, FourierOptions options);
    public static void Inverse(Double[] real, Double[] imaginary, FourierOptions options);
    public static void InverseReal(Single[] data, int n, FourierOptions options);
    public static void InverseReal(Double[] data, int n, FourierOptions options);
    public static void InverseMultiDim(Complex32[] spectrum, Int32[] dimensions, FourierOptions options);
    public static void InverseMultiDim(Complex[] spectrum, Int32[] dimensions, FourierOptions options);
    public static void Inverse2D(Complex32[] spectrumRowWise, int rows, int columns, FourierOptions options);
    public static void Inverse2D(Complex[] spectrumRowWise, int rows, int columns, FourierOptions options);
    public static void Inverse2D(Matrix`1<Complex32> spectrum, FourierOptions options);
    public static void Inverse2D(Matrix`1<Complex> spectrum, FourierOptions options);
    public static Double[] FrequencyScale(int length, double sampleRate);
}
[FlagsAttribute]
public enum MathNet.Numerics.IntegralTransforms.FourierOptions : Enum {
    public int value__;
    public static FourierOptions InverseExponent;
    public static FourierOptions AsymmetricScaling;
    public static FourierOptions NoScaling;
    public static FourierOptions Default;
    public static FourierOptions Matlab;
    public static FourierOptions NumericalRecipes;
}
public static class MathNet.Numerics.IntegralTransforms.Hartley : object {
    public static Double[] NaiveForward(Double[] timeSpace, HartleyOptions options);
    public static Double[] NaiveInverse(Double[] frequencySpace, HartleyOptions options);
    private static void ForwardScaleByOptions(HartleyOptions options, Double[] samples);
    private static void InverseScaleByOptions(HartleyOptions options, Double[] samples);
    internal static Double[] Naive(Double[] samples);
}
[FlagsAttribute]
public enum MathNet.Numerics.IntegralTransforms.HartleyOptions : Enum {
    public int value__;
    public static HartleyOptions AsymmetricScaling;
    public static HartleyOptions NoScaling;
    public static HartleyOptions Default;
}
public static class MathNet.Numerics.Integrate : object {
    public static double OnClosedInterval(Func`2<double, double> f, double intervalBegin, double intervalEnd, double targetAbsoluteError);
    public static double OnClosedInterval(Func`2<double, double> f, double intervalBegin, double intervalEnd);
    public static double OnRectangle(Func`3<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB, int order);
    public static double OnRectangle(Func`3<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB);
    public static double DoubleExponential(Func`2<double, double> f, double intervalBegin, double intervalEnd, double targetAbsoluteError);
    public static double GaussLegendre(Func`2<double, double> f, double intervalBegin, double intervalEnd, int order);
    public static double GaussKronrod(Func`2<double, double> f, double intervalBegin, double intervalEnd, double targetRelativeError, int maximumDepth, int order);
    public static double GaussKronrod(Func`2<double, double> f, double intervalBegin, double intervalEnd, Double& error, Double& L1Norm, double targetRelativeError, int maximumDepth, int order);
}
public static class MathNet.Numerics.Integration.DoubleExponentialTransformation : object {
    private static int NumberOfMaximumLevels;
    private static Double[][] PrecomputedAbscissas;
    private static Double[][] PrecomputedWeights;
    private static DoubleExponentialTransformation();
    public static double Integrate(Func`2<double, double> f, double intervalBegin, double intervalEnd, double targetRelativeError);
    public static Complex ContourIntegrate(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, double targetRelativeError);
    private static Double[] EvaluateAbcissas(int level);
    private static Double[] EvaluateWeights(int level);
}
public class MathNet.Numerics.Integration.GaussKronrodRule : object {
    private GaussPointPair _gaussKronrodPoint;
    public int Order { get; }
    public Double[] KronrodAbscissas { get; }
    public Double[] KronrodWeights { get; }
    public Double[] GaussWeights { get; }
    public GaussKronrodRule(int order);
    public int get_Order();
    public Double[] get_KronrodAbscissas();
    public Double[] get_KronrodWeights();
    public Double[] get_GaussWeights();
    public static double Integrate(Func`2<double, double> f, double intervalBegin, double intervalEnd, Double& error, Double& L1Norm, double targetRelativeError, int maximumDepth, int order);
    public static Complex ContourIntegrate(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, Double& error, Double& L1Norm, double targetRelativeError, int maximumDepth, int order);
    private static double integrate_non_adaptive_m1_1(Func`2<double, double> f, Double& error, Double& pL1, GaussPointPair gaussKronrodPoint);
    private static Complex contour_integrate_non_adaptive_m1_1(Func`2<double, Complex> f, Double& error, Double& pL1, GaussPointPair gaussKronrodPoint);
    private static double recursive_adaptive_integrate(Func`2<double, double> f, double a, double b, int maxLevels, double relTol, double absTol, Double& error, Double& L1, GaussPointPair gaussKronrodPoint);
    private static Complex contour_recursive_adaptive_integrate(Func`2<double, Complex> f, double a, double b, int maxLevels, double relTol, double absTol, Double& error, Double& L1, GaussPointPair gaussKronrodPoint);
}
public class MathNet.Numerics.Integration.GaussLegendreRule : object {
    private GaussPoint _gaussLegendrePoint;
    public Double[] Abscissas { get; }
    public Double[] Weights { get; }
    public int Order { get; }
    public double IntervalBegin { get; }
    public double IntervalEnd { get; }
    public GaussLegendreRule(double intervalBegin, double intervalEnd, int order);
    public double GetAbscissa(int index);
    public Double[] get_Abscissas();
    public double GetWeight(int index);
    public Double[] get_Weights();
    public int get_Order();
    public double get_IntervalBegin();
    public double get_IntervalEnd();
    public static double Integrate(Func`2<double, double> f, double invervalBegin, double invervalEnd, int order);
    public static Complex ContourIntegrate(Func`2<double, Complex> f, double invervalBegin, double invervalEnd, int order);
    public static double Integrate(Func`3<double, double, double> f, double invervalBeginA, double invervalEndA, double invervalBeginB, double invervalEndB, int order);
}
internal static class MathNet.Numerics.Integration.GaussRule.GaussKronrodPoint : object {
    internal static Dictionary`2<int, GaussPointPair> PreComputed;
    private static GaussKronrodPoint();
    internal static GaussPointPair Generate(int order, double eps);
    private static Double[] StieltjesP(int order);
    private static ValueTuple`2<double, double> LegendreSeries(Double[] a, double x);
    private static ValueTuple`2<double, double> LegendreP(int order, double x);
}
internal static class MathNet.Numerics.Integration.GaussRule.GaussKronrodPointFactory : object {
    [ThreadStaticAttribute]
private static GaussPointPair _gaussKronrodPoint;
    public static GaussPointPair GetGaussPoint(int order);
}
internal static class MathNet.Numerics.Integration.GaussRule.GaussLegendrePoint : object {
    internal static Dictionary`2<int, GaussPoint> PreComputed;
    private static GaussLegendrePoint();
    internal static GaussPoint Generate(int order, double eps);
}
internal static class MathNet.Numerics.Integration.GaussRule.GaussLegendrePointFactory : object {
    [ThreadStaticAttribute]
private static GaussPoint _gaussLegendrePoint;
    public static GaussPoint GetGaussPoint(int order);
    public static GaussPoint GetGaussPoint(double intervalBegin, double intervalEnd, int order);
    private static GaussPoint Map(double intervalBegin, double intervalEnd, GaussPoint gaussPoint);
}
internal class MathNet.Numerics.Integration.GaussRule.GaussPoint : object {
    [CompilerGeneratedAttribute]
private Double[] <Abscissas>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Weights>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalBegin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    internal Double[] Abscissas { get; }
    internal Double[] Weights { get; }
    internal double IntervalBegin { get; }
    internal double IntervalEnd { get; }
    internal int Order { get; }
    internal GaussPoint(double intervalBegin, double intervalEnd, int order, Double[] abscissas, Double[] weights);
    internal GaussPoint(int order, Double[] abscissas, Double[] weights);
    [CompilerGeneratedAttribute]
internal Double[] get_Abscissas();
    [CompilerGeneratedAttribute]
internal Double[] get_Weights();
    [CompilerGeneratedAttribute]
internal double get_IntervalBegin();
    [CompilerGeneratedAttribute]
internal double get_IntervalEnd();
    [CompilerGeneratedAttribute]
internal int get_Order();
}
internal class MathNet.Numerics.Integration.GaussRule.GaussPointPair : object {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Abscissas>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Weights>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SecondOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <SecondAbscissas>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <SecondWeights>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalBegin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalEnd>k__BackingField;
    internal int Order { get; }
    internal Double[] Abscissas { get; }
    internal Double[] Weights { get; }
    internal int SecondOrder { get; }
    internal Double[] SecondAbscissas { get; }
    internal Double[] SecondWeights { get; }
    internal double IntervalBegin { get; }
    internal double IntervalEnd { get; }
    internal GaussPointPair(double intervalBegin, double intervalEnd, int order, Double[] abscissas, Double[] weights, int secondOrder, Double[] secondAbscissas, Double[] secondWeights);
    internal GaussPointPair(int order, Double[] abscissas, Double[] weights, int secondOrder, Double[] secondWeights);
    [CompilerGeneratedAttribute]
internal int get_Order();
    [CompilerGeneratedAttribute]
internal Double[] get_Abscissas();
    [CompilerGeneratedAttribute]
internal Double[] get_Weights();
    [CompilerGeneratedAttribute]
internal int get_SecondOrder();
    [CompilerGeneratedAttribute]
internal Double[] get_SecondAbscissas();
    [CompilerGeneratedAttribute]
internal Double[] get_SecondWeights();
    [CompilerGeneratedAttribute]
internal double get_IntervalBegin();
    [CompilerGeneratedAttribute]
internal double get_IntervalEnd();
}
public static class MathNet.Numerics.Integration.NewtonCotesTrapeziumRule : object {
    public static double IntegrateTwoPoint(Func`2<double, double> f, double intervalBegin, double intervalEnd);
    public static Complex ContourIntegrateTwoPoint(Func`2<double, Complex> f, double intervalBegin, double intervalEnd);
    public static double IntegrateComposite(Func`2<double, double> f, double intervalBegin, double intervalEnd, int numberOfPartitions);
    public static Complex ContourIntegrateComposite(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, int numberOfPartitions);
    public static double IntegrateAdaptive(Func`2<double, double> f, double intervalBegin, double intervalEnd, double targetError);
    public static Complex ContourIntegrateAdaptive(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, double targetError);
    public static double IntegrateAdaptiveTransformedOdd(Func`2<double, double> f, double intervalBegin, double intervalEnd, IEnumerable`1<Double[]> levelAbscissas, IEnumerable`1<Double[]> levelWeights, double levelOneStep, double targetRelativeError);
    public static Complex ContourIntegrateAdaptiveTransformedOdd(Func`2<double, Complex> f, double intervalBegin, double intervalEnd, IEnumerable`1<Double[]> levelAbscissas, IEnumerable`1<Double[]> levelWeights, double levelOneStep, double targetRelativeError);
}
public static class MathNet.Numerics.Integration.SimpsonRule : object {
    public static double IntegrateThreePoint(Func`2<double, double> f, double intervalBegin, double intervalEnd);
    public static double IntegrateComposite(Func`2<double, double> f, double intervalBegin, double intervalEnd, int numberOfPartitions);
}
public static class MathNet.Numerics.Interpolate : object {
    public static IInterpolation Common(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation RationalWithoutPoles(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation RationalWithPoles(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation PolynomialEquidistant(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation Polynomial(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation Linear(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation LogLinear(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation CubicSpline(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation CubicSplineRobust(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation CubicSplineMonotone(IEnumerable`1<double> points, IEnumerable`1<double> values);
    public static IInterpolation CubicSplineWithDerivatives(IEnumerable`1<double> points, IEnumerable`1<double> values, IEnumerable`1<double> firstDerivatives);
    public static IInterpolation Step(IEnumerable`1<double> points, IEnumerable`1<double> values);
}
public class MathNet.Numerics.Interpolation.Barycentric : object {
    private Double[] _x;
    private Double[] _y;
    private Double[] _w;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public Barycentric(Double[] x, Double[] y, Double[] w);
    public static Barycentric InterpolatePolynomialEquidistantSorted(Double[] x, Double[] y);
    public static Barycentric InterpolatePolynomialEquidistantInplace(Double[] x, Double[] y);
    public static Barycentric InterpolatePolynomialEquidistant(IEnumerable`1<double> x, IEnumerable`1<double> y);
    public static Barycentric InterpolatePolynomialEquidistant(double leftBound, double rightBound, IEnumerable`1<double> y);
    public static Barycentric InterpolateRationalFloaterHormannSorted(Double[] x, Double[] y, int order);
    public static Barycentric InterpolateRationalFloaterHormannInplace(Double[] x, Double[] y, int order);
    public static Barycentric InterpolateRationalFloaterHormann(IEnumerable`1<double> x, IEnumerable`1<double> y, int order);
    public static Barycentric InterpolateRationalFloaterHormannSorted(Double[] x, Double[] y);
    public static Barycentric InterpolateRationalFloaterHormannInplace(Double[] x, Double[] y);
    public static Barycentric InterpolateRationalFloaterHormann(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate2(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double a, double b);
}
public class MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation : object {
    private Double[] _x;
    private Double[] _y;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public BulirschStoerRationalInterpolation(Double[] x, Double[] y);
    public static BulirschStoerRationalInterpolation InterpolateSorted(Double[] x, Double[] y);
    public static BulirschStoerRationalInterpolation InterpolateInplace(Double[] x, Double[] y);
    public static BulirschStoerRationalInterpolation Interpolate(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate2(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double a, double b);
}
public class MathNet.Numerics.Interpolation.CubicSpline : object {
    private Double[] _x;
    private Double[] _c0;
    private Double[] _c1;
    private Double[] _c2;
    private Double[] _c3;
    private Lazy`1<Double[]> _indefiniteIntegral;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public CubicSpline(Double[] x, Double[] c0, Double[] c1, Double[] c2, Double[] c3);
    public static CubicSpline InterpolateHermiteSorted(Double[] x, Double[] y, Double[] firstDerivatives);
    public static CubicSpline InterpolateHermiteInplace(Double[] x, Double[] y, Double[] firstDerivatives);
    public static CubicSpline InterpolateHermite(IEnumerable`1<double> x, IEnumerable`1<double> y, IEnumerable`1<double> firstDerivatives);
    public static CubicSpline InterpolateAkimaSorted(Double[] x, Double[] y);
    public static CubicSpline InterpolateAkimaInplace(Double[] x, Double[] y);
    public static CubicSpline InterpolateAkima(IEnumerable`1<double> x, IEnumerable`1<double> y);
    public static CubicSpline InterpolatePchipSorted(Double[] x, Double[] y);
    private static double PchipEndPoints(double h0, double h1, double m0, double m1);
    public static CubicSpline InterpolatePchipInplace(Double[] x, Double[] y);
    public static CubicSpline InterpolatePchip(IEnumerable`1<double> x, IEnumerable`1<double> y);
    public static CubicSpline InterpolateBoundariesSorted(Double[] x, Double[] y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary);
    public static CubicSpline InterpolateBoundariesInplace(Double[] x, Double[] y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary);
    public static CubicSpline InterpolateBoundaries(IEnumerable`1<double> x, IEnumerable`1<double> y, SplineBoundaryCondition leftBoundaryCondition, double leftBoundary, SplineBoundaryCondition rightBoundaryCondition, double rightBoundary);
    public static CubicSpline InterpolateNaturalSorted(Double[] x, Double[] y);
    public static CubicSpline InterpolateNaturalInplace(Double[] x, Double[] y);
    public static CubicSpline InterpolateNatural(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private static double DifferentiateThreePoint(Double[] xx, Double[] yy, int indexT, int index0, int index1, int index2);
    private static Double[] SolveTridiagonal(Double[] a, Double[] b, Double[] c, Double[] d);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    public sealed virtual double Integrate(double t);
    public sealed virtual double Integrate(double a, double b);
    private Double[] ComputeIndefiniteIntegral();
    private int LeftSegmentIndex(double t);
    public Double[] StationaryPoints();
    public Tuple`2<double, double> Extrema();
}
public interface MathNet.Numerics.Interpolation.IInterpolation {
    public bool SupportsDifferentiation { get; }
    public bool SupportsIntegration { get; }
    public abstract virtual bool get_SupportsDifferentiation();
    public abstract virtual bool get_SupportsIntegration();
    public abstract virtual double Interpolate(double t);
    public abstract virtual double Differentiate(double t);
    public abstract virtual double Differentiate2(double t);
    public abstract virtual double Integrate(double t);
    public abstract virtual double Integrate(double a, double b);
}
public class MathNet.Numerics.Interpolation.LinearSpline : object {
    private Double[] _x;
    private Double[] _c0;
    private Double[] _c1;
    private Lazy`1<Double[]> _indefiniteIntegral;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public LinearSpline(Double[] x, Double[] c0, Double[] c1);
    public static LinearSpline InterpolateSorted(Double[] x, Double[] y);
    public static LinearSpline InterpolateInplace(Double[] x, Double[] y);
    public static LinearSpline Interpolate(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    public sealed virtual double Integrate(double t);
    public sealed virtual double Integrate(double a, double b);
    private Double[] ComputeIndefiniteIntegral();
    private int LeftSegmentIndex(double t);
}
public class MathNet.Numerics.Interpolation.LogLinear : object {
    private LinearSpline _spline;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public LogLinear(Double[] x, Double[] logy);
    public static LogLinear InterpolateSorted(Double[] x, Double[] y);
    public static LogLinear InterpolateInplace(Double[] x, Double[] y);
    public static LogLinear Interpolate(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double a, double b);
}
public class MathNet.Numerics.Interpolation.NevillePolynomialInterpolation : object {
    private Double[] _x;
    private Double[] _y;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public NevillePolynomialInterpolation(Double[] x, Double[] y);
    public static NevillePolynomialInterpolation InterpolateSorted(Double[] x, Double[] y);
    public static NevillePolynomialInterpolation InterpolateInplace(Double[] x, Double[] y);
    public static NevillePolynomialInterpolation Interpolate(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double a, double b);
}
public class MathNet.Numerics.Interpolation.QuadraticSpline : object {
    private Double[] _x;
    private Double[] _c0;
    private Double[] _c1;
    private Double[] _c2;
    private Lazy`1<Double[]> _indefiniteIntegral;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public QuadraticSpline(Double[] x, Double[] c0, Double[] c1, Double[] c2);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    public sealed virtual double Integrate(double t);
    public sealed virtual double Integrate(double a, double b);
    private Double[] ComputeIndefiniteIntegral();
    private int LeftSegmentIndex(double t);
}
public enum MathNet.Numerics.Interpolation.SplineBoundaryCondition : Enum {
    public int value__;
    public static SplineBoundaryCondition Natural;
    public static SplineBoundaryCondition ParabolicallyTerminated;
    public static SplineBoundaryCondition FirstDerivative;
    public static SplineBoundaryCondition SecondDerivative;
}
public class MathNet.Numerics.Interpolation.StepInterpolation : object {
    private Double[] _x;
    private Double[] _y;
    private Lazy`1<Double[]> _indefiniteIntegral;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public StepInterpolation(Double[] x, Double[] sy);
    public static StepInterpolation InterpolateSorted(Double[] x, Double[] y);
    public static StepInterpolation InterpolateInplace(Double[] x, Double[] y);
    public static StepInterpolation Interpolate(IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    public sealed virtual double Differentiate(double t);
    public sealed virtual double Differentiate2(double t);
    public sealed virtual double Integrate(double t);
    public sealed virtual double Integrate(double a, double b);
    private Double[] ComputeIndefiniteIntegral();
    private int LeftBracketIndex(double t);
}
public class MathNet.Numerics.Interpolation.TransformedInterpolation : object {
    private IInterpolation _interpolation;
    private Func`2<double, double> _transform;
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsDifferentiation { get; }
    private bool MathNet.Numerics.Interpolation.IInterpolation.SupportsIntegration { get; }
    public TransformedInterpolation(IInterpolation interpolation, Func`2<double, double> transform);
    public static TransformedInterpolation InterpolateSorted(Func`2<double, double> transform, Func`2<double, double> transformInverse, Double[] x, Double[] y);
    public static TransformedInterpolation InterpolateInplace(Func`2<double, double> transform, Func`2<double, double> transformInverse, Double[] x, Double[] y);
    public static TransformedInterpolation Interpolate(Func`2<double, double> transform, Func`2<double, double> transformInverse, IEnumerable`1<double> x, IEnumerable`1<double> y);
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsDifferentiation();
    private sealed virtual override bool MathNet.Numerics.Interpolation.IInterpolation.get_SupportsIntegration();
    public sealed virtual double Interpolate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Differentiate2(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double t);
    private sealed virtual override double MathNet.Numerics.Interpolation.IInterpolation.Integrate(double a, double b);
}
public class MathNet.Numerics.InvalidParameterException : NativeInterfaceException {
    public InvalidParameterException(int parameter);
    public InvalidParameterException(int parameter, Exception innerException);
    protected InvalidParameterException(SerializationInfo info, StreamingContext context);
}
public interface MathNet.Numerics.IPrecisionSupport`1 {
    public abstract virtual double Norm();
    public abstract virtual double NormOfDifference(T otherValue);
}
internal static class MathNet.Numerics.LinearAlgebra.BuilderInstance`1 : object {
    private static Lazy`1<Tuple`2<MatrixBuilder`1<T>, VectorBuilder`1<T>>> _singleton;
    public static MatrixBuilder`1<T> Matrix { get; }
    public static VectorBuilder`1<T> Vector { get; }
    private static BuilderInstance`1();
    private static Tuple`2<MatrixBuilder`1<T>, VectorBuilder`1<T>> Create();
    public static void Register(MatrixBuilder`1<T> matrixBuilder, VectorBuilder`1<T> vectorBuilder);
    public static MatrixBuilder`1<T> get_Matrix();
    public static VectorBuilder`1<T> get_Vector();
}
[DebuggerDisplayAttribute("DenseMatrix {RowCount}x{ColumnCount}-Complex")]
public class MathNet.Numerics.LinearAlgebra.Complex.DenseMatrix : Matrix {
    private int _rowCount;
    private int _columnCount;
    private Complex[] _values;
    public Complex[] Values { get; }
    public DenseMatrix(DenseColumnMajorMatrixStorage`1<Complex> storage);
    public DenseMatrix(int order);
    public DenseMatrix(int rows, int columns);
    public DenseMatrix(int rows, int columns, Complex[] storage);
    public static DenseMatrix OfMatrix(Matrix`1<Complex> matrix);
    public static DenseMatrix OfArray(Complex[0...,0...] array);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, Complex>> enumerable);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, Complex>> enumerable);
    public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable`1<Complex> columnMajor);
    public static DenseMatrix OfColumns(IEnumerable`1<IEnumerable`1<Complex>> data);
    public static DenseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex>> data);
    public static DenseMatrix OfColumnArrays(Complex[][] columns);
    public static DenseMatrix OfColumnArrays(IEnumerable`1<Complex[]> columns);
    public static DenseMatrix OfColumnVectors(Vector`1[] columns);
    public static DenseMatrix OfColumnVectors(IEnumerable`1<Vector`1<Complex>> columns);
    public static DenseMatrix OfRows(IEnumerable`1<IEnumerable`1<Complex>> data);
    public static DenseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex>> data);
    public static DenseMatrix OfRowArrays(Complex[][] rows);
    public static DenseMatrix OfRowArrays(IEnumerable`1<Complex[]> rows);
    public static DenseMatrix OfRowVectors(Vector`1[] rows);
    public static DenseMatrix OfRowVectors(IEnumerable`1<Vector`1<Complex>> rows);
    public static DenseMatrix OfDiagonalVector(Vector`1<Complex> diagonal);
    public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector`1<Complex> diagonal);
    public static DenseMatrix OfDiagonalArray(Complex[] diagonal);
    public static DenseMatrix OfDiagonalArray(int rows, int columns, Complex[] diagonal);
    public static DenseMatrix Create(int rows, int columns, Complex value);
    public static DenseMatrix Create(int rows, int columns, Func`3<int, int, Complex> init);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Complex value);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Func`2<int, Complex> init);
    public static DenseMatrix CreateIdentity(int order);
    public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    public Complex[] get_Values();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoNegate(Matrix`1<Complex> result);
    protected virtual void DoConjugate(Matrix`1<Complex> result);
    protected virtual void DoAdd(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoAdd(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoDivide(Complex divisor, Matrix`1<Complex> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex> divisor, Matrix`1<Complex> result);
    protected virtual void DoPointwisePower(Matrix`1<Complex> exponent, Matrix`1<Complex> result);
    public virtual Complex Trace();
    public static DenseMatrix op_Addition(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryPlus(DenseMatrix rightSide);
    public static DenseMatrix op_Subtraction(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryNegation(DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, Complex rightSide);
    public static DenseMatrix op_Multiply(Complex leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseVector op_Multiply(DenseMatrix leftSide, DenseVector rightSide);
    public static DenseVector op_Multiply(DenseVector leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Modulus(DenseMatrix leftSide, Complex rightSide);
    public virtual bool IsSymmetric();
    public virtual bool IsHermitian();
    public virtual Cholesky`1<Complex> Cholesky();
    public virtual LU`1<Complex> LU();
    public virtual QR`1<Complex> QR(QRMethod method);
    public virtual GramSchmidt`1<Complex> GramSchmidt();
    public virtual Svd`1<Complex> Svd(bool computeVectors);
    public virtual Evd`1<Complex> Evd(Symmetricity symmetricity);
}
[DebuggerDisplayAttribute("DenseVector {Count}-Complex")]
public class MathNet.Numerics.LinearAlgebra.Complex.DenseVector : Vector {
    private int _length;
    private Complex[] _values;
    public Complex[] Values { get; }
    public DenseVector(DenseVectorStorage`1<Complex> storage);
    public DenseVector(int length);
    public DenseVector(Complex[] storage);
    public static DenseVector OfVector(Vector`1<Complex> vector);
    public static DenseVector OfArray(Complex[] array);
    public static DenseVector OfEnumerable(IEnumerable`1<Complex> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, Complex>> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, Complex>> enumerable);
    public static DenseVector Create(int length, Complex value);
    public static DenseVector Create(int length, Func`2<int, Complex> init);
    public static DenseVector CreateRandom(int length, IContinuousDistribution distribution);
    public Complex[] get_Values();
    public static Complex[] op_Explicit(DenseVector vector);
    public static DenseVector op_Implicit(Complex[] array);
    protected virtual void DoAdd(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoAdd(Vector`1<Complex> other, Vector`1<Complex> result);
    public static Vector`1<Complex> op_Addition(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoSubtract(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoSubtract(Vector`1<Complex> other, Vector`1<Complex> result);
    public static Vector`1<Complex> op_UnaryNegation(DenseVector rightSide);
    public static Vector`1<Complex> op_Subtraction(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoNegate(Vector`1<Complex> result);
    protected virtual void DoConjugate(Vector`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Vector`1<Complex> result);
    protected virtual Complex DoDotProduct(Vector`1<Complex> other);
    protected virtual Complex DoConjugateDotProduct(Vector`1<Complex> other);
    public static DenseVector op_Multiply(DenseVector leftSide, Complex rightSide);
    public static DenseVector op_Multiply(Complex leftSide, DenseVector rightSide);
    public static Complex op_Multiply(DenseVector leftSide, DenseVector rightSide);
    public static DenseVector op_Division(DenseVector leftSide, Complex rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseDivide(Vector`1<Complex> divisor, Vector`1<Complex> result);
    protected virtual void DoPointwisePower(Vector`1<Complex> exponent, Vector`1<Complex> result);
    public static DenseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, DenseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, DenseVector& result);
}
[DebuggerDisplayAttribute("DiagonalMatrix {RowCount}x{ColumnCount}-Complex")]
public class MathNet.Numerics.LinearAlgebra.Complex.DiagonalMatrix : Matrix {
    private Complex[] _data;
    public DiagonalMatrix(DiagonalMatrixStorage`1<Complex> storage);
    public DiagonalMatrix(int order);
    public DiagonalMatrix(int rows, int columns);
    public DiagonalMatrix(int rows, int columns, Complex diagonalValue);
    public DiagonalMatrix(int rows, int columns, Complex[] diagonalStorage);
    public static DiagonalMatrix OfMatrix(Matrix`1<Complex> matrix);
    public static DiagonalMatrix OfArray(Complex[0...,0...] array);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<Tuple`2<int, Complex>> diagonal);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<ValueTuple`2<int, Complex>> diagonal);
    public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable`1<Complex> diagonal);
    public static DiagonalMatrix Create(int rows, int columns, Func`2<int, Complex> init);
    public static DiagonalMatrix CreateIdentity(int order);
    public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    protected virtual void DoNegate(Matrix`1<Complex> result);
    protected virtual void DoConjugate(Matrix`1<Complex> result);
    protected virtual void DoAdd(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoDivide(Complex divisor, Matrix`1<Complex> result);
    protected virtual void DoDivideByThis(Complex dividend, Matrix`1<Complex> result);
    public virtual Complex Determinant();
    public virtual Vector`1<Complex> Diagonal();
    public virtual void SetDiagonal(Complex[] source);
    public virtual void SetDiagonal(Vector`1<Complex> source);
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Complex ConditionNumber();
    public virtual Matrix`1<Complex> Inverse();
    public virtual Matrix`1<Complex> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public virtual void PermuteColumns(Permutation p);
    public virtual void PermuteRows(Permutation p);
    public sealed virtual bool IsSymmetric();
    public sealed virtual bool IsHermitian();
    [CompilerGeneratedAttribute]
private Complex <DoMultiply>b__20_0(int i, int _, Complex x);
    [CompilerGeneratedAttribute]
private Complex <DoMultiply>b__20_1(int i, int _, Complex x);
    [CompilerGeneratedAttribute]
private Complex <DoTransposeThisAndMultiply>b__23_0(int i, int _, Complex x);
    [CompilerGeneratedAttribute]
private Complex <DoTransposeThisAndMultiply>b__23_1(int i, int _, Complex x);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.Cholesky : Cholesky`1<Complex> {
    public Complex Determinant { get; }
    public Complex DeterminantLn { get; }
    protected Cholesky(Matrix`1<Complex> factor);
    public virtual Complex get_Determinant();
    public virtual Complex get_DeterminantLn();
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseCholesky : Cholesky {
    private DenseCholesky(Matrix`1<Complex> factor);
    public static DenseCholesky Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
    public virtual void Factorize(Matrix`1<Complex> matrix);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseEvd : Evd {
    private DenseEvd(Matrix`1<Complex> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex> blockDiagonal, bool isSymmetric);
    public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseGramSchmidt : GramSchmidt {
    private DenseGramSchmidt(Matrix`1<Complex> q, Matrix`1<Complex> rFull);
    public static DenseGramSchmidt Create(Matrix`1<Complex> matrix);
    private static void Factorize(Complex[] q, int rowsQ, int columnsQ, Complex[] r);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseLU : LU {
    private DenseLU(Matrix`1<Complex> factors, Int32[] pivots);
    public static DenseLU Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
    public virtual Matrix`1<Complex> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseQR : QR {
    [CompilerGeneratedAttribute]
private Complex[] <Tau>k__BackingField;
    private Complex[] Tau { get; private set; }
    private DenseQR(Matrix`1<Complex> q, Matrix`1<Complex> rFull, QRMethod method, Complex[] tau);
    [CompilerGeneratedAttribute]
private Complex[] get_Tau();
    [CompilerGeneratedAttribute]
private void set_Tau(Complex[] value);
    public static DenseQR Create(DenseMatrix matrix, QRMethod method);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.DenseSvd : Svd {
    private DenseSvd(Vector`1<Complex> s, Matrix`1<Complex> u, Matrix`1<Complex> vt, bool vectorsComputed);
    public static DenseSvd Create(DenseMatrix matrix, bool computeVectors);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.Evd : Evd`1<Complex> {
    public Complex Determinant { get; }
    public int Rank { get; }
    public bool IsFullRank { get; }
    protected Evd(Matrix`1<Complex> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex> blockDiagonal, bool isSymmetric);
    public virtual Complex get_Determinant();
    public virtual int get_Rank();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.GramSchmidt : GramSchmidt`1<Complex> {
    public Complex Determinant { get; }
    public bool IsFullRank { get; }
    protected GramSchmidt(Matrix`1<Complex> q, Matrix`1<Complex> rFull);
    public virtual Complex get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.LU : LU`1<Complex> {
    public Complex Determinant { get; }
    protected LU(Matrix`1<Complex> factors, Int32[] pivots);
    public virtual Complex get_Determinant();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.QR : QR`1<Complex> {
    public Complex Determinant { get; }
    public bool IsFullRank { get; }
    protected QR(Matrix`1<Complex> q, Matrix`1<Complex> rFull, QRMethod method);
    public virtual Complex get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex.Factorization.Svd : Svd`1<Complex> {
    public int Rank { get; }
    public double L2Norm { get; }
    public Complex ConditionNumber { get; }
    public Complex Determinant { get; }
    protected Svd(Vector`1<Complex> s, Matrix`1<Complex> u, Matrix`1<Complex> vt, bool vectorsComputed);
    public virtual int get_Rank();
    public virtual double get_L2Norm();
    public virtual Complex get_ConditionNumber();
    public virtual Complex get_Determinant();
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserCholesky : Cholesky {
    private UserCholesky(Matrix`1<Complex> factor);
    private static void DoCholesky(Matrix`1<Complex> factor);
    public static UserCholesky Create(Matrix`1<Complex> matrix);
    public virtual void Factorize(Matrix`1<Complex> matrix);
    private static void DoCholeskyStep(Matrix`1<Complex> data, int rowDim, int firstCol, int colLimit, Complex[] multipliers, int availableCores);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserEvd : Evd {
    private UserEvd(Matrix`1<Complex> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex> blockDiagonal, bool isSymmetric);
    public static UserEvd Create(Matrix`1<Complex> matrix, Symmetricity symmetricity);
    private static void SymmetricTridiagonalize(Complex[0...,0...] matrixA, Double[] d, Double[] e, Complex[] tau, int order);
    private static void SymmetricDiagonalize(Matrix`1<Complex> eigenVectors, Double[] d, Double[] e, int order);
    private static void SymmetricUntridiagonalize(Matrix`1<Complex> eigenVectors, Complex[0...,0...] matrixA, Complex[] tau, int order);
    private static void NonsymmetricReduceToHessenberg(Matrix`1<Complex> eigenVectors, Complex[0...,0...] matrixH, int order);
    private static void NonsymmetricReduceHessenberToRealSchur(Matrix`1<Complex> eigenVectors, Vector`1<Complex> eigenValues, Complex[0...,0...] matrixH, int order);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserGramSchmidt : GramSchmidt {
    private UserGramSchmidt(Matrix`1<Complex> q, Matrix`1<Complex> rFull);
    public static UserGramSchmidt Create(Matrix`1<Complex> matrix);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserLU : LU {
    private UserLU(Matrix`1<Complex> factors, Int32[] pivots);
    public static UserLU Create(Matrix`1<Complex> matrix);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
    public virtual Matrix`1<Complex> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserQR : QR {
    private UserQR(Matrix`1<Complex> q, Matrix`1<Complex> rFull, QRMethod method);
    public static UserQR Create(Matrix`1<Complex> matrix, QRMethod method);
    private static Complex[] GenerateColumn(Matrix`1<Complex> a, int row, int column);
    private static void ComputeQR(Complex[] u, Matrix`1<Complex> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.Factorization.UserSvd : Svd {
    private UserSvd(Vector`1<Complex> s, Matrix`1<Complex> u, Matrix`1<Complex> vt, bool vectorsComputed);
    public static UserSvd Create(Matrix`1<Complex> matrix, bool computeVectors);
    private static Complex Csign(Complex z1, Complex z2);
    private static void Swap(Matrix`1<Complex> a, int rowCount, int columnA, int columnB);
    private static void CscalColumn(Matrix`1<Complex> a, int rowCount, int column, int rowStart, Complex z);
    private static void CscalVector(Complex[] a, int start, Complex z);
    private static void Srotg(Double& da, Double& db, Double& c, Double& s);
    private static double Cnrm2Column(Matrix`1<Complex> a, int rowCount, int column, int rowStart);
    private static double Cnrm2Vector(Complex[] a, int rowStart);
    private static Complex Cdotc(Matrix`1<Complex> a, int rowCount, int columnA, int columnB, int rowStart);
    private static void Csrot(Matrix`1<Complex> a, int rowCount, int columnA, int columnB, double c, double s);
    public virtual void Solve(Matrix`1<Complex> input, Matrix`1<Complex> result);
    public virtual void Solve(Vector`1<Complex> input, Vector`1<Complex> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Complex.Matrix : Matrix`1<Complex> {
    protected Matrix(MatrixStorage`1<Complex> storage);
    public virtual void CoerceZero(double threshold);
    public sealed virtual Matrix`1<Complex> ConjugateTranspose();
    public sealed virtual void ConjugateTranspose(Matrix`1<Complex> result);
    protected virtual void DoConjugate(Matrix`1<Complex> result);
    protected virtual void DoNegate(Matrix`1<Complex> result);
    protected virtual void DoAdd(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoAdd(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoDivide(Complex divisor, Matrix`1<Complex> result);
    protected virtual void DoDivideByThis(Complex dividend, Matrix`1<Complex> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex> divisor, Matrix`1<Complex> result);
    protected virtual void DoPointwisePower(Complex exponent, Matrix`1<Complex> result);
    protected virtual void DoPointwisePower(Matrix`1<Complex> exponent, Matrix`1<Complex> result);
    protected sealed virtual void DoPointwiseModulus(Matrix`1<Complex> divisor, Matrix`1<Complex> result);
    protected sealed virtual void DoPointwiseRemainder(Matrix`1<Complex> divisor, Matrix`1<Complex> result);
    protected sealed virtual void DoModulus(Complex divisor, Matrix`1<Complex> result);
    protected sealed virtual void DoModulusByThis(Complex dividend, Matrix`1<Complex> result);
    protected sealed virtual void DoRemainder(Complex divisor, Matrix`1<Complex> result);
    protected sealed virtual void DoRemainderByThis(Complex dividend, Matrix`1<Complex> result);
    protected virtual void DoPointwiseExp(Matrix`1<Complex> result);
    protected virtual void DoPointwiseLog(Matrix`1<Complex> result);
    protected virtual void DoPointwiseAbs(Matrix`1<Complex> result);
    protected virtual void DoPointwiseAcos(Matrix`1<Complex> result);
    protected virtual void DoPointwiseAsin(Matrix`1<Complex> result);
    protected virtual void DoPointwiseAtan(Matrix`1<Complex> result);
    protected virtual void DoPointwiseAtan2(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseCeiling(Matrix`1<Complex> result);
    protected virtual void DoPointwiseCos(Matrix`1<Complex> result);
    protected virtual void DoPointwiseCosh(Matrix`1<Complex> result);
    protected virtual void DoPointwiseFloor(Matrix`1<Complex> result);
    protected virtual void DoPointwiseLog10(Matrix`1<Complex> result);
    protected virtual void DoPointwiseRound(Matrix`1<Complex> result);
    protected virtual void DoPointwiseSign(Matrix`1<Complex> result);
    protected virtual void DoPointwiseSin(Matrix`1<Complex> result);
    protected virtual void DoPointwiseSinh(Matrix`1<Complex> result);
    protected virtual void DoPointwiseSqrt(Matrix`1<Complex> result);
    protected virtual void DoPointwiseTan(Matrix`1<Complex> result);
    protected virtual void DoPointwiseTanh(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> PseudoInverse();
    public virtual Complex Trace();
    protected virtual void DoPointwiseMinimum(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoPointwiseMaximum(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoPointwiseMinimum(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseMaximum(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Matrix`1<Complex> other, Matrix`1<Complex> result);
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Vector`1<double> RowNorms(double norm);
    public virtual Vector`1<double> ColumnNorms(double norm);
    public sealed virtual Matrix`1<Complex> NormalizeRows(double norm);
    public sealed virtual Matrix`1<Complex> NormalizeColumns(double norm);
    public virtual Vector`1<Complex> RowSums();
    public virtual Vector`1<Complex> RowAbsoluteSums();
    public virtual Vector`1<Complex> ColumnSums();
    public virtual Vector`1<Complex> ColumnAbsoluteSums();
    public virtual bool IsHermitian();
    public virtual Cholesky`1<Complex> Cholesky();
    public virtual LU`1<Complex> LU();
    public virtual QR`1<Complex> QR(QRMethod method);
    public virtual GramSchmidt`1<Complex> GramSchmidt();
    public virtual Svd`1<Complex> Svd(bool computeVectors);
    public virtual Evd`1<Complex> Evd(Symmetricity symmetricity);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.MatrixBuilder : MatrixBuilder`1<Complex> {
    public Complex Zero { get; }
    public Complex One { get; }
    public virtual Complex get_Zero();
    public virtual Complex get_One();
    public virtual Matrix`1<Complex> Dense(DenseColumnMajorMatrixStorage`1<Complex> storage);
    public virtual Matrix`1<Complex> Sparse(SparseCompressedRowMatrixStorage`1<Complex> storage);
    public virtual Matrix`1<Complex> Diagonal(DiagonalMatrixStorage`1<Complex> storage);
    public virtual Matrix`1<Complex> Random(int rows, int columns, IContinuousDistribution distribution);
    public virtual IIterationStopCriterion`1[] IterativeSolverStopCriteria(int maxIterations);
    internal virtual Complex Add(Complex x, Complex y);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.BiCgStab : object {
    private static void CalculateTrueResidual(Matrix`1<Complex> matrix, Vector`1<Complex> residual, Vector`1<Complex> x, Vector`1<Complex> b);
    public sealed virtual void Solve(Matrix`1<Complex> matrix, Vector`1<Complex> input, Vector`1<Complex> result, Iterator`1<Complex> iterator, IPreconditioner`1<Complex> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.CompositeSolver : object {
    private List`1<Tuple`2<IIterativeSolver`1<Complex>, IPreconditioner`1<Complex>>> _solvers;
    public CompositeSolver(IEnumerable`1<IIterativeSolverSetup`1<Complex>> solvers);
    public sealed virtual void Solve(Matrix`1<Complex> matrix, Vector`1<Complex> input, Vector`1<Complex> result, Iterator`1<Complex> iterator, IPreconditioner`1<Complex> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.DiagonalPreconditioner : object {
    private Complex[] _inverseDiagonals;
    internal DiagonalMatrix DiagonalEntries();
    public sealed virtual void Initialize(Matrix`1<Complex> matrix);
    public sealed virtual void Approximate(Vector`1<Complex> rhs, Vector`1<Complex> lhs);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.GpBiCg : object {
    private int _numberOfBiCgStabSteps;
    private int _numberOfGpbiCgSteps;
    public int NumberOfBiCgStabSteps { get; public set; }
    public int NumberOfGpBiCgSteps { get; public set; }
    public int get_NumberOfBiCgStabSteps();
    public void set_NumberOfBiCgStabSteps(int value);
    public int get_NumberOfGpBiCgSteps();
    public void set_NumberOfGpBiCgSteps(int value);
    private static void CalculateTrueResidual(Matrix`1<Complex> matrix, Vector`1<Complex> residual, Vector`1<Complex> x, Vector`1<Complex> b);
    private bool ShouldRunBiCgStabSteps(int iterationNumber);
    public sealed virtual void Solve(Matrix`1<Complex> matrix, Vector`1<Complex> input, Vector`1<Complex> result, Iterator`1<Complex> iterator, IPreconditioner`1<Complex> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.ILU0Preconditioner : object {
    private SparseMatrix _decompositionLU;
    internal Matrix`1<Complex> UpperTriangle();
    internal Matrix`1<Complex> LowerTriangle();
    public sealed virtual void Initialize(Matrix`1<Complex> matrix);
    public sealed virtual void Approximate(Vector`1<Complex> rhs, Vector`1<Complex> lhs);
}
internal static class MathNet.Numerics.LinearAlgebra.Complex.Solvers.ILUTPElementSorter : object {
    public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex> values);
    private static void HeapSortDoublesIndices(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex> values);
    private static void BuildDoubleIndexHeap(int start, int count, Int32[] sortedIndices, Vector`1<Complex> values);
    private static void SiftDoubleIndices(Int32[] sortedIndices, Vector`1<Complex> values, int begin, int count);
    public static void SortIntegersDecreasing(Int32[] values);
    private static void HeapSortIntegers(Int32[] values, int count);
    private static void BuildHeap(Int32[] values, int start, int count);
    private static void Sift(Int32[] values, int start, int count);
    private static void Exchange(Int32[] values, int first, int second);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.ILUTPPreconditioner : object {
    public static double DefaultFillLevel;
    public static double DefaultDropTolerance;
    private SparseMatrix _upper;
    private SparseMatrix _lower;
    private Int32[] _pivots;
    private double _fillLevel;
    private double _dropTolerance;
    private double _pivotTolerance;
    public double FillLevel { get; public set; }
    public double DropTolerance { get; public set; }
    public double PivotTolerance { get; public set; }
    public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance);
    public double get_FillLevel();
    public void set_FillLevel(double value);
    public double get_DropTolerance();
    public void set_DropTolerance(double value);
    public double get_PivotTolerance();
    public void set_PivotTolerance(double value);
    internal Matrix`1<Complex> UpperTriangle();
    internal Matrix`1<Complex> LowerTriangle();
    internal Int32[] Pivots();
    public sealed virtual void Initialize(Matrix`1<Complex> matrix);
    private void PivotRow(Vector`1<Complex> row);
    private bool PivotMapFound(Dictionary`2<int, int> knownPivots, int currentItem);
    private static void SwapColumns(Matrix`1<Complex> matrix, int firstColumn, int secondColumn);
    private static void FindLargestItems(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex> values);
    public sealed virtual void Approximate(Vector`1<Complex> rhs, Vector`1<Complex> lhs);
    private void Pivot(Vector`1<Complex> vector, Vector`1<Complex> result);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.MILU0Preconditioner : object {
    private Complex[] _alu;
    private Int32[] _jlu;
    private Int32[] _diag;
    [CompilerGeneratedAttribute]
private bool <UseModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool UseModified { get; public set; }
    public bool IsInitialized { get; private set; }
    public MILU0Preconditioner(bool modified);
    [CompilerGeneratedAttribute]
public bool get_UseModified();
    [CompilerGeneratedAttribute]
public void set_UseModified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual void Initialize(Matrix`1<Complex> matrix);
    public sealed virtual void Approximate(Vector`1<Complex> input, Vector`1<Complex> result);
    private int Compute(int n, Complex[] a, Int32[] ja, Int32[] ia, Complex[] alu, Int32[] jlu, Int32[] ju, bool modified);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.MlkBiCgStab : object {
    private static int DefaultNumberOfStartingVectors;
    private IList`1<Vector`1<Complex>> _startingVectors;
    private int _numberOfStartingVectors;
    public int NumberOfStartingVectors { get; public set; }
    public IList`1<Vector`1<Complex>> StartingVectors { get; public set; }
    [DebuggerStepThroughAttribute]
public int get_NumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public void set_NumberOfStartingVectors(int value);
    public void ResetNumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public IList`1<Vector`1<Complex>> get_StartingVectors();
    [DebuggerStepThroughAttribute]
public void set_StartingVectors(IList`1<Vector`1<Complex>> value);
    private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static IList`1<Vector`1<Complex>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static Vector`1[] CreateVectorArray(int arraySize, int vectorSize);
    private static void CalculateTrueResidual(Matrix`1<Complex> matrix, Vector`1<Complex> residual, Vector`1<Complex> x, Vector`1<Complex> b);
    public sealed virtual void Solve(Matrix`1<Complex> matrix, Vector`1<Complex> input, Vector`1<Complex> result, Iterator`1<Complex> iterator, IPreconditioner`1<Complex> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex.Solvers.TFQMR : object {
    private static void CalculateTrueResidual(Matrix`1<Complex> matrix, Vector`1<Complex> residual, Vector`1<Complex> x, Vector`1<Complex> b);
    private static bool IsEven(int number);
    public sealed virtual void Solve(Matrix`1<Complex> matrix, Vector`1<Complex> input, Vector`1<Complex> result, Iterator`1<Complex> iterator, IPreconditioner`1<Complex> preconditioner);
}
[DebuggerDisplayAttribute("SparseMatrix {RowCount}x{ColumnCount}-Complex {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Complex.SparseMatrix : Matrix {
    private SparseCompressedRowMatrixStorage`1<Complex> _storage;
    public int NonZerosCount { get; }
    public SparseMatrix(SparseCompressedRowMatrixStorage`1<Complex> storage);
    public SparseMatrix(int order);
    public SparseMatrix(int rows, int columns);
    public int get_NonZerosCount();
    public static SparseMatrix OfMatrix(Matrix`1<Complex> matrix);
    public static SparseMatrix OfArray(Complex[0...,0...] array);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, Complex>> enumerable);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, Complex>> enumerable);
    public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable`1<Complex> rowMajor);
    public static SparseMatrix OfColumnMajor(int rows, int columns, IList`1<Complex> columnMajor);
    public static SparseMatrix OfColumns(IEnumerable`1<IEnumerable`1<Complex>> data);
    public static SparseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex>> data);
    public static SparseMatrix OfColumnArrays(Complex[][] columns);
    public static SparseMatrix OfColumnArrays(IEnumerable`1<Complex[]> columns);
    public static SparseMatrix OfColumnVectors(Vector`1[] columns);
    public static SparseMatrix OfColumnVectors(IEnumerable`1<Vector`1<Complex>> columns);
    public static SparseMatrix OfRows(IEnumerable`1<IEnumerable`1<Complex>> data);
    public static SparseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex>> data);
    public static SparseMatrix OfRowArrays(Complex[][] rows);
    public static SparseMatrix OfRowArrays(IEnumerable`1<Complex[]> rows);
    public static SparseMatrix OfRowVectors(Vector`1[] rows);
    public static SparseMatrix OfRowVectors(IEnumerable`1<Vector`1<Complex>> rows);
    public static SparseMatrix OfDiagonalVector(Vector`1<Complex> diagonal);
    public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector`1<Complex> diagonal);
    public static SparseMatrix OfDiagonalArray(Complex[] diagonal);
    public static SparseMatrix OfDiagonalArray(int rows, int columns, Complex[] diagonal);
    public static SparseMatrix Create(int rows, int columns, Complex value);
    public static SparseMatrix Create(int rows, int columns, Func`3<int, int, Complex> init);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Complex value);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Func`2<int, Complex> init);
    public static SparseMatrix CreateIdentity(int order);
    public virtual Matrix`1<Complex> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<Complex> result);
    private void LowerTriangleImpl(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<Complex> result);
    private void UpperTriangleImpl(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<Complex> result);
    private void StrictlyLowerTriangleImpl(Matrix`1<Complex> result);
    public virtual Matrix`1<Complex> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<Complex> result);
    private void StrictlyUpperTriangleImpl(Matrix`1<Complex> result);
    protected virtual void DoNegate(Matrix`1<Complex> result);
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoAdd(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoSubtract(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Matrix`1<Complex> result);
    protected virtual void DoMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    private void DoMultiplySparse(SparseMatrix other, SparseMatrix result);
    protected virtual void DoMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex> rightSide, Vector`1<Complex> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex> other, Matrix`1<Complex> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex> divisor, Matrix`1<Complex> result);
    public virtual void KroneckerProduct(Matrix`1<Complex> other, Matrix`1<Complex> result);
    public virtual bool IsSymmetric();
    public virtual bool IsHermitian();
    public static SparseMatrix op_Addition(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryPlus(SparseMatrix rightSide);
    public static SparseMatrix op_Subtraction(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryNegation(SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, Complex rightSide);
    public static SparseMatrix op_Multiply(Complex leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseVector op_Multiply(SparseMatrix leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Modulus(SparseMatrix leftSide, Complex rightSide);
    public virtual string ToTypeString();
}
[DebuggerDisplayAttribute("SparseVector {Count}-Complex {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Complex.SparseVector : Vector {
    private SparseVectorStorage`1<Complex> _storage;
    public int NonZerosCount { get; }
    public SparseVector(SparseVectorStorage`1<Complex> storage);
    public SparseVector(int length);
    public int get_NonZerosCount();
    public static SparseVector OfVector(Vector`1<Complex> vector);
    public static SparseVector OfEnumerable(IEnumerable`1<Complex> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, Complex>> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, Complex>> enumerable);
    public static SparseVector Create(int length, Complex value);
    public static SparseVector Create(int length, Func`2<int, Complex> init);
    protected virtual void DoAdd(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoAdd(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoSubtract(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoSubtract(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoNegate(Vector`1<Complex> result);
    protected virtual void DoConjugate(Vector`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Vector`1<Complex> result);
    protected virtual Complex DoDotProduct(Vector`1<Complex> other);
    protected virtual Complex DoConjugateDotProduct(Vector`1<Complex> other);
    public static SparseVector op_Addition(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_UnaryNegation(SparseVector rightSide);
    public static SparseVector op_Subtraction(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, Complex rightSide);
    public static SparseVector op_Multiply(Complex leftSide, SparseVector rightSide);
    public static Complex op_Multiply(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Division(SparseVector leftSide, Complex rightSide);
    public static SparseVector op_Modulus(SparseVector leftSide, Complex rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex Sum();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex> other, Vector`1<Complex> result);
    public static SparseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, SparseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, SparseVector& result);
    public virtual string ToTypeString();
    [CompilerGeneratedAttribute]
private double <InfinityNorm>b__32_0(int i);
}
public abstract class MathNet.Numerics.LinearAlgebra.Complex.Vector : Vector`1<Complex> {
    protected Vector(VectorStorage`1<Complex> storage);
    public virtual void CoerceZero(double threshold);
    protected virtual void DoConjugate(Vector`1<Complex> result);
    protected virtual void DoNegate(Vector`1<Complex> result);
    protected virtual void DoAdd(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoAdd(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoSubtract(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoSubtract(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoMultiply(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoDivide(Complex divisor, Vector`1<Complex> result);
    protected virtual void DoDivideByThis(Complex dividend, Vector`1<Complex> result);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseDivide(Vector`1<Complex> divisor, Vector`1<Complex> result);
    protected virtual void DoPointwisePower(Complex exponent, Vector`1<Complex> result);
    protected virtual void DoPointwisePower(Vector`1<Complex> exponent, Vector`1<Complex> result);
    protected sealed virtual void DoPointwiseModulus(Vector`1<Complex> divisor, Vector`1<Complex> result);
    protected sealed virtual void DoPointwiseRemainder(Vector`1<Complex> divisor, Vector`1<Complex> result);
    protected virtual void DoPointwiseExp(Vector`1<Complex> result);
    protected virtual void DoPointwiseLog(Vector`1<Complex> result);
    protected virtual void DoPointwiseAbs(Vector`1<Complex> result);
    protected virtual void DoPointwiseAcos(Vector`1<Complex> result);
    protected virtual void DoPointwiseAsin(Vector`1<Complex> result);
    protected virtual void DoPointwiseAtan(Vector`1<Complex> result);
    protected virtual void DoPointwiseAtan2(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseAtan2(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoPointwiseCeiling(Vector`1<Complex> result);
    protected virtual void DoPointwiseCos(Vector`1<Complex> result);
    protected virtual void DoPointwiseCosh(Vector`1<Complex> result);
    protected virtual void DoPointwiseFloor(Vector`1<Complex> result);
    protected virtual void DoPointwiseLog10(Vector`1<Complex> result);
    protected virtual void DoPointwiseRound(Vector`1<Complex> result);
    protected virtual void DoPointwiseSign(Vector`1<Complex> result);
    protected virtual void DoPointwiseSin(Vector`1<Complex> result);
    protected virtual void DoPointwiseSinh(Vector`1<Complex> result);
    protected virtual void DoPointwiseSqrt(Vector`1<Complex> result);
    protected virtual void DoPointwiseTan(Vector`1<Complex> result);
    protected virtual void DoPointwiseTanh(Vector`1<Complex> result);
    protected virtual Complex DoDotProduct(Vector`1<Complex> other);
    protected virtual Complex DoConjugateDotProduct(Vector`1<Complex> other);
    protected sealed virtual void DoModulus(Complex divisor, Vector`1<Complex> result);
    protected sealed virtual void DoModulusByThis(Complex dividend, Vector`1<Complex> result);
    protected sealed virtual void DoRemainder(Complex divisor, Vector`1<Complex> result);
    protected sealed virtual void DoRemainderByThis(Complex dividend, Vector`1<Complex> result);
    protected virtual void DoPointwiseMinimum(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoPointwiseMaximum(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Complex scalar, Vector`1<Complex> result);
    protected virtual void DoPointwiseMinimum(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseMaximum(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Vector`1<Complex> other, Vector`1<Complex> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Vector`1<Complex> other, Vector`1<Complex> result);
    public sealed virtual Complex AbsoluteMinimum();
    public virtual int AbsoluteMinimumIndex();
    public virtual Complex AbsoluteMaximum();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual Vector`1<Complex> Normalize(double p);
    [CompilerGeneratedAttribute]
private double <InfinityNorm>b__58_0(int i);
}
internal class MathNet.Numerics.LinearAlgebra.Complex.VectorBuilder : VectorBuilder`1<Complex> {
    public Complex Zero { get; }
    public Complex One { get; }
    public virtual Complex get_Zero();
    public virtual Complex get_One();
    public virtual Vector`1<Complex> Dense(DenseVectorStorage`1<Complex> storage);
    public virtual Vector`1<Complex> Sparse(SparseVectorStorage`1<Complex> storage);
    public virtual Vector`1<Complex> Random(int length, IContinuousDistribution distribution);
}
[DebuggerDisplayAttribute("DenseMatrix {RowCount}x{ColumnCount}-Complex32")]
public class MathNet.Numerics.LinearAlgebra.Complex32.DenseMatrix : Matrix {
    private int _rowCount;
    private int _columnCount;
    private Complex32[] _values;
    public Complex32[] Values { get; }
    public DenseMatrix(DenseColumnMajorMatrixStorage`1<Complex32> storage);
    public DenseMatrix(int order);
    public DenseMatrix(int rows, int columns);
    public DenseMatrix(int rows, int columns, Complex32[] storage);
    public static DenseMatrix OfMatrix(Matrix`1<Complex32> matrix);
    public static DenseMatrix OfArray(Complex32[0...,0...] array);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, Complex32>> enumerable);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, Complex32>> enumerable);
    public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable`1<Complex32> columnMajor);
    public static DenseMatrix OfColumns(IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static DenseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static DenseMatrix OfColumnArrays(Complex32[][] columns);
    public static DenseMatrix OfColumnArrays(IEnumerable`1<Complex32[]> columns);
    public static DenseMatrix OfColumnVectors(Vector`1[] columns);
    public static DenseMatrix OfColumnVectors(IEnumerable`1<Vector`1<Complex32>> columns);
    public static DenseMatrix OfRows(IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static DenseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static DenseMatrix OfRowArrays(Complex32[][] rows);
    public static DenseMatrix OfRowArrays(IEnumerable`1<Complex32[]> rows);
    public static DenseMatrix OfRowVectors(Vector`1[] rows);
    public static DenseMatrix OfRowVectors(IEnumerable`1<Vector`1<Complex32>> rows);
    public static DenseMatrix OfDiagonalVector(Vector`1<Complex32> diagonal);
    public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector`1<Complex32> diagonal);
    public static DenseMatrix OfDiagonalArray(Complex32[] diagonal);
    public static DenseMatrix OfDiagonalArray(int rows, int columns, Complex32[] diagonal);
    public static DenseMatrix Create(int rows, int columns, Complex32 value);
    public static DenseMatrix Create(int rows, int columns, Func`3<int, int, Complex32> init);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Complex32 value);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Func`2<int, Complex32> init);
    public static DenseMatrix CreateIdentity(int order);
    public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    public Complex32[] get_Values();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoNegate(Matrix`1<Complex32> result);
    protected virtual void DoConjugate(Matrix`1<Complex32> result);
    protected virtual void DoAdd(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoAdd(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoDivide(Complex32 divisor, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex32> divisor, Matrix`1<Complex32> result);
    protected virtual void DoPointwisePower(Matrix`1<Complex32> exponent, Matrix`1<Complex32> result);
    public virtual Complex32 Trace();
    public static DenseMatrix op_Addition(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryPlus(DenseMatrix rightSide);
    public static DenseMatrix op_Subtraction(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryNegation(DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, Complex32 rightSide);
    public static DenseMatrix op_Multiply(Complex32 leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseVector op_Multiply(DenseMatrix leftSide, DenseVector rightSide);
    public static DenseVector op_Multiply(DenseVector leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Modulus(DenseMatrix leftSide, Complex32 rightSide);
    public virtual bool IsSymmetric();
    public virtual bool IsHermitian();
    public virtual Cholesky`1<Complex32> Cholesky();
    public virtual LU`1<Complex32> LU();
    public virtual QR`1<Complex32> QR(QRMethod method);
    public virtual GramSchmidt`1<Complex32> GramSchmidt();
    public virtual Svd`1<Complex32> Svd(bool computeVectors);
    public virtual Evd`1<Complex32> Evd(Symmetricity symmetricity);
}
[DebuggerDisplayAttribute("DenseVector {Count}-Complex32")]
public class MathNet.Numerics.LinearAlgebra.Complex32.DenseVector : Vector {
    private int _length;
    private Complex32[] _values;
    public Complex32[] Values { get; }
    public DenseVector(DenseVectorStorage`1<Complex32> storage);
    public DenseVector(int length);
    public DenseVector(Complex32[] storage);
    public static DenseVector OfVector(Vector`1<Complex32> vector);
    public static DenseVector OfArray(Complex32[] array);
    public static DenseVector OfEnumerable(IEnumerable`1<Complex32> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, Complex32>> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, Complex32>> enumerable);
    public static DenseVector Create(int length, Complex32 value);
    public static DenseVector Create(int length, Func`2<int, Complex32> init);
    public static DenseVector CreateRandom(int length, IContinuousDistribution distribution);
    public Complex32[] get_Values();
    public static Complex32[] op_Explicit(DenseVector vector);
    public static DenseVector op_Implicit(Complex32[] array);
    protected virtual void DoAdd(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoAdd(Vector`1<Complex32> other, Vector`1<Complex32> result);
    public static DenseVector op_Addition(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoSubtract(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoSubtract(Vector`1<Complex32> other, Vector`1<Complex32> result);
    public static DenseVector op_UnaryNegation(DenseVector rightSide);
    public static DenseVector op_Subtraction(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoNegate(Vector`1<Complex32> result);
    protected virtual void DoConjugate(Vector`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual Complex32 DoDotProduct(Vector`1<Complex32> other);
    protected virtual Complex32 DoConjugateDotProduct(Vector`1<Complex32> other);
    public static DenseVector op_Multiply(DenseVector leftSide, Complex32 rightSide);
    public static DenseVector op_Multiply(Complex32 leftSide, DenseVector rightSide);
    public static Complex32 op_Multiply(DenseVector leftSide, DenseVector rightSide);
    public static DenseVector op_Division(DenseVector leftSide, Complex32 rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex32 Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseDivide(Vector`1<Complex32> divisor, Vector`1<Complex32> result);
    protected virtual void DoPointwisePower(Vector`1<Complex32> exponent, Vector`1<Complex32> result);
    public static DenseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, DenseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, DenseVector& result);
}
[DebuggerDisplayAttribute("DiagonalMatrix {RowCount}x{ColumnCount}-Complex32")]
public class MathNet.Numerics.LinearAlgebra.Complex32.DiagonalMatrix : Matrix {
    private Complex32[] _data;
    public DiagonalMatrix(DiagonalMatrixStorage`1<Complex32> storage);
    public DiagonalMatrix(int order);
    public DiagonalMatrix(int rows, int columns);
    public DiagonalMatrix(int rows, int columns, Complex32 diagonalValue);
    public DiagonalMatrix(int rows, int columns, Complex32[] diagonalStorage);
    public static DiagonalMatrix OfMatrix(Matrix`1<Complex32> matrix);
    public static DiagonalMatrix OfArray(Complex32[0...,0...] array);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<Tuple`2<int, Complex32>> diagonal);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<ValueTuple`2<int, Complex32>> diagonal);
    public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable`1<Complex32> diagonal);
    public static DiagonalMatrix Create(int rows, int columns, Func`2<int, Complex32> init);
    public static DiagonalMatrix CreateIdentity(int order);
    public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    protected virtual void DoNegate(Matrix`1<Complex32> result);
    protected virtual void DoConjugate(Matrix`1<Complex32> result);
    protected virtual void DoAdd(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoDivide(Complex32 divisor, Matrix`1<Complex32> result);
    protected virtual void DoDivideByThis(Complex32 dividend, Matrix`1<Complex32> result);
    public virtual Complex32 Determinant();
    public virtual Vector`1<Complex32> Diagonal();
    public virtual void SetDiagonal(Complex32[] source);
    public virtual void SetDiagonal(Vector`1<Complex32> source);
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Complex32 ConditionNumber();
    public virtual Matrix`1<Complex32> Inverse();
    public virtual Matrix`1<Complex32> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public virtual void PermuteColumns(Permutation p);
    public virtual void PermuteRows(Permutation p);
    public sealed virtual bool IsSymmetric();
    public sealed virtual bool IsHermitian();
    [CompilerGeneratedAttribute]
private Complex32 <DoMultiply>b__20_0(int i, int _, Complex32 x);
    [CompilerGeneratedAttribute]
private Complex32 <DoMultiply>b__20_1(int i, int _, Complex32 x);
    [CompilerGeneratedAttribute]
private Complex32 <DoTransposeThisAndMultiply>b__23_0(int i, int _, Complex32 x);
    [CompilerGeneratedAttribute]
private Complex32 <DoTransposeThisAndMultiply>b__23_1(int i, int _, Complex32 x);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.Cholesky : Cholesky`1<Complex32> {
    public Complex32 Determinant { get; }
    public Complex32 DeterminantLn { get; }
    protected Cholesky(Matrix`1<Complex32> factor);
    public virtual Complex32 get_Determinant();
    public virtual Complex32 get_DeterminantLn();
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseCholesky : Cholesky {
    private DenseCholesky(Matrix`1<Complex32> factor);
    public static DenseCholesky Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
    public virtual void Factorize(Matrix`1<Complex32> matrix);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseEvd : Evd {
    private DenseEvd(Matrix`1<Complex32> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex32> blockDiagonal, bool isSymmetric);
    public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseGramSchmidt : GramSchmidt {
    private DenseGramSchmidt(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull);
    public static DenseGramSchmidt Create(Matrix`1<Complex32> matrix);
    private static void Factorize(Complex32[] q, int rowsQ, int columnsQ, Complex32[] r);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseLU : LU {
    private DenseLU(Matrix`1<Complex32> factors, Int32[] pivots);
    public static DenseLU Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
    public virtual Matrix`1<Complex32> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseQR : QR {
    [CompilerGeneratedAttribute]
private Complex32[] <Tau>k__BackingField;
    private Complex32[] Tau { get; private set; }
    private DenseQR(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull, QRMethod method, Complex32[] tau);
    [CompilerGeneratedAttribute]
private Complex32[] get_Tau();
    [CompilerGeneratedAttribute]
private void set_Tau(Complex32[] value);
    public static DenseQR Create(DenseMatrix matrix, QRMethod method);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.DenseSvd : Svd {
    private DenseSvd(Vector`1<Complex32> s, Matrix`1<Complex32> u, Matrix`1<Complex32> vt, bool vectorsComputed);
    public static DenseSvd Create(DenseMatrix matrix, bool computeVectors);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.Evd : Evd`1<Complex32> {
    public Complex32 Determinant { get; }
    public int Rank { get; }
    public bool IsFullRank { get; }
    protected Evd(Matrix`1<Complex32> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex32> blockDiagonal, bool isSymmetric);
    public virtual Complex32 get_Determinant();
    public virtual int get_Rank();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.GramSchmidt : GramSchmidt`1<Complex32> {
    public Complex32 Determinant { get; }
    public bool IsFullRank { get; }
    protected GramSchmidt(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull);
    public virtual Complex32 get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.LU : LU`1<Complex32> {
    public Complex32 Determinant { get; }
    protected LU(Matrix`1<Complex32> factors, Int32[] pivots);
    public virtual Complex32 get_Determinant();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.QR : QR`1<Complex32> {
    public Complex32 Determinant { get; }
    public bool IsFullRank { get; }
    protected QR(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull, QRMethod method);
    public virtual Complex32 get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.Svd : Svd`1<Complex32> {
    public int Rank { get; }
    public double L2Norm { get; }
    public Complex32 ConditionNumber { get; }
    public Complex32 Determinant { get; }
    protected Svd(Vector`1<Complex32> s, Matrix`1<Complex32> u, Matrix`1<Complex32> vt, bool vectorsComputed);
    public virtual int get_Rank();
    public virtual double get_L2Norm();
    public virtual Complex32 get_ConditionNumber();
    public virtual Complex32 get_Determinant();
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserCholesky : Cholesky {
    private UserCholesky(Matrix`1<Complex32> factor);
    private static void DoCholesky(Matrix`1<Complex32> factor);
    public static UserCholesky Create(Matrix`1<Complex32> matrix);
    public virtual void Factorize(Matrix`1<Complex32> matrix);
    private static void DoCholeskyStep(Matrix`1<Complex32> data, int rowDim, int firstCol, int colLimit, Complex32[] multipliers, int availableCores);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserEvd : Evd {
    private UserEvd(Matrix`1<Complex32> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<Complex32> blockDiagonal, bool isSymmetric);
    public static UserEvd Create(Matrix`1<Complex32> matrix, Symmetricity symmetricity);
    private static void SymmetricTridiagonalize(Complex32[0...,0...] matrixA, Single[] d, Single[] e, Complex32[] tau, int order);
    private static void SymmetricDiagonalize(Matrix`1<Complex32> eigenVectors, Single[] d, Single[] e, int order);
    private static void SymmetricUntridiagonalize(Matrix`1<Complex32> eigenVectors, Complex32[0...,0...] matrixA, Complex32[] tau, int order);
    private static void NonsymmetricReduceToHessenberg(Matrix`1<Complex32> eigenVectors, Complex32[0...,0...] matrixH, int order);
    private static void NonsymmetricReduceHessenberToRealSchur(Matrix`1<Complex32> eigenVectors, Vector`1<Complex> eigenValues, Complex32[0...,0...] matrixH, int order);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserGramSchmidt : GramSchmidt {
    private UserGramSchmidt(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull);
    public static UserGramSchmidt Create(Matrix`1<Complex32> matrix);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserLU : LU {
    private UserLU(Matrix`1<Complex32> factors, Int32[] pivots);
    public static UserLU Create(Matrix`1<Complex32> matrix);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
    public virtual Matrix`1<Complex32> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserQR : QR {
    private UserQR(Matrix`1<Complex32> q, Matrix`1<Complex32> rFull, QRMethod method);
    public static UserQR Create(Matrix`1<Complex32> matrix, QRMethod method);
    private static Complex32[] GenerateColumn(Matrix`1<Complex32> a, int row, int column);
    private static void ComputeQR(Complex32[] u, Matrix`1<Complex32> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.Factorization.UserSvd : Svd {
    private UserSvd(Vector`1<Complex32> s, Matrix`1<Complex32> u, Matrix`1<Complex32> vt, bool vectorsComputed);
    public static UserSvd Create(Matrix`1<Complex32> matrix, bool computeVectors);
    private static Complex32 Csign(Complex32 z1, Complex32 z2);
    private static void Swap(Matrix`1<Complex32> a, int rowCount, int columnA, int columnB);
    private static void CscalColumn(Matrix`1<Complex32> a, int rowCount, int column, int rowStart, Complex32 z);
    private static void CscalVector(Complex32[] a, int start, Complex32 z);
    private static void Srotg(Single& da, Single& db, Single& c, Single& s);
    private static float Cnrm2Column(Matrix`1<Complex32> a, int rowCount, int column, int rowStart);
    private static float Cnrm2Vector(Complex32[] a, int rowStart);
    private static Complex32 Cdotc(Matrix`1<Complex32> a, int rowCount, int columnA, int columnB, int rowStart);
    private static void Csrot(Matrix`1<Complex32> a, int rowCount, int columnA, int columnB, float c, float s);
    public virtual void Solve(Matrix`1<Complex32> input, Matrix`1<Complex32> result);
    public virtual void Solve(Vector`1<Complex32> input, Vector`1<Complex32> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Complex32.Matrix : Matrix`1<Complex32> {
    protected Matrix(MatrixStorage`1<Complex32> storage);
    public virtual void CoerceZero(double threshold);
    public sealed virtual Matrix`1<Complex32> ConjugateTranspose();
    public sealed virtual void ConjugateTranspose(Matrix`1<Complex32> result);
    protected virtual void DoConjugate(Matrix`1<Complex32> result);
    protected virtual void DoNegate(Matrix`1<Complex32> result);
    protected virtual void DoAdd(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoAdd(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoDivide(Complex32 divisor, Matrix`1<Complex32> result);
    protected virtual void DoDivideByThis(Complex32 dividend, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoConjugateTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex32> divisor, Matrix`1<Complex32> result);
    protected virtual void DoPointwisePower(Complex32 exponent, Matrix`1<Complex32> result);
    protected virtual void DoPointwisePower(Matrix`1<Complex32> exponent, Matrix`1<Complex32> result);
    protected sealed virtual void DoPointwiseModulus(Matrix`1<Complex32> divisor, Matrix`1<Complex32> result);
    protected sealed virtual void DoPointwiseRemainder(Matrix`1<Complex32> divisor, Matrix`1<Complex32> result);
    protected sealed virtual void DoModulus(Complex32 divisor, Matrix`1<Complex32> result);
    protected sealed virtual void DoModulusByThis(Complex32 dividend, Matrix`1<Complex32> result);
    protected sealed virtual void DoRemainder(Complex32 divisor, Matrix`1<Complex32> result);
    protected sealed virtual void DoRemainderByThis(Complex32 dividend, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseExp(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseLog(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAbs(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAcos(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAsin(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAtan(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAtan2(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseCeiling(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseCos(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseCosh(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseFloor(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseLog10(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseRound(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseSign(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseSin(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseSinh(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseSqrt(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseTan(Matrix`1<Complex32> result);
    protected virtual void DoPointwiseTanh(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> PseudoInverse();
    public virtual Complex32 Trace();
    protected virtual void DoPointwiseMinimum(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseMaximum(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseMinimum(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseMaximum(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Vector`1<double> RowNorms(double norm);
    public virtual Vector`1<double> ColumnNorms(double norm);
    public sealed virtual Matrix`1<Complex32> NormalizeRows(double norm);
    public sealed virtual Matrix`1<Complex32> NormalizeColumns(double norm);
    public virtual Vector`1<Complex32> RowSums();
    public virtual Vector`1<Complex32> RowAbsoluteSums();
    public virtual Vector`1<Complex32> ColumnSums();
    public virtual Vector`1<Complex32> ColumnAbsoluteSums();
    public virtual bool IsHermitian();
    public virtual Cholesky`1<Complex32> Cholesky();
    public virtual LU`1<Complex32> LU();
    public virtual QR`1<Complex32> QR(QRMethod method);
    public virtual GramSchmidt`1<Complex32> GramSchmidt();
    public virtual Svd`1<Complex32> Svd(bool computeVectors);
    public virtual Evd`1<Complex32> Evd(Symmetricity symmetricity);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.MatrixBuilder : MatrixBuilder`1<Complex32> {
    public Complex32 Zero { get; }
    public Complex32 One { get; }
    public virtual Complex32 get_Zero();
    public virtual Complex32 get_One();
    public virtual Matrix`1<Complex32> Dense(DenseColumnMajorMatrixStorage`1<Complex32> storage);
    public virtual Matrix`1<Complex32> Sparse(SparseCompressedRowMatrixStorage`1<Complex32> storage);
    public virtual Matrix`1<Complex32> Diagonal(DiagonalMatrixStorage`1<Complex32> storage);
    public virtual Matrix`1<Complex32> Random(int rows, int columns, IContinuousDistribution distribution);
    public virtual IIterationStopCriterion`1[] IterativeSolverStopCriteria(int maxIterations);
    internal virtual Complex32 Add(Complex32 x, Complex32 y);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.BiCgStab : object {
    private static void CalculateTrueResidual(Matrix`1<Complex32> matrix, Vector`1<Complex32> residual, Vector`1<Complex32> x, Vector`1<Complex32> b);
    public sealed virtual void Solve(Matrix`1<Complex32> matrix, Vector`1<Complex32> input, Vector`1<Complex32> result, Iterator`1<Complex32> iterator, IPreconditioner`1<Complex32> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.CompositeSolver : object {
    private List`1<Tuple`2<IIterativeSolver`1<Complex32>, IPreconditioner`1<Complex32>>> _solvers;
    public CompositeSolver(IEnumerable`1<IIterativeSolverSetup`1<Complex32>> solvers);
    public sealed virtual void Solve(Matrix`1<Complex32> matrix, Vector`1<Complex32> input, Vector`1<Complex32> result, Iterator`1<Complex32> iterator, IPreconditioner`1<Complex32> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.DiagonalPreconditioner : object {
    private Complex32[] _inverseDiagonals;
    internal DiagonalMatrix DiagonalEntries();
    public sealed virtual void Initialize(Matrix`1<Complex32> matrix);
    public sealed virtual void Approximate(Vector`1<Complex32> rhs, Vector`1<Complex32> lhs);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.GpBiCg : object {
    private int _numberOfBiCgStabSteps;
    private int _numberOfGpbiCgSteps;
    public int NumberOfBiCgStabSteps { get; public set; }
    public int NumberOfGpBiCgSteps { get; public set; }
    public int get_NumberOfBiCgStabSteps();
    public void set_NumberOfBiCgStabSteps(int value);
    public int get_NumberOfGpBiCgSteps();
    public void set_NumberOfGpBiCgSteps(int value);
    private static void CalculateTrueResidual(Matrix`1<Complex32> matrix, Vector`1<Complex32> residual, Vector`1<Complex32> x, Vector`1<Complex32> b);
    private bool ShouldRunBiCgStabSteps(int iterationNumber);
    public sealed virtual void Solve(Matrix`1<Complex32> matrix, Vector`1<Complex32> input, Vector`1<Complex32> result, Iterator`1<Complex32> iterator, IPreconditioner`1<Complex32> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.ILU0Preconditioner : object {
    private SparseMatrix _decompositionLU;
    internal Matrix`1<Complex32> UpperTriangle();
    internal Matrix`1<Complex32> LowerTriangle();
    public sealed virtual void Initialize(Matrix`1<Complex32> matrix);
    public sealed virtual void Approximate(Vector`1<Complex32> rhs, Vector`1<Complex32> lhs);
}
internal static class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.ILUTPElementSorter : object {
    public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex32> values);
    private static void HeapSortDoublesIndices(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex32> values);
    private static void BuildDoubleIndexHeap(int start, int count, Int32[] sortedIndices, Vector`1<Complex32> values);
    private static void SiftDoubleIndices(Int32[] sortedIndices, Vector`1<Complex32> values, int begin, int count);
    public static void SortIntegersDecreasing(Int32[] values);
    private static void HeapSortIntegers(Int32[] values, int count);
    private static void BuildHeap(Int32[] values, int start, int count);
    private static void Sift(Int32[] values, int start, int count);
    private static void Exchange(Int32[] values, int first, int second);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.ILUTPPreconditioner : object {
    public static double DefaultFillLevel;
    public static double DefaultDropTolerance;
    private SparseMatrix _upper;
    private SparseMatrix _lower;
    private Int32[] _pivots;
    private double _fillLevel;
    private double _dropTolerance;
    private double _pivotTolerance;
    public double FillLevel { get; public set; }
    public double DropTolerance { get; public set; }
    public double PivotTolerance { get; public set; }
    public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance);
    public double get_FillLevel();
    public void set_FillLevel(double value);
    public double get_DropTolerance();
    public void set_DropTolerance(double value);
    public double get_PivotTolerance();
    public void set_PivotTolerance(double value);
    internal Matrix`1<Complex32> UpperTriangle();
    internal Matrix`1<Complex32> LowerTriangle();
    internal Int32[] Pivots();
    public sealed virtual void Initialize(Matrix`1<Complex32> matrix);
    private void PivotRow(Vector`1<Complex32> row);
    private bool PivotMapFound(Dictionary`2<int, int> knownPivots, int currentItem);
    private static void SwapColumns(Matrix`1<Complex32> matrix, int firstColumn, int secondColumn);
    private static void FindLargestItems(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<Complex32> values);
    public sealed virtual void Approximate(Vector`1<Complex32> rhs, Vector`1<Complex32> lhs);
    private void Pivot(Vector`1<Complex32> vector, Vector`1<Complex32> result);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.MILU0Preconditioner : object {
    private Complex32[] _alu;
    private Int32[] _jlu;
    private Int32[] _diag;
    [CompilerGeneratedAttribute]
private bool <UseModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool UseModified { get; public set; }
    public bool IsInitialized { get; private set; }
    public MILU0Preconditioner(bool modified);
    [CompilerGeneratedAttribute]
public bool get_UseModified();
    [CompilerGeneratedAttribute]
public void set_UseModified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual void Initialize(Matrix`1<Complex32> matrix);
    public sealed virtual void Approximate(Vector`1<Complex32> input, Vector`1<Complex32> result);
    private int Compute(int n, Complex32[] a, Int32[] ja, Int32[] ia, Complex32[] alu, Int32[] jlu, Int32[] ju, bool modified);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.MlkBiCgStab : object {
    private static int DefaultNumberOfStartingVectors;
    private IList`1<Vector`1<Complex32>> _startingVectors;
    private int _numberOfStartingVectors;
    public int NumberOfStartingVectors { get; public set; }
    public IList`1<Vector`1<Complex32>> StartingVectors { get; public set; }
    [DebuggerStepThroughAttribute]
public int get_NumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public void set_NumberOfStartingVectors(int value);
    public void ResetNumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public IList`1<Vector`1<Complex32>> get_StartingVectors();
    [DebuggerStepThroughAttribute]
public void set_StartingVectors(IList`1<Vector`1<Complex32>> value);
    private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static IList`1<Vector`1<Complex32>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static Vector`1[] CreateVectorArray(int arraySize, int vectorSize);
    private static void CalculateTrueResidual(Matrix`1<Complex32> matrix, Vector`1<Complex32> residual, Vector`1<Complex32> x, Vector`1<Complex32> b);
    public sealed virtual void Solve(Matrix`1<Complex32> matrix, Vector`1<Complex32> input, Vector`1<Complex32> result, Iterator`1<Complex32> iterator, IPreconditioner`1<Complex32> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Complex32.Solvers.TFQMR : object {
    private static void CalculateTrueResidual(Matrix`1<Complex32> matrix, Vector`1<Complex32> residual, Vector`1<Complex32> x, Vector`1<Complex32> b);
    private static bool IsEven(int number);
    public sealed virtual void Solve(Matrix`1<Complex32> matrix, Vector`1<Complex32> input, Vector`1<Complex32> result, Iterator`1<Complex32> iterator, IPreconditioner`1<Complex32> preconditioner);
}
[DebuggerDisplayAttribute("SparseMatrix {RowCount}x{ColumnCount}-Complex32 {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Complex32.SparseMatrix : Matrix {
    private SparseCompressedRowMatrixStorage`1<Complex32> _storage;
    public int NonZerosCount { get; }
    public SparseMatrix(SparseCompressedRowMatrixStorage`1<Complex32> storage);
    public SparseMatrix(int order);
    public SparseMatrix(int rows, int columns);
    public int get_NonZerosCount();
    public static SparseMatrix OfMatrix(Matrix`1<Complex32> matrix);
    public static SparseMatrix OfArray(Complex32[0...,0...] array);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, Complex32>> enumerable);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, Complex32>> enumerable);
    public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable`1<Complex32> rowMajor);
    public static SparseMatrix OfColumnMajor(int rows, int columns, IList`1<Complex32> columnMajor);
    public static SparseMatrix OfColumns(IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static SparseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static SparseMatrix OfColumnArrays(Complex32[][] columns);
    public static SparseMatrix OfColumnArrays(IEnumerable`1<Complex32[]> columns);
    public static SparseMatrix OfColumnVectors(Vector`1[] columns);
    public static SparseMatrix OfColumnVectors(IEnumerable`1<Vector`1<Complex32>> columns);
    public static SparseMatrix OfRows(IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static SparseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<Complex32>> data);
    public static SparseMatrix OfRowArrays(Complex32[][] rows);
    public static SparseMatrix OfRowArrays(IEnumerable`1<Complex32[]> rows);
    public static SparseMatrix OfRowVectors(Vector`1[] rows);
    public static SparseMatrix OfRowVectors(IEnumerable`1<Vector`1<Complex32>> rows);
    public static SparseMatrix OfDiagonalVector(Vector`1<Complex32> diagonal);
    public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector`1<Complex32> diagonal);
    public static SparseMatrix OfDiagonalArray(Complex32[] diagonal);
    public static SparseMatrix OfDiagonalArray(int rows, int columns, Complex32[] diagonal);
    public static SparseMatrix Create(int rows, int columns, Complex32 value);
    public static SparseMatrix Create(int rows, int columns, Func`3<int, int, Complex32> init);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Complex32 value);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Func`2<int, Complex32> init);
    public static SparseMatrix CreateIdentity(int order);
    public virtual Matrix`1<Complex32> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<Complex32> result);
    private void LowerTriangleImpl(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<Complex32> result);
    private void UpperTriangleImpl(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<Complex32> result);
    private void StrictlyLowerTriangleImpl(Matrix`1<Complex32> result);
    public virtual Matrix`1<Complex32> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<Complex32> result);
    private void StrictlyUpperTriangleImpl(Matrix`1<Complex32> result);
    protected virtual void DoNegate(Matrix`1<Complex32> result);
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoAdd(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoSubtract(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Matrix`1<Complex32> result);
    protected virtual void DoMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    private void DoMultiplySparse(SparseMatrix other, SparseMatrix result);
    protected virtual void DoMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<Complex32> rightSide, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    protected virtual void DoPointwiseDivide(Matrix`1<Complex32> divisor, Matrix`1<Complex32> result);
    public virtual void KroneckerProduct(Matrix`1<Complex32> other, Matrix`1<Complex32> result);
    public virtual bool IsSymmetric();
    public virtual bool IsHermitian();
    public static SparseMatrix op_Addition(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryPlus(SparseMatrix rightSide);
    public static SparseMatrix op_Subtraction(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryNegation(SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, Complex32 rightSide);
    public static SparseMatrix op_Multiply(Complex32 leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseVector op_Multiply(SparseMatrix leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Modulus(SparseMatrix leftSide, Complex32 rightSide);
    public virtual string ToTypeString();
}
[DebuggerDisplayAttribute("SparseVector {Count}-Complex32 {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Complex32.SparseVector : Vector {
    private SparseVectorStorage`1<Complex32> _storage;
    public int NonZerosCount { get; }
    public SparseVector(SparseVectorStorage`1<Complex32> storage);
    public SparseVector(int length);
    public int get_NonZerosCount();
    public static SparseVector OfVector(Vector`1<Complex32> vector);
    public static SparseVector OfEnumerable(IEnumerable`1<Complex32> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, Complex32>> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, Complex32>> enumerable);
    public static SparseVector Create(int length, Complex32 value);
    public static SparseVector Create(int length, Func`2<int, Complex32> init);
    protected virtual void DoAdd(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoAdd(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoSubtract(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoSubtract(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoNegate(Vector`1<Complex32> result);
    protected virtual void DoConjugate(Vector`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual Complex32 DoDotProduct(Vector`1<Complex32> other);
    protected virtual Complex32 DoConjugateDotProduct(Vector`1<Complex32> other);
    public static SparseVector op_Addition(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_UnaryNegation(SparseVector rightSide);
    public static SparseVector op_Subtraction(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, Complex32 rightSide);
    public static SparseVector op_Multiply(Complex32 leftSide, SparseVector rightSide);
    public static Complex32 op_Multiply(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Division(SparseVector leftSide, Complex32 rightSide);
    public static SparseVector op_Modulus(SparseVector leftSide, Complex32 rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex32 Sum();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex32> other, Vector`1<Complex32> result);
    public static SparseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, SparseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, SparseVector& result);
    public virtual string ToTypeString();
    [CompilerGeneratedAttribute]
private float <InfinityNorm>b__32_0(int i);
}
public abstract class MathNet.Numerics.LinearAlgebra.Complex32.Vector : Vector`1<Complex32> {
    protected Vector(VectorStorage`1<Complex32> storage);
    public virtual void CoerceZero(double threshold);
    protected virtual void DoConjugate(Vector`1<Complex32> result);
    protected virtual void DoNegate(Vector`1<Complex32> result);
    protected virtual void DoAdd(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoAdd(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoSubtract(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoSubtract(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoMultiply(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoDivide(Complex32 divisor, Vector`1<Complex32> result);
    protected virtual void DoDivideByThis(Complex32 dividend, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMultiply(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseDivide(Vector`1<Complex32> divisor, Vector`1<Complex32> result);
    protected virtual void DoPointwisePower(Complex32 exponent, Vector`1<Complex32> result);
    protected virtual void DoPointwisePower(Vector`1<Complex32> exponent, Vector`1<Complex32> result);
    protected sealed virtual void DoPointwiseModulus(Vector`1<Complex32> divisor, Vector`1<Complex32> result);
    protected sealed virtual void DoPointwiseRemainder(Vector`1<Complex32> divisor, Vector`1<Complex32> result);
    protected virtual void DoPointwiseExp(Vector`1<Complex32> result);
    protected virtual void DoPointwiseLog(Vector`1<Complex32> result);
    protected virtual void DoPointwiseAbs(Vector`1<Complex32> result);
    protected virtual void DoPointwiseAcos(Vector`1<Complex32> result);
    protected virtual void DoPointwiseAsin(Vector`1<Complex32> result);
    protected virtual void DoPointwiseAtan(Vector`1<Complex32> result);
    protected virtual void DoPointwiseAtan2(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseAtan2(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoPointwiseCeiling(Vector`1<Complex32> result);
    protected virtual void DoPointwiseCos(Vector`1<Complex32> result);
    protected virtual void DoPointwiseCosh(Vector`1<Complex32> result);
    protected virtual void DoPointwiseFloor(Vector`1<Complex32> result);
    protected virtual void DoPointwiseLog10(Vector`1<Complex32> result);
    protected virtual void DoPointwiseRound(Vector`1<Complex32> result);
    protected virtual void DoPointwiseSign(Vector`1<Complex32> result);
    protected virtual void DoPointwiseSin(Vector`1<Complex32> result);
    protected virtual void DoPointwiseSinh(Vector`1<Complex32> result);
    protected virtual void DoPointwiseSqrt(Vector`1<Complex32> result);
    protected virtual void DoPointwiseTan(Vector`1<Complex32> result);
    protected virtual void DoPointwiseTanh(Vector`1<Complex32> result);
    protected virtual Complex32 DoDotProduct(Vector`1<Complex32> other);
    protected virtual Complex32 DoConjugateDotProduct(Vector`1<Complex32> other);
    protected sealed virtual void DoModulus(Complex32 divisor, Vector`1<Complex32> result);
    protected sealed virtual void DoModulusByThis(Complex32 dividend, Vector`1<Complex32> result);
    protected sealed virtual void DoRemainder(Complex32 divisor, Vector`1<Complex32> result);
    protected sealed virtual void DoRemainderByThis(Complex32 dividend, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMinimum(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMaximum(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Complex32 scalar, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMinimum(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseMaximum(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Vector`1<Complex32> other, Vector`1<Complex32> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Vector`1<Complex32> other, Vector`1<Complex32> result);
    public sealed virtual Complex32 AbsoluteMinimum();
    public virtual int AbsoluteMinimumIndex();
    public virtual Complex32 AbsoluteMaximum();
    public virtual int AbsoluteMaximumIndex();
    public virtual Complex32 Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual Vector`1<Complex32> Normalize(double p);
    [CompilerGeneratedAttribute]
private float <InfinityNorm>b__58_0(int i);
}
internal class MathNet.Numerics.LinearAlgebra.Complex32.VectorBuilder : VectorBuilder`1<Complex32> {
    public Complex32 Zero { get; }
    public Complex32 One { get; }
    public virtual Complex32 get_Zero();
    public virtual Complex32 get_One();
    public virtual Vector`1<Complex32> Dense(DenseVectorStorage`1<Complex32> storage);
    public virtual Vector`1<Complex32> Sparse(SparseVectorStorage`1<Complex32> storage);
    public virtual Vector`1<Complex32> Random(int length, IContinuousDistribution distribution);
}
public static class MathNet.Numerics.LinearAlgebra.CreateMatrix : object {
    public static Matrix`1<T> WithStorage(MatrixStorage`1<T> storage);
    public static Matrix`1<T> SameAs(Matrix`1<TU> example, int rows, int columns, bool fullyMutable);
    public static Matrix`1<T> SameAs(Matrix`1<TU> example);
    public static Matrix`1<T> SameAs(Vector`1<T> example, int rows, int columns);
    public static Matrix`1<T> SameAs(Matrix`1<T> example, Matrix`1<T> otherExample, int rows, int columns, bool fullyMutable);
    public static Matrix`1<T> SameAs(Matrix`1<T> example, Matrix`1<T> otherExample);
    public static Matrix`1<T> Random(int rows, int columns, IContinuousDistribution distribution);
    public static Matrix`1<T> Random(int rows, int columns);
    public static Matrix`1<T> Random(int rows, int columns, int seed);
    public static Matrix`1<T> RandomPositiveDefinite(int order, IContinuousDistribution distribution);
    public static Matrix`1<T> RandomPositiveDefinite(int order);
    public static Matrix`1<T> RandomPositiveDefinite(int order, int seed);
    public static Matrix`1<T> Dense(DenseColumnMajorMatrixStorage`1<T> storage);
    public static Matrix`1<T> Dense(int rows, int columns);
    public static Matrix`1<T> Dense(int rows, int columns, T[] storage);
    public static Matrix`1<T> Dense(int rows, int columns, T value);
    public static Matrix`1<T> Dense(int rows, int columns, Func`3<int, int, T> init);
    public static Matrix`1<T> DenseDiagonal(int rows, int columns, T value);
    public static Matrix`1<T> DenseDiagonal(int order, T value);
    public static Matrix`1<T> DenseDiagonal(int rows, int columns, Func`2<int, T> init);
    public static Matrix`1<T> DenseIdentity(int rows, int columns);
    public static Matrix`1<T> DenseIdentity(int order);
    public static Matrix`1<T> DenseOfMatrix(Matrix`1<T> matrix);
    public static Matrix`1<T> DenseOfArray(T[0...,0...] array);
    public static Matrix`1<T> DenseOfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> enumerable);
    public static Matrix`1<T> DenseOfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> enumerable);
    public static Matrix`1<T> DenseOfColumnMajor(int rows, int columns, IEnumerable`1<T> columnMajor);
    public static Matrix`1<T> DenseOfColumns(IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> DenseOfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> DenseOfColumnArrays(T[][] columns);
    public static Matrix`1<T> DenseOfColumnArrays(IEnumerable`1<T[]> columns);
    public static Matrix`1<T> DenseOfColumnVectors(Vector`1[] columns);
    public static Matrix`1<T> DenseOfColumnVectors(IEnumerable`1<Vector`1<T>> columns);
    public static Matrix`1<T> DenseOfRows(IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> DenseOfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> DenseOfRowArrays(T[][] rows);
    public static Matrix`1<T> DenseOfRowArrays(IEnumerable`1<T[]> rows);
    public static Matrix`1<T> DenseOfRowVectors(Vector`1[] rows);
    public static Matrix`1<T> DenseOfRowVectors(IEnumerable`1<Vector`1<T>> rows);
    public static Matrix`1<T> DenseOfDiagonalVector(Vector`1<T> diagonal);
    public static Matrix`1<T> DenseOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public static Matrix`1<T> DenseOfDiagonalArray(T[] diagonal);
    public static Matrix`1<T> DenseOfDiagonalArray(int rows, int columns, T[] diagonal);
    public static Matrix`1<T> DenseOfMatrixArray(Matrix`1[0...,0...] matrices);
    public static Matrix`1<T> Sparse(SparseCompressedRowMatrixStorage`1<T> storage);
    public static Matrix`1<T> Sparse(int rows, int columns);
    public static Matrix`1<T> Sparse(int rows, int columns, T value);
    public static Matrix`1<T> Sparse(int rows, int columns, Func`3<int, int, T> init);
    public static Matrix`1<T> SparseDiagonal(int rows, int columns, T value);
    public static Matrix`1<T> SparseDiagonal(int order, T value);
    public static Matrix`1<T> SparseDiagonal(int rows, int columns, Func`2<int, T> init);
    public static Matrix`1<T> SparseIdentity(int rows, int columns);
    public static Matrix`1<T> SparseIdentity(int order);
    public static Matrix`1<T> SparseOfMatrix(Matrix`1<T> matrix);
    public static Matrix`1<T> SparseOfArray(T[0...,0...] array);
    public static Matrix`1<T> SparseOfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> enumerable);
    public static Matrix`1<T> SparseOfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> enumerable);
    public static Matrix`1<T> SparseOfRowMajor(int rows, int columns, IEnumerable`1<T> rowMajor);
    public static Matrix`1<T> SparseOfColumnMajor(int rows, int columns, IList`1<T> columnMajor);
    public static Matrix`1<T> SparseOfColumns(IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> SparseOfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> SparseOfColumnArrays(T[][] columns);
    public static Matrix`1<T> SparseOfColumnArrays(IEnumerable`1<T[]> columns);
    public static Matrix`1<T> SparseOfColumnVectors(Vector`1[] columns);
    public static Matrix`1<T> SparseOfColumnVectors(IEnumerable`1<Vector`1<T>> columns);
    public static Matrix`1<T> SparseOfRows(IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> SparseOfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static Matrix`1<T> SparseOfRowArrays(T[][] rows);
    public static Matrix`1<T> SparseOfRowArrays(IEnumerable`1<T[]> rows);
    public static Matrix`1<T> SparseOfRowVectors(Vector`1[] rows);
    public static Matrix`1<T> SparseOfRowVectors(IEnumerable`1<Vector`1<T>> rows);
    public static Matrix`1<T> SparseOfDiagonalVector(Vector`1<T> diagonal);
    public static Matrix`1<T> SparseOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public static Matrix`1<T> SparseOfDiagonalArray(T[] diagonal);
    public static Matrix`1<T> SparseOfDiagonalArray(int rows, int columns, T[] diagonal);
    public static Matrix`1<T> SparseOfMatrixArray(Matrix`1[0...,0...] matrices);
    public static Matrix`1<T> SparseFromCoordinateFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnIndices, T[] values);
    public static Matrix`1<T> SparseFromCompressedSparseRowFormat(int rows, int columns, int valueCount, Int32[] rowPointers, Int32[] columnIndices, T[] values);
    public static Matrix`1<T> SparseFromCompressedSparseColumnFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnPointers, T[] values);
    public static Matrix`1<T> Diagonal(DiagonalMatrixStorage`1<T> storage);
    public static Matrix`1<T> Diagonal(int rows, int columns);
    public static Matrix`1<T> Diagonal(int rows, int columns, T[] storage);
    public static Matrix`1<T> Diagonal(T[] storage);
    public static Matrix`1<T> Diagonal(int rows, int columns, T value);
    public static Matrix`1<T> Diagonal(int rows, int columns, Func`2<int, T> init);
    public static Matrix`1<T> DiagonalIdentity(int rows, int columns);
    public static Matrix`1<T> DiagonalIdentity(int order);
    public static Matrix`1<T> DiagonalOfDiagonalVector(Vector`1<T> diagonal);
    public static Matrix`1<T> DiagonalOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public static Matrix`1<T> DiagonalOfDiagonalArray(T[] diagonal);
    public static Matrix`1<T> DiagonalOfDiagonalArray(int rows, int columns, T[] diagonal);
}
public static class MathNet.Numerics.LinearAlgebra.CreateVector : object {
    public static Vector`1<T> WithStorage(VectorStorage`1<T> storage);
    public static Vector`1<T> SameAs(Vector`1<TU> example, int length);
    public static Vector`1<T> SameAs(Vector`1<TU> example);
    public static Vector`1<T> SameAs(Matrix`1<TU> example, int length);
    public static Vector`1<T> SameAs(Vector`1<T> example, Vector`1<T> otherExample, int length);
    public static Vector`1<T> SameAs(Vector`1<T> example, Vector`1<T> otherExample);
    public static Vector`1<T> SameAs(Matrix`1<T> matrix, Vector`1<T> vector, int length);
    public static Vector`1<T> Random(int length, IContinuousDistribution distribution);
    public static Vector`1<T> Random(int length);
    public static Vector`1<T> Random(int length, int seed);
    public static Vector`1<T> Dense(DenseVectorStorage`1<T> storage);
    public static Vector`1<T> Dense(int size);
    public static Vector`1<T> Dense(T[] array);
    public static Vector`1<T> Dense(int length, T value);
    public static Vector`1<T> Dense(int length, Func`2<int, T> init);
    public static Vector`1<T> DenseOfVector(Vector`1<T> vector);
    public static Vector`1<T> DenseOfArray(T[] array);
    public static Vector`1<T> DenseOfEnumerable(IEnumerable`1<T> enumerable);
    public static Vector`1<T> DenseOfIndexed(int length, IEnumerable`1<Tuple`2<int, T>> enumerable);
    public static Vector`1<T> DenseOfIndexed(int length, IEnumerable`1<ValueTuple`2<int, T>> enumerable);
    public static Vector`1<T> Sparse(SparseVectorStorage`1<T> storage);
    public static Vector`1<T> Sparse(int size);
    public static Vector`1<T> Sparse(int length, T value);
    public static Vector`1<T> Sparse(int length, Func`2<int, T> init);
    public static Vector`1<T> SparseOfVector(Vector`1<T> vector);
    public static Vector`1<T> SparseOfArray(T[] array);
    public static Vector`1<T> SparseOfEnumerable(IEnumerable`1<T> enumerable);
    public static Vector`1<T> SparseOfIndexed(int length, IEnumerable`1<Tuple`2<int, T>> enumerable);
    public static Vector`1<T> SparseOfIndexed(int length, IEnumerable`1<ValueTuple`2<int, T>> enumerable);
}
[DebuggerDisplayAttribute("DenseMatrix {RowCount}x{ColumnCount}-Double")]
public class MathNet.Numerics.LinearAlgebra.Double.DenseMatrix : Matrix {
    private int _rowCount;
    private int _columnCount;
    private Double[] _values;
    public Double[] Values { get; }
    public DenseMatrix(DenseColumnMajorMatrixStorage`1<double> storage);
    public DenseMatrix(int order);
    public DenseMatrix(int rows, int columns);
    public DenseMatrix(int rows, int columns, Double[] storage);
    public static DenseMatrix OfMatrix(Matrix`1<double> matrix);
    public static DenseMatrix OfArray(Double[0...,0...] array);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, double>> enumerable);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, double>> enumerable);
    public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable`1<double> columnMajor);
    public static DenseMatrix OfColumns(IEnumerable`1<IEnumerable`1<double>> data);
    public static DenseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<double>> data);
    public static DenseMatrix OfColumnArrays(Double[][] columns);
    public static DenseMatrix OfColumnArrays(IEnumerable`1<Double[]> columns);
    public static DenseMatrix OfColumnVectors(Vector`1[] columns);
    public static DenseMatrix OfColumnVectors(IEnumerable`1<Vector`1<double>> columns);
    public static DenseMatrix OfRows(IEnumerable`1<IEnumerable`1<double>> data);
    public static DenseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<double>> data);
    public static DenseMatrix OfRowArrays(Double[][] rows);
    public static DenseMatrix OfRowArrays(IEnumerable`1<Double[]> rows);
    public static DenseMatrix OfRowVectors(Vector`1[] rows);
    public static DenseMatrix OfRowVectors(IEnumerable`1<Vector`1<double>> rows);
    public static DenseMatrix OfDiagonalVector(Vector`1<double> diagonal);
    public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector`1<double> diagonal);
    public static DenseMatrix OfDiagonalArray(Double[] diagonal);
    public static DenseMatrix OfDiagonalArray(int rows, int columns, Double[] diagonal);
    public static DenseMatrix Create(int rows, int columns, double value);
    public static DenseMatrix Create(int rows, int columns, Func`3<int, int, double> init);
    public static DenseMatrix CreateDiagonal(int rows, int columns, double value);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Func`2<int, double> init);
    public static DenseMatrix CreateIdentity(int order);
    public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    public Double[] get_Values();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoNegate(Matrix`1<double> result);
    protected virtual void DoAdd(double scalar, Matrix`1<double> result);
    protected virtual void DoAdd(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoSubtract(double scalar, Matrix`1<double> result);
    protected virtual void DoSubtract(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoMultiply(double scalar, Matrix`1<double> result);
    protected virtual void DoMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoDivide(double divisor, Matrix`1<double> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseDivide(Matrix`1<double> divisor, Matrix`1<double> result);
    protected virtual void DoPointwisePower(Matrix`1<double> exponent, Matrix`1<double> result);
    protected virtual void DoModulus(double divisor, Matrix`1<double> result);
    protected virtual void DoModulusByThis(double dividend, Matrix`1<double> result);
    protected virtual void DoRemainder(double divisor, Matrix`1<double> result);
    protected virtual void DoRemainderByThis(double dividend, Matrix`1<double> result);
    public virtual double Trace();
    public static DenseMatrix op_Addition(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryPlus(DenseMatrix rightSide);
    public static DenseMatrix op_Subtraction(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryNegation(DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, double rightSide);
    public static DenseMatrix op_Multiply(double leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseVector op_Multiply(DenseMatrix leftSide, DenseVector rightSide);
    public static DenseVector op_Multiply(DenseVector leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Modulus(DenseMatrix leftSide, double rightSide);
    public virtual bool IsSymmetric();
    public virtual Cholesky`1<double> Cholesky();
    public virtual LU`1<double> LU();
    public virtual QR`1<double> QR(QRMethod method);
    public virtual GramSchmidt`1<double> GramSchmidt();
    public virtual Svd`1<double> Svd(bool computeVectors);
    public virtual Evd`1<double> Evd(Symmetricity symmetricity);
}
[DebuggerDisplayAttribute("DenseVector {Count}-Double")]
public class MathNet.Numerics.LinearAlgebra.Double.DenseVector : Vector {
    private int _length;
    private Double[] _values;
    public Double[] Values { get; }
    public DenseVector(DenseVectorStorage`1<double> storage);
    public DenseVector(int length);
    public DenseVector(Double[] storage);
    public static DenseVector OfVector(Vector`1<double> vector);
    public static DenseVector OfArray(Double[] array);
    public static DenseVector OfEnumerable(IEnumerable`1<double> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, double>> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, double>> enumerable);
    public static DenseVector Create(int length, double value);
    public static DenseVector Create(int length, Func`2<int, double> init);
    public static DenseVector CreateRandom(int length, IContinuousDistribution distribution);
    public Double[] get_Values();
    public static Double[] op_Explicit(DenseVector vector);
    public static DenseVector op_Implicit(Double[] array);
    protected virtual void DoAdd(double scalar, Vector`1<double> result);
    protected virtual void DoAdd(Vector`1<double> other, Vector`1<double> result);
    public static DenseVector op_Addition(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoSubtract(double scalar, Vector`1<double> result);
    protected virtual void DoSubtract(Vector`1<double> other, Vector`1<double> result);
    public static DenseVector op_UnaryNegation(DenseVector rightSide);
    public static DenseVector op_Subtraction(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoNegate(Vector`1<double> result);
    protected virtual void DoMultiply(double scalar, Vector`1<double> result);
    protected virtual double DoDotProduct(Vector`1<double> other);
    public static DenseVector op_Multiply(DenseVector leftSide, double rightSide);
    public static DenseVector op_Multiply(double leftSide, DenseVector rightSide);
    public static double op_Multiply(DenseVector leftSide, DenseVector rightSide);
    public static DenseVector op_Division(DenseVector leftSide, double rightSide);
    protected virtual void DoModulus(double divisor, Vector`1<double> result);
    protected virtual void DoRemainder(double divisor, Vector`1<double> result);
    public static DenseVector op_Modulus(DenseVector leftSide, double rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual double Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseDivide(Vector`1<double> divisor, Vector`1<double> result);
    protected virtual void DoPointwisePower(Vector`1<double> exponent, Vector`1<double> result);
    public static DenseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, DenseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, DenseVector& result);
}
[DebuggerDisplayAttribute("DiagonalMatrix {RowCount}x{ColumnCount}-Double")]
public class MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix : Matrix {
    private Double[] _data;
    public DiagonalMatrix(DiagonalMatrixStorage`1<double> storage);
    public DiagonalMatrix(int order);
    public DiagonalMatrix(int rows, int columns);
    public DiagonalMatrix(int rows, int columns, double diagonalValue);
    public DiagonalMatrix(int rows, int columns, Double[] diagonalStorage);
    public static DiagonalMatrix OfMatrix(Matrix`1<double> matrix);
    public static DiagonalMatrix OfArray(Double[0...,0...] array);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<Tuple`2<int, double>> diagonal);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<ValueTuple`2<int, double>> diagonal);
    public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable`1<double> diagonal);
    public static DiagonalMatrix Create(int rows, int columns, Func`2<int, double> init);
    public static DiagonalMatrix CreateIdentity(int order);
    public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    protected virtual void DoNegate(Matrix`1<double> result);
    protected virtual void DoAdd(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoSubtract(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoMultiply(double scalar, Matrix`1<double> result);
    protected virtual void DoMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoDivide(double divisor, Matrix`1<double> result);
    protected virtual void DoDivideByThis(double dividend, Matrix`1<double> result);
    public virtual double Determinant();
    public virtual Vector`1<double> Diagonal();
    public virtual void SetDiagonal(Double[] source);
    public virtual void SetDiagonal(Vector`1<double> source);
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual double ConditionNumber();
    public virtual Matrix`1<double> Inverse();
    public virtual Matrix`1<double> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<double> result);
    public virtual Matrix`1<double> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<double> result);
    public virtual Matrix`1<double> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<double> result);
    public virtual Matrix`1<double> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<double> result);
    public virtual Matrix`1<double> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public virtual void PermuteColumns(Permutation p);
    public virtual void PermuteRows(Permutation p);
    public sealed virtual bool IsSymmetric();
    protected virtual void DoModulus(double divisor, Matrix`1<double> result);
    protected virtual void DoModulusByThis(double dividend, Matrix`1<double> result);
    protected virtual void DoRemainder(double divisor, Matrix`1<double> result);
    protected virtual void DoRemainderByThis(double dividend, Matrix`1<double> result);
    [CompilerGeneratedAttribute]
private double <DoMultiply>b__19_0(int i, int _, double x);
    [CompilerGeneratedAttribute]
private double <DoMultiply>b__19_1(int i, int _, double x);
    [CompilerGeneratedAttribute]
private double <DoTransposeThisAndMultiply>b__21_0(int i, int _, double x);
    [CompilerGeneratedAttribute]
private double <DoTransposeThisAndMultiply>b__21_1(int i, int _, double x);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.Cholesky : Cholesky`1<double> {
    public double Determinant { get; }
    public double DeterminantLn { get; }
    protected Cholesky(Matrix`1<double> factor);
    public virtual double get_Determinant();
    public virtual double get_DeterminantLn();
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseCholesky : Cholesky {
    private DenseCholesky(Matrix`1<double> factor);
    public static DenseCholesky Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
    public virtual void Factorize(Matrix`1<double> matrix);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseEvd : Evd {
    private DenseEvd(Matrix`1<double> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<double> blockDiagonal, bool isSymmetric);
    public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseGramSchmidt : GramSchmidt {
    private DenseGramSchmidt(Matrix`1<double> q, Matrix`1<double> rFull);
    public static DenseGramSchmidt Create(Matrix`1<double> matrix);
    private static void Factorize(Double[] q, int rowsQ, int columnsQ, Double[] r);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU : LU {
    private DenseLU(Matrix`1<double> factors, Int32[] pivots);
    public static DenseLU Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
    public virtual Matrix`1<double> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseQR : QR {
    [CompilerGeneratedAttribute]
private Double[] <Tau>k__BackingField;
    private Double[] Tau { get; private set; }
    private DenseQR(Matrix`1<double> q, Matrix`1<double> rFull, QRMethod method, Double[] tau);
    [CompilerGeneratedAttribute]
private Double[] get_Tau();
    [CompilerGeneratedAttribute]
private void set_Tau(Double[] value);
    public static DenseQR Create(DenseMatrix matrix, QRMethod method);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd : Svd {
    private DenseSvd(Vector`1<double> s, Matrix`1<double> u, Matrix`1<double> vt, bool vectorsComputed);
    public static DenseSvd Create(DenseMatrix matrix, bool computeVectors);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.Evd : Evd`1<double> {
    public double Determinant { get; }
    public int Rank { get; }
    public bool IsFullRank { get; }
    protected Evd(Matrix`1<double> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<double> blockDiagonal, bool isSymmetric);
    public virtual double get_Determinant();
    public virtual int get_Rank();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.GramSchmidt : GramSchmidt`1<double> {
    public double Determinant { get; }
    public bool IsFullRank { get; }
    protected GramSchmidt(Matrix`1<double> q, Matrix`1<double> rFull);
    public virtual double get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.LU : LU`1<double> {
    public double Determinant { get; }
    protected LU(Matrix`1<double> factors, Int32[] pivots);
    public virtual double get_Determinant();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.QR : QR`1<double> {
    public double Determinant { get; }
    public bool IsFullRank { get; }
    protected QR(Matrix`1<double> q, Matrix`1<double> rFull, QRMethod method);
    public virtual double get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd : Svd`1<double> {
    public int Rank { get; }
    public double L2Norm { get; }
    public double ConditionNumber { get; }
    public double Determinant { get; }
    protected Svd(Vector`1<double> s, Matrix`1<double> u, Matrix`1<double> vt, bool vectorsComputed);
    public virtual int get_Rank();
    public virtual double get_L2Norm();
    public virtual double get_ConditionNumber();
    public virtual double get_Determinant();
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserCholesky : Cholesky {
    private UserCholesky(Matrix`1<double> factor);
    private static void DoCholesky(Matrix`1<double> factor);
    public static UserCholesky Create(Matrix`1<double> matrix);
    public virtual void Factorize(Matrix`1<double> matrix);
    private static void DoCholeskyStep(Matrix`1<double> data, int rowDim, int firstCol, int colLimit, Double[] multipliers, int availableCores);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserEvd : Evd {
    private UserEvd(Matrix`1<double> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<double> blockDiagonal, bool isSymmetric);
    public static UserEvd Create(Matrix`1<double> matrix, Symmetricity symmetricity);
    private static void SymmetricTridiagonalize(Matrix`1<double> eigenVectors, Double[] d, Double[] e, int order);
    private static void SymmetricDiagonalize(Matrix`1<double> eigenVectors, Double[] d, Double[] e, int order);
    private static void NonsymmetricReduceToHessenberg(Matrix`1<double> eigenVectors, Double[0...,0...] matrixH, int order);
    private static void NonsymmetricReduceHessenberToRealSchur(Matrix`1<double> eigenVectors, Double[0...,0...] matrixH, Double[] d, Double[] e, int order);
    private static Complex Cdiv(double xreal, double ximag, double yreal, double yimag);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserGramSchmidt : GramSchmidt {
    private UserGramSchmidt(Matrix`1<double> q, Matrix`1<double> rFull);
    public static UserGramSchmidt Create(Matrix`1<double> matrix);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserLU : LU {
    private UserLU(Matrix`1<double> factors, Int32[] pivots);
    public static UserLU Create(Matrix`1<double> matrix);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
    public virtual Matrix`1<double> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserQR : QR {
    private UserQR(Matrix`1<double> q, Matrix`1<double> rFull, QRMethod method);
    public static UserQR Create(Matrix`1<double> matrix, QRMethod method);
    private static Double[] GenerateColumn(Matrix`1<double> a, int row, int column);
    private static void ComputeQR(Double[] u, Matrix`1<double> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
internal class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd : Svd {
    private UserSvd(Vector`1<double> s, Matrix`1<double> u, Matrix`1<double> vt, bool vectorsComputed);
    public static UserSvd Create(Matrix`1<double> matrix, bool computeVectors);
    private static double Dsign(double z1, double z2);
    private static void Dswap(Matrix`1<double> a, int rowCount, int columnA, int columnB);
    private static void DscalColumn(Matrix`1<double> a, int rowCount, int column, int rowStart, double z);
    private static void DscalVector(Double[] a, int start, double z);
    private static void Drotg(Double& da, Double& db, Double& c, Double& s);
    private static double Dnrm2Column(Matrix`1<double> a, int rowCount, int column, int rowStart);
    private static double Dnrm2Vector(Double[] a, int rowStart);
    private static double Ddot(Matrix`1<double> a, int rowCount, int columnA, int columnB, int rowStart);
    private static void Drot(Matrix`1<double> a, int rowCount, int columnA, int columnB, double c, double s);
    public virtual void Solve(Matrix`1<double> input, Matrix`1<double> result);
    public virtual void Solve(Vector`1<double> input, Vector`1<double> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Double.Matrix : Matrix`1<double> {
    protected Matrix(MatrixStorage`1<double> storage);
    public virtual void CoerceZero(double threshold);
    public sealed virtual Matrix`1<double> ConjugateTranspose();
    public sealed virtual void ConjugateTranspose(Matrix`1<double> result);
    protected sealed virtual void DoConjugate(Matrix`1<double> result);
    protected virtual void DoNegate(Matrix`1<double> result);
    protected virtual void DoAdd(double scalar, Matrix`1<double> result);
    protected virtual void DoAdd(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoSubtract(double scalar, Matrix`1<double> result);
    protected virtual void DoSubtract(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoMultiply(double scalar, Matrix`1<double> result);
    protected virtual void DoMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoDivide(double divisor, Matrix`1<double> result);
    protected virtual void DoDivideByThis(double dividend, Matrix`1<double> result);
    protected virtual void DoMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected sealed virtual void DoConjugateTransposeAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected sealed virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected sealed virtual void DoConjugateTransposeThisAndMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoModulus(double divisor, Matrix`1<double> result);
    protected virtual void DoModulusByThis(double dividend, Matrix`1<double> result);
    protected virtual void DoRemainder(double divisor, Matrix`1<double> result);
    protected virtual void DoRemainderByThis(double dividend, Matrix`1<double> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseDivide(Matrix`1<double> divisor, Matrix`1<double> result);
    protected virtual void DoPointwisePower(double exponent, Matrix`1<double> result);
    protected virtual void DoPointwisePower(Matrix`1<double> exponent, Matrix`1<double> result);
    protected virtual void DoPointwiseModulus(Matrix`1<double> divisor, Matrix`1<double> result);
    protected virtual void DoPointwiseRemainder(Matrix`1<double> divisor, Matrix`1<double> result);
    protected virtual void DoPointwiseExp(Matrix`1<double> result);
    protected virtual void DoPointwiseLog(Matrix`1<double> result);
    protected virtual void DoPointwiseAbs(Matrix`1<double> result);
    protected virtual void DoPointwiseAcos(Matrix`1<double> result);
    protected virtual void DoPointwiseAsin(Matrix`1<double> result);
    protected virtual void DoPointwiseAtan(Matrix`1<double> result);
    protected virtual void DoPointwiseAtan2(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseCeiling(Matrix`1<double> result);
    protected virtual void DoPointwiseCos(Matrix`1<double> result);
    protected virtual void DoPointwiseCosh(Matrix`1<double> result);
    protected virtual void DoPointwiseFloor(Matrix`1<double> result);
    protected virtual void DoPointwiseLog10(Matrix`1<double> result);
    protected virtual void DoPointwiseRound(Matrix`1<double> result);
    protected virtual void DoPointwiseSign(Matrix`1<double> result);
    protected virtual void DoPointwiseSin(Matrix`1<double> result);
    protected virtual void DoPointwiseSinh(Matrix`1<double> result);
    protected virtual void DoPointwiseSqrt(Matrix`1<double> result);
    protected virtual void DoPointwiseTan(Matrix`1<double> result);
    protected virtual void DoPointwiseTanh(Matrix`1<double> result);
    public virtual Matrix`1<double> PseudoInverse();
    public virtual double Trace();
    protected virtual void DoPointwiseMinimum(double scalar, Matrix`1<double> result);
    protected virtual void DoPointwiseMaximum(double scalar, Matrix`1<double> result);
    protected virtual void DoPointwiseAbsoluteMinimum(double scalar, Matrix`1<double> result);
    protected virtual void DoPointwiseAbsoluteMaximum(double scalar, Matrix`1<double> result);
    protected virtual void DoPointwiseMinimum(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseMaximum(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Matrix`1<double> other, Matrix`1<double> result);
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Vector`1<double> RowNorms(double norm);
    public virtual Vector`1<double> ColumnNorms(double norm);
    public sealed virtual Matrix`1<double> NormalizeRows(double norm);
    public sealed virtual Matrix`1<double> NormalizeColumns(double norm);
    public virtual Vector`1<double> RowSums();
    public virtual Vector`1<double> RowAbsoluteSums();
    public virtual Vector`1<double> ColumnSums();
    public virtual Vector`1<double> ColumnAbsoluteSums();
    public sealed virtual bool IsHermitian();
    public virtual Cholesky`1<double> Cholesky();
    public virtual LU`1<double> LU();
    public virtual QR`1<double> QR(QRMethod method);
    public virtual GramSchmidt`1<double> GramSchmidt();
    public virtual Svd`1<double> Svd(bool computeVectors);
    public virtual Evd`1<double> Evd(Symmetricity symmetricity);
}
internal class MathNet.Numerics.LinearAlgebra.Double.MatrixBuilder : MatrixBuilder`1<double> {
    public double Zero { get; }
    public double One { get; }
    public virtual double get_Zero();
    public virtual double get_One();
    public virtual Matrix`1<double> Dense(DenseColumnMajorMatrixStorage`1<double> storage);
    public virtual Matrix`1<double> Sparse(SparseCompressedRowMatrixStorage`1<double> storage);
    public virtual Matrix`1<double> Diagonal(DiagonalMatrixStorage`1<double> storage);
    public virtual Matrix`1<double> Random(int rows, int columns, IContinuousDistribution distribution);
    public virtual IIterationStopCriterion`1[] IterativeSolverStopCriteria(int maxIterations);
    internal virtual double Add(double x, double y);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.BiCgStab : object {
    private static void CalculateTrueResidual(Matrix`1<double> matrix, Vector`1<double> residual, Vector`1<double> x, Vector`1<double> b);
    public sealed virtual void Solve(Matrix`1<double> matrix, Vector`1<double> input, Vector`1<double> result, Iterator`1<double> iterator, IPreconditioner`1<double> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.CompositeSolver : object {
    private List`1<Tuple`2<IIterativeSolver`1<double>, IPreconditioner`1<double>>> _solvers;
    public CompositeSolver(IEnumerable`1<IIterativeSolverSetup`1<double>> solvers);
    public sealed virtual void Solve(Matrix`1<double> matrix, Vector`1<double> input, Vector`1<double> result, Iterator`1<double> iterator, IPreconditioner`1<double> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.DiagonalPreconditioner : object {
    private Double[] _inverseDiagonals;
    internal DiagonalMatrix DiagonalEntries();
    public sealed virtual void Initialize(Matrix`1<double> matrix);
    public sealed virtual void Approximate(Vector`1<double> rhs, Vector`1<double> lhs);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.GpBiCg : object {
    private int _numberOfBiCgStabSteps;
    private int _numberOfGpbiCgSteps;
    public int NumberOfBiCgStabSteps { get; public set; }
    public int NumberOfGpBiCgSteps { get; public set; }
    public int get_NumberOfBiCgStabSteps();
    public void set_NumberOfBiCgStabSteps(int value);
    public int get_NumberOfGpBiCgSteps();
    public void set_NumberOfGpBiCgSteps(int value);
    private static void CalculateTrueResidual(Matrix`1<double> matrix, Vector`1<double> residual, Vector`1<double> x, Vector`1<double> b);
    private bool ShouldRunBiCgStabSteps(int iterationNumber);
    public sealed virtual void Solve(Matrix`1<double> matrix, Vector`1<double> input, Vector`1<double> result, Iterator`1<double> iterator, IPreconditioner`1<double> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.ILU0Preconditioner : object {
    private SparseMatrix _decompositionLU;
    internal Matrix`1<double> UpperTriangle();
    internal Matrix`1<double> LowerTriangle();
    public sealed virtual void Initialize(Matrix`1<double> matrix);
    public sealed virtual void Approximate(Vector`1<double> rhs, Vector`1<double> lhs);
}
internal static class MathNet.Numerics.LinearAlgebra.Double.Solvers.ILUTPElementSorter : object {
    public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<double> values);
    private static void HeapSortDoublesIndices(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<double> values);
    private static void BuildDoubleIndexHeap(int start, int count, Int32[] sortedIndices, Vector`1<double> values);
    private static void SiftDoubleIndices(Int32[] sortedIndices, Vector`1<double> values, int begin, int count);
    public static void SortIntegersDecreasing(Int32[] values);
    private static void HeapSortIntegers(Int32[] values, int count);
    private static void BuildHeap(Int32[] values, int start, int count);
    private static void Sift(Int32[] values, int start, int count);
    private static void Exchange(Int32[] values, int first, int second);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.ILUTPPreconditioner : object {
    public static double DefaultFillLevel;
    public static double DefaultDropTolerance;
    private SparseMatrix _upper;
    private SparseMatrix _lower;
    private Int32[] _pivots;
    private double _fillLevel;
    private double _dropTolerance;
    private double _pivotTolerance;
    public double FillLevel { get; public set; }
    public double DropTolerance { get; public set; }
    public double PivotTolerance { get; public set; }
    public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance);
    public double get_FillLevel();
    public void set_FillLevel(double value);
    public double get_DropTolerance();
    public void set_DropTolerance(double value);
    public double get_PivotTolerance();
    public void set_PivotTolerance(double value);
    internal Matrix`1<double> UpperTriangle();
    internal Matrix`1<double> LowerTriangle();
    internal Int32[] Pivots();
    public sealed virtual void Initialize(Matrix`1<double> matrix);
    private void PivotRow(Vector`1<double> row);
    private bool PivotMapFound(Dictionary`2<int, int> knownPivots, int currentItem);
    private static void SwapColumns(Matrix`1<double> matrix, int firstColumn, int secondColumn);
    private static void FindLargestItems(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<double> values);
    public sealed virtual void Approximate(Vector`1<double> rhs, Vector`1<double> lhs);
    private void Pivot(Vector`1<double> vector, Vector`1<double> result);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.MILU0Preconditioner : object {
    private Double[] _alu;
    private Int32[] _jlu;
    private Int32[] _diag;
    [CompilerGeneratedAttribute]
private bool <UseModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool UseModified { get; public set; }
    public bool IsInitialized { get; private set; }
    public MILU0Preconditioner(bool modified);
    [CompilerGeneratedAttribute]
public bool get_UseModified();
    [CompilerGeneratedAttribute]
public void set_UseModified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual void Initialize(Matrix`1<double> matrix);
    public sealed virtual void Approximate(Vector`1<double> input, Vector`1<double> result);
    private int Compute(int n, Double[] a, Int32[] ja, Int32[] ia, Double[] alu, Int32[] jlu, Int32[] ju, bool modified);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.MlkBiCgStab : object {
    private static int DefaultNumberOfStartingVectors;
    private IList`1<Vector`1<double>> _startingVectors;
    private int _numberOfStartingVectors;
    public int NumberOfStartingVectors { get; public set; }
    public IList`1<Vector`1<double>> StartingVectors { get; public set; }
    [DebuggerStepThroughAttribute]
public int get_NumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public void set_NumberOfStartingVectors(int value);
    public void ResetNumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public IList`1<Vector`1<double>> get_StartingVectors();
    [DebuggerStepThroughAttribute]
public void set_StartingVectors(IList`1<Vector`1<double>> value);
    private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static IList`1<Vector`1<double>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static Vector`1[] CreateVectorArray(int arraySize, int vectorSize);
    private static void CalculateTrueResidual(Matrix`1<double> matrix, Vector`1<double> residual, Vector`1<double> x, Vector`1<double> b);
    public sealed virtual void Solve(Matrix`1<double> matrix, Vector`1<double> input, Vector`1<double> result, Iterator`1<double> iterator, IPreconditioner`1<double> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Double.Solvers.TFQMR : object {
    private static void CalculateTrueResidual(Matrix`1<double> matrix, Vector`1<double> residual, Vector`1<double> x, Vector`1<double> b);
    private static bool IsEven(int number);
    public sealed virtual void Solve(Matrix`1<double> matrix, Vector`1<double> input, Vector`1<double> result, Iterator`1<double> iterator, IPreconditioner`1<double> preconditioner);
}
[DebuggerDisplayAttribute("SparseMatrix {RowCount}x{ColumnCount}-Double {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Double.SparseMatrix : Matrix {
    private SparseCompressedRowMatrixStorage`1<double> _storage;
    public int NonZerosCount { get; }
    public SparseMatrix(SparseCompressedRowMatrixStorage`1<double> storage);
    public SparseMatrix(int order);
    public SparseMatrix(int rows, int columns);
    public int get_NonZerosCount();
    public static SparseMatrix OfMatrix(Matrix`1<double> matrix);
    public static SparseMatrix OfArray(Double[0...,0...] array);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, double>> enumerable);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, double>> enumerable);
    public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable`1<double> rowMajor);
    public static SparseMatrix OfColumnMajor(int rows, int columns, IList`1<double> columnMajor);
    public static SparseMatrix OfColumns(IEnumerable`1<IEnumerable`1<double>> data);
    public static SparseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<double>> data);
    public static SparseMatrix OfColumnArrays(Double[][] columns);
    public static SparseMatrix OfColumnArrays(IEnumerable`1<Double[]> columns);
    public static SparseMatrix OfColumnVectors(Vector`1[] columns);
    public static SparseMatrix OfColumnVectors(IEnumerable`1<Vector`1<double>> columns);
    public static SparseMatrix OfRows(IEnumerable`1<IEnumerable`1<double>> data);
    public static SparseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<double>> data);
    public static SparseMatrix OfRowArrays(Double[][] rows);
    public static SparseMatrix OfRowArrays(IEnumerable`1<Double[]> rows);
    public static SparseMatrix OfRowVectors(Vector`1[] rows);
    public static SparseMatrix OfRowVectors(IEnumerable`1<Vector`1<double>> rows);
    public static SparseMatrix OfDiagonalVector(Vector`1<double> diagonal);
    public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector`1<double> diagonal);
    public static SparseMatrix OfDiagonalArray(Double[] diagonal);
    public static SparseMatrix OfDiagonalArray(int rows, int columns, Double[] diagonal);
    public static SparseMatrix Create(int rows, int columns, double value);
    public static SparseMatrix Create(int rows, int columns, Func`3<int, int, double> init);
    public static SparseMatrix CreateDiagonal(int rows, int columns, double value);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Func`2<int, double> init);
    public static SparseMatrix CreateIdentity(int order);
    public virtual Matrix`1<double> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<double> result);
    private void LowerTriangleImpl(Matrix`1<double> result);
    public virtual Matrix`1<double> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<double> result);
    private void UpperTriangleImpl(Matrix`1<double> result);
    public virtual Matrix`1<double> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<double> result);
    private void StrictlyLowerTriangleImpl(Matrix`1<double> result);
    public virtual Matrix`1<double> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<double> result);
    private void StrictlyUpperTriangleImpl(Matrix`1<double> result);
    protected virtual void DoNegate(Matrix`1<double> result);
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoAdd(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoSubtract(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoMultiply(double scalar, Matrix`1<double> result);
    protected virtual void DoMultiply(Matrix`1<double> other, Matrix`1<double> result);
    private void DoMultiplySparse(SparseMatrix other, SparseMatrix result);
    protected virtual void DoMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<double> rightSide, Vector`1<double> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoPointwiseDivide(Matrix`1<double> divisor, Matrix`1<double> result);
    public virtual void KroneckerProduct(Matrix`1<double> other, Matrix`1<double> result);
    protected virtual void DoModulus(double divisor, Matrix`1<double> result);
    protected virtual void DoRemainder(double divisor, Matrix`1<double> result);
    public virtual bool IsSymmetric();
    public static SparseMatrix op_Addition(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryPlus(SparseMatrix rightSide);
    public static SparseMatrix op_Subtraction(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryNegation(SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, double rightSide);
    public static SparseMatrix op_Multiply(double leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseVector op_Multiply(SparseMatrix leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Modulus(SparseMatrix leftSide, double rightSide);
    public virtual string ToTypeString();
}
[DebuggerDisplayAttribute("SparseVector {Count}-Double {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Double.SparseVector : Vector {
    private SparseVectorStorage`1<double> _storage;
    public int NonZerosCount { get; }
    public SparseVector(SparseVectorStorage`1<double> storage);
    public SparseVector(int length);
    public int get_NonZerosCount();
    public static SparseVector OfVector(Vector`1<double> vector);
    public static SparseVector OfEnumerable(IEnumerable`1<double> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, double>> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, double>> enumerable);
    public static SparseVector Create(int length, double value);
    public static SparseVector Create(int length, Func`2<int, double> init);
    protected virtual void DoAdd(double scalar, Vector`1<double> result);
    protected virtual void DoAdd(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoSubtract(double scalar, Vector`1<double> result);
    protected virtual void DoSubtract(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoNegate(Vector`1<double> result);
    protected virtual void DoMultiply(double scalar, Vector`1<double> result);
    protected virtual double DoDotProduct(Vector`1<double> other);
    protected virtual void DoModulus(double divisor, Vector`1<double> result);
    protected virtual void DoRemainder(double divisor, Vector`1<double> result);
    public static SparseVector op_Addition(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_UnaryNegation(SparseVector rightSide);
    public static SparseVector op_Subtraction(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, double rightSide);
    public static SparseVector op_Multiply(double leftSide, SparseVector rightSide);
    public static double op_Multiply(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Division(SparseVector leftSide, double rightSide);
    public static SparseVector op_Modulus(SparseVector leftSide, double rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual double Sum();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<double> other, Vector`1<double> result);
    public static SparseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, SparseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, SparseVector& result);
    public virtual string ToTypeString();
    [CompilerGeneratedAttribute]
private double <InfinityNorm>b__34_0(int i);
}
public abstract class MathNet.Numerics.LinearAlgebra.Double.Vector : Vector`1<double> {
    protected Vector(VectorStorage`1<double> storage);
    public virtual void CoerceZero(double threshold);
    protected sealed virtual void DoConjugate(Vector`1<double> result);
    protected virtual void DoNegate(Vector`1<double> result);
    protected virtual void DoAdd(double scalar, Vector`1<double> result);
    protected virtual void DoAdd(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoSubtract(double scalar, Vector`1<double> result);
    protected virtual void DoSubtract(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoMultiply(double scalar, Vector`1<double> result);
    protected virtual void DoDivide(double divisor, Vector`1<double> result);
    protected virtual void DoDivideByThis(double dividend, Vector`1<double> result);
    protected virtual void DoPointwiseMultiply(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseDivide(Vector`1<double> divisor, Vector`1<double> result);
    protected virtual void DoPointwisePower(double exponent, Vector`1<double> result);
    protected virtual void DoPointwisePower(Vector`1<double> exponent, Vector`1<double> result);
    protected virtual void DoPointwiseModulus(Vector`1<double> divisor, Vector`1<double> result);
    protected virtual void DoPointwiseRemainder(Vector`1<double> divisor, Vector`1<double> result);
    protected virtual void DoPointwiseExp(Vector`1<double> result);
    protected virtual void DoPointwiseLog(Vector`1<double> result);
    protected virtual void DoPointwiseAbs(Vector`1<double> result);
    protected virtual void DoPointwiseAcos(Vector`1<double> result);
    protected virtual void DoPointwiseAsin(Vector`1<double> result);
    protected virtual void DoPointwiseAtan(Vector`1<double> result);
    protected virtual void DoPointwiseAtan2(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseAtan2(double scalar, Vector`1<double> result);
    protected virtual void DoPointwiseCeiling(Vector`1<double> result);
    protected virtual void DoPointwiseCos(Vector`1<double> result);
    protected virtual void DoPointwiseCosh(Vector`1<double> result);
    protected virtual void DoPointwiseFloor(Vector`1<double> result);
    protected virtual void DoPointwiseLog10(Vector`1<double> result);
    protected virtual void DoPointwiseRound(Vector`1<double> result);
    protected virtual void DoPointwiseSign(Vector`1<double> result);
    protected virtual void DoPointwiseSin(Vector`1<double> result);
    protected virtual void DoPointwiseSinh(Vector`1<double> result);
    protected virtual void DoPointwiseSqrt(Vector`1<double> result);
    protected virtual void DoPointwiseTan(Vector`1<double> result);
    protected virtual void DoPointwiseTanh(Vector`1<double> result);
    protected virtual double DoDotProduct(Vector`1<double> other);
    protected sealed virtual double DoConjugateDotProduct(Vector`1<double> other);
    protected virtual void DoModulus(double divisor, Vector`1<double> result);
    protected virtual void DoModulusByThis(double dividend, Vector`1<double> result);
    protected virtual void DoRemainder(double divisor, Vector`1<double> result);
    protected virtual void DoRemainderByThis(double dividend, Vector`1<double> result);
    protected virtual void DoPointwiseMinimum(double scalar, Vector`1<double> result);
    protected virtual void DoPointwiseMaximum(double scalar, Vector`1<double> result);
    protected virtual void DoPointwiseAbsoluteMinimum(double scalar, Vector`1<double> result);
    protected virtual void DoPointwiseAbsoluteMaximum(double scalar, Vector`1<double> result);
    protected virtual void DoPointwiseMinimum(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseMaximum(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Vector`1<double> other, Vector`1<double> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Vector`1<double> other, Vector`1<double> result);
    public virtual double AbsoluteMinimum();
    public virtual int AbsoluteMinimumIndex();
    public virtual double AbsoluteMaximum();
    public virtual int AbsoluteMaximumIndex();
    public virtual double Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual Vector`1<double> Normalize(double p);
    [CompilerGeneratedAttribute]
private double <InfinityNorm>b__58_0(int i);
}
internal class MathNet.Numerics.LinearAlgebra.Double.VectorBuilder : VectorBuilder`1<double> {
    public double Zero { get; }
    public double One { get; }
    public virtual double get_Zero();
    public virtual double get_One();
    public virtual Vector`1<double> Dense(DenseVectorStorage`1<double> storage);
    public virtual Vector`1<double> Sparse(SparseVectorStorage`1<double> storage);
    public virtual Vector`1<double> Random(int length, IContinuousDistribution distribution);
}
public enum MathNet.Numerics.LinearAlgebra.ExistingData : Enum {
    public int value__;
    public static ExistingData Clear;
    public static ExistingData AssumeZeros;
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.Cholesky`1 : object {
    [CompilerGeneratedAttribute]
private Matrix`1<T> <Factor>k__BackingField;
    public Matrix`1<T> Factor { get; }
    public T Determinant { get; }
    public T DeterminantLn { get; }
    protected Cholesky`1(Matrix`1<T> factor);
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_Factor();
    public abstract virtual T get_Determinant();
    public abstract virtual T get_DeterminantLn();
    public abstract virtual void Factorize(Matrix`1<T> matrix);
    public virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.Evd`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsSymmetric>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<Complex> <EigenValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<T> <EigenVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<T> <D>k__BackingField;
    public bool IsSymmetric { get; }
    public T Determinant { get; }
    public int Rank { get; }
    public bool IsFullRank { get; }
    public Vector`1<Complex> EigenValues { get; }
    public Matrix`1<T> EigenVectors { get; }
    public Matrix`1<T> D { get; }
    protected Evd`1(Matrix`1<T> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<T> blockDiagonal, bool isSymmetric);
    [CompilerGeneratedAttribute]
public bool get_IsSymmetric();
    public abstract virtual T get_Determinant();
    public abstract virtual int get_Rank();
    public abstract virtual bool get_IsFullRank();
    [CompilerGeneratedAttribute]
public Vector`1<Complex> get_EigenValues();
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_EigenVectors();
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_D();
    public virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.GramSchmidt`1 : QR`1<T> {
    protected GramSchmidt`1(Matrix`1<T> q, Matrix`1<T> rFull);
}
public interface MathNet.Numerics.LinearAlgebra.Factorization.ISolver`1 {
    public abstract virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public abstract virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.LU`1 : object {
    private static T One;
    private Lazy`1<Matrix`1<T>> _lazyL;
    private Lazy`1<Matrix`1<T>> _lazyU;
    private Lazy`1<Permutation> _lazyP;
    protected Matrix`1<T> Factors;
    protected Int32[] Pivots;
    public Matrix`1<T> L { get; }
    public Matrix`1<T> U { get; }
    public Permutation P { get; }
    public T Determinant { get; }
    protected LU`1(Matrix`1<T> factors, Int32[] pivots);
    private static LU`1();
    private Matrix`1<T> ComputeL();
    public Matrix`1<T> get_L();
    public Matrix`1<T> get_U();
    public Permutation get_P();
    public abstract virtual T get_Determinant();
    public virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
    public abstract virtual Matrix`1<T> Inverse();
    [CompilerGeneratedAttribute]
private Permutation <.ctor>b__6_0();
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.QR`1 : object {
    private Lazy`1<Matrix`1<T>> _lazyR;
    protected Matrix`1<T> FullR;
    protected QRMethod Method;
    [CompilerGeneratedAttribute]
private Matrix`1<T> <Q>k__BackingField;
    public Matrix`1<T> Q { get; }
    public Matrix`1<T> R { get; }
    public T Determinant { get; }
    public bool IsFullRank { get; }
    protected QR`1(Matrix`1<T> q, Matrix`1<T> rFull, QRMethod method);
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_Q();
    public Matrix`1<T> get_R();
    public abstract virtual T get_Determinant();
    public abstract virtual bool get_IsFullRank();
    public virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
}
public enum MathNet.Numerics.LinearAlgebra.Factorization.QRMethod : Enum {
    public int value__;
    public static QRMethod Full;
    public static QRMethod Thin;
}
public abstract class MathNet.Numerics.LinearAlgebra.Factorization.Svd`1 : object {
    private Lazy`1<Matrix`1<T>> _lazyW;
    protected bool VectorsComputed;
    [CompilerGeneratedAttribute]
private Vector`1<T> <S>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<T> <U>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<T> <VT>k__BackingField;
    public Vector`1<T> S { get; }
    public Matrix`1<T> U { get; }
    public Matrix`1<T> VT { get; }
    public Matrix`1<T> W { get; }
    public int Rank { get; }
    public double L2Norm { get; }
    public T ConditionNumber { get; }
    public T Determinant { get; }
    protected Svd`1(Vector`1<T> s, Matrix`1<T> u, Matrix`1<T> vt, bool vectorsComputed);
    private Matrix`1<T> ComputeW();
    [CompilerGeneratedAttribute]
public Vector`1<T> get_S();
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_U();
    [CompilerGeneratedAttribute]
public Matrix`1<T> get_VT();
    public Matrix`1<T> get_W();
    public abstract virtual int get_Rank();
    public abstract virtual double get_L2Norm();
    public abstract virtual T get_ConditionNumber();
    public abstract virtual T get_Determinant();
    public virtual Matrix`1<T> Solve(Matrix`1<T> input);
    public abstract virtual void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public virtual Vector`1<T> Solve(Vector`1<T> input);
    public abstract virtual void Solve(Vector`1<T> input, Vector`1<T> result);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Matrix {RowCount}x{ColumnCount}")]
public abstract class MathNet.Numerics.LinearAlgebra.Matrix`1 : object {
    public static T One;
    public static T Zero;
    public static MatrixBuilder`1<T> Build;
    [CompilerGeneratedAttribute]
private MatrixStorage`1<T> <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowCount>k__BackingField;
    public MatrixStorage`1<T> Storage { get; private set; }
    public int ColumnCount { get; private set; }
    public int RowCount { get; private set; }
    public T Item { get; public set; }
    protected Matrix`1(MatrixStorage`1<T> storage);
    private static Matrix`1();
    protected abstract virtual void DoNegate(Matrix`1<T> result);
    protected abstract virtual void DoConjugate(Matrix`1<T> result);
    protected abstract virtual void DoAdd(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoAdd(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoSubtract(T scalar, Matrix`1<T> result);
    protected void DoSubtractFrom(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoSubtract(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoMultiply(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoMultiply(Vector`1<T> rightSide, Vector`1<T> result);
    protected abstract virtual void DoMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoTransposeAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoConjugateTransposeAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoTransposeThisAndMultiply(Vector`1<T> rightSide, Vector`1<T> result);
    protected abstract virtual void DoConjugateTransposeThisAndMultiply(Vector`1<T> rightSide, Vector`1<T> result);
    protected abstract virtual void DoTransposeThisAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoDivide(T divisor, Matrix`1<T> result);
    protected abstract virtual void DoDivideByThis(T dividend, Matrix`1<T> result);
    protected abstract virtual void DoModulus(T divisor, Matrix`1<T> result);
    protected abstract virtual void DoModulusByThis(T dividend, Matrix`1<T> result);
    protected abstract virtual void DoRemainder(T divisor, Matrix`1<T> result);
    protected abstract virtual void DoRemainderByThis(T dividend, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseMultiply(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseDivide(Matrix`1<T> divisor, Matrix`1<T> result);
    protected abstract virtual void DoPointwisePower(T exponent, Matrix`1<T> result);
    protected abstract virtual void DoPointwisePower(Matrix`1<T> exponent, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseModulus(Matrix`1<T> divisor, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseRemainder(Matrix`1<T> divisor, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseExp(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseLog(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAbs(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAcos(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAsin(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAtan(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseCeiling(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseCos(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseCosh(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseFloor(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseLog10(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseRound(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseSign(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseSin(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseSinh(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseSqrt(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseTan(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseTanh(Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAtan2(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseMinimum(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseMinimum(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseMaximum(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseMaximum(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMinimum(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMinimum(Matrix`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMaximum(T scalar, Matrix`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMaximum(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> Add(T scalar);
    public void Add(T scalar, Matrix`1<T> result);
    public Matrix`1<T> Add(Matrix`1<T> other);
    public void Add(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> Subtract(T scalar);
    public void Subtract(T scalar, Matrix`1<T> result);
    public Matrix`1<T> SubtractFrom(T scalar);
    public void SubtractFrom(T scalar, Matrix`1<T> result);
    public Matrix`1<T> Subtract(Matrix`1<T> other);
    public void Subtract(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> Multiply(T scalar);
    public void Multiply(T scalar, Matrix`1<T> result);
    public Matrix`1<T> Divide(T scalar);
    public void Divide(T scalar, Matrix`1<T> result);
    public Matrix`1<T> DivideByThis(T scalar);
    public void DivideByThis(T scalar, Matrix`1<T> result);
    public Vector`1<T> Multiply(Vector`1<T> rightSide);
    public void Multiply(Vector`1<T> rightSide, Vector`1<T> result);
    public Vector`1<T> LeftMultiply(Vector`1<T> leftSide);
    public void LeftMultiply(Vector`1<T> leftSide, Vector`1<T> result);
    protected void DoLeftMultiply(Vector`1<T> leftSide, Vector`1<T> result);
    public void Multiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> Multiply(Matrix`1<T> other);
    public void TransposeAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> TransposeAndMultiply(Matrix`1<T> other);
    public Vector`1<T> TransposeThisAndMultiply(Vector`1<T> rightSide);
    public void TransposeThisAndMultiply(Vector`1<T> rightSide, Vector`1<T> result);
    public void TransposeThisAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> TransposeThisAndMultiply(Matrix`1<T> other);
    public void ConjugateTransposeAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> ConjugateTransposeAndMultiply(Matrix`1<T> other);
    public Vector`1<T> ConjugateTransposeThisAndMultiply(Vector`1<T> rightSide);
    public void ConjugateTransposeThisAndMultiply(Vector`1<T> rightSide, Vector`1<T> result);
    public void ConjugateTransposeThisAndMultiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> ConjugateTransposeThisAndMultiply(Matrix`1<T> other);
    private static Matrix`1<T> IntPower(int exponent, Matrix`1<T> x, Matrix`1<T> y, Matrix`1<T> work);
    public void Power(int exponent, Matrix`1<T> result);
    public Matrix`1<T> Power(int exponent);
    public Matrix`1<T> Negate();
    public void Negate(Matrix`1<T> result);
    public Matrix`1<T> Conjugate();
    public void Conjugate(Matrix`1<T> result);
    public Matrix`1<T> Modulus(T divisor);
    public void Modulus(T divisor, Matrix`1<T> result);
    public Matrix`1<T> ModulusByThis(T dividend);
    public void ModulusByThis(T dividend, Matrix`1<T> result);
    public Matrix`1<T> Remainder(T divisor);
    public void Remainder(T divisor, Matrix`1<T> result);
    public Matrix`1<T> RemainderByThis(T dividend);
    public void RemainderByThis(T dividend, Matrix`1<T> result);
    public Matrix`1<T> PointwiseMultiply(Matrix`1<T> other);
    public void PointwiseMultiply(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseDivide(Matrix`1<T> divisor);
    public void PointwiseDivide(Matrix`1<T> divisor, Matrix`1<T> result);
    public Matrix`1<T> PointwisePower(T exponent);
    public void PointwisePower(T exponent, Matrix`1<T> result);
    public Matrix`1<T> PointwisePower(Matrix`1<T> exponent);
    public void PointwisePower(Matrix`1<T> exponent, Matrix`1<T> result);
    public Matrix`1<T> PointwiseModulus(Matrix`1<T> divisor);
    public void PointwiseModulus(Matrix`1<T> divisor, Matrix`1<T> result);
    public Matrix`1<T> PointwiseRemainder(Matrix`1<T> divisor);
    public void PointwiseRemainder(Matrix`1<T> divisor, Matrix`1<T> result);
    protected Matrix`1<T> PointwiseUnary(Action`1<Matrix`1<T>> f);
    protected void PointwiseUnary(Action`1<Matrix`1<T>> f, Matrix`1<T> result);
    protected Matrix`1<T> PointwiseBinary(Action`2<Matrix`1<T>, Matrix`1<T>> f, Matrix`1<T> other);
    protected void PointwiseBinary(Action`2<Matrix`1<T>, Matrix`1<T>> f, Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseExp();
    public void PointwiseExp(Matrix`1<T> result);
    public Matrix`1<T> PointwiseLog();
    public void PointwiseLog(Matrix`1<T> result);
    public Matrix`1<T> PointwiseAbs();
    public void PointwiseAbs(Matrix`1<T> result);
    public Matrix`1<T> PointwiseAcos();
    public void PointwiseAcos(Matrix`1<T> result);
    public Matrix`1<T> PointwiseAsin();
    public void PointwiseAsin(Matrix`1<T> result);
    public Matrix`1<T> PointwiseAtan();
    public void PointwiseAtan(Matrix`1<T> result);
    public Matrix`1<T> PointwiseAtan2(Matrix`1<T> other);
    public void PointwiseAtan2(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseCeiling();
    public void PointwiseCeiling(Matrix`1<T> result);
    public Matrix`1<T> PointwiseCos();
    public void PointwiseCos(Matrix`1<T> result);
    public Matrix`1<T> PointwiseCosh();
    public void PointwiseCosh(Matrix`1<T> result);
    public Matrix`1<T> PointwiseFloor();
    public void PointwiseFloor(Matrix`1<T> result);
    public Matrix`1<T> PointwiseLog10();
    public void PointwiseLog10(Matrix`1<T> result);
    public Matrix`1<T> PointwiseRound();
    public void PointwiseRound(Matrix`1<T> result);
    public Matrix`1<T> PointwiseSign();
    public void PointwiseSign(Matrix`1<T> result);
    public Matrix`1<T> PointwiseSin();
    public void PointwiseSin(Matrix`1<T> result);
    public Matrix`1<T> PointwiseSinh();
    public void PointwiseSinh(Matrix`1<T> result);
    public Matrix`1<T> PointwiseSqrt();
    public void PointwiseSqrt(Matrix`1<T> result);
    public Matrix`1<T> PointwiseTan();
    public void PointwiseTan(Matrix`1<T> result);
    public Matrix`1<T> PointwiseTanh();
    public void PointwiseTanh(Matrix`1<T> result);
    public abstract virtual T Trace();
    public virtual int Rank();
    public int Nullity();
    public virtual T ConditionNumber();
    public virtual T Determinant();
    public virtual Vector`1[] Kernel();
    public virtual Vector`1[] Range();
    public virtual Matrix`1<T> Inverse();
    public abstract virtual Matrix`1<T> PseudoInverse();
    public Matrix`1<T> KroneckerProduct(Matrix`1<T> other);
    public virtual void KroneckerProduct(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseMinimum(T scalar);
    public void PointwiseMinimum(T scalar, Matrix`1<T> result);
    public Matrix`1<T> PointwiseMaximum(T scalar);
    public void PointwiseMaximum(T scalar, Matrix`1<T> result);
    public Matrix`1<T> PointwiseAbsoluteMinimum(T scalar);
    public void PointwiseAbsoluteMinimum(T scalar, Matrix`1<T> result);
    public Matrix`1<T> PointwiseAbsoluteMaximum(T scalar);
    public void PointwiseAbsoluteMaximum(T scalar, Matrix`1<T> result);
    public Matrix`1<T> PointwiseMinimum(Matrix`1<T> other);
    public void PointwiseMinimum(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseMaximum(Matrix`1<T> other);
    public void PointwiseMaximum(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseAbsoluteMinimum(Matrix`1<T> other);
    public void PointwiseAbsoluteMinimum(Matrix`1<T> other, Matrix`1<T> result);
    public Matrix`1<T> PointwiseAbsoluteMaximum(Matrix`1<T> other);
    public void PointwiseAbsoluteMaximum(Matrix`1<T> other, Matrix`1<T> result);
    public abstract virtual double L1Norm();
    public virtual double L2Norm();
    public abstract virtual double InfinityNorm();
    public abstract virtual double FrobeniusNorm();
    public abstract virtual Vector`1<double> RowNorms(double norm);
    public abstract virtual Vector`1<double> ColumnNorms(double norm);
    public abstract virtual Matrix`1<T> NormalizeRows(double norm);
    public abstract virtual Matrix`1<T> NormalizeColumns(double norm);
    public abstract virtual Vector`1<T> RowSums();
    public abstract virtual Vector`1<T> ColumnSums();
    public abstract virtual Vector`1<T> RowAbsoluteSums();
    public abstract virtual Vector`1<T> ColumnAbsoluteSums();
    internal static Exception DimensionsDontMatch(Matrix`1<T> left, Matrix`1<T> right, Matrix`1<T> result, string paramName);
    internal static Exception DimensionsDontMatch(Matrix`1<T> left, Matrix`1<T> right, string paramName);
    internal static Exception DimensionsDontMatch(Matrix`1<T> matrix);
    internal static Exception DimensionsDontMatch(Matrix`1<T> left, Vector`1<T> right, Vector`1<T> result, string paramName);
    internal static Exception DimensionsDontMatch(Matrix`1<T> left, Vector`1<T> right, string paramName);
    internal static Exception DimensionsDontMatch(Vector`1<T> left, Matrix`1<T> right, string paramName);
    internal static Exception DimensionsDontMatch(Vector`1<T> left, Vector`1<T> right, string paramName);
    private static Exception CreateException(string message, string paramName);
    public sealed virtual bool Equals(Matrix`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToTypeString();
    public String[0...,0...] ToMatrixStringArray(int upperRows, int lowerRows, int leftColumns, int rightColumns, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, Func`2<T, string> formatValue);
    public String[0...,0...] ToMatrixStringArray(int upperRows, int lowerRows, int minLeftColumns, int rightColumns, int maxWidth, int padding, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, Func`2<T, string> formatValue);
    private Tuple`2<int, String[]> FormatColumn(int column, int height, int upper, int lower, bool withEllipsis, string ellipsis, Func`2<T, string> formatValue);
    private static string FormatStringArrayToString(String[0...,0...] array, string columnSeparator, string rowSeparator);
    public string ToMatrixString(int upperRows, int lowerRows, int leftColumns, int rightColumns, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, string columnSeparator, string rowSeparator, Func`2<T, string> formatValue);
    public string ToMatrixString(int upperRows, int lowerRows, int minLeftColumns, int rightColumns, int maxWidth, string horizontalEllipsis, string verticalEllipsis, string diagonalEllipsis, string columnSeparator, string rowSeparator, Func`2<T, string> formatValue);
    public string ToMatrixString(int maxRows, int maxColumns, string format, IFormatProvider provider);
    public string ToMatrixString(string format, IFormatProvider provider);
    public string ToString(int maxRows, int maxColumns, string format, IFormatProvider formatProvider);
    public sealed virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public MatrixStorage`1<T> get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(MatrixStorage`1<T> value);
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
private void set_ColumnCount(int value);
    [CompilerGeneratedAttribute]
public int get_RowCount();
    [CompilerGeneratedAttribute]
private void set_RowCount(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public T get_Item(int row, int column);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void set_Item(int row, int column, T value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public T At(int row, int column);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void At(int row, int column, T value);
    public void Clear();
    public void ClearRow(int rowIndex);
    public void ClearColumn(int columnIndex);
    public void ClearRows(Int32[] rowIndices);
    public void ClearColumns(Int32[] columnIndices);
    public void ClearSubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public abstract virtual void CoerceZero(double threshold);
    public void CoerceZero(Func`2<T, bool> zeroPredicate);
    public Matrix`1<T> Clone();
    public void CopyTo(Matrix`1<T> target);
    public Vector`1<T> Row(int index);
    public void Row(int index, Vector`1<T> result);
    public Vector`1<T> Row(int rowIndex, int columnIndex, int length);
    public void Row(int rowIndex, int columnIndex, int length, Vector`1<T> result);
    public Vector`1<T> Column(int index);
    public void Column(int index, Vector`1<T> result);
    public Vector`1<T> Column(int columnIndex, int rowIndex, int length);
    public void Column(int columnIndex, int rowIndex, int length, Vector`1<T> result);
    public virtual Matrix`1<T> UpperTriangle();
    public virtual Matrix`1<T> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<T> result);
    public virtual void UpperTriangle(Matrix`1<T> result);
    public virtual Matrix`1<T> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public virtual Vector`1<T> Diagonal();
    public virtual Matrix`1<T> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<T> result);
    public virtual Matrix`1<T> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<T> result);
    public Matrix`1<T> InsertColumn(int columnIndex, Vector`1<T> column);
    public Matrix`1<T> RemoveColumn(int columnIndex);
    public void SetColumn(int columnIndex, Vector`1<T> column);
    public void SetColumn(int columnIndex, int rowIndex, int length, Vector`1<T> column);
    public void SetColumn(int columnIndex, T[] column);
    public Matrix`1<T> InsertRow(int rowIndex, Vector`1<T> row);
    public Matrix`1<T> RemoveRow(int rowIndex);
    public void SetRow(int rowIndex, Vector`1<T> row);
    public void SetRow(int rowIndex, int columnIndex, int length, Vector`1<T> row);
    public void SetRow(int rowIndex, T[] row);
    public void SetSubMatrix(int rowIndex, int columnIndex, Matrix`1<T> subMatrix);
    public void SetSubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount, Matrix`1<T> subMatrix);
    public void SetSubMatrix(int rowIndex, int sorceRowIndex, int rowCount, int columnIndex, int sourceColumnIndex, int columnCount, Matrix`1<T> subMatrix);
    public virtual void SetDiagonal(Vector`1<T> source);
    public virtual void SetDiagonal(T[] source);
    public Matrix`1<T> Resize(int rowCount, int columnCount);
    public Matrix`1<T> Transpose();
    public void Transpose(Matrix`1<T> result);
    public abstract virtual Matrix`1<T> ConjugateTranspose();
    public abstract virtual void ConjugateTranspose(Matrix`1<T> result);
    public virtual void PermuteRows(Permutation p);
    public virtual void PermuteColumns(Permutation p);
    public Matrix`1<T> Append(Matrix`1<T> right);
    public void Append(Matrix`1<T> right, Matrix`1<T> result);
    public Matrix`1<T> Stack(Matrix`1<T> lower);
    public void Stack(Matrix`1<T> lower, Matrix`1<T> result);
    public Matrix`1<T> DiagonalStack(Matrix`1<T> lower);
    public void DiagonalStack(Matrix`1<T> lower, Matrix`1<T> result);
    public virtual bool IsSymmetric();
    public abstract virtual bool IsHermitian();
    public T[0...,0...] ToArray();
    public T[] ToColumnMajorArray();
    public T[] ToRowMajorArray();
    public T[][] ToRowArrays();
    public T[][] ToColumnArrays();
    public T[0...,0...] AsArray();
    public T[] AsColumnMajorArray();
    public T[] AsRowMajorArray();
    public T[][] AsRowArrays();
    public T[][] AsColumnArrays();
    public IEnumerable`1<T> Enumerate();
    public IEnumerable`1<T> Enumerate(Zeros zeros);
    public IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed();
    public IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed(Zeros zeros);
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateColumns>d__315")]
public IEnumerable`1<Vector`1<T>> EnumerateColumns();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateColumns>d__316")]
public IEnumerable`1<Vector`1<T>> EnumerateColumns(int index, int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateColumnsIndexed>d__317")]
public IEnumerable`1<ValueTuple`2<int, Vector`1<T>>> EnumerateColumnsIndexed();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateColumnsIndexed>d__318")]
public IEnumerable`1<ValueTuple`2<int, Vector`1<T>>> EnumerateColumnsIndexed(int index, int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateRows>d__319")]
public IEnumerable`1<Vector`1<T>> EnumerateRows();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateRows>d__320")]
public IEnumerable`1<Vector`1<T>> EnumerateRows(int index, int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateRowsIndexed>d__321")]
public IEnumerable`1<ValueTuple`2<int, Vector`1<T>>> EnumerateRowsIndexed();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Matrix`1/<EnumerateRowsIndexed>d__322")]
public IEnumerable`1<ValueTuple`2<int, Vector`1<T>>> EnumerateRowsIndexed(int index, int length);
    public void MapInplace(Func`2<T, T> f, Zeros zeros);
    public void MapIndexedInplace(Func`4<int, int, T, T> f, Zeros zeros);
    public void Map(Func`2<T, T> f, Matrix`1<T> result, Zeros zeros);
    public void MapIndexed(Func`4<int, int, T, T> f, Matrix`1<T> result, Zeros zeros);
    public void MapConvert(Func`2<T, TU> f, Matrix`1<TU> result, Zeros zeros);
    public void MapIndexedConvert(Func`4<int, int, T, TU> f, Matrix`1<TU> result, Zeros zeros);
    public Matrix`1<TU> Map(Func`2<T, TU> f, Zeros zeros);
    public Matrix`1<TU> MapIndexed(Func`4<int, int, T, TU> f, Zeros zeros);
    public TU[] FoldByRow(Func`3<TU, T, TU> f, TU state, Zeros zeros);
    public TU[] FoldByColumn(Func`3<TU, T, TU> f, TU state, Zeros zeros);
    public Vector`1<TU> FoldRows(Func`3<Vector`1<TU>, Vector`1<T>, Vector`1<TU>> f, Vector`1<TU> state);
    public Vector`1<TU> FoldColumns(Func`3<Vector`1<TU>, Vector`1<T>, Vector`1<TU>> f, Vector`1<TU> state);
    public Vector`1<T> ReduceRows(Func`3<Vector`1<T>, Vector`1<T>, Vector`1<T>> f);
    public Vector`1<T> ReduceColumns(Func`3<Vector`1<T>, Vector`1<T>, Vector`1<T>> f);
    public void Map2(Func`3<T, T, T> f, Matrix`1<T> other, Matrix`1<T> result, Zeros zeros);
    public Matrix`1<T> Map2(Func`3<T, T, T> f, Matrix`1<T> other, Zeros zeros);
    public TState Fold2(Func`4<TState, T, TOther, TState> f, TState state, Matrix`1<TOther> other, Zeros zeros);
    public Tuple`3<int, int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    public Tuple`4<int, int, T, TOther> Find2(Func`3<T, TOther, bool> predicate, Matrix`1<TOther> other, Zeros zeros);
    public bool Exists(Func`2<T, bool> predicate, Zeros zeros);
    public bool Exists2(Func`3<T, TOther, bool> predicate, Matrix`1<TOther> other, Zeros zeros);
    public bool ForAll(Func`2<T, bool> predicate, Zeros zeros);
    public bool ForAll2(Func`3<T, TOther, bool> predicate, Matrix`1<TOther> other, Zeros zeros);
    public static Matrix`1<T> op_UnaryPlus(Matrix`1<T> rightSide);
    public static Matrix`1<T> op_UnaryNegation(Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Addition(Matrix`1<T> leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Addition(Matrix`1<T> leftSide, T rightSide);
    public static Matrix`1<T> op_Addition(T leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Subtraction(Matrix`1<T> leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Subtraction(Matrix`1<T> leftSide, T rightSide);
    public static Matrix`1<T> op_Subtraction(T leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Multiply(Matrix`1<T> leftSide, T rightSide);
    public static Matrix`1<T> op_Multiply(T leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Multiply(Matrix`1<T> leftSide, Matrix`1<T> rightSide);
    public static Vector`1<T> op_Multiply(Matrix`1<T> leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Multiply(Vector`1<T> leftSide, Matrix`1<T> rightSide);
    public static Matrix`1<T> op_Division(T dividend, Matrix`1<T> divisor);
    public static Matrix`1<T> op_Division(Matrix`1<T> dividend, T divisor);
    public static Matrix`1<T> op_Modulus(Matrix`1<T> dividend, T divisor);
    public static Matrix`1<T> op_Modulus(T dividend, Matrix`1<T> divisor);
    public static Matrix`1<T> op_Modulus(Matrix`1<T> dividend, Matrix`1<T> divisor);
    public static Matrix`1<T> op_DotMultiply(Matrix`1<T> x, Matrix`1<T> y);
    public static Matrix`1<T> op_DotDivide(Matrix`1<T> dividend, Matrix`1<T> divisor);
    public static Matrix`1<T> op_DotPercent(Matrix`1<T> dividend, Matrix`1<T> divisor);
    public static Matrix`1<T> op_DotHat(Matrix`1<T> matrix, Matrix`1<T> exponent);
    public static Matrix`1<T> op_DotHat(Matrix`1<T> matrix, T exponent);
    public static Matrix`1<T> Sqrt(Matrix`1<T> x);
    public static Matrix`1<T> Exp(Matrix`1<T> x);
    public static Matrix`1<T> Log(Matrix`1<T> x);
    public static Matrix`1<T> Log10(Matrix`1<T> x);
    public static Matrix`1<T> Sin(Matrix`1<T> x);
    public static Matrix`1<T> Cos(Matrix`1<T> x);
    public static Matrix`1<T> Tan(Matrix`1<T> x);
    public static Matrix`1<T> Asin(Matrix`1<T> x);
    public static Matrix`1<T> Acos(Matrix`1<T> x);
    public static Matrix`1<T> Atan(Matrix`1<T> x);
    public static Matrix`1<T> Sinh(Matrix`1<T> x);
    public static Matrix`1<T> Cosh(Matrix`1<T> x);
    public static Matrix`1<T> Tanh(Matrix`1<T> x);
    public static Matrix`1<T> Abs(Matrix`1<T> x);
    public static Matrix`1<T> Floor(Matrix`1<T> x);
    public static Matrix`1<T> Ceiling(Matrix`1<T> x);
    public static Matrix`1<T> Round(Matrix`1<T> x);
    public abstract virtual Cholesky`1<T> Cholesky();
    public abstract virtual LU`1<T> LU();
    public abstract virtual QR`1<T> QR(QRMethod method);
    public abstract virtual GramSchmidt`1<T> GramSchmidt();
    public abstract virtual Svd`1<T> Svd(bool computeVectors);
    public abstract virtual Evd`1<T> Evd(Symmetricity symmetricity);
    public void Solve(Vector`1<T> input, Vector`1<T> result);
    public void Solve(Matrix`1<T> input, Matrix`1<T> result);
    public Matrix`1<T> Solve(Matrix`1<T> input);
    public Vector`1<T> Solve(Vector`1<T> input);
    public IterationStatus TrySolveIterative(Vector`1<T> input, Vector`1<T> result, IIterativeSolver`1<T> solver, Iterator`1<T> iterator, IPreconditioner`1<T> preconditioner);
    public IterationStatus TrySolveIterative(Matrix`1<T> input, Matrix`1<T> result, IIterativeSolver`1<T> solver, Iterator`1<T> iterator, IPreconditioner`1<T> preconditioner);
    public IterationStatus TrySolveIterative(Vector`1<T> input, Vector`1<T> result, IIterativeSolver`1<T> solver, IPreconditioner`1<T> preconditioner, IIterationStopCriterion`1[] stopCriteria);
    public IterationStatus TrySolveIterative(Matrix`1<T> input, Matrix`1<T> result, IIterativeSolver`1<T> solver, IPreconditioner`1<T> preconditioner, IIterationStopCriterion`1[] stopCriteria);
    public IterationStatus TrySolveIterative(Vector`1<T> input, Vector`1<T> result, IIterativeSolver`1<T> solver, IIterationStopCriterion`1[] stopCriteria);
    public IterationStatus TrySolveIterative(Matrix`1<T> input, Matrix`1<T> result, IIterativeSolver`1<T> solver, IIterationStopCriterion`1[] stopCriteria);
    public Vector`1<T> SolveIterative(Vector`1<T> input, IIterativeSolver`1<T> solver, Iterator`1<T> iterator, IPreconditioner`1<T> preconditioner);
    public Matrix`1<T> SolveIterative(Matrix`1<T> input, IIterativeSolver`1<T> solver, Iterator`1<T> iterator, IPreconditioner`1<T> preconditioner);
    public Vector`1<T> SolveIterative(Vector`1<T> input, IIterativeSolver`1<T> solver, IPreconditioner`1<T> preconditioner, IIterationStopCriterion`1[] stopCriteria);
    public Matrix`1<T> SolveIterative(Matrix`1<T> input, IIterativeSolver`1<T> solver, IPreconditioner`1<T> preconditioner, IIterationStopCriterion`1[] stopCriteria);
    public Vector`1<T> SolveIterative(Vector`1<T> input, IIterativeSolver`1<T> solver, IIterationStopCriterion`1[] stopCriteria);
    public Matrix`1<T> SolveIterative(Matrix`1<T> input, IIterativeSolver`1<T> solver, IIterationStopCriterion`1[] stopCriteria);
}
public abstract class MathNet.Numerics.LinearAlgebra.MatrixBuilder`1 : object {
    public T Zero { get; }
    public T One { get; }
    public abstract virtual T get_Zero();
    public abstract virtual T get_One();
    internal abstract virtual T Add(T x, T y);
    public Matrix`1<T> OfStorage(MatrixStorage`1<T> storage);
    public Matrix`1<T> SameAs(Matrix`1<TU> example, int rows, int columns, bool fullyMutable);
    public Matrix`1<T> SameAs(Matrix`1<TU> example);
    public Matrix`1<T> SameAs(Vector`1<T> example, int rows, int columns);
    public Matrix`1<T> SameAs(Matrix`1<T> example, Matrix`1<T> otherExample, int rows, int columns, bool fullyMutable);
    public Matrix`1<T> SameAs(Matrix`1<T> example, Matrix`1<T> otherExample);
    public abstract virtual Matrix`1<T> Random(int rows, int columns, IContinuousDistribution distribution);
    public Matrix`1<T> Random(int rows, int columns);
    public Matrix`1<T> Random(int rows, int columns, int seed);
    public Matrix`1<T> RandomPositiveDefinite(int order, IContinuousDistribution distribution);
    public Matrix`1<T> RandomPositiveDefinite(int order);
    public Matrix`1<T> RandomPositiveDefinite(int order, int seed);
    public abstract virtual Matrix`1<T> Dense(DenseColumnMajorMatrixStorage`1<T> storage);
    public Matrix`1<T> Dense(int rows, int columns);
    public Matrix`1<T> Dense(int rows, int columns, T[] storage);
    public Matrix`1<T> Dense(int rows, int columns, T value);
    public Matrix`1<T> Dense(int rows, int columns, Func`3<int, int, T> init);
    public Matrix`1<T> DenseDiagonal(int rows, int columns, T value);
    public Matrix`1<T> DenseDiagonal(int order, T value);
    public Matrix`1<T> DenseDiagonal(int rows, int columns, Func`2<int, T> init);
    public Matrix`1<T> DenseIdentity(int rows, int columns);
    public Matrix`1<T> DenseIdentity(int order);
    public Matrix`1<T> DenseOfMatrix(Matrix`1<T> matrix);
    public Matrix`1<T> DenseOfArray(T[0...,0...] array);
    public Matrix`1<T> DenseOfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> enumerable);
    public Matrix`1<T> DenseOfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> enumerable);
    public Matrix`1<T> DenseOfColumnMajor(int rows, int columns, IEnumerable`1<T> columnMajor);
    public Matrix`1<T> DenseOfColumns(IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> DenseOfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> DenseOfColumnArrays(T[][] columns);
    public Matrix`1<T> DenseOfColumnArrays(IEnumerable`1<T[]> columns);
    public Matrix`1<T> DenseOfColumnVectors(Vector`1[] columns);
    public Matrix`1<T> DenseOfColumnVectors(IEnumerable`1<Vector`1<T>> columns);
    public Matrix`1<T> DenseOfRowMajor(int rows, int columns, IEnumerable`1<T> columnMajor);
    public Matrix`1<T> DenseOfRows(IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> DenseOfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> DenseOfRowArrays(T[][] rows);
    public Matrix`1<T> DenseOfRowArrays(IEnumerable`1<T[]> rows);
    public Matrix`1<T> DenseOfRowVectors(Vector`1[] rows);
    public Matrix`1<T> DenseOfRowVectors(IEnumerable`1<Vector`1<T>> rows);
    public Matrix`1<T> DenseOfDiagonalVector(Vector`1<T> diagonal);
    public Matrix`1<T> DenseOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public Matrix`1<T> DenseOfDiagonalArray(T[] diagonal);
    public Matrix`1<T> DenseOfDiagonalArray(int rows, int columns, T[] diagonal);
    public Matrix`1<T> DenseOfMatrixArray(Matrix`1[0...,0...] matrices);
    public abstract virtual Matrix`1<T> Sparse(SparseCompressedRowMatrixStorage`1<T> storage);
    public Matrix`1<T> Sparse(int rows, int columns);
    public Matrix`1<T> Sparse(int rows, int columns, T value);
    public Matrix`1<T> Sparse(int rows, int columns, Func`3<int, int, T> init);
    public Matrix`1<T> SparseDiagonal(int rows, int columns, T value);
    public Matrix`1<T> SparseDiagonal(int order, T value);
    public Matrix`1<T> SparseDiagonal(int rows, int columns, Func`2<int, T> init);
    public Matrix`1<T> SparseIdentity(int rows, int columns);
    public Matrix`1<T> SparseIdentity(int order);
    public Matrix`1<T> SparseOfMatrix(Matrix`1<T> matrix);
    public Matrix`1<T> SparseOfArray(T[0...,0...] array);
    public Matrix`1<T> SparseOfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> enumerable);
    public Matrix`1<T> SparseOfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> enumerable);
    public Matrix`1<T> SparseOfRowMajor(int rows, int columns, IEnumerable`1<T> rowMajor);
    public Matrix`1<T> SparseOfColumnMajor(int rows, int columns, IList`1<T> columnMajor);
    public Matrix`1<T> SparseOfColumns(IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> SparseOfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> SparseOfColumnArrays(T[][] columns);
    public Matrix`1<T> SparseOfColumnArrays(IEnumerable`1<T[]> columns);
    public Matrix`1<T> SparseOfColumnVectors(Vector`1[] columns);
    public Matrix`1<T> SparseOfColumnVectors(IEnumerable`1<Vector`1<T>> columns);
    public Matrix`1<T> SparseOfRows(IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> SparseOfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public Matrix`1<T> SparseOfRowArrays(T[][] rows);
    public Matrix`1<T> SparseOfRowArrays(IEnumerable`1<T[]> rows);
    public Matrix`1<T> SparseOfRowVectors(Vector`1[] rows);
    public Matrix`1<T> SparseOfRowVectors(IEnumerable`1<Vector`1<T>> rows);
    public Matrix`1<T> SparseOfDiagonalVector(Vector`1<T> diagonal);
    public Matrix`1<T> SparseOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public Matrix`1<T> SparseOfDiagonalArray(T[] diagonal);
    public Matrix`1<T> SparseOfDiagonalArray(int rows, int columns, T[] diagonal);
    public Matrix`1<T> SparseOfMatrixArray(Matrix`1[0...,0...] matrices);
    public Matrix`1<T> SparseFromCoordinateFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnIndices, T[] values);
    public Matrix`1<T> SparseFromCompressedSparseRowFormat(int rows, int columns, int valueCount, Int32[] rowPointers, Int32[] columnIndices, T[] values);
    public Matrix`1<T> SparseFromCompressedSparseColumnFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnPointers, T[] values);
    public abstract virtual Matrix`1<T> Diagonal(DiagonalMatrixStorage`1<T> storage);
    public Matrix`1<T> Diagonal(int rows, int columns);
    public Matrix`1<T> Diagonal(int rows, int columns, T[] storage);
    public Matrix`1<T> Diagonal(T[] storage);
    public Matrix`1<T> Diagonal(int rows, int columns, T value);
    public Matrix`1<T> Diagonal(int rows, int columns, Func`2<int, T> init);
    public Matrix`1<T> DiagonalIdentity(int rows, int columns);
    public Matrix`1<T> DiagonalIdentity(int order);
    public Matrix`1<T> DiagonalOfDiagonalVector(Vector`1<T> diagonal);
    public Matrix`1<T> DiagonalOfDiagonalVector(int rows, int columns, Vector`1<T> diagonal);
    public Matrix`1<T> DiagonalOfDiagonalArray(T[] diagonal);
    public Matrix`1<T> DiagonalOfDiagonalArray(int rows, int columns, T[] diagonal);
    public abstract virtual IIterationStopCriterion`1[] IterativeSolverStopCriteria(int maxIterations);
    [CompilerGeneratedAttribute]
private T <DenseIdentity>b__25_0(int _);
    [CompilerGeneratedAttribute]
private T <DenseIdentity>b__26_0(int _);
    [CompilerGeneratedAttribute]
private T <SparseIdentity>b__57_0(int _);
    [CompilerGeneratedAttribute]
private T <SparseIdentity>b__58_0(int _);
}
[ExtensionAttribute]
public static class MathNet.Numerics.LinearAlgebra.MatrixExtensions : object {
    [ExtensionAttribute]
public static Matrix`1<float> ToSingle(Matrix`1<double> matrix);
    [ExtensionAttribute]
public static Matrix`1<double> ToDouble(Matrix`1<float> matrix);
    [ExtensionAttribute]
public static Matrix`1<Complex32> ToComplex32(Matrix`1<Complex> matrix);
    [ExtensionAttribute]
public static Matrix`1<Complex> ToComplex(Matrix`1<Complex32> matrix);
    [ExtensionAttribute]
public static Matrix`1<Complex32> ToComplex32(Matrix`1<float> matrix);
    [ExtensionAttribute]
public static Matrix`1<Complex> ToComplex(Matrix`1<double> matrix);
    [ExtensionAttribute]
public static Matrix`1<double> Real(Matrix`1<Complex> matrix);
    [ExtensionAttribute]
public static Matrix`1<float> Real(Matrix`1<Complex32> matrix);
    [ExtensionAttribute]
public static Matrix`1<double> Imaginary(Matrix`1<Complex> matrix);
    [ExtensionAttribute]
public static Matrix`1<float> Imaginary(Matrix`1<Complex32> matrix);
}
[DebuggerDisplayAttribute("DenseMatrix {RowCount}x{ColumnCount}-Single")]
public class MathNet.Numerics.LinearAlgebra.Single.DenseMatrix : Matrix {
    private int _rowCount;
    private int _columnCount;
    private Single[] _values;
    public Single[] Values { get; }
    public DenseMatrix(DenseColumnMajorMatrixStorage`1<float> storage);
    public DenseMatrix(int order);
    public DenseMatrix(int rows, int columns);
    public DenseMatrix(int rows, int columns, Single[] storage);
    public static DenseMatrix OfMatrix(Matrix`1<float> matrix);
    public static DenseMatrix OfArray(Single[0...,0...] array);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, float>> enumerable);
    public static DenseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, float>> enumerable);
    public static DenseMatrix OfColumnMajor(int rows, int columns, IEnumerable`1<float> columnMajor);
    public static DenseMatrix OfColumns(IEnumerable`1<IEnumerable`1<float>> data);
    public static DenseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<float>> data);
    public static DenseMatrix OfColumnArrays(Single[][] columns);
    public static DenseMatrix OfColumnArrays(IEnumerable`1<Single[]> columns);
    public static DenseMatrix OfColumnVectors(Vector`1[] columns);
    public static DenseMatrix OfColumnVectors(IEnumerable`1<Vector`1<float>> columns);
    public static DenseMatrix OfRows(IEnumerable`1<IEnumerable`1<float>> data);
    public static DenseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<float>> data);
    public static DenseMatrix OfRowArrays(Single[][] rows);
    public static DenseMatrix OfRowArrays(IEnumerable`1<Single[]> rows);
    public static DenseMatrix OfRowVectors(Vector`1[] rows);
    public static DenseMatrix OfRowVectors(IEnumerable`1<Vector`1<float>> rows);
    public static DenseMatrix OfDiagonalVector(Vector`1<float> diagonal);
    public static DenseMatrix OfDiagonalVector(int rows, int columns, Vector`1<float> diagonal);
    public static DenseMatrix OfDiagonalArray(Single[] diagonal);
    public static DenseMatrix OfDiagonalArray(int rows, int columns, Single[] diagonal);
    public static DenseMatrix Create(int rows, int columns, float value);
    public static DenseMatrix Create(int rows, int columns, Func`3<int, int, float> init);
    public static DenseMatrix CreateDiagonal(int rows, int columns, float value);
    public static DenseMatrix CreateDiagonal(int rows, int columns, Func`2<int, float> init);
    public static DenseMatrix CreateIdentity(int order);
    public static DenseMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    public Single[] get_Values();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoNegate(Matrix`1<float> result);
    protected virtual void DoAdd(float scalar, Matrix`1<float> result);
    protected virtual void DoAdd(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoSubtract(float scalar, Matrix`1<float> result);
    protected virtual void DoSubtract(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoMultiply(float scalar, Matrix`1<float> result);
    protected virtual void DoMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoDivide(float divisor, Matrix`1<float> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseDivide(Matrix`1<float> divisor, Matrix`1<float> result);
    protected virtual void DoPointwisePower(Matrix`1<float> exponent, Matrix`1<float> result);
    protected virtual void DoModulus(float divisor, Matrix`1<float> result);
    protected virtual void DoModulusByThis(float dividend, Matrix`1<float> result);
    protected virtual void DoRemainder(float divisor, Matrix`1<float> result);
    protected virtual void DoRemainderByThis(float dividend, Matrix`1<float> result);
    public virtual float Trace();
    public static DenseMatrix op_Addition(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryPlus(DenseMatrix rightSide);
    public static DenseMatrix op_Subtraction(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_UnaryNegation(DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, float rightSide);
    public static DenseMatrix op_Multiply(float leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Multiply(DenseMatrix leftSide, DenseMatrix rightSide);
    public static DenseVector op_Multiply(DenseMatrix leftSide, DenseVector rightSide);
    public static DenseVector op_Multiply(DenseVector leftSide, DenseMatrix rightSide);
    public static DenseMatrix op_Modulus(DenseMatrix leftSide, float rightSide);
    public virtual bool IsSymmetric();
    public virtual Cholesky`1<float> Cholesky();
    public virtual LU`1<float> LU();
    public virtual QR`1<float> QR(QRMethod method);
    public virtual GramSchmidt`1<float> GramSchmidt();
    public virtual Svd`1<float> Svd(bool computeVectors);
    public virtual Evd`1<float> Evd(Symmetricity symmetricity);
}
[DebuggerDisplayAttribute("DenseVector {Count}-Single")]
public class MathNet.Numerics.LinearAlgebra.Single.DenseVector : Vector {
    private int _length;
    private Single[] _values;
    public Single[] Values { get; }
    public DenseVector(DenseVectorStorage`1<float> storage);
    public DenseVector(int length);
    public DenseVector(Single[] storage);
    public static DenseVector OfVector(Vector`1<float> vector);
    public static DenseVector OfArray(Single[] array);
    public static DenseVector OfEnumerable(IEnumerable`1<float> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, float>> enumerable);
    public static DenseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, float>> enumerable);
    public static DenseVector Create(int length, float value);
    public static DenseVector Create(int length, Func`2<int, float> init);
    public static DenseVector CreateRandom(int length, IContinuousDistribution distribution);
    public Single[] get_Values();
    public static Single[] op_Explicit(DenseVector vector);
    public static DenseVector op_Implicit(Single[] array);
    protected virtual void DoAdd(float scalar, Vector`1<float> result);
    protected virtual void DoAdd(Vector`1<float> other, Vector`1<float> result);
    public static DenseVector op_Addition(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoSubtract(float scalar, Vector`1<float> result);
    protected virtual void DoSubtract(Vector`1<float> other, Vector`1<float> result);
    public static DenseVector op_UnaryNegation(DenseVector rightSide);
    public static DenseVector op_Subtraction(DenseVector leftSide, DenseVector rightSide);
    protected virtual void DoNegate(Vector`1<float> result);
    protected virtual void DoMultiply(float scalar, Vector`1<float> result);
    protected virtual float DoDotProduct(Vector`1<float> other);
    public static DenseVector op_Multiply(DenseVector leftSide, float rightSide);
    public static DenseVector op_Multiply(float leftSide, DenseVector rightSide);
    public static float op_Multiply(DenseVector leftSide, DenseVector rightSide);
    public static DenseVector op_Division(DenseVector leftSide, float rightSide);
    protected virtual void DoModulus(float divisor, Vector`1<float> result);
    protected virtual void DoRemainder(float divisor, Vector`1<float> result);
    public static DenseVector op_Modulus(DenseVector leftSide, float rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual float Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseDivide(Vector`1<float> divisor, Vector`1<float> result);
    protected virtual void DoPointwisePower(Vector`1<float> exponent, Vector`1<float> result);
    public static DenseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, DenseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, DenseVector& result);
}
[DebuggerDisplayAttribute("DiagonalMatrix {RowCount}x{ColumnCount}-Single")]
public class MathNet.Numerics.LinearAlgebra.Single.DiagonalMatrix : Matrix {
    private Single[] _data;
    public DiagonalMatrix(DiagonalMatrixStorage`1<float> storage);
    public DiagonalMatrix(int order);
    public DiagonalMatrix(int rows, int columns);
    public DiagonalMatrix(int rows, int columns, float diagonalValue);
    public DiagonalMatrix(int rows, int columns, Single[] diagonalStorage);
    public static DiagonalMatrix OfMatrix(Matrix`1<float> matrix);
    public static DiagonalMatrix OfArray(Single[0...,0...] array);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<Tuple`2<int, float>> diagonal);
    public static DiagonalMatrix OfIndexedDiagonal(int rows, int columns, IEnumerable`1<ValueTuple`2<int, float>> diagonal);
    public static DiagonalMatrix OfDiagonal(int rows, int columns, IEnumerable`1<float> diagonal);
    public static DiagonalMatrix Create(int rows, int columns, Func`2<int, float> init);
    public static DiagonalMatrix CreateIdentity(int order);
    public static DiagonalMatrix CreateRandom(int rows, int columns, IContinuousDistribution distribution);
    protected virtual void DoNegate(Matrix`1<float> result);
    protected virtual void DoAdd(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoSubtract(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoMultiply(float scalar, Matrix`1<float> result);
    protected virtual void DoMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoDivide(float divisor, Matrix`1<float> result);
    protected virtual void DoDivideByThis(float dividend, Matrix`1<float> result);
    public virtual float Determinant();
    public virtual Vector`1<float> Diagonal();
    public virtual void SetDiagonal(Single[] source);
    public virtual void SetDiagonal(Vector`1<float> source);
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual float ConditionNumber();
    public virtual Matrix`1<float> Inverse();
    public virtual Matrix`1<float> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<float> result);
    public virtual Matrix`1<float> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<float> result);
    public virtual Matrix`1<float> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<float> result);
    public virtual Matrix`1<float> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<float> result);
    public virtual Matrix`1<float> SubMatrix(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public virtual void PermuteColumns(Permutation p);
    public virtual void PermuteRows(Permutation p);
    public sealed virtual bool IsSymmetric();
    protected virtual void DoModulus(float divisor, Matrix`1<float> result);
    protected virtual void DoModulusByThis(float dividend, Matrix`1<float> result);
    protected virtual void DoRemainder(float divisor, Matrix`1<float> result);
    protected virtual void DoRemainderByThis(float dividend, Matrix`1<float> result);
    [CompilerGeneratedAttribute]
private float <DoMultiply>b__19_0(int i, int _, float x);
    [CompilerGeneratedAttribute]
private float <DoMultiply>b__19_1(int i, int _, float x);
    [CompilerGeneratedAttribute]
private float <DoTransposeThisAndMultiply>b__21_0(int i, int _, float x);
    [CompilerGeneratedAttribute]
private float <DoTransposeThisAndMultiply>b__21_1(int i, int _, float x);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.Cholesky : Cholesky`1<float> {
    public float Determinant { get; }
    public float DeterminantLn { get; }
    protected Cholesky(Matrix`1<float> factor);
    public virtual float get_Determinant();
    public virtual float get_DeterminantLn();
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseCholesky : Cholesky {
    private DenseCholesky(Matrix`1<float> factor);
    public static DenseCholesky Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
    public virtual void Factorize(Matrix`1<float> matrix);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseEvd : Evd {
    private DenseEvd(Matrix`1<float> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<float> blockDiagonal, bool isSymmetric);
    public static DenseEvd Create(DenseMatrix matrix, Symmetricity symmetricity);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseGramSchmidt : GramSchmidt {
    private DenseGramSchmidt(Matrix`1<float> q, Matrix`1<float> rFull);
    public static DenseGramSchmidt Create(Matrix`1<float> matrix);
    private static void Factorize(Single[] q, int rowsQ, int columnsQ, Single[] r);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseLU : LU {
    private DenseLU(Matrix`1<float> factors, Int32[] pivots);
    public static DenseLU Create(DenseMatrix matrix);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
    public virtual Matrix`1<float> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseQR : QR {
    [CompilerGeneratedAttribute]
private Single[] <Tau>k__BackingField;
    private Single[] Tau { get; private set; }
    private DenseQR(Matrix`1<float> q, Matrix`1<float> rFull, QRMethod method, Single[] tau);
    [CompilerGeneratedAttribute]
private Single[] get_Tau();
    [CompilerGeneratedAttribute]
private void set_Tau(Single[] value);
    public static DenseQR Create(DenseMatrix matrix, QRMethod method);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.DenseSvd : Svd {
    private DenseSvd(Vector`1<float> s, Matrix`1<float> u, Matrix`1<float> vt, bool vectorsComputed);
    public static DenseSvd Create(DenseMatrix matrix, bool computeVectors);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.Evd : Evd`1<float> {
    public float Determinant { get; }
    public int Rank { get; }
    public bool IsFullRank { get; }
    protected Evd(Matrix`1<float> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<float> blockDiagonal, bool isSymmetric);
    public virtual float get_Determinant();
    public virtual int get_Rank();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.GramSchmidt : GramSchmidt`1<float> {
    public float Determinant { get; }
    public bool IsFullRank { get; }
    protected GramSchmidt(Matrix`1<float> q, Matrix`1<float> rFull);
    public virtual float get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.LU : LU`1<float> {
    public float Determinant { get; }
    protected LU(Matrix`1<float> factors, Int32[] pivots);
    public virtual float get_Determinant();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.QR : QR`1<float> {
    public float Determinant { get; }
    public bool IsFullRank { get; }
    protected QR(Matrix`1<float> q, Matrix`1<float> rFull, QRMethod method);
    public virtual float get_Determinant();
    public virtual bool get_IsFullRank();
}
internal abstract class MathNet.Numerics.LinearAlgebra.Single.Factorization.Svd : Svd`1<float> {
    public int Rank { get; }
    public double L2Norm { get; }
    public float ConditionNumber { get; }
    public float Determinant { get; }
    protected Svd(Vector`1<float> s, Matrix`1<float> u, Matrix`1<float> vt, bool vectorsComputed);
    public virtual int get_Rank();
    public virtual double get_L2Norm();
    public virtual float get_ConditionNumber();
    public virtual float get_Determinant();
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserCholesky : Cholesky {
    private UserCholesky(Matrix`1<float> factor);
    private static void DoCholesky(Matrix`1<float> factor);
    public static UserCholesky Create(Matrix`1<float> matrix);
    public virtual void Factorize(Matrix`1<float> matrix);
    private static void DoCholeskyStep(Matrix`1<float> data, int rowDim, int firstCol, int colLimit, Single[] multipliers, int availableCores);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserEvd : Evd {
    private UserEvd(Matrix`1<float> eigenVectors, Vector`1<Complex> eigenValues, Matrix`1<float> blockDiagonal, bool isSymmetric);
    public static UserEvd Create(Matrix`1<float> matrix, Symmetricity symmetricity);
    private static void SymmetricTridiagonalize(Matrix`1<float> eigenVectors, Single[] d, Single[] e, int order);
    private static void SymmetricDiagonalize(Matrix`1<float> eigenVectors, Single[] d, Single[] e, int order);
    private static void NonsymmetricReduceToHessenberg(Matrix`1<float> eigenVectors, Single[0...,0...] matrixH, int order);
    private static void NonsymmetricReduceHessenberToRealSchur(Matrix`1<float> eigenVectors, Single[0...,0...] matrixH, Single[] d, Single[] e, int order);
    private static Complex32 Cdiv(float xreal, float ximag, float yreal, float yimag);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserGramSchmidt : GramSchmidt {
    private UserGramSchmidt(Matrix`1<float> q, Matrix`1<float> rFull);
    public static UserGramSchmidt Create(Matrix`1<float> matrix);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserLU : LU {
    private UserLU(Matrix`1<float> factors, Int32[] pivots);
    public static UserLU Create(Matrix`1<float> matrix);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
    public virtual Matrix`1<float> Inverse();
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserQR : QR {
    private UserQR(Matrix`1<float> q, Matrix`1<float> rFull, QRMethod method);
    public static UserQR Create(Matrix`1<float> matrix, QRMethod method);
    private static Single[] GenerateColumn(Matrix`1<float> a, int row, int column);
    private static void ComputeQR(Single[] u, Matrix`1<float> a, int rowStart, int rowDim, int columnStart, int columnDim, int availableCores);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
internal class MathNet.Numerics.LinearAlgebra.Single.Factorization.UserSvd : Svd {
    private UserSvd(Vector`1<float> s, Matrix`1<float> u, Matrix`1<float> vt, bool vectorsComputed);
    public static UserSvd Create(Matrix`1<float> matrix, bool computeVectors);
    private static float Dsign(float z1, float z2);
    private static void Dswap(Matrix`1<float> a, int rowCount, int columnA, int columnB);
    private static void DscalColumn(Matrix`1<float> a, int rowCount, int column, int rowStart, float z);
    private static void DscalVector(Single[] a, int start, float z);
    private static void Drotg(Single& da, Single& db, Single& c, Single& s);
    private static float Dnrm2Column(Matrix`1<float> a, int rowCount, int column, int rowStart);
    private static float Dnrm2Vector(Single[] a, int rowStart);
    private static float Ddot(Matrix`1<float> a, int rowCount, int columnA, int columnB, int rowStart);
    private static void Drot(Matrix`1<float> a, int rowCount, int columnA, int columnB, float c, float s);
    public virtual void Solve(Matrix`1<float> input, Matrix`1<float> result);
    public virtual void Solve(Vector`1<float> input, Vector`1<float> result);
}
public abstract class MathNet.Numerics.LinearAlgebra.Single.Matrix : Matrix`1<float> {
    protected Matrix(MatrixStorage`1<float> storage);
    public virtual void CoerceZero(double threshold);
    public sealed virtual Matrix`1<float> ConjugateTranspose();
    public sealed virtual void ConjugateTranspose(Matrix`1<float> result);
    protected sealed virtual void DoConjugate(Matrix`1<float> result);
    protected virtual void DoNegate(Matrix`1<float> result);
    protected virtual void DoAdd(float scalar, Matrix`1<float> result);
    protected virtual void DoAdd(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoSubtract(float scalar, Matrix`1<float> result);
    protected virtual void DoSubtract(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoMultiply(float scalar, Matrix`1<float> result);
    protected virtual void DoMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoDivide(float divisor, Matrix`1<float> result);
    protected virtual void DoDivideByThis(float dividend, Matrix`1<float> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected sealed virtual void DoConjugateTransposeAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected sealed virtual void DoConjugateTransposeThisAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected sealed virtual void DoConjugateTransposeThisAndMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoModulus(float divisor, Matrix`1<float> result);
    protected virtual void DoModulusByThis(float dividend, Matrix`1<float> result);
    protected virtual void DoRemainder(float divisor, Matrix`1<float> result);
    protected virtual void DoRemainderByThis(float dividend, Matrix`1<float> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseDivide(Matrix`1<float> divisor, Matrix`1<float> result);
    protected virtual void DoPointwisePower(float exponent, Matrix`1<float> result);
    protected virtual void DoPointwisePower(Matrix`1<float> exponent, Matrix`1<float> result);
    protected virtual void DoPointwiseModulus(Matrix`1<float> divisor, Matrix`1<float> result);
    protected virtual void DoPointwiseRemainder(Matrix`1<float> divisor, Matrix`1<float> result);
    protected virtual void DoPointwiseExp(Matrix`1<float> result);
    protected virtual void DoPointwiseLog(Matrix`1<float> result);
    protected virtual void DoPointwiseAbs(Matrix`1<float> result);
    protected virtual void DoPointwiseAcos(Matrix`1<float> result);
    protected virtual void DoPointwiseAsin(Matrix`1<float> result);
    protected virtual void DoPointwiseAtan(Matrix`1<float> result);
    protected virtual void DoPointwiseAtan2(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseCeiling(Matrix`1<float> result);
    protected virtual void DoPointwiseCos(Matrix`1<float> result);
    protected virtual void DoPointwiseCosh(Matrix`1<float> result);
    protected virtual void DoPointwiseFloor(Matrix`1<float> result);
    protected virtual void DoPointwiseLog10(Matrix`1<float> result);
    protected virtual void DoPointwiseRound(Matrix`1<float> result);
    protected virtual void DoPointwiseSign(Matrix`1<float> result);
    protected virtual void DoPointwiseSin(Matrix`1<float> result);
    protected virtual void DoPointwiseSinh(Matrix`1<float> result);
    protected virtual void DoPointwiseSqrt(Matrix`1<float> result);
    protected virtual void DoPointwiseTan(Matrix`1<float> result);
    protected virtual void DoPointwiseTanh(Matrix`1<float> result);
    public virtual Matrix`1<float> PseudoInverse();
    public virtual float Trace();
    protected virtual void DoPointwiseMinimum(float scalar, Matrix`1<float> result);
    protected virtual void DoPointwiseMaximum(float scalar, Matrix`1<float> result);
    protected virtual void DoPointwiseAbsoluteMinimum(float scalar, Matrix`1<float> result);
    protected virtual void DoPointwiseAbsoluteMaximum(float scalar, Matrix`1<float> result);
    protected virtual void DoPointwiseMinimum(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseMaximum(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Matrix`1<float> other, Matrix`1<float> result);
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    public virtual Vector`1<double> RowNorms(double norm);
    public virtual Vector`1<double> ColumnNorms(double norm);
    public sealed virtual Matrix`1<float> NormalizeRows(double norm);
    public sealed virtual Matrix`1<float> NormalizeColumns(double norm);
    public virtual Vector`1<float> RowSums();
    public virtual Vector`1<float> RowAbsoluteSums();
    public virtual Vector`1<float> ColumnSums();
    public virtual Vector`1<float> ColumnAbsoluteSums();
    public sealed virtual bool IsHermitian();
    public virtual Cholesky`1<float> Cholesky();
    public virtual LU`1<float> LU();
    public virtual QR`1<float> QR(QRMethod method);
    public virtual GramSchmidt`1<float> GramSchmidt();
    public virtual Svd`1<float> Svd(bool computeVectors);
    public virtual Evd`1<float> Evd(Symmetricity symmetricity);
}
internal class MathNet.Numerics.LinearAlgebra.Single.MatrixBuilder : MatrixBuilder`1<float> {
    public float Zero { get; }
    public float One { get; }
    public virtual float get_Zero();
    public virtual float get_One();
    public virtual Matrix`1<float> Dense(DenseColumnMajorMatrixStorage`1<float> storage);
    public virtual Matrix`1<float> Sparse(SparseCompressedRowMatrixStorage`1<float> storage);
    public virtual Matrix`1<float> Diagonal(DiagonalMatrixStorage`1<float> storage);
    public virtual Matrix`1<float> Random(int rows, int columns, IContinuousDistribution distribution);
    public virtual IIterationStopCriterion`1[] IterativeSolverStopCriteria(int maxIterations);
    internal virtual float Add(float x, float y);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.BiCgStab : object {
    private static void CalculateTrueResidual(Matrix`1<float> matrix, Vector`1<float> residual, Vector`1<float> x, Vector`1<float> b);
    public sealed virtual void Solve(Matrix`1<float> matrix, Vector`1<float> input, Vector`1<float> result, Iterator`1<float> iterator, IPreconditioner`1<float> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.CompositeSolver : object {
    private List`1<Tuple`2<IIterativeSolver`1<float>, IPreconditioner`1<float>>> _solvers;
    public CompositeSolver(IEnumerable`1<IIterativeSolverSetup`1<float>> solvers);
    public sealed virtual void Solve(Matrix`1<float> matrix, Vector`1<float> input, Vector`1<float> result, Iterator`1<float> iterator, IPreconditioner`1<float> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.DiagonalPreconditioner : object {
    private Single[] _inverseDiagonals;
    internal DiagonalMatrix DiagonalEntries();
    public sealed virtual void Initialize(Matrix`1<float> matrix);
    public sealed virtual void Approximate(Vector`1<float> rhs, Vector`1<float> lhs);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.GpBiCg : object {
    private int _numberOfBiCgStabSteps;
    private int _numberOfGpbiCgSteps;
    public int NumberOfBiCgStabSteps { get; public set; }
    public int NumberOfGpBiCgSteps { get; public set; }
    public int get_NumberOfBiCgStabSteps();
    public void set_NumberOfBiCgStabSteps(int value);
    public int get_NumberOfGpBiCgSteps();
    public void set_NumberOfGpBiCgSteps(int value);
    private static void CalculateTrueResidual(Matrix`1<float> matrix, Vector`1<float> residual, Vector`1<float> x, Vector`1<float> b);
    private bool ShouldRunBiCgStabSteps(int iterationNumber);
    public sealed virtual void Solve(Matrix`1<float> matrix, Vector`1<float> input, Vector`1<float> result, Iterator`1<float> iterator, IPreconditioner`1<float> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.ILU0Preconditioner : object {
    private SparseMatrix _decompositionLU;
    internal Matrix`1<float> UpperTriangle();
    internal Matrix`1<float> LowerTriangle();
    public sealed virtual void Initialize(Matrix`1<float> matrix);
    public sealed virtual void Approximate(Vector`1<float> rhs, Vector`1<float> lhs);
}
internal static class MathNet.Numerics.LinearAlgebra.Single.Solvers.ILUTPElementSorter : object {
    public static void SortDoubleIndicesDecreasing(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<float> values);
    private static void HeapSortDoublesIndices(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<float> values);
    private static void BuildDoubleIndexHeap(int start, int count, Int32[] sortedIndices, Vector`1<float> values);
    private static void SiftDoubleIndices(Int32[] sortedIndices, Vector`1<float> values, int begin, int count);
    public static void SortIntegersDecreasing(Int32[] values);
    private static void HeapSortIntegers(Int32[] values, int count);
    private static void BuildHeap(Int32[] values, int start, int count);
    private static void Sift(Int32[] values, int start, int count);
    private static void Exchange(Int32[] values, int first, int second);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.ILUTPPreconditioner : object {
    public static double DefaultFillLevel;
    public static double DefaultDropTolerance;
    private SparseMatrix _upper;
    private SparseMatrix _lower;
    private Int32[] _pivots;
    private double _fillLevel;
    private double _dropTolerance;
    private double _pivotTolerance;
    public double FillLevel { get; public set; }
    public double DropTolerance { get; public set; }
    public double PivotTolerance { get; public set; }
    public ILUTPPreconditioner(double fillLevel, double dropTolerance, double pivotTolerance);
    public double get_FillLevel();
    public void set_FillLevel(double value);
    public double get_DropTolerance();
    public void set_DropTolerance(double value);
    public double get_PivotTolerance();
    public void set_PivotTolerance(double value);
    internal Matrix`1<float> UpperTriangle();
    internal Matrix`1<float> LowerTriangle();
    internal Int32[] Pivots();
    public sealed virtual void Initialize(Matrix`1<float> matrix);
    private void PivotRow(Vector`1<float> row);
    private bool PivotMapFound(Dictionary`2<int, int> knownPivots, int currentItem);
    private static void SwapColumns(Matrix`1<float> matrix, int firstColumn, int secondColumn);
    private static void FindLargestItems(int lowerBound, int upperBound, Int32[] sortedIndices, Vector`1<float> values);
    public sealed virtual void Approximate(Vector`1<float> rhs, Vector`1<float> lhs);
    private void Pivot(Vector`1<float> vector, Vector`1<float> result);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.MILU0Preconditioner : object {
    private Single[] _alu;
    private Int32[] _jlu;
    private Int32[] _diag;
    [CompilerGeneratedAttribute]
private bool <UseModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool UseModified { get; public set; }
    public bool IsInitialized { get; private set; }
    public MILU0Preconditioner(bool modified);
    [CompilerGeneratedAttribute]
public bool get_UseModified();
    [CompilerGeneratedAttribute]
public void set_UseModified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual void Initialize(Matrix`1<float> matrix);
    public sealed virtual void Approximate(Vector`1<float> input, Vector`1<float> result);
    private int Compute(int n, Single[] a, Int32[] ja, Int32[] ia, Single[] alu, Int32[] jlu, Int32[] ju, bool modified);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.MlkBiCgStab : object {
    private static int DefaultNumberOfStartingVectors;
    private IList`1<Vector`1<float>> _startingVectors;
    private int _numberOfStartingVectors;
    public int NumberOfStartingVectors { get; public set; }
    public IList`1<Vector`1<float>> StartingVectors { get; public set; }
    [DebuggerStepThroughAttribute]
public int get_NumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public void set_NumberOfStartingVectors(int value);
    public void ResetNumberOfStartingVectors();
    [DebuggerStepThroughAttribute]
public IList`1<Vector`1<float>> get_StartingVectors();
    [DebuggerStepThroughAttribute]
public void set_StartingVectors(IList`1<Vector`1<float>> value);
    private static int NumberOfStartingVectorsToCreate(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static IList`1<Vector`1<float>> CreateStartingVectors(int maximumNumberOfStartingVectors, int numberOfVariables);
    private static Vector`1[] CreateVectorArray(int arraySize, int vectorSize);
    private static void CalculateTrueResidual(Matrix`1<float> matrix, Vector`1<float> residual, Vector`1<float> x, Vector`1<float> b);
    public sealed virtual void Solve(Matrix`1<float> matrix, Vector`1<float> input, Vector`1<float> result, Iterator`1<float> iterator, IPreconditioner`1<float> preconditioner);
}
public class MathNet.Numerics.LinearAlgebra.Single.Solvers.TFQMR : object {
    private static void CalculateTrueResidual(Matrix`1<float> matrix, Vector`1<float> residual, Vector`1<float> x, Vector`1<float> b);
    private static bool IsEven(int number);
    public sealed virtual void Solve(Matrix`1<float> matrix, Vector`1<float> input, Vector`1<float> result, Iterator`1<float> iterator, IPreconditioner`1<float> preconditioner);
}
[DebuggerDisplayAttribute("SparseMatrix {RowCount}x{ColumnCount}-Single {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Single.SparseMatrix : Matrix {
    private SparseCompressedRowMatrixStorage`1<float> _storage;
    public int NonZerosCount { get; }
    public SparseMatrix(SparseCompressedRowMatrixStorage`1<float> storage);
    public SparseMatrix(int order);
    public SparseMatrix(int rows, int columns);
    public int get_NonZerosCount();
    public static SparseMatrix OfMatrix(Matrix`1<float> matrix);
    public static SparseMatrix OfArray(Single[0...,0...] array);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<Tuple`3<int, int, float>> enumerable);
    public static SparseMatrix OfIndexed(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, float>> enumerable);
    public static SparseMatrix OfRowMajor(int rows, int columns, IEnumerable`1<float> rowMajor);
    public static SparseMatrix OfColumnMajor(int rows, int columns, IList`1<float> columnMajor);
    public static SparseMatrix OfColumns(IEnumerable`1<IEnumerable`1<float>> data);
    public static SparseMatrix OfColumns(int rows, int columns, IEnumerable`1<IEnumerable`1<float>> data);
    public static SparseMatrix OfColumnArrays(Single[][] columns);
    public static SparseMatrix OfColumnArrays(IEnumerable`1<Single[]> columns);
    public static SparseMatrix OfColumnVectors(Vector`1[] columns);
    public static SparseMatrix OfColumnVectors(IEnumerable`1<Vector`1<float>> columns);
    public static SparseMatrix OfRows(IEnumerable`1<IEnumerable`1<float>> data);
    public static SparseMatrix OfRows(int rows, int columns, IEnumerable`1<IEnumerable`1<float>> data);
    public static SparseMatrix OfRowArrays(Single[][] rows);
    public static SparseMatrix OfRowArrays(IEnumerable`1<Single[]> rows);
    public static SparseMatrix OfRowVectors(Vector`1[] rows);
    public static SparseMatrix OfRowVectors(IEnumerable`1<Vector`1<float>> rows);
    public static SparseMatrix OfDiagonalVector(Vector`1<float> diagonal);
    public static SparseMatrix OfDiagonalVector(int rows, int columns, Vector`1<float> diagonal);
    public static SparseMatrix OfDiagonalArray(Single[] diagonal);
    public static SparseMatrix OfDiagonalArray(int rows, int columns, Single[] diagonal);
    public static SparseMatrix Create(int rows, int columns, float value);
    public static SparseMatrix Create(int rows, int columns, Func`3<int, int, float> init);
    public static SparseMatrix CreateDiagonal(int rows, int columns, float value);
    public static SparseMatrix CreateDiagonal(int rows, int columns, Func`2<int, float> init);
    public static SparseMatrix CreateIdentity(int order);
    public virtual Matrix`1<float> LowerTriangle();
    public virtual void LowerTriangle(Matrix`1<float> result);
    private void LowerTriangleImpl(Matrix`1<float> result);
    public virtual Matrix`1<float> UpperTriangle();
    public virtual void UpperTriangle(Matrix`1<float> result);
    private void UpperTriangleImpl(Matrix`1<float> result);
    public virtual Matrix`1<float> StrictlyLowerTriangle();
    public virtual void StrictlyLowerTriangle(Matrix`1<float> result);
    private void StrictlyLowerTriangleImpl(Matrix`1<float> result);
    public virtual Matrix`1<float> StrictlyUpperTriangle();
    public virtual void StrictlyUpperTriangle(Matrix`1<float> result);
    private void StrictlyUpperTriangleImpl(Matrix`1<float> result);
    protected virtual void DoNegate(Matrix`1<float> result);
    public virtual double InfinityNorm();
    public virtual double FrobeniusNorm();
    protected virtual void DoAdd(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoSubtract(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoMultiply(float scalar, Matrix`1<float> result);
    protected virtual void DoMultiply(Matrix`1<float> other, Matrix`1<float> result);
    private void DoMultiplySparse(SparseMatrix other, SparseMatrix result);
    protected virtual void DoMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoTransposeAndMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoTransposeThisAndMultiply(Vector`1<float> rightSide, Vector`1<float> result);
    protected virtual void DoPointwiseMultiply(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoPointwiseDivide(Matrix`1<float> divisor, Matrix`1<float> result);
    public virtual void KroneckerProduct(Matrix`1<float> other, Matrix`1<float> result);
    protected virtual void DoModulus(float divisor, Matrix`1<float> result);
    protected virtual void DoRemainder(float divisor, Matrix`1<float> result);
    public virtual bool IsSymmetric();
    public static SparseMatrix op_Addition(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryPlus(SparseMatrix rightSide);
    public static SparseMatrix op_Subtraction(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_UnaryNegation(SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, float rightSide);
    public static SparseMatrix op_Multiply(float leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Multiply(SparseMatrix leftSide, SparseMatrix rightSide);
    public static SparseVector op_Multiply(SparseMatrix leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, SparseMatrix rightSide);
    public static SparseMatrix op_Modulus(SparseMatrix leftSide, float rightSide);
    public virtual string ToTypeString();
}
[DebuggerDisplayAttribute("SparseVector {Count}-Single {NonZerosCount}-NonZero")]
public class MathNet.Numerics.LinearAlgebra.Single.SparseVector : Vector {
    private SparseVectorStorage`1<float> _storage;
    public int NonZerosCount { get; }
    public SparseVector(SparseVectorStorage`1<float> storage);
    public SparseVector(int length);
    public int get_NonZerosCount();
    public static SparseVector OfVector(Vector`1<float> vector);
    public static SparseVector OfEnumerable(IEnumerable`1<float> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, float>> enumerable);
    public static SparseVector OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, float>> enumerable);
    public static SparseVector Create(int length, float value);
    public static SparseVector Create(int length, Func`2<int, float> init);
    protected virtual void DoAdd(float scalar, Vector`1<float> result);
    protected virtual void DoAdd(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoSubtract(float scalar, Vector`1<float> result);
    protected virtual void DoSubtract(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoNegate(Vector`1<float> result);
    protected virtual void DoMultiply(float scalar, Vector`1<float> result);
    protected virtual float DoDotProduct(Vector`1<float> other);
    protected virtual void DoModulus(float divisor, Vector`1<float> result);
    protected virtual void DoRemainder(float divisor, Vector`1<float> result);
    public static SparseVector op_Addition(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_UnaryNegation(SparseVector rightSide);
    public static SparseVector op_Subtraction(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Multiply(SparseVector leftSide, float rightSide);
    public static SparseVector op_Multiply(float leftSide, SparseVector rightSide);
    public static float op_Multiply(SparseVector leftSide, SparseVector rightSide);
    public static SparseVector op_Division(SparseVector leftSide, float rightSide);
    public static SparseVector op_Modulus(SparseVector leftSide, float rightSide);
    public virtual int AbsoluteMinimumIndex();
    public virtual int AbsoluteMaximumIndex();
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual float Sum();
    public virtual double L1Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    protected virtual void DoPointwiseMultiply(Vector`1<float> other, Vector`1<float> result);
    public static SparseVector Parse(string value, IFormatProvider formatProvider);
    public static bool TryParse(string value, SparseVector& result);
    public static bool TryParse(string value, IFormatProvider formatProvider, SparseVector& result);
    public virtual string ToTypeString();
    [CompilerGeneratedAttribute]
private float <InfinityNorm>b__34_0(int i);
}
public abstract class MathNet.Numerics.LinearAlgebra.Single.Vector : Vector`1<float> {
    protected Vector(VectorStorage`1<float> storage);
    public virtual void CoerceZero(double threshold);
    protected sealed virtual void DoConjugate(Vector`1<float> result);
    protected virtual void DoNegate(Vector`1<float> result);
    protected virtual void DoAdd(float scalar, Vector`1<float> result);
    protected virtual void DoAdd(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoSubtract(float scalar, Vector`1<float> result);
    protected virtual void DoSubtract(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoMultiply(float scalar, Vector`1<float> result);
    protected virtual void DoDivide(float divisor, Vector`1<float> result);
    protected virtual void DoDivideByThis(float dividend, Vector`1<float> result);
    protected virtual void DoPointwiseMultiply(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseDivide(Vector`1<float> divisor, Vector`1<float> result);
    protected virtual void DoPointwisePower(float exponent, Vector`1<float> result);
    protected virtual void DoPointwisePower(Vector`1<float> exponent, Vector`1<float> result);
    protected virtual void DoPointwiseModulus(Vector`1<float> divisor, Vector`1<float> result);
    protected virtual void DoPointwiseRemainder(Vector`1<float> divisor, Vector`1<float> result);
    protected virtual void DoPointwiseExp(Vector`1<float> result);
    protected virtual void DoPointwiseLog(Vector`1<float> result);
    protected virtual void DoPointwiseAbs(Vector`1<float> result);
    protected virtual void DoPointwiseAcos(Vector`1<float> result);
    protected virtual void DoPointwiseAsin(Vector`1<float> result);
    protected virtual void DoPointwiseAtan(Vector`1<float> result);
    protected virtual void DoPointwiseAtan2(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseAtan2(float scalar, Vector`1<float> result);
    protected virtual void DoPointwiseCeiling(Vector`1<float> result);
    protected virtual void DoPointwiseCos(Vector`1<float> result);
    protected virtual void DoPointwiseCosh(Vector`1<float> result);
    protected virtual void DoPointwiseFloor(Vector`1<float> result);
    protected virtual void DoPointwiseLog10(Vector`1<float> result);
    protected virtual void DoPointwiseRound(Vector`1<float> result);
    protected virtual void DoPointwiseSign(Vector`1<float> result);
    protected virtual void DoPointwiseSin(Vector`1<float> result);
    protected virtual void DoPointwiseSinh(Vector`1<float> result);
    protected virtual void DoPointwiseSqrt(Vector`1<float> result);
    protected virtual void DoPointwiseTan(Vector`1<float> result);
    protected virtual void DoPointwiseTanh(Vector`1<float> result);
    protected virtual float DoDotProduct(Vector`1<float> other);
    protected sealed virtual float DoConjugateDotProduct(Vector`1<float> other);
    protected virtual void DoModulus(float divisor, Vector`1<float> result);
    protected virtual void DoModulusByThis(float dividend, Vector`1<float> result);
    protected virtual void DoRemainder(float divisor, Vector`1<float> result);
    protected virtual void DoRemainderByThis(float dividend, Vector`1<float> result);
    protected virtual void DoPointwiseMinimum(float scalar, Vector`1<float> result);
    protected virtual void DoPointwiseMaximum(float scalar, Vector`1<float> result);
    protected virtual void DoPointwiseAbsoluteMinimum(float scalar, Vector`1<float> result);
    protected virtual void DoPointwiseAbsoluteMaximum(float scalar, Vector`1<float> result);
    protected virtual void DoPointwiseMinimum(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseMaximum(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseAbsoluteMinimum(Vector`1<float> other, Vector`1<float> result);
    protected virtual void DoPointwiseAbsoluteMaximum(Vector`1<float> other, Vector`1<float> result);
    public virtual float AbsoluteMinimum();
    public virtual int AbsoluteMinimumIndex();
    public virtual float AbsoluteMaximum();
    public virtual int AbsoluteMaximumIndex();
    public virtual float Sum();
    public virtual double L1Norm();
    public virtual double L2Norm();
    public virtual double InfinityNorm();
    public virtual double Norm(double p);
    public virtual int MaximumIndex();
    public virtual int MinimumIndex();
    public virtual Vector`1<float> Normalize(double p);
    [CompilerGeneratedAttribute]
private float <InfinityNorm>b__58_0(int i);
}
internal class MathNet.Numerics.LinearAlgebra.Single.VectorBuilder : VectorBuilder`1<float> {
    public float Zero { get; }
    public float One { get; }
    public virtual float get_Zero();
    public virtual float get_One();
    public virtual Vector`1<float> Dense(DenseVectorStorage`1<float> storage);
    public virtual Vector`1<float> Sparse(SparseVectorStorage`1<float> storage);
    public virtual Vector`1<float> Random(int length, IContinuousDistribution distribution);
}
public class MathNet.Numerics.LinearAlgebra.Solvers.CancellationStopCriterion`1 : object {
    private CancellationToken _masterToken;
    private CancellationTokenSource _currentTcs;
    public IterationStatus Status { get; }
    public CancellationStopCriterion`1(CancellationToken masterToken);
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    [DebuggerStepThroughAttribute]
public sealed virtual IterationStatus get_Status();
    public void Cancel();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public class MathNet.Numerics.LinearAlgebra.Solvers.DelegateStopCriterion`1 : object {
    private Func`5<int, Vector`1<T>, Vector`1<T>, Vector`1<T>, IterationStatus> _determine;
    private IterationStatus _status;
    public IterationStatus Status { get; }
    public DelegateStopCriterion`1(Func`5<int, Vector`1<T>, Vector`1<T>, Vector`1<T>, IterationStatus> determine);
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    public sealed virtual IterationStatus get_Status();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public class MathNet.Numerics.LinearAlgebra.Solvers.DivergenceStopCriterion`1 : object {
    private double _maximumRelativeIncrease;
    private int _minimumNumberOfIterations;
    private IterationStatus _status;
    private Double[] _residualHistory;
    private int _lastIteration;
    public double MaximumRelativeIncrease { get; public set; }
    public int MinimumNumberOfIterations { get; public set; }
    private int RequiredHistoryLength { get; }
    public IterationStatus Status { get; }
    public DivergenceStopCriterion`1(double maximumRelativeIncrease, int minimumIterations);
    [DebuggerStepThroughAttribute]
public double get_MaximumRelativeIncrease();
    [DebuggerStepThroughAttribute]
public void set_MaximumRelativeIncrease(double value);
    [DebuggerStepThroughAttribute]
public int get_MinimumNumberOfIterations();
    [DebuggerStepThroughAttribute]
public void set_MinimumNumberOfIterations(int value);
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    private bool IsDiverging();
    [DebuggerStepThroughAttribute]
private int get_RequiredHistoryLength();
    [DebuggerStepThroughAttribute]
public sealed virtual IterationStatus get_Status();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public class MathNet.Numerics.LinearAlgebra.Solvers.FailureStopCriterion`1 : object {
    private IterationStatus _status;
    private int _lastIteration;
    public IterationStatus Status { get; }
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    [DebuggerStepThroughAttribute]
public sealed virtual IterationStatus get_Status();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public interface MathNet.Numerics.LinearAlgebra.Solvers.IIterationStopCriterion`1 {
    public IterationStatus Status { get; }
    public abstract virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    public abstract virtual IterationStatus get_Status();
    public abstract virtual void Reset();
    public abstract virtual IIterationStopCriterion`1<T> Clone();
}
public interface MathNet.Numerics.LinearAlgebra.Solvers.IIterativeSolver`1 {
    public abstract virtual void Solve(Matrix`1<T> matrix, Vector`1<T> input, Vector`1<T> result, Iterator`1<T> iterator, IPreconditioner`1<T> preconditioner);
}
public interface MathNet.Numerics.LinearAlgebra.Solvers.IIterativeSolverSetup`1 {
    public Type SolverType { get; }
    public Type PreconditionerType { get; }
    public double SolutionSpeed { get; }
    public double Reliability { get; }
    public abstract virtual Type get_SolverType();
    public abstract virtual Type get_PreconditionerType();
    public abstract virtual IIterativeSolver`1<T> CreateSolver();
    public abstract virtual IPreconditioner`1<T> CreatePreconditioner();
    public abstract virtual double get_SolutionSpeed();
    public abstract virtual double get_Reliability();
}
public interface MathNet.Numerics.LinearAlgebra.Solvers.IPreconditioner`1 {
    public abstract virtual void Initialize(Matrix`1<T> matrix);
    public abstract virtual void Approximate(Vector`1<T> rhs, Vector`1<T> lhs);
}
public class MathNet.Numerics.LinearAlgebra.Solvers.IterationCountStopCriterion`1 : object {
    public static int DefaultMaximumNumberOfIterations;
    private int _maximumNumberOfIterations;
    private IterationStatus _status;
    public int MaximumNumberOfIterations { get; public set; }
    public IterationStatus Status { get; }
    public IterationCountStopCriterion`1(int maximumNumberOfIterations);
    [DebuggerStepThroughAttribute]
public int get_MaximumNumberOfIterations();
    [DebuggerStepThroughAttribute]
public void set_MaximumNumberOfIterations(int value);
    public void ResetMaximumNumberOfIterationsToDefault();
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    [DebuggerStepThroughAttribute]
public sealed virtual IterationStatus get_Status();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public enum MathNet.Numerics.LinearAlgebra.Solvers.IterationStatus : Enum {
    public int value__;
    public static IterationStatus Continue;
    public static IterationStatus Converged;
    public static IterationStatus Diverged;
    public static IterationStatus StoppedWithoutConvergence;
    public static IterationStatus Cancelled;
    public static IterationStatus Failure;
}
public class MathNet.Numerics.LinearAlgebra.Solvers.Iterator`1 : object {
    private List`1<IIterationStopCriterion`1<T>> _stopCriteria;
    private IterationStatus _status;
    public IterationStatus Status { get; }
    public Iterator`1(IIterationStopCriterion`1[] stopCriteria);
    public Iterator`1(IEnumerable`1<IIterationStopCriterion`1<T>> stopCriteria);
    public IterationStatus get_Status();
    public IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    public void Cancel();
    public void Reset();
    public Iterator`1<T> Clone();
}
public class MathNet.Numerics.LinearAlgebra.Solvers.ResidualStopCriterion`1 : object {
    private double _maximum;
    private int _minimumIterationsBelowMaximum;
    private IterationStatus _status;
    private int _iterationCount;
    private int _lastIteration;
    public double Maximum { get; public set; }
    public int MinimumIterationsBelowMaximum { get; public set; }
    public IterationStatus Status { get; }
    public ResidualStopCriterion`1(double maximum, int minimumIterationsBelowMaximum);
    [DebuggerStepThroughAttribute]
public double get_Maximum();
    [DebuggerStepThroughAttribute]
public void set_Maximum(double value);
    [DebuggerStepThroughAttribute]
public int get_MinimumIterationsBelowMaximum();
    [DebuggerStepThroughAttribute]
public void set_MinimumIterationsBelowMaximum(int value);
    public sealed virtual IterationStatus DetermineStatus(int iterationNumber, Vector`1<T> solutionVector, Vector`1<T> sourceVector, Vector`1<T> residualVector);
    [DebuggerStepThroughAttribute]
public sealed virtual IterationStatus get_Status();
    public sealed virtual void Reset();
    public sealed virtual IIterationStopCriterion`1<T> Clone();
}
public static class MathNet.Numerics.LinearAlgebra.Solvers.SolverSetup`1 : object {
    public static IEnumerable`1<IIterativeSolverSetup`1<T>> LoadFromAssembly(Assembly assembly, bool ignoreFailed, Type[] typesToExclude);
    public static IEnumerable`1<IIterativeSolverSetup`1<T>> LoadFromAssembly(Type typeInAssembly, bool ignoreFailed, Type[] typesToExclude);
    public static IEnumerable`1<IIterativeSolverSetup`1<T>> LoadFromAssembly(AssemblyName assemblyName, bool ignoreFailed, Type[] typesToExclude);
    public static IEnumerable`1<IIterativeSolverSetup`1<T>> Load(Type[] typesToExclude);
    public static IEnumerable`1<IIterativeSolverSetup`1<T>> Load();
}
public class MathNet.Numerics.LinearAlgebra.Solvers.UnitPreconditioner`1 : object {
    private int _size;
    public sealed virtual void Initialize(Matrix`1<T> matrix);
    public sealed virtual void Approximate(Vector`1<T> rhs, Vector`1<T> lhs);
}
[DataContractAttribute]
public class MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage`1 : MatrixStorage`1<T> {
    [DataMemberAttribute]
public T[] Data;
    public bool IsDense { get; }
    public bool IsFullyMutable { get; }
    internal DenseColumnMajorMatrixStorage`1(int rows, int columns);
    internal DenseColumnMajorMatrixStorage`1(int rows, int columns, T[] data);
    public virtual bool get_IsDense();
    public virtual bool get_IsFullyMutable();
    public virtual bool IsMutableAt(int row, int column);
    public virtual T At(int row, int column);
    public virtual void At(int row, int column, T value);
    private void RowColumnAtIndex(int index, Int32& row, Int32& column);
    public virtual void Clear();
    internal virtual void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount);
    internal virtual void ClearRowsUnchecked(Int32[] rowIndices);
    internal virtual void ClearColumnsUnchecked(Int32[] columnIndices);
    public static DenseColumnMajorMatrixStorage`1<T> OfMatrix(MatrixStorage`1<T> matrix);
    public static DenseColumnMajorMatrixStorage`1<T> OfValue(int rows, int columns, T value);
    public static DenseColumnMajorMatrixStorage`1<T> OfInit(int rows, int columns, Func`3<int, int, T> init);
    public static DenseColumnMajorMatrixStorage`1<T> OfDiagonalInit(int rows, int columns, Func`2<int, T> init);
    public static DenseColumnMajorMatrixStorage`1<T> OfArray(T[0...,0...] array);
    public static DenseColumnMajorMatrixStorage`1<T> OfColumnArrays(T[][] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfRowArrays(T[][] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfColumnMajorArray(int rows, int columns, T[] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfRowMajorArray(int rows, int columns, T[] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfColumnVectors(VectorStorage`1[] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfRowVectors(VectorStorage`1[] data);
    public static DenseColumnMajorMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> data);
    public static DenseColumnMajorMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> data);
    public static DenseColumnMajorMatrixStorage`1<T> OfColumnMajorEnumerable(int rows, int columns, IEnumerable`1<T> data);
    public static DenseColumnMajorMatrixStorage`1<T> OfRowMajorEnumerable(int rows, int columns, IEnumerable`1<T> data);
    public static DenseColumnMajorMatrixStorage`1<T> OfColumnEnumerables(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static DenseColumnMajorMatrixStorage`1<T> OfRowEnumerables(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    internal virtual void CopyToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    private void CopyToUnchecked(DenseColumnMajorMatrixStorage`1<T> target);
    internal virtual void CopySubMatrixToUnchecked(MatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    private void CopySubMatrixToUnchecked(DenseColumnMajorMatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount);
    internal virtual void CopySubRowToUnchecked(VectorStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubColumnToUnchecked(VectorStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    internal virtual void TransposeToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    private void TransposeToUnchecked(DenseColumnMajorMatrixStorage`1<T> target);
    private void TransposeToUnchecked(SparseCompressedRowMatrixStorage`1<T> target);
    internal virtual void TransposeSquareInplaceUnchecked();
    public virtual T[] ToRowMajorArray();
    public virtual T[] ToColumnMajorArray();
    public virtual T[][] ToRowArrays();
    public virtual T[][] ToColumnArrays();
    public virtual T[0...,0...] ToArray();
    public virtual T[] AsColumnMajorArray();
    public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage`1/<EnumerateIndexed>d__49")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed();
    public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage`1/<EnumerateNonZeroIndexed>d__51")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`3<int, int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    internal virtual Tuple`4<int, int, T, TOther> Find2Unchecked(MatrixStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`4<int, int, T, T> f, Zeros zeros);
    internal virtual void MapToUnchecked(MatrixStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapSubMatrixIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    internal virtual void FoldByRowUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual void FoldByColumnUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual TState Fold2Unchecked(MatrixStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
}
[DataContractAttribute]
public class MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage`1 : VectorStorage`1<T> {
    [DataMemberAttribute]
public T[] Data;
    public bool IsDense { get; }
    internal DenseVectorStorage`1(int length);
    internal DenseVectorStorage`1(int length, T[] data);
    public virtual bool get_IsDense();
    public virtual T At(int index);
    public virtual void At(int index, T value);
    public virtual void Clear();
    public virtual void Clear(int index, int count);
    public static DenseVectorStorage`1<T> OfVector(VectorStorage`1<T> vector);
    public static DenseVectorStorage`1<T> OfValue(int length, T value);
    public static DenseVectorStorage`1<T> OfInit(int length, Func`2<int, T> init);
    public static DenseVectorStorage`1<T> OfEnumerable(IEnumerable`1<T> data);
    public static DenseVectorStorage`1<T> OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, T>> data);
    public static DenseVectorStorage`1<T> OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, T>> data);
    internal virtual void CopyToUnchecked(VectorStorage`1<T> target, ExistingData existingData);
    internal virtual void CopyToRowUnchecked(MatrixStorage`1<T> target, int rowIndex, ExistingData existingData);
    internal virtual void CopyToColumnUnchecked(MatrixStorage`1<T> target, int columnIndex, ExistingData existingData);
    internal virtual void CopySubVectorToUnchecked(VectorStorage`1<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData);
    internal virtual void CopyToSubRowUnchecked(MatrixStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopyToSubColumnUnchecked(MatrixStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    public virtual T[] ToArray();
    public virtual T[] AsArray();
    public virtual IEnumerable`1<T> Enumerate();
    public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateIndexed();
    public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage`1/<EnumerateNonZeroIndexed>d__26")]
public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`2<int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    internal virtual Tuple`3<int, T, TOther> Find2Unchecked(VectorStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`3<int, T, T> f, Zeros zeros);
    internal virtual void MapToUnchecked(VectorStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(VectorStorage`1<TU> target, Func`3<int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void Map2ToUnchecked(VectorStorage`1<T> target, VectorStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    internal virtual TState Fold2Unchecked(VectorStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
}
[DataContractAttribute]
public class MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage`1 : MatrixStorage`1<T> {
    [DataMemberAttribute]
public T[] Data;
    public bool IsDense { get; }
    public bool IsFullyMutable { get; }
    internal DiagonalMatrixStorage`1(int rows, int columns);
    internal DiagonalMatrixStorage`1(int rows, int columns, T[] data);
    public virtual bool get_IsDense();
    public virtual bool get_IsFullyMutable();
    public virtual bool IsMutableAt(int row, int column);
    public virtual T At(int row, int column);
    public virtual void At(int row, int column, T value);
    public virtual int GetHashCode();
    public virtual void Clear();
    internal virtual void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount);
    internal virtual void ClearRowsUnchecked(Int32[] rowIndices);
    internal virtual void ClearColumnsUnchecked(Int32[] columnIndices);
    public static DiagonalMatrixStorage`1<T> OfMatrix(MatrixStorage`1<T> matrix);
    public static DiagonalMatrixStorage`1<T> OfArray(T[0...,0...] array);
    public static DiagonalMatrixStorage`1<T> OfValue(int rows, int columns, T diagonalValue);
    public static DiagonalMatrixStorage`1<T> OfInit(int rows, int columns, Func`2<int, T> init);
    public static DiagonalMatrixStorage`1<T> OfEnumerable(int rows, int columns, IEnumerable`1<T> data);
    public static DiagonalMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<Tuple`2<int, T>> data);
    public static DiagonalMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<ValueTuple`2<int, T>> data);
    internal virtual void CopyToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    private void CopyToUnchecked(DiagonalMatrixStorage`1<T> target);
    private void CopyToUnchecked(SparseCompressedRowMatrixStorage`1<T> target, ExistingData existingData);
    private void CopyToUnchecked(DenseColumnMajorMatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void CopySubMatrixToUnchecked(MatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    private void CopySubMatrixToUnchecked(DiagonalMatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount);
    private void CopySubMatrixToUnchecked(DenseColumnMajorMatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubRowToUnchecked(VectorStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubColumnToUnchecked(VectorStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    internal virtual void TransposeToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void TransposeSquareInplaceUnchecked();
    public virtual T[] ToRowMajorArray();
    public virtual T[] ToColumnMajorArray();
    public virtual T[][] ToRowArrays();
    public virtual T[][] ToColumnArrays();
    public virtual T[0...,0...] ToArray();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage`1/<Enumerate>d__38")]
public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage`1/<EnumerateIndexed>d__39")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed();
    public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage`1/<EnumerateNonZeroIndexed>d__41")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`3<int, int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    internal virtual Tuple`4<int, int, T, TOther> Find2Unchecked(MatrixStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`4<int, int, T, T> f, Zeros zeros);
    internal virtual void MapToUnchecked(MatrixStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapSubMatrixIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    private void MapSubMatrixIndexedToUnchecked(DiagonalMatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros);
    private void MapSubMatrixIndexedToUnchecked(DenseColumnMajorMatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    internal virtual void FoldByRowUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual void FoldByColumnUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual TState Fold2Unchecked(MatrixStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public abstract class MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage`1 : object {
    protected static T Zero;
    [DataMemberAttribute]
public int RowCount;
    [DataMemberAttribute]
public int ColumnCount;
    public bool IsDense { get; }
    public bool IsFullyMutable { get; }
    public T Item { get; public set; }
    protected MatrixStorage`1(int rowCount, int columnCount);
    private static MatrixStorage`1();
    public abstract virtual bool get_IsDense();
    public abstract virtual bool get_IsFullyMutable();
    public abstract virtual bool IsMutableAt(int row, int column);
    public T get_Item(int row, int column);
    public void set_Item(int row, int column, T value);
    public abstract virtual T At(int row, int column);
    public abstract virtual void At(int row, int column, T value);
    public sealed virtual bool Equals(MatrixStorage`1<T> other);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Clear();
    public void Clear(int rowIndex, int rowCount, int columnIndex, int columnCount);
    internal virtual void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount);
    public void ClearRows(Int32[] rowIndices);
    public void ClearColumns(Int32[] columnIndices);
    internal virtual void ClearRowsUnchecked(Int32[] rowIndices);
    internal virtual void ClearColumnsUnchecked(Int32[] columnIndices);
    public void CopyTo(MatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void CopyToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    public void CopySubMatrixTo(MatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubMatrixToUnchecked(MatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    public void CopyRowTo(VectorStorage`1<T> target, int rowIndex, ExistingData existingData);
    public void CopySubRowTo(VectorStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubRowToUnchecked(VectorStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    public void CopyColumnTo(VectorStorage`1<T> target, int columnIndex, ExistingData existingData);
    public void CopySubColumnTo(VectorStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    internal virtual void CopySubColumnToUnchecked(VectorStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    public void TransposeTo(MatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void TransposeToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void TransposeSquareInplaceUnchecked();
    public virtual T[] ToRowMajorArray();
    public virtual T[] ToColumnMajorArray();
    public virtual T[][] ToRowArrays();
    public virtual T[][] ToColumnArrays();
    public virtual T[0...,0...] ToArray();
    public virtual T[] AsRowMajorArray();
    public virtual T[] AsColumnMajorArray();
    public virtual T[][] AsRowArrays();
    public virtual T[][] AsColumnArrays();
    public virtual T[0...,0...] AsArray();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage`1/<Enumerate>d__47")]
public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage`1/<EnumerateIndexed>d__48")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage`1/<EnumerateNonZero>d__49")]
public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage`1/<EnumerateNonZeroIndexed>d__50")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`3<int, int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    public Tuple`4<int, int, T, TOther> Find2(MatrixStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    internal virtual Tuple`4<int, int, T, TOther> Find2Unchecked(MatrixStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`4<int, int, T, T> f, Zeros zeros);
    public void MapTo(MatrixStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapToUnchecked(MatrixStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    public void MapIndexedTo(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, Zeros zeros, ExistingData existingData);
    public void MapSubMatrixIndexedTo(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    internal virtual void MapSubMatrixIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    public void Map2To(MatrixStorage`1<T> target, MatrixStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    internal virtual void Map2ToUnchecked(MatrixStorage`1<T> target, MatrixStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    public void FoldByRow(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual void FoldByRowUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    public void FoldByColumn(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual void FoldByColumnUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    public TState Fold2(MatrixStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
    internal virtual TState Fold2Unchecked(MatrixStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
    private void ValidateRange(int row, int column);
    private void ValidateSubMatrixRange(MatrixStorage`1<TU> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount);
    private void ValidateRowRange(VectorStorage`1<TU> target, int rowIndex);
    private void ValidateColumnRange(VectorStorage`1<TU> target, int columnIndex);
    private void ValidateSubRowRange(VectorStorage`1<TU> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount);
    private void ValidateSubColumnRange(VectorStorage`1<TU> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount);
}
[DataContractAttribute]
public class MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage`1 : MatrixStorage`1<T> {
    [DataMemberAttribute]
public Int32[] RowPointers;
    [DataMemberAttribute]
public Int32[] ColumnIndices;
    [DataMemberAttribute]
public T[] Values;
    public int ValueCount { get; }
    public bool IsDense { get; }
    public bool IsFullyMutable { get; }
    internal SparseCompressedRowMatrixStorage`1(int rows, int columns);
    internal SparseCompressedRowMatrixStorage`1(int rows, int columns, Int32[] rowPointers, Int32[] columnIndices, T[] values);
    public int get_ValueCount();
    public virtual bool get_IsDense();
    public virtual bool get_IsFullyMutable();
    public virtual bool IsMutableAt(int row, int column);
    public virtual T At(int row, int column);
    public virtual void At(int row, int column, T value);
    private void RemoveAtIndexUnchecked(int itemIndex, int row);
    public int FindItem(int row, int column);
    private int GrowthSize();
    public void Normalize();
    public void NormalizeOrdering();
    public void NormalizeZeros();
    public void NormalizeDuplicates();
    public void PopulateExplicitZerosOnDiagonal();
    public virtual int GetHashCode();
    public virtual void Clear();
    internal virtual void ClearUnchecked(int rowIndex, int rowCount, int columnIndex, int columnCount);
    internal virtual void ClearRowsUnchecked(Int32[] rowIndices);
    internal virtual void ClearColumnsUnchecked(Int32[] columnIndices);
    public static SparseCompressedRowMatrixStorage`1<T> OfMatrix(MatrixStorage`1<T> matrix);
    public static SparseCompressedRowMatrixStorage`1<T> OfValue(int rows, int columns, T value);
    public static SparseCompressedRowMatrixStorage`1<T> OfInit(int rows, int columns, Func`3<int, int, T> init);
    public static SparseCompressedRowMatrixStorage`1<T> OfDiagonalInit(int rows, int columns, Func`2<int, T> init);
    public static SparseCompressedRowMatrixStorage`1<T> OfArray(T[0...,0...] array);
    public static SparseCompressedRowMatrixStorage`1<T> OfRowArrays(T[][] data);
    public static SparseCompressedRowMatrixStorage`1<T> OfColumnArrays(T[][] data);
    public static SparseCompressedRowMatrixStorage`1<T> OfRowVectors(VectorStorage`1[] data);
    public static SparseCompressedRowMatrixStorage`1<T> OfColumnVectors(VectorStorage`1[] data);
    public static SparseCompressedRowMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<Tuple`3<int, int, T>> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfIndexedEnumerable(int rows, int columns, IEnumerable`1<ValueTuple`3<int, int, T>> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfRowEnumerables(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfColumnEnumerables(int rows, int columns, IEnumerable`1<IEnumerable`1<T>> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfRowMajorEnumerable(int rows, int columns, IEnumerable`1<T> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfColumnMajorList(int rows, int columns, IList`1<T> data);
    public static SparseCompressedRowMatrixStorage`1<T> OfCompressedSparseRowFormat(int rows, int columns, int valueCount, Int32[] rowPointers, Int32[] columnIndices, T[] values);
    public static SparseCompressedRowMatrixStorage`1<T> OfCompressedSparseColumnFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnPointers, T[] values);
    public static SparseCompressedRowMatrixStorage`1<T> OfCoordinateFormat(int rows, int columns, int valueCount, Int32[] rowIndices, Int32[] columnIndices, T[] values);
    internal virtual void CopyToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    private void CopyToUnchecked(SparseCompressedRowMatrixStorage`1<T> target);
    private void CopyToUnchecked(DenseColumnMajorMatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void CopySubMatrixToUnchecked(MatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    private void CopySubMatrixToUnchecked(SparseCompressedRowMatrixStorage`1<T> target, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopySubRowToUnchecked(VectorStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void TransposeToUnchecked(MatrixStorage`1<T> target, ExistingData existingData);
    private void TransposeToUnchecked(SparseCompressedRowMatrixStorage`1<T> target);
    private void TransposeToUnchecked(DenseColumnMajorMatrixStorage`1<T> target, ExistingData existingData);
    internal virtual void TransposeSquareInplaceUnchecked();
    public virtual T[] ToRowMajorArray();
    public virtual T[] ToColumnMajorArray();
    public virtual T[][] ToRowArrays();
    public virtual T[][] ToColumnArrays();
    public virtual T[0...,0...] ToArray();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage`1/<Enumerate>d__60")]
public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage`1/<EnumerateIndexed>d__61")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateIndexed();
    public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage`1/<EnumerateNonZeroIndexed>d__63")]
public virtual IEnumerable`1<ValueTuple`3<int, int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`3<int, int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    internal virtual Tuple`4<int, int, T, TOther> Find2Unchecked(MatrixStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`4<int, int, T, T> f, Zeros zeros);
    internal virtual void MapToUnchecked(MatrixStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapSubMatrixIndexedToUnchecked(MatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    private void MapSubMatrixIndexedToUnchecked(SparseCompressedRowMatrixStorage`1<TU> target, Func`4<int, int, T, TU> f, int sourceRowIndex, int targetRowIndex, int rowCount, int sourceColumnIndex, int targetColumnIndex, int columnCount, Zeros zeros, ExistingData existingData);
    internal virtual void FoldByRowUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual void FoldByColumnUnchecked(TU[] target, Func`3<TU, T, TU> f, Func`3<TU, int, TU> finalize, TU[] state, Zeros zeros);
    internal virtual TState Fold2Unchecked(MatrixStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
}
[DataContractAttribute]
public class MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage`1 : VectorStorage`1<T> {
    [DataMemberAttribute]
public Int32[] Indices;
    [DataMemberAttribute]
public T[] Values;
    [DataMemberAttribute]
public int ValueCount;
    public bool IsDense { get; }
    internal SparseVectorStorage`1(int length);
    public virtual bool get_IsDense();
    public virtual T At(int index);
    public virtual void At(int index, T value);
    internal void InsertAtIndexUnchecked(int itemIndex, int index, T value);
    internal void RemoveAtIndexUnchecked(int itemIndex);
    private int GrowthSize();
    public virtual bool Equals(VectorStorage`1<T> other);
    public virtual int GetHashCode();
    public virtual void Clear();
    public virtual void Clear(int index, int count);
    public static SparseVectorStorage`1<T> OfVector(VectorStorage`1<T> vector);
    public static SparseVectorStorage`1<T> OfValue(int length, T value);
    public static SparseVectorStorage`1<T> OfInit(int length, Func`2<int, T> init);
    public static SparseVectorStorage`1<T> OfEnumerable(IEnumerable`1<T> data);
    public static SparseVectorStorage`1<T> OfIndexedEnumerable(int length, IEnumerable`1<Tuple`2<int, T>> data);
    public static SparseVectorStorage`1<T> OfIndexedEnumerable(int length, IEnumerable`1<ValueTuple`2<int, T>> data);
    internal virtual void CopyToUnchecked(VectorStorage`1<T> target, ExistingData existingData);
    private void CopyToUnchecked(SparseVectorStorage`1<T> target);
    internal virtual void CopyToRowUnchecked(MatrixStorage`1<T> target, int rowIndex, ExistingData existingData);
    internal virtual void CopyToColumnUnchecked(MatrixStorage`1<T> target, int columnIndex, ExistingData existingData);
    internal virtual void CopySubVectorToUnchecked(VectorStorage`1<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData);
    private void CopySubVectorToUnchecked(SparseVectorStorage`1<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData);
    public virtual T[] ToArray();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage`1/<Enumerate>d__28")]
public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage`1/<EnumerateIndexed>d__29")]
public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateIndexed();
    public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage`1/<EnumerateNonZeroIndexed>d__31")]
public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`2<int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    internal virtual Tuple`3<int, T, TOther> Find2Unchecked(VectorStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`3<int, T, T> f, Zeros zeros);
    internal virtual void MapToUnchecked(VectorStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(VectorStorage`1<TU> target, Func`3<int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void Map2ToUnchecked(VectorStorage`1<T> target, VectorStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    internal virtual TState Fold2Unchecked(VectorStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public abstract class MathNet.Numerics.LinearAlgebra.Storage.VectorStorage`1 : object {
    protected static T Zero;
    [DataMemberAttribute]
public int Length;
    public bool IsDense { get; }
    public T Item { get; public set; }
    protected VectorStorage`1(int length);
    private static VectorStorage`1();
    public abstract virtual bool get_IsDense();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public abstract virtual T At(int index);
    public abstract virtual void At(int index, T value);
    public virtual bool Equals(VectorStorage`1<T> other);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Clear();
    public virtual void Clear(int index, int count);
    public void CopyTo(VectorStorage`1<T> target, ExistingData existingData);
    internal virtual void CopyToUnchecked(VectorStorage`1<T> target, ExistingData existingData);
    public void CopyToRow(MatrixStorage`1<T> target, int rowIndex, ExistingData existingData);
    internal virtual void CopyToRowUnchecked(MatrixStorage`1<T> target, int rowIndex, ExistingData existingData);
    public void CopyToColumn(MatrixStorage`1<T> target, int columnIndex, ExistingData existingData);
    internal virtual void CopyToColumnUnchecked(MatrixStorage`1<T> target, int columnIndex, ExistingData existingData);
    public void CopySubVectorTo(VectorStorage`1<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData);
    internal virtual void CopySubVectorToUnchecked(VectorStorage`1<T> target, int sourceIndex, int targetIndex, int count, ExistingData existingData);
    public void CopyToSubRow(MatrixStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    internal virtual void CopyToSubRowUnchecked(MatrixStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount, ExistingData existingData);
    public void CopyToSubColumn(MatrixStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    internal virtual void CopyToSubColumnUnchecked(MatrixStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount, ExistingData existingData);
    public virtual T[] ToArray();
    public virtual T[] AsArray();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.VectorStorage`1/<Enumerate>d__29")]
public virtual IEnumerable`1<T> Enumerate();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.VectorStorage`1/<EnumerateIndexed>d__30")]
public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateIndexed();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.VectorStorage`1/<EnumerateNonZero>d__31")]
public virtual IEnumerable`1<T> EnumerateNonZero();
    [IteratorStateMachineAttribute("MathNet.Numerics.LinearAlgebra.Storage.VectorStorage`1/<EnumerateNonZeroIndexed>d__32")]
public virtual IEnumerable`1<ValueTuple`2<int, T>> EnumerateNonZeroIndexed();
    public virtual Tuple`2<int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    public Tuple`3<int, T, TOther> Find2(VectorStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    internal virtual Tuple`3<int, T, TOther> Find2Unchecked(VectorStorage`1<TOther> other, Func`3<T, TOther, bool> predicate, Zeros zeros);
    public virtual void MapInplace(Func`2<T, T> f, Zeros zeros);
    public virtual void MapIndexedInplace(Func`3<int, T, T> f, Zeros zeros);
    public void MapTo(VectorStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapToUnchecked(VectorStorage`1<TU> target, Func`2<T, TU> f, Zeros zeros, ExistingData existingData);
    public void MapIndexedTo(VectorStorage`1<TU> target, Func`3<int, T, TU> f, Zeros zeros, ExistingData existingData);
    internal virtual void MapIndexedToUnchecked(VectorStorage`1<TU> target, Func`3<int, T, TU> f, Zeros zeros, ExistingData existingData);
    public void Map2To(VectorStorage`1<T> target, VectorStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    internal virtual void Map2ToUnchecked(VectorStorage`1<T> target, VectorStorage`1<T> other, Func`3<T, T, T> f, Zeros zeros, ExistingData existingData);
    public TState Fold2(VectorStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
    internal virtual TState Fold2Unchecked(VectorStorage`1<TOther> other, Func`4<TState, T, TOther, TState> f, TState state, Zeros zeros);
    private void ValidateRange(int index);
    private void ValidateSubVectorRange(VectorStorage`1<T> target, int sourceIndex, int targetIndex, int count);
    private void ValidateRowRange(MatrixStorage`1<T> target, int rowIndex);
    private void ValidateColumnRange(MatrixStorage`1<T> target, int columnIndex);
    private void ValidateSubRowRange(MatrixStorage`1<T> target, int rowIndex, int sourceColumnIndex, int targetColumnIndex, int columnCount);
    private void ValidateSubColumnRange(MatrixStorage`1<T> target, int columnIndex, int sourceRowIndex, int targetRowIndex, int rowCount);
}
public enum MathNet.Numerics.LinearAlgebra.Symmetricity : Enum {
    public int value__;
    public static Symmetricity Unknown;
    public static Symmetricity Symmetric;
    public static Symmetricity Hermitian;
    public static Symmetricity Asymmetric;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Vector {Count}")]
public abstract class MathNet.Numerics.LinearAlgebra.Vector`1 : object {
    public static T Zero;
    public static T One;
    public static VectorBuilder`1<T> Build;
    [CompilerGeneratedAttribute]
private VectorStorage`1<T> <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public VectorStorage`1<T> Storage { get; private set; }
    public int Count { get; private set; }
    public T Item { get; public set; }
    protected Vector`1(VectorStorage`1<T> storage);
    private static Vector`1();
    protected abstract virtual void DoNegate(Vector`1<T> result);
    protected abstract virtual void DoConjugate(Vector`1<T> result);
    protected abstract virtual void DoAdd(T scalar, Vector`1<T> result);
    protected abstract virtual void DoAdd(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoSubtract(T scalar, Vector`1<T> result);
    protected void DoSubtractFrom(T scalar, Vector`1<T> result);
    protected abstract virtual void DoSubtract(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoMultiply(T scalar, Vector`1<T> result);
    protected abstract virtual T DoDotProduct(Vector`1<T> other);
    protected abstract virtual T DoConjugateDotProduct(Vector`1<T> other);
    protected void DoOuterProduct(Vector`1<T> other, Matrix`1<T> result);
    protected abstract virtual void DoDivide(T divisor, Vector`1<T> result);
    protected abstract virtual void DoDivideByThis(T dividend, Vector`1<T> result);
    protected abstract virtual void DoModulus(T divisor, Vector`1<T> result);
    protected abstract virtual void DoModulusByThis(T dividend, Vector`1<T> result);
    protected abstract virtual void DoRemainder(T divisor, Vector`1<T> result);
    protected abstract virtual void DoRemainderByThis(T dividend, Vector`1<T> result);
    protected abstract virtual void DoPointwiseMultiply(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoPointwiseDivide(Vector`1<T> divisor, Vector`1<T> result);
    protected abstract virtual void DoPointwisePower(T exponent, Vector`1<T> result);
    protected abstract virtual void DoPointwisePower(Vector`1<T> exponent, Vector`1<T> result);
    protected abstract virtual void DoPointwiseModulus(Vector`1<T> divisor, Vector`1<T> result);
    protected abstract virtual void DoPointwiseRemainder(Vector`1<T> divisor, Vector`1<T> result);
    protected abstract virtual void DoPointwiseExp(Vector`1<T> result);
    protected abstract virtual void DoPointwiseLog(Vector`1<T> result);
    protected abstract virtual void DoPointwiseAbs(Vector`1<T> result);
    protected abstract virtual void DoPointwiseAcos(Vector`1<T> result);
    protected abstract virtual void DoPointwiseAsin(Vector`1<T> result);
    protected abstract virtual void DoPointwiseAtan(Vector`1<T> result);
    protected abstract virtual void DoPointwiseCeiling(Vector`1<T> result);
    protected abstract virtual void DoPointwiseCos(Vector`1<T> result);
    protected abstract virtual void DoPointwiseCosh(Vector`1<T> result);
    protected abstract virtual void DoPointwiseFloor(Vector`1<T> result);
    protected abstract virtual void DoPointwiseLog10(Vector`1<T> result);
    protected abstract virtual void DoPointwiseRound(Vector`1<T> result);
    protected abstract virtual void DoPointwiseSign(Vector`1<T> result);
    protected abstract virtual void DoPointwiseSin(Vector`1<T> result);
    protected abstract virtual void DoPointwiseSinh(Vector`1<T> result);
    protected abstract virtual void DoPointwiseSqrt(Vector`1<T> result);
    protected abstract virtual void DoPointwiseTan(Vector`1<T> result);
    protected abstract virtual void DoPointwiseTanh(Vector`1<T> result);
    protected abstract virtual void DoPointwiseAtan2(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoPointwiseAtan2(T scalar, Vector`1<T> result);
    protected abstract virtual void DoPointwiseMinimum(T scalar, Vector`1<T> result);
    protected abstract virtual void DoPointwiseMinimum(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoPointwiseMaximum(T scalar, Vector`1<T> result);
    protected abstract virtual void DoPointwiseMaximum(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMinimum(T scalar, Vector`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMinimum(Vector`1<T> other, Vector`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMaximum(T scalar, Vector`1<T> result);
    protected abstract virtual void DoPointwiseAbsoluteMaximum(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> Add(T scalar);
    public void Add(T scalar, Vector`1<T> result);
    public Vector`1<T> Add(Vector`1<T> other);
    public void Add(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> Subtract(T scalar);
    public void Subtract(T scalar, Vector`1<T> result);
    public Vector`1<T> SubtractFrom(T scalar);
    public void SubtractFrom(T scalar, Vector`1<T> result);
    public Vector`1<T> Negate();
    public void Negate(Vector`1<T> result);
    public Vector`1<T> Subtract(Vector`1<T> other);
    public void Subtract(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> Conjugate();
    public void Conjugate(Vector`1<T> result);
    public Vector`1<T> Multiply(T scalar);
    public void Multiply(T scalar, Vector`1<T> result);
    public T DotProduct(Vector`1<T> other);
    public T ConjugateDotProduct(Vector`1<T> other);
    public Vector`1<T> Divide(T scalar);
    public void Divide(T scalar, Vector`1<T> result);
    public Vector`1<T> DivideByThis(T scalar);
    public void DivideByThis(T scalar, Vector`1<T> result);
    public Vector`1<T> Modulus(T divisor);
    public void Modulus(T divisor, Vector`1<T> result);
    public Vector`1<T> ModulusByThis(T dividend);
    public void ModulusByThis(T dividend, Vector`1<T> result);
    public Vector`1<T> Remainder(T divisor);
    public void Remainder(T divisor, Vector`1<T> result);
    public Vector`1<T> RemainderByThis(T dividend);
    public void RemainderByThis(T dividend, Vector`1<T> result);
    public Vector`1<T> PointwiseMultiply(Vector`1<T> other);
    public void PointwiseMultiply(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseDivide(Vector`1<T> divisor);
    public void PointwiseDivide(Vector`1<T> divisor, Vector`1<T> result);
    public Vector`1<T> PointwisePower(T exponent);
    public void PointwisePower(T exponent, Vector`1<T> result);
    public Vector`1<T> PointwisePower(Vector`1<T> exponent);
    public void PointwisePower(Vector`1<T> exponent, Vector`1<T> result);
    public Vector`1<T> PointwiseModulus(Vector`1<T> divisor);
    public void PointwiseModulus(Vector`1<T> divisor, Vector`1<T> result);
    public Vector`1<T> PointwiseRemainder(Vector`1<T> divisor);
    public void PointwiseRemainder(Vector`1<T> divisor, Vector`1<T> result);
    protected Vector`1<T> PointwiseUnary(Action`1<Vector`1<T>> f);
    protected void PointwiseUnary(Action`1<Vector`1<T>> f, Vector`1<T> result);
    protected Vector`1<T> PointwiseBinary(Action`2<T, Vector`1<T>> f, T other);
    protected void PointwiseBinary(Action`2<T, Vector`1<T>> f, T x, Vector`1<T> result);
    protected Vector`1<T> PointwiseBinary(Action`2<Vector`1<T>, Vector`1<T>> f, Vector`1<T> other);
    protected void PointwiseBinary(Action`2<Vector`1<T>, Vector`1<T>> f, Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseExp();
    public void PointwiseExp(Vector`1<T> result);
    public Vector`1<T> PointwiseLog();
    public void PointwiseLog(Vector`1<T> result);
    public Vector`1<T> PointwiseAbs();
    public void PointwiseAbs(Vector`1<T> result);
    public Vector`1<T> PointwiseAcos();
    public void PointwiseAcos(Vector`1<T> result);
    public Vector`1<T> PointwiseAsin();
    public void PointwiseAsin(Vector`1<T> result);
    public Vector`1<T> PointwiseAtan();
    public void PointwiseAtan(Vector`1<T> result);
    public Vector`1<T> PointwiseAtan2(Vector`1<T> other);
    public void PointwiseAtan2(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseCeiling();
    public void PointwiseCeiling(Vector`1<T> result);
    public Vector`1<T> PointwiseCos();
    public void PointwiseCos(Vector`1<T> result);
    public Vector`1<T> PointwiseCosh();
    public void PointwiseCosh(Vector`1<T> result);
    public Vector`1<T> PointwiseFloor();
    public void PointwiseFloor(Vector`1<T> result);
    public Vector`1<T> PointwiseLog10();
    public void PointwiseLog10(Vector`1<T> result);
    public Vector`1<T> PointwiseRound();
    public void PointwiseRound(Vector`1<T> result);
    public Vector`1<T> PointwiseSign();
    public void PointwiseSign(Vector`1<T> result);
    public Vector`1<T> PointwiseSin();
    public void PointwiseSin(Vector`1<T> result);
    public Vector`1<T> PointwiseSinh();
    public void PointwiseSinh(Vector`1<T> result);
    public Vector`1<T> PointwiseSqrt();
    public void PointwiseSqrt(Vector`1<T> result);
    public Vector`1<T> PointwiseTan();
    public void PointwiseTan(Vector`1<T> result);
    public Vector`1<T> PointwiseTanh();
    public void PointwiseTanh(Vector`1<T> result);
    public Matrix`1<T> OuterProduct(Vector`1<T> other);
    public void OuterProduct(Vector`1<T> other, Matrix`1<T> result);
    public static Matrix`1<T> OuterProduct(Vector`1<T> u, Vector`1<T> v);
    public Vector`1<T> PointwiseMinimum(T scalar);
    public void PointwiseMinimum(T scalar, Vector`1<T> result);
    public Vector`1<T> PointwiseMaximum(T scalar);
    public void PointwiseMaximum(T scalar, Vector`1<T> result);
    public Vector`1<T> PointwiseAbsoluteMinimum(T scalar);
    public void PointwiseAbsoluteMinimum(T scalar, Vector`1<T> result);
    public Vector`1<T> PointwiseAbsoluteMaximum(T scalar);
    public void PointwiseAbsoluteMaximum(T scalar, Vector`1<T> result);
    public Vector`1<T> PointwiseMinimum(Vector`1<T> other);
    public void PointwiseMinimum(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseMaximum(Vector`1<T> other);
    public void PointwiseMaximum(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseAbsoluteMinimum(Vector`1<T> other);
    public void PointwiseAbsoluteMinimum(Vector`1<T> other, Vector`1<T> result);
    public Vector`1<T> PointwiseAbsoluteMaximum(Vector`1<T> other);
    public void PointwiseAbsoluteMaximum(Vector`1<T> other, Vector`1<T> result);
    public abstract virtual double L1Norm();
    public abstract virtual double L2Norm();
    public abstract virtual double InfinityNorm();
    public abstract virtual double Norm(double p);
    public abstract virtual Vector`1<T> Normalize(double p);
    public abstract virtual T AbsoluteMinimum();
    public abstract virtual int AbsoluteMinimumIndex();
    public abstract virtual T AbsoluteMaximum();
    public abstract virtual int AbsoluteMaximumIndex();
    public T Maximum();
    public abstract virtual int MaximumIndex();
    public T Minimum();
    public abstract virtual int MinimumIndex();
    public abstract virtual T Sum();
    public double SumMagnitudes();
    public sealed virtual bool Equals(Vector`1<T> other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToTypeString();
    public String[0...,0...] ToVectorStringArray(int maxPerColumn, int maxCharactersWidth, int padding, string ellipsis, Func`2<T, string> formatValue);
    private static string FormatStringArrayToString(String[0...,0...] array, string columnSeparator, string rowSeparator);
    private Tuple`2<int, String[]> FormatCompleteColumn(int offset, int height, Func`2<T, string> formatValue);
    public string ToVectorString(int maxPerColumn, int maxCharactersWidth, string ellipsis, string columnSeparator, string rowSeparator, Func`2<T, string> formatValue);
    public string ToVectorString(int maxPerColumn, int maxCharactersWidth, string format, IFormatProvider provider);
    public string ToVectorString(string format, IFormatProvider provider);
    public string ToString(int maxPerColumn, int maxCharactersWidth, string format, IFormatProvider provider);
    public sealed virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public VectorStorage`1<T> get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(VectorStorage`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual T get_Item(int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual void set_Item(int index, T value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public T At(int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void At(int index, T value);
    public sealed virtual void Clear();
    public void ClearSubVector(int index, int count);
    public abstract virtual void CoerceZero(double threshold);
    public void CoerceZero(Func`2<T, bool> zeroPredicate);
    public Vector`1<T> Clone();
    public void SetValues(T[] values);
    public void CopyTo(Vector`1<T> target);
    public Vector`1<T> SubVector(int index, int count);
    public void SetSubVector(int index, int count, Vector`1<T> subVector);
    public void CopySubVectorTo(Vector`1<T> destination, int sourceIndex, int targetIndex, int count);
    public T[] ToArray();
    public T[] AsArray();
    public Matrix`1<T> ToColumnMatrix();
    public Matrix`1<T> ToRowMatrix();
    public IEnumerable`1<T> Enumerate();
    public IEnumerable`1<T> Enumerate(Zeros zeros);
    public IEnumerable`1<ValueTuple`2<int, T>> EnumerateIndexed();
    public IEnumerable`1<ValueTuple`2<int, T>> EnumerateIndexed(Zeros zeros);
    public void MapInplace(Func`2<T, T> f, Zeros zeros);
    public void MapIndexedInplace(Func`3<int, T, T> f, Zeros zeros);
    public void Map(Func`2<T, T> f, Vector`1<T> result, Zeros zeros);
    public void MapIndexed(Func`3<int, T, T> f, Vector`1<T> result, Zeros zeros);
    public void MapConvert(Func`2<T, TU> f, Vector`1<TU> result, Zeros zeros);
    public void MapIndexedConvert(Func`3<int, T, TU> f, Vector`1<TU> result, Zeros zeros);
    public Vector`1<TU> Map(Func`2<T, TU> f, Zeros zeros);
    public Vector`1<TU> MapIndexed(Func`3<int, T, TU> f, Zeros zeros);
    public void Map2(Func`3<T, T, T> f, Vector`1<T> other, Vector`1<T> result, Zeros zeros);
    public Vector`1<T> Map2(Func`3<T, T, T> f, Vector`1<T> other, Zeros zeros);
    public TState Fold2(Func`4<TState, T, TOther, TState> f, TState state, Vector`1<TOther> other, Zeros zeros);
    public Tuple`2<int, T> Find(Func`2<T, bool> predicate, Zeros zeros);
    public Tuple`3<int, T, TOther> Find2(Func`3<T, TOther, bool> predicate, Vector`1<TOther> other, Zeros zeros);
    public bool Exists(Func`2<T, bool> predicate, Zeros zeros);
    public bool Exists2(Func`3<T, TOther, bool> predicate, Vector`1<TOther> other, Zeros zeros);
    public bool ForAll(Func`2<T, bool> predicate, Zeros zeros);
    public bool ForAll2(Func`3<T, TOther, bool> predicate, Vector`1<TOther> other, Zeros zeros);
    public static Vector`1<T> op_UnaryPlus(Vector`1<T> rightSide);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> rightSide);
    public static Vector`1<T> op_Addition(Vector`1<T> leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Addition(Vector`1<T> leftSide, T rightSide);
    public static Vector`1<T> op_Addition(T leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Subtraction(Vector`1<T> leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Subtraction(Vector`1<T> leftSide, T rightSide);
    public static Vector`1<T> op_Subtraction(T leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Multiply(Vector`1<T> leftSide, T rightSide);
    public static Vector`1<T> op_Multiply(T leftSide, Vector`1<T> rightSide);
    public static T op_Multiply(Vector`1<T> leftSide, Vector`1<T> rightSide);
    public static Vector`1<T> op_Division(T dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_Division(Vector`1<T> dividend, T divisor);
    public static Vector`1<T> op_Division(Vector`1<T> dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_Modulus(Vector`1<T> dividend, T divisor);
    public static Vector`1<T> op_Modulus(T dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_Modulus(Vector`1<T> dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_DotMultiply(Vector`1<T> x, Vector`1<T> y);
    public static Vector`1<T> op_DotDivide(Vector`1<T> dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_DotPercent(Vector`1<T> dividend, Vector`1<T> divisor);
    public static Vector`1<T> op_DotHat(Vector`1<T> vector, Vector`1<T> exponent);
    public static Vector`1<T> op_DotHat(Vector`1<T> vector, T exponent);
    public static Vector`1<T> Sqrt(Vector`1<T> x);
    public static Vector`1<T> Exp(Vector`1<T> x);
    public static Vector`1<T> Log(Vector`1<T> x);
    public static Vector`1<T> Log10(Vector`1<T> x);
    public static Vector`1<T> Sin(Vector`1<T> x);
    public static Vector`1<T> Cos(Vector`1<T> x);
    public static Vector`1<T> Tan(Vector`1<T> x);
    public static Vector`1<T> Asin(Vector`1<T> x);
    public static Vector`1<T> Acos(Vector`1<T> x);
    public static Vector`1<T> Atan(Vector`1<T> x);
    public static Vector`1<T> Sinh(Vector`1<T> x);
    public static Vector`1<T> Cosh(Vector`1<T> x);
    public static Vector`1<T> Tanh(Vector`1<T> x);
    public static Vector`1<T> Abs(Vector`1<T> x);
    public static Vector`1<T> Floor(Vector`1<T> x);
    public static Vector`1<T> Ceiling(Vector`1<T> x);
    public static Vector`1<T> Round(Vector`1<T> x);
}
public abstract class MathNet.Numerics.LinearAlgebra.VectorBuilder`1 : object {
    public T Zero { get; }
    public T One { get; }
    public abstract virtual T get_Zero();
    public abstract virtual T get_One();
    public Vector`1<T> OfStorage(VectorStorage`1<T> storage);
    public Vector`1<T> SameAs(Vector`1<TU> example, int length);
    public Vector`1<T> SameAs(Vector`1<TU> example);
    public Vector`1<T> SameAs(Matrix`1<TU> example, int length);
    public Vector`1<T> SameAs(Vector`1<T> example, Vector`1<T> otherExample, int length);
    public Vector`1<T> SameAs(Vector`1<T> example, Vector`1<T> otherExample);
    public Vector`1<T> SameAs(Matrix`1<T> matrix, Vector`1<T> vector, int length);
    public abstract virtual Vector`1<T> Random(int length, IContinuousDistribution distribution);
    public Vector`1<T> Random(int length);
    public Vector`1<T> Random(int length, int seed);
    public abstract virtual Vector`1<T> Dense(DenseVectorStorage`1<T> storage);
    public Vector`1<T> Dense(int size);
    public Vector`1<T> Dense(T[] array);
    public Vector`1<T> Dense(int length, T value);
    public Vector`1<T> Dense(int length, Func`2<int, T> init);
    public Vector`1<T> DenseOfVector(Vector`1<T> vector);
    public Vector`1<T> DenseOfArray(T[] array);
    public Vector`1<T> DenseOfEnumerable(IEnumerable`1<T> enumerable);
    public Vector`1<T> DenseOfIndexed(int length, IEnumerable`1<Tuple`2<int, T>> enumerable);
    public Vector`1<T> DenseOfIndexed(int length, IEnumerable`1<ValueTuple`2<int, T>> enumerable);
    public abstract virtual Vector`1<T> Sparse(SparseVectorStorage`1<T> storage);
    public Vector`1<T> Sparse(int size);
    public Vector`1<T> Sparse(int length, T value);
    public Vector`1<T> Sparse(int length, Func`2<int, T> init);
    public Vector`1<T> SparseOfVector(Vector`1<T> vector);
    public Vector`1<T> SparseOfArray(T[] array);
    public Vector`1<T> SparseOfEnumerable(IEnumerable`1<T> enumerable);
    public Vector`1<T> SparseOfIndexed(int length, IEnumerable`1<Tuple`2<int, T>> enumerable);
    public Vector`1<T> SparseOfIndexed(int length, IEnumerable`1<ValueTuple`2<int, T>> enumerable);
}
[ExtensionAttribute]
public static class MathNet.Numerics.LinearAlgebra.VectorExtensions : object {
    [ExtensionAttribute]
public static Vector`1<float> ToSingle(Vector`1<double> vector);
    [ExtensionAttribute]
public static Vector`1<double> ToDouble(Vector`1<float> vector);
    [ExtensionAttribute]
public static Vector`1<Complex32> ToComplex32(Vector`1<Complex> vector);
    [ExtensionAttribute]
public static Vector`1<Complex> ToComplex(Vector`1<Complex32> vector);
    [ExtensionAttribute]
public static Vector`1<Complex32> ToComplex32(Vector`1<float> vector);
    [ExtensionAttribute]
public static Vector`1<Complex> ToComplex(Vector`1<double> vector);
    [ExtensionAttribute]
public static Vector`1<double> Real(Vector`1<Complex> vector);
    [ExtensionAttribute]
public static Vector`1<float> Real(Vector`1<Complex32> vector);
    [ExtensionAttribute]
public static Vector`1<double> Imaginary(Vector`1<Complex> vector);
    [ExtensionAttribute]
public static Vector`1<float> Imaginary(Vector`1<Complex32> vector);
}
public enum MathNet.Numerics.LinearAlgebra.Zeros : Enum {
    public int value__;
    public static Zeros AllowSkip;
    public static Zeros Include;
}
public enum MathNet.Numerics.LinearRegression.DirectRegressionMethod : Enum {
    public int value__;
    public static DirectRegressionMethod NormalEquations;
    public static DirectRegressionMethod QR;
    public static DirectRegressionMethod Svd;
}
public static class MathNet.Numerics.LinearRegression.MultipleRegression : object {
    public static Vector`1<T> DirectMethod(Matrix`1<T> x, Vector`1<T> y, DirectRegressionMethod method);
    public static Matrix`1<T> DirectMethod(Matrix`1<T> x, Matrix`1<T> y, DirectRegressionMethod method);
    public static T[] DirectMethod(T[][] x, T[] y, bool intercept, DirectRegressionMethod method);
    public static T[] DirectMethod(IEnumerable`1<Tuple`2<T[], T>> samples, bool intercept, DirectRegressionMethod method);
    public static Vector`1<T> NormalEquations(Matrix`1<T> x, Vector`1<T> y);
    public static Matrix`1<T> NormalEquations(Matrix`1<T> x, Matrix`1<T> y);
    public static T[] NormalEquations(T[][] x, T[] y, bool intercept);
    public static T[] NormalEquations(IEnumerable`1<Tuple`2<T[], T>> samples, bool intercept);
    public static T[] NormalEquations(IEnumerable`1<ValueTuple`2<T[], T>> samples, bool intercept);
    public static Vector`1<T> QR(Matrix`1<T> x, Vector`1<T> y);
    public static Matrix`1<T> QR(Matrix`1<T> x, Matrix`1<T> y);
    public static T[] QR(T[][] x, T[] y, bool intercept);
    public static T[] QR(IEnumerable`1<Tuple`2<T[], T>> samples, bool intercept);
    public static T[] QR(IEnumerable`1<ValueTuple`2<T[], T>> samples, bool intercept);
    public static Vector`1<T> Svd(Matrix`1<T> x, Vector`1<T> y);
    public static Matrix`1<T> Svd(Matrix`1<T> x, Matrix`1<T> y);
    public static T[] Svd(T[][] x, T[] y, bool intercept);
    public static T[] Svd(IEnumerable`1<Tuple`2<T[], T>> samples, bool intercept);
    public static T[] Svd(IEnumerable`1<ValueTuple`2<T[], T>> samples, bool intercept);
}
public static class MathNet.Numerics.LinearRegression.SimpleRegression : object {
    public static ValueTuple`2<double, double> Fit(Double[] x, Double[] y);
    public static ValueTuple`2<double, double> Fit(IEnumerable`1<Tuple`2<double, double>> samples);
    public static ValueTuple`2<double, double> Fit(IEnumerable`1<ValueTuple`2<double, double>> samples);
    public static double FitThroughOrigin(Double[] x, Double[] y);
    public static double FitThroughOrigin(IEnumerable`1<Tuple`2<double, double>> samples);
}
[ExtensionAttribute]
internal static class MathNet.Numerics.LinearRegression.Util : object {
    [ExtensionAttribute]
public static ValueTuple`2<TU[], TV[]> UnpackSinglePass(IEnumerable`1<Tuple`2<TU, TV>> samples);
    [ExtensionAttribute]
public static ValueTuple`2<TU[], TV[]> UnpackSinglePass(IEnumerable`1<ValueTuple`2<TU, TV>> samples);
}
public static class MathNet.Numerics.LinearRegression.WeightedRegression : object {
    public static Vector`1<T> Weighted(Matrix`1<T> x, Vector`1<T> y, Matrix`1<T> w);
    public static Matrix`1<T> Weighted(Matrix`1<T> x, Matrix`1<T> y, Matrix`1<T> w);
    public static T[] Weighted(T[][] x, T[] y, T[] w, bool intercept);
    public static T[] Weighted(IEnumerable`1<Tuple`2<T[], T>> samples, T[] weights, bool intercept);
    public static T[] Weighted(IEnumerable`1<ValueTuple`2<T[], T>> samples, T[] weights, bool intercept);
    [ObsoleteAttribute("Warning: This function is here to stay but its signature will likely change. Opting out from semantic versioning.")]
public static Vector`1<T> Local(Matrix`1<T> x, Vector`1<T> y, Vector`1<T> t, double radius, Func`2<double, T> kernel);
    [ObsoleteAttribute("Warning: This function is here to stay but its signature will likely change. Opting out from semantic versioning.")]
public static Matrix`1<T> Local(Matrix`1<T> x, Matrix`1<T> y, Vector`1<T> t, double radius, Func`2<double, T> kernel);
    [ObsoleteAttribute("Warning: This function is here to stay but will likely be refactored and/or moved to another place. Opting out from semantic versioning.")]
public static double GaussianKernel(double normalizedDistance);
}
public class MathNet.Numerics.MemoryAllocationException : NativeInterfaceException {
    public MemoryAllocationException(Exception innerException);
    protected MemoryAllocationException(SerializationInfo info, StreamingContext context);
}
public abstract class MathNet.Numerics.NativeInterfaceException : Exception {
    protected NativeInterfaceException(string message);
    protected NativeInterfaceException(string message, Exception innerException);
    protected NativeInterfaceException(SerializationInfo info, StreamingContext context);
}
public class MathNet.Numerics.NonConvergenceException : Exception {
    public NonConvergenceException(string message);
    public NonConvergenceException(string message, Exception innerException);
    protected NonConvergenceException(SerializationInfo info, StreamingContext context);
}
public class MathNet.Numerics.NumericalBreakdownException : NonConvergenceException {
    public NumericalBreakdownException(string message);
    public NumericalBreakdownException(string message, Exception innerException);
    protected NumericalBreakdownException(SerializationInfo info, StreamingContext context);
}
public static class MathNet.Numerics.OdeSolvers.AdamsBashforth : object {
    public static Double[] FirstOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
    public static Double[] SecondOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
    public static Double[] ThirdOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
    public static Double[] FourthOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
}
public static class MathNet.Numerics.OdeSolvers.RungeKutta : object {
    public static Double[] SecondOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
    public static Double[] FourthOrder(double y0, double start, double end, int N, Func`3<double, double, double> f);
    public static Vector`1[] SecondOrder(Vector`1<double> y0, double start, double end, int N, Func`3<double, Vector`1<double>, Vector`1<double>> f);
    public static Vector`1[] FourthOrder(Vector`1<double> y0, double start, double end, int N, Func`3<double, Vector`1<double>, Vector`1<double>> f);
}
public class MathNet.Numerics.Optimization.BfgsBMinimizer : BfgsMinimizerBase {
    private Vector`1<double> _lowerBound;
    private Vector`1<double> _upperBound;
    public BfgsBMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations);
    public MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> initialGuess);
    protected virtual Vector`1<double> CalculateSearchDirection(Matrix`1& pseudoHessian, Double& maxLineSearchStep, Double& startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidatePoint, Vector`1<double> step);
    private static Vector`1<double> ReducedToFull(List`1<int> reducedMap, Vector`1<double> reducedVector, Vector`1<double> fullVector);
    private static double FindMaxStep(Vector`1<double> startingPoint, Vector`1<double> searchDirection, Vector`1<double> lowerBound, Vector`1<double> upperBound);
    private static void CreateReducedData(Vector`1<double> initialPoint, Vector`1<double> cauchyPoint, List`1<bool> isFixed, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> gradient, Matrix`1<double> pseudoHessian, Vector`1<double> reducedInitialPoint, Vector`1<double> reducedCauchyPoint, Vector`1<double> reducedGradient, Matrix`1<double> reducedHessian, List`1<int> reducedMap);
    protected virtual double GetProjectedGradient(IObjectiveFunctionEvaluation candidatePoint, int ii);
}
public class MathNet.Numerics.Optimization.BfgsMinimizer : BfgsMinimizerBase {
    public BfgsMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations);
    public sealed virtual MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> initialGuess);
    protected virtual Vector`1<double> CalculateSearchDirection(Matrix`1& inversePseudoHessian, Double& maxLineSearchStep, Double& startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidate, Vector`1<double> step);
}
public abstract class MathNet.Numerics.Optimization.BfgsMinimizerBase : MinimizerBase {
    protected BfgsMinimizerBase(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations);
    protected int DoBfgsUpdate(ExitCondition& currentExitCondition, WolfeLineSearch lineSearcher, Matrix`1& inversePseudoHessian, Vector`1& lineSearchDirection, IObjectiveFunction& previousPoint, LineSearchResult& lineSearchResult, IObjectiveFunction& candidate, Vector`1& step, Int32& totalLineSearchSteps, Int32& iterationsWithNontrivialLineSearch);
    protected abstract virtual Vector`1<double> CalculateSearchDirection(Matrix`1& inversePseudoHessian, Double& maxLineSearchStep, Double& startingStepSize, IObjectiveFunction previousPoint, IObjectiveFunction candidate, Vector`1<double> step);
}
public static class MathNet.Numerics.Optimization.BfgsSolver : object {
    private static double GradientTolerance;
    private static int MaxIterations;
    public static Vector`1<double> Solve(Vector initialGuess, Func`2<Vector`1<double>, double> functionValue, Func`2<Vector`1<double>, Vector`1<double>> functionGradient);
}
public class MathNet.Numerics.Optimization.ConjugateGradientMinimizer : object {
    [CompilerGeneratedAttribute]
private double <GradientTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    public double GradientTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    public ConjugateGradientMinimizer(double gradientTolerance, int maximumIterations);
    [CompilerGeneratedAttribute]
public double get_GradientTolerance();
    [CompilerGeneratedAttribute]
public void set_GradientTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    public sealed virtual MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> initialGuess);
    public static MinimizationResult Minimum(IObjectiveFunction objective, Vector`1<double> initialGuess, double gradientTolerance, int maxIterations);
    private static void ValidateGradient(IObjectiveFunctionEvaluation objective);
    private static void ValidateObjective(IObjectiveFunctionEvaluation objective);
}
public class MathNet.Numerics.Optimization.EvaluationException : OptimizationException {
    [CompilerGeneratedAttribute]
private IObjectiveFunctionEvaluation <ObjectiveFunction>k__BackingField;
    public IObjectiveFunctionEvaluation ObjectiveFunction { get; }
    public EvaluationException(string message, IObjectiveFunctionEvaluation eval);
    public EvaluationException(string message, IObjectiveFunctionEvaluation eval, Exception innerException);
    [CompilerGeneratedAttribute]
public IObjectiveFunctionEvaluation get_ObjectiveFunction();
}
public enum MathNet.Numerics.Optimization.ExitCondition : Enum {
    public int value__;
    public static ExitCondition None;
    public static ExitCondition InvalidValues;
    public static ExitCondition ExceedIterations;
    public static ExitCondition RelativePoints;
    public static ExitCondition RelativeGradient;
    public static ExitCondition LackOfProgress;
    public static ExitCondition AbsoluteGradient;
    public static ExitCondition WeakWolfeCriteria;
    public static ExitCondition BoundTolerance;
    public static ExitCondition StrongWolfeCriteria;
    public static ExitCondition Converged;
    public static ExitCondition ManuallyStopped;
}
public class MathNet.Numerics.Optimization.GoldenSectionMinimizer : object {
    [CompilerGeneratedAttribute]
private double <XTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumExpansionSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LowerExpansionFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UpperExpansionFactor>k__BackingField;
    public double XTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    public int MaximumExpansionSteps { get; public set; }
    public double LowerExpansionFactor { get; public set; }
    public double UpperExpansionFactor { get; public set; }
    public GoldenSectionMinimizer(double xTolerance, int maxIterations, int maxExpansionSteps, double lowerExpansionFactor, double upperExpansionFactor);
    [CompilerGeneratedAttribute]
public double get_XTolerance();
    [CompilerGeneratedAttribute]
public void set_XTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumExpansionSteps();
    [CompilerGeneratedAttribute]
public void set_MaximumExpansionSteps(int value);
    [CompilerGeneratedAttribute]
public double get_LowerExpansionFactor();
    [CompilerGeneratedAttribute]
public void set_LowerExpansionFactor(double value);
    [CompilerGeneratedAttribute]
public double get_UpperExpansionFactor();
    [CompilerGeneratedAttribute]
public void set_UpperExpansionFactor(double value);
    public ScalarMinimizationResult FindMinimum(IScalarObjectiveFunction objective, double lowerBound, double upperBound);
    public static ScalarMinimizationResult Minimum(IScalarObjectiveFunction objective, double lowerBound, double upperBound, double xTolerance, int maxIterations, int maxExpansionSteps, double lowerExpansionFactor, double upperExpansionFactor);
    private static void ValueChecker(double value);
}
public class MathNet.Numerics.Optimization.IncompatibleObjectiveException : OptimizationException {
    public IncompatibleObjectiveException(string message);
}
public class MathNet.Numerics.Optimization.InnerOptimizationException : OptimizationException {
    public InnerOptimizationException(string message);
    public InnerOptimizationException(string message, Exception innerException);
}
public interface MathNet.Numerics.Optimization.IObjectiveFunction {
    public abstract virtual void EvaluateAt(Vector`1<double> point);
    public abstract virtual IObjectiveFunction Fork();
}
public interface MathNet.Numerics.Optimization.IObjectiveFunctionEvaluation {
    public Vector`1<double> Point { get; }
    public double Value { get; }
    public bool IsGradientSupported { get; }
    public Vector`1<double> Gradient { get; }
    public bool IsHessianSupported { get; }
    public Matrix`1<double> Hessian { get; }
    public abstract virtual IObjectiveFunction CreateNew();
    public abstract virtual Vector`1<double> get_Point();
    public abstract virtual double get_Value();
    public abstract virtual bool get_IsGradientSupported();
    public abstract virtual Vector`1<double> get_Gradient();
    public abstract virtual bool get_IsHessianSupported();
    public abstract virtual Matrix`1<double> get_Hessian();
}
public interface MathNet.Numerics.Optimization.IObjectiveModel {
    public abstract virtual void SetParameters(Vector`1<double> initialGuess, List`1<bool> isFixed);
    public abstract virtual void EvaluateAt(Vector`1<double> parameters);
    public abstract virtual IObjectiveModel Fork();
    public abstract virtual IObjectiveFunction ToObjectiveFunction();
}
public interface MathNet.Numerics.Optimization.IObjectiveModelEvaluation {
    public Vector`1<double> ObservedY { get; }
    public Matrix`1<double> Weights { get; }
    public Vector`1<double> ModelValues { get; }
    public Vector`1<double> Point { get; }
    public double Value { get; }
    public Vector`1<double> Gradient { get; }
    public Matrix`1<double> Hessian { get; }
    public int FunctionEvaluations { get; public set; }
    public int JacobianEvaluations { get; public set; }
    public int DegreeOfFreedom { get; }
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public abstract virtual IObjectiveModel CreateNew();
    public abstract virtual Vector`1<double> get_ObservedY();
    public abstract virtual Matrix`1<double> get_Weights();
    public abstract virtual Vector`1<double> get_ModelValues();
    public abstract virtual Vector`1<double> get_Point();
    public abstract virtual double get_Value();
    public abstract virtual Vector`1<double> get_Gradient();
    public abstract virtual Matrix`1<double> get_Hessian();
    public abstract virtual int get_FunctionEvaluations();
    public abstract virtual void set_FunctionEvaluations(int value);
    public abstract virtual int get_JacobianEvaluations();
    public abstract virtual void set_JacobianEvaluations(int value);
    public abstract virtual int get_DegreeOfFreedom();
    public abstract virtual bool get_IsGradientSupported();
    public abstract virtual bool get_IsHessianSupported();
}
public interface MathNet.Numerics.Optimization.IScalarObjectiveFunction {
    public bool IsDerivativeSupported { get; }
    public bool IsSecondDerivativeSupported { get; }
    public abstract virtual bool get_IsDerivativeSupported();
    public abstract virtual bool get_IsSecondDerivativeSupported();
    public abstract virtual IScalarObjectiveFunctionEvaluation Evaluate(double point);
}
public interface MathNet.Numerics.Optimization.IScalarObjectiveFunctionEvaluation {
    public double Point { get; }
    public double Value { get; }
    public double Derivative { get; }
    public double SecondDerivative { get; }
    public abstract virtual double get_Point();
    public abstract virtual double get_Value();
    public abstract virtual double get_Derivative();
    public abstract virtual double get_SecondDerivative();
}
public interface MathNet.Numerics.Optimization.IUnconstrainedMinimizer {
    public abstract virtual MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> initialGuess);
}
public class MathNet.Numerics.Optimization.LevenbergMarquardtMinimizer : NonlinearMinimizerBase {
    [CompilerGeneratedAttribute]
private double <InitialMu>k__BackingField;
    public double InitialMu { get; public set; }
    public LevenbergMarquardtMinimizer(double initialMu, double gradientTolerance, double stepTolerance, double functionTolerance, int maximumIterations);
    [CompilerGeneratedAttribute]
public double get_InitialMu();
    [CompilerGeneratedAttribute]
public void set_InitialMu(double value);
    public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Vector`1<double> initialGuess, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> scales, List`1<bool> isFixed);
    public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Double[] initialGuess, Double[] lowerBound, Double[] upperBound, Double[] scales, Boolean[] isFixed);
    public NonlinearMinimizationResult Minimum(IObjectiveModel objective, Vector`1<double> initialGuess, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> scales, List`1<bool> isFixed, double initialMu, double gradientTolerance, double stepTolerance, double functionTolerance, int maximumIterations);
}
public class MathNet.Numerics.Optimization.LimitedMemoryBfgsMinimizer : MinimizerBase {
    [CompilerGeneratedAttribute]
private int <Memory>k__BackingField;
    public int Memory { get; public set; }
    public LimitedMemoryBfgsMinimizer(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int memory, int maximumIterations);
    [CompilerGeneratedAttribute]
public int get_Memory();
    [CompilerGeneratedAttribute]
public void set_Memory(int value);
    public sealed virtual MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> initialGuess);
    private Vector`1<double> ApplyLbfgsUpdate(IObjectiveFunction previousPoint, List`1<Vector`1<double>> ykhistory, List`1<Vector`1<double>> skhistory, List`1<double> rhokhistory);
}
public class MathNet.Numerics.Optimization.LineSearch.LineSearchResult : MinimizationResult {
    [CompilerGeneratedAttribute]
private double <FinalStep>k__BackingField;
    public double FinalStep { get; }
    public LineSearchResult(IObjectiveFunction functionInfo, int iterations, double finalStep, ExitCondition reasonForExit);
    [CompilerGeneratedAttribute]
public double get_FinalStep();
}
public class MathNet.Numerics.Optimization.LineSearch.StrongWolfeLineSearch : WolfeLineSearch {
    protected ExitCondition WolfeExitCondition { get; }
    public StrongWolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations);
    protected virtual ExitCondition get_WolfeExitCondition();
    protected virtual bool WolfeCondition(double stepDd, double initialDd);
}
public class MathNet.Numerics.Optimization.LineSearch.WeakWolfeLineSearch : WolfeLineSearch {
    protected ExitCondition WolfeExitCondition { get; }
    public WeakWolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations);
    protected virtual ExitCondition get_WolfeExitCondition();
    protected virtual bool WolfeCondition(double stepDd, double initialDd);
    protected virtual void ValidateValue(IObjectiveFunctionEvaluation eval);
    protected virtual void ValidateInputArguments(IObjectiveFunctionEvaluation startingPoint, Vector`1<double> searchDirection, double initialStep, double upperBound);
    protected virtual void ValidateGradient(IObjectiveFunctionEvaluation eval);
    private static bool IsFinite(double x);
}
public abstract class MathNet.Numerics.Optimization.LineSearch.WolfeLineSearch : object {
    [CompilerGeneratedAttribute]
private double <C1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <C2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ParameterTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    protected double C1 { get; }
    protected double C2 { get; }
    protected double ParameterTolerance { get; }
    protected int MaximumIterations { get; }
    protected ExitCondition WolfeExitCondition { get; }
    public WolfeLineSearch(double c1, double c2, double parameterTolerance, int maxIterations);
    [CompilerGeneratedAttribute]
protected double get_C1();
    [CompilerGeneratedAttribute]
protected double get_C2();
    [CompilerGeneratedAttribute]
protected double get_ParameterTolerance();
    [CompilerGeneratedAttribute]
protected int get_MaximumIterations();
    public LineSearchResult FindConformingStep(IObjectiveFunctionEvaluation startingPoint, Vector`1<double> searchDirection, double initialStep);
    public LineSearchResult FindConformingStep(IObjectiveFunctionEvaluation startingPoint, Vector`1<double> searchDirection, double initialStep, double upperBound);
    protected abstract virtual ExitCondition get_WolfeExitCondition();
    protected abstract virtual bool WolfeCondition(double stepDd, double initialDd);
    protected virtual void ValidateGradient(IObjectiveFunctionEvaluation objective);
    protected virtual void ValidateValue(IObjectiveFunctionEvaluation objective);
    protected virtual void ValidateInputArguments(IObjectiveFunctionEvaluation startingPoint, Vector`1<double> searchDirection, double initialStep, double upperBound);
}
public class MathNet.Numerics.Optimization.MaximumIterationsException : OptimizationException {
    public MaximumIterationsException(string message);
}
public class MathNet.Numerics.Optimization.MinimizationResult : object {
    [CompilerGeneratedAttribute]
private IObjectiveFunction <FunctionInfoAtMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    [CompilerGeneratedAttribute]
private ExitCondition <ReasonForExit>k__BackingField;
    public Vector`1<double> MinimizingPoint { get; }
    public IObjectiveFunction FunctionInfoAtMinimum { get; }
    public int Iterations { get; }
    public ExitCondition ReasonForExit { get; }
    public MinimizationResult(IObjectiveFunction functionInfo, int iterations, ExitCondition reasonForExit);
    public Vector`1<double> get_MinimizingPoint();
    [CompilerGeneratedAttribute]
public IObjectiveFunction get_FunctionInfoAtMinimum();
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public ExitCondition get_ReasonForExit();
}
public class MathNet.Numerics.Optimization.MinimizationWithLineSearchResult : MinimizationResult {
    [CompilerGeneratedAttribute]
private int <TotalLineSearchIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationsWithNonTrivialLineSearch>k__BackingField;
    public int TotalLineSearchIterations { get; }
    public int IterationsWithNonTrivialLineSearch { get; }
    public MinimizationWithLineSearchResult(IObjectiveFunction functionInfo, int iterations, ExitCondition reasonForExit, int totalLineSearchIterations, int iterationsWithNonTrivialLineSearch);
    [CompilerGeneratedAttribute]
public int get_TotalLineSearchIterations();
    [CompilerGeneratedAttribute]
public int get_IterationsWithNonTrivialLineSearch();
}
public abstract class MathNet.Numerics.Optimization.MinimizerBase : object {
    [CompilerGeneratedAttribute]
private double <GradientTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ParameterTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FunctionProgressTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    protected static double VerySmall;
    public double GradientTolerance { get; public set; }
    public double ParameterTolerance { get; public set; }
    public double FunctionProgressTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    protected MinimizerBase(double gradientTolerance, double parameterTolerance, double functionProgressTolerance, int maximumIterations);
    [CompilerGeneratedAttribute]
public double get_GradientTolerance();
    [CompilerGeneratedAttribute]
public void set_GradientTolerance(double value);
    [CompilerGeneratedAttribute]
public double get_ParameterTolerance();
    [CompilerGeneratedAttribute]
public void set_ParameterTolerance(double value);
    [CompilerGeneratedAttribute]
public double get_FunctionProgressTolerance();
    [CompilerGeneratedAttribute]
public void set_FunctionProgressTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    protected ExitCondition ExitCriteriaSatisfied(IObjectiveFunctionEvaluation candidatePoint, IObjectiveFunctionEvaluation lastPoint, int iterations);
    protected virtual double GetProjectedGradient(IObjectiveFunctionEvaluation candidatePoint, int ii);
    protected void ValidateGradientAndObjective(IObjectiveFunctionEvaluation eval);
}
public class MathNet.Numerics.Optimization.NelderMeadSimplex : object {
    private static double JITTER;
    [CompilerGeneratedAttribute]
private double <ConvergenceTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    public double ConvergenceTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    public NelderMeadSimplex(double convergenceTolerance, int maximumIterations);
    private static NelderMeadSimplex();
    [CompilerGeneratedAttribute]
public double get_ConvergenceTolerance();
    [CompilerGeneratedAttribute]
public void set_ConvergenceTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    public sealed virtual MinimizationResult FindMinimum(IObjectiveFunction objectiveFunction, Vector`1<double> initialGuess);
    public MinimizationResult FindMinimum(IObjectiveFunction objectiveFunction, Vector`1<double> initialGuess, Vector`1<double> initalPertubation);
    public static MinimizationResult Minimum(IObjectiveFunction objectiveFunction, Vector`1<double> initialGuess, double convergenceTolerance, int maximumIterations);
    public static MinimizationResult Minimum(IObjectiveFunction objectiveFunction, Vector`1<double> initialGuess, Vector`1<double> initalPertubation, double convergenceTolerance, int maximumIterations);
    private static Double[] InitializeErrorValues(Vector`1[] vertices, IObjectiveFunction objectiveFunction);
    private static bool HasConverged(double convergenceTolerance, ErrorProfile errorProfile, Double[] errorValues);
    private static ErrorProfile EvaluateSimplex(Double[] errorValues);
    private static Vector`1[] InitializeVertices(SimplexConstant[] simplexConstants);
    private static double TryToScaleSimplex(double scaleFactor, ErrorProfile& errorProfile, Vector`1[] vertices, Double[] errorValues, IObjectiveFunction objectiveFunction);
    private static void ShrinkSimplex(ErrorProfile errorProfile, Vector`1[] vertices, Double[] errorValues, IObjectiveFunction objectiveFunction);
    private static Vector`1<double> ComputeCentroid(Vector`1[] vertices, ErrorProfile errorProfile);
}
public class MathNet.Numerics.Optimization.NewtonMinimizer : object {
    [CompilerGeneratedAttribute]
private double <GradientTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLineSearch>k__BackingField;
    public double GradientTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    public bool UseLineSearch { get; public set; }
    public NewtonMinimizer(double gradientTolerance, int maximumIterations, bool useLineSearch);
    [CompilerGeneratedAttribute]
public double get_GradientTolerance();
    [CompilerGeneratedAttribute]
public void set_GradientTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    [CompilerGeneratedAttribute]
public bool get_UseLineSearch();
    [CompilerGeneratedAttribute]
public void set_UseLineSearch(bool value);
    public sealed virtual MinimizationResult FindMinimum(IObjectiveFunction objective, Vector`1<double> initialGuess);
    public static MinimizationResult Minimum(IObjectiveFunction objective, Vector`1<double> initialGuess, double gradientTolerance, int maxIterations, bool useLineSearch);
    private static void ValidateGradient(IObjectiveFunctionEvaluation eval);
    private static void ValidateHessian(IObjectiveFunctionEvaluation eval);
}
public class MathNet.Numerics.Optimization.NonlinearMinimizationResult : object {
    [CompilerGeneratedAttribute]
private IObjectiveModel <ModelInfoAtMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <StandardErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Covariance>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Correlation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    [CompilerGeneratedAttribute]
private ExitCondition <ReasonForExit>k__BackingField;
    public IObjectiveModel ModelInfoAtMinimum { get; }
    public Vector`1<double> MinimizingPoint { get; }
    public Vector`1<double> StandardErrors { get; private set; }
    public Vector`1<double> MinimizedValues { get; }
    public Matrix`1<double> Covariance { get; private set; }
    public Matrix`1<double> Correlation { get; private set; }
    public int Iterations { get; }
    public ExitCondition ReasonForExit { get; }
    public NonlinearMinimizationResult(IObjectiveModel modelInfo, int iterations, ExitCondition reasonForExit);
    [CompilerGeneratedAttribute]
public IObjectiveModel get_ModelInfoAtMinimum();
    public Vector`1<double> get_MinimizingPoint();
    [CompilerGeneratedAttribute]
public Vector`1<double> get_StandardErrors();
    [CompilerGeneratedAttribute]
private void set_StandardErrors(Vector`1<double> value);
    public Vector`1<double> get_MinimizedValues();
    [CompilerGeneratedAttribute]
public Matrix`1<double> get_Covariance();
    [CompilerGeneratedAttribute]
private void set_Covariance(Matrix`1<double> value);
    [CompilerGeneratedAttribute]
public Matrix`1<double> get_Correlation();
    [CompilerGeneratedAttribute]
private void set_Correlation(Matrix`1<double> value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public ExitCondition get_ReasonForExit();
    private void EvaluateCovariance(IObjectiveModel objective);
}
public abstract class MathNet.Numerics.Optimization.NonlinearMinimizerBase : object {
    [CompilerGeneratedAttribute]
private double <FunctionTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StepTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <GradientTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Scales>k__BackingField;
    public double FunctionTolerance { get; public set; }
    public double StepTolerance { get; public set; }
    public double GradientTolerance { get; public set; }
    public int MaximumIterations { get; public set; }
    public Vector`1<double> LowerBound { get; private set; }
    public Vector`1<double> UpperBound { get; private set; }
    public Vector`1<double> Scales { get; private set; }
    private bool IsBounded { get; }
    protected NonlinearMinimizerBase(double gradientTolerance, double stepTolerance, double functionTolerance, int maximumIterations);
    [CompilerGeneratedAttribute]
public double get_FunctionTolerance();
    [CompilerGeneratedAttribute]
public void set_FunctionTolerance(double value);
    [CompilerGeneratedAttribute]
public double get_StepTolerance();
    [CompilerGeneratedAttribute]
public void set_StepTolerance(double value);
    [CompilerGeneratedAttribute]
public double get_GradientTolerance();
    [CompilerGeneratedAttribute]
public void set_GradientTolerance(double value);
    [CompilerGeneratedAttribute]
public int get_MaximumIterations();
    [CompilerGeneratedAttribute]
public void set_MaximumIterations(int value);
    [CompilerGeneratedAttribute]
public Vector`1<double> get_LowerBound();
    [CompilerGeneratedAttribute]
private void set_LowerBound(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public Vector`1<double> get_UpperBound();
    [CompilerGeneratedAttribute]
private void set_UpperBound(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public Vector`1<double> get_Scales();
    [CompilerGeneratedAttribute]
private void set_Scales(Vector`1<double> value);
    private bool get_IsBounded();
    protected void ValidateBounds(Vector`1<double> parameters, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> scales);
    protected double EvaluateFunction(IObjectiveModel objective, Vector`1<double> Pint);
    protected ValueTuple`2<Vector`1<double>, Matrix`1<double>> EvaluateJacobian(IObjectiveModel objective, Vector`1<double> Pint);
    protected Vector`1<double> ProjectToInternalParameters(Vector`1<double> Pext);
    protected Vector`1<double> ProjectToExternalParameters(Vector`1<double> Pint);
    protected Vector`1<double> ScaleFactorsOfJacobian(Vector`1<double> Pint);
}
public static class MathNet.Numerics.Optimization.ObjectiveFunction : object {
    public static IObjectiveFunction Value(Func`2<Vector`1<double>, double> function);
    public static IObjectiveFunction Gradient(Func`2<Vector`1<double>, ValueTuple`2<double, Vector`1<double>>> function);
    public static IObjectiveFunction Gradient(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient);
    public static IObjectiveFunction Hessian(Func`2<Vector`1<double>, ValueTuple`2<double, Matrix`1<double>>> function);
    public static IObjectiveFunction Hessian(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Matrix`1<double>> hessian);
    public static IObjectiveFunction GradientHessian(Func`2<Vector`1<double>, ValueTuple`3<double, Vector`1<double>, Matrix`1<double>>> function);
    public static IObjectiveFunction GradientHessian(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient, Func`2<Vector`1<double>, Matrix`1<double>> hessian);
    public static IScalarObjectiveFunction ScalarValue(Func`2<double, double> function);
    public static IScalarObjectiveFunction ScalarDerivative(Func`2<double, double> function, Func`2<double, double> derivative);
    public static IScalarObjectiveFunction ScalarSecondDerivative(Func`2<double, double> function, Func`2<double, double> derivative, Func`2<double, double> secondDerivative);
    public static IObjectiveModel NonlinearModel(Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> function, Func`3<Vector`1<double>, Vector`1<double>, Matrix`1<double>> derivatives, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight);
    public static IObjectiveModel NonlinearModel(Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> function, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight, int accuracyOrder);
    public static IObjectiveModel NonlinearModel(Func`3<Vector`1<double>, double, double> function, Func`3<Vector`1<double>, double, Vector`1<double>> derivatives, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight);
    public static IObjectiveModel NonlinearModel(Func`3<Vector`1<double>, double, double> function, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight, int accuracyOrder);
    public static IObjectiveFunction NonlinearFunction(Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> function, Func`3<Vector`1<double>, Vector`1<double>, Matrix`1<double>> derivatives, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight);
    public static IObjectiveFunction NonlinearFunction(Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> function, Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weight, int accuracyOrder);
}
public class MathNet.Numerics.Optimization.ObjectiveFunctions.ForwardDifferenceGradientObjectiveFunction : object {
    [CompilerGeneratedAttribute]
private IObjectiveFunction <InnerObjectiveFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueEvaluated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GradientEvaluated>k__BackingField;
    private Vector`1<double> _gradient;
    [CompilerGeneratedAttribute]
private double <MinimumIncrement>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RelativeIncrement>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    public IObjectiveFunction InnerObjectiveFunction { get; protected set; }
    protected Vector`1<double> LowerBound { get; protected set; }
    protected Vector`1<double> UpperBound { get; protected set; }
    protected bool ValueEvaluated { get; protected set; }
    protected bool GradientEvaluated { get; protected set; }
    public double MinimumIncrement { get; public set; }
    public double RelativeIncrement { get; public set; }
    public Vector`1<double> Gradient { get; protected set; }
    public Matrix`1<double> Hessian { get; }
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; protected set; }
    public double Value { get; }
    public ForwardDifferenceGradientObjectiveFunction(IObjectiveFunction valueOnlyObj, Vector`1<double> lowerBound, Vector`1<double> upperBound, double relativeIncrement, double minimumIncrement);
    [CompilerGeneratedAttribute]
public IObjectiveFunction get_InnerObjectiveFunction();
    [CompilerGeneratedAttribute]
protected void set_InnerObjectiveFunction(IObjectiveFunction value);
    [CompilerGeneratedAttribute]
protected Vector`1<double> get_LowerBound();
    [CompilerGeneratedAttribute]
protected void set_LowerBound(Vector`1<double> value);
    [CompilerGeneratedAttribute]
protected Vector`1<double> get_UpperBound();
    [CompilerGeneratedAttribute]
protected void set_UpperBound(Vector`1<double> value);
    [CompilerGeneratedAttribute]
protected bool get_ValueEvaluated();
    [CompilerGeneratedAttribute]
protected void set_ValueEvaluated(bool value);
    [CompilerGeneratedAttribute]
protected bool get_GradientEvaluated();
    [CompilerGeneratedAttribute]
protected void set_GradientEvaluated(bool value);
    [CompilerGeneratedAttribute]
public double get_MinimumIncrement();
    [CompilerGeneratedAttribute]
public void set_MinimumIncrement(double value);
    [CompilerGeneratedAttribute]
public double get_RelativeIncrement();
    [CompilerGeneratedAttribute]
public void set_RelativeIncrement(double value);
    protected void EvaluateValue();
    protected void EvaluateGradient();
    public sealed virtual Vector`1<double> get_Gradient();
    protected void set_Gradient(Vector`1<double> value);
    public sealed virtual Matrix`1<double> get_Hessian();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
protected void set_Point(Vector`1<double> value);
    public sealed virtual double get_Value();
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    public sealed virtual IObjectiveFunction Fork();
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.GradientHessianObjectiveFunction : object {
    private Func`2<Vector`1<double>, ValueTuple`3<double, Vector`1<double>, Matrix`1<double>>> _function;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Gradient>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Hessian>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; private set; }
    public double Value { get; private set; }
    public Vector`1<double> Gradient { get; private set; }
    public Matrix`1<double> Hessian { get; private set; }
    public GradientHessianObjectiveFunction(Func`2<Vector`1<double>, ValueTuple`3<double, Vector`1<double>, Matrix`1<double>>> function);
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual IObjectiveFunction Fork();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Gradient();
    [CompilerGeneratedAttribute]
private void set_Gradient(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual Matrix`1<double> get_Hessian();
    [CompilerGeneratedAttribute]
private void set_Hessian(Matrix`1<double> value);
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.GradientObjectiveFunction : object {
    private Func`2<Vector`1<double>, ValueTuple`2<double, Vector`1<double>>> _function;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Gradient>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; private set; }
    public double Value { get; private set; }
    public Vector`1<double> Gradient { get; private set; }
    public Matrix`1<double> Hessian { get; }
    public GradientObjectiveFunction(Func`2<Vector`1<double>, ValueTuple`2<double, Vector`1<double>>> function);
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual IObjectiveFunction Fork();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Gradient();
    [CompilerGeneratedAttribute]
private void set_Gradient(Vector`1<double> value);
    public sealed virtual Matrix`1<double> get_Hessian();
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.HessianObjectiveFunction : object {
    private Func`2<Vector`1<double>, ValueTuple`2<double, Matrix`1<double>>> _function;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Hessian>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; private set; }
    public double Value { get; private set; }
    public Matrix`1<double> Hessian { get; private set; }
    public Vector`1<double> Gradient { get; }
    public HessianObjectiveFunction(Func`2<Vector`1<double>, ValueTuple`2<double, Matrix`1<double>>> function);
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual IObjectiveFunction Fork();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual Matrix`1<double> get_Hessian();
    [CompilerGeneratedAttribute]
private void set_Hessian(Matrix`1<double> value);
    public sealed virtual Vector`1<double> get_Gradient();
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.LazyObjectiveFunction : object {
    private Func`2<Vector`1<double>, double> _function;
    private Func`2<Vector`1<double>, Vector`1<double>> _gradient;
    private Func`2<Vector`1<double>, Matrix`1<double>> _hessian;
    private Vector`1<double> _point;
    private bool _hasFunctionValue;
    private double _functionValue;
    private bool _hasGradientValue;
    private Vector`1<double> _gradientValue;
    private bool _hasHessianValue;
    private Matrix`1<double> _hessianValue;
    [CompilerGeneratedAttribute]
private bool <IsGradientSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHessianSupported>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; }
    public double Value { get; }
    public Vector`1<double> Gradient { get; }
    public Matrix`1<double> Hessian { get; }
    public LazyObjectiveFunction(Func`2<Vector`1<double>, double> function, Func`2<Vector`1<double>, Vector`1<double>> gradient, Func`2<Vector`1<double>, Matrix`1<double>> hessian);
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual IObjectiveFunction Fork();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGradientSupported();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    public sealed virtual Vector`1<double> get_Point();
    public sealed virtual double get_Value();
    public sealed virtual Vector`1<double> get_Gradient();
    public sealed virtual Matrix`1<double> get_Hessian();
}
public abstract class MathNet.Numerics.Optimization.ObjectiveFunctions.LazyObjectiveFunctionBase : object {
    private Vector`1<double> _point;
    [CompilerGeneratedAttribute]
private bool <HasFunctionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FunctionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGradientValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <GradientValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHessianValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <HessianValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGradientSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHessianSupported>k__BackingField;
    protected bool HasFunctionValue { get; protected set; }
    protected double FunctionValue { get; protected set; }
    protected bool HasGradientValue { get; protected set; }
    protected Vector`1<double> GradientValue { get; protected set; }
    protected bool HasHessianValue { get; protected set; }
    protected Matrix`1<double> HessianValue { get; protected set; }
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; }
    public double Value { get; protected set; }
    public Vector`1<double> Gradient { get; protected set; }
    public Matrix`1<double> Hessian { get; protected set; }
    protected LazyObjectiveFunctionBase(bool gradientSupported, bool hessianSupported);
    [CompilerGeneratedAttribute]
protected bool get_HasFunctionValue();
    [CompilerGeneratedAttribute]
protected void set_HasFunctionValue(bool value);
    [CompilerGeneratedAttribute]
protected double get_FunctionValue();
    [CompilerGeneratedAttribute]
protected void set_FunctionValue(double value);
    [CompilerGeneratedAttribute]
protected bool get_HasGradientValue();
    [CompilerGeneratedAttribute]
protected void set_HasGradientValue(bool value);
    [CompilerGeneratedAttribute]
protected Vector`1<double> get_GradientValue();
    [CompilerGeneratedAttribute]
protected void set_GradientValue(Vector`1<double> value);
    [CompilerGeneratedAttribute]
protected bool get_HasHessianValue();
    [CompilerGeneratedAttribute]
protected void set_HasHessianValue(bool value);
    [CompilerGeneratedAttribute]
protected Matrix`1<double> get_HessianValue();
    [CompilerGeneratedAttribute]
protected void set_HessianValue(Matrix`1<double> value);
    public abstract virtual IObjectiveFunction CreateNew();
    public virtual IObjectiveFunction Fork();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGradientSupported();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    protected abstract virtual void EvaluateValue();
    protected virtual void EvaluateGradient();
    protected virtual void EvaluateHessian();
    public sealed virtual Vector`1<double> get_Point();
    public sealed virtual double get_Value();
    protected void set_Value(double value);
    public sealed virtual Vector`1<double> get_Gradient();
    protected void set_Gradient(Vector`1<double> value);
    public sealed virtual Matrix`1<double> get_Hessian();
    protected void set_Hessian(Matrix`1<double> value);
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.LazyScalarObjectiveFunctionEvaluation : object {
    private Nullable`1<double> _value;
    private Nullable`1<double> _derivative;
    private Nullable`1<double> _secondDerivative;
    private ScalarObjectiveFunction _objectiveObject;
    private double _point;
    public double Point { get; }
    public double Value { get; }
    public double Derivative { get; }
    public double SecondDerivative { get; }
    public LazyScalarObjectiveFunctionEvaluation(ScalarObjectiveFunction f, double point);
    private double SetValue();
    private double SetDerivative();
    private double SetSecondDerivative();
    public sealed virtual double get_Point();
    public sealed virtual double get_Value();
    public sealed virtual double get_Derivative();
    public sealed virtual double get_SecondDerivative();
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.NonlinearObjectiveFunction : object {
    private Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> _userFunction;
    private Func`3<Vector`1<double>, Vector`1<double>, Matrix`1<double>> _userDerivative;
    private int _accuracyOrder;
    private Vector`1<double> _coefficients;
    private bool _hasFunctionValue;
    private double _functionValue;
    private Vector`1<double> _residuals;
    private bool _hasJacobianValue;
    private Matrix`1<double> _jacobianValue;
    private Vector`1<double> _gradientValue;
    private Matrix`1<double> _hessianValue;
    [CompilerGeneratedAttribute]
private Vector`1<double> <ObservedX>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <ObservedY>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Weights>k__BackingField;
    private Vector`1<double> L;
    [CompilerGeneratedAttribute]
private List`1<bool> <IsFixed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FunctionEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <JacobianEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <ModelValues>k__BackingField;
    public Vector`1<double> ObservedX { get; private set; }
    public Vector`1<double> ObservedY { get; private set; }
    public Matrix`1<double> Weights { get; private set; }
    public List`1<bool> IsFixed { get; private set; }
    public int NumberOfObservations { get; }
    public int NumberOfParameters { get; }
    public int DegreeOfFreedom { get; }
    public int FunctionEvaluations { get; public set; }
    public int JacobianEvaluations { get; public set; }
    public Vector`1<double> Point { get; }
    public Vector`1<double> ModelValues { get; private set; }
    public double Value { get; }
    public Vector`1<double> Gradient { get; }
    public Matrix`1<double> Hessian { get; }
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public NonlinearObjectiveFunction(Func`3<Vector`1<double>, Vector`1<double>, Vector`1<double>> function, Func`3<Vector`1<double>, Vector`1<double>, Matrix`1<double>> derivative, int accuracyOrder);
    [CompilerGeneratedAttribute]
public Vector`1<double> get_ObservedX();
    [CompilerGeneratedAttribute]
private void set_ObservedX(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_ObservedY();
    [CompilerGeneratedAttribute]
private void set_ObservedY(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual Matrix`1<double> get_Weights();
    [CompilerGeneratedAttribute]
private void set_Weights(Matrix`1<double> value);
    [CompilerGeneratedAttribute]
public List`1<bool> get_IsFixed();
    [CompilerGeneratedAttribute]
private void set_IsFixed(List`1<bool> value);
    public int get_NumberOfObservations();
    public int get_NumberOfParameters();
    public sealed virtual int get_DegreeOfFreedom();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FunctionEvaluations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FunctionEvaluations(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_JacobianEvaluations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_JacobianEvaluations(int value);
    public sealed virtual IObjectiveModel Fork();
    public sealed virtual IObjectiveModel CreateNew();
    public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_ModelValues();
    [CompilerGeneratedAttribute]
private void set_ModelValues(Vector`1<double> value);
    public sealed virtual double get_Value();
    public sealed virtual Vector`1<double> get_Gradient();
    public sealed virtual Matrix`1<double> get_Hessian();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    public void SetObserved(Vector`1<double> observedX, Vector`1<double> observedY, Vector`1<double> weights);
    public sealed virtual void SetParameters(Vector`1<double> initialGuess, List`1<bool> isFixed);
    public sealed virtual void EvaluateAt(Vector`1<double> parameters);
    public sealed virtual IObjectiveFunction ToObjectiveFunction();
    private void EvaluateFunction();
    private void EvaluateJacobian();
    private Matrix`1<double> NumericalJacobian(Vector`1<double> parameters, Vector`1<double> currentValues, int accuracyOrder);
    [CompilerGeneratedAttribute]
private ValueTuple`3<double, Vector`1<double>, Matrix`1<double>> <ToObjectiveFunction>g__Function|64_0(Vector`1<double> point);
}
public abstract class MathNet.Numerics.Optimization.ObjectiveFunctions.ObjectiveFunctionBase : object {
    [CompilerGeneratedAttribute]
private bool <IsGradientSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHessianSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Gradient>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix`1<double> <Hessian>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; private set; }
    public double Value { get; protected set; }
    public Vector`1<double> Gradient { get; protected set; }
    public Matrix`1<double> Hessian { get; protected set; }
    protected ObjectiveFunctionBase(bool isGradientSupported, bool isHessianSupported);
    public abstract virtual IObjectiveFunction CreateNew();
    public virtual IObjectiveFunction Fork();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGradientSupported();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    protected abstract virtual void Evaluate();
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Gradient();
    [CompilerGeneratedAttribute]
protected void set_Gradient(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual Matrix`1<double> get_Hessian();
    [CompilerGeneratedAttribute]
protected void set_Hessian(Matrix`1<double> value);
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.ScalarObjectiveFunction : object {
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Objective>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Derivative>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <SecondDerivative>k__BackingField;
    public Func`2<double, double> Objective { get; }
    public Func`2<double, double> Derivative { get; }
    public Func`2<double, double> SecondDerivative { get; }
    public bool IsDerivativeSupported { get; }
    public bool IsSecondDerivativeSupported { get; }
    public ScalarObjectiveFunction(Func`2<double, double> objective);
    public ScalarObjectiveFunction(Func`2<double, double> objective, Func`2<double, double> derivative);
    public ScalarObjectiveFunction(Func`2<double, double> objective, Func`2<double, double> derivative, Func`2<double, double> secondDerivative);
    [CompilerGeneratedAttribute]
public Func`2<double, double> get_Objective();
    [CompilerGeneratedAttribute]
public Func`2<double, double> get_Derivative();
    [CompilerGeneratedAttribute]
public Func`2<double, double> get_SecondDerivative();
    public sealed virtual bool get_IsDerivativeSupported();
    public sealed virtual bool get_IsSecondDerivativeSupported();
    public sealed virtual IScalarObjectiveFunctionEvaluation Evaluate(double point);
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.ScalarValueObjectiveFunction : object {
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Objective>k__BackingField;
    public Func`2<double, double> Objective { get; }
    public bool IsDerivativeSupported { get; }
    public bool IsSecondDerivativeSupported { get; }
    public ScalarValueObjectiveFunction(Func`2<double, double> objective);
    [CompilerGeneratedAttribute]
public Func`2<double, double> get_Objective();
    public sealed virtual bool get_IsDerivativeSupported();
    public sealed virtual bool get_IsSecondDerivativeSupported();
    public sealed virtual IScalarObjectiveFunctionEvaluation Evaluate(double point);
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.ScalarValueObjectiveFunctionEvaluation : object {
    [CompilerGeneratedAttribute]
private double <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Point { get; }
    public double Value { get; }
    public double Derivative { get; }
    public double SecondDerivative { get; }
    public ScalarValueObjectiveFunctionEvaluation(double point, double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Point();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    public sealed virtual double get_Derivative();
    public sealed virtual double get_SecondDerivative();
}
internal class MathNet.Numerics.Optimization.ObjectiveFunctions.ValueObjectiveFunction : object {
    private Func`2<Vector`1<double>, double> _function;
    [CompilerGeneratedAttribute]
private Vector`1<double> <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public bool IsGradientSupported { get; }
    public bool IsHessianSupported { get; }
    public Vector`1<double> Point { get; private set; }
    public double Value { get; private set; }
    public Matrix`1<double> Hessian { get; }
    public Vector`1<double> Gradient { get; }
    public ValueObjectiveFunction(Func`2<Vector`1<double>, double> function);
    public sealed virtual IObjectiveFunction CreateNew();
    public sealed virtual IObjectiveFunction Fork();
    public sealed virtual bool get_IsGradientSupported();
    public sealed virtual bool get_IsHessianSupported();
    public sealed virtual void EvaluateAt(Vector`1<double> point);
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    public sealed virtual Matrix`1<double> get_Hessian();
    public sealed virtual Vector`1<double> get_Gradient();
}
public class MathNet.Numerics.Optimization.OptimizationException : Exception {
    public OptimizationException(string message);
    public OptimizationException(string message, Exception innerException);
}
public static class MathNet.Numerics.Optimization.QuadraticGradientProjectionSearch : object {
    public static GradientProjectionResult Search(Vector`1<double> x0, Vector`1<double> gradient, Matrix`1<double> hessian, Vector`1<double> lowerBound, Vector`1<double> upperBound);
}
public class MathNet.Numerics.Optimization.ScalarMinimizationResult : object {
    [CompilerGeneratedAttribute]
private IScalarObjectiveFunctionEvaluation <FunctionInfoAtMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    [CompilerGeneratedAttribute]
private ExitCondition <ReasonForExit>k__BackingField;
    public double MinimizingPoint { get; }
    public IScalarObjectiveFunctionEvaluation FunctionInfoAtMinimum { get; }
    public int Iterations { get; }
    public ExitCondition ReasonForExit { get; }
    public ScalarMinimizationResult(IScalarObjectiveFunctionEvaluation functionInfo, int iterations, ExitCondition reasonForExit);
    public double get_MinimizingPoint();
    [CompilerGeneratedAttribute]
public IScalarObjectiveFunctionEvaluation get_FunctionInfoAtMinimum();
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public ExitCondition get_ReasonForExit();
}
public interface MathNet.Numerics.Optimization.TrustRegion.ITrustRegionSubproblem {
    public Vector`1<double> Pstep { get; }
    public bool HitBoundary { get; }
    public abstract virtual Vector`1<double> get_Pstep();
    public abstract virtual bool get_HitBoundary();
    public abstract virtual void Solve(IObjectiveModel objective, double radius);
}
internal class MathNet.Numerics.Optimization.TrustRegion.Subproblems.DogLegSubproblem : object {
    [CompilerGeneratedAttribute]
private Vector`1<double> <Pstep>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HitBoundary>k__BackingField;
    public Vector`1<double> Pstep { get; private set; }
    public bool HitBoundary { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Pstep();
    [CompilerGeneratedAttribute]
private void set_Pstep(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HitBoundary();
    [CompilerGeneratedAttribute]
private void set_HitBoundary(bool value);
    public sealed virtual void Solve(IObjectiveModel objective, double delta);
}
internal class MathNet.Numerics.Optimization.TrustRegion.Subproblems.NewtonCGSubproblem : object {
    [CompilerGeneratedAttribute]
private Vector`1<double> <Pstep>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HitBoundary>k__BackingField;
    public Vector`1<double> Pstep { get; private set; }
    public bool HitBoundary { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Vector`1<double> get_Pstep();
    [CompilerGeneratedAttribute]
private void set_Pstep(Vector`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HitBoundary();
    [CompilerGeneratedAttribute]
private void set_HitBoundary(bool value);
    public sealed virtual void Solve(IObjectiveModel objective, double delta);
}
internal static class MathNet.Numerics.Optimization.TrustRegion.Subproblems.Util : object {
    public static ValueTuple`2<double, double> FindBeta(double alpha, Vector`1<double> sd, Vector`1<double> gn, double delta);
}
public class MathNet.Numerics.Optimization.TrustRegion.TrustRegionDogLegMinimizer : TrustRegionMinimizerBase {
    public TrustRegionDogLegMinimizer(double gradientTolerance, double stepTolerance, double functionTolerance, double radiusTolerance, int maximumIterations);
}
public abstract class MathNet.Numerics.Optimization.TrustRegion.TrustRegionMinimizerBase : NonlinearMinimizerBase {
    public ITrustRegionSubproblem Subproblem;
    [CompilerGeneratedAttribute]
private double <RadiusTolerance>k__BackingField;
    public double RadiusTolerance { get; public set; }
    public TrustRegionMinimizerBase(ITrustRegionSubproblem subproblem, double gradientTolerance, double stepTolerance, double functionTolerance, double radiusTolerance, int maximumIterations);
    [CompilerGeneratedAttribute]
public double get_RadiusTolerance();
    [CompilerGeneratedAttribute]
public void set_RadiusTolerance(double value);
    public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Vector`1<double> initialGuess, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> scales, List`1<bool> isFixed);
    public NonlinearMinimizationResult FindMinimum(IObjectiveModel objective, Double[] initialGuess, Double[] lowerBound, Double[] upperBound, Double[] scales, Boolean[] isFixed);
    public NonlinearMinimizationResult Minimum(ITrustRegionSubproblem subproblem, IObjectiveModel objective, Vector`1<double> initialGuess, Vector`1<double> lowerBound, Vector`1<double> upperBound, Vector`1<double> scales, List`1<bool> isFixed, double gradientTolerance, double stepTolerance, double functionTolerance, double radiusTolerance, int maximumIterations);
}
public class MathNet.Numerics.Optimization.TrustRegion.TrustRegionNewtonCGMinimizer : TrustRegionMinimizerBase {
    public TrustRegionNewtonCGMinimizer(double gradientTolerance, double stepTolerance, double functionTolerance, double radiusTolerance, int maximumIterations);
}
public static class MathNet.Numerics.Optimization.TrustRegion.TrustRegionSubproblem : object {
    public static ITrustRegionSubproblem DogLeg();
    public static ITrustRegionSubproblem NewtonCG();
}
[DefaultMemberAttribute("Item")]
public class MathNet.Numerics.Permutation : object {
    private Int32[] _indices;
    public int Dimension { get; }
    public int Item { get; }
    public Permutation(Int32[] indices);
    public int get_Dimension();
    public int get_Item(int idx);
    public Permutation Inverse();
    public static Permutation FromInversions(Int32[] inv);
    public Int32[] ToInversions();
    private static bool CheckForProperPermutation(Int32[] indices);
}
[DataContractAttribute]
public class MathNet.Numerics.Polynomial : object {
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    [DataMemberAttribute]
public string VariableName;
    [DataMemberAttribute]
public Double[] Coefficients { get; private set; }
    public int Degree { get; }
    public static Polynomial Zero { get; }
    public Polynomial(int n);
    public Polynomial(double coefficient);
    public Polynomial(Double[] coefficients);
    public Polynomial(IEnumerable`1<double> coefficients);
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    [CompilerGeneratedAttribute]
private void set_Coefficients(Double[] value);
    public int get_Degree();
    public static Polynomial get_Zero();
    public static Polynomial Fit(Double[] x, Double[] y, int order, DirectRegressionMethod method);
    private static int EvaluateDegree(Double[] coefficients);
    public static double Evaluate(double z, Double[] coefficients);
    public static Complex Evaluate(Complex z, Double[] coefficients);
    public static Complex Evaluate(Complex z, Complex[] coefficients);
    public double Evaluate(double z);
    public Complex Evaluate(Complex z);
    public IEnumerable`1<double> Evaluate(IEnumerable`1<double> z);
    public IEnumerable`1<Complex> Evaluate(IEnumerable`1<Complex> z);
    public Polynomial Differentiate();
    public Polynomial Integrate();
    public Complex[] Roots();
    public DenseMatrix EigenvalueMatrix();
    public static Polynomial Add(Polynomial a, Polynomial b);
    public static Polynomial Add(Polynomial a, double b);
    public static Polynomial Subtract(Polynomial a, Polynomial b);
    public static Polynomial Subtract(Polynomial a, double b);
    public static Polynomial Subtract(double b, Polynomial a);
    public static Polynomial Negate(Polynomial a);
    public static Polynomial Multiply(Polynomial a, Polynomial b);
    public static Polynomial Multiply(Polynomial a, double k);
    public static Polynomial Divide(Polynomial a, double k);
    public static ValueTuple`2<Polynomial, Polynomial> DivideRemainder(Polynomial a, Polynomial b);
    public static Polynomial PointwiseDivide(Polynomial a, Polynomial b);
    public static Polynomial PointwiseMultiply(Polynomial a, Polynomial b);
    public ValueTuple`2<Polynomial, Polynomial> DivideRemainder(Polynomial b);
    public static Polynomial op_Addition(Polynomial a, Polynomial b);
    public static Polynomial op_Addition(Polynomial a, double k);
    public static Polynomial op_Addition(double k, Polynomial a);
    public static Polynomial op_Subtraction(Polynomial a, Polynomial b);
    public static Polynomial op_Subtraction(Polynomial a, double k);
    public static Polynomial op_Subtraction(double k, Polynomial a);
    public static Polynomial op_UnaryNegation(Polynomial a);
    public static Polynomial op_Multiply(Polynomial a, Polynomial b);
    public static Polynomial op_Multiply(Polynomial a, double k);
    public static Polynomial op_Multiply(double k, Polynomial a);
    public static Polynomial op_Division(Polynomial a, double k);
    public virtual string ToString();
    public string ToStringDescending();
    public string ToString(string format);
    public string ToStringDescending(string format);
    public string ToString(IFormatProvider formatProvider);
    public string ToStringDescending(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public string ToStringDescending(string format, IFormatProvider formatProvider);
    public sealed virtual bool Equals(Polynomial other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Polynomial Clone();
    private sealed virtual override object System.ICloneable.Clone();
}
[ExtensionAttribute]
public static class MathNet.Numerics.Precision : object {
    private static int DoubleWidth;
    private static int SingleWidth;
    public static double DoublePrecision;
    public static double PositiveDoublePrecision;
    public static double SinglePrecision;
    public static double PositiveSinglePrecision;
    public static double MachineEpsilon;
    public static double PositiveMachineEpsilon;
    public static int DoubleDecimalPlaces;
    public static int SingleDecimalPlaces;
    private static double DefaultDoubleAccuracy;
    private static float DefaultSingleAccuracy;
    private static Double[] NegativePowersOf10;
    private static Precision();
    [ExtensionAttribute]
public static int CompareTo(double a, double b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static int CompareTo(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static int CompareToRelative(double a, double b, double maximumError);
    [ExtensionAttribute]
public static int CompareToRelative(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static int CompareToNumbersBetween(double a, double b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool IsLarger(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsLarger(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsLarger(double a, double b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool IsLarger(float a, float b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool IsLargerRelative(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsLargerRelative(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsLargerRelative(double a, double b, double maximumError);
    [ExtensionAttribute]
public static bool IsLargerRelative(float a, float b, double maximumError);
    [ExtensionAttribute]
public static bool IsLargerNumbersBetween(double a, double b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool IsLargerNumbersBetween(float a, float b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool IsSmaller(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsSmaller(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsSmaller(double a, double b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool IsSmaller(float a, float b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool IsSmallerRelative(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsSmallerRelative(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool IsSmallerRelative(double a, double b, double maximumError);
    [ExtensionAttribute]
public static bool IsSmallerRelative(float a, float b, double maximumError);
    [ExtensionAttribute]
public static bool IsSmallerNumbersBetween(double a, double b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool IsSmallerNumbersBetween(float a, float b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool IsFinite(double value);
    [ExtensionAttribute]
public static int Magnitude(double value);
    [ExtensionAttribute]
public static int Magnitude(float value);
    [ExtensionAttribute]
public static double ScaleUnitMagnitude(double value);
    private static long AsDirectionalInt64(double value);
    private static int AsDirectionalInt32(float value);
    [ExtensionAttribute]
public static double Increment(double value, int count);
    [ExtensionAttribute]
public static double Decrement(double value, int count);
    [ExtensionAttribute]
public static double CoerceZero(double a, int maxNumbersBetween);
    [ExtensionAttribute]
public static double CoerceZero(double a, long maxNumbersBetween);
    [ExtensionAttribute]
public static double CoerceZero(double a, double maximumAbsoluteError);
    [ExtensionAttribute]
public static double CoerceZero(double a);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> RangeOfMatchingFloatingPointNumbers(double value, long maxNumbersBetween);
    [ExtensionAttribute]
public static double MaximumMatchingFloatingPointNumber(double value, long maxNumbersBetween);
    [ExtensionAttribute]
public static double MinimumMatchingFloatingPointNumber(double value, long maxNumbersBetween);
    [ExtensionAttribute]
public static ValueTuple`2<long, long> RangeOfMatchingNumbers(double value, double relativeDifference);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static ulong NumbersBetween(double a, double b);
    [ExtensionAttribute]
public static double EpsilonOf(double value);
    [ExtensionAttribute]
public static float EpsilonOf(float value);
    [ExtensionAttribute]
public static double PositiveEpsilonOf(double value);
    [ExtensionAttribute]
public static float PositiveEpsilonOf(float value);
    private static double MeasureMachineEpsilon();
    private static double MeasurePositiveMachineEpsilon();
    [ExtensionAttribute]
public static double RoundToMultiple(double number, double basis);
    [ExtensionAttribute]
public static float RoundToMultiple(float number, float basis);
    [ExtensionAttribute]
public static decimal RoundToMultiple(decimal number, decimal basis);
    [ExtensionAttribute]
public static double RoundToPower(double number, double basis);
    [ExtensionAttribute]
public static float RoundToPower(float number, float basis);
    [ExtensionAttribute]
public static double Round(double number, int digits);
    [ExtensionAttribute]
public static float Round(float number, int digits);
    [ExtensionAttribute]
public static decimal Round(decimal number, int digits);
    [ExtensionAttribute]
public static int Round(int number, int digits);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Round(UInt32 number, int digits);
    [ExtensionAttribute]
public static long Round(long number, int digits);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static ulong Round(ulong number, int digits);
    [ExtensionAttribute]
public static short Round(short number, int digits);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static ushort Round(ushort number, int digits);
    [ExtensionAttribute]
public static BigInteger Round(BigInteger number, int digits);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
private static double Truncate(double value);
    private static int SingleToInt32Bits(float value);
    private static float Int32BitsToSingle(int value);
    [ExtensionAttribute]
public static bool AlmostEqualNorm(double a, double b, double diff, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqualNorm(T a, T b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqualNormRelative(double a, double b, double diff, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqualNormRelative(T a, T b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqual(double a, double b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqual(float a, float b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex a, Complex b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex32 a, Complex32 b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(double a, double b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(float a, float b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex a, Complex b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex32 a, Complex32 b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqual(double a, double b);
    [ExtensionAttribute]
public static bool AlmostEqual(float a, float b);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex a, Complex b);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex32 a, Complex32 b);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(double a, double b);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(float a, float b);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex a, Complex b);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex32 a, Complex32 b);
    [ExtensionAttribute]
public static bool AlmostEqualNorm(double a, double b, double diff, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualNorm(T a, T b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualNormRelative(double a, double b, double diff, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualNormRelative(T a, T b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqual(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqual(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex a, Complex b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqual(Complex32 a, Complex32 b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(double a, double b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(float a, float b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex a, Complex b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Complex32 a, Complex32 b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualNumbersBetween(double a, double b, long maxNumbersBetween);
    [ExtensionAttribute]
public static bool AlmostEqualNumbersBetween(float a, float b, int maxNumbersBetween);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<double> a, IList`1<double> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<float> a, IList`1<float> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<Complex> a, IList`1<Complex> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<Complex32> a, IList`1<Complex32> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<double> a, IList`1<double> b, double maximumError);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<float> a, IList`1<float> b, double maximumError);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<Complex> a, IList`1<Complex> b, double maximumError);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<Complex32> a, IList`1<Complex32> b, double maximumError);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<double> a, IList`1<double> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<float> a, IList`1<float> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<Complex> a, IList`1<Complex> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqual(IList`1<Complex32> a, IList`1<Complex32> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<double> a, IList`1<double> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<float> a, IList`1<float> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<Complex> a, IList`1<Complex> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqualRelative(IList`1<Complex32> a, IList`1<Complex32> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool ListAlmostEqualNorm(IList`1<T> a, IList`1<T> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool ListAlmostEqualNormRelative(IList`1<T> a, IList`1<T> b, double maximumError);
    private static bool ListForAll(IList`1<T> a, IList`1<T> b, Func`4<T, T, TP, bool> predicate, TP parameter);
    [ExtensionAttribute]
public static bool AlmostEqual(Vector`1<T> a, Vector`1<T> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Vector`1<T> a, Vector`1<T> b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqual(Vector`1<T> a, Vector`1<T> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Vector`1<T> a, Vector`1<T> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqual(Matrix`1<T> a, Matrix`1<T> b, double maximumAbsoluteError);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Matrix`1<T> a, Matrix`1<T> b, double maximumError);
    [ExtensionAttribute]
public static bool AlmostEqual(Matrix`1<T> a, Matrix`1<T> b, int decimalPlaces);
    [ExtensionAttribute]
public static bool AlmostEqualRelative(Matrix`1<T> a, Matrix`1<T> b, int decimalPlaces);
    private static double Pow10(int y);
}
public static class MathNet.Numerics.Providers.FourierTransform.FourierTransformControl : object {
    private static string EnvVarFFTProvider;
    private static IFourierTransformProvider _fourierTransformProvider;
    private static object StaticLock;
    private static string MklTypeName;
    private static ProviderProbe`1<IFourierTransformProvider> MklProbe;
    [CompilerGeneratedAttribute]
private static string <HintPath>k__BackingField;
    public static string HintPath { get; public set; }
    public static IFourierTransformProvider Provider { get; public set; }
    private static FourierTransformControl();
    [CompilerGeneratedAttribute]
public static string get_HintPath();
    [CompilerGeneratedAttribute]
public static void set_HintPath(string value);
    public static IFourierTransformProvider get_Provider();
    public static void set_Provider(IFourierTransformProvider value);
    public static void UseManaged();
    public static void UseNativeMKL();
    public static bool TryUseNativeMKL();
    public static bool TryUseNative();
    public static bool TryUse(IFourierTransformProvider provider);
    public static void UseBest();
    public static void UseDefault();
    public static void FreeResources();
}
public enum MathNet.Numerics.Providers.FourierTransform.FourierTransformScaling : Enum {
    public int value__;
    public static FourierTransformScaling NoScaling;
    public static FourierTransformScaling SymmetricScaling;
    public static FourierTransformScaling BackwardScaling;
    public static FourierTransformScaling ForwardScaling;
}
public interface MathNet.Numerics.Providers.FourierTransform.IFourierTransformProvider {
    public abstract virtual bool IsAvailable();
    public abstract virtual void InitializeVerify();
    public abstract virtual void FreeResources();
    public abstract virtual void Forward(Complex32[] samples, FourierTransformScaling scaling);
    public abstract virtual void Forward(Complex[] samples, FourierTransformScaling scaling);
    public abstract virtual void Backward(Complex32[] spectrum, FourierTransformScaling scaling);
    public abstract virtual void Backward(Complex[] spectrum, FourierTransformScaling scaling);
    public abstract virtual void ForwardReal(Single[] samples, int n, FourierTransformScaling scaling);
    public abstract virtual void ForwardReal(Double[] samples, int n, FourierTransformScaling scaling);
    public abstract virtual void BackwardReal(Single[] spectrum, int n, FourierTransformScaling scaling);
    public abstract virtual void BackwardReal(Double[] spectrum, int n, FourierTransformScaling scaling);
    public abstract virtual void ForwardMultidim(Complex32[] samples, Int32[] dimensions, FourierTransformScaling scaling);
    public abstract virtual void ForwardMultidim(Complex[] samples, Int32[] dimensions, FourierTransformScaling scaling);
    public abstract virtual void BackwardMultidim(Complex32[] spectrum, Int32[] dimensions, FourierTransformScaling scaling);
    public abstract virtual void BackwardMultidim(Complex[] spectrum, Int32[] dimensions, FourierTransformScaling scaling);
}
public class MathNet.Numerics.Providers.FourierTransform.ManagedFourierTransformProvider : object {
    private static int BluesteinSequenceLengthThreshold;
    [CompilerGeneratedAttribute]
private static ManagedFourierTransformProvider <Instance>k__BackingField;
    public static ManagedFourierTransformProvider Instance { get; }
    private static ManagedFourierTransformProvider();
    private static Complex32[] BluesteinSequence32(int n);
    private static Complex[] BluesteinSequence(int n);
    private static void BluesteinConvolutionParallel(Complex32[] samples);
    private static void BluesteinConvolutionParallel(Complex[] samples);
    private static void SwapRealImaginary(Complex32[] samples);
    private static void SwapRealImaginary(Complex[] samples);
    private static void BluesteinForward(Complex[] samples);
    private static void BluesteinInverse(Complex[] spectrum);
    private static void BluesteinForward(Complex32[] samples);
    private static void BluesteinInverse(Complex32[] spectrum);
    [CompilerGeneratedAttribute]
public static ManagedFourierTransformProvider get_Instance();
    public sealed virtual bool IsAvailable();
    public sealed virtual void InitializeVerify();
    public sealed virtual void FreeResources();
    public virtual string ToString();
    public sealed virtual void Forward(Complex32[] samples, FourierTransformScaling scaling);
    public sealed virtual void Forward(Complex[] samples, FourierTransformScaling scaling);
    public sealed virtual void Backward(Complex32[] spectrum, FourierTransformScaling scaling);
    public sealed virtual void Backward(Complex[] spectrum, FourierTransformScaling scaling);
    public sealed virtual void ForwardReal(Single[] samples, int n, FourierTransformScaling scaling);
    public sealed virtual void ForwardReal(Double[] samples, int n, FourierTransformScaling scaling);
    public sealed virtual void BackwardReal(Single[] spectrum, int n, FourierTransformScaling scaling);
    public sealed virtual void BackwardReal(Double[] spectrum, int n, FourierTransformScaling scaling);
    public sealed virtual void ForwardMultidim(Complex32[] samples, Int32[] dimensions, FourierTransformScaling scaling);
    public sealed virtual void ForwardMultidim(Complex[] samples, Int32[] dimensions, FourierTransformScaling scaling);
    public sealed virtual void BackwardMultidim(Complex32[] spectrum, Int32[] dimensions, FourierTransformScaling scaling);
    public sealed virtual void BackwardMultidim(Complex[] spectrum, Int32[] dimensions, FourierTransformScaling scaling);
    private static void Radix2Reorder(T[] samples);
    private static void Radix2Step(Complex32[] samples, int exponentSign, int levelSize, int k);
    private static void Radix2Step(Complex[] samples, int exponentSign, int levelSize, int k);
    private static void Radix2Forward(Complex32[] data);
    private static void Radix2Forward(Complex[] data);
    private static void Radix2Inverse(Complex32[] data);
    private static void Radix2Inverse(Complex[] data);
    private static void Radix2ForwardParallel(Complex32[] data);
    private static void Radix2ForwardParallel(Complex[] data);
    private static void Radix2InverseParallel(Complex32[] data);
    private static void Radix2InverseParallel(Complex[] data);
    private static void FullRescale(Complex32[] samples);
    private static void FullRescale(Complex[] samples);
    private static void HalfRescale(Complex32[] samples);
    private static void HalfRescale(Complex[] samples);
}
public interface MathNet.Numerics.Providers.IProviderCreator`1 {
    public abstract virtual T CreateProvider();
}
public interface MathNet.Numerics.Providers.LinearAlgebra.ILinearAlgebraProvider {
    public abstract virtual bool IsAvailable();
    public abstract virtual void InitializeVerify();
    public abstract virtual void FreeResources();
}
public interface MathNet.Numerics.Providers.LinearAlgebra.ILinearAlgebraProvider`1 {
    public abstract virtual void AddVectorToScaledVector(T[] y, T alpha, T[] x, T[] result);
    public abstract virtual void ScaleArray(T alpha, T[] x, T[] result);
    public abstract virtual void ConjugateArray(T[] x, T[] result);
    public abstract virtual T DotProduct(T[] x, T[] y);
    public abstract virtual void AddArrays(T[] x, T[] y, T[] result);
    public abstract virtual void SubtractArrays(T[] x, T[] y, T[] result);
    public abstract virtual void PointWiseMultiplyArrays(T[] x, T[] y, T[] result);
    public abstract virtual void PointWiseDivideArrays(T[] x, T[] y, T[] result);
    public abstract virtual void PointWisePowerArrays(T[] x, T[] y, T[] result);
    public abstract virtual double MatrixNorm(Norm norm, int rows, int columns, T[] matrix);
    public abstract virtual void MatrixMultiply(T[] x, int rowsX, int columnsX, T[] y, int rowsY, int columnsY, T[] result);
    public abstract virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, T alpha, T[] a, int rowsA, int columnsA, T[] b, int rowsB, int columnsB, T beta, T[] c);
    public abstract virtual void LUFactor(T[] data, int order, Int32[] ipiv);
    public abstract virtual void LUInverse(T[] a, int order);
    public abstract virtual void LUInverseFactored(T[] a, int order, Int32[] ipiv);
    public abstract virtual void LUSolve(int columnsOfB, T[] a, int order, T[] b);
    public abstract virtual void LUSolveFactored(int columnsOfB, T[] a, int order, Int32[] ipiv, T[] b);
    public abstract virtual void CholeskyFactor(T[] a, int order);
    public abstract virtual void CholeskySolve(T[] a, int orderA, T[] b, int columnsB);
    public abstract virtual void CholeskySolveFactored(T[] a, int orderA, T[] b, int columnsB);
    public abstract virtual void QRFactor(T[] a, int rowsA, int columnsA, T[] q, T[] tau);
    public abstract virtual void ThinQRFactor(T[] a, int rowsA, int columnsA, T[] r, T[] tau);
    public abstract virtual void QRSolve(T[] a, int rows, int columns, T[] b, int columnsB, T[] x, QRMethod method);
    public abstract virtual void QRSolveFactored(T[] q, T[] r, int rowsA, int columnsA, T[] tau, T[] b, int columnsB, T[] x, QRMethod method);
    public abstract virtual void SingularValueDecomposition(bool computeVectors, T[] a, int rowsA, int columnsA, T[] s, T[] u, T[] vt);
    public abstract virtual void SvdSolve(T[] a, int rowsA, int columnsA, T[] b, int columnsB, T[] x);
    public abstract virtual void SvdSolveFactored(int rowsA, int columnsA, T[] s, T[] u, T[] vt, T[] b, int columnsB, T[] x);
    public abstract virtual void EigenDecomp(bool isSymmetric, int order, T[] matrix, T[] matrixEv, Complex[] vectorEv, T[] matrixD);
}
public static class MathNet.Numerics.Providers.LinearAlgebra.LinearAlgebraControl : object {
    private static string EnvVarLAProvider;
    private static ILinearAlgebraProvider _linearAlgebraProvider;
    private static object StaticLock;
    private static string MklTypeName;
    private static ProviderProbe`1<ILinearAlgebraProvider> MklProbe;
    private static string OpenBlasTypeName;
    private static ProviderProbe`1<ILinearAlgebraProvider> OpenBlasProbe;
    private static string CudaTypeName;
    private static ProviderProbe`1<ILinearAlgebraProvider> CudaProbe;
    [CompilerGeneratedAttribute]
private static string <HintPath>k__BackingField;
    public static string HintPath { get; public set; }
    public static ILinearAlgebraProvider Provider { get; public set; }
    private static LinearAlgebraControl();
    [CompilerGeneratedAttribute]
public static string get_HintPath();
    [CompilerGeneratedAttribute]
public static void set_HintPath(string value);
    public static ILinearAlgebraProvider get_Provider();
    public static void set_Provider(ILinearAlgebraProvider value);
    public static void UseManaged();
    public static void UseNativeMKL();
    public static bool TryUseNativeMKL();
    public static void UseNativeCUDA();
    public static bool TryUseNativeCUDA();
    public static void UseNativeOpenBLAS();
    public static bool TryUseNativeOpenBLAS();
    public static bool TryUseNative();
    public static bool TryUse(ILinearAlgebraProvider provider);
    public static void UseBest();
    public static void UseDefault();
    public static void FreeResources();
}
public class MathNet.Numerics.Providers.LinearAlgebra.ManagedLinearAlgebraProvider : object {
    [CompilerGeneratedAttribute]
private static ManagedLinearAlgebraProvider <Instance>k__BackingField;
    public static ManagedLinearAlgebraProvider Instance { get; }
    private static ManagedLinearAlgebraProvider();
    public sealed virtual void AddVectorToScaledVector(Complex[] y, Complex alpha, Complex[] x, Complex[] result);
    public sealed virtual void ScaleArray(Complex alpha, Complex[] x, Complex[] result);
    public sealed virtual void ConjugateArray(Complex[] x, Complex[] result);
    public sealed virtual Complex DotProduct(Complex[] x, Complex[] y);
    public sealed virtual void AddArrays(Complex[] x, Complex[] y, Complex[] result);
    public sealed virtual void SubtractArrays(Complex[] x, Complex[] y, Complex[] result);
    public sealed virtual void PointWiseMultiplyArrays(Complex[] x, Complex[] y, Complex[] result);
    public sealed virtual void PointWiseDivideArrays(Complex[] x, Complex[] y, Complex[] result);
    public sealed virtual void PointWisePowerArrays(Complex[] x, Complex[] y, Complex[] result);
    public sealed virtual double MatrixNorm(Norm norm, int rows, int columns, Complex[] matrix);
    public sealed virtual void MatrixMultiply(Complex[] x, int rowsX, int columnsX, Complex[] y, int rowsY, int columnsY, Complex[] result);
    public sealed virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex alpha, Complex[] a, int rowsA, int columnsA, Complex[] b, int rowsB, int columnsB, Complex beta, Complex[] c);
    public sealed virtual void LUFactor(Complex[] data, int order, Int32[] ipiv);
    public sealed virtual void LUInverse(Complex[] a, int order);
    public sealed virtual void LUInverseFactored(Complex[] a, int order, Int32[] ipiv);
    public sealed virtual void LUSolve(int columnsOfB, Complex[] a, int order, Complex[] b);
    public sealed virtual void LUSolveFactored(int columnsOfB, Complex[] a, int order, Int32[] ipiv, Complex[] b);
    public sealed virtual void CholeskyFactor(Complex[] a, int order);
    private static void DoCholeskyStep(Complex[] data, int rowDim, int firstCol, int colLimit, Complex[] multipliers, int availableCores);
    public sealed virtual void CholeskySolve(Complex[] a, int orderA, Complex[] b, int columnsB);
    public sealed virtual void CholeskySolveFactored(Complex[] a, int orderA, Complex[] b, int columnsB);
    private static void DoCholeskySolve(Complex[] a, int orderA, Complex[] b, int index);
    public sealed virtual void QRFactor(Complex[] r, int rowsR, int columnsR, Complex[] q, Complex[] tau);
    public sealed virtual void ThinQRFactor(Complex[] a, int rowsA, int columnsA, Complex[] r, Complex[] tau);
    private static void ComputeQR(Complex[] work, int workIndex, Complex[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores);
    private static void GenerateColumn(Complex[] work, Complex[] a, int rowCount, int row, int column);
    public sealed virtual void QRSolve(Complex[] a, int rows, int columns, Complex[] b, int columnsB, Complex[] x, QRMethod method);
    public sealed virtual void QRSolveFactored(Complex[] q, Complex[] r, int rowsA, int columnsA, Complex[] tau, Complex[] b, int columnsB, Complex[] x, QRMethod method);
    public sealed virtual void SingularValueDecomposition(bool computeVectors, Complex[] a, int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt);
    public sealed virtual void SvdSolve(Complex[] a, int rowsA, int columnsA, Complex[] b, int columnsB, Complex[] x);
    public sealed virtual void SvdSolveFactored(int rowsA, int columnsA, Complex[] s, Complex[] u, Complex[] vt, Complex[] b, int columnsB, Complex[] x);
    public sealed virtual void EigenDecomp(bool isSymmetric, int order, Complex[] matrix, Complex[] matrixEv, Complex[] vectorEv, Complex[] matrixD);
    internal static void SymmetricTridiagonalize(Complex[] matrixA, Double[] d, Double[] e, Complex[] tau, int order);
    internal static void SymmetricDiagonalize(Complex[] dataEv, Double[] d, Double[] e, int order);
    internal static void SymmetricUntridiagonalize(Complex[] dataEv, Complex[] matrixA, Complex[] tau, int order);
    internal static void NonsymmetricReduceToHessenberg(Complex[] dataEv, Complex[] matrixH, int order);
    internal static void NonsymmetricReduceHessenberToRealSchur(Complex[] vectorV, Complex[] dataEv, Complex[] matrixH, int order);
    private static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex[] matrix, Complex[] row);
    private static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex[] matrix, Complex[] column);
    public sealed virtual void AddVectorToScaledVector(Complex32[] y, Complex32 alpha, Complex32[] x, Complex32[] result);
    public sealed virtual void ScaleArray(Complex32 alpha, Complex32[] x, Complex32[] result);
    public sealed virtual void ConjugateArray(Complex32[] x, Complex32[] result);
    public sealed virtual Complex32 DotProduct(Complex32[] x, Complex32[] y);
    public sealed virtual void AddArrays(Complex32[] x, Complex32[] y, Complex32[] result);
    public sealed virtual void SubtractArrays(Complex32[] x, Complex32[] y, Complex32[] result);
    public sealed virtual void PointWiseMultiplyArrays(Complex32[] x, Complex32[] y, Complex32[] result);
    public sealed virtual void PointWiseDivideArrays(Complex32[] x, Complex32[] y, Complex32[] result);
    public sealed virtual void PointWisePowerArrays(Complex32[] x, Complex32[] y, Complex32[] result);
    public sealed virtual double MatrixNorm(Norm norm, int rows, int columns, Complex32[] matrix);
    public sealed virtual void MatrixMultiply(Complex32[] x, int rowsX, int columnsX, Complex32[] y, int rowsY, int columnsY, Complex32[] result);
    public sealed virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, Complex32 alpha, Complex32[] a, int rowsA, int columnsA, Complex32[] b, int rowsB, int columnsB, Complex32 beta, Complex32[] c);
    public sealed virtual void LUFactor(Complex32[] data, int order, Int32[] ipiv);
    public sealed virtual void LUInverse(Complex32[] a, int order);
    public sealed virtual void LUInverseFactored(Complex32[] a, int order, Int32[] ipiv);
    public sealed virtual void LUSolve(int columnsOfB, Complex32[] a, int order, Complex32[] b);
    public sealed virtual void LUSolveFactored(int columnsOfB, Complex32[] a, int order, Int32[] ipiv, Complex32[] b);
    public sealed virtual void CholeskyFactor(Complex32[] a, int order);
    private static void DoCholeskyStep(Complex32[] data, int rowDim, int firstCol, int colLimit, Complex32[] multipliers, int availableCores);
    public sealed virtual void CholeskySolve(Complex32[] a, int orderA, Complex32[] b, int columnsB);
    public sealed virtual void CholeskySolveFactored(Complex32[] a, int orderA, Complex32[] b, int columnsB);
    private static void DoCholeskySolve(Complex32[] a, int orderA, Complex32[] b, int index);
    public sealed virtual void QRFactor(Complex32[] r, int rowsR, int columnsR, Complex32[] q, Complex32[] tau);
    public sealed virtual void ThinQRFactor(Complex32[] a, int rowsA, int columnsA, Complex32[] r, Complex32[] tau);
    private static void ComputeQR(Complex32[] work, int workIndex, Complex32[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores);
    private static void GenerateColumn(Complex32[] work, Complex32[] a, int rowCount, int row, int column);
    public sealed virtual void QRSolve(Complex32[] a, int rows, int columns, Complex32[] b, int columnsB, Complex32[] x, QRMethod method);
    public sealed virtual void QRSolveFactored(Complex32[] q, Complex32[] r, int rowsA, int columnsA, Complex32[] tau, Complex32[] b, int columnsB, Complex32[] x, QRMethod method);
    public sealed virtual void SingularValueDecomposition(bool computeVectors, Complex32[] a, int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt);
    public sealed virtual void SvdSolve(Complex32[] a, int rowsA, int columnsA, Complex32[] b, int columnsB, Complex32[] x);
    public sealed virtual void SvdSolveFactored(int rowsA, int columnsA, Complex32[] s, Complex32[] u, Complex32[] vt, Complex32[] b, int columnsB, Complex32[] x);
    public sealed virtual void EigenDecomp(bool isSymmetric, int order, Complex32[] matrix, Complex32[] matrixEv, Complex[] vectorEv, Complex32[] matrixD);
    internal static void SymmetricTridiagonalize(Complex32[] matrixA, Single[] d, Single[] e, Complex32[] tau, int order);
    internal static void SymmetricDiagonalize(Complex32[] dataEv, Single[] d, Single[] e, int order);
    internal static void SymmetricUntridiagonalize(Complex32[] dataEv, Complex32[] matrixA, Complex32[] tau, int order);
    internal static void NonsymmetricReduceToHessenberg(Complex32[] dataEv, Complex32[] matrixH, int order);
    internal static void NonsymmetricReduceHessenberToRealSchur(Complex32[] vectorV, Complex32[] dataEv, Complex32[] matrixH, int order);
    private static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, Complex32[] matrix, Complex32[] row);
    private static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, Complex32[] matrix, Complex32[] column);
    [CompilerGeneratedAttribute]
public static ManagedLinearAlgebraProvider get_Instance();
    public sealed virtual bool IsAvailable();
    public sealed virtual void InitializeVerify();
    public sealed virtual void FreeResources();
    public virtual string ToString();
    private static void GetRow(Transpose transpose, int rowindx, int numRows, int numCols, T[] matrix, T[] row);
    private static void GetColumn(Transpose transpose, int colindx, int numRows, int numCols, T[] matrix, T[] column);
    public sealed virtual void AddVectorToScaledVector(Double[] y, double alpha, Double[] x, Double[] result);
    public sealed virtual void ScaleArray(double alpha, Double[] x, Double[] result);
    public sealed virtual void ConjugateArray(Double[] x, Double[] result);
    public sealed virtual double DotProduct(Double[] x, Double[] y);
    public sealed virtual void AddArrays(Double[] x, Double[] y, Double[] result);
    public sealed virtual void SubtractArrays(Double[] x, Double[] y, Double[] result);
    public sealed virtual void PointWiseMultiplyArrays(Double[] x, Double[] y, Double[] result);
    public sealed virtual void PointWiseDivideArrays(Double[] x, Double[] y, Double[] result);
    public sealed virtual void PointWisePowerArrays(Double[] x, Double[] y, Double[] result);
    public sealed virtual double MatrixNorm(Norm norm, int rows, int columns, Double[] matrix);
    public sealed virtual void MatrixMultiply(Double[] x, int rowsX, int columnsX, Double[] y, int rowsY, int columnsY, Double[] result);
    public sealed virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, double alpha, Double[] a, int rowsA, int columnsA, Double[] b, int rowsB, int columnsB, double beta, Double[] c);
    public sealed virtual void LUFactor(Double[] data, int order, Int32[] ipiv);
    public sealed virtual void LUInverse(Double[] a, int order);
    public sealed virtual void LUInverseFactored(Double[] a, int order, Int32[] ipiv);
    public sealed virtual void LUSolve(int columnsOfB, Double[] a, int order, Double[] b);
    public sealed virtual void LUSolveFactored(int columnsOfB, Double[] a, int order, Int32[] ipiv, Double[] b);
    public sealed virtual void CholeskyFactor(Double[] a, int order);
    private static void DoCholeskyStep(Double[] data, int rowDim, int firstCol, int colLimit, Double[] multipliers, int availableCores);
    public sealed virtual void CholeskySolve(Double[] a, int orderA, Double[] b, int columnsB);
    public sealed virtual void CholeskySolveFactored(Double[] a, int orderA, Double[] b, int columnsB);
    private static void DoCholeskySolve(Double[] a, int orderA, Double[] b, int index);
    public sealed virtual void QRFactor(Double[] r, int rowsR, int columnsR, Double[] q, Double[] tau);
    public sealed virtual void ThinQRFactor(Double[] a, int rowsA, int columnsA, Double[] r, Double[] tau);
    private static void ComputeQR(Double[] work, int workIndex, Double[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores);
    private static void GenerateColumn(Double[] work, Double[] a, int rowCount, int row, int column);
    public sealed virtual void QRSolve(Double[] a, int rows, int columns, Double[] b, int columnsB, Double[] x, QRMethod method);
    public sealed virtual void QRSolveFactored(Double[] q, Double[] r, int rowsA, int columnsA, Double[] tau, Double[] b, int columnsB, Double[] x, QRMethod method);
    public sealed virtual void SingularValueDecomposition(bool computeVectors, Double[] a, int rowsA, int columnsA, Double[] s, Double[] u, Double[] vt);
    private static void Drotg(Double& da, Double& db, Double& c, Double& s);
    public sealed virtual void SvdSolve(Double[] a, int rowsA, int columnsA, Double[] b, int columnsB, Double[] x);
    public sealed virtual void SvdSolveFactored(int rowsA, int columnsA, Double[] s, Double[] u, Double[] vt, Double[] b, int columnsB, Double[] x);
    public sealed virtual void EigenDecomp(bool isSymmetric, int order, Double[] matrix, Double[] matrixEv, Complex[] vectorEv, Double[] matrixD);
    internal static void SymmetricTridiagonalize(Double[] a, Double[] d, Double[] e, int order);
    internal static void SymmetricDiagonalize(Double[] a, Double[] d, Double[] e, int order);
    internal static void NonsymmetricReduceToHessenberg(Double[] a, Double[] matrixH, int order);
    internal static void NonsymmetricReduceHessenberToRealSchur(Double[] a, Double[] matrixH, Double[] d, Double[] e, int order);
    private static Complex Cdiv(double xreal, double ximag, double yreal, double yimag);
    public sealed virtual void AddVectorToScaledVector(Single[] y, float alpha, Single[] x, Single[] result);
    public sealed virtual void ScaleArray(float alpha, Single[] x, Single[] result);
    public sealed virtual void ConjugateArray(Single[] x, Single[] result);
    public sealed virtual float DotProduct(Single[] x, Single[] y);
    public sealed virtual void AddArrays(Single[] x, Single[] y, Single[] result);
    public sealed virtual void SubtractArrays(Single[] x, Single[] y, Single[] result);
    public sealed virtual void PointWiseMultiplyArrays(Single[] x, Single[] y, Single[] result);
    public sealed virtual void PointWiseDivideArrays(Single[] x, Single[] y, Single[] result);
    public sealed virtual void PointWisePowerArrays(Single[] x, Single[] y, Single[] result);
    public sealed virtual double MatrixNorm(Norm norm, int rows, int columns, Single[] matrix);
    public sealed virtual void MatrixMultiply(Single[] x, int rowsX, int columnsX, Single[] y, int rowsY, int columnsY, Single[] result);
    public sealed virtual void MatrixMultiplyWithUpdate(Transpose transposeA, Transpose transposeB, float alpha, Single[] a, int rowsA, int columnsA, Single[] b, int rowsB, int columnsB, float beta, Single[] c);
    public sealed virtual void LUFactor(Single[] data, int order, Int32[] ipiv);
    public sealed virtual void LUInverse(Single[] a, int order);
    public sealed virtual void LUInverseFactored(Single[] a, int order, Int32[] ipiv);
    public sealed virtual void LUSolve(int columnsOfB, Single[] a, int order, Single[] b);
    public sealed virtual void LUSolveFactored(int columnsOfB, Single[] a, int order, Int32[] ipiv, Single[] b);
    public sealed virtual void CholeskyFactor(Single[] a, int order);
    private static void DoCholeskyStep(Single[] data, int rowDim, int firstCol, int colLimit, Single[] multipliers, int availableCores);
    public sealed virtual void CholeskySolve(Single[] a, int orderA, Single[] b, int columnsB);
    public sealed virtual void CholeskySolveFactored(Single[] a, int orderA, Single[] b, int columnsB);
    private static void DoCholeskySolve(Single[] a, int orderA, Single[] b, int index);
    public sealed virtual void QRFactor(Single[] r, int rowsR, int columnsR, Single[] q, Single[] tau);
    public sealed virtual void ThinQRFactor(Single[] a, int rowsA, int columnsA, Single[] r, Single[] tau);
    private static void ComputeQR(Single[] work, int workIndex, Single[] a, int rowStart, int rowCount, int columnStart, int columnCount, int availableCores);
    private static void GenerateColumn(Single[] work, Single[] a, int rowCount, int row, int column);
    public sealed virtual void QRSolve(Single[] a, int rows, int columns, Single[] b, int columnsB, Single[] x, QRMethod method);
    public sealed virtual void QRSolveFactored(Single[] q, Single[] r, int rowsA, int columnsA, Single[] tau, Single[] b, int columnsB, Single[] x, QRMethod method);
    public sealed virtual void SingularValueDecomposition(bool computeVectors, Single[] a, int rowsA, int columnsA, Single[] s, Single[] u, Single[] vt);
    private static void Drotg(Single& da, Single& db, Single& c, Single& s);
    public sealed virtual void SvdSolve(Single[] a, int rowsA, int columnsA, Single[] b, int columnsB, Single[] x);
    public sealed virtual void SvdSolveFactored(int rowsA, int columnsA, Single[] s, Single[] u, Single[] vt, Single[] b, int columnsB, Single[] x);
    public sealed virtual void EigenDecomp(bool isSymmetric, int order, Single[] matrix, Single[] matrixEv, Complex[] vectorEv, Single[] matrixD);
    internal static void SymmetricTridiagonalize(Single[] a, Single[] d, Single[] e, int order);
    internal static void SymmetricDiagonalize(Single[] a, Single[] d, Single[] e, int order);
    internal static void NonsymmetricReduceToHessenberg(Single[] a, Single[] matrixH, int order);
    internal static void NonsymmetricReduceHessenberToRealSchur(Single[] a, Single[] matrixH, Single[] d, Single[] e, int order);
    private static Complex32 Cdiv(float xreal, float ximag, float yreal, float yimag);
}
public enum MathNet.Numerics.Providers.LinearAlgebra.Norm : Enum {
    public byte value__;
    public static Norm OneNorm;
    public static Norm FrobeniusNorm;
    public static Norm InfinityNorm;
    public static Norm LargestAbsoluteValue;
}
public enum MathNet.Numerics.Providers.LinearAlgebra.Transpose : Enum {
    public int value__;
    public static Transpose DontTranspose;
    public static Transpose Transpose;
    public static Transpose ConjugateTranspose;
}
public class MathNet.Numerics.Providers.ProviderProbe`1 : object {
    private bool _disabled;
    private Lazy`1<IProviderCreator`1<T>> _creator;
    public ProviderProbe`1(string typeName, bool disabled);
    public T Create();
    public T TryCreate();
}
public enum MathNet.Numerics.Providers.SparseSolver.DssMatrixStructure : Enum {
    public int value__;
    public static DssMatrixStructure Symmetric;
    public static DssMatrixStructure SymmetricStructure;
    public static DssMatrixStructure Nonsymmetric;
    public static DssMatrixStructure SymmetricComplex;
    public static DssMatrixStructure SymmetricStructureComplex;
    public static DssMatrixStructure NonsymmetricComplex;
}
public enum MathNet.Numerics.Providers.SparseSolver.DssMatrixType : Enum {
    public int value__;
    public static DssMatrixType PositiveDefinite;
    public static DssMatrixType Indefinite;
    public static DssMatrixType HermitianPositiveDefinite;
    public static DssMatrixType HermitianIndefinite;
}
public enum MathNet.Numerics.Providers.SparseSolver.DssStatus : Enum {
    public int value__;
    public static DssStatus MKL_DSS_SUCCESS;
    public static DssStatus MKL_DSS_ZERO_PIVOT;
    public static DssStatus MKL_DSS_OUT_OF_MEMORY;
    public static DssStatus MKL_DSS_FAILURE;
    public static DssStatus MKL_DSS_ROW_ERR;
    public static DssStatus MKL_DSS_COL_ERR;
    public static DssStatus MKL_DSS_TOO_FEW_VALUES;
    public static DssStatus MKL_DSS_TOO_MANY_VALUES;
    public static DssStatus MKL_DSS_NOT_SQUARE;
    public static DssStatus MKL_DSS_STATE_ERR;
    public static DssStatus MKL_DSS_INVALID_OPTION;
    public static DssStatus MKL_DSS_OPTION_CONFLICT;
    public static DssStatus MKL_DSS_MSG_LVL_ERR;
    public static DssStatus MKL_DSS_TERM_LVL_ERR;
    public static DssStatus MKL_DSS_STRUCTURE_ERR;
    public static DssStatus MKL_DSS_REORDER_ERR;
    public static DssStatus MKL_DSS_VALUES_ERR;
    public static DssStatus MKL_DSS_STATISTICS_INVALID_MATRIX;
    public static DssStatus MKL_DSS_STATISTICS_INVALID_STATE;
    public static DssStatus MKL_DSS_STATISTICS_INVALID_STRING;
    public static DssStatus MKL_DSS_REORDER1_ERR;
    public static DssStatus MKL_DSS_PREORDER_ERR;
    public static DssStatus MKL_DSS_DIAG_ERR;
    public static DssStatus MKL_DSS_I32BIT_ERR;
    public static DssStatus MKL_DSS_OOC_MEM_ERR;
    public static DssStatus MKL_DSS_OOC_OC_ERR;
    public static DssStatus MKL_DSS_OOC_RW_ERR;
}
public enum MathNet.Numerics.Providers.SparseSolver.DssSystemType : Enum {
    public int value__;
    public static DssSystemType DontTranspose;
    public static DssSystemType Transpose;
    public static DssSystemType ConjugateTranspose;
}
public interface MathNet.Numerics.Providers.SparseSolver.ISparseSolverProvider {
    public abstract virtual bool IsAvailable();
    public abstract virtual void InitializeVerify();
    public abstract virtual void FreeResources();
}
public interface MathNet.Numerics.Providers.SparseSolver.ISparseSolverProvider`1 {
    public abstract virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rows, int cols, int nnz, Int32[] rowIdx, Int32[] colPtr, T[] values, int nRhs, T[] rhs, T[] solution);
}
public class MathNet.Numerics.Providers.SparseSolver.ManagedSparseSolverProvider : object {
    [CompilerGeneratedAttribute]
private static ManagedSparseSolverProvider <Instance>k__BackingField;
    public static ManagedSparseSolverProvider Instance { get; }
    private static ManagedSparseSolverProvider();
    [CompilerGeneratedAttribute]
public static ManagedSparseSolverProvider get_Instance();
    public sealed virtual bool IsAvailable();
    public sealed virtual void InitializeVerify();
    public sealed virtual void FreeResources();
    public virtual string ToString();
    public sealed virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, Int32[] rowPointers, Int32[] columnIndices, Single[] values, int nRhs, Single[] rhs, Single[] solution);
    public sealed virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, Int32[] rowPointers, Int32[] columnIndices, Double[] values, int nRhs, Double[] rhs, Double[] solution);
    public sealed virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, Int32[] rowPointers, Int32[] columnIndices, Complex32[] values, int nRhs, Complex32[] rhs, Complex32[] solution);
    public sealed virtual DssStatus Solve(DssMatrixStructure matrixStructure, DssMatrixType matrixType, DssSystemType systemType, int rowCount, int columnCount, int nonZerosCount, Int32[] rowPointers, Int32[] columnIndices, Complex[] values, int nRhs, Complex[] rhs, Complex[] solution);
}
public static class MathNet.Numerics.Providers.SparseSolver.SparseSolverControl : object {
    private static string EnvVarSSProvider;
    private static ISparseSolverProvider _sparseSolverProvider;
    private static object StaticLock;
    private static string MklTypeName;
    private static ProviderProbe`1<ISparseSolverProvider> MklProbe;
    [CompilerGeneratedAttribute]
private static string <HintPath>k__BackingField;
    public static string HintPath { get; public set; }
    public static ISparseSolverProvider Provider { get; public set; }
    private static SparseSolverControl();
    [CompilerGeneratedAttribute]
public static string get_HintPath();
    [CompilerGeneratedAttribute]
public static void set_HintPath(string value);
    public static ISparseSolverProvider get_Provider();
    public static void set_Provider(ISparseSolverProvider value);
    public static void UseManaged();
    public static void UseNativeMKL();
    public static bool TryUseNativeMKL();
    public static bool TryUseNative();
    public static bool TryUse(ISparseSolverProvider provider);
    public static void UseBest();
    public static void UseDefault();
    public static void FreeResources();
}
public class MathNet.Numerics.Random.CryptoRandomSource : RandomSource {
    private static double Reciprocal;
    private RandomNumberGenerator _crypto;
    public CryptoRandomSource(RandomNumberGenerator rng);
    public CryptoRandomSource(bool threadSafe);
    public CryptoRandomSource(RandomNumberGenerator rng, bool threadSafe);
    protected virtual void DoSampleBytes(Byte[] buffer);
    protected virtual double DoSample();
    protected virtual int DoSampleInteger();
    public sealed virtual void Dispose();
    public static void Doubles(Double[] values);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.CryptoRandomSource/<DoubleSequence>d__12")]
public static IEnumerable`1<double> DoubleSequence();
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Mcg31m1 : RandomSource {
    private static ulong Modulus;
    private static ulong Multiplier;
    private static double Reciprocal;
    [DataMemberAttribute]
private ulong _xn;
    public Mcg31m1(bool threadSafe);
    public Mcg31m1(int seed);
    public Mcg31m1(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Mcg31m1/<DoubleSequence>d__11")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Mcg59 : RandomSource {
    private static ulong Modulus;
    private static ulong Multiplier;
    private static double Reciprocal;
    [DataMemberAttribute]
private ulong _xn;
    public Mcg59(bool threadSafe);
    public Mcg59(int seed);
    public Mcg59(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Mcg59/<DoubleSequence>d__11")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.MersenneTwister : RandomSource {
    private static UInt32 LowerMask;
    private static int M;
    private static UInt32 MatrixA;
    private static int N;
    private static double Reciprocal;
    private static UInt32 UpperMask;
    private static UInt32[] Mag01;
    [DataMemberAttribute]
private UInt32[] _mt;
    [DataMemberAttribute]
private int _mti;
    private static ThreadLocal`1<MersenneTwister> DefaultInstance;
    public static MersenneTwister Default { get; }
    public MersenneTwister(bool threadSafe);
    public MersenneTwister(int seed);
    public MersenneTwister(int seed, bool threadSafe);
    private static MersenneTwister();
    public static MersenneTwister get_Default();
    private void init_genrand(UInt32 s);
    private UInt32 genrand_int32();
    protected sealed virtual double DoSample();
    protected sealed virtual int DoSampleInteger();
    protected sealed virtual void DoSampleBytes(Byte[] buffer);
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.MersenneTwister/<DoubleSequence>d__23")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Mrg32k3a : RandomSource {
    private static double A12;
    private static double A13;
    private static double A21;
    private static double A23;
    private static double Modulus1;
    private static double Modulus2;
    private static double Reciprocal;
    [DataMemberAttribute]
private double _xn1;
    [DataMemberAttribute]
private double _xn2;
    [DataMemberAttribute]
private double _xn3;
    [DataMemberAttribute]
private double _yn1;
    [DataMemberAttribute]
private double _yn2;
    [DataMemberAttribute]
private double _yn3;
    public Mrg32k3a(bool threadSafe);
    public Mrg32k3a(int seed);
    public Mrg32k3a(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Mrg32k3a/<DoubleSequence>d__20")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Palf : RandomSource {
    private static int DefaultShortLag;
    private static int DefaultLongLag;
    private static double Reciprocal;
    [CompilerGeneratedAttribute]
private int <ShortLag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LongLag>k__BackingField;
    [DataMemberAttribute]
private UInt32[] _x;
    [DataMemberAttribute]
private int _threads;
    [DataMemberAttribute]
private int _k;
    [DataMemberAttribute]
public int ShortLag { get; private set; }
    [DataMemberAttribute]
public int LongLag { get; private set; }
    public Palf(bool threadSafe);
    public Palf(int seed);
    public Palf(int seed, bool threadSafe);
    public Palf(int seed, bool threadSafe, int shortLag, int longLag);
    [CompilerGeneratedAttribute]
public int get_ShortLag();
    [CompilerGeneratedAttribute]
private void set_ShortLag(int value);
    [CompilerGeneratedAttribute]
public int get_LongLag();
    [CompilerGeneratedAttribute]
private void set_LongLag(int value);
    private void Fill();
    protected sealed virtual double DoSample();
    protected virtual int DoSampleInteger();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Palf/<DoubleSequence>d__24")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Random.RandomExtensions : object {
    [ExtensionAttribute]
public static void NextDoubles(Random rnd, Double[] values);
    [ExtensionAttribute]
public static Double[] NextDoubles(Random rnd, int count);
    [ExtensionAttribute]
public static IEnumerable`1<double> NextDoubleSequence(Random rnd);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomExtensions/<NextDoubleSequenceEnumerable>d__3")]
private static IEnumerable`1<double> NextDoubleSequenceEnumerable(Random rnd);
    [ExtensionAttribute]
public static Byte[] NextBytes(Random rnd, int count);
    [ExtensionAttribute]
public static void NextInt32s(Random rnd, Int32[] values);
    [ExtensionAttribute]
public static void NextInt32s(Random rnd, Int32[] values, int minInclusive, int maxExclusive);
    [ExtensionAttribute]
public static IEnumerable`1<int> NextInt32Sequence(Random rnd, int minInclusive, int maxExclusive);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomExtensions/<NextInt32SequenceEnumerable>d__8")]
private static IEnumerable`1<int> NextInt32SequenceEnumerable(Random rnd, int minInclusive, int maxExclusive);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomExtensions/<NextBigIntegerSequence>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<BigInteger> NextBigIntegerSequence(Random rnd, BigInteger minInclusive, BigInteger maxExclusive);
    [ExtensionAttribute]
public static long NextInt64(Random rnd);
    [ExtensionAttribute]
public static int NextFullRangeInt32(Random rnd);
    [ExtensionAttribute]
public static long NextFullRangeInt64(Random rnd);
    [ExtensionAttribute]
public static decimal NextDecimal(Random rnd);
    [ExtensionAttribute]
public static bool NextBoolean(Random rnd);
}
public static class MathNet.Numerics.Random.RandomSeed : object {
    private static object Lock;
    private static RandomNumberGenerator MasterRng;
    private static RandomSeed();
    public static int Time();
    public static int Guid();
    public static int Robust();
}
[DataContractAttribute]
public abstract class MathNet.Numerics.Random.RandomSource : Random {
    private bool _threadSafe;
    private object _lock;
    protected RandomSource(bool threadSafe);
    public void NextDoubles(Double[] values);
    public Double[] NextDoubles(int count);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomSource/<NextDoubleSequence>d__6")]
public IEnumerable`1<double> NextDoubleSequence();
    public sealed virtual int Next();
    public sealed virtual int Next(int maxExclusive);
    public sealed virtual int Next(int minInclusive, int maxExclusive);
    public void NextInt32s(Int32[] values);
    public Int32[] NextInt32s(int count);
    public void NextInt32s(Int32[] values, int maxExclusive);
    public Int32[] NextInt32s(int count, int maxExclusive);
    public void NextInt32s(Int32[] values, int minInclusive, int maxExclusive);
    public Int32[] NextInt32s(int count, int minInclusive, int maxExclusive);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomSource/<NextInt32Sequence>d__16")]
public IEnumerable`1<int> NextInt32Sequence();
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.RandomSource/<NextInt32Sequence>d__17")]
public IEnumerable`1<int> NextInt32Sequence(int minInclusive, int maxExclusive);
    public sealed virtual void NextBytes(Byte[] buffer);
    protected sealed virtual double Sample();
    protected abstract virtual double DoSample();
    protected virtual int DoSampleInteger();
    protected virtual void DoSampleBytes(Byte[] buffer);
    protected virtual int DoSampleInt32WithNBits(int bitCount);
    protected virtual long DoSampleInt64WithNBits(int bitCount);
    protected virtual int DoSampleInteger(int maxExclusive);
    protected virtual int DoSampleInteger(int minInclusive, int maxExclusive);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.SystemRandomSource : RandomSource {
    [DataMemberAttribute]
private Random _random;
    private static ThreadLocal`1<SystemRandomSource> DefaultInstance;
    public static SystemRandomSource Default { get; }
    public SystemRandomSource(bool threadSafe);
    public SystemRandomSource(int seed);
    public SystemRandomSource(int seed, bool threadSafe);
    private static SystemRandomSource();
    public static SystemRandomSource get_Default();
    protected sealed virtual double DoSample();
    protected virtual int DoSampleInteger();
    protected virtual int DoSampleInteger(int maxExclusive);
    protected virtual int DoSampleInteger(int minInclusive, int maxExclusive);
    protected virtual void DoSampleBytes(Byte[] buffer);
    public static void FastDoubles(Double[] values);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] FastDoubles(int length);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.SystemRandomSource/<DoubleSequence>d__15")]
public static IEnumerable`1<double> DoubleSequence();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.SystemRandomSource/<DoubleSequence>d__18")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.WH1982 : RandomSource {
    private static UInt32 Modx;
    private static double ModxRecip;
    private static UInt32 Mody;
    private static double ModyRecip;
    private static UInt32 Modz;
    private static double ModzRecip;
    [DataMemberAttribute]
private UInt32 _xn;
    [DataMemberAttribute]
private UInt32 _yn;
    [DataMemberAttribute]
private UInt32 _zn;
    public WH1982(bool threadSafe);
    public WH1982(int seed);
    public WH1982(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.WH1982/<DoubleSequence>d__16")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.WH2006 : RandomSource {
    private static UInt32 Modw;
    private static double ModwRecip;
    private static UInt32 Modx;
    private static double ModxRecip;
    private static UInt32 Mody;
    private static double ModyRecip;
    private static UInt32 Modz;
    private static double ModzRecip;
    [DataMemberAttribute]
private ulong _wn;
    [DataMemberAttribute]
private ulong _xn;
    [DataMemberAttribute]
private ulong _yn;
    [DataMemberAttribute]
private ulong _zn;
    public WH2006(bool threadSafe);
    public WH2006(int seed);
    public WH2006(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.WH2006/<DoubleSequence>d__19")]
public static IEnumerable`1<double> DoubleSequence(int seed);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Xorshift : RandomSource {
    private static UInt32 YSeed;
    private static UInt32 ZSeed;
    private static UInt32 ASeed;
    private static UInt32 CSeed;
    private static double UlongToDoubleMultiplier;
    [DataMemberAttribute]
private ulong _x;
    [DataMemberAttribute]
private ulong _y;
    [DataMemberAttribute]
private ulong _z;
    [DataMemberAttribute]
private ulong _c;
    [DataMemberAttribute]
private ulong _a;
    public Xorshift(long a, long c, long x1, long x2);
    public Xorshift(bool threadSafe);
    public Xorshift(bool threadSafe, long a, long c, long x1, long x2);
    public Xorshift(int seed);
    public Xorshift(int seed, long a, long c, long x1, long x2);
    public Xorshift(int seed, bool threadSafe);
    public Xorshift(int seed, bool threadSafe, long a, long c, long x1, long x2);
    protected sealed virtual double DoSample();
    protected sealed virtual int DoSampleInteger();
    protected sealed virtual void DoSampleBytes(Byte[] buffer);
    [CLSCompliantAttribute("False")]
public static void Doubles(Double[] values, int seed, ulong a, ulong c, ulong x1, ulong x2);
    [CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed, ulong a, ulong c, ulong x1, ulong x2);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Xorshift/<DoubleSequence>d__23")]
[CLSCompliantAttribute("False")]
public static IEnumerable`1<double> DoubleSequence(int seed, ulong a, ulong c, ulong x1, ulong x2);
}
[DataContractAttribute]
public class MathNet.Numerics.Random.Xoshiro256StarStar : RandomSource {
    private static double REAL_UNIT_UINT;
    [DataMemberAttribute]
private ulong _s0;
    [DataMemberAttribute]
private ulong _s1;
    [DataMemberAttribute]
private ulong _s2;
    [DataMemberAttribute]
private ulong _s3;
    public Xoshiro256StarStar(bool threadSafe);
    public Xoshiro256StarStar(int seed);
    public Xoshiro256StarStar(int seed, bool threadSafe);
    protected sealed virtual double DoSample();
    protected virtual int DoSampleInteger();
    protected virtual void DoSampleBytes(Byte[] buffer);
    protected virtual int DoSampleInt32WithNBits(int bitCount);
    protected virtual long DoSampleInt64WithNBits(int bitCount);
    private void Initialise(int seed);
    private ulong NextInnerULong();
    public static void Doubles(Double[] values, int seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline this type of method across NGen image boundaries")]
public static Double[] Doubles(int length, int seed);
    [IteratorStateMachineAttribute("MathNet.Numerics.Random.Xoshiro256StarStar/<DoubleSequence>d__18")]
public static IEnumerable`1<double> DoubleSequence(int seed);
    private static ulong Splitmix64(UInt64& x);
    private static ulong RotateLeft(ulong x, int k);
}
public static class MathNet.Numerics.RootFinding.Bisection : object {
    public static double FindRootExpand(Func`2<double, double> f, double guessLowerBound, double guessUpperBound, double accuracy, int maxIterations, double expandFactor, int maxExpandIteratons);
    public static double FindRoot(Func`2<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static bool TryFindRoot(Func`2<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations, Double& root);
}
public static class MathNet.Numerics.RootFinding.Brent : object {
    public static double FindRootExpand(Func`2<double, double> f, double guessLowerBound, double guessUpperBound, double accuracy, int maxIterations, double expandFactor, int maxExpandIteratons);
    public static double FindRoot(Func`2<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static bool TryFindRoot(Func`2<double, double> f, double lowerBound, double upperBound, double accuracy, int maxIterations, Double& root);
    private static double Sign(double a, double b);
}
public static class MathNet.Numerics.RootFinding.Broyden : object {
    public static Double[] FindRoot(Func`2<Double[], Double[]> f, Double[] initialGuess, double accuracy, int maxIterations, double jacobianStepSize);
    public static bool TryFindRootWithJacobianStep(Func`2<Double[], Double[]> f, Double[] initialGuess, double accuracy, int maxIterations, double jacobianStepSize, Double[]& root);
    public static bool TryFindRoot(Func`2<Double[], Double[]> f, Double[] initialGuess, double accuracy, int maxIterations, Double[]& root);
    private static Matrix`1<double> CalculateApproximateJacobian(Func`2<Double[], Double[]> f, Double[] x0, Double[] y0, double jacobianStepSize);
}
public static class MathNet.Numerics.RootFinding.Cubic : object {
    private static void QR(double a2, double a1, double a0, Double& Q, Double& R);
    private static double PowThird(double n);
    public static ValueTuple`3<double, double, double> RealRoots(double a0, double a1, double a2);
    public static ValueTuple`3<Complex, Complex, Complex> Roots(double d, double c, double b, double a);
}
public static class MathNet.Numerics.RootFinding.NewtonRaphson : object {
    public static double FindRoot(Func`2<double, double> f, Func`2<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static double FindRootNearGuess(Func`2<double, double> f, Func`2<double, double> df, double initialGuess, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static bool TryFindRoot(Func`2<double, double> f, Func`2<double, double> df, double initialGuess, double lowerBound, double upperBound, double accuracy, int maxIterations, Double& root);
}
public static class MathNet.Numerics.RootFinding.RobustNewtonRaphson : object {
    public static double FindRoot(Func`2<double, double> f, Func`2<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations, int subdivision);
    public static bool TryFindRoot(Func`2<double, double> f, Func`2<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations, int subdivision, Double& root);
    private static bool TryScanForCrossingsWithRoots(Func`2<double, double> f, Func`2<double, double> df, double lowerBound, double upperBound, double accuracy, int maxIterations, int subdivision, Double& root);
}
public static class MathNet.Numerics.RootFinding.Secant : object {
    public static double FindRoot(Func`2<double, double> f, double guess, double secondGuess, double lowerBound, double upperBound, double accuracy, int maxIterations);
    public static bool TryFindRoot(Func`2<double, double> f, double guess, double secondGuess, double lowerBound, double upperBound, double accuracy, int maxIterations, Double& root);
}
public static class MathNet.Numerics.RootFinding.ZeroCrossingBracketing : object {
    [IteratorStateMachineAttribute("MathNet.Numerics.RootFinding.ZeroCrossingBracketing/<FindIntervalsWithin>d__0")]
public static IEnumerable`1<ValueTuple`2<double, double>> FindIntervalsWithin(Func`2<double, double> f, double lowerBound, double upperBound, int subdivisions);
    public static bool Expand(Func`2<double, double> f, Double& lowerBound, Double& upperBound, double factor, int maxIterations);
    public static bool Reduce(Func`2<double, double> f, Double& lowerBound, Double& upperBound, int subdivisions);
    public static bool ExpandReduce(Func`2<double, double> f, Double& lowerBound, Double& upperBound, double expansionFactor, int expansionMaxIterations, int reduceSubdivisions);
}
public static class MathNet.Numerics.Series : object {
    public static double Evaluate(Func`1<double> nextSummand);
    public static double Evaluate(IEnumerable`1<double> infiniteSummands);
}
public class MathNet.Numerics.SingularUMatrixException : NativeInterfaceException {
    public SingularUMatrixException(int element);
    public SingularUMatrixException(int element, Exception innerException);
    protected SingularUMatrixException(SerializationInfo info, StreamingContext context);
}
public static class MathNet.Numerics.Sorting : object {
    public static void Sort(IList`1<T> keys, IComparer`1<T> comparer);
    public static void Sort(IList`1<TKey> keys, IList`1<TItem> items, IComparer`1<TKey> comparer);
    public static void Sort(IList`1<TKey> keys, IList`1<TItem1> items1, IList`1<TItem2> items2, IComparer`1<TKey> comparer);
    public static void Sort(IList`1<T> keys, int index, int count, IComparer`1<T> comparer);
    public static void Sort(IList`1<TKey> keys, IList`1<TItem> items, int index, int count, IComparer`1<TKey> comparer);
    public static void Sort(IList`1<TKey> keys, IList`1<TItem1> items1, IList`1<TItem2> items2, int index, int count, IComparer`1<TKey> comparer);
    public static void SortAll(IList`1<T1> primary, IList`1<T2> secondary, IComparer`1<T1> primaryComparer, IComparer`1<T2> secondaryComparer);
    private static void QuickSort(IList`1<T> keys, IComparer`1<T> comparer, int left, int right);
    private static void QuickSort(IList`1<T> keys, IList`1<TItems> items, IComparer`1<T> comparer, int left, int right);
    private static void QuickSort(IList`1<T> keys, IList`1<TItems1> items1, IList`1<TItems2> items2, IComparer`1<T> comparer, int left, int right);
    private static void QuickSortAll(IList`1<T1> primary, IList`1<T2> secondary, IComparer`1<T1> primaryComparer, IComparer`1<T2> secondaryComparer, int left, int right);
    private static void Swap(IList`1<T> keys, int a, int b);
}
public static class MathNet.Numerics.SpecialFunctions : object {
    private static Double[] ErfImpAn;
    private static Double[] ErfImpAd;
    private static Double[] ErfImpBn;
    private static Double[] ErfImpBd;
    private static Double[] ErfImpCn;
    private static Double[] ErfImpCd;
    private static Double[] ErfImpDn;
    private static Double[] ErfImpDd;
    private static Double[] ErfImpEn;
    private static Double[] ErfImpEd;
    private static Double[] ErfImpFn;
    private static Double[] ErfImpFd;
    private static Double[] ErfImpGn;
    private static Double[] ErfImpGd;
    private static Double[] ErfImpHn;
    private static Double[] ErfImpHd;
    private static Double[] ErfImpIn;
    private static Double[] ErfImpId;
    private static Double[] ErfImpJn;
    private static Double[] ErfImpJd;
    private static Double[] ErfImpKn;
    private static Double[] ErfImpKd;
    private static Double[] ErfImpLn;
    private static Double[] ErfImpLd;
    private static Double[] ErfImpMn;
    private static Double[] ErfImpMd;
    private static Double[] ErfImpNn;
    private static Double[] ErfImpNd;
    private static Double[] ErvInvImpAn;
    private static Double[] ErvInvImpAd;
    private static Double[] ErvInvImpBn;
    private static Double[] ErvInvImpBd;
    private static Double[] ErvInvImpCn;
    private static Double[] ErvInvImpCd;
    private static Double[] ErvInvImpDn;
    private static Double[] ErvInvImpDd;
    private static Double[] ErvInvImpEn;
    private static Double[] ErvInvImpEd;
    private static Double[] ErvInvImpFn;
    private static Double[] ErvInvImpFd;
    private static Double[] ErvInvImpGn;
    private static Double[] ErvInvImpGd;
    private static Double[] _factorialCache;
    private static int GammaN;
    private static double GammaR;
    private static Double[] GammaDk;
    private static Double[] BesselI0A;
    private static Double[] BesselI0B;
    private static Double[] BesselI1A;
    private static Double[] BesselI1B;
    private static Double[] BesselK0A;
    private static Double[] BesselK0B;
    private static Double[] BesselK1A;
    private static Double[] BesselK1B;
    private static SpecialFunctions();
    public static Complex AiryAi(Complex z);
    public static Complex AiryAiScaled(Complex z);
    public static double AiryAi(double z);
    public static double AiryAiScaled(double z);
    public static Complex AiryAiPrime(Complex z);
    public static Complex AiryAiPrimeScaled(Complex z);
    public static double AiryAiPrime(double z);
    public static double AiryAiPrimeScaled(double z);
    public static Complex AiryBi(Complex z);
    public static Complex AiryBiScaled(Complex z);
    public static double AiryBi(double z);
    public static double AiryBiScaled(double z);
    public static Complex AiryBiPrime(Complex z);
    public static Complex AiryBiPrimeScaled(Complex z);
    public static double AiryBiPrime(double z);
    public static double AiryBiPrimeScaled(double z);
    public static Complex BesselJ(double n, Complex z);
    public static Complex BesselJScaled(double n, Complex z);
    public static double BesselJ(double n, double z);
    public static double BesselJScaled(double n, double z);
    public static Complex BesselY(double n, Complex z);
    public static Complex BesselYScaled(double n, Complex z);
    public static double BesselY(double n, double z);
    public static double BesselYScaled(double n, double z);
    public static Complex BesselI(double n, Complex z);
    public static Complex BesselIScaled(double n, Complex z);
    public static double BesselI(double n, double z);
    public static double BesselIScaled(double n, double z);
    public static Complex BesselK(double n, Complex z);
    public static Complex BesselKScaled(double n, Complex z);
    public static double BesselK(double n, double z);
    public static double BesselKScaled(double n, double z);
    public static double BetaLn(double z, double w);
    public static double Beta(double z, double w);
    public static double BetaIncomplete(double a, double b, double x);
    public static double BetaRegularized(double a, double b, double x);
    public static double Erf(double x);
    public static double Erfc(double x);
    public static double ErfInv(double z);
    private static double ErfImp(double z, bool invert);
    public static double ErfcInv(double z);
    private static double ErfInvImpl(double p, double q, double s);
    public static double Expm1(double power);
    [ObsoleteAttribute("Use Expm1 instead")]
public static double ExponentialMinusOne(double power);
    public static double ExponentialIntegral(double x, int n);
    public static double Factorial(int x);
    public static BigInteger Factorial(BigInteger x);
    public static double FactorialLn(int x);
    public static double Binomial(int n, int k);
    public static double BinomialLn(int n, int k);
    public static double Multinomial(int n, Int32[] ni);
    public static double GammaLn(double z);
    public static double Gamma(double z);
    public static double GammaUpperRegularized(double a, double x);
    public static double GammaUpperIncomplete(double a, double x);
    public static double GammaLowerIncomplete(double a, double x);
    public static double GammaLowerRegularized(double a, double x);
    public static double GammaLowerRegularizedInv(double a, double y0);
    public static double DiGamma(double x);
    public static double DiGammaInv(double p);
    public static double RisingFactorial(double x, int n);
    public static double FallingFactorial(double x, int n);
    public static double GeneralizedHypergeometric(Double[] a, Double[] b, int z);
    private static double HGIncrement(Double[] a, Double[] b, int z, int currentN);
    public static Complex HankelH1(double n, Complex z);
    public static Complex HankelH1Scaled(double n, Complex z);
    public static Complex HankelH2(double n, Complex z);
    public static Complex HankelH2Scaled(double n, Complex z);
    public static double Harmonic(int t);
    public static double GeneralHarmonic(int n, double m);
    public static Complex KelvinBe(double nu, double x);
    public static double KelvinBer(double nu, double x);
    public static double KelvinBer(double x);
    public static double KelvinBei(double nu, double x);
    public static double KelvinBei(double x);
    public static double KelvinBerPrime(double nu, double x);
    public static double KelvinBerPrime(double x);
    public static double KelvinBeiPrime(double nu, double x);
    public static double KelvinBeiPrime(double x);
    public static Complex KelvinKe(double nu, double x);
    public static double KelvinKer(double nu, double x);
    public static double KelvinKer(double x);
    public static double KelvinKei(double nu, double x);
    public static double KelvinKei(double x);
    public static double KelvinKerPrime(double nu, double x);
    public static double KelvinKerPrime(double x);
    public static double KelvinKeiPrime(double nu, double x);
    public static double KelvinKeiPrime(double x);
    public static double Log1p(double x);
    public static double Logistic(double p);
    public static double Logit(double p);
    public static double MarcumQ(double nu, double a, double b);
    public static double MarcumQ(double nu, double a, double b, Int32& err);
    public static double BesselI0(double x);
    public static double BesselI1(double x);
    public static double BesselK0(double x);
    public static double BesselK0e(double x);
    public static double BesselK1(double x);
    public static double BesselK1e(double x);
    public static double StruveL0(double x);
    public static double StruveL1(double x);
    public static double BesselI0MStruveL0(double x);
    public static double BesselI1MStruveL1(double x);
    public static Complex SphericalBesselJ(double n, Complex z);
    public static double SphericalBesselJ(double n, double z);
    public static Complex SphericalBesselY(double n, Complex z);
    public static double SphericalBesselY(double n, double z);
    public static Complex Hypotenuse(Complex a, Complex b);
    public static Complex32 Hypotenuse(Complex32 a, Complex32 b);
    public static double Hypotenuse(double a, double b);
    public static float Hypotenuse(float a, float b);
}
public static class MathNet.Numerics.Statistics.ArrayStatistics : object {
    public static Complex MinimumMagnitudePhase(Complex[] data);
    public static Complex32 MinimumMagnitudePhase(Complex32[] data);
    public static Complex MaximumMagnitudePhase(Complex[] data);
    public static Complex32 MaximumMagnitudePhase(Complex32[] data);
    public static double Minimum(Double[] data);
    public static double Maximum(Double[] data);
    public static double MinimumAbsolute(Double[] data);
    public static double MaximumAbsolute(Double[] data);
    public static double Mean(Double[] data);
    public static double GeometricMean(Double[] data);
    public static double HarmonicMean(Double[] data);
    public static double Variance(Double[] samples);
    public static double PopulationVariance(Double[] population);
    public static double StandardDeviation(Double[] samples);
    public static double PopulationStandardDeviation(Double[] population);
    public static ValueTuple`2<double, double> MeanVariance(Double[] samples);
    public static ValueTuple`2<double, double> MeanStandardDeviation(Double[] samples);
    public static double Covariance(Double[] samples1, Double[] samples2);
    public static double PopulationCovariance(Double[] population1, Double[] population2);
    public static double RootMeanSquare(Double[] data);
    public static double OrderStatisticInplace(Double[] data, int order);
    public static double MedianInplace(Double[] data);
    public static double PercentileInplace(Double[] data, int p);
    public static double LowerQuartileInplace(Double[] data);
    public static double UpperQuartileInplace(Double[] data);
    public static double InterquartileRangeInplace(Double[] data);
    public static Double[] FiveNumberSummaryInplace(Double[] data);
    public static double QuantileInplace(Double[] data, double tau);
    public static double QuantileCustomInplace(Double[] data, double tau, double a, double b, double c, double d);
    public static double QuantileCustomInplace(Double[] data, double tau, QuantileDefinition definition);
    private static double SelectInplace(Double[] workingData, int rank);
    public static Double[] RanksInplace(Double[] data, RankDefinition definition);
    private static void RanksTies(Double[] ranks, Int32[] index, int a, int b, RankDefinition definition);
    public static double Mean(Int32[] data);
    public static double GeometricMean(Int32[] data);
    public static double HarmonicMean(Int32[] data);
    public static double Variance(Int32[] samples);
    public static double PopulationVariance(Int32[] population);
    public static double StandardDeviation(Int32[] samples);
    public static double PopulationStandardDeviation(Int32[] population);
    public static ValueTuple`2<double, double> MeanVariance(Int32[] samples);
    public static ValueTuple`2<double, double> MeanStandardDeviation(Int32[] samples);
    public static double Covariance(Int32[] samples1, Int32[] samples2);
    public static double PopulationCovariance(Int32[] population1, Int32[] population2);
    public static double RootMeanSquare(Int32[] data);
    public static float Minimum(Single[] data);
    public static float Maximum(Single[] data);
    public static float MinimumAbsolute(Single[] data);
    public static float MaximumAbsolute(Single[] data);
    public static double Mean(Single[] data);
    public static double GeometricMean(Single[] data);
    public static double HarmonicMean(Single[] data);
    public static double Variance(Single[] samples);
    public static double PopulationVariance(Single[] population);
    public static double StandardDeviation(Single[] samples);
    public static double PopulationStandardDeviation(Single[] population);
    public static ValueTuple`2<double, double> MeanVariance(Single[] samples);
    public static ValueTuple`2<double, double> MeanStandardDeviation(Single[] samples);
    public static double Covariance(Single[] samples1, Single[] samples2);
    public static double PopulationCovariance(Single[] population1, Single[] population2);
    public static double RootMeanSquare(Single[] data);
    public static float OrderStatisticInplace(Single[] data, int order);
    public static float MedianInplace(Single[] data);
    public static float PercentileInplace(Single[] data, int p);
    public static float LowerQuartileInplace(Single[] data);
    public static float UpperQuartileInplace(Single[] data);
    public static float InterquartileRangeInplace(Single[] data);
    public static Single[] FiveNumberSummaryInplace(Single[] data);
    public static float QuantileInplace(Single[] data, double tau);
    public static float QuantileCustomInplace(Single[] data, double tau, double a, double b, double c, double d);
    public static float QuantileCustomInplace(Single[] data, double tau, QuantileDefinition definition);
    private static float SelectInplace(Single[] workingData, int rank);
    public static Single[] RanksInplace(Single[] data, RankDefinition definition);
    private static void RanksTies(Single[] ranks, Int32[] index, int a, int b, RankDefinition definition);
}
[DataContractAttribute]
public class MathNet.Numerics.Statistics.Bucket : object {
    private static PointComparer Comparer;
    [CompilerGeneratedAttribute]
private double <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Count>k__BackingField;
    [DataMemberAttribute]
public double LowerBound { get; public set; }
    [DataMemberAttribute]
public double UpperBound { get; public set; }
    [DataMemberAttribute]
public double Count { get; public set; }
    public double Width { get; }
    private bool IsSinglePoint { get; }
    public static IComparer`1<Bucket> DefaultPointComparer { get; }
    public Bucket(double lowerBound, double upperBound, double count);
    public Bucket(double targetValue);
    private static Bucket();
    [CompilerGeneratedAttribute]
public double get_LowerBound();
    [CompilerGeneratedAttribute]
public void set_LowerBound(double value);
    [CompilerGeneratedAttribute]
public double get_UpperBound();
    [CompilerGeneratedAttribute]
public void set_UpperBound(double value);
    [CompilerGeneratedAttribute]
public double get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(double value);
    public sealed virtual object Clone();
    public double get_Width();
    private bool get_IsSinglePoint();
    public static IComparer`1<Bucket> get_DefaultPointComparer();
    public int Contains(double x);
    public sealed virtual int CompareTo(Bucket bucket);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class MathNet.Numerics.Statistics.Correlation : object {
    public static Double[] Auto(Double[] x);
    public static Double[] Auto(Double[] x, int kMax, int kMin);
    public static Double[] Auto(Double[] x, Int32[] k);
    private static Double[] AutoCorrelationFft(Double[] x, int kLow, int kHigh);
    public static double Pearson(IEnumerable`1<double> dataA, IEnumerable`1<double> dataB);
    public static double WeightedPearson(IEnumerable`1<double> dataA, IEnumerable`1<double> dataB, IEnumerable`1<double> weights);
    public static Matrix`1<double> PearsonMatrix(Double[][] vectors);
    public static Matrix`1<double> PearsonMatrix(IEnumerable`1<Double[]> vectors);
    public static double Spearman(IEnumerable`1<double> dataA, IEnumerable`1<double> dataB);
    public static Matrix`1<double> SpearmanMatrix(Double[][] vectors);
    public static Matrix`1<double> SpearmanMatrix(IEnumerable`1<Double[]> vectors);
    private static Double[] Rank(IEnumerable`1<double> series);
}
[DataContractAttribute]
public class MathNet.Numerics.Statistics.DescriptiveStatistics : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Skewness>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Kurtosis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Minimum>k__BackingField;
    [DataMemberAttribute]
public long Count { get; private set; }
    [DataMemberAttribute]
public double Mean { get; private set; }
    [DataMemberAttribute]
public double Variance { get; private set; }
    [DataMemberAttribute]
public double StandardDeviation { get; private set; }
    [DataMemberAttribute]
public double Skewness { get; private set; }
    [DataMemberAttribute]
public double Kurtosis { get; private set; }
    [DataMemberAttribute]
public double Maximum { get; private set; }
    [DataMemberAttribute]
public double Minimum { get; private set; }
    public DescriptiveStatistics(IEnumerable`1<double> data, bool increasedAccuracy);
    public DescriptiveStatistics(IEnumerable`1<Nullable`1<double>> data, bool increasedAccuracy);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
private void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public double get_Skewness();
    [CompilerGeneratedAttribute]
private void set_Skewness(double value);
    [CompilerGeneratedAttribute]
public double get_Kurtosis();
    [CompilerGeneratedAttribute]
private void set_Kurtosis(double value);
    [CompilerGeneratedAttribute]
public double get_Maximum();
    [CompilerGeneratedAttribute]
private void set_Maximum(double value);
    [CompilerGeneratedAttribute]
public double get_Minimum();
    [CompilerGeneratedAttribute]
private void set_Minimum(double value);
    private void Compute(IEnumerable`1<double> data);
    private void Compute(IEnumerable`1<Nullable`1<double>> data);
    private void ComputeDecimal(IEnumerable`1<double> data);
    private void ComputeDecimal(IEnumerable`1<Nullable`1<double>> data);
    private void SetStatistics(double mean, double variance, double skewness, double kurtosis, double minimum, double maximum, long n);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class MathNet.Numerics.Statistics.Histogram : object {
    [DataMemberAttribute]
private List`1<Bucket> _buckets;
    [DataMemberAttribute]
private bool _areBucketsSorted;
    public double LowerBound { get; }
    public double UpperBound { get; }
    public Bucket Item { get; }
    public int BucketCount { get; }
    public double DataCount { get; }
    public Histogram(IEnumerable`1<double> data, int nbuckets);
    public Histogram(IEnumerable`1<double> data, int nbuckets, double lower, double upper);
    public void AddData(double d);
    public void AddData(IEnumerable`1<double> data);
    public void AddBucket(Bucket bucket);
    private void LazySort();
    public Bucket GetBucketOf(double v);
    public int GetBucketIndexOf(double v);
    public double get_LowerBound();
    public double get_UpperBound();
    public Bucket get_Item(int n);
    public int get_BucketCount();
    public double get_DataCount();
    public virtual string ToString();
}
public static class MathNet.Numerics.Statistics.KernelDensity : object {
    public static double Estimate(double x, double bandwidth, IList`1<double> samples, Func`2<double, double> kernel);
    public static double EstimateGaussian(double x, double bandwidth, IList`1<double> samples);
    public static double EstimateEpanechnikov(double x, double bandwidth, IList`1<double> samples);
    public static double EstimateUniform(double x, double bandwidth, IList`1<double> samples);
    public static double EstimateTriangular(double x, double bandwidth, IList`1<double> samples);
    public static double GaussianKernel(double x);
    public static double EpanechnikovKernel(double x);
    public static double UniformKernel(double x);
    public static double TriangularKernel(double x);
}
public class MathNet.Numerics.Statistics.Mcmc.Density`1 : MulticastDelegate {
    public Density`1(object object, IntPtr method);
    public virtual double Invoke(T sample);
    public virtual IAsyncResult BeginInvoke(T sample, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class MathNet.Numerics.Statistics.Mcmc.DensityLn`1 : MulticastDelegate {
    public DensityLn`1(object object, IntPtr method);
    public virtual double Invoke(T sample);
    public virtual IAsyncResult BeginInvoke(T sample, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class MathNet.Numerics.Statistics.Mcmc.GlobalProposalSampler`1 : MulticastDelegate {
    public GlobalProposalSampler`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class MathNet.Numerics.Statistics.Mcmc.HybridMC : HybridMCGeneric`1<Double[]> {
    private int _length;
    private Normal _pDistribution;
    private Double[] _mpSdv;
    public Double[] MomentumStdDev { get; public set; }
    public HybridMC(Double[] x0, DensityLn`1<Double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval);
    public HybridMC(Double[] x0, DensityLn`1<Double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, Double[] pSdv);
    public HybridMC(Double[] x0, DensityLn`1<Double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, Double[] pSdv, Random randomSource);
    public HybridMC(Double[] x0, DensityLn`1<Double[]> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, Double[] pSdv, Random randomSource, DiffMethod<Double[]> diff);
    public Double[] get_MomentumStdDev();
    public void set_MomentumStdDev(Double[] value);
    private void Initialize(Double[] x0);
    private void CheckVariance(Double[] pSdv);
    protected virtual Double[] Copy(Double[] source);
    protected virtual Double[] Create();
    protected virtual void DoAdd(Double[]& first, double factor, Double[] second);
    protected virtual void DoSubtract(Double[]& first, double factor, Double[] second);
    protected virtual double DoProduct(Double[] first, Double[] second);
    protected virtual void RandomizeMomentum(Double[]& p);
    private static Double[] Grad(DensityLn`1<Double[]> function, Double[] x);
}
public abstract class MathNet.Numerics.Statistics.Mcmc.HybridMCGeneric`1 : McmcSampler`1<T> {
    private DensityLn`1<T> _energy;
    protected T Current;
    private int _burnInterval;
    private double _stepSize;
    private int _frogLeapSteps;
    private DiffMethod<T> _diff;
    public int BurnInterval { get; public set; }
    public int FrogLeapSteps { get; public set; }
    public double StepSize { get; public set; }
    protected HybridMCGeneric`1(T x0, DensityLn`1<T> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, Random randomSource, DiffMethod<T> diff);
    public int get_BurnInterval();
    public void set_BurnInterval(int value);
    public int get_FrogLeapSteps();
    public void set_FrogLeapSteps(int value);
    public double get_StepSize();
    public void set_StepSize(double value);
    public virtual T Sample();
    protected void Burn(int n);
    protected void Update(Double& e, T& gradient, T mNew, T gNew, double enew, double dh);
    protected abstract virtual T Create();
    protected abstract virtual T Copy(T source);
    protected abstract virtual double DoProduct(T first, T second);
    protected abstract virtual void DoAdd(T& first, double factor, T second);
    protected abstract virtual void DoSubtract(T& first, double factor, T second);
    protected abstract virtual void RandomizeMomentum(T& p);
    protected void HamiltonianEquations(T& gNew, T& mNew, T& p);
    protected double Hamiltonian(T momentum, double e);
    protected int SetNonNegative(int value);
    protected int SetPositive(int value);
    protected double SetPositive(double value);
}
public class MathNet.Numerics.Statistics.Mcmc.LocalProposalSampler`1 : MulticastDelegate {
    public LocalProposalSampler`1(object object, IntPtr method);
    public virtual T Invoke(T init);
    public virtual IAsyncResult BeginInvoke(T init, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public static class MathNet.Numerics.Statistics.Mcmc.MCMCDiagnostics : object {
    public static double ACF(IEnumerable`1<T> series, int lag, Func`2<T, double> f);
    public static double EffectiveSize(IEnumerable`1<T> series, Func`2<T, double> f);
}
public abstract class MathNet.Numerics.Statistics.Mcmc.McmcSampler`1 : object {
    private Random _randomNumberGenerator;
    protected int Accepts;
    protected int Samples;
    public Random RandomSource { get; public set; }
    public double AcceptanceRate { get; }
    public Random get_RandomSource();
    public void set_RandomSource(Random value);
    public abstract virtual T Sample();
    public virtual T[] Sample(int n);
    public double get_AcceptanceRate();
}
public class MathNet.Numerics.Statistics.Mcmc.MetropolisHastingsSampler`1 : McmcSampler`1<T> {
    private DensityLn`1<T> _pdfLnP;
    private TransitionKernelLn`1<T> _krnlQ;
    private LocalProposalSampler`1<T> _proposal;
    private T _current;
    private double _currentDensityLn;
    private int _burnInterval;
    public int BurnInterval { get; public set; }
    public MetropolisHastingsSampler`1(T x0, DensityLn`1<T> pdfLnP, TransitionKernelLn`1<T> krnlQ, LocalProposalSampler`1<T> proposal, int burnInterval);
    public int get_BurnInterval();
    public void set_BurnInterval(int value);
    private void Burn(int n);
    public virtual T Sample();
}
public class MathNet.Numerics.Statistics.Mcmc.MetropolisSampler`1 : McmcSampler`1<T> {
    private DensityLn`1<T> _pdfLnP;
    private LocalProposalSampler`1<T> _proposal;
    private T _current;
    private double _currentDensityLn;
    private int _burnInterval;
    public int BurnInterval { get; public set; }
    public MetropolisSampler`1(T x0, DensityLn`1<T> pdfLnP, LocalProposalSampler`1<T> proposal, int burnInterval);
    public int get_BurnInterval();
    public void set_BurnInterval(int value);
    private void Burn(int n);
    public virtual T Sample();
}
public class MathNet.Numerics.Statistics.Mcmc.RejectionSampler`1 : McmcSampler`1<T> {
    private Density`1<T> _pdfP;
    private Density`1<T> _pdfQ;
    private GlobalProposalSampler`1<T> _proposal;
    public RejectionSampler`1(Density`1<T> pdfP, Density`1<T> pdfQ, GlobalProposalSampler`1<T> proposal);
    public virtual T Sample();
}
public class MathNet.Numerics.Statistics.Mcmc.TransitionKernelLn`1 : MulticastDelegate {
    public TransitionKernelLn`1(object object, IntPtr method);
    public virtual double Invoke(T to, T from);
    public virtual IAsyncResult BeginInvoke(T to, T from, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class MathNet.Numerics.Statistics.Mcmc.UnivariateHybridMC : HybridMCGeneric`1<double> {
    private Normal _distribution;
    private double _sdv;
    public double MomentumStdDev { get; public set; }
    public UnivariateHybridMC(double x0, DensityLn`1<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double pSdv);
    public UnivariateHybridMC(double x0, DensityLn`1<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double pSdv, Random randomSource);
    public UnivariateHybridMC(double x0, DensityLn`1<double> pdfLnP, int frogLeapSteps, double stepSize, int burnInterval, double pSdv, Random randomSource, DiffMethod<double> diff);
    public double get_MomentumStdDev();
    public void set_MomentumStdDev(double value);
    protected virtual double Copy(double source);
    protected virtual double Create();
    protected virtual void DoAdd(Double& first, double factor, double second);
    protected virtual double DoProduct(double first, double second);
    protected virtual void DoSubtract(Double& first, double factor, double second);
    protected virtual void RandomizeMomentum(Double& p);
    private static double Grad(DensityLn`1<double> function, double x);
}
public class MathNet.Numerics.Statistics.Mcmc.UnivariateSliceSampler : McmcSampler`1<double> {
    private DensityLn`1<double> _pdfLnP;
    private double _current;
    private double _currentDensityLn;
    private int _burnInterval;
    private double _scale;
    public int BurnInterval { get; public set; }
    public double Scale { get; public set; }
    public UnivariateSliceSampler(double x0, DensityLn`1<double> pdfLnP, double scale);
    public UnivariateSliceSampler(double x0, DensityLn`1<double> pdfLnP, int burnInterval, double scale);
    public int get_BurnInterval();
    public void set_BurnInterval(int value);
    public double get_Scale();
    public void set_Scale(double value);
    private void Burn(int n);
    public virtual double Sample();
}
public class MathNet.Numerics.Statistics.MovingStatistics : object {
    private Double[] _oldValues;
    private int _windowSize;
    private long _count;
    private long _totalCountOffset;
    private int _lastIndex;
    private int _lastNaNTimeToLive;
    private int _lastPosInfTimeToLive;
    private int _lastNegInfTimeToLive;
    private double _m1;
    private double _m2;
    private double _max;
    private double _min;
    public int WindowSize { get; }
    public long Count { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double PopulationVariance { get; }
    public double StandardDeviation { get; }
    public double PopulationStandardDeviation { get; }
    public MovingStatistics(int windowSize);
    public MovingStatistics(int windowSize, IEnumerable`1<double> values);
    public int get_WindowSize();
    public long get_Count();
    public double get_Minimum();
    public double get_Maximum();
    public double get_Mean();
    public double get_Variance();
    public double get_PopulationVariance();
    public double get_StandardDeviation();
    public double get_PopulationStandardDeviation();
    public void Push(double value);
    public void PushRange(IEnumerable`1<double> values);
    private void DecrementTimeToLive();
    private void Reset(double min, double max);
}
public enum MathNet.Numerics.Statistics.QuantileDefinition : Enum {
    public int value__;
    public static QuantileDefinition R1;
    public static QuantileDefinition SAS3;
    public static QuantileDefinition EmpiricalInvCDF;
    public static QuantileDefinition R2;
    public static QuantileDefinition SAS5;
    public static QuantileDefinition EmpiricalInvCDFAverage;
    public static QuantileDefinition R3;
    public static QuantileDefinition SAS2;
    public static QuantileDefinition Nearest;
    public static QuantileDefinition R4;
    public static QuantileDefinition SAS1;
    public static QuantileDefinition California;
    public static QuantileDefinition R5;
    public static QuantileDefinition Hydrology;
    public static QuantileDefinition Hazen;
    public static QuantileDefinition R6;
    public static QuantileDefinition SAS4;
    public static QuantileDefinition Nist;
    public static QuantileDefinition Weibull;
    public static QuantileDefinition SPSS;
    public static QuantileDefinition R7;
    public static QuantileDefinition Excel;
    public static QuantileDefinition Mode;
    public static QuantileDefinition S;
    public static QuantileDefinition R8;
    public static QuantileDefinition Median;
    public static QuantileDefinition Default;
    public static QuantileDefinition R9;
    public static QuantileDefinition Normal;
}
public enum MathNet.Numerics.Statistics.RankDefinition : Enum {
    public int value__;
    public static RankDefinition Average;
    public static RankDefinition Default;
    public static RankDefinition Min;
    public static RankDefinition Sports;
    public static RankDefinition Max;
    public static RankDefinition First;
    public static RankDefinition EmpiricalCDF;
}
[DataContractAttribute]
public class MathNet.Numerics.Statistics.RunningStatistics : object {
    [DataMemberAttribute]
private long _n;
    [DataMemberAttribute]
private double _min;
    [DataMemberAttribute]
private double _max;
    [DataMemberAttribute]
private double _m1;
    [DataMemberAttribute]
private double _m2;
    [DataMemberAttribute]
private double _m3;
    [DataMemberAttribute]
private double _m4;
    public long Count { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double PopulationVariance { get; }
    public double StandardDeviation { get; }
    public double PopulationStandardDeviation { get; }
    public double Skewness { get; }
    public double PopulationSkewness { get; }
    public double Kurtosis { get; }
    public double PopulationKurtosis { get; }
    public RunningStatistics(IEnumerable`1<double> values);
    public long get_Count();
    public double get_Minimum();
    public double get_Maximum();
    public double get_Mean();
    public double get_Variance();
    public double get_PopulationVariance();
    public double get_StandardDeviation();
    public double get_PopulationStandardDeviation();
    public double get_Skewness();
    public double get_PopulationSkewness();
    public double get_Kurtosis();
    public double get_PopulationKurtosis();
    public void Push(double value);
    public void PushRange(IEnumerable`1<double> values);
    public static RunningStatistics Combine(RunningStatistics a, RunningStatistics b);
    public static RunningStatistics op_Addition(RunningStatistics a, RunningStatistics b);
}
[DataContractAttribute]
public class MathNet.Numerics.Statistics.RunningWeightedStatistics : object {
    [DataMemberAttribute]
private long _n;
    [DataMemberAttribute]
private double _min;
    [DataMemberAttribute]
private double _max;
    [DataMemberAttribute]
private double _m1;
    [DataMemberAttribute]
private double _m2;
    [DataMemberAttribute]
private double _m3;
    [DataMemberAttribute]
private double _m4;
    [DataMemberAttribute]
private double _w1;
    [DataMemberAttribute]
private double _w2;
    [DataMemberAttribute]
private double _w3;
    [DataMemberAttribute]
private double _w4;
    [DataMemberAttribute]
private double _den;
    public long Count { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double PopulationVariance { get; }
    public double StandardDeviation { get; }
    public double PopulationStandardDeviation { get; }
    public double Skewness { get; }
    public double PopulationSkewness { get; }
    public double Kurtosis { get; }
    public double PopulationKurtosis { get; }
    public double TotalWeight { get; }
    public double EffectiveSampleSize { get; }
    public RunningWeightedStatistics(IEnumerable`1<Tuple`2<double, double>> values);
    public long get_Count();
    public double get_Minimum();
    public double get_Maximum();
    public double get_Mean();
    public double get_Variance();
    public double get_PopulationVariance();
    public double get_StandardDeviation();
    public double get_PopulationStandardDeviation();
    public double get_Skewness();
    public double get_PopulationSkewness();
    public double get_Kurtosis();
    public double get_PopulationKurtosis();
    public double get_TotalWeight();
    public double get_EffectiveSampleSize();
    public void Push(double weight, double value);
    public void PushRange(IEnumerable`1<Tuple`2<double, double>> values);
    public void PushRange(IEnumerable`1<double> weights, IEnumerable`1<double> values);
    public static RunningWeightedStatistics Combine(RunningWeightedStatistics a, RunningWeightedStatistics b);
    public static RunningWeightedStatistics op_Addition(RunningWeightedStatistics a, RunningWeightedStatistics b);
}
public static class MathNet.Numerics.Statistics.SortedArrayStatistics : object {
    public static double Minimum(Double[] data);
    public static double Maximum(Double[] data);
    public static double OrderStatistic(Double[] data, int order);
    public static double Median(Double[] data);
    public static double Percentile(Double[] data, int p);
    public static double LowerQuartile(Double[] data);
    public static double UpperQuartile(Double[] data);
    public static double InterquartileRange(Double[] data);
    public static Double[] FiveNumberSummary(Double[] data);
    public static double Quantile(Double[] data, double tau);
    public static double QuantileCustom(Double[] data, double tau, double a, double b, double c, double d);
    public static double QuantileCustom(Double[] data, double tau, QuantileDefinition definition);
    public static double EmpiricalCDF(Double[] data, double x);
    public static double QuantileRank(Double[] data, double x, RankDefinition definition);
    public static Double[] Ranks(Double[] data, RankDefinition definition);
    private static void RanksTies(Double[] ranks, int a, int b, RankDefinition definition);
    public static float Minimum(Single[] data);
    public static float Maximum(Single[] data);
    public static float OrderStatistic(Single[] data, int order);
    public static float Median(Single[] data);
    public static float Percentile(Single[] data, int p);
    public static float LowerQuartile(Single[] data);
    public static float UpperQuartile(Single[] data);
    public static float InterquartileRange(Single[] data);
    public static Single[] FiveNumberSummary(Single[] data);
    public static float Quantile(Single[] data, double tau);
    public static float QuantileCustom(Single[] data, double tau, double a, double b, double c, double d);
    public static float QuantileCustom(Single[] data, double tau, QuantileDefinition definition);
    public static double EmpiricalCDF(Single[] data, float x);
    public static double QuantileRank(Single[] data, float x, RankDefinition definition);
    public static Double[] Ranks(Single[] data, RankDefinition definition);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Statistics.Statistics : object {
    [ExtensionAttribute]
public static double Minimum(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float Minimum(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double Minimum(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double Maximum(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float Maximum(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double Maximum(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double MinimumAbsolute(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float MinimumAbsolute(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double MaximumAbsolute(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float MaximumAbsolute(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Complex MinimumMagnitudePhase(IEnumerable`1<Complex> data);
    [ExtensionAttribute]
public static Complex32 MinimumMagnitudePhase(IEnumerable`1<Complex32> data);
    [ExtensionAttribute]
public static Complex MaximumMagnitudePhase(IEnumerable`1<Complex> data);
    [ExtensionAttribute]
public static Complex32 MaximumMagnitudePhase(IEnumerable`1<Complex32> data);
    [ExtensionAttribute]
public static double Mean(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double Mean(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double Mean(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double GeometricMean(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double GeometricMean(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double HarmonicMean(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double HarmonicMean(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double Variance(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static double Variance(IEnumerable`1<float> samples);
    [ExtensionAttribute]
public static double Variance(IEnumerable`1<Nullable`1<double>> samples);
    [ExtensionAttribute]
public static double PopulationVariance(IEnumerable`1<double> population);
    [ExtensionAttribute]
public static double PopulationVariance(IEnumerable`1<float> population);
    [ExtensionAttribute]
public static double PopulationVariance(IEnumerable`1<Nullable`1<double>> population);
    [ExtensionAttribute]
public static double StandardDeviation(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static double StandardDeviation(IEnumerable`1<float> samples);
    [ExtensionAttribute]
public static double StandardDeviation(IEnumerable`1<Nullable`1<double>> samples);
    [ExtensionAttribute]
public static double PopulationStandardDeviation(IEnumerable`1<double> population);
    [ExtensionAttribute]
public static double PopulationStandardDeviation(IEnumerable`1<float> population);
    [ExtensionAttribute]
public static double PopulationStandardDeviation(IEnumerable`1<Nullable`1<double>> population);
    [ExtensionAttribute]
public static double Skewness(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static double Skewness(IEnumerable`1<Nullable`1<double>> samples);
    [ExtensionAttribute]
public static double PopulationSkewness(IEnumerable`1<double> population);
    [ExtensionAttribute]
public static double PopulationSkewness(IEnumerable`1<Nullable`1<double>> population);
    [ExtensionAttribute]
public static double Kurtosis(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static double Kurtosis(IEnumerable`1<Nullable`1<double>> samples);
    [ExtensionAttribute]
public static double PopulationKurtosis(IEnumerable`1<double> population);
    [ExtensionAttribute]
public static double PopulationKurtosis(IEnumerable`1<Nullable`1<double>> population);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> MeanVariance(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> MeanVariance(IEnumerable`1<float> samples);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> MeanStandardDeviation(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> MeanStandardDeviation(IEnumerable`1<float> samples);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> SkewnessKurtosis(IEnumerable`1<double> samples);
    [ExtensionAttribute]
public static ValueTuple`2<double, double> PopulationSkewnessKurtosis(IEnumerable`1<double> population);
    [ExtensionAttribute]
public static double Covariance(IEnumerable`1<double> samples1, IEnumerable`1<double> samples2);
    [ExtensionAttribute]
public static double Covariance(IEnumerable`1<float> samples1, IEnumerable`1<float> samples2);
    [ExtensionAttribute]
public static double Covariance(IEnumerable`1<Nullable`1<double>> samples1, IEnumerable`1<Nullable`1<double>> samples2);
    [ExtensionAttribute]
public static double PopulationCovariance(IEnumerable`1<double> population1, IEnumerable`1<double> population2);
    [ExtensionAttribute]
public static double PopulationCovariance(IEnumerable`1<float> population1, IEnumerable`1<float> population2);
    [ExtensionAttribute]
public static double PopulationCovariance(IEnumerable`1<Nullable`1<double>> population1, IEnumerable`1<Nullable`1<double>> population2);
    [ExtensionAttribute]
public static double RootMeanSquare(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static double RootMeanSquare(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double RootMeanSquare(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double Median(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float Median(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double Median(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double Quantile(IEnumerable`1<double> data, double tau);
    [ExtensionAttribute]
public static float Quantile(IEnumerable`1<float> data, double tau);
    [ExtensionAttribute]
public static double Quantile(IEnumerable`1<Nullable`1<double>> data, double tau);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileFunc(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static Func`2<float, float> QuantileFunc(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileFunc(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double QuantileCustom(IEnumerable`1<double> data, double tau, QuantileDefinition definition);
    [ExtensionAttribute]
public static float QuantileCustom(IEnumerable`1<float> data, double tau, QuantileDefinition definition);
    [ExtensionAttribute]
public static double QuantileCustom(IEnumerable`1<Nullable`1<double>> data, double tau, QuantileDefinition definition);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileCustomFunc(IEnumerable`1<double> data, QuantileDefinition definition);
    [ExtensionAttribute]
public static Func`2<float, float> QuantileCustomFunc(IEnumerable`1<float> data, QuantileDefinition definition);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileCustomFunc(IEnumerable`1<Nullable`1<double>> data, QuantileDefinition definition);
    [ExtensionAttribute]
public static double Percentile(IEnumerable`1<double> data, int p);
    [ExtensionAttribute]
public static float Percentile(IEnumerable`1<float> data, int p);
    [ExtensionAttribute]
public static double Percentile(IEnumerable`1<Nullable`1<double>> data, int p);
    [ExtensionAttribute]
public static Func`2<int, double> PercentileFunc(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static Func`2<int, float> PercentileFunc(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Func`2<int, double> PercentileFunc(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double LowerQuartile(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float LowerQuartile(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double LowerQuartile(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double UpperQuartile(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float UpperQuartile(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double UpperQuartile(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double InterquartileRange(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static float InterquartileRange(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static double InterquartileRange(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static Double[] FiveNumberSummary(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static Single[] FiveNumberSummary(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Double[] FiveNumberSummary(IEnumerable`1<Nullable`1<double>> data);
    public static double OrderStatistic(IEnumerable`1<double> data, int order);
    public static float OrderStatistic(IEnumerable`1<float> data, int order);
    public static Func`2<int, double> OrderStatisticFunc(IEnumerable`1<double> data);
    public static Func`2<int, float> OrderStatisticFunc(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Double[] Ranks(IEnumerable`1<double> data, RankDefinition definition);
    [ExtensionAttribute]
public static Single[] Ranks(IEnumerable`1<float> data, RankDefinition definition);
    [ExtensionAttribute]
public static Double[] Ranks(IEnumerable`1<Nullable`1<double>> data, RankDefinition definition);
    [ExtensionAttribute]
public static double QuantileRank(IEnumerable`1<double> data, double x, RankDefinition definition);
    [ExtensionAttribute]
public static double QuantileRank(IEnumerable`1<float> data, float x, RankDefinition definition);
    [ExtensionAttribute]
public static double QuantileRank(IEnumerable`1<Nullable`1<double>> data, double x, RankDefinition definition);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileRankFunc(IEnumerable`1<double> data, RankDefinition definition);
    [ExtensionAttribute]
public static Func`2<float, double> QuantileRankFunc(IEnumerable`1<float> data, RankDefinition definition);
    [ExtensionAttribute]
public static Func`2<double, double> QuantileRankFunc(IEnumerable`1<Nullable`1<double>> data, RankDefinition definition);
    [ExtensionAttribute]
public static double EmpiricalCDF(IEnumerable`1<double> data, double x);
    [ExtensionAttribute]
public static double EmpiricalCDF(IEnumerable`1<float> data, float x);
    [ExtensionAttribute]
public static double EmpiricalCDF(IEnumerable`1<Nullable`1<double>> data, double x);
    [ExtensionAttribute]
public static Func`2<double, double> EmpiricalCDFFunc(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static Func`2<float, double> EmpiricalCDFFunc(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Func`2<double, double> EmpiricalCDFFunc(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static double EmpiricalInvCDF(IEnumerable`1<double> data, double tau);
    [ExtensionAttribute]
public static float EmpiricalInvCDF(IEnumerable`1<float> data, double tau);
    [ExtensionAttribute]
public static double EmpiricalInvCDF(IEnumerable`1<Nullable`1<double>> data, double tau);
    [ExtensionAttribute]
public static Func`2<double, double> EmpiricalInvCDFFunc(IEnumerable`1<double> data);
    [ExtensionAttribute]
public static Func`2<double, float> EmpiricalInvCDFFunc(IEnumerable`1<float> data);
    [ExtensionAttribute]
public static Func`2<double, double> EmpiricalInvCDFFunc(IEnumerable`1<Nullable`1<double>> data);
    public static double Entropy(IEnumerable`1<double> data);
    public static double Entropy(IEnumerable`1<Nullable`1<double>> data);
    [ExtensionAttribute]
public static IEnumerable`1<double> MovingAverage(IEnumerable`1<double> samples, int windowSize);
}
public static class MathNet.Numerics.Statistics.StreamingStatistics : object {
    public static double Minimum(IEnumerable`1<double> stream);
    public static float Minimum(IEnumerable`1<float> stream);
    public static double Maximum(IEnumerable`1<double> stream);
    public static float Maximum(IEnumerable`1<float> stream);
    public static double MinimumAbsolute(IEnumerable`1<double> stream);
    public static float MinimumAbsolute(IEnumerable`1<float> stream);
    public static double MaximumAbsolute(IEnumerable`1<double> stream);
    public static float MaximumAbsolute(IEnumerable`1<float> stream);
    public static Complex MinimumMagnitudePhase(IEnumerable`1<Complex> stream);
    public static Complex32 MinimumMagnitudePhase(IEnumerable`1<Complex32> stream);
    public static Complex MaximumMagnitudePhase(IEnumerable`1<Complex> stream);
    public static Complex32 MaximumMagnitudePhase(IEnumerable`1<Complex32> stream);
    public static double Mean(IEnumerable`1<double> stream);
    public static double Mean(IEnumerable`1<float> stream);
    public static double GeometricMean(IEnumerable`1<double> stream);
    public static double GeometricMean(IEnumerable`1<float> stream);
    public static double HarmonicMean(IEnumerable`1<double> stream);
    public static double HarmonicMean(IEnumerable`1<float> stream);
    public static double Variance(IEnumerable`1<double> samples);
    public static double Variance(IEnumerable`1<float> samples);
    public static double PopulationVariance(IEnumerable`1<double> population);
    public static double PopulationVariance(IEnumerable`1<float> population);
    public static double StandardDeviation(IEnumerable`1<double> samples);
    public static double StandardDeviation(IEnumerable`1<float> samples);
    public static double PopulationStandardDeviation(IEnumerable`1<double> population);
    public static double PopulationStandardDeviation(IEnumerable`1<float> population);
    public static ValueTuple`2<double, double> MeanVariance(IEnumerable`1<double> samples);
    public static ValueTuple`2<double, double> MeanVariance(IEnumerable`1<float> samples);
    public static ValueTuple`2<double, double> MeanStandardDeviation(IEnumerable`1<double> samples);
    public static ValueTuple`2<double, double> MeanStandardDeviation(IEnumerable`1<float> samples);
    public static double Covariance(IEnumerable`1<double> samples1, IEnumerable`1<double> samples2);
    public static double Covariance(IEnumerable`1<float> samples1, IEnumerable`1<float> samples2);
    public static double PopulationCovariance(IEnumerable`1<double> population1, IEnumerable`1<double> population2);
    public static double PopulationCovariance(IEnumerable`1<float> population1, IEnumerable`1<float> population2);
    public static double RootMeanSquare(IEnumerable`1<double> stream);
    public static double RootMeanSquare(IEnumerable`1<float> stream);
    public static double Entropy(IEnumerable`1<double> stream);
}
[DataContractAttribute]
public class MathNet.Numerics.Statistics.WeightedDescriptiveStatistics : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Skewness>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Kurtosis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TotalWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EffectiveSampleSize>k__BackingField;
    [DataMemberAttribute]
public long Count { get; private set; }
    [DataMemberAttribute]
public double Mean { get; private set; }
    [DataMemberAttribute]
public double Variance { get; private set; }
    [DataMemberAttribute]
public double StandardDeviation { get; private set; }
    [DataMemberAttribute]
public double Skewness { get; private set; }
    [DataMemberAttribute]
public double Kurtosis { get; private set; }
    [DataMemberAttribute]
public double Maximum { get; private set; }
    [DataMemberAttribute]
public double Minimum { get; private set; }
    [DataMemberAttribute]
public double TotalWeight { get; private set; }
    [DataMemberAttribute]
public double EffectiveSampleSize { get; private set; }
    public WeightedDescriptiveStatistics(IEnumerable`1<Tuple`2<double, double>> data, bool increasedAccuracy);
    public WeightedDescriptiveStatistics(IEnumerable`1<ValueTuple`2<double, double>> data, bool increasedAccuracy);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
private void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public double get_Skewness();
    [CompilerGeneratedAttribute]
private void set_Skewness(double value);
    [CompilerGeneratedAttribute]
public double get_Kurtosis();
    [CompilerGeneratedAttribute]
private void set_Kurtosis(double value);
    [CompilerGeneratedAttribute]
public double get_Maximum();
    [CompilerGeneratedAttribute]
private void set_Maximum(double value);
    [CompilerGeneratedAttribute]
public double get_Minimum();
    [CompilerGeneratedAttribute]
private void set_Minimum(double value);
    [CompilerGeneratedAttribute]
public double get_TotalWeight();
    [CompilerGeneratedAttribute]
private void set_TotalWeight(double value);
    [CompilerGeneratedAttribute]
public double get_EffectiveSampleSize();
    [CompilerGeneratedAttribute]
private void set_EffectiveSampleSize(double value);
    private void Compute(IEnumerable`1<ValueTuple`2<double, double>> data);
    private void ComputeDecimal(IEnumerable`1<ValueTuple`2<double, double>> data);
    private void SetStatisticsWeighted(double mean, double variance, double skewness, double kurtosis, double minimum, double maximum, long n, double w1, double den, double w2, double w3, double w4);
}
public static class MathNet.Numerics.TestFunctions : object {
    public static double Rosenbrock(double x, double y);
    public static double Rosenbrock(Double[] x);
    public static double Himmelblau(double x, double y);
    public static double Rastrigin(Double[] x);
    public static double DropWave(double x, double y);
    public static double Ackley(Double[] x);
    public static double Bohachevsky1(double x, double y);
    public static double Matyas(double x, double y);
    public static double SixHumpCamel(double x, double y);
}
internal static class MathNet.Numerics.Threading.CommonParallel : object {
    private static ParallelOptions CreateParallelOptions();
    public static void For(int fromInclusive, int toExclusive, Action`2<int, int> body);
    public static void For(int fromInclusive, int toExclusive, int rangeSize, Action`2<int, int> body);
    public static void Invoke(Action[] actions);
    public static T Aggregate(int fromInclusive, int toExclusive, Func`2<int, T> select, Func`2<T[], T> reduce);
    public static TOut Aggregate(T[] array, Func`3<int, T, TOut> select, Func`2<TOut[], TOut> reduce);
    public static T Aggregate(int fromInclusive, int toExclusive, Func`2<int, T> select, Func`3<T, T, T> reducePair, T reduceDefault);
    public static TOut Aggregate(T[] array, Func`3<int, T, TOut> select, Func`3<TOut, TOut, TOut> reducePair, TOut reduceDefault);
}
[ExtensionAttribute]
public static class MathNet.Numerics.Trig : object {
    private static double DegreeToGradConstant;
    public static double DegreeToGrad(double degree);
    public static double DegreeToRadian(double degree);
    public static double GradToDegree(double grad);
    public static double GradToRadian(double grad);
    public static double RadianToDegree(double radian);
    public static double RadianToGrad(double radian);
    public static double Sinc(double x);
    public static double Sin(double radian);
    [ExtensionAttribute]
public static Complex Sin(Complex value);
    public static double Cos(double radian);
    [ExtensionAttribute]
public static Complex Cos(Complex value);
    public static double Tan(double radian);
    [ExtensionAttribute]
public static Complex Tan(Complex value);
    public static double Cot(double radian);
    [ExtensionAttribute]
public static Complex Cot(Complex value);
    public static double Sec(double radian);
    [ExtensionAttribute]
public static Complex Sec(Complex value);
    public static double Csc(double radian);
    [ExtensionAttribute]
public static Complex Csc(Complex value);
    public static double Asin(double opposite);
    [ExtensionAttribute]
public static Complex Asin(Complex value);
    public static double Acos(double adjacent);
    [ExtensionAttribute]
public static Complex Acos(Complex value);
    public static double Atan(double opposite);
    [ExtensionAttribute]
public static Complex Atan(Complex value);
    public static double Acot(double adjacent);
    [ExtensionAttribute]
public static Complex Acot(Complex value);
    public static double Asec(double hypotenuse);
    [ExtensionAttribute]
public static Complex Asec(Complex value);
    public static double Acsc(double hypotenuse);
    [ExtensionAttribute]
public static Complex Acsc(Complex value);
    public static double Sinh(double angle);
    [ExtensionAttribute]
public static Complex Sinh(Complex value);
    public static double Cosh(double angle);
    [ExtensionAttribute]
public static Complex Cosh(Complex value);
    public static double Tanh(double angle);
    [ExtensionAttribute]
public static Complex Tanh(Complex value);
    public static double Coth(double angle);
    [ExtensionAttribute]
public static Complex Coth(Complex value);
    public static double Sech(double angle);
    [ExtensionAttribute]
public static Complex Sech(Complex value);
    public static double Csch(double angle);
    [ExtensionAttribute]
public static Complex Csch(Complex value);
    public static double Asinh(double value);
    [ExtensionAttribute]
public static Complex Asinh(Complex value);
    public static double Acosh(double value);
    [ExtensionAttribute]
public static Complex Acosh(Complex value);
    public static double Atanh(double value);
    [ExtensionAttribute]
public static Complex Atanh(Complex value);
    public static double Acoth(double value);
    [ExtensionAttribute]
public static Complex Acoth(Complex value);
    public static double Asech(double value);
    [ExtensionAttribute]
public static Complex Asech(Complex value);
    public static double Acsch(double value);
    [ExtensionAttribute]
public static Complex Acsch(Complex value);
}
public static class MathNet.Numerics.Window : object {
    public static Double[] Hamming(int width);
    public static Double[] HammingPeriodic(int width);
    public static Double[] Hann(int width);
    public static Double[] HannPeriodic(int width);
    public static Double[] Cosine(int width);
    public static Double[] CosinePeriodic(int width);
    public static Double[] Lanczos(int width);
    public static Double[] LanczosPeriodic(int width);
    public static Double[] Gauss(int width, double sigma);
    public static Double[] Blackman(int width);
    public static Double[] BlackmanHarris(int width);
    public static Double[] BlackmanNuttall(int width);
    public static Double[] Bartlett(int width);
    public static Double[] BartlettHann(int width);
    public static Double[] Nuttall(int width);
    public static Double[] FlatTop(int width);
    public static Double[] Dirichlet(int width);
    public static Double[] Triangular(int width);
    public static Double[] Tukey(int width, double r);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
