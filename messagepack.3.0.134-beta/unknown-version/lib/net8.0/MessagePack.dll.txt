[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.BufferWriter : ValueType {
    private IBufferWriter`1<byte> _output;
    private Span`1<byte> _span;
    private ArraySegment`1<byte> _segment;
    private int _buffered;
    private long _bytesCommitted;
    private SequencePool _sequencePool;
    private Rental _rental;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    internal IBufferWriter`1<byte> UnderlyingWriter { get; }
    internal Rental SequenceRental { get; }
    public BufferWriter(IBufferWriter`1<byte> output);
    internal BufferWriter(SequencePool sequencePool, Byte[] array);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    internal IBufferWriter`1<byte> get_UnderlyingWriter();
    internal Rental get_SequenceRental();
    public Span`1<byte> GetSpan(int sizeHint);
    public Byte& GetPointer(int sizeHint);
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    internal bool TryGetUncommittedSpan(ReadOnlySpan`1& span);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
    private void MigrateToSequence();
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("NEVERDEFINED")]
public class MessagePack.CompositeResolverAttribute : Attribute {
    [NullableContextAttribute("1")]
public CompositeResolverAttribute(Type[] resolvers);
}
public class MessagePack.ExtensionHeader : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public UInt32 Length { get; private set; }
    public ExtensionHeader(sbyte typeCode, UInt32 length);
    public ExtensionHeader(sbyte typeCode, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(UInt32 value);
    public sealed virtual bool Equals(ExtensionHeader other);
}
public class MessagePack.ExtensionResult : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <Data>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public ReadOnlySequence`1<byte> Data { get; private set; }
    public ExtensionHeader Header { get; }
    public ExtensionResult(sbyte typeCode, Memory`1<byte> data);
    public ExtensionResult(sbyte typeCode, ReadOnlySequence`1<byte> data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ReadOnlySequence`1<byte> value);
    public ExtensionHeader get_Header();
}
public class MessagePack.FormatterNotRegisteredException : MessagePackSerializationException {
    [NullableContextAttribute("2")]
public FormatterNotRegisteredException(string message);
    [NullableContextAttribute("1")]
[ObsoleteAttribute]
protected FormatterNotRegisteredException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class MessagePack.FormatterResolverExtensions : object {
    private static ThreadsafeTypeKeyHashTable`1<Func`2<IFormatterResolver, IMessagePackFormatter>> FormatterGetters;
    private static MethodInfo GetFormatterRuntimeMethod;
    private static FormatterResolverExtensions();
    [ExtensionAttribute]
public static IMessagePackFormatter`1<T> GetFormatterWithVerify(IFormatterResolver resolver);
    [DoesNotReturnAttribute]
private static void Throw(TypeInitializationException ex);
    [DoesNotReturnAttribute]
private static void Throw(Type t, IFormatterResolver resolver);
    [ExtensionAttribute]
public static object GetFormatterDynamic(IFormatterResolver resolver, Type type);
    [ExtensionAttribute]
internal static object GetFormatterDynamicWithVerify(IFormatterResolver resolver, Type type);
}
public class MessagePack.Formatters.ArrayFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T[] value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ArraySegmentFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ArraySegment`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ArraySegment`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BigIntegerFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<BigInteger> Instance;
    private static BigIntegerFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, BigInteger value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual BigInteger Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BitArrayFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<BitArray> Instance;
    private static BitArrayFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, BitArray value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual BitArray Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.BooleanArrayFormatter : object {
    public static BooleanArrayFormatter Instance;
    private static BooleanArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Boolean[] value, MessagePackSerializerOptions options);
    public sealed virtual Boolean[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BooleanFormatter : object {
    [NullableAttribute("1")]
public static BooleanFormatter Instance;
    private static BooleanFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, bool value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual bool Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.BooleanListFormatter : object {
    public static BooleanListFormatter Instance;
    private static BooleanListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<bool> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<bool> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ByteArrayFormatter : object {
    public static ByteArrayFormatter Instance;
    private static ByteArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Byte[] value, MessagePackSerializerOptions options);
    public sealed virtual Byte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteArraySegmentFormatter : object {
    [NullableAttribute("1")]
public static ByteArraySegmentFormatter Instance;
    private static ByteArraySegmentFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ArraySegment`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual ArraySegment`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteFormatter : object {
    [NullableAttribute("1")]
public static ByteFormatter Instance;
    private static ByteFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, byte value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual byte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ByteListFormatter : object {
    public static ByteListFormatter Instance;
    private static ByteListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteMemoryFormatter : object {
    [NullableAttribute("1")]
public static ByteMemoryFormatter Instance;
    private static ByteMemoryFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Memory`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual Memory`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteReadOnlyMemoryFormatter : object {
    [NullableAttribute("1")]
public static ByteReadOnlyMemoryFormatter Instance;
    private static ByteReadOnlyMemoryFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ReadOnlyMemory`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual ReadOnlyMemory`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteReadOnlySequenceFormatter : object {
    [NullableAttribute("1")]
public static ByteReadOnlySequenceFormatter Instance;
    private static ByteReadOnlySequenceFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ReadOnlySequence`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual ReadOnlySequence`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.CharArrayFormatter : object {
    public static CharArrayFormatter Instance;
    private static CharArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Char[] value, MessagePackSerializerOptions options);
    public sealed virtual Char[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.CharFormatter : object {
    [NullableAttribute("1")]
public static CharFormatter Instance;
    private static CharFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, char value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual char Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.CharListFormatter : object {
    public static CharListFormatter Instance;
    private static CharListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<char> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<char> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class MessagePack.Formatters.CollectionFormatterBase`2 : CollectionFormatterBase`3<TElement, TCollection, TCollection> {
    protected sealed virtual TCollection Complete(TCollection intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class MessagePack.Formatters.CollectionFormatterBase`3 : CollectionFormatterBase`4<TElement, TIntermediate, IEnumerator`1<TElement>, TCollection> {
    protected virtual IEnumerator`1<TElement> GetSourceEnumerator(TCollection source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MessagePack.Formatters.CollectionFormatterBase`4 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, TCollection value, MessagePackSerializerOptions options);
    public sealed virtual TCollection Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected virtual Nullable`1<int> GetCount(TCollection sequence);
    protected abstract virtual TEnumerator GetSourceEnumerator(TCollection source);
    protected abstract virtual TIntermediate Create(int count, MessagePackSerializerOptions options);
    protected abstract virtual void Add(TIntermediate collection, int index, TElement value, MessagePackSerializerOptions options);
    protected abstract virtual TCollection Complete(TIntermediate intermediateCollection);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class MessagePack.Formatters.CollectionHelpers`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<int, TEqualityComparer, TCollection> collectionCreator;
    private static CollectionHelpers`2();
    [NullableContextAttribute("1")]
internal static TCollection CreateHashCollection(int count, TEqualityComparer equalityComparer);
}
public class MessagePack.Formatters.ComplexFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Complex> Instance;
    private static ComplexFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Complex value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Complex Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ConcurrentBagFormatter`1 : CollectionFormatterBase`2<T, ConcurrentBag`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentBag`1<T> sequence);
    protected virtual void Add(ConcurrentBag`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ConcurrentBag`1<T> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ConcurrentDictionaryFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, ConcurrentDictionary`2<TKey, TValue>> {
    protected virtual void Add(ConcurrentDictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ConcurrentDictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ConcurrentQueueFormatter`1 : CollectionFormatterBase`2<T, ConcurrentQueue`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentQueue`1<T> sequence);
    protected virtual void Add(ConcurrentQueue`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ConcurrentQueue`1<T> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ConcurrentStackFormatter`1 : CollectionFormatterBase`3<T, T[], ConcurrentStack`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentStack`1<T> sequence);
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual ConcurrentStack`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.DateOnlyFormatter : object {
    [NullableAttribute("1")]
public static DateOnlyFormatter Instance;
    private static DateOnlyFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, DateOnly value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual DateOnly Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.DateTimeArrayFormatter : object {
    public static DateTimeArrayFormatter Instance;
    private static DateTimeArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime[] value, MessagePackSerializerOptions options);
    public sealed virtual DateTime[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DateTimeFormatter : object {
    [NullableAttribute("1")]
public static DateTimeFormatter Instance;
    private static DateTimeFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, DateTime value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual DateTime Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DateTimeOffsetFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<DateTimeOffset> Instance;
    private static DateTimeOffsetFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, DateTimeOffset value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual DateTimeOffset Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DecimalFormatter : object {
    [NullableAttribute("1")]
public static DecimalFormatter Instance;
    private static DecimalFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, decimal value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual decimal Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.DictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, Dictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, Dictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual Dictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(Dictionary`2<TKey, TValue> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class MessagePack.Formatters.DictionaryFormatterBase`3 : DictionaryFormatterBase`4<TKey, TValue, TDictionary, TDictionary> {
    protected virtual TDictionary Complete(TDictionary intermediateCollection);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class MessagePack.Formatters.DictionaryFormatterBase`4 : DictionaryFormatterBase`5<TKey, TValue, TIntermediate, IEnumerator`1<KeyValuePair`2<TKey, TValue>>, TDictionary> {
    [NullableContextAttribute("1")]
protected virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetSourceEnumerator(TDictionary source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class MessagePack.Formatters.DictionaryFormatterBase`5 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, TDictionary value, MessagePackSerializerOptions options);
    public sealed virtual TDictionary Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected abstract virtual TEnumerator GetSourceEnumerator(TDictionary source);
    protected abstract virtual TIntermediate Create(int count, MessagePackSerializerOptions options);
    protected abstract virtual void Add(TIntermediate collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected abstract virtual TDictionary Complete(TIntermediate intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.DoubleArrayFormatter : object {
    public static DoubleArrayFormatter Instance;
    private static DoubleArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Double[] value, MessagePackSerializerOptions options);
    public sealed virtual Double[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DoubleFormatter : object {
    [NullableAttribute("1")]
public static DoubleFormatter Instance;
    private static DoubleFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, double value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual double Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.DoubleListFormatter : object {
    public static DoubleListFormatter Instance;
    private static DoubleListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<double> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<double> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DynamicObjectTypeFallbackFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<object> Instance;
    [NullableAttribute("1")]
private static ThreadsafeTypeKeyHashTable`1<SerializeMethod> SerializerDelegates;
    private static DynamicObjectTypeFallbackFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.EnumAsStringFormatter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, T> nameValueMapping;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<T, string> valueNameMapping;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> clrToSerializationName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> serializationToClrName;
    private bool isFlags;
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
private string GetClrNames(string serializedNames);
    [NullableContextAttribute("1")]
private string GetSerializedNames(string clrNames);
    [NullableContextAttribute("1")]
private static string Translate(string items, IReadOnlyDictionary`2<string, string> mapping);
}
public class MessagePack.Formatters.ExpandoObjectFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<ExpandoObject> Instance;
    private static ExpandoObjectFormatter();
    [NullableContextAttribute("1")]
public sealed virtual ExpandoObject Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ExpandoObject value, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceByteBlockFormatter : object {
    [NullableAttribute("1")]
public static ForceByteBlockFormatter Instance;
    private static ForceByteBlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, byte value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual byte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceInt16BlockArrayFormatter : object {
    public static ForceInt16BlockArrayFormatter Instance;
    private static ForceInt16BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int16[] value, MessagePackSerializerOptions options);
    public sealed virtual Int16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt16BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceInt16BlockFormatter Instance;
    private static ForceInt16BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, short value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual short Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceInt32BlockArrayFormatter : object {
    public static ForceInt32BlockArrayFormatter Instance;
    private static ForceInt32BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int32[] value, MessagePackSerializerOptions options);
    public sealed virtual Int32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt32BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceInt32BlockFormatter Instance;
    private static ForceInt32BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, int value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual int Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceInt64BlockArrayFormatter : object {
    public static ForceInt64BlockArrayFormatter Instance;
    private static ForceInt64BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int64[] value, MessagePackSerializerOptions options);
    public sealed virtual Int64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt64BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceInt64BlockFormatter Instance;
    private static ForceInt64BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, long value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual long Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceSByteBlockArrayFormatter : object {
    public static ForceSByteBlockArrayFormatter Instance;
    private static ForceSByteBlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, SByte[] value, MessagePackSerializerOptions options);
    public sealed virtual SByte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceSByteBlockFormatter : object {
    [NullableAttribute("1")]
public static ForceSByteBlockFormatter Instance;
    private static ForceSByteBlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, sbyte value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual sbyte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceTypelessFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceUInt16BlockArrayFormatter : object {
    public static ForceUInt16BlockArrayFormatter Instance;
    private static ForceUInt16BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt16[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt16BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceUInt16BlockFormatter Instance;
    private static ForceUInt16BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ushort value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ushort Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceUInt32BlockArrayFormatter : object {
    public static ForceUInt32BlockArrayFormatter Instance;
    private static ForceUInt32BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt32BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceUInt32BlockFormatter Instance;
    private static ForceUInt32BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, UInt32 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual UInt32 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ForceUInt64BlockArrayFormatter : object {
    public static ForceUInt64BlockArrayFormatter Instance;
    private static ForceUInt64BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt64[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt64BlockFormatter : object {
    [NullableAttribute("1")]
public static ForceUInt64BlockFormatter Instance;
    private static ForceUInt64BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ulong value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ulong Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.FourDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...,0...,0...] value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T[0...,0...,0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.GenericCollectionFormatter`2 : CollectionFormatterBase`2<TElement, TCollection> {
    protected virtual TCollection Create(int count, MessagePackSerializerOptions options);
    protected virtual void Add(TCollection collection, int index, TElement value, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.GenericDictionaryFormatter`3 : DictionaryFormatterBase`3<TKey, TValue, TDictionary> {
    protected virtual void Add(TDictionary collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual TDictionary Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.GenericEnumerableFormatter`2 : CollectionFormatterBase`3<TElement, TElement[], TCollection> {
    protected virtual TElement[] Create(int count, MessagePackSerializerOptions options);
    protected virtual void Add(TElement[] collection, int index, TElement value, MessagePackSerializerOptions options);
    protected virtual TCollection Complete(TElement[] intermediateCollection);
}
public class MessagePack.Formatters.GenericEnumFormatter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumSerialize<T> serializer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumDeserialize<T> deserializer;
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.GenericReadOnlyDictionaryFormatter`3 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, TDictionary> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual TDictionary Complete(Dictionary`2<TKey, TValue> intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Formatters.Grouping`2 : object {
    private TKey key;
    private IEnumerable`1<TElement> elements;
    public TKey Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    public sealed virtual TKey get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MessagePack.Formatters.GuidFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Guid> Instance;
    private static GuidFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Guid value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Guid Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.HalfFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Half> Instance;
    private static HalfFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Half value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Half Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.HashSetFormatter`1 : CollectionFormatterBase`4<T, HashSet`1<T>, Enumerator<T>, HashSet`1<T>> {
    protected virtual Nullable`1<int> GetCount(HashSet`1<T> sequence);
    protected virtual void Add(HashSet`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual HashSet`1<T> Complete(HashSet`1<T> intermediateCollection);
    protected virtual HashSet`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(HashSet`1<T> source);
}
public class MessagePack.Formatters.IgnoreFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[EditorBrowsableAttribute("1")]
public interface MessagePack.Formatters.IMessagePackFormatter {
}
[NullableContextAttribute("1")]
public interface MessagePack.Formatters.IMessagePackFormatter`1 {
    public abstract virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public abstract virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int16ArrayFormatter : object {
    public static Int16ArrayFormatter Instance;
    private static Int16ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int16[] value, MessagePackSerializerOptions options);
    public sealed virtual Int16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int16Formatter : object {
    [NullableAttribute("1")]
public static Int16Formatter Instance;
    private static Int16Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, short value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual short Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int16ListFormatter : object {
    public static Int16ListFormatter Instance;
    private static Int16ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<short> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<short> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int32ArrayFormatter : object {
    public static Int32ArrayFormatter Instance;
    private static Int32ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int32[] value, MessagePackSerializerOptions options);
    public sealed virtual Int32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int32Formatter : object {
    [NullableAttribute("1")]
public static Int32Formatter Instance;
    private static Int32Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, int value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual int Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int32ListFormatter : object {
    public static Int32ListFormatter Instance;
    private static Int32ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<int> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<int> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int64ArrayFormatter : object {
    public static Int64ArrayFormatter Instance;
    private static Int64ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int64[] value, MessagePackSerializerOptions options);
    public sealed virtual Int64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int64Formatter : object {
    [NullableAttribute("1")]
public static Int64Formatter Instance;
    private static Int64Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, long value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual long Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.Int64ListFormatter : object {
    public static Int64ListFormatter Instance;
    private static Int64ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<long> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<long> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("Use InterfaceCollectionFormatter2 instead.")]
public class MessagePack.Formatters.InterfaceCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], ICollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual ICollection`1<T> Complete(T[] intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceCollectionFormatter2`1 : CollectionFormatterBase`3<T, List`1<T>, ICollection`1<T>> {
    protected virtual void Add(List`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual List`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual ICollection`1<T> Complete(List`1<T> intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual IDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceEnumerableFormatter`1 : CollectionFormatterBase`3<T, T[], IEnumerable`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IEnumerable`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceGroupingFormatter`2 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, IGrouping`2<TKey, TElement> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual IGrouping`2<TKey, TElement> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("Use InterfaceListFormatter2 instead.")]
public class MessagePack.Formatters.InterfaceListFormatter`1 : CollectionFormatterBase`3<T, T[], IList`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IList`1<T> Complete(T[] intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceListFormatter2`1 : CollectionFormatterBase`3<T, List`1<T>, IList`1<T>> {
    protected virtual void Add(List`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual List`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual IList`1<T> Complete(List`1<T> intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceLookupFormatter`2 : CollectionFormatterBase`3<IGrouping`2<TKey, TElement>, Dictionary`2<TKey, IGrouping`2<TKey, TElement>>, ILookup`2<TKey, TElement>> {
    protected virtual void Add(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> collection, int index, IGrouping`2<TKey, TElement> value, MessagePackSerializerOptions options);
    protected virtual ILookup`2<TKey, TElement> Complete(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> intermediateCollection);
    protected virtual Dictionary`2<TKey, IGrouping`2<TKey, TElement>> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], IReadOnlyCollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IReadOnlyCollection`1<T> Complete(T[] intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual IReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceReadOnlyListFormatter`1 : CollectionFormatterBase`3<T, T[], IReadOnlyList`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IReadOnlyList`1<T> Complete(T[] intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceReadOnlySetFormatter`1 : CollectionFormatterBase`3<T, HashSet`1<T>, IReadOnlySet`1<T>> {
    protected virtual void Add(HashSet`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual IReadOnlySet`1<T> Complete(HashSet`1<T> intermediateCollection);
    protected virtual HashSet`1<T> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.InterfaceSetFormatter`1 : CollectionFormatterBase`3<T, HashSet`1<T>, ISet`1<T>> {
    protected virtual void Add(HashSet`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ISet`1<T> Complete(HashSet`1<T> intermediateCollection);
    protected virtual HashSet`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.KeyValuePairFormatter`2 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, KeyValuePair`2<TKey, TValue> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual KeyValuePair`2<TKey, TValue> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.LazyFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Lazy`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Lazy`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.LinkedListFormatter`1 : CollectionFormatterBase`4<T, LinkedList`1<T>, Enumerator<T>, LinkedList`1<T>> {
    protected virtual void Add(LinkedList`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual LinkedList`1<T> Complete(LinkedList`1<T> intermediateCollection);
    protected virtual LinkedList`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(LinkedList`1<T> source);
}
public class MessagePack.Formatters.ListFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, List`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual List`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class MessagePack.Formatters.Lookup`2 : object {
    private Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings;
    public IEnumerable`1<TElement> Item { get; }
    public int Count { get; }
    public Lookup`2(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings);
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MessagePack.Formatters.Matrix3x2Formatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Matrix3x2> Instance;
    private static Matrix3x2Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Matrix3x2 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Matrix3x2 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Matrix4x4Formatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Matrix4x4> Instance;
    private static Matrix4x4Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Matrix4x4 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Matrix4x4 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.MemoryFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Memory`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Memory`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.NativeDateTimeArrayFormatter : object {
    public static NativeDateTimeArrayFormatter Instance;
    private static NativeDateTimeArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime[] value, MessagePackSerializerOptions options);
    public sealed virtual DateTime[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeDateTimeFormatter : object {
    [NullableAttribute("1")]
public static NativeDateTimeFormatter Instance;
    private static NativeDateTimeFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, DateTime value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual DateTime Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeDecimalFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<decimal> Instance;
    private static NativeDecimalFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, decimal value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual decimal Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeGuidFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Guid> Instance;
    private static NativeGuidFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Guid value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Guid Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NilFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Nil> Instance;
    private static NilFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nil value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nil Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.NonGenericDictionaryFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceCollectionFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<ICollection> Instance;
    private static NonGenericInterfaceCollectionFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ICollection value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ICollection Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceDictionaryFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<IDictionary> Instance;
    private static NonGenericInterfaceDictionaryFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, IDictionary value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual IDictionary Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceEnumerableFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<IEnumerable> Instance;
    private static NonGenericInterfaceEnumerableFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, IEnumerable value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceListFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<IList> Instance;
    private static NonGenericInterfaceListFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, IList value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual IList Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.NonGenericListFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableBooleanFormatter : object {
    [NullableAttribute("1")]
public static NullableBooleanFormatter Instance;
    private static NullableBooleanFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<bool> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<bool> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableByteFormatter : object {
    [NullableAttribute("1")]
public static NullableByteFormatter Instance;
    private static NullableByteFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<byte> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableCharFormatter : object {
    [NullableAttribute("1")]
public static NullableCharFormatter Instance;
    private static NullableCharFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<char> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<char> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableDateTimeFormatter : object {
    [NullableAttribute("1")]
public static NullableDateTimeFormatter Instance;
    private static NullableDateTimeFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<DateTime> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<DateTime> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableDoubleFormatter : object {
    [NullableAttribute("1")]
public static NullableDoubleFormatter Instance;
    private static NullableDoubleFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<double> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<double> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceByteBlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceByteBlockFormatter Instance;
    private static NullableForceByteBlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<byte> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt16BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceInt16BlockFormatter Instance;
    private static NullableForceInt16BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<short> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<short> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt32BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceInt32BlockFormatter Instance;
    private static NullableForceInt32BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<int> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<int> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt64BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceInt64BlockFormatter Instance;
    private static NullableForceInt64BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<long> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<long> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceSByteBlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceSByteBlockFormatter Instance;
    private static NullableForceSByteBlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<sbyte> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<sbyte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt16BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceUInt16BlockFormatter Instance;
    private static NullableForceUInt16BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ushort> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<ushort> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt32BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceUInt32BlockFormatter Instance;
    private static NullableForceUInt32BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<UInt32> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<UInt32> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt64BlockFormatter : object {
    [NullableAttribute("1")]
public static NullableForceUInt64BlockFormatter Instance;
    private static NullableForceUInt64BlockFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ulong> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<ulong> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt16Formatter : object {
    [NullableAttribute("1")]
public static NullableInt16Formatter Instance;
    private static NullableInt16Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<short> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<short> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt32Formatter : object {
    [NullableAttribute("1")]
public static NullableInt32Formatter Instance;
    private static NullableInt32Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<int> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<int> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt64Formatter : object {
    [NullableAttribute("1")]
public static NullableInt64Formatter Instance;
    private static NullableInt64Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<long> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<long> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableNilFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Nullable`1<Nil>> Instance;
    private static NullableNilFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<Nil> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<Nil> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableSByteFormatter : object {
    [NullableAttribute("1")]
public static NullableSByteFormatter Instance;
    private static NullableSByteFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<sbyte> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<sbyte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableSingleFormatter : object {
    [NullableAttribute("1")]
public static NullableSingleFormatter Instance;
    private static NullableSingleFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<float> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<float> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.NullableStringArrayFormatter : object {
    public static NullableStringArrayFormatter Instance;
    private static NullableStringArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, String[] value, MessagePackSerializerOptions options);
    public sealed virtual String[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.NullableStringFormatter : object {
    public static NullableStringFormatter Instance;
    private static NullableStringFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, string value, MessagePackSerializerOptions options);
    public sealed virtual string Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt16Formatter : object {
    [NullableAttribute("1")]
public static NullableUInt16Formatter Instance;
    private static NullableUInt16Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ushort> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<ushort> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt32Formatter : object {
    [NullableAttribute("1")]
public static NullableUInt32Formatter Instance;
    private static NullableUInt32Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<UInt32> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<UInt32> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt64Formatter : object {
    [NullableAttribute("1")]
public static NullableUInt64Formatter Instance;
    private static NullableUInt64Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ulong> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<ulong> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ObservableCollectionFormatter`1 : CollectionFormatterBase`2<T, ObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ObservableCollection`1<T> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.PrimitiveObjectFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<object> Instance;
    private static Dictionary`2<Type, int> TypeToJumpCode;
    private static PrimitiveObjectFormatter();
    public static bool IsSupportedType(Type type, TypeInfo typeInfo, object value);
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected virtual object DeserializeMap(MessagePackReader& reader, int length, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.PriorityQueueFormatter`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<TPriority> comparer;
    public PriorityQueueFormatter`2(IComparer`1<TPriority> comparer);
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, PriorityQueue`2<TElement, TPriority> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual PriorityQueue`2<TElement, TPriority> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.QuaternionFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Quaternion> Instance;
    private static QuaternionFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Quaternion value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Quaternion Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.QueueFormatter`1 : CollectionFormatterBase`4<T, Queue`1<T>, Enumerator<T>, Queue`1<T>> {
    protected virtual Nullable`1<int> GetCount(Queue`1<T> sequence);
    protected virtual void Add(Queue`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual Queue`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(Queue`1<T> source);
    protected virtual Queue`1<T> Complete(Queue`1<T> intermediateCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], ReadOnlyCollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ReadOnlyCollection`1<T> Complete(T[] intermediateCollection);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, ReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ReadOnlyMemoryFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ReadOnlyMemory`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ReadOnlyMemory`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.ReadOnlyObservableCollectionFormatter`1 : CollectionFormatterBase`3<T, ObservableCollection`1<T>, ReadOnlyObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ObservableCollection`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual ReadOnlyObservableCollection`1<T> Complete(ObservableCollection`1<T> intermediateCollection);
}
public class MessagePack.Formatters.ReadOnlySequenceFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ReadOnlySequence`1<T> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ReadOnlySequence`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.SByteArrayFormatter : object {
    public static SByteArrayFormatter Instance;
    private static SByteArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, SByte[] value, MessagePackSerializerOptions options);
    public sealed virtual SByte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SByteFormatter : object {
    [NullableAttribute("1")]
public static SByteFormatter Instance;
    private static SByteFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, sbyte value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual sbyte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.SByteListFormatter : object {
    public static SByteListFormatter Instance;
    private static SByteListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<sbyte> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<sbyte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.SingleArrayFormatter : object {
    public static SingleArrayFormatter Instance;
    private static SingleArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Single[] value, MessagePackSerializerOptions options);
    public sealed virtual Single[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SingleFormatter : object {
    [NullableAttribute("1")]
public static SingleFormatter Instance;
    private static SingleFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, float value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual float Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.SingleListFormatter : object {
    public static SingleListFormatter Instance;
    private static SingleListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<float> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<float> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.SortedDictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, SortedDictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, SortedDictionary`2<TKey, TValue>> {
    protected virtual void Add(SortedDictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual SortedDictionary`2<TKey, TValue> Complete(SortedDictionary`2<TKey, TValue> intermediateCollection);
    protected virtual SortedDictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(SortedDictionary`2<TKey, TValue> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.SortedListFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, SortedList`2<TKey, TValue>> {
    protected virtual void Add(SortedList`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual SortedList`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class MessagePack.Formatters.StackFormatter`1 : CollectionFormatterBase`4<T, T[], Enumerator<T>, Stack`1<T>> {
    protected virtual Nullable`1<int> GetCount(Stack`1<T> sequence);
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(Stack`1<T> source);
    protected virtual Stack`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.StaticNullableFormatter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMessagePackFormatter`1<T> underlyingFormatter;
    public StaticNullableFormatter`1(IMessagePackFormatter`1<T> underlyingFormatter);
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.StringBuilderFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<StringBuilder> Instance;
    private static StringBuilderFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, StringBuilder value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual StringBuilder Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.StringInterningFormatter : object {
    [NullableContextAttribute("1")]
public sealed virtual string Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, string value, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ThreeDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...,0...] value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T[0...,0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TimeOnlyFormatter : object {
    [NullableAttribute("1")]
public static TimeOnlyFormatter Instance;
    private static TimeOnlyFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, TimeOnly value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual TimeOnly Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TimeSpanFormatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<TimeSpan> Instance;
    private static TimeSpanFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, TimeSpan value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual TimeSpan Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`1<T1> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`1<T1> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`2 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`2<T1, T2> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`2<T1, T2> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`3 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`3<T1, T2, T3> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`3<T1, T2, T3> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`4 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`4<T1, T2, T3, T4> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`4<T1, T2, T3, T4> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`5 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`5<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`5<T1, T2, T3, T4, T5> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`6 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`6<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`6<T1, T2, T3, T4, T5, T6> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`7 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TupleFormatter`8 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TwoDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...] value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T[0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TypeFormatter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<T> Instance;
    private static TypeFormatter`1();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.TypelessFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<object> Instance;
    private static ThreadsafeTypeKeyHashTable`1<SerializeMethod> Serializers;
    private static ThreadsafeTypeKeyHashTable`1<DeserializeMethod> Deserializers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadsafeTypeKeyHashTable`1<Byte[]> FullTypeNameCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadsafeTypeKeyHashTable`1<Byte[]> ShortenedTypeNameCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static AsymmetricKeyHashTable`3<Byte[], ArraySegment`1<byte>, Type> TypeCache;
    private static HashSet`1<Type> UseBuiltinTypes;
    private static bool IsMscorlib;
    private static TypelessFormatter();
    private string BuildTypeName(Type type, MessagePackSerializerOptions options);
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    private object DeserializeByTypeName(ArraySegment`1<byte> typeName, MessagePackReader& byteSequence, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt16ArrayFormatter : object {
    public static UInt16ArrayFormatter Instance;
    private static UInt16ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt16[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt16Formatter : object {
    [NullableAttribute("1")]
public static UInt16Formatter Instance;
    private static UInt16Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ushort value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ushort Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt16ListFormatter : object {
    public static UInt16ListFormatter Instance;
    private static UInt16ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<ushort> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<ushort> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt32ArrayFormatter : object {
    public static UInt32ArrayFormatter Instance;
    private static UInt32ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt32Formatter : object {
    [NullableAttribute("1")]
public static UInt32Formatter Instance;
    private static UInt32Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, UInt32 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual UInt32 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt32ListFormatter : object {
    public static UInt32ListFormatter Instance;
    private static UInt32ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<UInt32> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<UInt32> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt64ArrayFormatter : object {
    public static UInt64ArrayFormatter Instance;
    private static UInt64ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt64[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt64Formatter : object {
    [NullableAttribute("1")]
public static UInt64Formatter Instance;
    private static UInt64Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ulong value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ulong Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Formatters.UInt64ListFormatter : object {
    public static UInt64ListFormatter Instance;
    private static UInt64ListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<ulong> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<ulong> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UriFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<Uri> Instance;
    private static UriFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Uri value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Uri Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`1<T1> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`1<T1> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`2 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`2<T1, T2> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`2<T1, T2> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`3 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`3<T1, T2, T3> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`3<T1, T2, T3> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`4 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`4<T1, T2, T3, T4> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`4<T1, T2, T3, T4> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`5 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`5<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`5<T1, T2, T3, T4, T5> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`6 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`6<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`6<T1, T2, T3, T4, T5, T6> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`7 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class MessagePack.Formatters.ValueTupleFormatter`8 : object {
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Vector2Formatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Vector2> Instance;
    private static Vector2Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Vector2 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Vector2 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Vector3Formatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Vector3> Instance;
    private static Vector3Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Vector3 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Vector3 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Vector4Formatter : object {
    [NullableAttribute("1")]
public static IMessagePackFormatter`1<Vector4> Instance;
    private static Vector4Formatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Vector4 value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Vector4 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.VersionFormatter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IMessagePackFormatter`1<Version> Instance;
    private static VersionFormatter();
    [NullableContextAttribute("1")]
public sealed virtual void Serialize(MessagePackWriter& writer, Version value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public sealed virtual Version Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("NEVERDEFINED")]
public class MessagePack.GeneratedMessagePackResolverAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <UseMapMode>k__BackingField;
    public bool UseMapMode { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseMapMode();
    [CompilerGeneratedAttribute]
public void set_UseMapMode(bool value);
}
[NullableContextAttribute("2")]
public interface MessagePack.IFormatterResolver {
    public abstract virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.ImmutableCollection.FrozenDictionaryFormatter`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<TKey> comparer;
    public FrozenDictionaryFormatter`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual void Serialize(MessagePackWriter& writer, FrozenDictionary`2<TKey, TValue> value, MessagePackSerializerOptions options);
    public sealed virtual FrozenDictionary`2<TKey, TValue> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.ImmutableCollection.FrozenSetFormatter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> comparer;
    public FrozenSetFormatter`1(IEqualityComparer`1<T> comparer);
    public sealed virtual void Serialize(MessagePackWriter& writer, FrozenSet`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual FrozenSet`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.ImmutableArrayFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ImmutableArray`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual ImmutableArray`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.ImmutableCollection.ImmutableCollectionGetFormatterHelper : object {
    private static Dictionary`2<Type, Type> FormatterMap;
    private static ImmutableCollectionGetFormatterHelper();
    internal static object GetFormatter(Type t);
    private static object CreateInstance(Type genericType, Type[] genericTypeArguments, Object[] arguments);
}
public class MessagePack.ImmutableCollection.ImmutableCollectionResolver : object {
    [NullableAttribute("1")]
public static ImmutableCollectionResolver Instance;
    private static ImmutableCollectionResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.ImmutableCollection.ImmutableDictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, Builder<TKey, TValue>, Enumerator<TKey, TValue>, ImmutableDictionary`2<TKey, TValue>> {
    protected virtual void Add(Builder<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ImmutableDictionary`2<TKey, TValue> Complete(Builder<TKey, TValue> intermediateCollection);
    protected virtual Builder<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(ImmutableDictionary`2<TKey, TValue> source);
}
public class MessagePack.ImmutableCollection.ImmutableHashSetFormatter`1 : CollectionFormatterBase`4<T, Builder<T>, Enumerator<T>, ImmutableHashSet`1<T>> {
    protected virtual void Add(Builder<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ImmutableHashSet`1<T> Complete(Builder<T> intermediateCollection);
    protected virtual Builder<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(ImmutableHashSet`1<T> source);
}
public class MessagePack.ImmutableCollection.ImmutableListFormatter`1 : CollectionFormatterBase`4<T, Builder<T>, Enumerator<T>, ImmutableList`1<T>> {
    protected virtual void Add(Builder<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ImmutableList`1<T> Complete(Builder<T> intermediateCollection);
    protected virtual Builder<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(ImmutableList`1<T> source);
}
public class MessagePack.ImmutableCollection.ImmutableQueueBuilder`1 : object {
    [CompilerGeneratedAttribute]
private ImmutableQueue`1<T> <Q>k__BackingField;
    public ImmutableQueue`1<T> Q { get; public set; }
    [CompilerGeneratedAttribute]
public ImmutableQueue`1<T> get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(ImmutableQueue`1<T> value);
    public void Add(T value);
}
public class MessagePack.ImmutableCollection.ImmutableQueueFormatter`1 : CollectionFormatterBase`3<T, ImmutableQueueBuilder`1<T>, ImmutableQueue`1<T>> {
    protected virtual void Add(ImmutableQueueBuilder`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ImmutableQueue`1<T> Complete(ImmutableQueueBuilder`1<T> intermediateCollection);
    protected virtual ImmutableQueueBuilder`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.ImmutableSortedDictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, Builder<TKey, TValue>, Enumerator<TKey, TValue>, ImmutableSortedDictionary`2<TKey, TValue>> {
    protected virtual void Add(Builder<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ImmutableSortedDictionary`2<TKey, TValue> Complete(Builder<TKey, TValue> intermediateCollection);
    protected virtual Builder<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(ImmutableSortedDictionary`2<TKey, TValue> source);
}
public class MessagePack.ImmutableCollection.ImmutableSortedSetFormatter`1 : CollectionFormatterBase`4<T, Builder<T>, Enumerator<T>, ImmutableSortedSet`1<T>> {
    protected virtual void Add(Builder<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ImmutableSortedSet`1<T> Complete(Builder<T> intermediateCollection);
    protected virtual Builder<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(ImmutableSortedSet`1<T> source);
}
public class MessagePack.ImmutableCollection.ImmutableStackFormatter`1 : CollectionFormatterBase`3<T, T[], ImmutableStack`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ImmutableStack`1<T> Complete(T[] intermediateCollection);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.InterfaceImmutableDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Builder<TKey, TValue>, IImmutableDictionary`2<TKey, TValue>> {
    protected virtual void Add(Builder<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual IImmutableDictionary`2<TKey, TValue> Complete(Builder<TKey, TValue> intermediateCollection);
    protected virtual Builder<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.InterfaceImmutableListFormatter`1 : CollectionFormatterBase`3<T, Builder<T>, IImmutableList`1<T>> {
    protected virtual void Add(Builder<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual IImmutableList`1<T> Complete(Builder<T> intermediateCollection);
    protected virtual Builder<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.InterfaceImmutableQueueFormatter`1 : CollectionFormatterBase`3<T, ImmutableQueueBuilder`1<T>, IImmutableQueue`1<T>> {
    protected virtual void Add(ImmutableQueueBuilder`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual IImmutableQueue`1<T> Complete(ImmutableQueueBuilder`1<T> intermediateCollection);
    protected virtual ImmutableQueueBuilder`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.InterfaceImmutableSetFormatter`1 : CollectionFormatterBase`3<T, Builder<T>, IImmutableSet`1<T>> {
    protected virtual void Add(Builder<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual IImmutableSet`1<T> Complete(Builder<T> intermediateCollection);
    protected virtual Builder<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.ImmutableCollection.InterfaceImmutableStackFormatter`1 : CollectionFormatterBase`3<T, T[], IImmutableStack`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual IImmutableStack`1<T> Complete(T[] intermediateCollection);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
}
[ExtensionAttribute]
internal static class MessagePack.ImmutableCollection.ReflectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(TypeInfo type);
}
internal class MessagePack.Internal.AnonymousDeserializeFunc`1 : MulticastDelegate {
    public AnonymousDeserializeFunc`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke(Object[] customFormatters, MessagePackReader& reader, MessagePackSerializerOptions options);
    public virtual IAsyncResult BeginInvoke(Object[] customFormatters, MessagePackReader& reader, MessagePackSerializerOptions options, AsyncCallback callback, object object);
    public virtual T EndInvoke(MessagePackReader& reader, IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.AnonymousSerializableFormatter`1 : object {
    private Byte[][] stringByteKeysField;
    private Object[] serializeCustomFormatters;
    private Object[] deserializeCustomFormatters;
    private AnonymousSerializeFunc`1<T> serialize;
    private AnonymousDeserializeFunc`1<T> deserialize;
    public AnonymousSerializableFormatter`1(Byte[][] stringByteKeysField, Object[] serializeCustomFormatters, Object[] deserializeCustomFormatters, AnonymousSerializeFunc`1<T> serialize, AnonymousDeserializeFunc`1<T> deserialize);
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
internal class MessagePack.Internal.AnonymousSerializeFunc`1 : MulticastDelegate {
    public AnonymousSerializeFunc`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(Byte[][] stringByteKeysField, Object[] customFormatters, MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(Byte[][] stringByteKeysField, Object[] customFormatters, MessagePackWriter& writer, T value, MessagePackSerializerOptions options, AsyncCallback callback, object object);
    public virtual void EndInvoke(MessagePackWriter& writer, IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.ArgumentField : ValueType {
    private int i;
    private bool ref;
    private ILGenerator il;
    public ArgumentField(ILGenerator il, int i, bool ref);
    public ArgumentField(ILGenerator il, int i, Type type);
    public void EmitLoad();
    public void EmitLdarg();
    public void EmitLdarga();
    public void EmitStore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.AsymmetricKeyHashTable`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Entry[] buckets;
    private int size;
    private object writerLock;
    private float loadFactor;
    private IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer;
    public AsymmetricKeyHashTable`3(IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer);
    public AsymmetricKeyHashTable`3(int capacity, float loadFactor, IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer);
    public TValue AddOrGet(TKey1 key1, Func`2<TKey1, TValue> valueFactory);
    public bool TryAdd(TKey1 key, TValue value);
    public bool TryAdd(TKey1 key, Func`2<TKey1, TValue> valueFactory);
    private bool TryAddInternal(TKey1 key, Func`2<TKey1, TValue> valueFactory, TValue& resultingValue);
    private bool AddToBuckets(Entry[] buckets, TKey1 newKey, Entry<TKey1, TKey2, TValue> newEntryOrNull, Func`2<TKey1, TValue> valueFactory, TValue& resultingValue);
    public bool TryGetValue(TKey2 key, TValue& value);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    private static void VolatileWrite(T& location, T value);
    private static void VolatileWrite(Entry[]& location, Entry[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Internal.AutomataDictionary : object {
    private AutomataNode root;
    public void Add(string str, int value);
    [NullableContextAttribute("0")]
public bool TryGetValue(ReadOnlySequence`1& bytes, Int32& value);
    [NullableContextAttribute("0")]
public bool TryGetValue(ReadOnlySpan`1<byte> bytes, Int32& value);
    public virtual string ToString();
    private static void ToStringCore(IEnumerable`1<AutomataNode> nexts, StringBuilder sb, int depth);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, int>> GetEnumerator();
    [IteratorStateMachineAttribute("MessagePack.Internal.AutomataDictionary/<YieldCore>d__9")]
private static IEnumerable`1<KeyValuePair`2<string, int>> YieldCore(IEnumerable`1<AutomataNode> nexts);
    public void EmitMatch(ILGenerator il, LocalBuilder bytesSpan, LocalBuilder key, Action`1<KeyValuePair`2<string, int>> onFound, Action onNotFound);
}
public static class MessagePack.Internal.AutomataKeyGen : object {
    [NullableAttribute("1")]
public static MethodInfo GetKeyMethod;
    private static AutomataKeyGen();
    public static ulong GetKey(ReadOnlySpan`1& span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.Internal.BuiltinResolverGetFormatterHelper : object {
    private static Dictionary`2<Type, object> FormatterMap;
    private static BuiltinResolverGetFormatterHelper();
    internal static object GetFormatter(Type t);
}
public class MessagePack.Internal.ByteArrayStringHashTable : object {
    [NullableAttribute("1")]
private Entry[][] buckets;
    private ulong indexFor;
    private static bool Is32Bit;
    public ByteArrayStringHashTable(int capacity);
    public ByteArrayStringHashTable(int capacity, float loadFactor);
    private static ByteArrayStringHashTable();
    [NullableContextAttribute("1")]
public void Add(string key, int value);
    [NullableContextAttribute("1")]
public void Add(Byte[] key, int value);
    [NullableContextAttribute("1")]
private bool TryAddInternal(Byte[] key, int value);
    public bool TryGetValue(ReadOnlySequence`1& key, Int32& value);
    public bool TryGetValue(ReadOnlySpan`1<byte> key, Int32& value);
    private bool TryGetValueSlow(ReadOnlySpan`1<byte> key, Entry[] entry, Int32& value);
    private static ulong ByteArrayGetHashCode(ReadOnlySpan`1<byte> x);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    [IteratorStateMachineAttribute("MessagePack.Internal.ByteArrayStringHashTable/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, int>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
public static class MessagePack.Internal.CodeGenHelpers : object {
    [NullableContextAttribute("1")]
public static Byte[] GetEncodedStringBytes(string value);
    public static ReadOnlySpan`1<byte> GetSpanFromSequence(ReadOnlySequence`1& sequence);
    public static ReadOnlySpan`1<byte> ReadStringSpan(MessagePackReader& reader);
    public static Byte[] GetArrayFromNullableSequence(Nullable`1& sequence);
}
internal static class MessagePack.Internal.DateTimeConstants : object {
    internal static long BclSecondsAtUnixEpoch;
    internal static int NanosecondsPerTick;
    internal static DateTime UnixEpoch;
    private static DateTimeConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.DynamicAssembly : object {
    internal static bool AvoidDynamicCode;
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    public DynamicAssembly(string moduleName);
    private static DynamicAssembly();
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.Internal.DynamicGenericResolverGetFormatterHelper : object {
    private static Dictionary`2<Type, Type> FormatterMap;
    private static DynamicGenericResolverGetFormatterHelper();
    internal static object GetFormatter(Type t);
    private static object CreateInstance(Type genericType, Type[] genericTypeArguments, Object[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.Internal.DynamicObjectTypeBuilder : object {
    internal static Regex SubtractFullNameRegex;
    private static int nameSequence;
    private static HashSet`1<Type> ignoreTypes;
    private static Type refMessagePackReader;
    private static MethodInfo ReadOnlySpanFromByteArray;
    private static MethodInfo ReadStringSpan;
    private static MethodInfo ArrayFromNullableReadOnlySequence;
    private static MethodInfo getFormatterWithVerify;
    private static MethodInfo getResolverFromOptions;
    private static MethodInfo getSecurityFromOptions;
    private static MethodInfo securityDepthStep;
    private static MethodInfo readerDepthGet;
    private static MethodInfo readerDepthSet;
    private static Func`2<Type, MethodInfo> getSerialize;
    private static Func`2<Type, MethodInfo> getDeserialize;
    private static ConstructorInfo messagePackSerializationExceptionMessageOnlyConstructor;
    private static MethodInfo onBeforeSerialize;
    private static MethodInfo onAfterDeserialize;
    private static ConstructorInfo objectCtor;
    private static DynamicObjectTypeBuilder();
    public static TypeInfo BuildType(DynamicAssembly assembly, Type type, bool forceStringKey, bool contractless);
    public static object BuildFormatterToDynamicMethod(Type type, bool forceStringKey, bool contractless, bool allowPrivate);
    private static void BuildConstructor(Type type, ObjectSerializationInfo info, ConstructorInfo method, FieldBuilder stringByteKeysField, ILGenerator il);
    private static Dictionary`2<EmittableMember, FieldInfo> BuildCustomFormatterField(TypeBuilder builder, ObjectSerializationInfo info, ILGenerator il);
    private static void BuildSerialize(Type type, ObjectSerializationInfo info, ILGenerator il, Action emitStringByteKeys, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, int firstArgIndex);
    private static void EmitSerializeValue(ILGenerator il, TypeInfo type, EmittableMember member, int index, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField argWriter, ArgumentField argValue, ArgumentField argOptions, LocalBuilder localResolver);
    private static void BuildDeserialize(Type type, ObjectSerializationInfo info, ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, int firstArgIndex);
    private static void BuildDeserializeInternalDeserializeEachPropertyStringKey(ObjectSerializationInfo info, ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, bool canOverwrite, ArgumentField& argReader, ArgumentField argOptions, LocalBuilder localResolver, LocalBuilder localResult, LocalBuilder localLength);
    private static void BuildDeserializeInternalDeserializeEachPropertyIntKey(ObjectSerializationInfo info, ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, bool canOverwrite, ArgumentField& argReader, ArgumentField& argOptions, LocalBuilder localResolver, LocalBuilder localResult, LocalBuilder localLength);
    private static void BuildDeserializeInternalAssignFieldFromLocalVariableStringKey(ObjectSerializationInfo info, ILGenerator il, DeserializeInfo[] infoList, LocalBuilder localResult);
    private static void BuildDeserializeInternalAssignFieldFromLocalVariableIntKey(ObjectSerializationInfo info, ILGenerator il, DeserializeInfo[] infoList, LocalBuilder localResult, LocalBuilder localLength, int maxKey);
    private static void BuildDeserializeInternalCreateInstanceWithArguments(ObjectSerializationInfo info, ILGenerator il, DeserializeInfo[] infoList, LocalBuilder localResult);
    private static DeserializeInfo[] BuildDeserializeInternalDeserializationInfoArrayStringKey(ObjectSerializationInfo info, ILGenerator il, bool canOverwrite);
    private static DeserializeInfo[] BuildDeserializeInternalDeserializationInfoArrayIntKey(ObjectSerializationInfo info, ILGenerator il, bool canOverwrite, Nullable`1& gotoDefault, Int32& maxKey);
    private static void BuildDeserializeInternalDeserializeLoopIntKey(ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField& argReader, ArgumentField& argOptions, DeserializeInfo[] infoList, LocalBuilder localResolver, LocalBuilder localResult, LocalBuilder localLength, bool canOverwrite, Nullable`1<Label> gotoDefault);
    private static void BuildDeserializeInternalDeserializeLoopStringKey(ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField& argReader, ArgumentField& argOptions, DeserializeInfo[] infoList, LocalBuilder localResolver, LocalBuilder localResult, LocalBuilder localLength, bool canOverwrite, ObjectSerializationInfo info);
    private static void BuildDeserializeInternalTryReadNil(Type type, ILGenerator il, ArgumentField& argReader);
    private static void BuildDeserializeInternalDepthUnStep(ILGenerator il, ArgumentField& argReader);
    private static void BuildDeserializeInternalOnAfterDeserialize(Type type, ObjectSerializationInfo info, ILGenerator il, LocalBuilder localResult);
    private static LocalBuilder BuildDeserializeInternalResolver(ObjectSerializationInfo info, ILGenerator il, ArgumentField& argOptions);
    private static LocalBuilder BuildDeserializeInternalReadHeaderLength(ObjectSerializationInfo info, ILGenerator il, ArgumentField& argReader);
    private static void BuildDeserializeInternalDepthStep(ILGenerator il, ArgumentField& argReader, ArgumentField& argOptions);
    private static void BuildDeserializeInternalCreateInstance(Type type, ObjectSerializationInfo info, ILGenerator il, LocalBuilder localResult);
    private static void BuildDeserializeInternalDeserializeValueAssignDirectly(ILGenerator il, DeserializeInfo info, int index, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField& argReader, ArgumentField& argOptions, LocalBuilder localResolver, LocalBuilder localResult);
    private static void BuildDeserializeInternalDeserializeValueAssignLocalVariable(ILGenerator il, DeserializeInfo info, int index, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField& argReader, ArgumentField& argOptions, LocalBuilder localResolver, LocalBuilder localResult);
    private static bool Matches(MethodInfo m, int parameterIndex, Type desiredType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.Internal.ExpressionUtility : object {
    private static MethodInfo GetMethodInfoCore(LambdaExpression expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, TR>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethodInfo(Expression`1<Func`3<T, TArg1, TR>> expression);
    private static MemberInfo GetMemberInfoCore(Expression`1<T> source);
    public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TR>> expression);
    public static FieldInfo GetFieldInfo(Expression`1<Func`2<T, TR>> expression);
}
internal static class MessagePack.Internal.FarmHash : object {
    private static UInt32 c1;
    private static UInt32 c2;
    private static ulong k0;
    private static ulong k1;
    private static ulong k2;
    public static UInt32 Hash32(ReadOnlySpan`1<byte> bytes);
    private static UInt32 Fetch32(Byte* p);
    private static UInt32 Rotate32(UInt32 val, int shift);
    private static UInt32 fmix(UInt32 h);
    private static UInt32 Mur(UInt32 a, UInt32 h);
    private static UInt32 Hash32Len0to4(ReadOnlySpan`1<byte> s);
    private static UInt32 Hash32Len5to12(Byte* s, UInt32 len);
    private static UInt32 Hash32Len13to24(Byte* s, UInt32 len);
    private static UInt32 Hash32(Byte* s, UInt32 len);
    public static ulong Hash64(ReadOnlySpan`1<byte> bytes);
    private static void swap(UInt64& x, UInt64& z);
    private static ulong Fetch64(Byte* p);
    private static ulong Rotate64(ulong val, int shift);
    private static ulong ShiftMix(ulong val);
    private static ulong HashLen16(ulong u, ulong v, ulong mul);
    private static ulong Hash64(Byte* s, UInt32 len);
    private static ulong HashLen0to16(Byte* s, UInt32 len);
    private static ulong HashLen17to32(Byte* s, UInt32 len);
    private static ulong H32(Byte* s, UInt32 len, ulong mul, ulong seed0, ulong seed1);
    private static ulong HashLen33to64(Byte* s, UInt32 len);
    private static ulong HashLen65to96(Byte* s, UInt32 len);
    private static void WeakHashLen32WithSeeds(ulong w, ulong x, ulong y, ulong z, ulong a, ulong b, UInt64& first, UInt64& second);
    private static void WeakHashLen32WithSeeds(Byte* s, ulong a, ulong b, UInt64& first, UInt64& second);
    private static ulong Hash64NA(Byte* s, UInt32 len);
    private static ulong H(ulong x, ulong y, ulong mul, int r);
    private static ulong Hash64UO(Byte* s, UInt32 len);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class MessagePack.Internal.GeneratedAssemblyMessagePackResolverAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ResolverType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinorVersion>k__BackingField;
    public Type ResolverType { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public GeneratedAssemblyMessagePackResolverAttribute(Type resolverType, int majorVersion, int minorVersion);
    [CompilerGeneratedAttribute]
public Type get_ResolverType();
    [CompilerGeneratedAttribute]
public int get_MajorVersion();
    [CompilerGeneratedAttribute]
public int get_MinorVersion();
}
internal class MessagePack.Internal.GuidBits : ValueType {
    public Guid Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public byte Byte8;
    public byte Byte9;
    public byte Byte10;
    public byte Byte11;
    public byte Byte12;
    public byte Byte13;
    public byte Byte14;
    public byte Byte15;
    public GuidBits(Guid& value);
    public GuidBits(ReadOnlySpan`1<byte> utf8string);
    private static ReadOnlySpan`1<byte> GetByteToHexStringHigh();
    private static ReadOnlySpan`1<byte> GetByteToHexStringLow();
    private static byte Parse(ReadOnlySpan`1<byte> bytes, int highOffset);
    private static byte SwitchParse(byte b);
    public void Write(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
internal interface MessagePack.Internal.IAsymmetricEqualityComparer`2 {
    public abstract virtual int GetHashCode(TKey1 key1);
    public abstract virtual int GetHashCode(TKey2 key2);
    public abstract virtual bool Equals(TKey1 x, TKey1 y);
    public abstract virtual bool Equals(TKey1 x, TKey2 y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MessagePack.Internal.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitTrue(ILGenerator il);
    [ExtensionAttribute]
public static void EmitFalse(ILGenerator il);
    [ExtensionAttribute]
public static void EmitBoolean(ILGenerator il, bool value);
    [ExtensionAttribute]
public static void EmitLdc_I4(ILGenerator il, int value);
    [ExtensionAttribute]
public static void EmitUnboxOrCast(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitBoxOrDoNothing(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitLdarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLoadThis(ILGenerator il);
    [ExtensionAttribute]
public static void EmitLdarga(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitPop(ILGenerator il, int count);
    [ExtensionAttribute]
public static void EmitCall(ILGenerator il, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void EmitLdfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitLdsfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitRet(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIntZeroReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitNullReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitULong(ILGenerator il, ulong value);
    [ExtensionAttribute]
public static void EmitThrowNotimplemented(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIncrementFor(ILGenerator il, LocalBuilder conditionGreater, Action`1<LocalBuilder> emitBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.InitAccessorInGenericClassNotSupportedException : NotSupportedException {
    public InitAccessorInGenericClassNotSupportedException(string message);
    public InitAccessorInGenericClassNotSupportedException(string message, Exception inner);
    [ObsoleteAttribute]
protected InitAccessorInGenericClassNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class MessagePack.Internal.MessagePackDynamicObjectResolverException : MessagePackSerializationException {
    [NullableContextAttribute("1")]
public MessagePackDynamicObjectResolverException(string message);
}
internal static class MessagePack.Internal.NativeDateTimeResolverGetFormatterHelper : object {
    [NullableContextAttribute("1")]
internal static object GetFormatter(Type t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.ObjectSerializationInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIntKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldUseFormatterResolver>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ConstructorInfo <BestmatchConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private EmittableMemberAndConstructorParameter[] <ConstructorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private EmittableMember[] <Members>k__BackingField;
    public Type Type { get; }
    public bool IsIntKey { get; }
    public bool IsStringKey { get; }
    public bool IsClass { get; }
    public bool IsStruct { get; }
    public bool ShouldUseFormatterResolver { get; private set; }
    [NullableAttribute("2")]
public ConstructorInfo BestmatchConstructor { get; }
    public EmittableMemberAndConstructorParameter[] ConstructorParameters { get; }
    public EmittableMember[] Members { get; }
    private ObjectSerializationInfo(Type type, EmittableMemberAndConstructorParameter[] constructorParameters, EmittableMember[] members, bool isClass, ConstructorInfo bestmatchConstructor, bool isIntKey);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public bool get_IsIntKey();
    public bool get_IsStringKey();
    [CompilerGeneratedAttribute]
public bool get_IsClass();
    public bool get_IsStruct();
    [CompilerGeneratedAttribute]
public bool get_ShouldUseFormatterResolver();
    [CompilerGeneratedAttribute]
private void set_ShouldUseFormatterResolver(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ConstructorInfo get_BestmatchConstructor();
    [CompilerGeneratedAttribute]
public EmittableMemberAndConstructorParameter[] get_ConstructorParameters();
    [CompilerGeneratedAttribute]
public EmittableMember[] get_Members();
    public static ObjectSerializationInfo CreateOrNull(Type type, bool forceStringKey, bool contractless, bool allowPrivate, bool dynamicMethod);
    internal static bool IsOptimizeTargetType(Type type);
    [IteratorStateMachineAttribute("MessagePack.Internal.ObjectSerializationInfo/<GetAllFields>d__29")]
private static IEnumerable`1<FieldInfo> GetAllFields(Type type);
    [IteratorStateMachineAttribute("MessagePack.Internal.ObjectSerializationInfo/<GetAllProperties>d__30")]
private static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    private static bool IsClassRecord(TypeInfo type);
    [NullableContextAttribute("2")]
private static bool TryGetNextConstructor(IEnumerator`1<ConstructorInfo> ctorEnumerator, ConstructorInfo& ctor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MessagePack.Internal.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsNullable(TypeInfo type);
    [ExtensionAttribute]
public static bool IsPublic(TypeInfo type);
    [ExtensionAttribute]
public static bool IsAnonymous(TypeInfo type);
    [ExtensionAttribute]
public static bool IsIndexer(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsConstructedGenericType(TypeInfo type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propInfo);
    [ExtensionAttribute]
public static bool HasPrivateCtorForSerialization(TypeInfo type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MessagePack.Internal.ResolverUtilities : object {
    internal static IMessagePackFormatter ActivateFormatter(Type formatterType, Object[] args);
    internal static FieldInfo FetchSingletonField(Type formatterType);
}
public class MessagePack.Internal.RuntimeTypeHandleEqualityComparer : object {
    [NullableAttribute("1")]
public static IEqualityComparer`1<RuntimeTypeHandle> Default;
    private static RuntimeTypeHandleEqualityComparer();
    public sealed virtual bool Equals(RuntimeTypeHandle x, RuntimeTypeHandle y);
    public sealed virtual int GetHashCode(RuntimeTypeHandle obj);
}
internal static class MessagePack.Internal.StandardResolverHelper : object {
    [NullableAttribute("1")]
public static IFormatterResolver[] DefaultResolvers;
    private static StandardResolverHelper();
}
internal class MessagePack.Internal.StringArraySegmentByteAscymmetricEqualityComparer : object {
    private static bool Is32Bit;
    private static StringArraySegmentByteAscymmetricEqualityComparer();
    [NullableContextAttribute("1")]
public sealed virtual bool Equals(Byte[] x, Byte[] y);
    public sealed virtual bool Equals(Byte[] x, ArraySegment`1<byte> y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(Byte[] key1);
    public sealed virtual int GetHashCode(ArraySegment`1<byte> key2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.Internal.ThreadsafeTypeKeyHashTable`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Entry[] buckets;
    private int size;
    private object writerLock;
    private float loadFactor;
    public ThreadsafeTypeKeyHashTable`1(int capacity, float loadFactor);
    public bool TryAdd(Type key, TValue value);
    public bool TryAdd(Type key, Func`2<Type, TValue> valueFactory);
    private bool TryAddInternal(Type key, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    private bool AddToBuckets(Entry[] buckets, Type newKey, Entry<TValue> newEntryOrNull, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    public bool TryGetValue(Type key, TValue& value);
    public TValue GetOrAdd(Type key, Func`2<Type, TValue> valueFactory);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    private static void VolatileWrite(Entry& location, Entry<TValue> value);
    private static void VolatileWrite(Entry[]& location, Entry[] value);
}
public static class MessagePack.Internal.UnsafeMemory : object {
    public static bool Is32Bit;
    private static UnsafeMemory();
}
public static class MessagePack.Internal.UnsafeMemory32 : object {
    public static void WriteRaw4(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw5(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw6(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw7(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw8(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw9(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw10(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw11(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw12(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw13(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw14(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw15(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw16(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw17(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw18(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw19(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw20(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw21(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw22(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw23(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw24(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw25(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw26(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw27(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw28(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw29(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw30(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw31(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw1(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw2(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw3(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
}
public static class MessagePack.Internal.UnsafeMemory64 : object {
    public static void WriteRaw8(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw9(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw10(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw11(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw12(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw13(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw14(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw15(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw16(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw17(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw18(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw19(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw20(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw21(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw22(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw23(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw24(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw25(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw26(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw27(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw28(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw29(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw30(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw31(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw1(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw2(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw3(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw4(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw5(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw6(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw7(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
}
internal static class MessagePack.Internal.UnsafeRefDeserializeHelper : object {
    internal static int Deserialize(Byte& input, int length, Boolean& output);
}
internal static class MessagePack.Internal.UnsafeRefSerializeHelper : object {
    internal static void Serialize(MessagePackWriter& writer, Boolean& input, int length);
    internal static void Serialize(MessagePackWriter& writer, SByte& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, SByte& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, SByte& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Int16& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, Int16& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, Int16& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Char& input, int length);
    internal static void Serialize(MessagePackWriter& writer, UInt16& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, UInt16& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, UInt16& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Int32& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, Int32& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, Int32& input, int length);
    internal static void Serialize(MessagePackWriter& writer, UInt32& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, UInt32& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, UInt32& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Int64& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, Int64& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, Int64& input, int length);
    internal static void Serialize(MessagePackWriter& writer, UInt64& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, UInt64& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, UInt64& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Single& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, Single& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, Single& input, int length);
    internal static void Serialize(MessagePackWriter& writer, Double& input, int length);
    private static void BigEndianSerialize(MessagePackWriter& writer, Double& input, int length);
    private static void LittleEndianSerialize(MessagePackWriter& writer, Double& input, int length);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, byte value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, sbyte value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, ushort value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, short value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, UInt32 value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, int value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, ulong value);
    private static UIntPtr ReverseWriteUnknown(Byte& destination, long value);
}
internal static class MessagePack.LZ4.LZ4Codec : object {
    private static int MEMORY_USAGE;
    private static int NOTCOMPRESSIBLE_DETECTIONLEVEL;
    private static int MINMATCH;
    private static int SKIPSTRENGTH;
    private static int COPYLENGTH;
    private static int LASTLITERALS;
    private static int MFLIMIT;
    private static int MINLENGTH;
    private static int MAXD_LOG;
    private static int MAXD;
    private static int MAXD_MASK;
    private static int MAX_DISTANCE;
    private static int ML_BITS;
    private static int ML_MASK;
    private static int RUN_BITS;
    private static int RUN_MASK;
    private static int STEPSIZE_64;
    private static int STEPSIZE_32;
    private static int LZ4_64KLIMIT;
    private static int HASH_LOG;
    private static int HASH_TABLESIZE;
    private static int HASH_ADJUST;
    private static int HASH64K_LOG;
    private static int HASH64K_TABLESIZE;
    private static int HASH64K_ADJUST;
    private static int HASHHC_LOG;
    private static int HASHHC_TABLESIZE;
    private static int HASHHC_ADJUST;
    private static int MAX_NB_ATTEMPTS;
    private static int OPTIMAL_ML;
    private static int BLOCK_COPY_LIMIT;
    [NullableAttribute("1")]
private static Int32[] DECODER_TABLE_32;
    [NullableAttribute("1")]
private static Int32[] DECODER_TABLE_64;
    [NullableAttribute("1")]
private static Int32[] DEBRUIJN_TABLE_32;
    [NullableAttribute("1")]
private static Int32[] DEBRUIJN_TABLE_64;
    private static LZ4Codec();
    public static int MaximumOutputLength(int inputLength);
    [NullableContextAttribute("1")]
internal static void CheckArguments(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset, int outputLength);
    public static int Encode(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public static int Decode(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    private static int LZ4_compressCtx_32(UInt32* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_compress64kCtx_32(UInt16* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_uncompress_32(Byte* src, Byte* dst, int dst_len);
    private static void BlockCopy32(Byte* src, Byte* dst, int len);
    private static int LZ4_compressCtx_64(UInt32* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_compress64kCtx_64(UInt16* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_uncompress_64(Byte* src, Byte* dst, int dst_len);
    private static void BlockCopy64(Byte* src, Byte* dst, int len);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MessagePack.MessagePackCode : object {
    public static byte MinFixInt;
    public static byte MaxFixInt;
    public static byte MinFixMap;
    public static byte MaxFixMap;
    public static byte MinFixArray;
    public static byte MaxFixArray;
    public static byte MinFixStr;
    public static byte MaxFixStr;
    public static byte Nil;
    public static byte NeverUsed;
    public static byte False;
    public static byte True;
    public static byte Bin8;
    public static byte Bin16;
    public static byte Bin32;
    public static byte Ext8;
    public static byte Ext16;
    public static byte Ext32;
    public static byte Float32;
    public static byte Float64;
    public static byte UInt8;
    public static byte UInt16;
    public static byte UInt32;
    public static byte UInt64;
    public static byte Int8;
    public static byte Int16;
    public static byte Int32;
    public static byte Int64;
    public static byte FixExt1;
    public static byte FixExt2;
    public static byte FixExt4;
    public static byte FixExt8;
    public static byte FixExt16;
    public static byte Str8;
    public static byte Str16;
    public static byte Str32;
    public static byte Array16;
    public static byte Array32;
    public static byte Map16;
    public static byte Map32;
    public static byte MinNegativeFixInt;
    public static byte MaxNegativeFixInt;
    private static MessagePackType[] TypeLookupTable;
    private static String[] FormatNameTable;
    private static MessagePackCode();
    public static MessagePackType ToMessagePackType(byte code);
    public static string ToFormatName(byte code);
    internal static bool IsSignedInteger(byte code);
}
public enum MessagePack.MessagePackCompression : Enum {
    public int value__;
    public static MessagePackCompression None;
    public static MessagePackCompression Lz4Block;
    public static MessagePackCompression Lz4BlockArray;
}
[ExtensionAttribute]
internal static class MessagePack.MessagePackCompressionExtensions : object {
    [ExtensionAttribute]
public static bool IsCompression(MessagePackCompression compression);
}
[EventSourceAttribute]
internal class MessagePack.MessagePackEventSource : EventSource {
    [NullableAttribute("1")]
internal static MessagePackEventSource Instance;
    private static int FormatterDynamicallyGeneratedStartEvent;
    private static int FormatterDynamicallyGeneratedStopEvent;
    private static MessagePackEventSource();
    [EventAttribute("1")]
public void FormatterDynamicallyGeneratedStart();
    [NullableContextAttribute("2")]
[EventAttribute("2")]
public void FormatterDynamicallyGeneratedStop(string dataType);
}
[ExtensionAttribute]
internal static class MessagePack.MessagePackEventSourceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void FormatterDynamicallyGeneratedStop(MessagePackEventSource source, Type dataType);
}
public static class MessagePack.MessagePackRange : object {
    public static int MinFixNegativeInt;
    public static int MaxFixNegativeInt;
    public static int MaxFixPositiveInt;
    public static int MinFixStringLength;
    public static int MaxFixStringLength;
    public static int MaxFixMapCount;
    public static int MaxFixArrayCount;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class MessagePack.MessagePackReader : ValueType {
    private SequenceReader`1<byte> reader;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public int Depth { get; public set; }
    public ReadOnlySequence`1<byte> Sequence { get; }
    public SequencePosition Position { get; }
    public long Consumed { get; }
    public bool End { get; }
    public bool IsNil { get; }
    public MessagePackType NextMessagePackType { get; }
    public byte NextCode { get; }
    public MessagePackReader(ReadOnlyMemory`1<byte> memory);
    public MessagePackReader(ReadOnlySequence`1& readOnlySequence);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    public ReadOnlySequence`1<byte> get_Sequence();
    public SequencePosition get_Position();
    public long get_Consumed();
    public bool get_End();
    public bool get_IsNil();
    public MessagePackType get_NextMessagePackType();
    public byte get_NextCode();
    public MessagePackReader Clone(ReadOnlySequence`1& readOnlySequence);
    public MessagePackReader CreatePeekReader();
    public void Skip();
    internal bool TrySkip();
    public Nil ReadNil();
    public bool TryReadNil();
    public ReadOnlySequence`1<byte> ReadRaw(long length);
    public ReadOnlySequence`1<byte> ReadRaw();
    public int ReadArrayHeader();
    public bool TryReadArrayHeader(Int32& count);
    public int ReadMapHeader();
    public bool TryReadMapHeader(Int32& count);
    public bool ReadBoolean();
    public char ReadChar();
    public float ReadSingle();
    public double ReadDouble();
    public DateTime ReadDateTime();
    public DateTime ReadDateTime(ExtensionHeader header);
    public Nullable`1<ReadOnlySequence`1<byte>> ReadBytes();
    public Nullable`1<ReadOnlySequence`1<byte>> ReadStringSequence();
    public bool TryReadStringSpan(ReadOnlySpan`1& span);
    [NullableContextAttribute("2")]
public string ReadString();
    public ExtensionHeader ReadExtensionFormatHeader();
    public bool TryReadExtensionFormatHeader(ExtensionHeader& extensionHeader);
    public ExtensionResult ReadExtensionFormat();
    [NullableContextAttribute("1")]
private static EndOfStreamException ThrowNotEnoughBytesException();
    [NullableContextAttribute("1")]
private static EndOfStreamException ThrowNotEnoughBytesException(Exception innerException);
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
private static Exception ThrowInvalidCode(byte code);
    private static void ThrowInsufficientBufferUnless(bool condition);
    private int GetBytesLength();
    private bool TryGetBytesLength(Int32& length);
    private bool TryGetStringLengthInBytes(Int32& length);
    private int GetStringLengthInBytes();
    private bool TryGetStringLengthInBytesSlow(byte code, Int32& length);
    [NullableContextAttribute("1")]
private string ReadStringSlow(int byteLength);
    private bool TrySkipNextArray();
    private bool TrySkipNextMap();
    private bool TrySkip(int count);
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.MessagePackSecurity : object {
    public static MessagePackSecurity TrustedData;
    public static MessagePackSecurity UntrustedData;
    private ObjectFallbackEqualityComparer objectFallbackEqualityComparer;
    [CompilerGeneratedAttribute]
private bool <HashCollisionResistant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumObjectGraphDepth>k__BackingField;
    public bool HashCollisionResistant { get; private set; }
    public int MaximumObjectGraphDepth { get; private set; }
    protected MessagePackSecurity(MessagePackSecurity copyFrom);
    private static MessagePackSecurity();
    [CompilerGeneratedAttribute]
public bool get_HashCollisionResistant();
    [CompilerGeneratedAttribute]
private void set_HashCollisionResistant(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumObjectGraphDepth();
    [CompilerGeneratedAttribute]
private void set_MaximumObjectGraphDepth(int value);
    public MessagePackSecurity WithMaximumObjectGraphDepth(int maximumObjectGraphDepth);
    public MessagePackSecurity WithHashCollisionResistant(bool hashCollisionResistant);
    public IEqualityComparer`1<T> GetEqualityComparer();
    public IEqualityComparer GetEqualityComparer();
    protected virtual IEqualityComparer`1<T> GetHashCollisionResistantEqualityComparer();
    public void DepthStep(MessagePackReader& reader);
    protected virtual IEqualityComparer GetHashCollisionResistantEqualityComparer();
    protected virtual MessagePackSecurity Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.MessagePackSerializationException : Exception {
    [NullableContextAttribute("2")]
public MessagePackSerializationException(string message);
    [NullableContextAttribute("2")]
public MessagePackSerializationException(string message, Exception inner);
    [ObsoleteAttribute]
protected MessagePackSerializationException(SerializationInfo info, StreamingContext context);
    [DoesNotReturnAttribute]
internal static Exception ThrowUnexpectedNilWhileDeserializing();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MessagePack.MessagePackSerializer : object {
    [NullableAttribute("2")]
private static MessagePackSerializerOptions defaultOptions;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Byte[] scratchArray;
    private static LZ4Transform LZ4CodecEncode;
    private static LZ4Transform LZ4CodecDecode;
    private static Func`2<Type, CompiledMethods> CreateCompiledMethods;
    private static ThreadsafeTypeKeyHashTable`1<CompiledMethods> Serializes;
    public static MessagePackSerializerOptions DefaultOptions { get; public set; }
    private static MessagePackSerializer();
    public static MessagePackSerializerOptions get_DefaultOptions();
    public static void set_DefaultOptions(MessagePackSerializerOptions value);
    public static void Serialize(IBufferWriter`1<byte> writer, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public static Byte[] Serialize(T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void Serialize(Stream stream, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<SerializeAsync>d__10`1")]
public static Task SerializeAsync(Stream stream, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static T Deserialize(ReadOnlySequence`1& byteSequence, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    [NullableContextAttribute("2")]
public static T Deserialize(ReadOnlyMemory`1<byte> buffer, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static T Deserialize(ReadOnlyMemory`1<byte> buffer, Int32& bytesRead, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static T Deserialize(ReadOnlyMemory`1<byte> buffer, MessagePackSerializerOptions options, Int32& bytesRead, CancellationToken cancellationToken);
    public static T Deserialize(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<DeserializeAsync>d__17`1")]
public static ValueTask`1<T> DeserializeAsync(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    private static bool TryDeserializeFromMemoryStream(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken, T& result);
    private static T DeserializeFromSequenceAndRewindStreamIfPossible(Stream streamToRewind, MessagePackSerializerOptions options, ReadOnlySequence`1<byte> sequence, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static int LZ4Operation(ReadOnlySequence`1& input, Span`1<byte> output, LZ4Transform lz4Operation);
    private static bool TryDecompress(MessagePackReader& reader, IBufferWriter`1<byte> writer);
    [NullableContextAttribute("0")]
private static void ToLZ4BinaryCore(ReadOnlySequence`1& msgpackUncompressedData, MessagePackWriter& writer, MessagePackCompression compression, int minCompressionSize);
    private static int GetUInt32WriteSize(UInt32 value);
    [NullableContextAttribute("0")]
private static void WriteBin32Header(UInt32 value, Span`1<byte> span);
    private static bool IsMessagePackFixedSizePrimitiveTypeHelper(Type type);
    public static void SerializeToJson(TextWriter textWriter, T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static string SerializeToJson(T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static string ConvertToJson(ReadOnlyMemory`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static string ConvertToJson(ReadOnlySequence`1& bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void ConvertToJson(MessagePackReader& reader, TextWriter jsonWriter, MessagePackSerializerOptions options);
    public static void ConvertFromJson(string str, MessagePackWriter& writer, MessagePackSerializerOptions options);
    public static Byte[] ConvertFromJson(string str, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void ConvertFromJson(TextReader reader, MessagePackWriter& writer, MessagePackSerializerOptions options);
    private static UInt32 FromJsonCore(TinyJsonReader jr, MessagePackWriter& writer, MessagePackSerializerOptions options);
    private static void ToJsonCore(MessagePackReader& reader, TextWriter writer, MessagePackSerializerOptions options);
    private static void WriteJsonString(string value, TextWriter builder);
    [NullableContextAttribute("2")]
public static void Serialize(Type type, MessagePackWriter& writer, object obj, MessagePackSerializerOptions options);
    public static void Serialize(Type type, IBufferWriter`1<byte> writer, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static Byte[] Serialize(Type type, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void Serialize(Type type, Stream stream, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Type type, Stream stream, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static object Deserialize(Type type, MessagePackReader& reader, MessagePackSerializerOptions options);
    public static object Deserialize(Type type, Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Type type, Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static object Deserialize(Type type, ReadOnlyMemory`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static object Deserialize(Type type, ReadOnlySequence`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static void SerializeSemiGeneric(MessagePackWriter& writer, object valueObject, MessagePackSerializerOptions options);
    [NullableContextAttribute("2")]
private static object DeserializeSemiGeneric(MessagePackReader& reader, MessagePackSerializerOptions options);
    [AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<DeserializeObjectAsync>d__56`1")]
private static ValueTask`1<object> DeserializeObjectAsync(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    private static CompiledMethods GetOrAdd(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.MessagePackSerializerOptions : object {
    internal static Regex AssemblyNameVersionSelectorRegex;
    private static HashSet`1<string> DisallowedTypes;
    [CompilerGeneratedAttribute]
private IFormatterResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePackCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompressionMinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuggestedContiguousMemorySize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OldSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitAssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAssemblyVersionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePackSecurity <Security>k__BackingField;
    [CompilerGeneratedAttribute]
private SequencePool <SequencePool>k__BackingField;
    public static MessagePackSerializerOptions Standard { get; }
    public IFormatterResolver Resolver { get; private set; }
    public MessagePackCompression Compression { get; private set; }
    public int CompressionMinLength { get; private set; }
    public int SuggestedContiguousMemorySize { get; private set; }
    public Nullable`1<bool> OldSpec { get; private set; }
    public bool OmitAssemblyVersion { get; private set; }
    public bool AllowAssemblyVersionMismatch { get; private set; }
    public MessagePackSecurity Security { get; private set; }
    public SequencePool SequencePool { get; private set; }
    public MessagePackSerializerOptions(IFormatterResolver resolver);
    protected MessagePackSerializerOptions(MessagePackSerializerOptions copyFrom);
    private static MessagePackSerializerOptions();
    public static MessagePackSerializerOptions get_Standard();
    [CompilerGeneratedAttribute]
public IFormatterResolver get_Resolver();
    [CompilerGeneratedAttribute]
private void set_Resolver(IFormatterResolver value);
    [CompilerGeneratedAttribute]
public MessagePackCompression get_Compression();
    [CompilerGeneratedAttribute]
private void set_Compression(MessagePackCompression value);
    [CompilerGeneratedAttribute]
public int get_CompressionMinLength();
    [CompilerGeneratedAttribute]
private void set_CompressionMinLength(int value);
    [CompilerGeneratedAttribute]
public int get_SuggestedContiguousMemorySize();
    [CompilerGeneratedAttribute]
private void set_SuggestedContiguousMemorySize(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OldSpec();
    [CompilerGeneratedAttribute]
private void set_OldSpec(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_OmitAssemblyVersion();
    [CompilerGeneratedAttribute]
private void set_OmitAssemblyVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAssemblyVersionMismatch();
    [CompilerGeneratedAttribute]
private void set_AllowAssemblyVersionMismatch(bool value);
    [CompilerGeneratedAttribute]
public MessagePackSecurity get_Security();
    [CompilerGeneratedAttribute]
private void set_Security(MessagePackSecurity value);
    [CompilerGeneratedAttribute]
public SequencePool get_SequencePool();
    [CompilerGeneratedAttribute]
private void set_SequencePool(SequencePool value);
    public virtual Type LoadType(string typeName);
    public virtual void ThrowIfDeserializingTypeIsDisallowed(Type type);
    public MessagePackSerializerOptions WithResolver(IFormatterResolver resolver);
    public MessagePackSerializerOptions WithCompression(MessagePackCompression compression);
    public MessagePackSerializerOptions WithCompressionMinLength(int compressionMinLength);
    public MessagePackSerializerOptions WithSuggestedContiguousMemorySize(int suggestedContiguousMemorySize);
    public MessagePackSerializerOptions WithOldSpec(Nullable`1<bool> oldSpec);
    public MessagePackSerializerOptions WithOmitAssemblyVersion(bool omitAssemblyVersion);
    public MessagePackSerializerOptions WithAllowAssemblyVersionMismatch(bool allowAssemblyVersionMismatch);
    public MessagePackSerializerOptions WithSecurity(MessagePackSecurity security);
    public MessagePackSerializerOptions WithPool(SequencePool pool);
    protected virtual MessagePackSerializerOptions Clone();
}
public class MessagePack.MessagePackStreamReader : object {
    [NullableAttribute("1")]
private Stream stream;
    private bool leaveOpen;
    private Rental sequenceRental;
    private Nullable`1<SequencePosition> endOfLastMessage;
    public ReadOnlySequence`1<byte> RemainingBytes { get; }
    [NullableAttribute("1")]
private Sequence`1<byte> ReadData { get; }
    [NullableContextAttribute("1")]
public MessagePackStreamReader(Stream stream);
    [NullableContextAttribute("1")]
public MessagePackStreamReader(Stream stream, bool leaveOpen);
    [NullableContextAttribute("1")]
public MessagePackStreamReader(Stream stream, bool leaveOpen, SequencePool sequencePool);
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadArrayHeaderAsync>d__0")]
public ValueTask`1<int> ReadArrayHeaderAsync(CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadArrayAsync>d__1")]
public IAsyncEnumerable`1<ReadOnlySequence`1<byte>> ReadArrayAsync(CancellationToken cancellationToken);
    private bool TryReadArrayHeader(Int32& length);
    public ReadOnlySequence`1<byte> get_RemainingBytes();
    [NullableContextAttribute("1")]
private Sequence`1<byte> get_ReadData();
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadAsync>d__14")]
public ValueTask`1<Nullable`1<ReadOnlySequence`1<byte>>> ReadAsync(CancellationToken cancellationToken);
    public void DiscardBufferedData();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void RecycleLastMessage();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<TryReadMoreDataAsync>d__19")]
private Task`1<bool> TryReadMoreDataAsync(CancellationToken cancellationToken);
    private bool TryReadNextMessage(ReadOnlySequence`1& completeMessage);
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadMapHeaderAsync>d__21")]
public ValueTask`1<int> ReadMapHeaderAsync(CancellationToken cancellationToken);
    private bool TryReadMapHeader(Int32& count);
}
public enum MessagePack.MessagePackType : Enum {
    public byte value__;
    public static MessagePackType Unknown;
    public static MessagePackType Integer;
    public static MessagePackType Nil;
    public static MessagePackType Boolean;
    public static MessagePackType Float;
    public static MessagePackType String;
    public static MessagePackType Binary;
    public static MessagePackType Array;
    public static MessagePackType Map;
    public static MessagePackType Extension;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class MessagePack.MessagePackWriter : ValueType {
    private BufferWriter writer;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldSpec>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public bool OldSpec { get; public set; }
    [NullableContextAttribute("1")]
public MessagePackWriter(IBufferWriter`1<byte> writer);
    [NullableContextAttribute("1")]
internal MessagePackWriter(SequencePool sequencePool, Byte[] array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_OldSpec();
    [CompilerGeneratedAttribute]
public void set_OldSpec(bool value);
    [NullableContextAttribute("1")]
public MessagePackWriter Clone(IBufferWriter`1<byte> writer);
    public void Flush();
    public void WriteNil();
    public void WriteRaw(ReadOnlySpan`1<byte> rawMessagePackBlock);
    public void WriteRaw(ReadOnlySequence`1& rawMessagePackBlock);
    public void WriteArrayHeader(int count);
    public void WriteArrayHeader(UInt32 count);
    public void WriteMapHeader(int count);
    public void WriteMapHeader(UInt32 count);
    public void Write(byte value);
    public void WriteUInt8(byte value);
    public void Write(sbyte value);
    public void WriteInt8(sbyte value);
    public void Write(ushort value);
    public void WriteUInt16(ushort value);
    public void Write(short value);
    public void WriteInt16(short value);
    public void Write(UInt32 value);
    public void WriteUInt32(UInt32 value);
    public void Write(int value);
    public void WriteInt32(int value);
    public void Write(ulong value);
    public void WriteUInt64(ulong value);
    public void Write(long value);
    public void WriteInt64(long value);
    public void Write(bool value);
    public void Write(char value);
    public void Write(float value);
    public void Write(double value);
    public void Write(DateTime dateTime);
    [NullableContextAttribute("2")]
public void Write(Byte[] src);
    public void Write(ReadOnlySpan`1<byte> src);
    public void Write(ReadOnlySequence`1& src);
    public void WriteBinHeader(int length);
    public void WriteString(ReadOnlySequence`1& utf8stringBytes);
    public void WriteString(ReadOnlySpan`1<byte> utf8stringBytes);
    public void WriteStringHeader(int byteCount);
    [NullableContextAttribute("2")]
public void Write(string value);
    public void Write(ReadOnlySpan`1<char> value);
    public void WriteExtensionFormatHeader(ExtensionHeader extensionHeader);
    public void WriteExtensionFormat(ExtensionResult extensionData);
    public Span`1<byte> GetSpan(int length);
    public void Advance(int length);
    internal void WriteBigEndian(ushort value);
    internal void WriteBigEndian(UInt32 value);
    internal void WriteBigEndian(ulong value);
    [NullableContextAttribute("1")]
internal Byte[] FlushAndGetArray();
    private static void WriteBigEndian(short value, Span`1<byte> span);
    private static void WriteBigEndian(int value, Span`1<byte> span);
    private static void WriteBigEndian(long value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Byte* span);
    private static void WriteBigEndian(UInt32 value, Span`1<byte> span);
    private static void WriteBigEndian(UInt32 value, Byte* span);
    private static void WriteBigEndian(ulong value, Span`1<byte> span);
    private static void WriteBigEndian(float value, Span`1<byte> span);
    private static void WriteBigEndian(double value, Span`1<byte> span);
    private Byte& WriteString_PrepareSpan(int characterLength, Int32& bufferSize, Int32& encodedBytesOffset);
    private void WriteString_PostEncoding(Byte* pBuffer, int estimatedOffset, int byteCount);
    public static int GetEncodedLength(long value);
    public static int GetEncodedLength(ulong value);
}
internal class MessagePack.MonoProtection : ValueType {
    [NullableAttribute("1")]
private static object RefEmitLock;
    internal static bool IsRunningOnMono { get; }
    private static MonoProtection();
    internal static bool get_IsRunningOnMono();
    internal static MonoProtectionDisposal EnterRefEmitLock();
}
internal class MessagePack.MonoProtectionDisposal : ValueType {
    [NullableAttribute("1")]
private object lockObject;
    [NullableContextAttribute("1")]
internal MonoProtectionDisposal(object lockObject);
    public sealed virtual void Dispose();
}
public class MessagePack.Nil : ValueType {
    public static Nil Default;
    public static bool op_Equality(Nil left, Nil right);
    public static bool op_Inequality(Nil left, Nil right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Nil other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public static class MessagePack.ReservedExtensionTypeCodes : object {
    public static sbyte UnityVector2;
    public static sbyte UnityVector3;
    public static sbyte UnityVector4;
    public static sbyte UnityQuaternion;
    public static sbyte UnityColor;
    public static sbyte UnityBounds;
    public static sbyte UnityRect;
    public static sbyte UnityInt;
    public static sbyte UnityFloat;
    public static sbyte UnityDouble;
    public static sbyte Lz4BlockArray;
    public static sbyte Lz4Block;
    public static sbyte TypelessFormatter;
}
public static class MessagePack.ReservedMessagePackExtensionTypeCode : object {
    public static sbyte DateTime;
}
public class MessagePack.Resolvers.AttributeFormatterResolver : object {
    [NullableAttribute("1")]
public static AttributeFormatterResolver Instance;
    private static AttributeFormatterResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.BuiltinResolver : object {
    [NullableAttribute("1")]
public static BuiltinResolver Instance;
    private static BuiltinResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal abstract class MessagePack.Resolvers.CachingFormatterResolver : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadsafeTypeKeyHashTable`1<IMessagePackFormatter> formatters;
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    [NullableContextAttribute("2")]
protected abstract virtual IMessagePackFormatter`1<T> GetFormatterCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class MessagePack.Resolvers.CompositeResolver : object {
    private static ReadOnlyDictionary`2<Type, IMessagePackFormatter> EmptyFormattersByType;
    private static CompositeResolver();
    public static IFormatterResolver Create(IReadOnlyList`1<IMessagePackFormatter> formatters, IReadOnlyList`1<IFormatterResolver> resolvers);
    public static IFormatterResolver Create(IFormatterResolver[] resolvers);
    public static IFormatterResolver Create(IMessagePackFormatter[] formatters);
}
public class MessagePack.Resolvers.ContractlessStandardResolver : object {
    [NullableAttribute("1")]
public static ContractlessStandardResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    [NullableAttribute("1")]
private static IFormatterResolver[] Resolvers;
    private static ContractlessStandardResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.ContractlessStandardResolverAllowPrivate : object {
    [NullableAttribute("1")]
public static ContractlessStandardResolverAllowPrivate Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    [NullableAttribute("1")]
private static IFormatterResolver[] Resolvers;
    private static ContractlessStandardResolverAllowPrivate();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicContractlessObjectResolver : object {
    [NullableAttribute("1")]
public static DynamicContractlessObjectResolver Instance;
    [NullableAttribute("1")]
private static string ModuleName;
    [NullableAttribute("1")]
private static Lazy`1<DynamicAssembly> DynamicAssembly;
    private static DynamicContractlessObjectResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicContractlessObjectResolverAllowPrivate : object {
    [NullableAttribute("1")]
public static DynamicContractlessObjectResolverAllowPrivate Instance;
    private static DynamicContractlessObjectResolverAllowPrivate();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicEnumAsStringResolver : object {
    [NullableAttribute("1")]
public static DynamicEnumAsStringResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    private static DynamicEnumAsStringResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Resolvers.DynamicEnumResolver : object {
    public static DynamicEnumResolver Instance;
    private static string ModuleName;
    private static Lazy`1<DynamicAssembly> DynamicAssembly;
    private static int nameSequence;
    private static DynamicEnumResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static TypeInfo BuildType(Type enumType);
}
public class MessagePack.Resolvers.DynamicGenericResolver : object {
    [NullableAttribute("1")]
public static DynamicGenericResolver Instance;
    private static DynamicGenericResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Resolvers.DynamicObjectResolver : object {
    private static string ModuleName;
    public static DynamicObjectResolver Instance;
    public static MessagePackSerializerOptions Options;
    internal static Lazy`1<DynamicAssembly> DynamicAssembly;
    private static DynamicObjectResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicObjectResolverAllowPrivate : object {
    [NullableAttribute("1")]
public static DynamicObjectResolverAllowPrivate Instance;
    private static DynamicObjectResolverAllowPrivate();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Resolvers.DynamicUnionResolver : object {
    private static string ModuleName;
    public static DynamicUnionResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static Lazy`1<DynamicAssembly> DynamicAssembly;
    private static int nameSequence;
    private static Type refMessagePackReader;
    private static Type refKvp;
    private static MethodInfo getFormatterWithVerify;
    private static MethodInfo getResolverFromOptions;
    private static Func`2<Type, MethodInfo> getSerialize;
    private static Func`2<Type, MethodInfo> getDeserialize;
    private static FieldInfo runtimeTypeHandleEqualityComparer;
    private static ConstructorInfo intIntKeyValuePairConstructor;
    private static ConstructorInfo typeMapDictionaryConstructor;
    private static MethodInfo typeMapDictionaryAdd;
    private static MethodInfo typeMapDictionaryTryGetValue;
    private static ConstructorInfo keyMapDictionaryConstructor;
    private static MethodInfo keyMapDictionaryAdd;
    private static MethodInfo keyMapDictionaryTryGetValue;
    private static MethodInfo objectGetType;
    private static MethodInfo getTypeHandle;
    private static MethodInfo intIntKeyValuePairGetKey;
    private static MethodInfo intIntKeyValuePairGetValue;
    private static ConstructorInfo invalidOperationExceptionConstructor;
    private static ConstructorInfo objectCtor;
    private static DynamicUnionResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static TypeInfo BuildType(Type type);
    private static void BuildConstructor(Type type, UnionAttribute[] infos, ConstructorInfo method, FieldBuilder typeToKeyAndJumpMap, FieldBuilder keyToJumpMap, ILGenerator il);
    private static void BuildSerialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder typeToKeyAndJumpMap, ILGenerator il);
    private static void BuildDeserialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder keyToJumpMap, ILGenerator il);
    private static bool IsZeroStartSequential(UnionAttribute[] infos);
}
public static class MessagePack.Resolvers.ExpandoObjectResolver : object {
    [NullableAttribute("1")]
public static IFormatterResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    private static ExpandoObjectResolver();
}
internal class MessagePack.Resolvers.ForceSizePrimitiveObjectResolver : object {
    [NullableAttribute("1")]
public static ForceSizePrimitiveObjectResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    private static ForceSizePrimitiveObjectResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal class MessagePack.Resolvers.MessagePackDynamicUnionResolverException : MessagePackSerializationException {
    [NullableContextAttribute("1")]
public MessagePackDynamicUnionResolverException(string message);
}
public class MessagePack.Resolvers.NativeDateTimeResolver : object {
    [NullableAttribute("1")]
public static NativeDateTimeResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    private static NativeDateTimeResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.NativeDecimalResolver : object {
    [NullableAttribute("1")]
public static NativeDecimalResolver Instance;
    private static NativeDecimalResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    [NullableContextAttribute("1")]
private static object GetFormatterHelper(Type t);
}
public class MessagePack.Resolvers.NativeGuidResolver : object {
    [NullableAttribute("1")]
public static NativeGuidResolver Instance;
    private static NativeGuidResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    [NullableContextAttribute("1")]
private static object GetFormatterHelper(Type t);
}
public class MessagePack.Resolvers.PrimitiveObjectResolver : object {
    [NullableAttribute("1")]
public static PrimitiveObjectResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    private static PrimitiveObjectResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.SourceGeneratedFormatterResolver : object {
    [NullableAttribute("1")]
public static SourceGeneratedFormatterResolver Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<Assembly, IFormatterResolver> AssemblyResolverCache;
    private static SourceGeneratedFormatterResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.StandardResolver : object {
    [NullableAttribute("1")]
public static StandardResolver Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    [NullableAttribute("1")]
private static IFormatterResolver[] Resolvers;
    private static StandardResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.StandardResolverAllowPrivate : object {
    [NullableAttribute("1")]
public static StandardResolverAllowPrivate Instance;
    [NullableAttribute("1")]
public static MessagePackSerializerOptions Options;
    [NullableAttribute("1")]
private static IFormatterResolver[] Resolvers;
    private static StandardResolverAllowPrivate();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Resolvers.StaticCompositeResolver : object {
    public static StaticCompositeResolver Instance;
    private bool frozen;
    private IReadOnlyList`1<IMessagePackFormatter> formatters;
    private IReadOnlyList`1<IFormatterResolver> resolvers;
    private static StaticCompositeResolver();
    public void Register(IMessagePackFormatter[] formatters);
    public void Register(IFormatterResolver[] resolvers);
    public void Register(IReadOnlyList`1<IMessagePackFormatter> formatters, IReadOnlyList`1<IFormatterResolver> resolvers);
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.Resolvers.TypelessContractlessStandardResolver : object {
    public static TypelessContractlessStandardResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static IReadOnlyList`1<IFormatterResolver> Resolvers;
    private ResolverCache resolverCache;
    private static TypelessContractlessStandardResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.TypelessObjectResolver : object {
    [NullableAttribute("1")]
public static IFormatterResolver Instance;
    [NullableAttribute("1")]
private static IFormatterResolver[] Resolvers;
    private static TypelessObjectResolver();
    [NullableContextAttribute("2")]
public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal static class MessagePack.SafeBitConverter : object {
    internal static long ToInt64(ReadOnlySpan`1<byte> value);
    internal static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    internal static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    internal static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.SequencePool : object {
    internal static SequencePool Shared;
    private static int MinimumSpanLength;
    private int maxSize;
    private Stack`1<Sequence`1<byte>> pool;
    private ArrayPool`1<byte> arrayPool;
    public SequencePool(int maxSize);
    public SequencePool(int maxSize, ArrayPool`1<byte> arrayPool);
    private static SequencePool();
    internal Rental Rent();
    private void Return(Sequence`1<byte> value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.SequenceReader`1 : ValueType {
    private bool usingSequence;
    private ReadOnlySequence`1<T> sequence;
    private SequencePosition currentPosition;
    private SequencePosition nextPosition;
    private ReadOnlyMemory`1<T> memory;
    private bool moreData;
    private long length;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1& sequence);
    public SequenceReader`1(ReadOnlyMemory`1<T> memory);
    public bool get_End();
    public ReadOnlySequence`1<T> get_Sequence();
    public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    public long get_Remaining();
    public long get_Length();
    public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    internal bool TryAdvance(long count);
    private void AdvanceToNextSpan(long count);
    public bool TryCopyTo(Span`1<T> destination);
    internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
internal static class MessagePack.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryRead(SequenceReader`1& reader, SByte& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Single& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Double& value);
}
internal static class MessagePack.StringEncoding : object {
    [NullableAttribute("1")]
internal static Encoding UTF8;
    private static StringEncoding();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class MessagePack.TinyJsonException : MessagePackSerializationException {
    public TinyJsonException(string message);
    [ObsoleteAttribute]
protected TinyJsonException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class MessagePack.TinyJsonReader : object {
    [NullableAttribute("1")]
private TextReader reader;
    private bool disposeInnerReader;
    private StringBuilder reusableBuilder;
    [CompilerGeneratedAttribute]
private TinyJsonToken <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DoubleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LongValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ULongValue>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <DecimalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    public TinyJsonToken TokenType { get; private set; }
    public ValueType ValueType { get; private set; }
    public double DoubleValue { get; private set; }
    public long LongValue { get; private set; }
    public ulong ULongValue { get; private set; }
    public decimal DecimalValue { get; private set; }
    public string StringValue { get; private set; }
    [NullableContextAttribute("1")]
public TinyJsonReader(TextReader reader, bool disposeInnerReader);
    [CompilerGeneratedAttribute]
public TinyJsonToken get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(TinyJsonToken value);
    [CompilerGeneratedAttribute]
public ValueType get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(ValueType value);
    [CompilerGeneratedAttribute]
public double get_DoubleValue();
    [CompilerGeneratedAttribute]
private void set_DoubleValue(double value);
    [CompilerGeneratedAttribute]
public long get_LongValue();
    [CompilerGeneratedAttribute]
private void set_LongValue(long value);
    [CompilerGeneratedAttribute]
public ulong get_ULongValue();
    [CompilerGeneratedAttribute]
private void set_ULongValue(ulong value);
    [CompilerGeneratedAttribute]
public decimal get_DecimalValue();
    [CompilerGeneratedAttribute]
private void set_DecimalValue(decimal value);
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
private void set_StringValue(string value);
    public bool Read();
    public sealed virtual void Dispose();
    private void SkipWhiteSpace();
    private char ReadChar();
    private static bool IsWordBreak(char c);
    private void ReadNextToken();
    private void ReadValue();
    private void ReadNumber();
    private void ReadString();
}
internal enum MessagePack.TinyJsonToken : Enum {
    public int value__;
    public static TinyJsonToken None;
    public static TinyJsonToken StartObject;
    public static TinyJsonToken EndObject;
    public static TinyJsonToken StartArray;
    public static TinyJsonToken EndArray;
    public static TinyJsonToken Number;
    public static TinyJsonToken String;
    public static TinyJsonToken True;
    public static TinyJsonToken False;
    public static TinyJsonToken Null;
}
[ExtensionAttribute]
internal static class MessagePack.Utilities : object {
    [NullableContextAttribute("1")]
internal static Byte[] GetWriterBytes(TArg arg, GetWriterBytesAction`1<TArg> action, SequencePool pool);
    [ExtensionAttribute]
internal static Memory`1<byte> GetMemoryCheckResult(IBufferWriter`1<byte> bufferWriter, int size);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static NonGenericDictionaryEnumerable GetEntryEnumerator(IDictionary dictionary);
}
internal enum MessagePack.ValueType : Enum {
    public byte value__;
    public static ValueType Null;
    public static ValueType True;
    public static ValueType False;
    public static ValueType Double;
    public static ValueType Long;
    public static ValueType ULong;
    public static ValueType Decimal;
    public static ValueType String;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Nerdbank.Streams.Requires : object {
    [DebuggerStepThroughAttribute]
public static void Range(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static Exception FailRange(string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static T NotNull(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, object arg1);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, object arg1, object arg2);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Nerdbank.Streams.Sequence`1 : object {
    private static int MaximumAutoGrowSize;
    private static int DefaultLengthFromArrayPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ReadOnlySequence`1<T> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<SequenceSegment<T>> segmentPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MemoryPool`1<T> memoryPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayPool`1<T> arrayPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SequenceSegment<T> first;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SequenceSegment<T> last;
    [CompilerGeneratedAttribute]
private int <MinimumSpanLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoIncreaseMinimumSpanLength>k__BackingField;
    public int MinimumSpanLength { get; public set; }
    public bool AutoIncreaseMinimumSpanLength { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySequence`1<T> AsReadOnlySequence { get; }
    public long Length { get; }
    private string DebuggerDisplay { get; }
    public Sequence`1(MemoryPool`1<T> memoryPool);
    public Sequence`1(ArrayPool`1<T> arrayPool);
    private static Sequence`1();
    [CompilerGeneratedAttribute]
public int get_MinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_MinimumSpanLength(int value);
    [CompilerGeneratedAttribute]
public bool get_AutoIncreaseMinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_AutoIncreaseMinimumSpanLength(bool value);
    public ReadOnlySequence`1<T> get_AsReadOnlySequence();
    public long get_Length();
    private string get_DebuggerDisplay();
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1<T> sequence);
    public void AdvanceTo(SequencePosition position);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    public void Append(ReadOnlyMemory`1<T> memory);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    public void Reset();
    private SequenceSegment<T> GetSegment(int sizeHint);
    private void Append(SequenceSegment<T> segment);
    private SequenceSegment<T> RecycleAndGetNext(SequenceSegment<T> segment);
    private void ConsiderMinimumSizeIncrease();
}
internal static class Nerdbank.Streams.Verify : object {
    [NullableContextAttribute("1")]
[DebuggerStepThroughAttribute]
internal static void Operation(bool condition, string message);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.139.59561")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
