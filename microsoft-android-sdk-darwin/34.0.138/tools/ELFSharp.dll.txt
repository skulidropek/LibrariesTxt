public enum ELFSharp.ELF.Class : Enum {
    public int value__;
    public static Class Bit32;
    public static Class Bit64;
    public static Class NotELF;
}
public static class ELFSharp.ELF.Consts : object {
    public static string ObjectsStringTableName;
    public static string DynamicStringTableName;
    public static int SymbolEntrySize32;
    public static int SymbolEntrySize64;
    public static int MinimalELFSize;
}
public class ELFSharp.ELF.ELF`1 : object {
    [CompilerGeneratedAttribute]
private Endianess <Endianess>k__BackingField;
    [CompilerGeneratedAttribute]
private Class <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private FileType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private T <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private T <MachineFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private IStringTable <SectionsStringTable>k__BackingField;
    private SimpleEndianessAwareReader reader;
    private bool ownsStream;
    private long segmentHeaderOffset;
    private long sectionHeaderOffset;
    private ushort segmentHeaderEntrySize;
    private ushort segmentHeaderEntryCount;
    private ushort sectionHeaderEntrySize;
    private ushort sectionHeaderEntryCount;
    private ushort stringTableIndex;
    private List`1<Segment`1<T>> segments;
    private List`1<Section`1<T>> sections;
    private Dictionary`2<string, int> sectionIndicesByName;
    private List`1<SectionHeader> sectionHeaders;
    private StringTable`1<T> objectsStringTable;
    private StringTable`1<T> dynamicStringTable;
    private Stage<T> currentStage;
    private static int SectionNameNotUniqueMarker;
    public Endianess Endianess { get; private set; }
    public Class Class { get; private set; }
    public FileType Type { get; private set; }
    public Machine Machine { get; private set; }
    public T EntryPoint { get; private set; }
    public T MachineFlags { get; private set; }
    public bool HasSegmentHeader { get; }
    public bool HasSectionHeader { get; }
    public bool HasSectionsStringTable { get; }
    public IReadOnlyList`1<Segment`1<T>> Segments { get; }
    private IReadOnlyList`1<ISegment> ELFSharp.ELF.IELF.Segments { get; }
    public IStringTable SectionsStringTable { get; private set; }
    public IReadOnlyList`1<Section`1<T>> Sections { get; }
    private IReadOnlyList`1<ISection> ELFSharp.ELF.IELF.Sections { get; }
    internal ELF`1(Stream stream, bool ownsStream);
    [CompilerGeneratedAttribute]
public sealed virtual Endianess get_Endianess();
    [CompilerGeneratedAttribute]
private void set_Endianess(Endianess value);
    [CompilerGeneratedAttribute]
public sealed virtual Class get_Class();
    [CompilerGeneratedAttribute]
private void set_Class(Class value);
    [CompilerGeneratedAttribute]
public sealed virtual FileType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(FileType value);
    [CompilerGeneratedAttribute]
public sealed virtual Machine get_Machine();
    [CompilerGeneratedAttribute]
private void set_Machine(Machine value);
    [CompilerGeneratedAttribute]
public T get_EntryPoint();
    [CompilerGeneratedAttribute]
private void set_EntryPoint(T value);
    [CompilerGeneratedAttribute]
public T get_MachineFlags();
    [CompilerGeneratedAttribute]
private void set_MachineFlags(T value);
    public sealed virtual bool get_HasSegmentHeader();
    public sealed virtual bool get_HasSectionHeader();
    public sealed virtual bool get_HasSectionsStringTable();
    public IReadOnlyList`1<Segment`1<T>> get_Segments();
    private sealed virtual override IReadOnlyList`1<ISegment> ELFSharp.ELF.IELF.get_Segments();
    [CompilerGeneratedAttribute]
public sealed virtual IStringTable get_SectionsStringTable();
    [CompilerGeneratedAttribute]
private void set_SectionsStringTable(IStringTable value);
    public IReadOnlyList`1<Section`1<T>> get_Sections();
    private sealed virtual override IEnumerable`1<TSectionType> ELFSharp.ELF.IELF.GetSections();
    public IEnumerable`1<TSection> GetSections();
    private sealed virtual override IReadOnlyList`1<ISection> ELFSharp.ELF.IELF.get_Sections();
    public bool TryGetSection(string name, Section`1& section);
    public Section`1<T> GetSection(string name);
    private sealed virtual override bool ELFSharp.ELF.IELF.TryGetSection(string name, ISection& section);
    private sealed virtual override ISection ELFSharp.ELF.IELF.GetSection(string name);
    public Section`1<T> GetSection(int index);
    public virtual string ToString();
    private sealed virtual override bool ELFSharp.ELF.IELF.TryGetSection(int index, ISection& section);
    private sealed virtual override ISection ELFSharp.ELF.IELF.GetSection(int index);
    public sealed virtual void Dispose();
    private bool TryGetSection(int index, Section`1& section);
    private Section`1<T> GetSectionFromSectionHeader(SectionHeader header);
    private void ReadSegmentHeaders();
    private void ReadSections();
    private void TouchSection(int index);
    private void FindStringTables();
    private void ReadStringTable();
    private SectionHeader ReadSectionHeader(int index);
    private SimpleEndianessAwareReader ObtainEndianessAwareReader(Stream stream);
    private void ReadFields();
    private GetSectionResult<T> TryGetSectionInner(string name, Section`1& section);
    private GetSectionResult<T> TryGetSectionInner(int index, Section`1& section);
}
public static class ELFSharp.ELF.ELFReader : object {
    private static Byte[] Magic;
    private static string NotELFMessage;
    private static ELFReader();
    public static IELF Load(Stream stream, bool shouldOwnStream);
    public static IELF Load(string fileName);
    public static bool TryLoad(Stream stream, bool shouldOwnStream, IELF& elf);
    public static bool TryLoad(string fileName, IELF& elf);
    public static Class CheckELFType(Stream stream);
    public static Class CheckELFType(string fileName);
    public static ELF`1<T> Load(Stream stream, bool shouldOwnStream);
    public static ELF`1<T> Load(string fileName);
    public static bool TryLoad(Stream stream, bool shouldOwnStream, ELF`1& elf);
    public static bool TryLoad(string fileName, ELF`1& elf);
}
public enum ELFSharp.ELF.FileType : Enum {
    public ushort value__;
    public static FileType None;
    public static FileType Relocatable;
    public static FileType Executable;
    public static FileType SharedObject;
    public static FileType Core;
}
public interface ELFSharp.ELF.IELF {
    public Endianess Endianess { get; }
    public Class Class { get; }
    public FileType Type { get; }
    public Machine Machine { get; }
    public bool HasSegmentHeader { get; }
    public bool HasSectionHeader { get; }
    public bool HasSectionsStringTable { get; }
    public IReadOnlyList`1<ISegment> Segments { get; }
    public IStringTable SectionsStringTable { get; }
    public IReadOnlyList`1<ISection> Sections { get; }
    public abstract virtual Endianess get_Endianess();
    public abstract virtual Class get_Class();
    public abstract virtual FileType get_Type();
    public abstract virtual Machine get_Machine();
    public abstract virtual bool get_HasSegmentHeader();
    public abstract virtual bool get_HasSectionHeader();
    public abstract virtual bool get_HasSectionsStringTable();
    public abstract virtual IReadOnlyList`1<ISegment> get_Segments();
    public abstract virtual IStringTable get_SectionsStringTable();
    public abstract virtual IReadOnlyList`1<ISection> get_Sections();
    public abstract virtual IEnumerable`1<T> GetSections();
    public abstract virtual bool TryGetSection(string name, ISection& section);
    public abstract virtual ISection GetSection(string name);
    public abstract virtual bool TryGetSection(int index, ISection& section);
    public abstract virtual ISection GetSection(int index);
}
public enum ELFSharp.ELF.Machine : Enum {
    public ushort value__;
    public static Machine None;
    public static Machine M32;
    public static Machine SPARC;
    public static Machine Intel386;
    public static Machine M68K;
    public static Machine M88K;
    public static Machine Intel486;
    public static Machine Intel860;
    public static Machine MIPS;
    public static Machine S370;
    public static Machine MIPSRS3LE;
    public static Machine PARISC;
    public static Machine VPP500;
    public static Machine SPARC32Plus;
    public static Machine Intel960;
    public static Machine PPC;
    public static Machine PPC64;
    public static Machine S390;
    public static Machine SPU;
    public static Machine V800;
    public static Machine FR20;
    public static Machine RH32;
    public static Machine RCE;
    public static Machine ARM;
    public static Machine Alpha;
    public static Machine SuperH;
    public static Machine SPARCv9;
    public static Machine TriCore;
    public static Machine ARC;
    public static Machine H8300;
    public static Machine H8300H;
    public static Machine H8S;
    public static Machine H8500;
    public static Machine IA64;
    public static Machine MIPSX;
    public static Machine ColdFire;
    public static Machine M68HC12;
    public static Machine MMA;
    public static Machine PCP;
    public static Machine NCPU;
    public static Machine NDR1;
    public static Machine StarCore;
    public static Machine ME16;
    public static Machine ST100;
    public static Machine TinyJ;
    public static Machine AMD64;
    public static Machine PDSP;
    public static Machine PDP10;
    public static Machine PDP11;
    public static Machine FX66;
    public static Machine ST9PLUS;
    public static Machine ST7;
    public static Machine M68HC16;
    public static Machine M68HC11;
    public static Machine M68HC08;
    public static Machine M68HC05;
    public static Machine SVX;
    public static Machine ST19;
    public static Machine VAX;
    public static Machine CRIS;
    public static Machine Javelin;
    public static Machine FirePath;
    public static Machine ZSP;
    public static Machine MMIX;
    public static Machine HUANY;
    public static Machine PRISM;
    public static Machine AVR;
    public static Machine FR30;
    public static Machine D10V;
    public static Machine D30V;
    public static Machine V850;
    public static Machine M32R;
    public static Machine MN10300;
    public static Machine MN10200;
    public static Machine PicoJava;
    public static Machine OpenRISC;
    public static Machine ARCompact;
    public static Machine Xtensa;
    public static Machine VideoCore;
    public static Machine TMMGPP;
    public static Machine NS32K;
    public static Machine TPC;
    public static Machine SNP1k;
    public static Machine ST200;
    public static Machine IP2K;
    public static Machine MAX;
    public static Machine CompactRISC;
    public static Machine F2MC16;
    public static Machine MSP430;
    public static Machine Blackfin;
    public static Machine S1C33;
    public static Machine SEP;
    public static Machine ArcaRISC;
    public static Machine UNICORE;
    public static Machine Excess;
    public static Machine DXP;
    public static Machine AlteraNios2;
    public static Machine CRX;
    public static Machine XGATE;
    public static Machine C166;
    public static Machine M16C;
    public static Machine DSPIC30F;
    public static Machine EngineRISC;
    public static Machine M32C;
    public static Machine TSK3000;
    public static Machine RS08;
    public static Machine SHARC;
    public static Machine ECOG2;
    public static Machine Score7;
    public static Machine DSP24;
    public static Machine VideoCore3;
    public static Machine LatticeMico32;
    public static Machine SeikoEpsonC17;
    public static Machine TIC6000;
    public static Machine TIC2000;
    public static Machine TIC5500;
    public static Machine MMDSPPlus;
    public static Machine CypressM8C;
    public static Machine R32C;
    public static Machine TriMedia;
    public static Machine Hexagon;
    public static Machine Intel8051;
    public static Machine STxP7x;
    public static Machine NDS32;
    public static Machine ECOG1;
    public static Machine ECOG1X;
    public static Machine MAXQ30;
    public static Machine XIMO16;
    public static Machine MANIK;
    public static Machine CrayNV2;
    public static Machine RX;
    public static Machine METAG;
    public static Machine MCSTElbrus;
    public static Machine ECOG16;
    public static Machine CR16;
    public static Machine ETPU;
    public static Machine SLE9X;
    public static Machine L10M;
    public static Machine K10M;
    public static Machine AArch64;
    public static Machine AVR32;
    public static Machine STM8;
    public static Machine TILE64;
    public static Machine TILEPro;
    public static Machine CUDA;
    public static Machine TILEGx;
    public static Machine CloudShield;
    public static Machine CoreA1st;
    public static Machine CoreA2nd;
    public static Machine ARCompact2;
    public static Machine Open8;
    public static Machine RL78;
    public static Machine VideoCore5;
    public static Machine R78KOR;
    public static Machine F56800EX;
}
public class ELFSharp.ELF.Sections.DynamicEntry`1 : object {
    [CompilerGeneratedAttribute]
private DynamicTag <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public DynamicTag Tag { get; private set; }
    public T Value { get; private set; }
    public DynamicEntry`1(T tagValue, T value);
    [CompilerGeneratedAttribute]
public sealed virtual DynamicTag get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(DynamicTag value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public virtual string ToString();
}
public class ELFSharp.ELF.Sections.DynamicSection`1 : Section`1<T> {
    private List`1<DynamicEntry`1<T>> entries;
    private ELF`1<T> elf;
    public IEnumerable`1<DynamicEntry`1<T>> Entries { get; }
    private IEnumerable`1<IDynamicEntry> ELFSharp.ELF.Sections.IDynamicSection.Entries { get; }
    internal DynamicSection`1(SectionHeader header, SimpleEndianessAwareReader reader, ELF`1<T> elf);
    public IEnumerable`1<DynamicEntry`1<T>> get_Entries();
    private sealed virtual override IEnumerable`1<IDynamicEntry> ELFSharp.ELF.Sections.IDynamicSection.get_Entries();
    public virtual string ToString();
    private void ReadEntries();
}
public enum ELFSharp.ELF.Sections.DynamicTag : Enum {
    public ulong value__;
    public static DynamicTag Null;
    public static DynamicTag Needed;
    public static DynamicTag PLTRelSz;
    public static DynamicTag PLTGOT;
    public static DynamicTag Hash;
    public static DynamicTag StrTab;
    public static DynamicTag SymTab;
    public static DynamicTag RelA;
    public static DynamicTag RelASz;
    public static DynamicTag RelAEnt;
    public static DynamicTag StrSz;
    public static DynamicTag SymEnt;
    public static DynamicTag Init;
    public static DynamicTag Fini;
    public static DynamicTag SoName;
    public static DynamicTag RPath;
    public static DynamicTag Symbolic;
    public static DynamicTag Rel;
    public static DynamicTag RelSz;
    public static DynamicTag RelEnt;
    public static DynamicTag PLTRel;
    public static DynamicTag Debug;
    public static DynamicTag TextRel;
    public static DynamicTag JmpRel;
    public static DynamicTag BindNow;
    public static DynamicTag InitArray;
    public static DynamicTag FiniArray;
    public static DynamicTag InitArraySz;
    public static DynamicTag FiniArraySz;
    public static DynamicTag RunPath;
    public static DynamicTag Flags;
    public static DynamicTag Encoding;
    public static DynamicTag PreInitArray;
    public static DynamicTag PreInitArraySz;
    public static DynamicTag LoOS;
    public static DynamicTag HiOS;
    public static DynamicTag LoProc;
    public static DynamicTag HiProc;
    public static DynamicTag GNUHash;
    public static DynamicTag TLSDescPLT;
    public static DynamicTag TLSDescGOT;
    public static DynamicTag RelACount;
    public static DynamicTag RelCount;
    public static DynamicTag Flags1;
    public static DynamicTag VerSym;
    public static DynamicTag VerDef;
    public static DynamicTag VerDefNum;
    public static DynamicTag VerNeed;
    public static DynamicTag VerNeedNum;
}
public interface ELFSharp.ELF.Sections.IDynamicEntry {
    public DynamicTag Tag { get; }
    public abstract virtual DynamicTag get_Tag();
}
public interface ELFSharp.ELF.Sections.IDynamicSection {
    public IEnumerable`1<IDynamicEntry> Entries { get; }
    public abstract virtual IEnumerable`1<IDynamicEntry> get_Entries();
}
public interface ELFSharp.ELF.Sections.INoteSection {
    public string NoteName { get; }
    public Byte[] Description { get; }
    public abstract virtual string get_NoteName();
    public abstract virtual Byte[] get_Description();
}
public interface ELFSharp.ELF.Sections.IProgBitsSection {
    public abstract virtual void WriteContents(Byte[] destination, int offset, int length);
}
public interface ELFSharp.ELF.Sections.ISection {
    public string Name { get; }
    public UInt32 NameIndex { get; }
    public SectionType Type { get; }
    public SectionFlags Flags { get; }
    public abstract virtual Byte[] GetContents();
    public abstract virtual string get_Name();
    public abstract virtual UInt32 get_NameIndex();
    public abstract virtual SectionType get_Type();
    public abstract virtual SectionFlags get_Flags();
}
[DefaultMemberAttribute("Item")]
public interface ELFSharp.ELF.Sections.IStringTable {
    public string Item { get; }
    public IEnumerable`1<string> Strings { get; }
    public abstract virtual string get_Item(long index);
    public abstract virtual IEnumerable`1<string> get_Strings();
}
public interface ELFSharp.ELF.Sections.ISymbolEntry {
    public string Name { get; }
    public SymbolBinding Binding { get; }
    public SymbolType Type { get; }
    public SymbolVisibility Visibility { get; }
    public bool IsPointedIndexSpecial { get; }
    public ISection PointedSection { get; }
    public ushort PointedSectionIndex { get; }
    public abstract virtual string get_Name();
    public abstract virtual SymbolBinding get_Binding();
    public abstract virtual SymbolType get_Type();
    public abstract virtual SymbolVisibility get_Visibility();
    public abstract virtual bool get_IsPointedIndexSpecial();
    public abstract virtual ISection get_PointedSection();
    public abstract virtual ushort get_PointedSectionIndex();
}
public interface ELFSharp.ELF.Sections.ISymbolTable {
    public IEnumerable`1<ISymbolEntry> Entries { get; }
    public abstract virtual IEnumerable`1<ISymbolEntry> get_Entries();
}
internal class ELFSharp.ELF.Sections.NoteData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Type>k__BackingField;
    private SimpleEndianessAwareReader reader;
    internal string Name { get; private set; }
    internal Byte[] Description { get; private set; }
    internal ulong Type { get; private set; }
    private int FieldSize { get; }
    internal NoteData(ulong sectionOffset, ulong sectionSize, SimpleEndianessAwareReader reader);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(Byte[] value);
    [CompilerGeneratedAttribute]
internal ulong get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ulong value);
    private int ReadSize();
    private ulong ReadField();
    private int get_FieldSize();
}
public class ELFSharp.ELF.Sections.NoteSection`1 : Section`1<T> {
    private NoteData data;
    public string NoteName { get; }
    public Byte[] Description { get; }
    public T NoteType { get; }
    internal NoteSection`1(SectionHeader header, SimpleEndianessAwareReader reader);
    public sealed virtual string get_NoteName();
    public sealed virtual Byte[] get_Description();
    public virtual string ToString();
    public T get_NoteType();
}
public class ELFSharp.ELF.Sections.ProgBitsSection`1 : Section`1<T> {
    private static int BufferSize;
    internal ProgBitsSection`1(SectionHeader header, SimpleEndianessAwareReader reader);
    public sealed virtual void WriteContents(Byte[] destination, int offset, int length);
}
public class ELFSharp.ELF.Sections.Section`1 : object {
    [CompilerGeneratedAttribute]
private SectionHeader <Header>k__BackingField;
    protected SimpleEndianessAwareReader Reader;
    public string Name { get; }
    public UInt32 NameIndex { get; }
    public SectionType Type { get; }
    public SectionFlags Flags { get; }
    public T RawFlags { get; }
    public T LoadAddress { get; }
    public T Alignment { get; }
    public T EntrySize { get; }
    public T Size { get; }
    public T Offset { get; }
    internal SectionHeader Header { get; private set; }
    internal Section`1(SectionHeader header, SimpleEndianessAwareReader reader);
    public virtual Byte[] GetContents();
    public sealed virtual string get_Name();
    public sealed virtual UInt32 get_NameIndex();
    public sealed virtual SectionType get_Type();
    public sealed virtual SectionFlags get_Flags();
    public T get_RawFlags();
    public T get_LoadAddress();
    public T get_Alignment();
    public T get_EntrySize();
    public T get_Size();
    public T get_Offset();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal SectionHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(SectionHeader value);
    protected void SeekToSectionBeginning();
}
[FlagsAttribute]
public enum ELFSharp.ELF.Sections.SectionFlags : Enum {
    public int value__;
    public static SectionFlags Writable;
    public static SectionFlags Allocatable;
    public static SectionFlags Executable;
}
internal class ELFSharp.ELF.Sections.SectionHeader : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NameIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RawFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EntrySize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Link>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Info>k__BackingField;
    private SimpleEndianessAwareReader reader;
    private IStringTable table;
    private Class elfClass;
    internal string Name { get; private set; }
    internal UInt32 NameIndex { get; private set; }
    internal SectionType Type { get; private set; }
    internal SectionFlags Flags { get; private set; }
    internal ulong RawFlags { get; private set; }
    internal ulong LoadAddress { get; private set; }
    internal ulong Alignment { get; private set; }
    internal ulong EntrySize { get; private set; }
    internal ulong Size { get; private set; }
    internal ulong Offset { get; private set; }
    internal UInt32 Link { get; private set; }
    internal UInt32 Info { get; private set; }
    internal SectionHeader(SimpleEndianessAwareReader reader, Class elfClass, IStringTable table);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
internal UInt32 get_NameIndex();
    [CompilerGeneratedAttribute]
private void set_NameIndex(UInt32 value);
    [CompilerGeneratedAttribute]
internal SectionType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SectionType value);
    [CompilerGeneratedAttribute]
internal SectionFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(SectionFlags value);
    [CompilerGeneratedAttribute]
internal ulong get_RawFlags();
    [CompilerGeneratedAttribute]
private void set_RawFlags(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_LoadAddress();
    [CompilerGeneratedAttribute]
private void set_LoadAddress(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_Alignment();
    [CompilerGeneratedAttribute]
private void set_Alignment(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_EntrySize();
    [CompilerGeneratedAttribute]
private void set_EntrySize(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ulong value);
    [CompilerGeneratedAttribute]
internal ulong get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(ulong value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Link();
    [CompilerGeneratedAttribute]
private void set_Link(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Info();
    [CompilerGeneratedAttribute]
private void set_Info(UInt32 value);
    public virtual string ToString();
    private void ReadSectionHeader();
    private ulong ReadAddress();
    private ulong ReadOffset();
}
public enum ELFSharp.ELF.Sections.SectionType : Enum {
    public UInt32 value__;
    public static SectionType Null;
    public static SectionType ProgBits;
    public static SectionType SymbolTable;
    public static SectionType StringTable;
    public static SectionType RelocationAddends;
    public static SectionType HashTable;
    public static SectionType Dynamic;
    public static SectionType Note;
    public static SectionType NoBits;
    public static SectionType Relocation;
    public static SectionType Shlib;
    public static SectionType DynamicSymbolTable;
}
public enum ELFSharp.ELF.Sections.SpecialSectionIndex : Enum {
    public ushort value__;
    public static SpecialSectionIndex Absolute;
    public static SpecialSectionIndex Common;
    public static SpecialSectionIndex Undefined;
}
public enum ELFSharp.ELF.Sections.SpecialSectionType : Enum {
    public int value__;
    public static SpecialSectionType Null;
    public static SpecialSectionType ProgBits;
    public static SpecialSectionType NoBits;
    public static SpecialSectionType Shlib;
    public static SpecialSectionType ProcessorSpecific;
    public static SpecialSectionType UserSpecific;
}
[DefaultMemberAttribute("Item")]
public class ELFSharp.ELF.Sections.StringTable`1 : Section`1<T> {
    private Dictionary`2<long, string> stringCache;
    private Byte[] stringBlob;
    private bool cachePopulated;
    public IEnumerable`1<string> Strings { get; }
    public string Item { get; }
    internal StringTable`1(SectionHeader header, SimpleEndianessAwareReader reader);
    public sealed virtual IEnumerable`1<string> get_Strings();
    public sealed virtual string get_Item(long index);
    private string HandleUnexpectedIndex(long index);
    private void PrepopulateCache();
    private Byte[] ReadStringData();
}
public enum ELFSharp.ELF.Sections.SymbolBinding : Enum {
    public int value__;
    public static SymbolBinding Local;
    public static SymbolBinding Global;
    public static SymbolBinding Weak;
    public static SymbolBinding ProcessorSpecific;
}
public class ELFSharp.ELF.Sections.SymbolEntry`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolVisibility <Visibility>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <PointedSectionIndex>k__BackingField;
    private ELF`1<T> elf;
    public string Name { get; }
    public SymbolBinding Binding { get; }
    public SymbolType Type { get; }
    public T Value { get; }
    public T Size { get; }
    public SymbolVisibility Visibility { get; }
    public bool IsPointedIndexSpecial { get; }
    public Section`1<T> PointedSection { get; }
    private ISection ELFSharp.ELF.Sections.ISymbolEntry.PointedSection { get; }
    public ushort PointedSectionIndex { get; }
    public SpecialSectionIndex SpecialPointedSectionIndex { get; }
    public SymbolEntry`1(string name, T value, T size, SymbolVisibility visibility, SymbolBinding binding, SymbolType type, ELF`1<T> elf, ushort sectionIdx);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual SymbolBinding get_Binding();
    [CompilerGeneratedAttribute]
public sealed virtual SymbolType get_Type();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public T get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual SymbolVisibility get_Visibility();
    public sealed virtual bool get_IsPointedIndexSpecial();
    public Section`1<T> get_PointedSection();
    private sealed virtual override ISection ELFSharp.ELF.Sections.ISymbolEntry.get_PointedSection();
    [CompilerGeneratedAttribute]
public sealed virtual ushort get_PointedSectionIndex();
    public SpecialSectionIndex get_SpecialPointedSectionIndex();
    public virtual string ToString();
}
public class ELFSharp.ELF.Sections.SymbolTable`1 : Section`1<T> {
    private List`1<SymbolEntry`1<T>> entries;
    private IStringTable table;
    private ELF`1<T> elf;
    public IEnumerable`1<SymbolEntry`1<T>> Entries { get; }
    private IEnumerable`1<ISymbolEntry> ELFSharp.ELF.Sections.ISymbolTable.Entries { get; }
    internal SymbolTable`1(SectionHeader header, SimpleEndianessAwareReader Reader, IStringTable table, ELF`1<T> elf);
    public IEnumerable`1<SymbolEntry`1<T>> get_Entries();
    private sealed virtual override IEnumerable`1<ISymbolEntry> ELFSharp.ELF.Sections.ISymbolTable.get_Entries();
    private void ReadSymbols();
}
public enum ELFSharp.ELF.Sections.SymbolType : Enum {
    public int value__;
    public static SymbolType NotSpecified;
    public static SymbolType Object;
    public static SymbolType Function;
    public static SymbolType Section;
    public static SymbolType File;
    public static SymbolType ProcessorSpecific;
}
public enum ELFSharp.ELF.Sections.SymbolVisibility : Enum {
    public byte value__;
    public static SymbolVisibility Default;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Hidden;
    public static SymbolVisibility Protected;
}
public interface ELFSharp.ELF.Segments.INoteSegment {
    public string NoteName { get; }
    public ulong NoteType { get; }
    public Byte[] NoteDescription { get; }
    public abstract virtual string get_NoteName();
    public abstract virtual ulong get_NoteType();
    public abstract virtual Byte[] get_NoteDescription();
}
public interface ELFSharp.ELF.Segments.ISegment {
    public SegmentType Type { get; }
    public SegmentFlags Flags { get; }
    public abstract virtual SegmentType get_Type();
    public abstract virtual SegmentFlags get_Flags();
    public abstract virtual Byte[] GetRawHeader();
    public abstract virtual Byte[] GetFileContents();
    public abstract virtual Byte[] GetMemoryContents();
}
public class ELFSharp.ELF.Segments.NoteSegment`1 : Segment`1<T> {
    private NoteData data;
    public string NoteName { get; }
    public ulong NoteType { get; }
    public Byte[] NoteDescription { get; }
    internal NoteSegment`1(long headerOffset, Class elfClass, SimpleEndianessAwareReader reader);
    public sealed virtual string get_NoteName();
    public sealed virtual ulong get_NoteType();
    public sealed virtual Byte[] get_NoteDescription();
}
public class ELFSharp.ELF.Segments.Segment`1 : object {
    [CompilerGeneratedAttribute]
private SegmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private T <PhysicalAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    private long headerOffset;
    private Class elfClass;
    private SimpleEndianessAwareReader reader;
    public SegmentType Type { get; private set; }
    public SegmentFlags Flags { get; private set; }
    public T Address { get; private set; }
    public T PhysicalAddress { get; private set; }
    public T Size { get; private set; }
    public T Alignment { get; private set; }
    public long FileSize { get; private set; }
    public long Offset { get; private set; }
    internal Segment`1(long headerOffset, Class elfClass, SimpleEndianessAwareReader reader);
    [CompilerGeneratedAttribute]
public sealed virtual SegmentType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SegmentType value);
    [CompilerGeneratedAttribute]
public sealed virtual SegmentFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(SegmentFlags value);
    [CompilerGeneratedAttribute]
public T get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(T value);
    [CompilerGeneratedAttribute]
public T get_PhysicalAddress();
    [CompilerGeneratedAttribute]
private void set_PhysicalAddress(T value);
    [CompilerGeneratedAttribute]
public T get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(T value);
    [CompilerGeneratedAttribute]
public T get_Alignment();
    [CompilerGeneratedAttribute]
private void set_Alignment(T value);
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
private void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public long get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(long value);
    public static SegmentType ProbeType(SimpleEndianessAwareReader reader);
    public sealed virtual Byte[] GetFileContents();
    public sealed virtual Byte[] GetMemoryContents();
    public sealed virtual Byte[] GetRawHeader();
    public virtual string ToString();
    private void ReadHeader();
    private void SeekTo(long givenOffset);
}
[FlagsAttribute]
public enum ELFSharp.ELF.Segments.SegmentFlags : Enum {
    public UInt32 value__;
    public static SegmentFlags Execute;
    public static SegmentFlags Write;
    public static SegmentFlags Read;
}
public enum ELFSharp.ELF.Segments.SegmentType : Enum {
    public UInt32 value__;
    public static SegmentType Null;
    public static SegmentType Load;
    public static SegmentType Dynamic;
    public static SegmentType Interpreter;
    public static SegmentType Note;
    public static SegmentType SharedLibrary;
    public static SegmentType ProgramHeader;
}
[ExtensionAttribute]
internal static class ELFSharp.ELF.Utilities : object {
    [ExtensionAttribute]
internal static T To(object source);
}
public enum ELFSharp.Endianess : Enum {
    public int value__;
    public static Endianess LittleEndian;
    public static Endianess BigEndian;
}
public class ELFSharp.MachO.Command : object {
    protected SimpleEndianessAwareReader Reader;
    protected Stream Stream;
    internal Command(SimpleEndianessAwareReader reader, Stream stream);
}
public enum ELFSharp.MachO.CommandType : Enum {
    public UInt32 value__;
    public static CommandType Segment;
    public static CommandType SymbolTable;
    public static CommandType LoadDylib;
    public static CommandType IdDylib;
    public static CommandType LoadWeakDylib;
    public static CommandType Segment64;
    public static CommandType ReexportDylib;
    public static CommandType Main;
}
public abstract class ELFSharp.MachO.Dylib : Command {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <CompatibilityVersion>k__BackingField;
    public string Name { get; }
    public DateTime Timestamp { get; }
    public Version CurrentVersion { get; }
    public Version CompatibilityVersion { get; }
    internal Dylib(SimpleEndianessAwareReader reader, Stream stream, UInt32 commandSize);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public Version get_CurrentVersion();
    [CompilerGeneratedAttribute]
public Version get_CompatibilityVersion();
    private static Version GetVersion(UInt32 version);
    private static string GetString(Byte[] bytes);
}
public class ELFSharp.MachO.EntryPoint : Command {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StackSize>k__BackingField;
    public long Value { get; private set; }
    public long StackSize { get; private set; }
    public EntryPoint(SimpleEndianessAwareReader reader, Stream stream);
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(long value);
    [CompilerGeneratedAttribute]
public long get_StackSize();
    [CompilerGeneratedAttribute]
private void set_StackSize(long value);
}
internal static class ELFSharp.MachO.FatArchiveReader : object {
    [IteratorStateMachineAttribute("ELFSharp.MachO.FatArchiveReader/<Enumerate>d__0")]
public static IEnumerable`1<MachO> Enumerate(Stream stream, bool shouldOwnStream);
}
public enum ELFSharp.MachO.FileType : Enum {
    public UInt32 value__;
    public static FileType Object;
    public static FileType Executable;
    public static FileType FixedVM;
    public static FileType Core;
    public static FileType Preload;
    public static FileType DynamicLibrary;
    public static FileType DynamicLinker;
    public static FileType Bundle;
    public static FileType DynamicLibraryStub;
    public static FileType Debug;
    public static FileType Kext;
}
[FlagsAttribute]
public enum ELFSharp.MachO.HeaderFlags : Enum {
    public UInt32 value__;
    public static HeaderFlags NoUndefs;
    public static HeaderFlags IncrLink;
    public static HeaderFlags DyldLink;
    public static HeaderFlags BindAtLoad;
    public static HeaderFlags Prebound;
    public static HeaderFlags SplitSeg;
    public static HeaderFlags LazyInit;
    public static HeaderFlags TwoLevel;
    public static HeaderFlags ForceFlat;
    public static HeaderFlags NoMultiDefs;
    public static HeaderFlags NoFixPrebinding;
    public static HeaderFlags Prebindable;
    public static HeaderFlags AllModsBound;
    public static HeaderFlags SubsectionsViaSymbols;
    public static HeaderFlags Canonical;
    public static HeaderFlags WeakDefines;
    public static HeaderFlags BindsToWeak;
    public static HeaderFlags AllowStackExecution;
    public static HeaderFlags RootSafe;
    public static HeaderFlags SetuidSafe;
    public static HeaderFlags NoReexportedDylibs;
    public static HeaderFlags PIE;
    public static HeaderFlags DeadStrippableDylib;
    public static HeaderFlags HasTLVDescriptors;
    public static HeaderFlags NoHeapExecution;
    public static HeaderFlags AppExtensionSafe;
}
public class ELFSharp.MachO.IdDylib : Dylib {
    public IdDylib(SimpleEndianessAwareReader reader, Stream stream, UInt32 commandSize);
}
public class ELFSharp.MachO.LoadDylib : Dylib {
    public LoadDylib(SimpleEndianessAwareReader reader, Stream stream, UInt32 commandSize);
}
public class ELFSharp.MachO.LoadWeakDylib : Dylib {
    public LoadWeakDylib(SimpleEndianessAwareReader reader, Stream stream, UInt32 commandSize);
}
public enum ELFSharp.MachO.Machine : Enum {
    public int value__;
    public static Machine Any;
    public static Machine Vax;
    public static Machine M68k;
    public static Machine X86;
    public static Machine X86_64;
    public static Machine M98k;
    public static Machine PaRisc;
    public static Machine Arm;
    public static Machine Arm64;
    public static Machine M88k;
    public static Machine Sparc;
    public static Machine I860;
    public static Machine PowerPc;
    public static Machine PowerPc64;
}
public class ELFSharp.MachO.MachO : object {
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private FileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFlags <Flags>k__BackingField;
    private bool is64;
    private Command[] commands;
    internal static int Architecture64;
    public Machine Machine { get; private set; }
    public FileType FileType { get; private set; }
    public HeaderFlags Flags { get; private set; }
    public bool Is64 { get; }
    internal MachO(Stream stream, bool is64, Endianess endianess, bool ownsStream);
    public IEnumerable`1<T> GetCommandsOfType();
    [CompilerGeneratedAttribute]
public Machine get_Machine();
    [CompilerGeneratedAttribute]
private void set_Machine(Machine value);
    [CompilerGeneratedAttribute]
public FileType get_FileType();
    [CompilerGeneratedAttribute]
private void set_FileType(FileType value);
    [CompilerGeneratedAttribute]
public HeaderFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(HeaderFlags value);
    public bool get_Is64();
    private void ReadCommands(int noOfCommands, Stream stream, SimpleEndianessAwareReader reader);
}
public static class ELFSharp.MachO.MachOReader : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IReadOnlyDictionary`2<UInt32, ValueTuple`2<bool, Endianess>> MagicToMachOType;
    private static UInt32 FatMagic;
    private static string FatArchiveErrorMessage;
    private static string NotMachOErrorMessage;
    private static MachOReader();
    public static MachO Load(string fileName);
    public static MachO Load(Stream stream, bool shouldOwnStream);
    public static IReadOnlyList`1<MachO> LoadFat(Stream stream, bool shouldOwnStream);
    public static MachOResult TryLoad(string fileName, MachO& machO);
    public static MachOResult TryLoad(Stream stream, bool shouldOwnStream, MachO& machO);
    public static MachOResult TryLoadFat(Stream stream, bool shouldOwnStream, IReadOnlyList`1& machOs);
}
public enum ELFSharp.MachO.MachOResult : Enum {
    public int value__;
    public static MachOResult OK;
    public static MachOResult NotMachO;
    public static MachOResult FatMachO;
}
[FlagsAttribute]
public enum ELFSharp.MachO.Protection : Enum {
    public int value__;
    public static Protection Read;
    public static Protection Write;
    public static Protection Execute;
}
public class ELFSharp.MachO.ReexportDylib : Dylib {
    public ReexportDylib(SimpleEndianessAwareReader reader, Stream stream, UInt32 commandSize);
}
[DebuggerDisplayAttribute("Section({segment.Name,nq},{Name,nq})")]
public class ELFSharp.MachO.Section : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentName>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AlignExponent>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelocOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelocCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    private Segment segment;
    public string Name { get; private set; }
    public string SegmentName { get; private set; }
    public ulong Address { get; private set; }
    public ulong Size { get; private set; }
    public UInt32 Offset { get; private set; }
    public UInt32 AlignExponent { get; private set; }
    public UInt32 RelocOffset { get; private set; }
    public UInt32 RelocCount { get; private set; }
    public UInt32 Flags { get; private set; }
    public Section(string name, string segmentName, ulong address, ulong size, UInt32 offset, UInt32 alignExponent, UInt32 relocOffset, UInt32 numberOfReloc, UInt32 flags, Segment segment);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_SegmentName();
    [CompilerGeneratedAttribute]
private void set_SegmentName(string value);
    [CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ulong value);
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_AlignExponent();
    [CompilerGeneratedAttribute]
private void set_AlignExponent(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_RelocOffset();
    [CompilerGeneratedAttribute]
private void set_RelocOffset(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_RelocCount();
    [CompilerGeneratedAttribute]
private void set_RelocCount(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(UInt32 value);
    public Byte[] GetData();
}
[DebuggerDisplayAttribute("{Type}({Name,nq})")]
public class ELFSharp.MachO.Segment : Command {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Protection <InitialProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private Protection <MaximalProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Section> <Sections>k__BackingField;
    private bool is64;
    private Byte[] data;
    public string Name { get; private set; }
    public ulong Address { get; private set; }
    public ulong Size { get; private set; }
    public ulong FileOffset { get; private set; }
    public Protection InitialProtection { get; private set; }
    public Protection MaximalProtection { get; private set; }
    public ReadOnlyCollection`1<Section> Sections { get; private set; }
    private CommandType Type { get; }
    public Segment(SimpleEndianessAwareReader reader, Stream stream, MachO machO);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
private void set_FileOffset(ulong value);
    [CompilerGeneratedAttribute]
public Protection get_InitialProtection();
    [CompilerGeneratedAttribute]
private void set_InitialProtection(Protection value);
    [CompilerGeneratedAttribute]
public Protection get_MaximalProtection();
    [CompilerGeneratedAttribute]
private void set_MaximalProtection(Protection value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Section> get_Sections();
    [CompilerGeneratedAttribute]
private void set_Sections(ReadOnlyCollection`1<Section> value);
    private CommandType get_Type();
    public Byte[] GetData();
    private ulong ReadUInt32OrUInt64();
    private Protection ReadProtection();
    private string ReadSectionOrSegmentName();
}
[DebuggerDisplayAttribute("Symbol({Name,nq},{Value})")]
public class ELFSharp.MachO.Symbol : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public string Name { get; private set; }
    public long Value { get; private set; }
    public Symbol(string name, long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(long value);
}
public class ELFSharp.MachO.SymbolTable : Command {
    private Symbol[] symbols;
    private bool is64;
    public IEnumerable`1<Symbol> Symbols { get; }
    public SymbolTable(SimpleEndianessAwareReader reader, Stream stream, bool is64);
    public IEnumerable`1<Symbol> get_Symbols();
    private void ReadSymbols();
    private string ReadStringFromOffset(int offset);
}
public enum ELFSharp.UImage.Architecture : Enum {
    public byte value__;
    public static Architecture Invalid;
    public static Architecture Alpha;
    public static Architecture ARM;
    public static Architecture Ix86;
    public static Architecture Itanium;
    public static Architecture MIPS;
    public static Architecture MIPS64;
    public static Architecture PowerPC;
    public static Architecture S390;
    public static Architecture SuperH;
    public static Architecture SPARC;
    public static Architecture SPARC64;
    public static Architecture M68k;
    public static Architecture MicroBlaze;
    public static Architecture Nios2;
    public static Architecture Blackfin;
    public static Architecture AVR32;
    public static Architecture ST200;
    public static Architecture Sandbox;
    public static Architecture NDS32;
    public static Architecture OpenRISC;
}
public enum ELFSharp.UImage.CompressionType : Enum {
    public byte value__;
    public static CompressionType None;
    public static CompressionType Gzip;
    public static CompressionType Bzip2;
    public static CompressionType Lzma;
    public static CompressionType Lzo;
}
public enum ELFSharp.UImage.ImageDataResult : Enum {
    public int value__;
    public static ImageDataResult OK;
    public static ImageDataResult BadChecksum;
    public static ImageDataResult UnsupportedCompressionFormat;
}
public enum ELFSharp.UImage.ImageType : Enum {
    public byte value__;
    public static ImageType Standalone;
    public static ImageType Kernel;
}
public enum ELFSharp.UImage.OS : Enum {
    public byte value__;
    public static OS Invalid;
    public static OS OpenBSD;
    public static OS NetBSD;
    public static OS FreeBSD;
    public static OS BSD44;
    public static OS Linux;
    public static OS SVR4;
    public static OS Esix;
    public static OS Solaris;
    public static OS Irix;
    public static OS SCO;
    public static OS Dell;
    public static OS NCR;
    public static OS LynxOS;
    public static OS VxWorks;
    public static OS PSOS;
    public static OS QNX;
    public static OS Firmware;
    public static OS RTEMS;
    public static OS ARTOS;
    public static OS UnityOS;
    public static OS INTEGRITY;
    public static OS OSE;
    public static OS Plan9;
}
public class ELFSharp.UImage.UImage : object {
    [CompilerGeneratedAttribute]
private UInt32 <CRC>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecksumOK>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionType <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private OS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    private static int MaximumNameLength;
    private Byte[] image;
    private bool shouldOwnStream;
    public UInt32 CRC { get; private set; }
    public bool IsChecksumOK { get; private set; }
    public UInt32 Size { get; private set; }
    public UInt32 LoadAddress { get; private set; }
    public UInt32 EntryPoint { get; private set; }
    public string Name { get; private set; }
    public DateTime Timestamp { get; private set; }
    public CompressionType Compression { get; private set; }
    public ImageType Type { get; private set; }
    public OS OperatingSystem { get; private set; }
    public Architecture Architecture { get; private set; }
    internal UImage(Stream stream, bool ownsStream);
    [CompilerGeneratedAttribute]
public UInt32 get_CRC();
    [CompilerGeneratedAttribute]
private void set_CRC(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsChecksumOK();
    [CompilerGeneratedAttribute]
private void set_IsChecksumOK(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LoadAddress();
    [CompilerGeneratedAttribute]
private void set_LoadAddress(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EntryPoint();
    [CompilerGeneratedAttribute]
private void set_EntryPoint(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public CompressionType get_Compression();
    [CompilerGeneratedAttribute]
private void set_Compression(CompressionType value);
    [CompilerGeneratedAttribute]
public ImageType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ImageType value);
    [CompilerGeneratedAttribute]
public OS get_OperatingSystem();
    [CompilerGeneratedAttribute]
private void set_OperatingSystem(OS value);
    [CompilerGeneratedAttribute]
public Architecture get_Architecture();
    [CompilerGeneratedAttribute]
private void set_Architecture(Architecture value);
    public ImageDataResult TryGetImageData(Byte[]& result);
    public Byte[] GetImageData();
    public Byte[] GetRawImageData();
}
[ExtensionAttribute]
public static class ELFSharp.UImage.UImageReader : object {
    private static UInt32 Magic;
    private static UInt32 Polynomial;
    private static UInt32 Seed;
    public static UImage Load(string fileName);
    public static UImage Load(Stream stream, bool shouldOwnStream);
    public static UImageResult TryLoad(string fileName, UImage& uImage);
    public static UImageResult TryLoad(Stream stream, bool shouldOwnStream, UImage& uImage);
    internal static UInt32 GzipCrc32(Byte[] data);
    [ExtensionAttribute]
internal static UInt32 ReadUInt32BigEndian(BinaryReader reader);
    [ExtensionAttribute]
internal static int ReadInt32BigEndian(BinaryReader reader);
}
public enum ELFSharp.UImage.UImageResult : Enum {
    public int value__;
    public static UImageResult OK;
    public static UImageResult NotUImage;
    public static UImageResult BadChecksum;
    public static UImageResult NotSupportedImageType;
}
[ExtensionAttribute]
internal static class ELFSharp.Utilities.Extensions : object {
    [ExtensionAttribute]
public static Byte[] ReadBytesOrThrow(Stream stream, int count);
}
public class ELFSharp.Utilities.SimpleEndianessAwareReader : object {
    private bool needsAdjusting;
    private bool beNonClosing;
    private Stream stream;
    public Stream BaseStream { get; }
    public SimpleEndianessAwareReader(Stream stream, Endianess endianess, bool beNonClosing);
    public sealed virtual void Dispose();
    public Byte[] ReadBytes(int count);
    public byte ReadByte();
    public short ReadInt16();
    public ushort ReadUInt16();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public long ReadInt64();
    public ulong ReadUInt64();
    public Stream get_BaseStream();
}
internal class ELFSharp.Utilities.SubStream : Stream {
    private Stream wrappedStream;
    private long startingPosition;
    private long length;
    private static string NegativeArgumentMessage;
    private static string OutsideStreamMessage;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SubStream(Stream wrappedStream, long startingPosition, long length);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
