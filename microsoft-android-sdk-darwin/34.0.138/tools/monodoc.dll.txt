public abstract class Lucene.Net.Analysis.Analyzer : object {
    private CloseableThreadLocal`1<object> tokenStreams;
    private bool isDisposed;
    [ObsoleteAttribute]
protected internal bool overridesTokenStreamMethod;
    protected internal object PreviousTokenStream { get; protected internal set; }
    public abstract virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    protected internal virtual object get_PreviousTokenStream();
    protected internal virtual void set_PreviousTokenStream(object value);
    [ObsoleteAttribute("This is only present to preserve back-compat of classes that subclass a core analyzer and override tokenStream but not reusableTokenStream ")]
protected internal virtual void SetOverridesTokenStreamMethod();
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(IFieldable field);
    public void Close();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Analysis.ASCIIFoldingFilter : TokenFilter {
    private Char[] output;
    private int outputPos;
    private ITermAttribute termAtt;
    public ASCIIFoldingFilter(TokenStream input);
    public virtual bool IncrementToken();
    public void FoldToASCII(Char[] input, int length);
}
public abstract class Lucene.Net.Analysis.BaseCharFilter : CharFilter {
    private Int32[] offsets;
    private Int32[] diffs;
    private int size;
    protected int LastCumulativeDiff { get; }
    protected BaseCharFilter(CharStream in);
    protected internal virtual int Correct(int currentOff);
    protected int get_LastCumulativeDiff();
    [ObsoleteAttribute("Use LastCumulativeDiff property instead")]
protected int GetLastCumulativeDiff();
    protected void AddOffCorrectMap(int off, int cumulativeDiff);
}
public class Lucene.Net.Analysis.CachingTokenFilter : TokenFilter {
    private LinkedList`1<State> cache;
    private IEnumerator`1<State> iterator;
    private State finalState;
    public CachingTokenFilter(TokenStream input);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
    private void FillCache();
}
public class Lucene.Net.Analysis.CharArraySet : object {
    private bool _ReadOnly;
    private static int INIT_SIZE;
    private Char[][] _Entries;
    private int _Count;
    private bool _IgnoreCase;
    public static CharArraySet EMPTY_SET;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; private set; }
    public CharArraySet(int startSize, bool ignoreCase);
    public CharArraySet(IEnumerable`1<string> c, bool ignoreCase);
    public CharArraySet(IEnumerable`1<object> c, bool ignoreCase);
    private CharArraySet(Char[][] entries, bool ignoreCase, int count);
    private static CharArraySet();
    private void Init(int startSize, bool ignoreCase);
    private void AddItems(IEnumerable`1<T> items);
    public virtual bool Contains(Char[] text, int off, int len);
    public virtual bool Contains(string text);
    private int GetSlot(Char[] text, int off, int len);
    private int GetSlot(string text);
    public sealed virtual bool Add(string text);
    public bool Add(Char[] text);
    private bool Equals(Char[] text1, int off, int len, Char[] text2);
    private bool Equals(string text1, Char[] text2);
    private void Rehash();
    private int GetHashCode(Char[] text, int offset, int len);
    private int GetHashCode(string text);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool Contains(object item);
    public bool Add(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.Add(string item);
    public static CharArraySet UnmodifiableSet(CharArraySet set);
    public static CharArraySet Copy(ISet`1<T> set);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    private void set_IsReadOnly(bool value);
    public sealed virtual void UnionWith(IEnumerable`1<string> other);
    public void AddAll(IEnumerable`1<string> coll);
    public void RemoveAll(ICollection`1<string> c);
    public void RetainAll(ICollection`1<string> c);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.CopyTo(String[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ISet<System.String>.IntersectWith(IEnumerable`1<string> other);
    private sealed virtual override void System.Collections.Generic.ISet<System.String>.ExceptWith(IEnumerable`1<string> other);
    private sealed virtual override void System.Collections.Generic.ISet<System.String>.SymmetricExceptWith(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.IsSubsetOf(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.IsSupersetOf(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.IsProperSupersetOf(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.IsProperSubsetOf(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.Overlaps(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ISet<System.String>.SetEquals(IEnumerable`1<string> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.String>.Remove(string item);
    public IEnumerator`1<string> StringEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Lucene.Net.Analysis.CharFilter : CharStream {
    private long currentPosition;
    private bool isDisposed;
    protected internal CharStream input;
    protected internal CharFilter(CharStream in_Renamed);
    protected internal virtual int Correct(int currentOff);
    public virtual int CorrectOffset(int currentOff);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Char[] cbuf, int off, int len);
    public bool MarkSupported();
    public void Mark(int readAheadLimit);
    public void Reset();
}
public class Lucene.Net.Analysis.CharReader : CharStream {
    private long currentPosition;
    private bool isDisposed;
    internal StreamReader input;
    private CharReader(StreamReader in_Renamed);
    public static CharStream Get(TextReader input);
    public virtual int CorrectOffset(int currentOff);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Char[] cbuf, int off, int len);
    public bool MarkSupported();
    public void Mark(int readAheadLimit);
    public void Reset();
}
public abstract class Lucene.Net.Analysis.CharStream : StreamReader {
    protected CharStream(StreamReader reader);
    public abstract virtual int CorrectOffset(int currentOff);
}
public abstract class Lucene.Net.Analysis.CharTokenizer : Tokenizer {
    private int offset;
    private int bufferIndex;
    private int dataLen;
    private static int MAX_WORD_LEN;
    private static int IO_BUFFER_SIZE;
    private Char[] ioBuffer;
    private ITermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    protected CharTokenizer(TextReader input);
    protected CharTokenizer(AttributeSource source, TextReader input);
    protected CharTokenizer(AttributeFactory factory, TextReader input);
    protected internal abstract virtual bool IsTokenChar(char c);
    protected internal virtual char Normalize(char c);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset(TextReader input);
}
[ObsoleteAttribute("If you build a new index, use ASCIIFoldingFilter which covers a superset of Latin 1.  This class is included for use with existing indexes and will be removed in a future release (possible Lucene 4.0).")]
public class Lucene.Net.Analysis.ISOLatin1AccentFilter : TokenFilter {
    private Char[] output;
    private int outputPos;
    private ITermAttribute termAtt;
    public ISOLatin1AccentFilter(TokenStream input);
    public virtual bool IncrementToken();
    public void RemoveAccents(Char[] input, int length);
}
public class Lucene.Net.Analysis.KeywordAnalyzer : Analyzer {
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.KeywordTokenizer : Tokenizer {
    private static int DEFAULT_BUFFER_SIZE;
    private bool done;
    private int finalOffset;
    private ITermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    public KeywordTokenizer(TextReader input);
    public KeywordTokenizer(TextReader input, int bufferSize);
    public KeywordTokenizer(AttributeSource source, TextReader input, int bufferSize);
    public KeywordTokenizer(AttributeFactory factory, TextReader input, int bufferSize);
    private void Init(int bufferSize);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset(TextReader input);
}
public class Lucene.Net.Analysis.LengthFilter : TokenFilter {
    internal int min;
    internal int max;
    private ITermAttribute termAtt;
    public LengthFilter(TokenStream in_Renamed, int min, int max);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.LetterTokenizer : CharTokenizer {
    public LetterTokenizer(TextReader in);
    public LetterTokenizer(AttributeSource source, TextReader in);
    public LetterTokenizer(AttributeFactory factory, TextReader in);
    protected internal virtual bool IsTokenChar(char c);
}
public class Lucene.Net.Analysis.LowerCaseFilter : TokenFilter {
    private ITermAttribute termAtt;
    public LowerCaseFilter(TokenStream in);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.LowerCaseTokenizer : LetterTokenizer {
    public LowerCaseTokenizer(TextReader in);
    public LowerCaseTokenizer(AttributeSource source, TextReader in);
    public LowerCaseTokenizer(AttributeFactory factory, TextReader in);
    protected internal virtual char Normalize(char c);
}
public class Lucene.Net.Analysis.MappingCharFilter : BaseCharFilter {
    private NormalizeCharMap normMap;
    private LinkedList`1<char> buffer;
    private string replacement;
    private int charPointer;
    private int nextCharCounter;
    public MappingCharFilter(NormalizeCharMap normMap, CharStream in);
    public MappingCharFilter(NormalizeCharMap normMap, TextReader in);
    public virtual int Read();
    private int NextChar();
    private void PushChar(int c);
    private void PushLastChar(int c);
    private NormalizeCharMap Match(NormalizeCharMap map);
    public virtual int Read(Char[] cbuf, int off, int len);
}
public class Lucene.Net.Analysis.NormalizeCharMap : object {
    internal IDictionary`2<char, NormalizeCharMap> submap;
    internal string normStr;
    internal int diff;
    public virtual void Add(string singleMatch, string replacement);
}
public class Lucene.Net.Analysis.NumericTokenStream : TokenStream {
    public static string TOKEN_TYPE_FULL_PREC;
    public static string TOKEN_TYPE_LOWER_PREC;
    private ITermAttribute termAtt;
    private ITypeAttribute typeAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private int shift;
    private int valSize;
    private int precisionStep;
    private long value_Renamed;
    public NumericTokenStream(int precisionStep);
    public NumericTokenStream(AttributeSource source, int precisionStep);
    public NumericTokenStream(AttributeFactory factory, int precisionStep);
    private void InitBlock();
    public NumericTokenStream SetLongValue(long value_Renamed);
    public NumericTokenStream SetIntValue(int value_Renamed);
    public NumericTokenStream SetDoubleValue(double value_Renamed);
    public NumericTokenStream SetFloatValue(float value_Renamed);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    public virtual bool IncrementToken();
    public virtual string ToString();
}
public class Lucene.Net.Analysis.PerFieldAnalyzerWrapper : Analyzer {
    private Analyzer defaultAnalyzer;
    private IDictionary`2<string, Analyzer> analyzerMap;
    public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer);
    public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer, IEnumerable`1<KeyValuePair`2<string, Analyzer>> fieldAnalyzers);
    public virtual void AddAnalyzer(string fieldName, Analyzer analyzer);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(IFieldable field);
    public virtual string ToString();
}
public class Lucene.Net.Analysis.PorterStemFilter : TokenFilter {
    private PorterStemmer stemmer;
    private ITermAttribute termAtt;
    public PorterStemFilter(TokenStream in_Renamed);
    public virtual bool IncrementToken();
}
internal class Lucene.Net.Analysis.PorterStemmer : object {
    private Char[] b;
    private int i;
    private int j;
    private int k;
    private int k0;
    private bool dirty;
    private static int INC;
    private static int EXTRA;
    public int ResultLength { get; }
    public Char[] ResultBuffer { get; }
    public virtual void Reset();
    public virtual void Add(char ch);
    public virtual string ToString();
    public virtual int get_ResultLength();
    public virtual Char[] get_ResultBuffer();
    private bool Cons(int i);
    private int M();
    private bool Vowelinstem();
    private bool Doublec(int j);
    private bool Cvc(int i);
    private bool Ends(string s);
    internal virtual void Setto(string s);
    internal virtual void R(string s);
    private void Step1();
    private void Step2();
    private void Step3();
    private void Step4();
    private void Step5();
    private void Step6();
    public virtual string Stem(string s);
    public virtual bool Stem(Char[] word);
    public virtual bool Stem(Char[] wordBuffer, int offset, int wordLen);
    public virtual bool Stem(Char[] word, int wordLen);
    public virtual bool Stem();
    public virtual bool Stem(int i0);
    [STAThreadAttribute]
public static void Main(String[] args);
}
public class Lucene.Net.Analysis.SimpleAnalyzer : Analyzer {
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Standard.StandardAnalyzer : Analyzer {
    private ISet`1<string> stopSet;
    private bool replaceInvalidAcronym;
    private bool enableStopPositionIncrements;
    public static ISet`1<string> STOP_WORDS_SET;
    private Version matchVersion;
    public static int DEFAULT_MAX_TOKEN_LENGTH;
    private int maxTokenLength;
    public int MaxTokenLength { get; public set; }
    public StandardAnalyzer(Version matchVersion);
    public StandardAnalyzer(Version matchVersion, ISet`1<string> stopWords);
    public StandardAnalyzer(Version matchVersion, FileInfo stopwords);
    public StandardAnalyzer(Version matchVersion, TextReader stopwords);
    private static StandardAnalyzer();
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual int get_MaxTokenLength();
    public virtual void set_MaxTokenLength(int value);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Standard.StandardFilter : TokenFilter {
    private static string APOSTROPHE_TYPE;
    private static string ACRONYM_TYPE;
    private ITypeAttribute typeAtt;
    private ITermAttribute termAtt;
    public StandardFilter(TokenStream in_Renamed);
    private static StandardFilter();
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Standard.StandardTokenizer : Tokenizer {
    private StandardTokenizerImpl scanner;
    public static int ALPHANUM;
    public static int APOSTROPHE;
    public static int ACRONYM;
    public static int COMPANY;
    public static int EMAIL;
    public static int HOST;
    public static int NUM;
    public static int CJ;
    [ObsoleteAttribute("this solves a bug where HOSTs that end with '.' are identified as ACRONYMs.")]
public static int ACRONYM_DEP;
    public static String[] TOKEN_TYPES;
    private bool replaceInvalidAcronym;
    private int maxTokenLength;
    private ITermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private ITypeAttribute typeAtt;
    public int MaxTokenLength { get; public set; }
    public StandardTokenizer(Version matchVersion, TextReader input);
    public StandardTokenizer(Version matchVersion, AttributeSource source, TextReader input);
    public StandardTokenizer(Version matchVersion, AttributeFactory factory, TextReader input);
    private static StandardTokenizer();
    private void InitBlock();
    public int get_MaxTokenLength();
    public void set_MaxTokenLength(int value);
    private void Init(TextReader input, Version matchVersion);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset(TextReader reader);
    [ObsoleteAttribute("Remove in 3.X and make true the only valid value. See https://issues.apache.org/jira/browse/LUCENE-1068")]
public void SetReplaceInvalidAcronym(bool replaceInvalidAcronym);
}
internal class Lucene.Net.Analysis.Standard.StandardTokenizerImpl : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzPushbackPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyline;
    private int yychar;
    private int yycolumn;
    private bool zzAtBOL;
    private bool zzAtEOF;
    public static int ALPHANUM;
    public static int APOSTROPHE;
    public static int ACRONYM;
    public static int COMPANY;
    public static int EMAIL;
    public static int HOST;
    public static int NUM;
    public static int CJ;
    [ObsoleteAttribute("this solves a bug where HOSTs that end with '.' are identified as ACRONYMs")]
public static int ACRONYM_DEP;
    public static String[] TOKEN_TYPES;
    internal StandardTokenizerImpl(TextReader in_Renamed);
    internal StandardTokenizerImpl(Stream in_Renamed);
    private static StandardTokenizerImpl();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public int Yychar();
    internal void Reset(TextReader r);
    internal void GetText(Token t);
    internal void GetText(ITermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void Yyclose();
    public void Yyreset(TextReader reader);
    public int Yystate();
    public void Yybegin(int newState);
    public string Yytext();
    public char Yycharat(int pos);
    public int Yylength();
    private void ZzScanError(int errorCode);
    public virtual void Yypushback(int number);
    public virtual int GetNextToken();
}
public class Lucene.Net.Analysis.StopAnalyzer : Analyzer {
    private ISet`1<string> stopWords;
    private bool enablePositionIncrements;
    public static ISet`1<string> ENGLISH_STOP_WORDS_SET;
    public StopAnalyzer(Version matchVersion);
    public StopAnalyzer(Version matchVersion, ISet`1<string> stopWords);
    public StopAnalyzer(Version matchVersion, FileInfo stopwordsFile);
    public StopAnalyzer(Version matchVersion, TextReader stopwords);
    private static StopAnalyzer();
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.StopFilter : TokenFilter {
    private CharArraySet stopWords;
    private bool enablePositionIncrements;
    private ITermAttribute termAtt;
    private IPositionIncrementAttribute posIncrAtt;
    public bool EnablePositionIncrements { get; public set; }
    public StopFilter(bool enablePositionIncrements, TokenStream input, ISet`1<string> stopWords, bool ignoreCase);
    public StopFilter(bool enablePositionIncrements, TokenStream in, ISet`1<string> stopWords);
    public static ISet`1<string> MakeStopSet(String[] stopWords);
    public static ISet`1<string> MakeStopSet(IList`1<object> stopWords);
    public static ISet`1<string> MakeStopSet(String[] stopWords, bool ignoreCase);
    public static ISet`1<string> MakeStopSet(IList`1<object> stopWords, bool ignoreCase);
    public virtual bool IncrementToken();
    public static bool GetEnablePositionIncrementsVersionDefault(Version matchVersion);
    public bool get_EnablePositionIncrements();
    public void set_EnablePositionIncrements(bool value);
}
public class Lucene.Net.Analysis.TeeSinkTokenFilter : TokenFilter {
    private LinkedList`1<WeakReference> sinks;
    private static SinkFilter ACCEPT_ALL_FILTER;
    public TeeSinkTokenFilter(TokenStream input);
    private static TeeSinkTokenFilter();
    public SinkTokenStream NewSinkTokenStream();
    public SinkTokenStream NewSinkTokenStream(SinkFilter filter);
    public void AddSinkTokenStream(SinkTokenStream sink);
    public void ConsumeAllTokens();
    public virtual bool IncrementToken();
    public virtual void End();
}
public class Lucene.Net.Analysis.Token : Attribute {
    public static string DEFAULT_TYPE;
    private static int MIN_BUFFER_SIZE;
    private Char[] termBuffer;
    private int termLength;
    private int startOffset;
    private int endOffset;
    private string type;
    private int flags;
    private Payload payload;
    private int positionIncrement;
    public static AttributeFactory TOKEN_ATTRIBUTE_FACTORY;
    public int PositionIncrement { get; public set; }
    public string Term { get; }
    public int StartOffset { get; public set; }
    public int EndOffset { get; public set; }
    public string Type { get; public set; }
    public int Flags { get; public set; }
    public Payload Payload { get; public set; }
    public Token(int start, int end);
    public Token(int start, int end, string typ);
    public Token(int start, int end, int flags);
    public Token(string text, int start, int end);
    public Token(string text, int start, int end, string typ);
    public Token(string text, int start, int end, int flags);
    public Token(Char[] startTermBuffer, int termBufferOffset, int termBufferLength, int start, int end);
    private static Token();
    public virtual void set_PositionIncrement(int value);
    public virtual int get_PositionIncrement();
    public sealed virtual string get_Term();
    public sealed virtual void SetTermBuffer(Char[] buffer, int offset, int length);
    public sealed virtual void SetTermBuffer(string buffer);
    public sealed virtual void SetTermBuffer(string buffer, int offset, int length);
    public sealed virtual Char[] TermBuffer();
    public virtual Char[] ResizeTermBuffer(int newSize);
    private void GrowTermBuffer(int newSize);
    private void InitTermBuffer();
    public sealed virtual int TermLength();
    public sealed virtual void SetTermLength(int length);
    public virtual int get_StartOffset();
    public virtual void set_StartOffset(int value);
    public virtual int get_EndOffset();
    public virtual void set_EndOffset(int value);
    public virtual void SetOffset(int startOffset, int endOffset);
    public sealed virtual string get_Type();
    public sealed virtual void set_Type(string value);
    public virtual int get_Flags();
    public virtual void set_Flags(int value);
    public virtual Payload get_Payload();
    public virtual void set_Payload(Payload value);
    public virtual string ToString();
    public virtual void Clear();
    public virtual object Clone();
    public virtual Token Clone(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual bool Equals(object obj);
    private bool SubEqual(object o1, object o2);
    public virtual int GetHashCode();
    private void ClearNoTermBuffer();
    public virtual Token Reinit(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual Token Reinit(string newTerm, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(string newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(string newTerm, int newStartOffset, int newEndOffset);
    public virtual Token Reinit(string newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual void Reinit(Token prototype);
    public virtual void Reinit(Token prototype, string newTerm);
    public virtual void Reinit(Token prototype, Char[] newTermBuffer, int offset, int length);
    public virtual void CopyTo(Attribute target);
}
public class Lucene.Net.Analysis.Tokenattributes.FlagsAttribute : Attribute {
    private int flags;
    public int Flags { get; public set; }
    public virtual int get_Flags();
    public virtual void set_Flags(int value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(Attribute target);
    public virtual object Clone();
}
public interface Lucene.Net.Analysis.Tokenattributes.IFlagsAttribute {
    public int Flags { get; public set; }
    public abstract virtual int get_Flags();
    public abstract virtual void set_Flags(int value);
}
public interface Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute {
    public int StartOffset { get; }
    public int EndOffset { get; }
    public abstract virtual int get_StartOffset();
    public abstract virtual void SetOffset(int startOffset, int endOffset);
    public abstract virtual int get_EndOffset();
}
public interface Lucene.Net.Analysis.Tokenattributes.IPayloadAttribute {
    public Payload Payload { get; public set; }
    public abstract virtual Payload get_Payload();
    public abstract virtual void set_Payload(Payload value);
}
public interface Lucene.Net.Analysis.Tokenattributes.IPositionIncrementAttribute {
    public int PositionIncrement { get; public set; }
    public abstract virtual void set_PositionIncrement(int value);
    public abstract virtual int get_PositionIncrement();
}
public interface Lucene.Net.Analysis.Tokenattributes.ITermAttribute {
    public string Term { get; }
    public abstract virtual string get_Term();
    public abstract virtual void SetTermBuffer(Char[] buffer, int offset, int length);
    public abstract virtual void SetTermBuffer(string buffer);
    public abstract virtual void SetTermBuffer(string buffer, int offset, int length);
    public abstract virtual Char[] TermBuffer();
    public abstract virtual Char[] ResizeTermBuffer(int newSize);
    public abstract virtual int TermLength();
    public abstract virtual void SetTermLength(int length);
}
public interface Lucene.Net.Analysis.Tokenattributes.ITypeAttribute {
    public string Type { get; public set; }
    public abstract virtual string get_Type();
    public abstract virtual void set_Type(string value);
}
public class Lucene.Net.Analysis.Tokenattributes.OffsetAttribute : Attribute {
    private int startOffset;
    private int endOffset;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public virtual int get_StartOffset();
    public virtual void SetOffset(int startOffset, int endOffset);
    public virtual int get_EndOffset();
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(Attribute target);
    public virtual object Clone();
}
public class Lucene.Net.Analysis.Tokenattributes.PayloadAttribute : Attribute {
    private Payload payload;
    public Payload Payload { get; public set; }
    public PayloadAttribute(Payload payload);
    public virtual Payload get_Payload();
    public virtual void set_Payload(Payload value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(Attribute target);
}
public class Lucene.Net.Analysis.Tokenattributes.PositionIncrementAttribute : Attribute {
    private int positionIncrement;
    public int PositionIncrement { get; public set; }
    public virtual void set_PositionIncrement(int value);
    public virtual int get_PositionIncrement();
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(Attribute target);
    public virtual object Clone();
}
public class Lucene.Net.Analysis.Tokenattributes.TermAttribute : Attribute {
    private static int MIN_BUFFER_SIZE;
    private Char[] termBuffer;
    private int termLength;
    public string Term { get; }
    private static TermAttribute();
    public virtual string get_Term();
    public virtual void SetTermBuffer(Char[] buffer, int offset, int length);
    public virtual void SetTermBuffer(string buffer);
    public virtual void SetTermBuffer(string buffer, int offset, int length);
    public virtual Char[] TermBuffer();
    public virtual Char[] ResizeTermBuffer(int newSize);
    private void GrowTermBuffer(int newSize);
    private void InitTermBuffer();
    public virtual int TermLength();
    public virtual void SetTermLength(int length);
    public virtual int GetHashCode();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Equals(object other);
    public virtual string ToString();
    public virtual void CopyTo(Attribute target);
}
public class Lucene.Net.Analysis.Tokenattributes.TypeAttribute : Attribute {
    private string type;
    public static string DEFAULT_TYPE;
    public string Type { get; public set; }
    public TypeAttribute(string type);
    public virtual string get_Type();
    public virtual void set_Type(string value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(Attribute target);
    public virtual object Clone();
}
public abstract class Lucene.Net.Analysis.TokenFilter : TokenStream {
    protected internal TokenStream input;
    private bool isDisposed;
    protected internal TokenFilter(TokenStream input);
    public virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
}
public abstract class Lucene.Net.Analysis.Tokenizer : TokenStream {
    protected internal TextReader input;
    private bool isDisposed;
    protected internal Tokenizer(TextReader input);
    protected internal Tokenizer(AttributeFactory factory);
    protected internal Tokenizer(AttributeFactory factory, TextReader input);
    protected internal Tokenizer(AttributeSource source);
    protected internal Tokenizer(AttributeSource source, TextReader input);
    protected virtual void Dispose(bool disposing);
    protected internal int CorrectOffset(int currentOff);
    public virtual void Reset(TextReader input);
}
public abstract class Lucene.Net.Analysis.TokenStream : AttributeSource {
    protected internal TokenStream(AttributeSource input);
    protected internal TokenStream(AttributeFactory factory);
    public abstract virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public class Lucene.Net.Analysis.WhitespaceAnalyzer : Analyzer {
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.WhitespaceTokenizer : CharTokenizer {
    public WhitespaceTokenizer(TextReader in);
    public WhitespaceTokenizer(AttributeSource source, TextReader in);
    public WhitespaceTokenizer(AttributeFactory factory, TextReader in);
    protected internal virtual bool IsTokenChar(char c);
}
public class Lucene.Net.Analysis.WordlistLoader : object {
    public static ISet`1<string> GetWordSet(FileInfo wordfile);
    public static ISet`1<string> GetWordSet(FileInfo wordfile, string comment);
    public static ISet`1<string> GetWordSet(TextReader reader);
    public static ISet`1<string> GetWordSet(TextReader reader, string comment);
    public static Dictionary`2<string, string> GetStemDict(FileInfo wordstemfile);
}
public abstract class Lucene.Net.Documents.AbstractField : object {
    protected internal string internalName;
    protected internal bool storeTermVector;
    protected internal bool storeOffsetWithTermVector;
    protected internal bool storePositionWithTermVector;
    protected internal bool internalOmitNorms;
    protected internal bool internalIsStored;
    protected internal bool internalIsIndexed;
    protected internal bool internalIsTokenized;
    protected internal bool internalIsBinary;
    protected internal bool lazy;
    protected internal bool internalOmitTermFreqAndPositions;
    protected internal float internalBoost;
    protected internal object fieldsData;
    protected internal TokenStream tokenStream;
    protected internal int internalBinaryLength;
    protected internal int internalbinaryOffset;
    public float Boost { get; public set; }
    public string Name { get; }
    public bool IsStored { get; }
    public bool IsIndexed { get; }
    public bool IsTokenized { get; }
    public bool IsTermVectorStored { get; }
    public bool IsStoreOffsetWithTermVector { get; }
    public bool IsStorePositionWithTermVector { get; }
    public bool IsBinary { get; }
    public int BinaryLength { get; }
    public int BinaryOffset { get; }
    public bool OmitNorms { get; public set; }
    public bool OmitTermFreqAndPositions { get; public set; }
    public bool IsLazy { get; }
    public TokenStream TokenStreamValue { get; }
    public TextReader ReaderValue { get; }
    public string StringValue { get; }
    protected internal AbstractField(string name, Store store, Index index, TermVector termVector);
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    public virtual string get_Name();
    protected internal virtual void SetStoreTermVector(TermVector termVector);
    public sealed virtual bool get_IsStored();
    public sealed virtual bool get_IsIndexed();
    public sealed virtual bool get_IsTokenized();
    public sealed virtual bool get_IsTermVectorStored();
    public virtual bool get_IsStoreOffsetWithTermVector();
    public virtual bool get_IsStorePositionWithTermVector();
    public sealed virtual bool get_IsBinary();
    public virtual Byte[] GetBinaryValue();
    public virtual Byte[] GetBinaryValue(Byte[] result);
    public virtual int get_BinaryLength();
    public virtual int get_BinaryOffset();
    public virtual bool get_OmitNorms();
    public virtual void set_OmitNorms(bool value);
    public virtual void set_OmitTermFreqAndPositions(bool value);
    public virtual bool get_OmitTermFreqAndPositions();
    public virtual bool get_IsLazy();
    public virtual string ToString();
    public abstract virtual TokenStream get_TokenStreamValue();
    public abstract virtual TextReader get_ReaderValue();
    public abstract virtual string get_StringValue();
}
public class Lucene.Net.Documents.CompressionTools : object {
    public static Byte[] Compress(Byte[] value_Renamed, int offset, int length, int compressionLevel);
    public static Byte[] Compress(Byte[] value_Renamed, int offset, int length);
    public static Byte[] Compress(Byte[] value_Renamed);
    public static Byte[] CompressString(string value_Renamed);
    public static Byte[] CompressString(string value_Renamed, int compressionLevel);
    public static Byte[] Decompress(Byte[] value_Renamed);
    public static string DecompressString(Byte[] value_Renamed);
}
[ObsoleteAttribute("If you build a new index, use DateTools or NumericField instead.This class is included for use with existing indices and will be removed in a future release (possibly Lucene 4.0).")]
public class Lucene.Net.Documents.DateField : object {
    private static int DATE_LEN;
    private static DateField();
    public static string MIN_DATE_STRING();
    public static string MAX_DATE_STRING();
    public static string DateToString(DateTime date);
    public static string TimeToString(long time);
    public static long StringToTime(string s);
    public static DateTime StringToDate(string s);
}
public class Lucene.Net.Documents.DateTools : object {
    private static string YEAR_FORMAT;
    private static string MONTH_FORMAT;
    private static string DAY_FORMAT;
    private static string HOUR_FORMAT;
    private static string MINUTE_FORMAT;
    private static string SECOND_FORMAT;
    private static string MILLISECOND_FORMAT;
    private static Calendar calInstance;
    private static DateTools();
    public static string DateToString(DateTime date, Resolution resolution);
    public static string TimeToString(long time, Resolution resolution);
    public static long StringToTime(string dateString);
    public static DateTime StringToDate(string dateString);
    public static DateTime Round(DateTime date, Resolution resolution);
    public static long Round(long time, Resolution resolution);
}
public class Lucene.Net.Documents.Document : object {
    internal IList`1<IFieldable> fields;
    private float boost;
    private static Field[] NO_FIELDS;
    private static IFieldable[] NO_FIELDABLES;
    private static String[] NO_STRINGS;
    private static Byte[][] NO_BYTES;
    public float Boost { get; public set; }
    public IList`1<IFieldable> fields_ForNUnit { get; }
    private static Document();
    public float get_Boost();
    public void set_Boost(float value);
    public void Add(IFieldable field);
    public void RemoveField(string name);
    public void RemoveFields(string name);
    public Field GetField(string name);
    public IFieldable GetFieldable(string name);
    public string Get(string name);
    public IList`1<IFieldable> GetFields();
    public Field[] GetFields(string name);
    public IFieldable[] GetFieldables(string name);
    public String[] GetValues(string name);
    public Byte[][] GetBinaryValues(string name);
    public Byte[] GetBinaryValue(string name);
    public virtual string ToString();
    public IList`1<IFieldable> get_fields_ForNUnit();
}
public class Lucene.Net.Documents.Field : AbstractField {
    public string StringValue { get; }
    public TextReader ReaderValue { get; }
    public TokenStream TokenStreamValue { get; }
    public Field(string name, string value, Store store, Index index);
    public Field(string name, string value, Store store, Index index, TermVector termVector);
    public Field(string name, bool internName, string value, Store store, Index index, TermVector termVector);
    public Field(string name, TextReader reader);
    public Field(string name, TextReader reader, TermVector termVector);
    public Field(string name, TokenStream tokenStream);
    public Field(string name, TokenStream tokenStream, TermVector termVector);
    public Field(string name, Byte[] value_Renamed, Store store);
    public Field(string name, Byte[] value_Renamed, int offset, int length, Store store);
    public virtual string get_StringValue();
    public virtual TextReader get_ReaderValue();
    public virtual TokenStream get_TokenStreamValue();
    public void SetValue(string value);
    public void SetValue(TextReader value);
    public void SetValue(Byte[] value);
    public void SetValue(Byte[] value, int offset, int length);
    public void SetTokenStream(TokenStream tokenStream);
}
[ExtensionAttribute]
public static class Lucene.Net.Documents.FieldExtensions : object {
    [ExtensionAttribute]
public static bool IsStored(Store store);
    [ExtensionAttribute]
public static bool IsIndexed(Index index);
    [ExtensionAttribute]
public static bool IsAnalyzed(Index index);
    [ExtensionAttribute]
public static bool OmitNorms(Index index);
    [ExtensionAttribute]
public static bool IsStored(TermVector tv);
    [ExtensionAttribute]
public static bool WithPositions(TermVector tv);
    [ExtensionAttribute]
public static bool WithOffsets(TermVector tv);
    public static Index ToIndex(bool indexed, bool analyed);
    public static Index ToIndex(bool indexed, bool analyzed, bool omitNorms);
    public static TermVector ToTermVector(bool stored, bool withOffsets, bool withPositions);
}
public interface Lucene.Net.Documents.FieldSelector {
    public abstract virtual FieldSelectorResult Accept(string fieldName);
}
public enum Lucene.Net.Documents.FieldSelectorResult : Enum {
    public int value__;
    public static FieldSelectorResult INVALID;
    public static FieldSelectorResult LOAD;
    public static FieldSelectorResult LAZY_LOAD;
    public static FieldSelectorResult NO_LOAD;
    public static FieldSelectorResult LOAD_AND_BREAK;
    public static FieldSelectorResult SIZE;
    public static FieldSelectorResult SIZE_AND_BREAK;
}
public interface Lucene.Net.Documents.IFieldable {
    public float Boost { get; public set; }
    public string Name { get; }
    public string StringValue { get; }
    public TextReader ReaderValue { get; }
    public TokenStream TokenStreamValue { get; }
    public bool IsStored { get; }
    public bool IsIndexed { get; }
    public bool IsTokenized { get; }
    public bool IsTermVectorStored { get; }
    public bool IsStoreOffsetWithTermVector { get; }
    public bool IsStorePositionWithTermVector { get; }
    public bool IsBinary { get; }
    public bool OmitNorms { get; public set; }
    public bool IsLazy { get; }
    public int BinaryOffset { get; }
    public int BinaryLength { get; }
    public bool OmitTermFreqAndPositions { get; public set; }
    public abstract virtual float get_Boost();
    public abstract virtual void set_Boost(float value);
    public abstract virtual string get_Name();
    public abstract virtual string get_StringValue();
    public abstract virtual TextReader get_ReaderValue();
    public abstract virtual TokenStream get_TokenStreamValue();
    public abstract virtual bool get_IsStored();
    public abstract virtual bool get_IsIndexed();
    public abstract virtual bool get_IsTokenized();
    public abstract virtual bool get_IsTermVectorStored();
    public abstract virtual bool get_IsStoreOffsetWithTermVector();
    public abstract virtual bool get_IsStorePositionWithTermVector();
    public abstract virtual bool get_IsBinary();
    public abstract virtual bool get_OmitNorms();
    public abstract virtual void set_OmitNorms(bool value);
    public abstract virtual bool get_IsLazy();
    public abstract virtual int get_BinaryOffset();
    public abstract virtual int get_BinaryLength();
    public abstract virtual Byte[] GetBinaryValue();
    public abstract virtual Byte[] GetBinaryValue(Byte[] result);
    public abstract virtual void set_OmitTermFreqAndPositions(bool value);
    public abstract virtual bool get_OmitTermFreqAndPositions();
}
public class Lucene.Net.Documents.LoadFirstFieldSelector : object {
    public virtual FieldSelectorResult Accept(string fieldName);
}
public class Lucene.Net.Documents.MapFieldSelector : object {
    internal IDictionary`2<string, FieldSelectorResult> fieldSelections;
    public MapFieldSelector(IDictionary`2<string, FieldSelectorResult> fieldSelections);
    public MapFieldSelector(IList`1<string> fields);
    public MapFieldSelector(String[] fields);
    public virtual FieldSelectorResult Accept(string field);
}
[ObsoleteAttribute("For new indexes use NumericUtils instead, which provides a sortable binary representation (prefix encoded) of numeric values. To index and efficiently query numeric values use NumericField and NumericRangeQuery. This class is included for use with existing indices and will be removed in a future release (possibly Lucene 4.0).")]
public class Lucene.Net.Documents.NumberTools : object {
    private static int RADIX;
    private static char NEGATIVE_PREFIX;
    private static char POSITIVE_PREFIX;
    public static string MIN_STRING_VALUE;
    public static string MAX_STRING_VALUE;
    public static int STR_SIZE;
    private static string digits;
    private static Int64[] powersOf36;
    private static NumberTools();
    public static string LongToString(long l);
    public static long StringToLong(string str);
    public static string ToString(long lval);
    public static long ToLong(string t);
}
public class Lucene.Net.Documents.NumericField : AbstractField {
    private NumericTokenStream tokenStream;
    public TokenStream TokenStreamValue { get; }
    public TextReader ReaderValue { get; }
    public string StringValue { get; }
    public ValueType NumericValue { get; }
    public NumericField(string name);
    public NumericField(string name, Store store, bool index);
    public NumericField(string name, int precisionStep);
    public NumericField(string name, int precisionStep, Store store, bool index);
    public virtual TokenStream get_TokenStreamValue();
    public virtual Byte[] GetBinaryValue(Byte[] result);
    public virtual TextReader get_ReaderValue();
    public virtual string get_StringValue();
    public ValueType get_NumericValue();
    public NumericField SetLongValue(long value_Renamed);
    public NumericField SetIntValue(int value_Renamed);
    public NumericField SetDoubleValue(double value_Renamed);
    public NumericField SetFloatValue(float value_Renamed);
}
public class Lucene.Net.Documents.SetBasedFieldSelector : object {
    private ISet`1<string> fieldsToLoad;
    private ISet`1<string> lazyFieldsToLoad;
    public SetBasedFieldSelector(ISet`1<string> fieldsToLoad, ISet`1<string> lazyFieldsToLoad);
    public virtual FieldSelectorResult Accept(string fieldName);
}
public abstract class Lucene.Net.Index.AbstractAllTermDocs : object {
    protected int maxDoc;
    protected int internalDoc;
    public int Doc { get; }
    public int Freq { get; }
    protected AbstractAllTermDocs(int maxDoc);
    public sealed virtual void Seek(Term term);
    public sealed virtual void Seek(TermEnum termEnum);
    public sealed virtual int get_Doc();
    public sealed virtual int get_Freq();
    public sealed virtual bool Next();
    public sealed virtual int Read(Int32[] docs, Int32[] freqs);
    public sealed virtual bool SkipTo(int target);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual bool IsDeleted(int doc);
}
internal class Lucene.Net.Index.AllTermDocs : AbstractAllTermDocs {
    protected internal BitVector deletedDocs;
    protected internal AllTermDocs(SegmentReader parent);
    protected virtual void Dispose(bool disposing);
    public virtual bool IsDeleted(int doc);
}
internal class Lucene.Net.Index.BufferedDeletes : object {
    internal int numTerms;
    internal IDictionary`2<Term, Num> terms;
    internal IDictionary`2<Query, int> queries;
    internal List`1<int> docIDs;
    internal long bytesUsed;
    internal bool doTermSort;
    public BufferedDeletes(bool doTermSort);
    internal virtual int Size();
    internal virtual void Update(BufferedDeletes in);
    internal virtual void Clear();
    internal virtual void AddBytesUsed(long b);
    internal virtual bool Any();
    internal virtual void Remap(MergeDocIDRemapper mapper, SegmentInfos infos, Int32[][] docMaps, Int32[] delCounts, OneMerge merge, int mergeDocCount);
}
public class Lucene.Net.Index.ByteBlockPool : object {
    public Byte[][] buffers;
    internal int bufferUpto;
    public int byteUpto;
    public Byte[] buffer;
    public int byteOffset;
    private bool trackAllocations;
    private Allocator allocator;
    internal static Int32[] nextLevelArray;
    internal static Int32[] levelSizeArray;
    internal static int FIRST_LEVEL_SIZE;
    public static int FIRST_LEVEL_SIZE_For_NUnit_Test;
    public static int FIRST_LEVEL_SIZE_ForNUnit { get; }
    public ByteBlockPool(Allocator allocator, bool trackAllocations);
    private static ByteBlockPool();
    private void InitBlock();
    public void Reset();
    public void NextBuffer();
    public int NewSlice(int size);
    public int AllocSlice(Byte[] slice, int upto);
    public static int get_FIRST_LEVEL_SIZE_ForNUnit();
}
public class Lucene.Net.Index.ByteSliceReader : IndexInput {
    internal ByteBlockPool pool;
    internal int bufferUpto;
    internal Byte[] buffer;
    public int upto;
    internal int limit;
    internal int level;
    public int bufferOffset;
    public int endIndex;
    public long FilePointer { get; }
    public void Init(ByteBlockPool pool, int startIndex, int endIndex);
    public bool Eof();
    public virtual byte ReadByte();
    public long WriteTo(IndexOutput out);
    public void NextSlice();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual long get_FilePointer();
    public virtual long Length();
    public virtual void Seek(long pos);
    protected virtual void Dispose(bool disposing);
    public virtual object Clone();
}
public class Lucene.Net.Index.ByteSliceWriter : object {
    private Byte[] slice;
    private int upto;
    private ByteBlockPool pool;
    internal int offset0;
    public int Address { get; }
    public ByteSliceWriter(ByteBlockPool pool);
    public void Init(int address);
    public void WriteByte(byte b);
    public void WriteBytes(Byte[] b, int offset, int len);
    public int get_Address();
    public void WriteVInt(int i);
}
internal class Lucene.Net.Index.CharBlockPool : object {
    public Char[][] buffers;
    internal int numBuffer;
    internal int bufferUpto;
    public int charUpto;
    public Char[] buffer;
    public int charOffset;
    private DocumentsWriter docWriter;
    public CharBlockPool(DocumentsWriter docWriter);
    private void InitBlock();
    public void Reset();
    public void NextBuffer();
}
public class Lucene.Net.Index.CheckIndex : object {
    private StreamWriter infoStream;
    private Directory dir;
    private static bool assertsOn;
    public CheckIndex(Directory dir);
    public virtual void SetInfoStream(StreamWriter out);
    private void Msg(string msg);
    public virtual Status CheckIndex_Renamed_Method();
    public virtual Status CheckIndex_Renamed_Method(List`1<string> onlySegments);
    private FieldNormStatus TestFieldNorms(IEnumerable`1<string> fieldNames, SegmentReader reader);
    private TermIndexStatus TestTermIndex(SegmentInfo info, SegmentReader reader);
    private StoredFieldStatus TestStoredFields(SegmentInfo info, SegmentReader reader, NumberFormatInfo format);
    private TermVectorStatus TestTermVectors(SegmentInfo info, SegmentReader reader, NumberFormatInfo format);
    public virtual void FixIndex(Status result);
    private static bool TestAsserts();
    private static bool AssertsOn();
    [STAThreadAttribute]
public static void Main(String[] args);
}
public class Lucene.Net.Index.CompoundFileReader : Directory {
    private int readBufferSize;
    private bool isDisposed;
    private Directory directory;
    private string fileName;
    private IndexInput stream;
    private HashMap`2<string, FileEntry> entries;
    public Directory Directory { get; }
    public string Name { get; }
    public CompoundFileReader(Directory dir, string name);
    public CompoundFileReader(Directory dir, string name, int readBufferSize);
    public virtual Directory get_Directory();
    public virtual string get_Name();
    protected virtual void Dispose(bool disposing);
    public virtual IndexInput OpenInput(string id);
    public virtual IndexInput OpenInput(string id, int readBufferSize);
    public virtual String[] ListAll();
    public virtual bool FileExists(string name);
    public virtual long FileModified(string name);
    public virtual void TouchFile(string name);
    public virtual void DeleteFile(string name);
    public void RenameFile(string from, string to);
    public virtual long FileLength(string name);
    public virtual IndexOutput CreateOutput(string name);
    public virtual Lock MakeLock(string name);
}
public class Lucene.Net.Index.CompoundFileWriter : object {
    private Directory directory;
    private string fileName;
    private HashSet`1<string> ids;
    private LinkedList`1<FileEntry> entries;
    private bool merged;
    private CheckAbort checkAbort;
    public Directory Directory { get; }
    public string Name { get; }
    public CompoundFileWriter(Directory dir, string name);
    internal CompoundFileWriter(Directory dir, string name, CheckAbort checkAbort);
    public Directory get_Directory();
    public string get_Name();
    public void AddFile(string file);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    private void CopyFile(FileEntry source, IndexOutput os, Byte[] buffer);
}
public class Lucene.Net.Index.ConcurrentMergeScheduler : MergeScheduler {
    private int mergeThreadPriority;
    protected internal IList`1<MergeThread> mergeThreads;
    private int _maxThreadCount;
    protected internal Directory dir;
    private bool closed;
    protected internal IndexWriter writer;
    protected internal int mergeThreadCount;
    internal static bool anyExceptions;
    private bool suppressExceptions;
    private static List`1<ConcurrentMergeScheduler> allInstances;
    public int MaxThreadCount { get; public set; }
    public virtual void set_MaxThreadCount(int value);
    public virtual int get_MaxThreadCount();
    public virtual int GetMergeThreadPriority();
    public virtual void SetMergeThreadPriority(int pri);
    private bool Verbose();
    private void Message(string message);
    private void InitMergeThreadPriority();
    protected virtual void Dispose(bool disposing);
    public virtual void Sync();
    private int MergeThreadCount();
    public virtual void Merge(IndexWriter writer);
    protected internal virtual void DoMerge(OneMerge merge);
    protected internal virtual MergeThread GetMergeThread(IndexWriter writer, OneMerge merge);
    protected internal virtual void HandleMergeException(Exception exc);
    public static bool AnyUnhandledExceptions();
    public static void ClearUnhandledExceptions();
    private void AddMyself();
    public virtual void SetSuppressExceptions();
    public virtual void ClearSuppressExceptions();
    public static void SetTestMode();
}
public class Lucene.Net.Index.CorruptIndexException : IOException {
    public CorruptIndexException(string message);
    public CorruptIndexException(string message, Exception exp);
}
internal class Lucene.Net.Index.DefaultSkipListReader : MultiLevelSkipListReader {
    private bool currentFieldStoresPayloads;
    private Int64[] freqPointer;
    private Int64[] proxPointer;
    private Int32[] payloadLength;
    private long lastFreqPointer;
    private long lastProxPointer;
    private int lastPayloadLength;
    internal DefaultSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval);
    internal virtual void Init(long skipPointer, long freqBasePointer, long proxBasePointer, int df, bool storesPayloads);
    internal virtual long GetFreqPointer();
    internal virtual long GetProxPointer();
    internal virtual int GetPayloadLength();
    protected internal virtual void SeekChild(int level);
    protected internal virtual void SetLastSkipData(int level);
    protected internal virtual int ReadSkipData(int level, IndexInput skipStream);
}
internal class Lucene.Net.Index.DefaultSkipListWriter : MultiLevelSkipListWriter {
    private Int32[] lastSkipDoc;
    private Int32[] lastSkipPayloadLength;
    private Int64[] lastSkipFreqPointer;
    private Int64[] lastSkipProxPointer;
    private IndexOutput freqOutput;
    private IndexOutput proxOutput;
    private int curDoc;
    private bool curStorePayloads;
    private int curPayloadLength;
    private long curFreqPointer;
    private long curProxPointer;
    internal DefaultSkipListWriter(int skipInterval, int numberOfSkipLevels, int docCount, IndexOutput freqOutput, IndexOutput proxOutput);
    internal virtual void SetFreqOutput(IndexOutput freqOutput);
    internal virtual void SetProxOutput(IndexOutput proxOutput);
    internal virtual void SetSkipData(int doc, bool storePayloads, int payloadLength);
    protected internal virtual void ResetSkip();
    protected internal virtual void WriteSkipData(int level, IndexOutput skipBuffer);
}
public class Lucene.Net.Index.DirectoryReader : IndexReader {
    protected internal Directory internalDirectory;
    protected internal bool readOnly;
    internal IndexWriter writer;
    private IndexDeletionPolicy deletionPolicy;
    private HashSet`1<string> synced;
    private Lock writeLock;
    private SegmentInfos segmentInfos;
    private SegmentInfos segmentInfosStart;
    private bool stale;
    private int termInfosIndexDivisor;
    private bool rollbackHasChanges;
    private SegmentReader[] subReaders;
    private Int32[] starts;
    private IDictionary`2<string, Byte[]> normsCache;
    private int maxDoc;
    private int numDocs;
    private bool hasDeletions;
    private long maxIndexVersion;
    public long Version { get; }
    public int MaxDoc { get; }
    public bool HasDeletions { get; }
    public IDictionary`2<string, string> CommitUserData { get; }
    public int TermInfosIndexDivisor { get; }
    public IndexCommit IndexCommit { get; }
    internal DirectoryReader(Directory directory, SegmentInfos sis, IndexDeletionPolicy deletionPolicy, bool readOnly, int termInfosIndexDivisor);
    internal DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor);
    internal DirectoryReader(Directory directory, SegmentInfos infos, SegmentReader[] oldReaders, Int32[] oldStarts, IEnumerable`1<KeyValuePair`2<string, Byte[]>> oldNormsCache, bool readOnly, bool doClone, int termInfosIndexDivisor);
    internal static IndexReader Open(Directory directory, IndexDeletionPolicy deletionPolicy, IndexCommit commit, bool readOnly, int termInfosIndexDivisor);
    private void Initialize(SegmentReader[] subReaders);
    public virtual object Clone();
    public virtual IndexReader Clone(bool openReadOnly);
    public virtual IndexReader Reopen();
    public virtual IndexReader Reopen(bool openReadOnly);
    public virtual IndexReader Reopen(IndexCommit commit);
    private IndexReader DoReopenFromWriter(bool openReadOnly, IndexCommit commit);
    internal virtual IndexReader DoReopen(bool openReadOnly, IndexCommit commit);
    private IndexReader DoReopenNoWriter(bool openReadOnly, IndexCommit commit);
    private DirectoryReader DoReopen(SegmentInfos infos, bool doClone, bool openReadOnly);
    public virtual long get_Version();
    public virtual ITermFreqVector[] GetTermFreqVectors(int n);
    public virtual ITermFreqVector GetTermFreqVector(int n, string field);
    public virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public virtual bool IsOptimized();
    public virtual int NumDocs();
    public virtual int get_MaxDoc();
    public virtual Document Document(int n, FieldSelector fieldSelector);
    public virtual bool IsDeleted(int n);
    public virtual bool get_HasDeletions();
    protected internal virtual void DoDelete(int n);
    protected internal virtual void DoUndeleteAll();
    private int ReaderIndex(int n);
    internal static int ReaderIndex(int n, Int32[] starts, int numSubReaders);
    public virtual bool HasNorms(string field);
    public virtual Byte[] Norms(string field);
    public virtual void Norms(string field, Byte[] result, int offset);
    protected internal virtual void DoSetNorm(int n, string field, byte value_Renamed);
    public virtual TermEnum Terms();
    public virtual TermEnum Terms(Term term);
    public virtual int DocFreq(Term t);
    public virtual TermDocs TermDocs();
    public virtual TermPositions TermPositions();
    protected internal virtual void AcquireWriteLock();
    protected internal virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    internal virtual void StartCommit();
    internal virtual void RollbackCommit();
    public virtual IDictionary`2<string, string> get_CommitUserData();
    public virtual bool IsCurrent();
    protected internal virtual void DoClose();
    public virtual ICollection`1<string> GetFieldNames(FieldOption fieldNames);
    internal static ICollection`1<string> GetFieldNames(FieldOption fieldNames, IndexReader[] subReaders);
    public virtual IndexReader[] GetSequentialSubReaders();
    public virtual Directory Directory();
    public virtual int get_TermInfosIndexDivisor();
    public virtual IndexCommit get_IndexCommit();
    public static ICollection`1<IndexCommit> ListCommits(Directory dir);
}
internal abstract class Lucene.Net.Index.DocConsumer : object {
    public abstract virtual DocConsumerPerThread AddThread(DocumentsWriterThreadState perThread);
    public abstract virtual void Flush(ICollection`1<DocConsumerPerThread> threads, SegmentWriteState state);
    public abstract virtual void CloseDocStore(SegmentWriteState state);
    public abstract virtual void Abort();
    public abstract virtual bool FreeRAM();
}
internal abstract class Lucene.Net.Index.DocConsumerPerThread : object {
    public abstract virtual DocWriter ProcessDocument();
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.DocFieldConsumer : object {
    internal FieldInfos fieldInfos;
    public abstract virtual void Flush(IDictionary`2<DocFieldConsumerPerThread, ICollection`1<DocFieldConsumerPerField>> threadsAndFields, SegmentWriteState state);
    public abstract virtual void CloseDocStore(SegmentWriteState state);
    public abstract virtual void Abort();
    public abstract virtual DocFieldConsumerPerThread AddThread(DocFieldProcessorPerThread docFieldProcessorPerThread);
    public abstract virtual bool FreeRAM();
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
}
internal abstract class Lucene.Net.Index.DocFieldConsumerPerField : object {
    public abstract virtual void ProcessFields(IFieldable[] fields, int count);
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.DocFieldConsumerPerThread : object {
    public abstract virtual void StartDocument();
    public abstract virtual DocWriter FinishDocument();
    public abstract virtual DocFieldConsumerPerField AddField(FieldInfo fi);
    public abstract virtual void Abort();
}
internal class Lucene.Net.Index.DocFieldConsumers : DocFieldConsumer {
    internal DocFieldConsumer one;
    internal DocFieldConsumer two;
    internal PerDoc[] docFreeList;
    internal int freeCount;
    internal int allocCount;
    public DocFieldConsumers(DocFieldConsumer one, DocFieldConsumer two);
    private void InitBlock();
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
    public virtual void Flush(IDictionary`2<DocFieldConsumerPerThread, ICollection`1<DocFieldConsumerPerField>> threadsAndFields, SegmentWriteState state);
    public virtual void CloseDocStore(SegmentWriteState state);
    public virtual void Abort();
    public virtual bool FreeRAM();
    public virtual DocFieldConsumerPerThread AddThread(DocFieldProcessorPerThread docFieldProcessorPerThread);
    internal PerDoc GetPerDoc();
    internal void FreePerDoc(PerDoc perDoc);
}
internal class Lucene.Net.Index.DocFieldConsumersPerField : DocFieldConsumerPerField {
    internal DocFieldConsumerPerField one;
    internal DocFieldConsumerPerField two;
    internal DocFieldConsumersPerThread perThread;
    public DocFieldConsumersPerField(DocFieldConsumersPerThread perThread, DocFieldConsumerPerField one, DocFieldConsumerPerField two);
    public virtual void ProcessFields(IFieldable[] fields, int count);
    public virtual void Abort();
}
internal class Lucene.Net.Index.DocFieldConsumersPerThread : DocFieldConsumerPerThread {
    internal DocFieldConsumerPerThread one;
    internal DocFieldConsumerPerThread two;
    internal DocFieldConsumers parent;
    internal DocState docState;
    public DocFieldConsumersPerThread(DocFieldProcessorPerThread docFieldProcessorPerThread, DocFieldConsumers parent, DocFieldConsumerPerThread one, DocFieldConsumerPerThread two);
    public virtual void StartDocument();
    public virtual void Abort();
    public virtual DocWriter FinishDocument();
    public virtual DocFieldConsumerPerField AddField(FieldInfo fi);
}
internal class Lucene.Net.Index.DocFieldProcessor : DocConsumer {
    internal DocumentsWriter docWriter;
    internal FieldInfos fieldInfos;
    internal DocFieldConsumer consumer;
    internal StoredFieldsWriter fieldsWriter;
    public DocFieldProcessor(DocumentsWriter docWriter, DocFieldConsumer consumer);
    public virtual void CloseDocStore(SegmentWriteState state);
    public virtual void Flush(ICollection`1<DocConsumerPerThread> threads, SegmentWriteState state);
    public virtual void Abort();
    public virtual bool FreeRAM();
    public virtual DocConsumerPerThread AddThread(DocumentsWriterThreadState threadState);
}
internal class Lucene.Net.Index.DocFieldProcessorPerField : object {
    internal DocFieldConsumerPerField consumer;
    internal FieldInfo fieldInfo;
    internal DocFieldProcessorPerField next;
    internal int lastGen;
    internal int fieldCount;
    internal IFieldable[] fields;
    public DocFieldProcessorPerField(DocFieldProcessorPerThread perThread, FieldInfo fieldInfo);
    public void Abort();
}
internal class Lucene.Net.Index.DocFieldProcessorPerThread : DocConsumerPerThread {
    internal float docBoost;
    internal int fieldGen;
    internal DocFieldProcessor docFieldProcessor;
    internal FieldInfos fieldInfos;
    internal DocFieldConsumerPerThread consumer;
    internal DocFieldProcessorPerField[] fields;
    internal int fieldCount;
    internal DocFieldProcessorPerField[] fieldHash;
    internal int hashMask;
    internal int totalFieldCount;
    internal StoredFieldsWriterPerThread fieldsWriter;
    internal DocState docState;
    internal PerDoc[] docFreeList;
    internal int freeCount;
    internal int allocCount;
    public DocFieldProcessorPerThread(DocumentsWriterThreadState threadState, DocFieldProcessor docFieldProcessor);
    private void InitBlock();
    public virtual void Abort();
    public ICollection`1<DocFieldConsumerPerField> Fields();
    internal void TrimFields(SegmentWriteState state);
    private void Rehash();
    public virtual DocWriter ProcessDocument();
    internal void QuickSort(DocFieldProcessorPerField[] array, int lo, int hi);
    internal PerDoc GetPerDoc();
    internal void FreePerDoc(PerDoc perDoc);
}
internal class Lucene.Net.Index.DocInverter : DocFieldConsumer {
    internal InvertedDocConsumer consumer;
    internal InvertedDocEndConsumer endConsumer;
    public DocInverter(InvertedDocConsumer consumer, InvertedDocEndConsumer endConsumer);
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
    public virtual void Flush(IDictionary`2<DocFieldConsumerPerThread, ICollection`1<DocFieldConsumerPerField>> threadsAndFields, SegmentWriteState state);
    public virtual void CloseDocStore(SegmentWriteState state);
    public virtual void Abort();
    public virtual bool FreeRAM();
    public virtual DocFieldConsumerPerThread AddThread(DocFieldProcessorPerThread docFieldProcessorPerThread);
}
internal class Lucene.Net.Index.DocInverterPerField : DocFieldConsumerPerField {
    private DocInverterPerThread perThread;
    private FieldInfo fieldInfo;
    internal InvertedDocConsumerPerField consumer;
    internal InvertedDocEndConsumerPerField endConsumer;
    internal DocState docState;
    internal FieldInvertState fieldState;
    public DocInverterPerField(DocInverterPerThread perThread, FieldInfo fieldInfo);
    public virtual void Abort();
    public virtual void ProcessFields(IFieldable[] fields, int count);
}
internal class Lucene.Net.Index.DocInverterPerThread : DocFieldConsumerPerThread {
    internal DocInverter docInverter;
    internal InvertedDocConsumerPerThread consumer;
    internal InvertedDocEndConsumerPerThread endConsumer;
    internal SingleTokenAttributeSource singleToken;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal ReusableStringReader stringReader;
    public DocInverterPerThread(DocFieldProcessorPerThread docFieldProcessorPerThread, DocInverter docInverter);
    private void InitBlock();
    public virtual void StartDocument();
    public virtual DocWriter FinishDocument();
    public virtual void Abort();
    public virtual DocFieldConsumerPerField AddField(FieldInfo fi);
}
public class Lucene.Net.Index.DocumentsWriter : object {
    internal IndexWriter writer;
    internal Directory directory;
    internal string segment;
    private string docStoreSegment;
    private int docStoreOffset;
    private int nextDocID;
    private int numDocsInRAM;
    internal int numDocsInStore;
    private static int MAX_THREAD_STATE;
    private DocumentsWriterThreadState[] threadStates;
    private HashMap`2<ThreadClass, DocumentsWriterThreadState> threadBindings;
    private int pauseThreads;
    internal bool flushPending;
    internal bool bufferIsFull;
    private bool aborting;
    private DocFieldProcessor docFieldProcessor;
    internal StreamWriter infoStream;
    internal int maxFieldLength;
    internal Similarity similarity;
    internal IList`1<string> newFiles;
    internal static IndexingChain DefaultIndexingChain;
    internal DocConsumer consumer;
    private BufferedDeletes deletesInRAM;
    private BufferedDeletes deletesFlushed;
    private int maxBufferedDeleteTerms;
    private long ramBufferSize;
    private long waitQueuePauseBytes;
    private long waitQueueResumeBytes;
    private long freeTrigger;
    private long freeLevel;
    private int maxBufferedDocs;
    private int flushedDocCount;
    private bool closed;
    private ICollection`1<string> abortedFiles;
    private SegmentWriteState flushState;
    internal IList`1<string> openFiles;
    internal IList`1<string> closedFiles;
    private Term lastDeleteTerm;
    internal SkipDocWriter skipDocWriter;
    internal long numBytesAlloc;
    internal long numBytesUsed;
    internal NumberFormatInfo nf;
    internal static int OBJECT_HEADER_BYTES;
    internal static int POINTER_NUM_BYTE;
    internal static int INT_NUM_BYTE;
    internal static int CHAR_NUM_BYTE;
    internal static int BYTES_PER_DEL_TERM;
    internal static int BYTES_PER_DEL_DOCID;
    internal static int BYTES_PER_DEL_QUERY;
    internal static int BYTE_BLOCK_SHIFT;
    internal static int BYTE_BLOCK_SIZE;
    internal static int BYTE_BLOCK_MASK;
    internal static int BYTE_BLOCK_NOT_MASK;
    internal static int INT_BLOCK_SHIFT;
    internal static int INT_BLOCK_SIZE;
    internal static int INT_BLOCK_MASK;
    private List`1<Int32[]> freeIntBlocks;
    internal ByteBlockAllocator byteBlockAllocator;
    internal static int PER_DOC_BLOCK_SIZE;
    private ByteBlockAllocator perDocAllocator;
    internal static int CHAR_BLOCK_SHIFT;
    internal static int CHAR_BLOCK_SIZE;
    internal static int CHAR_BLOCK_MASK;
    internal static int MAX_TERM_LENGTH;
    private List`1<Char[]> freeCharBlocks;
    internal WaitQueue waitQueue;
    internal int MaxBufferedDocs { get; internal set; }
    internal string Segment { get; }
    internal int NumDocsInRAM { get; }
    internal string DocStoreSegment { get; }
    internal int DocStoreOffset { get; }
    internal bool AnyChanges { get; }
    internal int MaxBufferedDeleteTerms { get; internal set; }
    public static int BYTE_BLOCK_SIZE_ForNUnit { get; }
    public static int CHAR_BLOCK_SIZE_ForNUnit { get; }
    internal DocumentsWriter(Directory directory, IndexWriter writer, IndexingChain indexingChain);
    private static DocumentsWriter();
    private void InitBlock();
    internal PerDocBuffer NewPerDocBuffer();
    internal void UpdateFlushedDocCount(int n);
    internal int GetFlushedDocCount();
    internal void SetFlushedDocCount(int n);
    internal bool HasProx();
    internal void SetInfoStream(StreamWriter infoStream);
    internal void SetMaxFieldLength(int maxFieldLength);
    internal void SetSimilarity(Similarity similarity);
    internal void SetRAMBufferSizeMB(double mb);
    internal double GetRAMBufferSizeMB();
    internal int get_MaxBufferedDocs();
    internal void set_MaxBufferedDocs(int value);
    internal string get_Segment();
    internal int get_NumDocsInRAM();
    internal string get_DocStoreSegment();
    internal int get_DocStoreOffset();
    internal string CloseDocStore();
    internal ICollection`1<string> AbortedFiles();
    internal void Message(string message);
    internal IList`1<string> OpenFiles();
    internal IList`1<string> ClosedFiles();
    internal void AddOpenFile(string name);
    internal void RemoveOpenFile(string name);
    internal void SetAborting();
    internal void Abort();
    private void DoAfterFlush();
    internal bool PauseAllThreads();
    internal void ResumeAllThreads();
    private bool AllThreadsIdle();
    internal bool get_AnyChanges();
    private void InitFlushState(bool onlyDocStore);
    internal int Flush(bool closeDocStore);
    internal ICollection`1<string> GetFlushedFiles();
    internal void CreateCompoundFile(string segment);
    internal bool SetFlushPending();
    internal void ClearFlushPending();
    internal void PushDeletes();
    public sealed virtual void Dispose();
    internal void InitSegmentName(bool onlyDocStore);
    internal DocumentsWriterThreadState GetThreadState(Document doc, Term delTerm);
    internal bool AddDocument(Document doc, Analyzer analyzer);
    internal bool UpdateDocument(Term t, Document doc, Analyzer analyzer);
    internal bool UpdateDocument(Document doc, Analyzer analyzer, Term delTerm);
    internal int GetNumBufferedDeleteTerms();
    internal IDictionary`2<Term, Num> GetBufferedDeleteTerms();
    internal void RemapDeletes(SegmentInfos infos, Int32[][] docMaps, Int32[] delCounts, OneMerge merge, int mergeDocCount);
    private void WaitReady(DocumentsWriterThreadState state);
    internal bool BufferDeleteTerms(Term[] terms);
    internal bool BufferDeleteTerm(Term term);
    internal bool BufferDeleteQueries(Query[] queries);
    internal bool BufferDeleteQuery(Query query);
    internal bool DeletesFull();
    internal bool DoApplyDeletes();
    private bool TimeToFlushDeletes();
    internal void set_MaxBufferedDeleteTerms(int value);
    internal int get_MaxBufferedDeleteTerms();
    internal bool HasDeletes();
    internal bool ApplyDeletes(SegmentInfos infos);
    private bool CheckDeleteTerm(Term term);
    private bool ApplyDeletes(IndexReader reader, int docIDStart);
    private void AddDeleteTerm(Term term, int docCount);
    private void AddDeleteDocID(int docID);
    private void AddDeleteQuery(Query query, int docID);
    internal bool DoBalanceRAM();
    private void FinishDocument(DocumentsWriterThreadState perThread, DocWriter docWriter);
    internal void WaitForWaitQueue();
    internal long GetRAMUsed();
    internal Int32[] GetIntBlock(bool trackAllocations);
    internal void BytesAllocated(long numBytes);
    internal void BytesUsed(long numBytes);
    internal void RecycleIntBlocks(Int32[][] blocks, int start, int end);
    internal Char[] GetCharBlock();
    internal void RecycleCharBlocks(Char[][] blocks, int numBlocks);
    internal string ToMB(long v);
    internal void BalanceRAM();
    public static int get_BYTE_BLOCK_SIZE_ForNUnit();
    public static int get_CHAR_BLOCK_SIZE_ForNUnit();
}
internal class Lucene.Net.Index.DocumentsWriterThreadState : object {
    internal bool isIdle;
    internal int numThreads;
    internal bool doFlushAfter;
    internal DocConsumerPerThread consumer;
    internal DocState docState;
    internal DocumentsWriter docWriter;
    public DocumentsWriterThreadState(DocumentsWriter docWriter);
    internal void DoAfterFlush();
}
public class Lucene.Net.Index.FieldInfo : object {
    internal string name;
    internal bool isIndexed;
    internal int number;
    internal bool storeTermVector;
    internal bool storeOffsetWithTermVector;
    internal bool storePositionWithTermVector;
    internal bool omitNorms;
    internal bool omitTermFreqAndPositions;
    internal bool storePayloads;
    public bool storePayloads_ForNUnit { get; }
    public string name_ForNUnit { get; }
    public bool isIndexed_ForNUnit { get; }
    public bool omitNorms_ForNUnit { get; }
    public bool omitTermFreqAndPositions_ForNUnit { get; }
    public bool storeTermVector_ForNUnit { get; }
    internal FieldInfo(string na, bool tk, int nu, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool omitNorms, bool storePayloads, bool omitTermFreqAndPositions);
    public sealed virtual object Clone();
    internal void Update(bool isIndexed, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool omitNorms, bool storePayloads, bool omitTermFreqAndPositions);
    public bool get_storePayloads_ForNUnit();
    public string get_name_ForNUnit();
    public bool get_isIndexed_ForNUnit();
    public bool get_omitNorms_ForNUnit();
    public bool get_omitTermFreqAndPositions_ForNUnit();
    public bool get_storeTermVector_ForNUnit();
}
public class Lucene.Net.Index.FieldInfos : object {
    public static int FORMAT_PRE;
    public static int FORMAT_START;
    internal static int CURRENT_FORMAT;
    internal static byte IS_INDEXED;
    internal static byte STORE_TERMVECTOR;
    internal static byte STORE_POSITIONS_WITH_TERMVECTOR;
    internal static byte STORE_OFFSET_WITH_TERMVECTOR;
    internal static byte OMIT_NORMS;
    internal static byte STORE_PAYLOADS;
    internal static byte OMIT_TERM_FREQ_AND_POSITIONS;
    private List`1<FieldInfo> byNumber;
    private HashMap`2<string, FieldInfo> byName;
    private int format;
    public FieldInfos(Directory d, string name);
    private static FieldInfos();
    public sealed virtual object Clone();
    public void Add(Document doc);
    internal bool HasProx();
    public void AddIndexed(ICollection`1<string> names, bool storeTermVectors, bool storePositionWithTermVector, bool storeOffsetWithTermVector);
    public void Add(ICollection`1<string> names, bool isIndexed);
    public void Add(string name, bool isIndexed);
    public void Add(string name, bool isIndexed, bool storeTermVector);
    public void Add(string name, bool isIndexed, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector);
    public void Add(string name, bool isIndexed, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool omitNorms);
    public FieldInfo Add(string name, bool isIndexed, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool omitNorms, bool storePayloads, bool omitTermFreqAndPositions);
    private FieldInfo AddInternal(string name, bool isIndexed, bool storeTermVector, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool omitNorms, bool storePayloads, bool omitTermFreqAndPositions);
    public int FieldNumber(string fieldName);
    public FieldInfo FieldInfo(string fieldName);
    public string FieldName(int fieldNumber);
    public FieldInfo FieldInfo(int fieldNumber);
    public int Size();
    public bool HasVectors();
    public void Write(Directory d, string name);
    public void Write(IndexOutput output);
    private void Read(IndexInput input, string fileName);
}
public class Lucene.Net.Index.FieldInvertState : object {
    internal int position;
    internal int length;
    internal int numOverlap;
    internal int offset;
    internal float boost;
    internal AttributeSource attributeSource;
    public int Position { get; }
    public int Length { get; }
    public int NumOverlap { get; }
    public int Offset { get; }
    public float Boost { get; }
    public AttributeSource AttributeSource { get; }
    public FieldInvertState(int position, int length, int numOverlap, int offset, float boost);
    internal void Reset(float docBoost);
    public int get_Position();
    public int get_Length();
    public int get_NumOverlap();
    public int get_Offset();
    public float get_Boost();
    public AttributeSource get_AttributeSource();
}
public class Lucene.Net.Index.FieldReaderException : SystemException {
    public FieldReaderException(Exception cause);
    public FieldReaderException(string message);
    public FieldReaderException(string message, Exception cause);
}
public class Lucene.Net.Index.FieldSortedTermVectorMapper : TermVectorMapper {
    private IDictionary`2<string, SortedSet`1<TermVectorEntry>> fieldToTerms;
    private SortedSet`1<TermVectorEntry> currentSet;
    private string currentField;
    private IComparer`1<TermVectorEntry> comparator;
    public IDictionary`2<string, SortedSet`1<TermVectorEntry>> FieldToTerms { get; }
    public IComparer`1<TermVectorEntry> Comparator { get; }
    public FieldSortedTermVectorMapper(IComparer`1<TermVectorEntry> comparator);
    public FieldSortedTermVectorMapper(bool ignoringPositions, bool ignoringOffsets, IComparer`1<TermVectorEntry> comparator);
    public virtual void Map(string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual void SetExpectations(string field, int numTerms, bool storeOffsets, bool storePositions);
    public virtual IDictionary`2<string, SortedSet`1<TermVectorEntry>> get_FieldToTerms();
    public virtual IComparer`1<TermVectorEntry> get_Comparator();
}
public class Lucene.Net.Index.FieldsReader : object {
    private FieldInfos fieldInfos;
    private IndexInput cloneableFieldsStream;
    private IndexInput fieldsStream;
    private IndexInput cloneableIndexStream;
    private IndexInput indexStream;
    private int numTotalDocs;
    private int size;
    private bool closed;
    private int format;
    private int formatSize;
    private int docStoreOffset;
    private CloseableThreadLocal`1<IndexInput> fieldsStreamTL;
    private bool isOriginal;
    private FieldsReader(FieldInfos fieldInfos, int numTotalDocs, int size, int format, int formatSize, int docStoreOffset, IndexInput cloneableFieldsStream, IndexInput cloneableIndexStream);
    public FieldsReader(Directory d, string segment, FieldInfos fn);
    internal FieldsReader(Directory d, string segment, FieldInfos fn, int readBufferSize);
    internal FieldsReader(Directory d, string segment, FieldInfos fn, int readBufferSize, int docStoreOffset, int size);
    public sealed virtual object Clone();
    internal void EnsureOpen();
    public sealed virtual void Dispose();
    public int Size();
    private void SeekIndex(int docID);
    internal bool CanReadRawDocs();
    public Document Doc(int n, FieldSelector fieldSelector);
    internal IndexInput RawDocs(Int32[] lengths, int startDocID, int numDocs);
    private void SkipField(bool binary, bool compressed);
    private void SkipField(bool binary, bool compressed, int toRead);
    private void AddFieldLazy(Document doc, FieldInfo fi, bool binary, bool compressed, bool tokenize);
    private void AddField(Document doc, FieldInfo fi, bool binary, bool compressed, bool tokenize);
    private int AddFieldSize(Document doc, FieldInfo fi, bool binary, bool compressed);
    private Byte[] Uncompress(Byte[] b);
}
internal class Lucene.Net.Index.FieldsWriter : object {
    internal static byte FIELD_IS_TOKENIZED;
    internal static byte FIELD_IS_BINARY;
    [ObsoleteAttribute("Kept for backwards-compatibility with <3.0 indexes; will be removed in 4.0")]
internal static byte FIELD_IS_COMPRESSED;
    internal static int FORMAT;
    internal static int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES;
    internal static int FORMAT_LUCENE_3_0_NO_COMPRESSED_FIELDS;
    internal static int FORMAT_CURRENT;
    private FieldInfos fieldInfos;
    private IndexOutput fieldsStream;
    private IndexOutput indexStream;
    private bool doClose;
    internal FieldsWriter(Directory d, string segment, FieldInfos fn);
    internal FieldsWriter(IndexOutput fdx, IndexOutput fdt, FieldInfos fn);
    private static FieldsWriter();
    internal void SetFieldsStream(IndexOutput stream);
    internal void FlushDocument(int numStoredFields, RAMOutputStream buffer);
    internal void SkipDocument();
    internal void Flush();
    public sealed virtual void Dispose();
    internal void WriteField(FieldInfo fi, IFieldable field);
    internal void AddRawDocuments(IndexInput stream, Int32[] lengths, int numDocs);
    internal void AddDocument(Document doc);
}
public class Lucene.Net.Index.FilterIndexReader : IndexReader {
    protected internal IndexReader in_Renamed;
    public int MaxDoc { get; }
    public bool HasDeletions { get; }
    public long Version { get; }
    public object FieldCacheKey { get; }
    public object DeletesCacheKey { get; }
    public FilterIndexReader(IndexReader in_Renamed);
    public virtual Directory Directory();
    public virtual ITermFreqVector[] GetTermFreqVectors(int docNumber);
    public virtual ITermFreqVector GetTermFreqVector(int docNumber, string field);
    public virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public virtual int NumDocs();
    public virtual int get_MaxDoc();
    public virtual Document Document(int n, FieldSelector fieldSelector);
    public virtual bool IsDeleted(int n);
    public virtual bool get_HasDeletions();
    protected internal virtual void DoUndeleteAll();
    public virtual bool HasNorms(string field);
    public virtual Byte[] Norms(string f);
    public virtual void Norms(string f, Byte[] bytes, int offset);
    protected internal virtual void DoSetNorm(int d, string f, byte b);
    public virtual TermEnum Terms();
    public virtual TermEnum Terms(Term t);
    public virtual int DocFreq(Term t);
    public virtual TermDocs TermDocs();
    public virtual TermDocs TermDocs(Term term);
    public virtual TermPositions TermPositions();
    protected internal virtual void DoDelete(int n);
    protected internal virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    protected internal virtual void DoClose();
    public virtual ICollection`1<string> GetFieldNames(FieldOption fieldNames);
    public virtual long get_Version();
    public virtual bool IsCurrent();
    public virtual bool IsOptimized();
    public virtual IndexReader[] GetSequentialSubReaders();
    public virtual object Clone();
    public virtual object get_FieldCacheKey();
    public virtual object get_DeletesCacheKey();
}
internal abstract class Lucene.Net.Index.FormatPostingsDocsConsumer : object {
    internal abstract virtual FormatPostingsPositionsConsumer AddDoc(int docID, int termDocFreq);
    internal abstract virtual void Finish();
}
internal class Lucene.Net.Index.FormatPostingsDocsWriter : FormatPostingsDocsConsumer {
    internal IndexOutput out_Renamed;
    internal FormatPostingsTermsWriter parent;
    internal FormatPostingsPositionsWriter posWriter;
    internal DefaultSkipListWriter skipListWriter;
    internal int skipInterval;
    internal int totalNumDocs;
    internal bool omitTermFreqAndPositions;
    internal bool storePayloads;
    internal long freqStart;
    internal FieldInfo fieldInfo;
    internal int lastDocID;
    internal int df;
    private TermInfo termInfo;
    internal UTF8Result utf8;
    internal FormatPostingsDocsWriter(SegmentWriteState state, FormatPostingsTermsWriter parent);
    internal void SetField(FieldInfo fieldInfo);
    internal virtual FormatPostingsPositionsConsumer AddDoc(int docID, int termDocFreq);
    internal virtual void Finish();
    public sealed virtual void Dispose();
}
internal abstract class Lucene.Net.Index.FormatPostingsFieldsConsumer : object {
    internal abstract virtual FormatPostingsTermsConsumer AddField(FieldInfo field);
    internal abstract virtual void Finish();
}
internal class Lucene.Net.Index.FormatPostingsFieldsWriter : FormatPostingsFieldsConsumer {
    internal Directory dir;
    internal string segment;
    internal TermInfosWriter termsOut;
    internal FieldInfos fieldInfos;
    internal FormatPostingsTermsWriter termsWriter;
    internal DefaultSkipListWriter skipListWriter;
    internal int totalNumDocs;
    public FormatPostingsFieldsWriter(SegmentWriteState state, FieldInfos fieldInfos);
    internal virtual FormatPostingsTermsConsumer AddField(FieldInfo field);
    internal virtual void Finish();
}
internal abstract class Lucene.Net.Index.FormatPostingsPositionsConsumer : object {
    internal abstract virtual void AddPosition(int position, Byte[] payload, int payloadOffset, int payloadLength);
    internal abstract virtual void Finish();
}
internal class Lucene.Net.Index.FormatPostingsPositionsWriter : FormatPostingsPositionsConsumer {
    internal FormatPostingsDocsWriter parent;
    internal IndexOutput out_Renamed;
    internal bool omitTermFreqAndPositions;
    internal bool storePayloads;
    internal int lastPayloadLength;
    internal int lastPosition;
    internal FormatPostingsPositionsWriter(SegmentWriteState state, FormatPostingsDocsWriter parent);
    internal virtual void AddPosition(int position, Byte[] payload, int payloadOffset, int payloadLength);
    internal void SetField(FieldInfo fieldInfo);
    internal virtual void Finish();
    public void Dispose();
}
internal abstract class Lucene.Net.Index.FormatPostingsTermsConsumer : object {
    internal Char[] termBuffer;
    internal abstract virtual FormatPostingsDocsConsumer AddTerm(Char[] text, int start);
    internal virtual FormatPostingsDocsConsumer AddTerm(string text);
    internal abstract virtual void Finish();
}
internal class Lucene.Net.Index.FormatPostingsTermsWriter : FormatPostingsTermsConsumer {
    internal FormatPostingsFieldsWriter parent;
    internal FormatPostingsDocsWriter docsWriter;
    internal TermInfosWriter termsOut;
    internal FieldInfo fieldInfo;
    internal Char[] currentTerm;
    internal int currentTermStart;
    internal long freqStart;
    internal long proxStart;
    internal FormatPostingsTermsWriter(SegmentWriteState state, FormatPostingsFieldsWriter parent);
    internal void SetField(FieldInfo fieldInfo);
    internal virtual FormatPostingsDocsConsumer AddTerm(Char[] text, int start);
    internal virtual void Finish();
    public sealed virtual void Dispose();
}
internal class Lucene.Net.Index.FreqProxFieldMergeState : object {
    internal FreqProxTermsWriterPerField field;
    internal int numPostings;
    internal CharBlockPool charPool;
    internal RawPostingList[] postings;
    private PostingList p;
    internal Char[] text;
    internal int textOffset;
    private int postingUpto;
    internal ByteSliceReader freq;
    internal ByteSliceReader prox;
    internal int docID;
    internal int termFreq;
    public FreqProxFieldMergeState(FreqProxTermsWriterPerField field);
    internal bool NextTerm();
    public bool NextDoc();
}
internal class Lucene.Net.Index.FreqProxTermsWriter : TermsHashConsumer {
    private Byte[] payloadBuffer;
    internal UTF8Result termsUTF8;
    public virtual TermsHashConsumerPerThread AddThread(TermsHashPerThread perThread);
    internal virtual void CreatePostings(RawPostingList[] postings, int start, int count);
    private static int compareText(Char[] text1, int pos1, Char[] text2, int pos2);
    internal virtual void CloseDocStore(SegmentWriteState state);
    public virtual void Abort();
    public virtual void Flush(IDictionary`2<TermsHashConsumerPerThread, ICollection`1<TermsHashConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal void AppendPostings(FreqProxTermsWriterPerField[] fields, FormatPostingsFieldsConsumer consumer);
    internal virtual int BytesPerPosting();
}
internal class Lucene.Net.Index.FreqProxTermsWriterPerField : TermsHashConsumerPerField {
    internal FreqProxTermsWriterPerThread perThread;
    internal TermsHashPerField termsHashPerField;
    internal FieldInfo fieldInfo;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal bool omitTermFreqAndPositions;
    internal IPayloadAttribute payloadAttribute;
    internal bool hasPayloads;
    public FreqProxTermsWriterPerField(TermsHashPerField termsHashPerField, FreqProxTermsWriterPerThread perThread, FieldInfo fieldInfo);
    internal virtual int GetStreamCount();
    internal virtual void Finish();
    internal virtual void SkippingLongTerm();
    public sealed virtual int CompareTo(FreqProxTermsWriterPerField other);
    internal void Reset();
    internal virtual bool Start(IFieldable[] fields, int count);
    internal virtual void Start(IFieldable f);
    internal void WriteProx(PostingList p, int proxCode);
    internal virtual void NewTerm(RawPostingList p0);
    internal virtual void AddTerm(RawPostingList p0);
    public void Abort();
}
internal class Lucene.Net.Index.FreqProxTermsWriterPerThread : TermsHashConsumerPerThread {
    internal TermsHashPerThread termsHashPerThread;
    internal DocState docState;
    public FreqProxTermsWriterPerThread(TermsHashPerThread perThread);
    public virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
    public virtual void StartDocument();
    public virtual DocWriter FinishDocument();
    public virtual void Abort();
}
public abstract class Lucene.Net.Index.IndexCommit : object {
    public string SegmentsFileName { get; }
    public ICollection`1<string> FileNames { get; }
    public Directory Directory { get; }
    public bool IsDeleted { get; }
    public bool IsOptimized { get; }
    public long Version { get; }
    public long Generation { get; }
    public long Timestamp { get; }
    public IDictionary`2<string, string> UserData { get; }
    public abstract virtual string get_SegmentsFileName();
    public abstract virtual ICollection`1<string> get_FileNames();
    public abstract virtual Directory get_Directory();
    public abstract virtual void Delete();
    public abstract virtual bool get_IsDeleted();
    public abstract virtual bool get_IsOptimized();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual long get_Version();
    public abstract virtual long get_Generation();
    public virtual long get_Timestamp();
    public abstract virtual IDictionary`2<string, string> get_UserData();
}
public interface Lucene.Net.Index.IndexDeletionPolicy {
    public abstract virtual void OnInit(IList`1<T> commits);
    public abstract virtual void OnCommit(IList`1<T> commits);
}
public class Lucene.Net.Index.IndexFileDeleter : object {
    private IList`1<string> deletable;
    private IDictionary`2<string, RefCount> refCounts;
    private List`1<CommitPoint> commits;
    private List`1<ICollection`1<string>> lastFiles;
    private List`1<CommitPoint> commitsToDelete;
    private StreamWriter infoStream;
    private Directory directory;
    private IndexDeletionPolicy policy;
    private DocumentsWriter docWriter;
    internal bool startingCommitDeleted;
    private SegmentInfos lastSegmentInfos;
    private HashSet`1<string> synced;
    public static bool VERBOSE_REF_COUNTS;
    public SegmentInfos LastSegmentInfos { get; }
    public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, StreamWriter infoStream, DocumentsWriter docWriter, HashSet`1<string> synced);
    internal void SetInfoStream(StreamWriter infoStream);
    private void Message(string message);
    public SegmentInfos get_LastSegmentInfos();
    private void DeleteCommits();
    public void Refresh(string segmentName);
    public void Refresh();
    public sealed virtual void Dispose();
    private void DeletePendingFiles();
    public void Checkpoint(SegmentInfos segmentInfos, bool isCommit);
    internal void IncRef(SegmentInfos segmentInfos, bool isCommit);
    internal void IncRef(ICollection`1<string> files);
    internal void IncRef(string fileName);
    internal void DecRef(ICollection`1<string> files);
    internal void DecRef(string fileName);
    internal void DecRef(SegmentInfos segmentInfos);
    public bool Exists(string fileName);
    private RefCount GetRefCount(string fileName);
    internal void DeleteFiles(IList`1<string> files);
    internal void DeleteNewFiles(ICollection`1<string> files);
    internal void DeleteFile(string fileName);
}
public class Lucene.Net.Index.IndexFileNameFilter : object {
    private static IndexFileNameFilter singleton;
    private HashSet`1<string> extensions;
    private HashSet`1<string> extensionsInCFS;
    public static IndexFileNameFilter Filter { get; }
    private static IndexFileNameFilter();
    public virtual bool Accept(FileInfo dir, string name);
    public virtual bool IsCFSFile(string name);
    public static IndexFileNameFilter get_Filter();
}
public class Lucene.Net.Index.IndexFileNames : object {
    public static string SEGMENTS;
    public static string SEGMENTS_GEN;
    public static string DELETABLE;
    public static string NORMS_EXTENSION;
    public static string FREQ_EXTENSION;
    public static string PROX_EXTENSION;
    public static string TERMS_EXTENSION;
    public static string TERMS_INDEX_EXTENSION;
    public static string FIELDS_INDEX_EXTENSION;
    public static string FIELDS_EXTENSION;
    public static string VECTORS_FIELDS_EXTENSION;
    public static string VECTORS_DOCUMENTS_EXTENSION;
    public static string VECTORS_INDEX_EXTENSION;
    public static string COMPOUND_FILE_EXTENSION;
    public static string COMPOUND_FILE_STORE_EXTENSION;
    internal static string DELETES_EXTENSION;
    public static string FIELD_INFOS_EXTENSION;
    public static string PLAIN_NORMS_EXTENSION;
    public static string SEPARATE_NORMS_EXTENSION;
    public static string GEN_EXTENSION;
    public static String[] INDEX_EXTENSIONS;
    public static String[] INDEX_EXTENSIONS_IN_COMPOUND_FILE;
    public static String[] STORE_INDEX_EXTENSIONS;
    public static String[] NON_STORE_INDEX_EXTENSIONS;
    public static String[] COMPOUND_EXTENSIONS;
    public static String[] VECTOR_EXTENSIONS;
    private static IndexFileNames();
    public static string FileNameFromGeneration(string base_Renamed, string extension, long gen);
    internal static bool IsDocStoreFile(string fileName);
    internal static string SegmentFileName(string segmentName, string ext);
}
[DefaultMemberAttribute("Item")]
public abstract class Lucene.Net.Index.IndexReader : object {
    private bool closed;
    protected internal bool hasChanges;
    private int refCount;
    protected internal static int DEFAULT_TERMS_INDEX_DIVISOR;
    public int RefCount { get; }
    public long Version { get; }
    public IDictionary`2<string, string> CommitUserData { get; }
    public int MaxDoc { get; }
    public int NumDeletedDocs { get; }
    public Document Item { get; }
    public bool HasDeletions { get; }
    public IndexCommit IndexCommit { get; }
    public object FieldCacheKey { get; }
    public object DeletesCacheKey { get; }
    public long UniqueTermCount { get; }
    public int TermInfosIndexDivisor { get; }
    private static IndexReader();
    public virtual int get_RefCount();
    public virtual void IncRef();
    public virtual void DecRef();
    protected internal void EnsureOpen();
    public static IndexReader Open(Directory directory, bool readOnly);
    public static IndexReader Open(IndexCommit commit, bool readOnly);
    public static IndexReader Open(Directory directory, IndexDeletionPolicy deletionPolicy, bool readOnly);
    public static IndexReader Open(Directory directory, IndexDeletionPolicy deletionPolicy, bool readOnly, int termInfosIndexDivisor);
    public static IndexReader Open(IndexCommit commit, IndexDeletionPolicy deletionPolicy, bool readOnly);
    public static IndexReader Open(IndexCommit commit, IndexDeletionPolicy deletionPolicy, bool readOnly, int termInfosIndexDivisor);
    private static IndexReader Open(Directory directory, IndexDeletionPolicy deletionPolicy, IndexCommit commit, bool readOnly, int termInfosIndexDivisor);
    public virtual IndexReader Reopen();
    public virtual IndexReader Reopen(bool openReadOnly);
    public virtual IndexReader Reopen(IndexCommit commit);
    public virtual object Clone();
    public virtual IndexReader Clone(bool openReadOnly);
    public virtual Directory Directory();
    public static long LastModified(Directory directory2);
    public static long GetCurrentVersion(Directory directory);
    public static IDictionary`2<string, string> GetCommitUserData(Directory directory);
    public virtual long get_Version();
    public virtual IDictionary`2<string, string> get_CommitUserData();
    public virtual bool IsCurrent();
    public virtual bool IsOptimized();
    public abstract virtual ITermFreqVector[] GetTermFreqVectors(int docNumber);
    public abstract virtual ITermFreqVector GetTermFreqVector(int docNumber, string field);
    public abstract virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public abstract virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public static bool IndexExists(Directory directory);
    public abstract virtual int NumDocs();
    public abstract virtual int get_MaxDoc();
    public virtual int get_NumDeletedDocs();
    public virtual Document Document(int n);
    public Document get_Item(int doc);
    public abstract virtual Document Document(int n, FieldSelector fieldSelector);
    public abstract virtual bool IsDeleted(int n);
    public abstract virtual bool get_HasDeletions();
    public virtual bool HasNorms(string field);
    public abstract virtual Byte[] Norms(string field);
    public abstract virtual void Norms(string field, Byte[] bytes, int offset);
    public virtual void SetNorm(int doc, string field, byte value);
    protected internal abstract virtual void DoSetNorm(int doc, string field, byte value_Renamed);
    public virtual void SetNorm(int doc, string field, float value);
    public abstract virtual TermEnum Terms();
    public abstract virtual TermEnum Terms(Term t);
    public abstract virtual int DocFreq(Term t);
    public virtual TermDocs TermDocs(Term term);
    public abstract virtual TermDocs TermDocs();
    public virtual TermPositions TermPositions(Term term);
    public abstract virtual TermPositions TermPositions();
    public virtual void DeleteDocument(int docNum);
    protected internal abstract virtual void DoDelete(int docNum);
    public virtual int DeleteDocuments(Term term);
    public virtual void UndeleteAll();
    protected internal abstract virtual void DoUndeleteAll();
    protected internal virtual void AcquireWriteLock();
    public void Flush();
    public void Flush(IDictionary`2<string, string> commitUserData);
    public void Commit();
    public void Commit(IDictionary`2<string, string> commitUserData);
    protected internal abstract virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected internal abstract virtual void DoClose();
    public abstract virtual ICollection`1<string> GetFieldNames(FieldOption fldOption);
    public virtual IndexCommit get_IndexCommit();
    [STAThreadAttribute]
public static void Main(String[] args);
    public static ICollection`1<IndexCommit> ListCommits(Directory dir);
    public virtual IndexReader[] GetSequentialSubReaders();
    public virtual object get_FieldCacheKey();
    public virtual object get_DeletesCacheKey();
    public virtual long get_UniqueTermCount();
    public virtual int get_TermInfosIndexDivisor();
}
public class Lucene.Net.Index.IndexWriter : object {
    public static long WRITE_LOCK_TIMEOUT;
    private long writeLockTimeout;
    public static string WRITE_LOCK_NAME;
    public static int DISABLE_AUTO_FLUSH;
    public static int DEFAULT_MAX_BUFFERED_DOCS;
    public static double DEFAULT_RAM_BUFFER_SIZE_MB;
    public static int DEFAULT_MAX_BUFFERED_DELETE_TERMS;
    public static int DEFAULT_MAX_FIELD_LENGTH;
    public static int DEFAULT_TERM_INDEX_INTERVAL;
    public static int MAX_TERM_LENGTH;
    private static int MERGE_READ_BUFFER_SIZE;
    private static object MESSAGE_ID_LOCK;
    private static int MESSAGE_ID;
    private int messageID;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hitOOM;
    private Directory directory;
    private Analyzer analyzer;
    private Similarity similarity;
    private UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) changeCount;
    private long lastCommitChangeCount;
    private SegmentInfos rollbackSegmentInfos;
    private HashMap`2<SegmentInfo, Nullable`1<int>> rollbackSegments;
    internal SegmentInfos modreq(System.Runtime.CompilerServices.IsVolatile) pendingCommit;
    internal UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) pendingCommitChangeCount;
    private SegmentInfos localRollbackSegmentInfos;
    private int localFlushedDocCount;
    private SegmentInfos segmentInfos;
    private int optimizeMaxNumSegments;
    private DocumentsWriter docWriter;
    private IndexFileDeleter deleter;
    private ISet`1<SegmentInfo> segmentsToOptimize;
    private Lock writeLock;
    private int termIndexInterval;
    private bool closed;
    private bool closing;
    private HashSet`1<SegmentInfo> mergingSegments;
    private MergePolicy mergePolicy;
    private MergeScheduler mergeScheduler;
    private LinkedList`1<OneMerge> pendingMerges;
    private ISet`1<OneMerge> runningMerges;
    private IList`1<OneMerge> mergeExceptions;
    private long mergeGen;
    private bool stopMerges;
    private int flushCount;
    private int flushDeletesCount;
    private int readCount;
    private ThreadClass writeThread;
    internal ReaderPool readerPool;
    private int upgradeCount;
    private int readerTermsIndexDivisor;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) poolReaders;
    private int maxFieldLength;
    private StreamWriter infoStream;
    private static StreamWriter defaultInfoStream;
    private object commitLock;
    private HashSet`1<string> synced;
    private HashSet`1<string> syncing;
    private IndexReaderWarmer mergedSegmentWarmer;
    private LogMergePolicy LogMergePolicy { get; }
    public bool UseCompoundFile { get; public set; }
    public Similarity Similarity { get; }
    public int TermIndexInterval { get; public set; }
    public MergePolicy MergePolicy { get; }
    public MergeScheduler MergeScheduler { get; }
    public int MaxMergeDocs { get; public set; }
    public int ReaderTermsIndexDivisor { get; public set; }
    public int MergeFactor { get; public set; }
    public static StreamWriter DefaultInfoStream { get; public set; }
    public StreamWriter InfoStream { get; }
    public bool Verbose { get; }
    public long WriteLockTimeout { get; public set; }
    public static long DefaultWriteLockTimeout { get; public set; }
    public Directory Directory { get; }
    public Analyzer Analyzer { get; }
    public IndexReaderWarmer MergedSegmentWarmer { get; public set; }
    public IndexWriter(Directory d, Analyzer a, bool create, MaxFieldLength mfl);
    public IndexWriter(Directory d, Analyzer a, MaxFieldLength mfl);
    public IndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl);
    public IndexWriter(Directory d, Analyzer a, bool create, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl);
    internal IndexWriter(Directory d, Analyzer a, bool create, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IndexingChain indexingChain, IndexCommit commit);
    public IndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IndexCommit commit);
    private static IndexWriter();
    private void InitBlock();
    public virtual IndexReader GetReader();
    public virtual IndexReader GetReader(int termInfosIndexDivisor);
    public virtual int NumDeletedDocs(SegmentInfo info);
    internal virtual void AcquireWrite();
    internal virtual void ReleaseWrite();
    internal virtual void AcquireRead();
    internal virtual void UpgradeReadToWrite();
    internal virtual void ReleaseRead();
    internal bool IsOpen(bool includePendingClose);
    protected internal void EnsureOpen(bool includePendingClose);
    protected internal void EnsureOpen();
    public virtual void Message(string message);
    private void SetMessageID(StreamWriter infoStream);
    private LogMergePolicy get_LogMergePolicy();
    public virtual bool get_UseCompoundFile();
    public virtual void set_UseCompoundFile(bool value);
    public virtual void SetSimilarity(Similarity similarity);
    public virtual Similarity get_Similarity();
    public virtual int get_TermIndexInterval();
    public virtual void set_TermIndexInterval(int value);
    private void Init(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, int maxFieldLength, IndexingChain indexingChain, IndexCommit commit);
    private void Init(Directory d, Analyzer a, bool create, IndexDeletionPolicy deletionPolicy, int maxFieldLength, IndexingChain indexingChain, IndexCommit commit);
    private void SetRollbackSegmentInfos(SegmentInfos infos);
    public virtual void SetMergePolicy(MergePolicy mp);
    public virtual MergePolicy get_MergePolicy();
    public virtual void SetMergeScheduler(MergeScheduler mergeScheduler);
    public virtual MergeScheduler get_MergeScheduler();
    public virtual int get_MaxMergeDocs();
    public virtual void set_MaxMergeDocs(int value);
    public virtual void SetMaxFieldLength(int maxFieldLength);
    public virtual int GetMaxFieldLength();
    public int get_ReaderTermsIndexDivisor();
    public void set_ReaderTermsIndexDivisor(int value);
    public virtual void SetMaxBufferedDocs(int maxBufferedDocs);
    private void PushMaxBufferedDocs();
    public virtual int GetMaxBufferedDocs();
    public virtual void SetRAMBufferSizeMB(double mb);
    public virtual double GetRAMBufferSizeMB();
    public virtual void SetMaxBufferedDeleteTerms(int maxBufferedDeleteTerms);
    public virtual int GetMaxBufferedDeleteTerms();
    public virtual void set_MergeFactor(int value);
    public virtual int get_MergeFactor();
    public static void set_DefaultInfoStream(StreamWriter value);
    public static StreamWriter get_DefaultInfoStream();
    public virtual void SetInfoStream(StreamWriter infoStream);
    private void MessageState();
    public virtual StreamWriter get_InfoStream();
    public virtual bool get_Verbose();
    public virtual long get_WriteLockTimeout();
    public virtual void set_WriteLockTimeout(long value);
    public static void set_DefaultWriteLockTimeout(long value);
    public static long get_DefaultWriteLockTimeout();
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public virtual void Dispose();
    public virtual void Dispose(bool waitForMerges);
    protected virtual void Dispose(bool disposing, bool waitForMerges);
    [ObsoleteAttribute("Use Dispose(bool) instead")]
public virtual void Close(bool waitForMerges);
    private bool ShouldClose();
    private void CloseInternal(bool waitForMerges);
    private bool FlushDocStores();
    public virtual Directory get_Directory();
    public virtual Analyzer get_Analyzer();
    public virtual int MaxDoc();
    public virtual int NumDocs();
    public virtual bool HasDeletions();
    public virtual void AddDocument(Document doc);
    public virtual void AddDocument(Document doc, Analyzer analyzer);
    public virtual void DeleteDocuments(Term term);
    public virtual void DeleteDocuments(Term[] terms);
    public virtual void DeleteDocuments(Query query);
    public virtual void DeleteDocuments(Query[] queries);
    public virtual void UpdateDocument(Term term, Document doc);
    public virtual void UpdateDocument(Term term, Document doc, Analyzer analyzer);
    internal int GetSegmentCount();
    internal int GetNumBufferedDocuments();
    public int GetDocCount(int i);
    internal int GetFlushCount();
    internal int GetFlushDeletesCount();
    internal string NewSegmentName();
    public virtual void Optimize();
    public virtual void Optimize(int maxNumSegments);
    public virtual void Optimize(bool doWait);
    public virtual void Optimize(int maxNumSegments, bool doWait);
    private bool OptimizeMergesPending();
    public virtual void ExpungeDeletes(bool doWait);
    public virtual void ExpungeDeletes();
    public void MaybeMerge();
    private void MaybeMerge(bool optimize);
    private void MaybeMerge(int maxNumSegmentsOptimize, bool optimize);
    private void UpdatePendingMerges(int maxNumSegmentsOptimize, bool optimize);
    internal virtual OneMerge GetNextMerge();
    private OneMerge GetNextExternalMerge();
    private void StartTransaction(bool haveReadLock);
    private void RollbackTransaction();
    private void CommitTransaction();
    public virtual void Rollback();
    private void RollbackInternal();
    public virtual void DeleteAll();
    private void FinishMerges(bool waitForMerges);
    public virtual void WaitForMerges();
    private void Checkpoint();
    private void FinishAddIndexes();
    private void BlockAddIndexes(bool includePendingClose);
    private void ResumeAddIndexes();
    private void ResetMergeExceptions();
    private void NoDupDirs(Directory[] dirs);
    public virtual void AddIndexesNoOptimize(Directory[] dirs);
    private bool HasExternalSegments();
    private void ResolveExternalSegments();
    public virtual void AddIndexes(IndexReader[] readers);
    protected virtual void DoAfterFlush();
    protected virtual void DoBeforeFlush();
    public void PrepareCommit();
    private void PrepareCommit(IDictionary`2<string, string> commitUserData);
    private void Commit(long sizeInBytes);
    public void Commit();
    public void Commit(IDictionary`2<string, string> commitUserData);
    private void FinishCommit();
    public void Flush(bool triggerMerge, bool flushDocStores, bool flushDeletes);
    private bool DoFlush(bool flushDocStores, bool flushDeletes);
    private bool DoFlushInternal(bool flushDocStores, bool flushDeletes);
    public long RamSizeInBytes();
    public int NumRamDocs();
    private int EnsureContiguousMerge(OneMerge merge);
    private void CommitMergedDeletes(OneMerge merge, SegmentReader mergeReader);
    private bool CommitMerge(OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader);
    private void HandleMergeException(Exception t, OneMerge merge);
    public void Merge_ForNUnit(OneMerge merge);
    internal void Merge(OneMerge merge);
    internal virtual void MergeSuccess(OneMerge merge);
    internal bool RegisterMerge(OneMerge merge);
    internal void MergeInit(OneMerge merge);
    private void _MergeInit(OneMerge merge);
    private void SetDiagnostics(SegmentInfo info, string source);
    private void SetDiagnostics(SegmentInfo info, string source, IDictionary`2<string, string> details);
    internal void MergeFinish(OneMerge merge);
    private void SetMergeDocStoreIsCompoundFile(OneMerge merge);
    private void CloseMergeReaders(OneMerge merge, bool suppressExceptions);
    private int MergeMiddle(OneMerge merge);
    internal virtual void AddMergeException(OneMerge merge);
    private bool ApplyDeletes();
    internal int GetBufferedDeleteTermsSize();
    internal int GetNumBufferedDeleteTerms();
    public virtual SegmentInfo NewestSegment();
    public virtual string SegString();
    private string SegString(SegmentInfos infos);
    private bool StartSync(string fileName, ICollection`1<string> pending);
    private void FinishSync(string fileName, bool success);
    private bool WaitForAllSynced(ICollection`1<string> syncing);
    private void DoWait();
    private void StartCommit(long sizeInBytes, IDictionary`2<string, string> commitUserData);
    public static bool IsLocked(Directory directory);
    public static void Unlock(Directory directory);
    public virtual void set_MergedSegmentWarmer(IndexReaderWarmer value);
    public virtual IndexReaderWarmer get_MergedSegmentWarmer();
    private void HandleOOM(OutOfMemoryException oom, string location);
    public virtual bool TestPoint(string name);
    internal virtual bool NrtIsCurrent(SegmentInfos infos);
    internal virtual bool IsClosed();
}
internal class Lucene.Net.Index.IntBlockPool : object {
    public Int32[][] buffers;
    internal int bufferUpto;
    public int intUpto;
    public Int32[] buffer;
    public int intOffset;
    private DocumentsWriter docWriter;
    internal bool trackAllocations;
    public IntBlockPool(DocumentsWriter docWriter, bool trackAllocations);
    private void InitBlock();
    public void Reset();
    public void NextBuffer();
}
internal abstract class Lucene.Net.Index.InvertedDocConsumer : object {
    internal FieldInfos fieldInfos;
    internal abstract virtual InvertedDocConsumerPerThread AddThread(DocInverterPerThread docInverterPerThread);
    public abstract virtual void Abort();
    internal abstract virtual void Flush(IDictionary`2<InvertedDocConsumerPerThread, ICollection`1<InvertedDocConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal abstract virtual void CloseDocStore(SegmentWriteState state);
    public abstract virtual bool FreeRAM();
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
}
internal abstract class Lucene.Net.Index.InvertedDocConsumerPerField : object {
    internal abstract virtual bool Start(IFieldable[] fields, int count);
    internal abstract virtual void Start(IFieldable field);
    internal abstract virtual void Add();
    internal abstract virtual void Finish();
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.InvertedDocConsumerPerThread : object {
    public abstract virtual void StartDocument();
    internal abstract virtual InvertedDocConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    public abstract virtual DocWriter FinishDocument();
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.InvertedDocEndConsumer : object {
    public abstract virtual InvertedDocEndConsumerPerThread AddThread(DocInverterPerThread docInverterPerThread);
    public abstract virtual void Flush(IDictionary`2<InvertedDocEndConsumerPerThread, ICollection`1<InvertedDocEndConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal abstract virtual void CloseDocStore(SegmentWriteState state);
    public abstract virtual void Abort();
    internal abstract virtual void SetFieldInfos(FieldInfos fieldInfos);
}
internal abstract class Lucene.Net.Index.InvertedDocEndConsumerPerField : object {
    internal abstract virtual void Finish();
    internal abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.InvertedDocEndConsumerPerThread : object {
    internal abstract virtual void StartDocument();
    internal abstract virtual InvertedDocEndConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    internal abstract virtual void FinishDocument();
    internal abstract virtual void Abort();
}
public interface Lucene.Net.Index.ITermFreqVector {
    public string Field { get; }
    public int Size { get; }
    public abstract virtual string get_Field();
    public abstract virtual int get_Size();
    public abstract virtual String[] GetTerms();
    public abstract virtual Int32[] GetTermFrequencies();
    public abstract virtual int IndexOf(string term);
    public abstract virtual Int32[] IndexesOf(String[] terms, int start, int len);
}
public class Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy : object {
    public sealed virtual void OnInit(IList`1<T> commits);
    public sealed virtual void OnCommit(IList`1<T> commits);
}
public class Lucene.Net.Index.LogByteSizeMergePolicy : LogMergePolicy {
    public static double DEFAULT_MIN_MERGE_MB;
    public static long DEFAULT_MAX_MERGE_MB;
    public double MaxMergeMB { get; public set; }
    public double MinMergeMB { get; public set; }
    public LogByteSizeMergePolicy(IndexWriter writer);
    private static LogByteSizeMergePolicy();
    protected internal virtual long Size(SegmentInfo info);
    protected virtual void Dispose(bool disposing);
    public virtual double get_MaxMergeMB();
    public virtual void set_MaxMergeMB(double value);
    public virtual double get_MinMergeMB();
    public virtual void set_MinMergeMB(double value);
}
public class Lucene.Net.Index.LogDocMergePolicy : LogMergePolicy {
    public static int DEFAULT_MIN_MERGE_DOCS;
    public int MinMergeDocs { get; public set; }
    public LogDocMergePolicy(IndexWriter writer);
    protected internal virtual long Size(SegmentInfo info);
    protected virtual void Dispose(bool disposing);
    public virtual int get_MinMergeDocs();
    public virtual void set_MinMergeDocs(int value);
}
public abstract class Lucene.Net.Index.LogMergePolicy : MergePolicy {
    public static double LEVEL_LOG_SPAN;
    public static int DEFAULT_MERGE_FACTOR;
    public static int DEFAULT_MAX_MERGE_DOCS;
    public static double DEFAULT_NO_CFS_RATIO;
    private int mergeFactor;
    internal long minMergeSize;
    internal long maxMergeSize;
    internal int maxMergeDocs;
    protected double internalNoCFSRatio;
    protected internal bool internalCalibrateSizeByDeletes;
    private bool useCompoundFile;
    private bool useCompoundDocStore;
    public double NoCFSRatio { get; public set; }
    public int MergeFactor { get; public set; }
    public bool CalibrateSizeByDeletes { get; public set; }
    public int MaxMergeDocs { get; public set; }
    protected LogMergePolicy(IndexWriter writer);
    private static LogMergePolicy();
    protected internal virtual bool Verbose();
    public double get_NoCFSRatio();
    public void set_NoCFSRatio(double value);
    private void Message(string message);
    public virtual int get_MergeFactor();
    public virtual void set_MergeFactor(int value);
    public virtual bool UseCompoundFile(SegmentInfos infos, SegmentInfo info);
    public virtual void SetUseCompoundFile(bool useCompoundFile);
    public virtual bool GetUseCompoundFile();
    public virtual bool UseCompoundDocStore(SegmentInfos infos);
    public virtual void SetUseCompoundDocStore(bool useCompoundDocStore);
    public virtual bool GetUseCompoundDocStore();
    public virtual void set_CalibrateSizeByDeletes(bool value);
    public virtual bool get_CalibrateSizeByDeletes();
    protected internal abstract virtual long Size(SegmentInfo info);
    protected internal virtual long SizeDocs(SegmentInfo info);
    protected internal virtual long SizeBytes(SegmentInfo info);
    private bool IsOptimized(SegmentInfos infos, int maxNumSegments, ISet`1<SegmentInfo> segmentsToOptimize);
    private bool IsOptimized(SegmentInfo info);
    public virtual MergeSpecification FindMergesForOptimize(SegmentInfos infos, int maxNumSegments, ISet`1<SegmentInfo> segmentsToOptimize);
    public virtual MergeSpecification FindMergesToExpungeDeletes(SegmentInfos segmentInfos);
    public virtual MergeSpecification FindMerges(SegmentInfos infos);
    protected OneMerge MakeOneMerge(SegmentInfos infos, SegmentInfos infosToMerge);
    public virtual void set_MaxMergeDocs(int value);
    public virtual int get_MaxMergeDocs();
}
internal class Lucene.Net.Index.MergeDocIDRemapper : object {
    internal Int32[] starts;
    internal Int32[] newStarts;
    internal Int32[][] docMaps;
    internal int minDocID;
    internal int maxDocID;
    internal int docShift;
    public MergeDocIDRemapper(SegmentInfos infos, Int32[][] docMaps, Int32[] delCounts, OneMerge merge, int mergedDocCount);
    public int Remap(int oldDocID);
}
public abstract class Lucene.Net.Index.MergePolicy : object {
    protected internal IndexWriter writer;
    protected MergePolicy(IndexWriter writer);
    public abstract virtual MergeSpecification FindMerges(SegmentInfos segmentInfos);
    public abstract virtual MergeSpecification FindMergesForOptimize(SegmentInfos segmentInfos, int maxSegmentCount, ISet`1<SegmentInfo> segmentsToOptimize);
    public abstract virtual MergeSpecification FindMergesToExpungeDeletes(SegmentInfos segmentInfos);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual bool UseCompoundFile(SegmentInfos segments, SegmentInfo newSegment);
    public abstract virtual bool UseCompoundDocStore(SegmentInfos segments);
}
public abstract class Lucene.Net.Index.MergeScheduler : object {
    public abstract virtual void Merge(IndexWriter writer);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal abstract class Lucene.Net.Index.MultiLevelSkipListReader : object {
    private int maxNumberOfSkipLevels;
    private int numberOfSkipLevels;
    private static int numberOfLevelsToBuffer;
    private int docCount;
    private bool haveSkipped;
    private bool isDisposed;
    private IndexInput[] skipStream;
    private Int64[] skipPointer;
    private Int32[] skipInterval;
    private Int32[] numSkipped;
    private Int32[] skipDoc;
    private int lastDoc;
    private Int64[] childPointer;
    private long lastChildPointer;
    private bool inputIsBuffered;
    protected MultiLevelSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval);
    internal virtual int GetDoc();
    internal virtual int SkipTo(int target);
    private bool LoadNextSkip(int level);
    protected internal virtual void SeekChild(int level);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void Init(long skipPointer, int df);
    private void LoadSkipLevels();
    protected internal abstract virtual int ReadSkipData(int level, IndexInput skipStream);
    protected internal virtual void SetLastSkipData(int level);
}
internal abstract class Lucene.Net.Index.MultiLevelSkipListWriter : object {
    private int numberOfSkipLevels;
    private int skipInterval;
    private RAMOutputStream[] skipBuffer;
    protected internal MultiLevelSkipListWriter(int skipInterval, int maxSkipLevels, int df);
    protected internal virtual void Init();
    protected internal virtual void ResetSkip();
    protected internal abstract virtual void WriteSkipData(int level, IndexOutput skipBuffer);
    internal virtual void BufferSkip(int df);
    internal virtual long WriteSkip(IndexOutput output);
}
public class Lucene.Net.Index.MultipleTermPositions : object {
    private int _doc;
    private int _freq;
    private TermPositionsQueue _termPositionsQueue;
    private IntQueue _posList;
    private bool isDisposed;
    public int Doc { get; }
    public int Freq { get; }
    public int PayloadLength { get; }
    public bool IsPayloadAvailable { get; }
    public MultipleTermPositions(IndexReader indexReader, Term[] terms);
    public sealed virtual bool Next();
    public sealed virtual int NextPosition();
    public sealed virtual bool SkipTo(int target);
    public sealed virtual int get_Doc();
    public sealed virtual int get_Freq();
    [ObsoleteAttribute("Use Dispose() instead")]
public sealed virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Seek(Term arg0);
    public virtual void Seek(TermEnum termEnum);
    public virtual int Read(Int32[] arg0, Int32[] arg1);
    public virtual int get_PayloadLength();
    public virtual Byte[] GetPayload(Byte[] data, int offset);
    public virtual bool get_IsPayloadAvailable();
}
public class Lucene.Net.Index.MultiReader : IndexReader {
    protected internal IndexReader[] subReaders;
    private Int32[] starts;
    private Boolean[] decrefOnClose;
    private IDictionary`2<string, Byte[]> normsCache;
    private int maxDoc;
    private int numDocs;
    private bool hasDeletions;
    public int MaxDoc { get; }
    public bool HasDeletions { get; }
    public long Version { get; }
    public MultiReader(IndexReader[] subReaders);
    public MultiReader(IndexReader[] subReaders, bool closeSubReaders);
    private void Initialize(IndexReader[] subReaders, bool closeSubReaders);
    public virtual IndexReader Reopen();
    public virtual object Clone();
    protected internal virtual IndexReader DoReopen(bool doClone);
    public virtual ITermFreqVector[] GetTermFreqVectors(int n);
    public virtual ITermFreqVector GetTermFreqVector(int n, string field);
    public virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public virtual bool IsOptimized();
    public virtual int NumDocs();
    public virtual int get_MaxDoc();
    public virtual Document Document(int n, FieldSelector fieldSelector);
    public virtual bool IsDeleted(int n);
    public virtual bool get_HasDeletions();
    protected internal virtual void DoDelete(int n);
    protected internal virtual void DoUndeleteAll();
    private int ReaderIndex(int n);
    public virtual bool HasNorms(string field);
    public virtual Byte[] Norms(string field);
    public virtual void Norms(string field, Byte[] result, int offset);
    protected internal virtual void DoSetNorm(int n, string field, byte value_Renamed);
    public virtual TermEnum Terms();
    public virtual TermEnum Terms(Term term);
    public virtual int DocFreq(Term t);
    public virtual TermDocs TermDocs();
    public virtual TermPositions TermPositions();
    protected internal virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    protected internal virtual void DoClose();
    public virtual ICollection`1<string> GetFieldNames(FieldOption fieldNames);
    public virtual bool IsCurrent();
    public virtual long get_Version();
    public virtual IndexReader[] GetSequentialSubReaders();
}
internal class Lucene.Net.Index.NormsWriter : InvertedDocEndConsumer {
    private static byte defaultNorm;
    private FieldInfos fieldInfos;
    private static NormsWriter();
    public virtual InvertedDocEndConsumerPerThread AddThread(DocInverterPerThread docInverterPerThread);
    public virtual void Abort();
    internal void Files(ICollection`1<string> files);
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
    public virtual void Flush(IDictionary`2<InvertedDocEndConsumerPerThread, ICollection`1<InvertedDocEndConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal virtual void CloseDocStore(SegmentWriteState state);
}
internal class Lucene.Net.Index.NormsWriterPerField : InvertedDocEndConsumerPerField {
    internal NormsWriterPerThread perThread;
    internal FieldInfo fieldInfo;
    internal DocState docState;
    internal Int32[] docIDs;
    internal Byte[] norms;
    internal int upto;
    internal FieldInvertState fieldState;
    public NormsWriterPerField(DocInverterPerField docInverterPerField, NormsWriterPerThread perThread, FieldInfo fieldInfo);
    public void Reset();
    internal virtual void Abort();
    public sealed virtual int CompareTo(NormsWriterPerField other);
    internal virtual void Finish();
}
internal class Lucene.Net.Index.NormsWriterPerThread : InvertedDocEndConsumerPerThread {
    internal NormsWriter normsWriter;
    internal DocState docState;
    public NormsWriterPerThread(DocInverterPerThread docInverterPerThread, NormsWriter normsWriter);
    internal virtual InvertedDocEndConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    internal virtual void Abort();
    internal virtual void StartDocument();
    internal virtual void FinishDocument();
    internal bool FreeRAM();
}
internal class Lucene.Net.Index.ParallelArrayTermVectorMapper : TermVectorMapper {
    private String[] terms;
    private Int32[] termFreqs;
    private Int32[][] positions;
    private TermVectorOffsetInfo[][] offsets;
    private int currentPosition;
    private bool storingOffsets;
    private bool storingPositions;
    private string field;
    public virtual void SetExpectations(string field, int numTerms, bool storeOffsets, bool storePositions);
    public virtual void Map(string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual ITermFreqVector MaterializeVector();
}
public class Lucene.Net.Index.ParallelReader : IndexReader {
    private List`1<IndexReader> readers;
    private List`1<bool> decrefOnClose;
    internal bool incRefReaders;
    private SortedDictionary`2<string, IndexReader> fieldToReader;
    private IDictionary`2<IndexReader, ICollection`1<string>> readerToFields;
    private List`1<IndexReader> storedFieldReaders;
    private int maxDoc;
    private int numDocs;
    private bool hasDeletions;
    public int MaxDoc { get; }
    public bool HasDeletions { get; }
    public long Version { get; }
    public ParallelReader(bool closeSubReaders);
    public virtual void Add(IndexReader reader);
    public virtual void Add(IndexReader reader, bool ignoreStoredFields);
    public virtual object Clone();
    public virtual IndexReader Reopen();
    protected internal virtual IndexReader DoReopen(bool doClone);
    public virtual int NumDocs();
    public virtual int get_MaxDoc();
    public virtual bool get_HasDeletions();
    public virtual bool IsDeleted(int n);
    protected internal virtual void DoDelete(int n);
    protected internal virtual void DoUndeleteAll();
    public virtual Document Document(int n, FieldSelector fieldSelector);
    public virtual ITermFreqVector[] GetTermFreqVectors(int n);
    public virtual ITermFreqVector GetTermFreqVector(int n, string field);
    public virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public virtual bool HasNorms(string field);
    public virtual Byte[] Norms(string field);
    public virtual void Norms(string field, Byte[] result, int offset);
    protected internal virtual void DoSetNorm(int n, string field, byte value_Renamed);
    public virtual TermEnum Terms();
    public virtual TermEnum Terms(Term term);
    public virtual int DocFreq(Term term);
    public virtual TermDocs TermDocs(Term term);
    public virtual TermDocs TermDocs();
    public virtual TermPositions TermPositions(Term term);
    public virtual TermPositions TermPositions();
    public virtual bool IsCurrent();
    public virtual bool IsOptimized();
    public virtual long get_Version();
    public virtual IndexReader[] GetSubReaders();
    protected internal virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    protected internal virtual void DoClose();
    public virtual ICollection`1<string> GetFieldNames(FieldOption fieldNames);
}
public class Lucene.Net.Index.Payload : object {
    protected internal Byte[] data;
    protected internal int internalOffset;
    protected internal int internalLength;
    public int Offset { get; }
    public int Length { get; }
    public Payload(Byte[] data);
    public Payload(Byte[] data, int offset, int length);
    public virtual void SetData(Byte[] value, int offset, int length);
    public virtual void SetData(Byte[] value);
    public virtual Byte[] GetData();
    public virtual int get_Offset();
    public virtual int get_Length();
    public virtual byte ByteAt(int index);
    public virtual Byte[] ToByteArray();
    public virtual void CopyTo(Byte[] target, int targetOffset);
    public virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.Index.PositionBasedTermVectorMapper : TermVectorMapper {
    private IDictionary`2<string, IDictionary`2<int, TVPositionInfo>> fieldToTerms;
    private string currentField;
    private IDictionary`2<int, TVPositionInfo> currentPositions;
    private bool storeOffsets;
    public bool IsIgnoringPositions { get; }
    public IDictionary`2<string, IDictionary`2<int, TVPositionInfo>> FieldToTerms { get; }
    public PositionBasedTermVectorMapper(bool ignoringOffsets);
    public virtual bool get_IsIgnoringPositions();
    public virtual void Map(string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual void SetExpectations(string field, int numTerms, bool storeOffsets, bool storePositions);
    public virtual IDictionary`2<string, IDictionary`2<int, TVPositionInfo>> get_FieldToTerms();
}
internal abstract class Lucene.Net.Index.RawPostingList : object {
    internal static int BYTES_SIZE;
    internal int textStart;
    internal int intStart;
    internal int byteStart;
    private static RawPostingList();
}
public class Lucene.Net.Index.ReadOnlyDirectoryReader : DirectoryReader {
    internal ReadOnlyDirectoryReader(Directory directory, SegmentInfos sis, IndexDeletionPolicy deletionPolicy, int termInfosIndexDivisor);
    internal ReadOnlyDirectoryReader(Directory directory, SegmentInfos infos, SegmentReader[] oldReaders, Int32[] oldStarts, IDictionary`2<string, Byte[]> oldNormsCache, bool doClone, int termInfosIndexDivisor);
    internal ReadOnlyDirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor);
    protected internal virtual void AcquireWriteLock();
}
public class Lucene.Net.Index.ReadOnlySegmentReader : SegmentReader {
    internal static void NoWrite();
    protected internal virtual void AcquireWriteLock();
    public virtual bool IsDeleted(int n);
}
internal class Lucene.Net.Index.ReusableStringReader : TextReader {
    internal int upto;
    internal int left;
    internal string s;
    internal void Init(string s);
    public int Read(Char[] c);
    public virtual int Read(Char[] c, int off, int len);
    public virtual void Close();
    public virtual int Read();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual int Peek();
    public virtual string ReadToEnd();
}
public class Lucene.Net.Index.SegmentInfo : object {
    internal static int NO;
    internal static int YES;
    internal static int CHECK_DIR;
    internal static int WITHOUT_GEN;
    public string name;
    public int docCount;
    public Directory dir;
    private bool preLockless;
    private long delGen;
    private Int64[] normGen;
    private sbyte isCompoundFile;
    private bool hasSingleNormFile;
    private IList`1<string> files;
    internal long sizeInBytes;
    private int docStoreOffset;
    private string docStoreSegment;
    private bool docStoreIsCompoundFile;
    private int delCount;
    private bool hasProx;
    private IDictionary`2<string, string> diagnostics;
    public IDictionary`2<string, string> Diagnostics { get; internal set; }
    public int DocStoreOffset { get; internal set; }
    public bool DocStoreIsCompoundFile { get; internal set; }
    public string DocStoreSegment { get; }
    public bool HasProx { get; internal set; }
    public SegmentInfo(string name, int docCount, Directory dir);
    public SegmentInfo(string name, int docCount, Directory dir, bool isCompoundFile, bool hasSingleNormFile);
    public SegmentInfo(string name, int docCount, Directory dir, bool isCompoundFile, bool hasSingleNormFile, int docStoreOffset, string docStoreSegment, bool docStoreIsCompoundFile, bool hasProx);
    internal SegmentInfo(Directory dir, int format, IndexInput input);
    public virtual string ToString();
    internal void Reset(SegmentInfo src);
    public IDictionary`2<string, string> get_Diagnostics();
    internal void set_Diagnostics(IDictionary`2<string, string> value);
    internal void SetNumFields(int numFields);
    public long SizeInBytes();
    public bool HasDeletions();
    internal void AdvanceDelGen();
    internal void ClearDelGen();
    public sealed virtual object Clone();
    public string GetDelFileName();
    public bool HasSeparateNorms(int fieldNumber);
    public bool HasSeparateNorms();
    internal void AdvanceNormGen(int fieldIndex);
    public string GetNormFileName(int number);
    internal void SetUseCompoundFile(bool value);
    public bool GetUseCompoundFile();
    public int GetDelCount();
    internal void SetDelCount(int delCount);
    public int get_DocStoreOffset();
    internal void set_DocStoreOffset(int value);
    public bool get_DocStoreIsCompoundFile();
    internal void set_DocStoreIsCompoundFile(bool value);
    public string get_DocStoreSegment();
    internal void SetDocStore(int offset, string segment, bool isCompoundFile);
    internal void Write(IndexOutput output);
    public bool get_HasProx();
    internal void set_HasProx(bool value);
    private void AddIfExists(IList`1<string> files, string fileName);
    public IList`1<string> Files();
    private void ClearFiles();
    public string SegString(Directory dir);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.Index.SegmentInfos : List`1<SegmentInfo> {
    public static int FORMAT;
    public static int FORMAT_LOCKLESS;
    public static int FORMAT_SINGLE_NORM_FILE;
    public static int FORMAT_SHARED_DOC_STORE;
    public static int FORMAT_CHECKSUM;
    public static int FORMAT_DEL_COUNT;
    public static int FORMAT_HAS_PROX;
    public static int FORMAT_USER_DATA;
    public static int FORMAT_DIAGNOSTICS;
    internal static int CURRENT_FORMAT;
    public int counter;
    private long version;
    private long generation;
    private long lastGeneration;
    private IDictionary`2<string, string> userData;
    private static StreamWriter infoStream;
    internal ChecksumIndexOutput pendingSegnOutput;
    private static int defaultGenFileRetryCount;
    private static int defaultGenFileRetryPauseMsec;
    private static int defaultGenLookaheadCount;
    public long Version { get; }
    public long Generation { get; }
    public long LastGeneration { get; }
    public static int DefaultGenFileRetryCount { get; public set; }
    public static int DefaultGenFileRetryPauseMsec { get; public set; }
    public static int DefaultGenLookaheadCount { get; public set; }
    public static StreamWriter InfoStream { get; }
    public IDictionary`2<string, string> UserData { get; internal set; }
    private static SegmentInfos();
    public SegmentInfo Info(int i);
    public static long GetCurrentSegmentGeneration(String[] files);
    public static long GetCurrentSegmentGeneration(Directory directory);
    public static string GetCurrentSegmentFileName(String[] files);
    public static string GetCurrentSegmentFileName(Directory directory);
    public string GetCurrentSegmentFileName();
    public static long GenerationFromSegmentsFileName(string fileName);
    public string GetNextSegmentFileName();
    public void Read(Directory directory, string segmentFileName);
    public void Read(Directory directory);
    private void Write(Directory directory);
    public sealed virtual object Clone();
    public long get_Version();
    public long get_Generation();
    public long get_LastGeneration();
    public static long ReadCurrentVersion(Directory directory);
    public static IDictionary`2<string, string> ReadCurrentUserData(Directory directory);
    public static void SetInfoStream(StreamWriter infoStream);
    public static int get_DefaultGenFileRetryCount();
    public static void set_DefaultGenFileRetryCount(int value);
    public static void set_DefaultGenFileRetryPauseMsec(int value);
    public static int get_DefaultGenFileRetryPauseMsec();
    public static void set_DefaultGenLookaheadCount(int value);
    public static int get_DefaultGenLookaheadCount();
    public static StreamWriter get_InfoStream();
    private static void Message(string message);
    public SegmentInfos Range(int first, int last);
    internal void UpdateGeneration(SegmentInfos other);
    internal void RollbackCommit(Directory dir);
    internal void PrepareCommit(Directory dir);
    public ICollection`1<string> Files(Directory dir, bool includeSegmentsFile);
    internal void FinishCommit(Directory dir);
    public void Commit(Directory dir);
    public string SegString(Directory directory);
    public IDictionary`2<string, string> get_UserData();
    internal void set_UserData(IDictionary`2<string, string> value);
    internal void Replace(SegmentInfos other);
    public bool HasExternalSegments(Directory dir);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Index.SegmentMergeInfo : object {
    internal Term term;
    internal int base_Renamed;
    internal int ord;
    internal TermEnum termEnum;
    internal IndexReader reader;
    internal int delCount;
    private TermPositions postings;
    private Int32[] docMap;
    private bool isDisposed;
    internal SegmentMergeInfo(int b, TermEnum te, IndexReader r);
    internal Int32[] GetDocMap();
    internal TermPositions GetPositions();
    internal bool Next();
    public sealed virtual void Dispose();
}
internal class Lucene.Net.Index.SegmentMergeQueue : PriorityQueue`1<SegmentMergeInfo> {
    internal SegmentMergeQueue(int size);
    public virtual bool LessThan(SegmentMergeInfo stiA, SegmentMergeInfo stiB);
    public sealed virtual void Dispose();
}
public class Lucene.Net.Index.SegmentMerger : object {
    internal static Byte[] NORMS_HEADER;
    private Directory directory;
    private string segment;
    private int termIndexInterval;
    private IList`1<IndexReader> readers;
    private FieldInfos fieldInfos;
    private int mergedDocs;
    private CheckAbort checkAbort;
    private bool mergeDocStores;
    private static int MAX_RAW_MERGE_DOCS;
    private SegmentReader[] matchingSegmentReaders;
    private Int32[] rawDocLengths;
    private Int32[] rawDocLengths2;
    private SegmentMergeQueue queue;
    internal bool omitTermFreqAndPositions;
    private Byte[] payloadBuffer;
    private Int32[][] docMaps;
    private Int32[] delCounts;
    public SegmentMerger(Directory dir, string name);
    internal SegmentMerger(IndexWriter writer, string name, OneMerge merge);
    private static SegmentMerger();
    private void InitBlock();
    internal bool HasProx();
    public void Add(IndexReader reader);
    internal IndexReader SegmentReader(int i);
    public int Merge();
    internal int Merge(bool mergeDocStores);
    internal void CloseReaders();
    internal ICollection`1<string> GetMergedFiles();
    public ICollection`1<string> CreateCompoundFile(string fileName);
    private void AddIndexed(IndexReader reader, FieldInfos fInfos, ICollection`1<string> names, bool storeTermVectors, bool storePositionWithTermVector, bool storeOffsetWithTermVector, bool storePayloads, bool omitTFAndPositions);
    private void SetMatchingSegmentReaders();
    private int MergeFields();
    private int CopyFieldsWithDeletions(FieldsWriter fieldsWriter, IndexReader reader, FieldsReader matchingFieldsReader);
    private int CopyFieldsNoDeletions(FieldsWriter fieldsWriter, IndexReader reader, FieldsReader matchingFieldsReader);
    private void MergeVectors();
    private void CopyVectorsWithDeletions(TermVectorsWriter termVectorsWriter, TermVectorsReader matchingVectorsReader, IndexReader reader);
    private void CopyVectorsNoDeletions(TermVectorsWriter termVectorsWriter, TermVectorsReader matchingVectorsReader, IndexReader reader);
    private void MergeTerms();
    private void MergeTermInfos(FormatPostingsFieldsConsumer consumer);
    internal Int32[][] GetDocMaps();
    internal Int32[] GetDelCounts();
    private int AppendPostings(FormatPostingsTermsConsumer termsConsumer, SegmentMergeInfo[] smis, int n);
    private void MergeNorms();
}
public class Lucene.Net.Index.SegmentReader : IndexReader {
    protected internal bool readOnly;
    private SegmentInfo si;
    private int readBufferSize;
    internal CloseableThreadLocal`1<FieldsReader> fieldsReaderLocal;
    internal CloseableThreadLocal`1<TermVectorsReader> termVectorsLocal;
    internal BitVector deletedDocs;
    internal Ref deletedDocsRef;
    private bool deletedDocsDirty;
    private bool normsDirty;
    private int pendingDeleteCount;
    private bool rollbackHasChanges;
    private bool rollbackDeletedDocsDirty;
    private bool rollbackNormsDirty;
    private SegmentInfo rollbackSegmentInfo;
    private int rollbackPendingDeleteCount;
    private IndexInput singleNormStream;
    private Ref singleNormRef;
    internal CoreReaders core;
    internal IDictionary`2<string, Norm> norms;
    public bool HasDeletions { get; }
    public int MaxDoc { get; }
    public string SegmentName { get; }
    internal SegmentInfo SegmentInfo { get; internal set; }
    public object FieldCacheKey { get; }
    public object DeletesCacheKey { get; }
    public long UniqueTermCount { get; }
    public int TermInfosIndexDivisor { get; }
    public IDictionary`2<string, Norm> norms_ForNUnit { get; }
    public BitVector deletedDocs_ForNUnit { get; }
    public CoreReaders core_ForNUnit { get; }
    public Ref deletedDocsRef_ForNUnit { get; }
    private void InitBlock();
    public static SegmentReader Get(bool readOnly, SegmentInfo si, int termInfosIndexDivisor);
    public static SegmentReader Get(bool readOnly, Directory dir, SegmentInfo si, int readBufferSize, bool doOpenStores, int termInfosIndexDivisor);
    internal virtual void OpenDocStores();
    private bool CheckDeletedCounts();
    private void LoadDeletedDocs();
    protected internal virtual Byte[] CloneNormBytes(Byte[] bytes);
    protected internal virtual BitVector CloneDeletedDocs(BitVector bv);
    public virtual object Clone();
    public virtual IndexReader Clone(bool openReadOnly);
    internal virtual SegmentReader ReopenSegment(SegmentInfo si, bool doClone, bool openReadOnly);
    protected internal virtual void DoCommit(IDictionary`2<string, string> commitUserData);
    private void CommitChanges(IDictionary`2<string, string> commitUserData);
    internal virtual FieldsReader GetFieldsReader();
    protected internal virtual void DoClose();
    public virtual bool get_HasDeletions();
    internal static bool UsesCompoundFile(SegmentInfo si);
    internal static bool HasSeparateNorms(SegmentInfo si);
    protected internal virtual void DoDelete(int docNum);
    protected internal virtual void DoUndeleteAll();
    internal virtual IList`1<string> Files();
    public virtual TermEnum Terms();
    public virtual TermEnum Terms(Term t);
    public virtual FieldInfos FieldInfos();
    public virtual Document Document(int n, FieldSelector fieldSelector);
    public virtual bool IsDeleted(int n);
    public virtual TermDocs TermDocs(Term term);
    public virtual TermDocs TermDocs();
    public virtual TermPositions TermPositions();
    public virtual int DocFreq(Term t);
    public virtual int NumDocs();
    public virtual int get_MaxDoc();
    public virtual ICollection`1<string> GetFieldNames(FieldOption fieldOption);
    public virtual bool HasNorms(string field);
    protected internal virtual Byte[] GetNorms(string field);
    public virtual Byte[] Norms(string field);
    protected internal virtual void DoSetNorm(int doc, string field, byte value_Renamed);
    public virtual void Norms(string field, Byte[] bytes, int offset);
    private void OpenNorms(Directory cfsDir, int readBufferSize);
    public virtual bool TermsIndexLoaded();
    internal virtual void LoadTermsIndex(int termsIndexDivisor);
    public virtual bool NormsClosed();
    public virtual bool NormsClosed(string field);
    internal virtual TermVectorsReader GetTermVectorsReader();
    internal virtual TermVectorsReader GetTermVectorsReaderOrig();
    public virtual ITermFreqVector GetTermFreqVector(int docNumber, string field);
    public virtual void GetTermFreqVector(int docNumber, string field, TermVectorMapper mapper);
    public virtual void GetTermFreqVector(int docNumber, TermVectorMapper mapper);
    public virtual ITermFreqVector[] GetTermFreqVectors(int docNumber);
    public virtual string get_SegmentName();
    internal virtual SegmentInfo get_SegmentInfo();
    internal virtual void set_SegmentInfo(SegmentInfo value);
    internal virtual void StartCommit();
    internal virtual void RollbackCommit();
    public virtual Directory Directory();
    public virtual object get_FieldCacheKey();
    public virtual object get_DeletesCacheKey();
    public virtual long get_UniqueTermCount();
    [ObsoleteAttribute("Remove this when tests are fixed!")]
public static SegmentReader GetOnlySegmentReader(Directory dir);
    public static SegmentReader GetOnlySegmentReader(IndexReader reader);
    public virtual int get_TermInfosIndexDivisor();
    public IDictionary`2<string, Norm> get_norms_ForNUnit();
    public BitVector get_deletedDocs_ForNUnit();
    public CoreReaders get_core_ForNUnit();
    public Ref get_deletedDocsRef_ForNUnit();
}
internal class Lucene.Net.Index.SegmentTermDocs : object {
    protected internal SegmentReader parent;
    protected internal IndexInput freqStream;
    protected internal int count;
    protected internal int df;
    protected internal BitVector deletedDocs;
    internal int doc;
    internal int freq;
    private int skipInterval;
    private int maxSkipLevels;
    private DefaultSkipListReader skipListReader;
    private long freqBasePointer;
    private long proxBasePointer;
    private long skipPointer;
    private bool haveSkipped;
    protected internal bool currentFieldStoresPayloads;
    protected internal bool currentFieldOmitTermFreqAndPositions;
    private bool isDisposed;
    public int Doc { get; }
    public int Freq { get; }
    public SegmentTermDocs(SegmentReader parent);
    public virtual void Seek(Term term);
    public virtual void Seek(TermEnum termEnum);
    internal virtual void Seek(TermInfo ti, Term term);
    public sealed virtual void Dispose();
    [ObsoleteAttribute("Use Dispose() instead")]
public sealed virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual int get_Doc();
    public sealed virtual int get_Freq();
    protected internal virtual void SkippingDoc();
    public virtual bool Next();
    public virtual int Read(Int32[] docs, Int32[] freqs);
    private int ReadNoTf(Int32[] docs, Int32[] freqs, int length);
    protected internal virtual void SkipProx(long proxPointer, int payloadLength);
    public virtual bool SkipTo(int target);
}
internal class Lucene.Net.Index.SegmentTermEnum : TermEnum {
    private IndexInput input;
    internal FieldInfos fieldInfos;
    internal long size;
    internal long position;
    private TermBuffer termBuffer;
    private TermBuffer prevBuffer;
    private TermBuffer scanBuffer;
    private TermInfo termInfo;
    private int format;
    private bool isIndex;
    internal long indexPointer;
    internal int indexInterval;
    internal int skipInterval;
    internal int maxSkipLevels;
    private int formatM1SkipInterval;
    public Term Term { get; }
    internal SegmentTermEnum(IndexInput i, FieldInfos fis, bool isi);
    public sealed virtual object Clone();
    internal void Seek(long pointer, long p, Term t, TermInfo ti);
    public virtual bool Next();
    internal int ScanTo(Term term);
    public virtual Term get_Term();
    public Term Prev();
    internal TermInfo TermInfo();
    internal void TermInfo(TermInfo ti);
    public virtual int DocFreq();
    internal long FreqPointer();
    internal long ProxPointer();
    protected virtual void Dispose(bool disposing);
}
internal class Lucene.Net.Index.SegmentTermPositions : SegmentTermDocs {
    private IndexInput proxStream;
    private int proxCount;
    private int position;
    private int payloadLength;
    private bool needToLoadPayload;
    private long lazySkipPointer;
    private int lazySkipProxCount;
    public int PayloadLength { get; }
    public bool IsPayloadAvailable { get; }
    internal SegmentTermPositions(SegmentReader p);
    internal virtual void Seek(TermInfo ti, Term term);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int NextPosition();
    private int ReadDeltaPosition();
    protected internal virtual void SkippingDoc();
    public virtual bool Next();
    public virtual int Read(Int32[] docs, Int32[] freqs);
    protected internal virtual void SkipProx(long proxPointer, int payloadLength);
    private void SkipPositions(int n);
    private void SkipPayload();
    private void LazySkip();
    public sealed virtual int get_PayloadLength();
    public sealed virtual Byte[] GetPayload(Byte[] data, int offset);
    public sealed virtual bool get_IsPayloadAvailable();
}
internal class Lucene.Net.Index.SegmentTermPositionVector : SegmentTermVector {
    protected internal Int32[][] positions;
    protected internal TermVectorOffsetInfo[][] offsets;
    public static Int32[] EMPTY_TERM_POS;
    public SegmentTermPositionVector(string field, String[] terms, Int32[] termFreqs, Int32[][] positions, TermVectorOffsetInfo[][] offsets);
    private static SegmentTermPositionVector();
    public virtual TermVectorOffsetInfo[] GetOffsets(int index);
    public virtual Int32[] GetTermPositions(int index);
}
internal class Lucene.Net.Index.SegmentTermVector : object {
    private string field;
    private String[] terms;
    private Int32[] termFreqs;
    public string Field { get; }
    public int Size { get; }
    internal SegmentTermVector(string field, String[] terms, Int32[] termFreqs);
    public virtual string get_Field();
    public virtual string ToString();
    public virtual int get_Size();
    public virtual String[] GetTerms();
    public virtual Int32[] GetTermFrequencies();
    public virtual int IndexOf(string termText);
    public virtual Int32[] IndexesOf(String[] termNumbers, int start, int len);
}
internal class Lucene.Net.Index.SegmentWriteState : object {
    internal DocumentsWriter docWriter;
    internal Directory directory;
    internal string segmentName;
    internal string docStoreSegmentName;
    internal int numDocs;
    internal int termIndexInterval;
    internal int numDocsInStore;
    internal ICollection`1<string> flushedFiles;
    public SegmentWriteState(DocumentsWriter docWriter, Directory directory, string segmentName, string docStoreSegmentName, int numDocs, int numDocsInStore, int termIndexInterval);
    public virtual string SegmentFileName(string ext);
}
public class Lucene.Net.Index.SerialMergeScheduler : MergeScheduler {
    public virtual void Merge(IndexWriter writer);
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Index.SnapshotDeletionPolicy : object {
    private IndexCommit lastCommit;
    private IndexDeletionPolicy primary;
    private string snapshot;
    public SnapshotDeletionPolicy(IndexDeletionPolicy primary);
    public virtual void OnInit(IList`1<T> commits);
    public virtual void OnCommit(IList`1<T> commits);
    public virtual IndexCommit Snapshot();
    public virtual void Release();
    private IList`1<IndexCommit> WrapCommits(IList`1<T> commits);
}
public class Lucene.Net.Index.SortedTermVectorMapper : TermVectorMapper {
    private SortedSet`1<TermVectorEntry> currentSet;
    private IDictionary`2<string, TermVectorEntry> termToTVE;
    private bool storeOffsets;
    private bool storePositions;
    public static string ALL;
    public SortedSet`1<TermVectorEntry> TermVectorEntrySet { get; }
    public SortedTermVectorMapper(IComparer`1<TermVectorEntry> comparator);
    public SortedTermVectorMapper(bool ignoringPositions, bool ignoringOffsets, IComparer`1<TermVectorEntry> comparator);
    public virtual void Map(string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual void SetExpectations(string field, int numTerms, bool storeOffsets, bool storePositions);
    public virtual SortedSet`1<TermVectorEntry> get_TermVectorEntrySet();
}
public class Lucene.Net.Index.StaleReaderException : IOException {
    public StaleReaderException(string message);
}
internal class Lucene.Net.Index.StoredFieldsWriter : object {
    internal FieldsWriter fieldsWriter;
    internal DocumentsWriter docWriter;
    internal FieldInfos fieldInfos;
    internal int lastDocID;
    internal PerDoc[] docFreeList;
    internal int freeCount;
    internal int allocCount;
    public StoredFieldsWriter(DocumentsWriter docWriter, FieldInfos fieldInfos);
    private void InitBlock();
    public StoredFieldsWriterPerThread AddThread(DocState docState);
    public void Flush(SegmentWriteState state);
    private void InitFieldsWriter();
    public void CloseDocStore(SegmentWriteState state);
    internal PerDoc GetPerDoc();
    internal void Abort();
    internal void Fill(int docID);
    internal void FinishDocument(PerDoc perDoc);
    public bool FreeRAM();
    internal void Free(PerDoc perDoc);
}
internal class Lucene.Net.Index.StoredFieldsWriterPerThread : object {
    internal FieldsWriter localFieldsWriter;
    internal StoredFieldsWriter storedFieldsWriter;
    internal DocState docState;
    internal PerDoc doc;
    public StoredFieldsWriterPerThread(DocState docState, StoredFieldsWriter storedFieldsWriter);
    public void StartDocument();
    public void AddField(IFieldable field, FieldInfo fieldInfo);
    public DocWriter FinishDocument();
    public void Abort();
}
public class Lucene.Net.Index.Term : object {
    internal string field;
    internal string text;
    public string Field { get; }
    public string Text { get; }
    public Term(string fld, string txt);
    public Term(string fld);
    internal Term(string fld, string txt, bool intern);
    public string get_Field();
    public string get_Text();
    public Term CreateTerm(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(Term other);
    public virtual string ToString();
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
}
internal class Lucene.Net.Index.TermBuffer : object {
    private string field;
    private Term term;
    private bool preUTF8Strings;
    private bool dirty;
    private UTF16Result text;
    private UTF8Result bytes;
    public int CompareTo(TermBuffer other);
    private static int CompareChars(Char[] chars1, int len1, Char[] chars2, int len2);
    internal void SetPreUTF8Strings();
    public void Read(IndexInput input, FieldInfos fieldInfos);
    public void Set(Term term);
    public void Set(TermBuffer other);
    public void Reset();
    public Term ToTerm();
    public sealed virtual object Clone();
}
public interface Lucene.Net.Index.TermDocs {
    public int Doc { get; }
    public int Freq { get; }
    public abstract virtual void Seek(Term term);
    public abstract virtual void Seek(TermEnum termEnum);
    public abstract virtual int get_Doc();
    public abstract virtual int get_Freq();
    public abstract virtual bool Next();
    public abstract virtual int Read(Int32[] docs, Int32[] freqs);
    public abstract virtual bool SkipTo(int target);
    [ObsoleteAttribute("Use Dispose() instead")]
public abstract virtual void Close();
}
public abstract class Lucene.Net.Index.TermEnum : object {
    public Term Term { get; }
    public abstract virtual bool Next();
    public abstract virtual Term get_Term();
    public abstract virtual int DocFreq();
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal class Lucene.Net.Index.TermInfo : object {
    internal int docFreq;
    internal long freqPointer;
    internal long proxPointer;
    internal int skipOffset;
    internal TermInfo(int df, long fp, long pp);
    internal TermInfo(TermInfo ti);
    internal void Set(int docFreq, long freqPointer, long proxPointer, int skipOffset);
    internal void Set(TermInfo ti);
}
internal class Lucene.Net.Index.TermInfosReader : object {
    private Directory directory;
    private string segment;
    private FieldInfos fieldInfos;
    private bool isDisposed;
    private CloseableThreadLocal`1<ThreadResources> threadResources;
    private SegmentTermEnum origEnum;
    private long size;
    private Term[] indexTerms;
    private TermInfo[] indexInfos;
    private Int64[] indexPointers;
    private int totalIndexInterval;
    private static int DEFAULT_CACHE_SIZE;
    public int SkipInterval { get; }
    public int MaxSkipLevels { get; }
    internal TermInfosReader(Directory dir, string seg, FieldInfos fis, int readBufferSize, int indexDivisor);
    public int get_SkipInterval();
    public int get_MaxSkipLevels();
    public sealed virtual void Dispose();
    internal long Size();
    private ThreadResources GetThreadResources();
    private int GetIndexOffset(Term term);
    private void SeekEnum(SegmentTermEnum enumerator, int indexOffset);
    internal TermInfo Get(Term term);
    private TermInfo Get(Term term, bool useCache);
    private void EnsureIndexIsRead();
    internal long GetPosition(Term term);
    public SegmentTermEnum Terms();
    public SegmentTermEnum Terms(Term term);
}
internal class Lucene.Net.Index.TermInfosWriter : object {
    public static int FORMAT;
    public static int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES;
    public static int FORMAT_CURRENT;
    private bool isDisposed;
    private FieldInfos fieldInfos;
    private IndexOutput output;
    private TermInfo lastTi;
    private long size;
    internal int indexInterval;
    internal int skipInterval;
    internal int maxSkipLevels;
    private long lastIndexPointer;
    private bool isIndex;
    private Byte[] lastTermBytes;
    private int lastTermBytesLength;
    private int lastFieldNumber;
    private TermInfosWriter other;
    private UTF8Result utf8Result;
    internal UTF16Result utf16Result1;
    internal UTF16Result utf16Result2;
    internal TermInfosWriter(Directory directory, string segment, FieldInfos fis, int interval);
    private TermInfosWriter(Directory directory, string segment, FieldInfos fis, int interval, bool isIndex);
    private static TermInfosWriter();
    private void Initialize(Directory directory, string segment, FieldInfos fis, int interval, bool isi);
    internal void Add(Term term, TermInfo ti);
    private bool InitUTF16Results();
    private int CompareToLastTerm(int fieldNumber, Byte[] termBytes, int termBytesLength);
    internal void Add(int fieldNumber, Byte[] termBytes, int termBytesLength, TermInfo ti);
    private void WriteTerm(int fieldNumber, Byte[] termBytes, int termBytesLength);
    public sealed virtual void Dispose();
}
public interface Lucene.Net.Index.TermPositions {
    public int PayloadLength { get; }
    public bool IsPayloadAvailable { get; }
    public abstract virtual int NextPosition();
    public abstract virtual int get_PayloadLength();
    public abstract virtual Byte[] GetPayload(Byte[] data, int offset);
    public abstract virtual bool get_IsPayloadAvailable();
}
public interface Lucene.Net.Index.TermPositionVector {
    public abstract virtual Int32[] GetTermPositions(int index);
    public abstract virtual TermVectorOffsetInfo[] GetOffsets(int index);
}
internal class Lucene.Net.Index.TermsHash : InvertedDocConsumer {
    internal TermsHashConsumer consumer;
    internal TermsHash nextTermsHash;
    internal int bytesPerPosting;
    internal int postingsFreeChunk;
    internal DocumentsWriter docWriter;
    private RawPostingList[] postingsFreeList;
    private int postingsFreeCount;
    private int postingsAllocCount;
    internal bool trackAllocations;
    public TermsHash(DocumentsWriter docWriter, bool trackAllocations, TermsHashConsumer consumer, TermsHash nextTermsHash);
    internal virtual InvertedDocConsumerPerThread AddThread(DocInverterPerThread docInverterPerThread);
    internal TermsHashPerThread AddThread(DocInverterPerThread docInverterPerThread, TermsHashPerThread primaryPerThread);
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
    public virtual void Abort();
    internal void ShrinkFreePostings(IDictionary`2<InvertedDocConsumerPerThread, ICollection`1<InvertedDocConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal virtual void CloseDocStore(SegmentWriteState state);
    internal virtual void Flush(IDictionary`2<InvertedDocConsumerPerThread, ICollection`1<InvertedDocConsumerPerField>> threadsAndFields, SegmentWriteState state);
    public virtual bool FreeRAM();
    public void RecyclePostings(RawPostingList[] postings, int numPostings);
    public void GetPostings(RawPostingList[] postings);
}
internal abstract class Lucene.Net.Index.TermsHashConsumer : object {
    internal FieldInfos fieldInfos;
    internal abstract virtual int BytesPerPosting();
    internal abstract virtual void CreatePostings(RawPostingList[] postings, int start, int count);
    public abstract virtual TermsHashConsumerPerThread AddThread(TermsHashPerThread perThread);
    public abstract virtual void Flush(IDictionary`2<TermsHashConsumerPerThread, ICollection`1<TermsHashConsumerPerField>> threadsAndFields, SegmentWriteState state);
    public abstract virtual void Abort();
    internal abstract virtual void CloseDocStore(SegmentWriteState state);
    internal virtual void SetFieldInfos(FieldInfos fieldInfos);
}
internal abstract class Lucene.Net.Index.TermsHashConsumerPerField : object {
    internal abstract virtual bool Start(IFieldable[] fields, int count);
    internal abstract virtual void Finish();
    internal abstract virtual void SkippingLongTerm();
    internal abstract virtual void Start(IFieldable field);
    internal abstract virtual void NewTerm(RawPostingList p);
    internal abstract virtual void AddTerm(RawPostingList p);
    internal abstract virtual int GetStreamCount();
}
internal abstract class Lucene.Net.Index.TermsHashConsumerPerThread : object {
    public abstract virtual void StartDocument();
    public abstract virtual DocWriter FinishDocument();
    public abstract virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
    public abstract virtual void Abort();
}
internal class Lucene.Net.Index.TermsHashPerField : InvertedDocConsumerPerField {
    internal TermsHashConsumerPerField consumer;
    internal TermsHashPerField nextPerField;
    internal TermsHashPerThread perThread;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal ITermAttribute termAtt;
    internal CharBlockPool charPool;
    internal IntBlockPool intPool;
    internal ByteBlockPool bytePool;
    internal int streamCount;
    internal int numPostingInt;
    internal FieldInfo fieldInfo;
    internal bool postingsCompacted;
    internal int numPostings;
    private int postingsHashSize;
    private int postingsHashHalfSize;
    private int postingsHashMask;
    private RawPostingList[] postingsHash;
    private RawPostingList p;
    private bool doCall;
    private bool doNextCall;
    internal Int32[] intUptos;
    internal int intUptoStart;
    public TermsHashPerField(DocInverterPerField docInverterPerField, TermsHashPerThread perThread, TermsHashPerThread nextPerThread, FieldInfo fieldInfo);
    private void InitBlock();
    internal void ShrinkHash(int targetSize);
    public void Reset();
    public virtual void Abort();
    public void InitReader(ByteSliceReader reader, RawPostingList p, int stream);
    private void CompactPostings();
    public RawPostingList[] SortPostings();
    internal void QuickSort(RawPostingList[] postings, int lo, int hi);
    internal int ComparePostings(RawPostingList p1, RawPostingList p2);
    private bool PostingEquals(Char[] tokenText, int tokenTextLen);
    internal virtual void Start(IFieldable f);
    internal virtual bool Start(IFieldable[] fields, int count);
    public void Add(int textStart);
    internal virtual void Add();
    internal void WriteByte(int stream, byte b);
    public void WriteBytes(int stream, Byte[] b, int offset, int len);
    internal void WriteVInt(int stream, int i);
    internal virtual void Finish();
    internal void RehashPostings(int newSize);
}
internal class Lucene.Net.Index.TermsHashPerThread : InvertedDocConsumerPerThread {
    internal TermsHash termsHash;
    internal TermsHashConsumerPerThread consumer;
    internal TermsHashPerThread nextPerThread;
    internal CharBlockPool charPool;
    internal IntBlockPool intPool;
    internal ByteBlockPool bytePool;
    internal bool primary;
    internal DocState docState;
    internal RawPostingList[] freePostings;
    internal int freePostingsCount;
    public TermsHashPerThread(DocInverterPerThread docInverterPerThread, TermsHash termsHash, TermsHash nextTermsHash, TermsHashPerThread primaryPerThread);
    internal virtual InvertedDocConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    public virtual void Abort();
    internal void MorePostings();
    private static bool noNullPostings(RawPostingList[] postings, int count, string details);
    public virtual void StartDocument();
    public virtual DocWriter FinishDocument();
    internal void Reset(bool recyclePostings);
}
public class Lucene.Net.Index.TermVectorEntry : object {
    private string field;
    private string term;
    private int frequency;
    private TermVectorOffsetInfo[] offsets;
    private Int32[] positions;
    public string Field { get; }
    public int Frequency { get; internal set; }
    public string Term { get; }
    public TermVectorEntry(string field, string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual string get_Field();
    public virtual int get_Frequency();
    internal virtual void set_Frequency(int value);
    internal virtual void SetOffsets(TermVectorOffsetInfo[] value);
    public virtual TermVectorOffsetInfo[] GetOffsets();
    internal virtual void SetPositions(Int32[] value);
    public virtual Int32[] GetPositions();
    public virtual string get_Term();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Lucene.Net.Index.TermVectorEntryFreqSortedComparator : object {
    public virtual int Compare(TermVectorEntry entry, TermVectorEntry entry1);
}
public abstract class Lucene.Net.Index.TermVectorMapper : object {
    private bool ignoringPositions;
    private bool ignoringOffsets;
    public bool IsIgnoringPositions { get; }
    public bool IsIgnoringOffsets { get; }
    protected internal TermVectorMapper(bool ignoringPositions, bool ignoringOffsets);
    public abstract virtual void SetExpectations(string field, int numTerms, bool storeOffsets, bool storePositions);
    public abstract virtual void Map(string term, int frequency, TermVectorOffsetInfo[] offsets, Int32[] positions);
    public virtual bool get_IsIgnoringPositions();
    public virtual bool get_IsIgnoringOffsets();
    public virtual void SetDocumentNumber(int documentNumber);
}
public class Lucene.Net.Index.TermVectorOffsetInfo : ValueType {
    public static TermVectorOffsetInfo[] EMPTY_OFFSET_INFO;
    public static TermVectorOffsetInfo Null;
    private int startOffset;
    private int endOffset;
    public int EndOffset { get; public set; }
    public int StartOffset { get; public set; }
    public TermVectorOffsetInfo(int startOffset, int endOffset);
    private static TermVectorOffsetInfo();
    public int get_EndOffset();
    public void set_EndOffset(int value);
    public int get_StartOffset();
    public void set_StartOffset(int value);
    public sealed virtual bool Equals(TermVectorOffsetInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TermVectorOffsetInfo left, object right);
    public static bool op_Inequality(TermVectorOffsetInfo left, object right);
}
internal class Lucene.Net.Index.TermVectorsReader : object {
    internal static int FORMAT_VERSION;
    internal static int FORMAT_VERSION2;
    internal static int FORMAT_UTF8_LENGTH_IN_BYTES;
    internal static int FORMAT_CURRENT;
    internal static int FORMAT_SIZE;
    internal static byte STORE_POSITIONS_WITH_TERMVECTOR;
    internal static byte STORE_OFFSET_WITH_TERMVECTOR;
    private FieldInfos fieldInfos;
    private IndexInput tvx;
    private IndexInput tvd;
    private IndexInput tvf;
    private int size;
    private int numTotalDocs;
    private int docStoreOffset;
    private int format;
    private bool isDisposed;
    internal TermVectorsReader(Directory d, string segment, FieldInfos fieldInfos);
    internal TermVectorsReader(Directory d, string segment, FieldInfos fieldInfos, int readBufferSize);
    internal TermVectorsReader(Directory d, string segment, FieldInfos fieldInfos, int readBufferSize, int docStoreOffset, int size);
    private static TermVectorsReader();
    internal virtual IndexInput GetTvdStream();
    internal virtual IndexInput GetTvfStream();
    private void SeekTvx(int docNum);
    internal virtual bool CanReadRawDocs();
    internal void RawDocs(Int32[] tvdLengths, Int32[] tvfLengths, int startDocID, int numDocs);
    private int CheckValidFormat(IndexInput in_Renamed);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual int Size();
    public virtual void Get(int docNum, string field, TermVectorMapper mapper);
    public virtual ITermFreqVector Get(int docNum, string field);
    private String[] ReadFields(int fieldCount);
    private Int64[] ReadTvfPointers(int fieldCount);
    public virtual ITermFreqVector[] Get(int docNum);
    public virtual void Get(int docNumber, TermVectorMapper mapper);
    private SegmentTermVector[] ReadTermVectors(int docNum, String[] fields, Int64[] tvfPointers);
    private void ReadTermVectors(String[] fields, Int64[] tvfPointers, TermVectorMapper mapper);
    private void ReadTermVector(string field, long tvfPointer, TermVectorMapper mapper);
    public virtual object Clone();
}
internal class Lucene.Net.Index.TermVectorsTermsWriter : TermsHashConsumer {
    internal DocumentsWriter docWriter;
    internal TermVectorsWriter termVectorsWriter;
    internal PerDoc[] docFreeList;
    internal int freeCount;
    internal IndexOutput tvx;
    internal IndexOutput tvd;
    internal IndexOutput tvf;
    internal int lastDocID;
    internal int allocCount;
    public TermVectorsTermsWriter(DocumentsWriter docWriter);
    private void InitBlock();
    public virtual TermsHashConsumerPerThread AddThread(TermsHashPerThread termsHashPerThread);
    internal virtual void CreatePostings(RawPostingList[] postings, int start, int count);
    public virtual void Flush(IDictionary`2<TermsHashConsumerPerThread, ICollection`1<TermsHashConsumerPerField>> threadsAndFields, SegmentWriteState state);
    internal virtual void CloseDocStore(SegmentWriteState state);
    internal PerDoc GetPerDoc();
    internal void Fill(int docID);
    internal void InitTermVectorsWriter();
    internal void FinishDocument(PerDoc perDoc);
    public bool FreeRAM();
    public virtual void Abort();
    internal void Free(PerDoc doc);
    internal virtual int BytesPerPosting();
}
internal class Lucene.Net.Index.TermVectorsTermsWriterPerField : TermsHashConsumerPerField {
    internal TermVectorsTermsWriterPerThread perThread;
    internal TermsHashPerField termsHashPerField;
    internal TermVectorsTermsWriter termsWriter;
    internal FieldInfo fieldInfo;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal bool doVectors;
    internal bool doVectorPositions;
    internal bool doVectorOffsets;
    internal int maxNumPostings;
    internal IOffsetAttribute offsetAttribute;
    public TermVectorsTermsWriterPerField(TermsHashPerField termsHashPerField, TermVectorsTermsWriterPerThread perThread, FieldInfo fieldInfo);
    internal virtual int GetStreamCount();
    internal virtual bool Start(IFieldable[] fields, int count);
    public void Abort();
    internal virtual void Finish();
    internal void ShrinkHash();
    internal virtual void Start(IFieldable f);
    internal virtual void NewTerm(RawPostingList p0);
    internal virtual void AddTerm(RawPostingList p0);
    internal virtual void SkippingLongTerm();
}
internal class Lucene.Net.Index.TermVectorsTermsWriterPerThread : TermsHashConsumerPerThread {
    internal TermVectorsTermsWriter termsWriter;
    internal TermsHashPerThread termsHashPerThread;
    internal DocState docState;
    internal PerDoc doc;
    internal ByteSliceReader vectorSliceReader;
    internal UTF8Result[] utf8Results;
    internal string lastVectorFieldName;
    public TermVectorsTermsWriterPerThread(TermsHashPerThread termsHashPerThread, TermVectorsTermsWriter termsWriter);
    public virtual void StartDocument();
    public virtual DocWriter FinishDocument();
    public virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
    public virtual void Abort();
    internal bool ClearLastVectorFieldName();
    internal bool VectorFieldsInOrder(FieldInfo fi);
}
internal class Lucene.Net.Index.TermVectorsWriter : object {
    private IndexOutput tvx;
    private IndexOutput tvd;
    private IndexOutput tvf;
    private FieldInfos fieldInfos;
    internal UTF8Result[] utf8Results;
    public TermVectorsWriter(Directory directory, string segment, FieldInfos fieldInfos);
    public void AddAllDocVectors(ITermFreqVector[] vectors);
    internal void AddRawDocuments(TermVectorsReader reader, Int32[] tvdLengths, Int32[] tvfLengths, int numDocs);
    public sealed virtual void Dispose();
}
public class Lucene.Net.LucenePackage : object {
}
public interface Lucene.Net.Messages.INLSException {
    public Message MessageObject { get; }
    public abstract virtual Message get_MessageObject();
}
public interface Lucene.Net.Messages.Message {
    public string Key { get; }
    public abstract virtual string get_Key();
    public abstract virtual Object[] GetArguments();
    public abstract virtual string GetLocalizedMessage();
    public abstract virtual string GetLocalizedMessage(CultureInfo locale);
}
public class Lucene.Net.Messages.MessageImpl : object {
    private static long serialVersionUID;
    private string key;
    private Object[] arguments;
    public string Key { get; }
    public MessageImpl(string key);
    public MessageImpl(string key, Object[] args);
    public virtual Object[] GetArguments();
    public virtual string get_Key();
    public virtual string GetLocalizedMessage();
    public virtual string GetLocalizedMessage(CultureInfo locale);
    public virtual string ToString();
}
public class Lucene.Net.Messages.NLS : object {
    private static IDictionary`2<string, Type> bundles;
    private static NLS();
    public static string GetLocalizedMessage(string key);
    public static string GetLocalizedMessage(string key, CultureInfo locale);
    public static string GetLocalizedMessage(string key, CultureInfo locale, Object[] args);
    public static string GetLocalizedMessage(string key, Object[] args);
    protected internal static void InitializeMessages(string bundleName);
    private static object GetResourceBundleObject(string messageKey, CultureInfo locale);
    private static void Load();
    private static void LoadfieldValue(FieldInfo field, bool isFieldAccessible);
    private static void ValidateMessage(string key);
    private static void MakeAccessible(FieldInfo field);
}
public class Lucene.Net.QueryParsers.FastCharStream : object {
    internal Char[] buffer;
    internal int bufferLength;
    internal int bufferPosition;
    internal int tokenStart;
    internal int bufferStart;
    internal TextReader input;
    public string Image { get; }
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public FastCharStream(TextReader r);
    public sealed virtual char ReadChar();
    private void Refill();
    public sealed virtual char BeginToken();
    public sealed virtual void Backup(int amount);
    public sealed virtual string get_Image();
    public sealed virtual Char[] GetSuffix(int len);
    public sealed virtual void Done();
    public sealed virtual int get_Column();
    public sealed virtual int get_Line();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual int get_BeginColumn();
    public sealed virtual int get_BeginLine();
}
public interface Lucene.Net.QueryParsers.ICharStream {
    [ObsoleteAttribute]
public int Column { get; }
    [ObsoleteAttribute]
public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public string Image { get; }
    public abstract virtual char ReadChar();
    public abstract virtual int get_Column();
    public abstract virtual int get_Line();
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_BeginColumn();
    public abstract virtual int get_BeginLine();
    public abstract virtual void Backup(int amount);
    public abstract virtual char BeginToken();
    public abstract virtual string get_Image();
    public abstract virtual Char[] GetSuffix(int len);
    public abstract virtual void Done();
}
public class Lucene.Net.QueryParsers.MultiFieldQueryParser : QueryParser {
    protected internal String[] fields;
    protected internal IDictionary`2<string, float> boosts;
    public MultiFieldQueryParser(Version matchVersion, String[] fields, Analyzer analyzer, IDictionary`2<string, float> boosts);
    public MultiFieldQueryParser(Version matchVersion, String[] fields, Analyzer analyzer);
    protected internal virtual Query GetFieldQuery(string field, string queryText, int slop);
    private void ApplySlop(Query q, int slop);
    protected internal virtual Query GetFieldQuery(string field, string queryText);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    protected internal virtual Query GetPrefixQuery(string field, string termStr);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetRangeQuery(string field, string part1, string part2, bool inclusive);
    public static Query Parse(Version matchVersion, String[] queries, String[] fields, Analyzer analyzer);
    public static Query Parse(Version matchVersion, string query, String[] fields, Occur[] flags, Analyzer analyzer);
    public static Query Parse(Version matchVersion, String[] queries, String[] fields, Occur[] flags, Analyzer analyzer);
}
public class Lucene.Net.QueryParsers.ParseException : Exception {
    protected internal bool specialConstructor;
    public Token currentToken;
    public Int32[][] expectedTokenSequences;
    public String[] tokenImage;
    protected internal string eol;
    public string Message { get; }
    public ParseException(Token currentTokenVal, Int32[][] expectedTokenSequencesVal, String[] tokenImageVal);
    public ParseException(string message);
    public ParseException(string message, Exception ex);
    public virtual string get_Message();
    protected internal virtual string Add_escapes(string str);
}
public class Lucene.Net.QueryParsers.QueryParser : QueryParserConstants {
    private static int CONJ_NONE;
    private static int CONJ_AND;
    private static int CONJ_OR;
    private static int MOD_NONE;
    private static int MOD_NOT;
    private static int MOD_REQ;
    public static Operator AND_OPERATOR;
    public static Operator OR_OPERATOR;
    private Operator operator_Renamed;
    private bool lowercaseExpandedTerms;
    private RewriteMethod multiTermRewriteMethod;
    private bool allowLeadingWildcard;
    private bool enablePositionIncrements;
    private bool _useJavaStyleDateRangeParsing;
    private Analyzer analyzer;
    private string field;
    private int phraseSlop;
    private float fuzzyMinSim;
    private int fuzzyPrefixLength;
    private CultureInfo locale;
    private Resolution dateResolution;
    private IDictionary`2<string, Resolution> fieldToDateResolution;
    private CompareInfo rangeCollator;
    public QueryParserTokenManager token_source;
    public Token token;
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private Int32[] jj_la1;
    private static Int32[] jj_la1_0;
    private static Int32[] jj_la1_1;
    private JJCalls[] jj_2_rtns;
    private bool jj_rescan;
    private int jj_gc;
    private LookaheadSuccess jj_ls;
    private List`1<Int32[]> jj_expentries;
    private Int32[] jj_expentry;
    private int jj_kind;
    private Int32[] jj_lasttokens;
    private int jj_endpos;
    public Analyzer Analyzer { get; }
    public string Field { get; }
    public float FuzzyMinSim { get; public set; }
    public int FuzzyPrefixLength { get; public set; }
    public int PhraseSlop { get; public set; }
    public bool AllowLeadingWildcard { get; public set; }
    public bool EnablePositionIncrements { get; public set; }
    public Operator DefaultOperator { get; public set; }
    public bool LowercaseExpandedTerms { get; public set; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    public CultureInfo Locale { get; public set; }
    public CompareInfo RangeCollator { get; public set; }
    public QueryParser(Version matchVersion, string f, Analyzer a);
    protected internal QueryParser(ICharStream stream);
    protected QueryParser(QueryParserTokenManager tm);
    private static QueryParser();
    public virtual Query Parse(string query);
    public virtual Analyzer get_Analyzer();
    public virtual string get_Field();
    public virtual float get_FuzzyMinSim();
    public virtual void set_FuzzyMinSim(float value);
    public virtual int get_FuzzyPrefixLength();
    public virtual void set_FuzzyPrefixLength(int value);
    public virtual void set_PhraseSlop(int value);
    public virtual int get_PhraseSlop();
    public virtual void set_AllowLeadingWildcard(bool value);
    public virtual bool get_AllowLeadingWildcard();
    public virtual void set_EnablePositionIncrements(bool value);
    public virtual bool get_EnablePositionIncrements();
    public virtual void set_DefaultOperator(Operator value);
    public virtual Operator get_DefaultOperator();
    public virtual void set_LowercaseExpandedTerms(bool value);
    public virtual bool get_LowercaseExpandedTerms();
    public virtual void set_MultiTermRewriteMethod(RewriteMethod value);
    public virtual RewriteMethod get_MultiTermRewriteMethod();
    public virtual void set_Locale(CultureInfo value);
    public virtual CultureInfo get_Locale();
    public virtual void SetDateResolution(Resolution dateResolution);
    public virtual void SetDateResolution(string fieldName, Resolution dateResolution);
    public virtual Resolution getDateResolution(string fieldName);
    public virtual void set_RangeCollator(CompareInfo value);
    public virtual CompareInfo get_RangeCollator();
    protected internal virtual void AddClause(List`1<BooleanClause> clauses, int conj, int mods, Query q);
    protected internal virtual Query GetFieldQuery(string field, string queryText);
    protected internal virtual Query GetFieldQuery(string field, string queryText, int slop);
    protected internal virtual Query GetRangeQuery(string field, string part1, string part2, bool inclusive);
    protected internal virtual BooleanQuery NewBooleanQuery(bool disableCoord);
    protected internal virtual BooleanClause NewBooleanClause(Query q, Occur occur);
    protected internal virtual Query NewTermQuery(Term term);
    protected internal virtual PhraseQuery NewPhraseQuery();
    protected internal virtual MultiPhraseQuery NewMultiPhraseQuery();
    protected internal virtual Query NewPrefixQuery(Term prefix);
    protected internal virtual Query NewFuzzyQuery(Term term, float minimumSimilarity, int prefixLength);
    protected internal virtual Query NewRangeQuery(string field, string part1, string part2, bool inclusive);
    protected internal virtual Query NewMatchAllDocsQuery();
    protected internal virtual Query NewWildcardQuery(Term t);
    protected internal virtual Query GetBooleanQuery(IList`1<BooleanClause> clauses);
    protected internal virtual Query GetBooleanQuery(IList`1<BooleanClause> clauses, bool disableCoord);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetPrefixQuery(string field, string termStr);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    private string DiscardEscapeChar(string input);
    private static int HexToInt(char c);
    public static string Escape(string s);
    [STAThreadAttribute]
public static void Main(String[] args);
    public int Conjunction();
    public int Modifiers();
    public Query TopLevelQuery(string field);
    public Query Query(string field);
    public Query Clause(string field);
    public Query Term(string field);
    private bool Jj_2_1(int xla);
    private bool Jj_3R_2();
    private bool Jj_3_1();
    private bool Jj_3R_3();
    private static void Jj_la1_init_0();
    private static void Jj_la1_init_1();
    public void ReInit(ICharStream stream);
    public void ReInit(QueryParserTokenManager tm);
    private Token Jj_consume_token(int kind);
    private bool jj_scan_token(int kind);
    public Token GetNextToken();
    public Token getToken(int index);
    private int Jj_ntk();
    private void Jj_add_error_token(int kind, int pos);
    public virtual ParseException GenerateParseException();
    public void Enable_tracing();
    public void Disable_tracing();
    private void Jj_rescan_token();
    private void Jj_save(int index, int xla);
}
public class Lucene.Net.QueryParsers.QueryParserConstants : object {
    protected internal static int EndOfFileToken;
    protected internal static int NumCharToken;
    protected internal static int EscapedCharToken;
    protected internal static int TermStartCharToken;
    protected internal static int TermCharToken;
    protected internal static int WhitespaceToken;
    protected internal static int QuotedCharToken;
    protected internal static int AndToken;
    protected internal static int OrToken;
    protected internal static int NotToken;
    protected internal static int PlusToken;
    protected internal static int MinusToken;
    protected internal static int LParanToken;
    protected internal static int RParenToken;
    protected internal static int ColonToken;
    protected internal static int StarToken;
    protected internal static int CaratToken;
    protected internal static int QuotedToken;
    protected internal static int TermToken;
    protected internal static int FuzzySlopToken;
    protected internal static int PrefixTermToken;
    protected internal static int WildTermToken;
    protected internal static int RangeInStartToken;
    protected internal static int RangeExStartToken;
    protected internal static int NumberToken;
    protected internal static int RangeInToToken;
    protected internal static int RangeInEndToken;
    protected internal static int RangeInQuotedToken;
    protected internal static int RangeInGoopToken;
    protected internal static int RangeExToToken;
    protected internal static int RangeExEndToken;
    protected internal static int RangeExQuotedToken;
    protected internal static int RangeExGoopToken;
    protected internal static int BoostToken;
    protected static int RangeExToken;
    protected internal static int RangeInToken;
    protected internal static int DefaultToken;
    protected internal static String[] tokenImage;
    private static QueryParserConstants();
}
public class Lucene.Net.QueryParsers.QueryParserTokenManager : QueryParserConstants {
    public StreamWriter debugStream;
    internal static UInt64[] jjbitVec0;
    internal static UInt64[] jjbitVec1;
    internal static UInt64[] jjbitVec3;
    internal static UInt64[] jjbitVec4;
    internal static Int32[] jjnextStates;
    public static String[] jjstrLiteralImages;
    public static String[] lexStateNames;
    public static Int32[] jjnewLexState;
    internal static UInt64[] jjtoToken;
    internal static Int64[] jjtoSkip;
    protected internal ICharStream input_stream;
    private UInt32[] jjrounds;
    private Int32[] jjstateSet;
    protected internal char curChar;
    internal int curLexState;
    internal int defaultLexState;
    internal int jjnewStateCnt;
    internal UInt32 jjround;
    internal int jjmatchedPos;
    internal int jjmatchedKind;
    public QueryParserTokenManager(ICharStream stream);
    public QueryParserTokenManager(ICharStream stream, int lexState);
    private static QueryParserTokenManager();
    private void InitBlock();
    public virtual void SetDebugStream(StreamWriter ds);
    private int JjStopStringLiteralDfa_3(int pos, long active0);
    private int JjStartNfa_3(int pos, long active0);
    private int JjStopAtPos(int pos, int kind);
    private int JjMoveStringLiteralDfa0_3();
    private int JjStartNfaWithStates_3(int pos, int kind, int state);
    private int JjMoveNfa_3(int startState, int curPos);
    private int JjStopStringLiteralDfa_1(int pos, long active0);
    private int JjStartNfa_1(int pos, long active0);
    private int JjMoveStringLiteralDfa0_1();
    private int JjMoveStringLiteralDfa1_1(long active0);
    private int JjStartNfaWithStates_1(int pos, int kind, int state);
    private int JjMoveNfa_1(int startState, int curPos);
    private int JjMoveStringLiteralDfa0_0();
    private int JjMoveNfa_0(int startState, int curPos);
    private int JjStopStringLiteralDfa_2(int pos, long active0);
    private int JjStartNfa_2(int pos, long active0);
    private int JjMoveStringLiteralDfa0_2();
    private int JjMoveStringLiteralDfa1_2(long active0);
    private int JjStartNfaWithStates_2(int pos, int kind, int state);
    private int JjMoveNfa_2(int startState, int curPos);
    private static bool JjCanMove_0(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_1(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_2(int hiByte, int i1, int i2, ulong l1, ulong l2);
    public virtual void ReInit(ICharStream stream);
    private void ReInitRounds();
    public virtual void ReInit(ICharStream stream, int lexState);
    public virtual void SwitchTo(int lexState);
    protected internal virtual Token JjFillToken();
    public virtual Token GetNextToken();
    private void JjCheckNAdd(int state);
    private void JjAddStates(int start, int end);
    private void JjCheckNAddTwoStates(int state1, int state2);
    private void JjCheckNAddStates(int start, int end);
}
public class Lucene.Net.QueryParsers.Token : object {
    public int kind;
    public int beginLine;
    public int beginColumn;
    public int endLine;
    public int endColumn;
    public string image;
    public Token next;
    public Token specialToken;
    public object Value { get; }
    public Token(int kind);
    public Token(int kind, string image);
    public virtual object get_Value();
    public virtual string ToString();
    public static Token NewToken(int ofKind, string image);
    public static Token NewToken(int ofKind);
}
public class Lucene.Net.QueryParsers.TokenMgrError : ApplicationException {
    internal static int LEXICAL_ERROR;
    internal static int STATIC_LEXER_ERROR;
    internal static int INVALID_LEXICAL_STATE;
    internal static int LOOP_DETECTED;
    internal int errorCode;
    public string Message { get; }
    public TokenMgrError(string message, int reason);
    public TokenMgrError(bool EOFSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar, int reason);
    public virtual string get_Message();
    protected internal static string addEscapes(string str);
    protected internal static string LexicalError(bool EOFSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar);
}
internal class Lucene.Net.Search.AnonymousClassByteParser : object {
    public virtual sbyte ParseByte(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassDoubleParser : object {
    public virtual double ParseDouble(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassDoubleParser1 : object {
    public virtual double ParseDouble(string val);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassFloatParser : object {
    public virtual float ParseFloat(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassFloatParser1 : object {
    public virtual float ParseFloat(string val);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassIntParser : object {
    public virtual int ParseInt(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassIntParser1 : object {
    public virtual int ParseInt(string val);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassLongParser : object {
    public virtual long ParseLong(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassLongParser1 : object {
    public virtual long ParseLong(string val);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
internal class Lucene.Net.Search.AnonymousClassShortParser : object {
    public virtual short ParseShort(string value_Renamed);
    protected internal virtual object ReadResolve();
    public virtual string ToString();
}
public class Lucene.Net.Search.BooleanClause : object {
    private Occur occur;
    private Query _query;
    public Occur Occur { get; public set; }
    public Query Query { get; public set; }
    public bool IsProhibited { get; }
    public bool IsRequired { get; }
    public BooleanClause(Query query, Occur occur);
    public virtual Occur get_Occur();
    public virtual void set_Occur(Occur value);
    public virtual Query get_Query();
    public virtual void set_Query(Query value);
    public virtual bool get_IsProhibited();
    public virtual bool get_IsRequired();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Lucene.Net.Search.BooleanQuery : Query {
    private static int _maxClauses;
    private EquatableList`1<BooleanClause> clauses;
    private bool disableCoord;
    protected internal int minNrShouldMatch;
    public static int MaxClauseCount { get; public set; }
    public int MinimumNumberShouldMatch { get; public set; }
    public List`1<BooleanClause> Clauses { get; }
    public BooleanQuery(bool disableCoord);
    private static BooleanQuery();
    public static int get_MaxClauseCount();
    public static void set_MaxClauseCount(int value);
    public virtual bool IsCoordDisabled();
    public virtual Similarity GetSimilarity(Searcher searcher);
    public virtual void set_MinimumNumberShouldMatch(int value);
    public virtual int get_MinimumNumberShouldMatch();
    public virtual void Add(Query query, Occur occur);
    public virtual void Add(BooleanClause clause);
    public virtual BooleanClause[] GetClauses();
    public virtual List`1<BooleanClause> get_Clauses();
    public sealed virtual IEnumerator`1<BooleanClause> GetEnumerator();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Lucene.Net.Search.BooleanScorer : Scorer {
    private SubScorer scorers;
    private BucketTable bucketTable;
    private int maxCoord;
    private Single[] coordFactors;
    private int requiredMask;
    private int prohibitedMask;
    private int nextMask;
    private int minNrShouldMatch;
    private int end;
    private Bucket current;
    private int doc;
    public BooleanScorer(Similarity similarity, int minNrShouldMatch, List`1<Scorer> optionalScorers, List`1<Scorer> prohibitedScorers);
    private void InitBlock();
    public virtual bool Score(Collector collector, int max, int firstDocID);
    public virtual int Advance(int target);
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual float Score();
    public virtual void Score(Collector collector);
    public virtual string ToString();
}
internal class Lucene.Net.Search.BooleanScorer2 : Scorer {
    private List`1<Scorer> requiredScorers;
    private List`1<Scorer> optionalScorers;
    private List`1<Scorer> prohibitedScorers;
    private Coordinator coordinator;
    private Scorer countingSumScorer;
    private int minNrShouldMatch;
    private int doc;
    private static Similarity defaultSimilarity;
    public BooleanScorer2(Similarity similarity, int minNrShouldMatch, List`1<Scorer> required, List`1<Scorer> prohibited, List`1<Scorer> optional);
    private static BooleanScorer2();
    private Scorer CountingDisjunctionSumScorer(List`1<Scorer> scorers, int minNrShouldMatch);
    private Scorer CountingConjunctionSumScorer(List`1<Scorer> requiredScorers);
    private Scorer DualConjunctionSumScorer(Scorer req1, Scorer req2);
    private Scorer MakeCountingSumScorer();
    private Scorer MakeCountingSumScorerNoReq();
    private Scorer MakeCountingSumScorerSomeReq();
    private Scorer AddProhibitedScorers(Scorer requiredCountingSumScorer);
    public virtual void Score(Collector collector);
    public virtual bool Score(Collector collector, int max, int firstDocID);
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual float Score();
    public virtual int Advance(int target);
}
public interface Lucene.Net.Search.ByteParser {
    public abstract virtual sbyte ParseByte(string string_Renamed);
}
public abstract class Lucene.Net.Search.CacheEntry : object {
    [CompilerGeneratedAttribute]
private string <EstimatedSize>k__BackingField;
    public object ReaderKey { get; }
    public string FieldName { get; }
    public Type CacheType { get; }
    public object Custom { get; }
    public object Value { get; }
    public string EstimatedSize { get; protected internal set; }
    public abstract virtual object get_ReaderKey();
    public abstract virtual string get_FieldName();
    public abstract virtual Type get_CacheType();
    public abstract virtual object get_Custom();
    public abstract virtual object get_Value();
    public virtual void EstimateSize();
    public virtual void EstimateSize(RamUsageEstimator ramCalc);
    [CompilerGeneratedAttribute]
public string get_EstimatedSize();
    [CompilerGeneratedAttribute]
protected internal void set_EstimatedSize(string value);
    public virtual string ToString();
}
public class Lucene.Net.Search.CachingSpanFilter : SpanFilter {
    private SpanFilter filter;
    internal FilterCache`1<SpanFilterResult> cache;
    public int hitCount;
    public int missCount;
    public CachingSpanFilter(SpanFilter filter);
    public CachingSpanFilter(SpanFilter filter, DeletesMode deletesMode);
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
    private SpanFilterResult GetCachedResult(IndexReader reader);
    public virtual SpanFilterResult BitSpans(IndexReader reader);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.CachingWrapperFilter : Filter {
    protected internal Filter filter;
    internal FilterCache`1<DocIdSet> cache;
    public int hitCount;
    public int missCount;
    public CachingWrapperFilter(Filter filter);
    public CachingWrapperFilter(Filter filter, DeletesMode deletesMode);
    protected internal virtual DocIdSet DocIdSetToCache(DocIdSet docIdSet, IndexReader reader);
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Search.Collector : object {
    public bool AcceptsDocsOutOfOrder { get; }
    public abstract virtual void SetScorer(Scorer scorer);
    public abstract virtual void Collect(int doc);
    public abstract virtual void SetNextReader(IndexReader reader, int docBase);
    public abstract virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.ComplexExplanation : Explanation {
    private Nullable`1<bool> match;
    public Nullable`1<bool> Match { get; public set; }
    public bool IsMatch { get; }
    protected internal string Summary { get; }
    public ComplexExplanation(bool match, float value_Renamed, string description);
    public virtual Nullable`1<bool> get_Match();
    public virtual void set_Match(Nullable`1<bool> value);
    public virtual bool get_IsMatch();
    protected internal virtual string get_Summary();
}
internal class Lucene.Net.Search.ConjunctionScorer : Scorer {
    private Scorer[] scorers;
    private float coord;
    private int lastDoc;
    public ConjunctionScorer(Similarity similarity, ICollection`1<Scorer> scorers);
    public ConjunctionScorer(Similarity similarity, Scorer[] scorers);
    private int DoNext();
    public virtual int Advance(int target);
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual float Score();
}
public class Lucene.Net.Search.ConstantScoreQuery : Query {
    protected internal Filter internalFilter;
    public Filter Filter { get; }
    public ConstantScoreQuery(Filter filter);
    public virtual Filter get_Filter();
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual object Clone();
}
public class Lucene.Net.Search.CreationPlaceholder : object {
    internal object value_Renamed;
}
public class Lucene.Net.Search.DefaultSimilarity : Similarity {
    protected internal bool internalDiscountOverlaps;
    public bool DiscountOverlaps { get; public set; }
    public virtual float ComputeNorm(string field, FieldInvertState state);
    public virtual float LengthNorm(string fieldName, int numTerms);
    public virtual float QueryNorm(float sumOfSquaredWeights);
    public virtual float Tf(float freq);
    public virtual float SloppyFreq(int distance);
    public virtual float Idf(int docFreq, int numDocs);
    public virtual float Coord(int overlap, int maxOverlap);
    public virtual bool get_DiscountOverlaps();
    public virtual void set_DiscountOverlaps(bool value);
}
public class Lucene.Net.Search.DisjunctionMaxQuery : Query {
    private EquatableList`1<Query> disjuncts;
    private float tieBreakerMultiplier;
    public DisjunctionMaxQuery(float tieBreakerMultiplier);
    public DisjunctionMaxQuery(ICollection`1<Query> disjuncts, float tieBreakerMultiplier);
    public virtual void Add(Query query);
    public virtual void Add(ICollection`1<Query> disjuncts);
    public virtual IEnumerator`1<Query> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual object Clone();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.DisjunctionMaxScorer : Scorer {
    private Scorer[] subScorers;
    private int numScorers;
    private float tieBreakerMultiplier;
    private int doc;
    public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity, Scorer[] subScorers, int numScorers);
    public virtual int NextDoc();
    public virtual int DocID();
    public virtual float Score();
    private void ScoreAll(int root, int size, int doc, Single[] sum, Single[] max);
    public virtual int Advance(int target);
    private void Heapify();
    private void HeapAdjust(int root);
    private void HeapRemoveRoot();
}
internal class Lucene.Net.Search.DisjunctionSumScorer : Scorer {
    private int nrScorers;
    protected internal IList`1<Scorer> subScorers;
    private int minimumNrMatchers;
    private ScorerDocQueue scorerDocQueue;
    private int currentDoc;
    protected internal int nrMatchers;
    private float currentScore;
    public DisjunctionSumScorer(IList`1<Scorer> subScorers, int minimumNrMatchers);
    public DisjunctionSumScorer(IList`1<Scorer> subScorers);
    private void InitScorerDocQueue();
    public virtual void Score(Collector collector);
    public virtual bool Score(Collector collector, int max, int firstDocID);
    public virtual int NextDoc();
    protected internal virtual bool AdvanceAfterCurrent();
    public virtual float Score();
    public virtual int DocID();
    public virtual int NrMatchers();
    public virtual int Advance(int target);
}
public abstract class Lucene.Net.Search.DocIdSet : object {
    public static DocIdSet EMPTY_DOCIDSET;
    public bool IsCacheable { get; }
    private static DocIdSet();
    public abstract virtual DocIdSetIterator Iterator();
    public virtual bool get_IsCacheable();
}
public abstract class Lucene.Net.Search.DocIdSetIterator : object {
    private int doc;
    public static int NO_MORE_DOCS;
    private static DocIdSetIterator();
    public abstract virtual int DocID();
    public abstract virtual int NextDoc();
    public abstract virtual int Advance(int target);
}
public interface Lucene.Net.Search.DoubleParser {
    public abstract virtual double ParseDouble(string string_Renamed);
}
internal class Lucene.Net.Search.ExactPhraseScorer : PhraseScorer {
    internal ExactPhraseScorer(Weight weight, TermPositions[] tps, Int32[] offsets, Similarity similarity, Byte[] norms);
    protected internal virtual float PhraseFreq();
}
public class Lucene.Net.Search.Explanation : object {
    private float value;
    private string description;
    private List`1<Explanation> details;
    public bool IsMatch { get; }
    public float Value { get; public set; }
    public string Description { get; public set; }
    protected internal string Summary { get; }
    public Explanation(float value, string description);
    public virtual bool get_IsMatch();
    public virtual float get_Value();
    public virtual void set_Value(float value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    protected internal virtual string get_Summary();
    public virtual Explanation[] GetDetails();
    public virtual void AddDetail(Explanation detail);
    public virtual string ToString();
    protected internal virtual string ToString(int depth);
    public virtual string ToHtml();
}
public interface Lucene.Net.Search.FieldCache {
    public StreamWriter InfoStream { get; public set; }
    public abstract virtual SByte[] GetBytes(IndexReader reader, string field);
    public abstract virtual SByte[] GetBytes(IndexReader reader, string field, ByteParser parser);
    public abstract virtual Int16[] GetShorts(IndexReader reader, string field);
    public abstract virtual Int16[] GetShorts(IndexReader reader, string field, ShortParser parser);
    public abstract virtual Int32[] GetInts(IndexReader reader, string field);
    public abstract virtual Int32[] GetInts(IndexReader reader, string field, IntParser parser);
    public abstract virtual Single[] GetFloats(IndexReader reader, string field);
    public abstract virtual Single[] GetFloats(IndexReader reader, string field, FloatParser parser);
    public abstract virtual Int64[] GetLongs(IndexReader reader, string field);
    public abstract virtual Int64[] GetLongs(IndexReader reader, string field, LongParser parser);
    public abstract virtual Double[] GetDoubles(IndexReader reader, string field);
    public abstract virtual Double[] GetDoubles(IndexReader reader, string field, DoubleParser parser);
    public abstract virtual String[] GetStrings(IndexReader reader, string field);
    public abstract virtual StringIndex GetStringIndex(IndexReader reader, string field);
    public abstract virtual CacheEntry[] GetCacheEntries();
    public abstract virtual void PurgeAllCaches();
    public abstract virtual void Purge(IndexReader r);
    public abstract virtual StreamWriter get_InfoStream();
    public abstract virtual void set_InfoStream(StreamWriter value);
}
public class Lucene.Net.Search.FieldCache_Fields : ValueType {
    public static int STRING_INDEX;
    public static FieldCache DEFAULT;
    public static ByteParser DEFAULT_BYTE_PARSER;
    public static ShortParser DEFAULT_SHORT_PARSER;
    public static IntParser DEFAULT_INT_PARSER;
    public static FloatParser DEFAULT_FLOAT_PARSER;
    public static LongParser DEFAULT_LONG_PARSER;
    public static DoubleParser DEFAULT_DOUBLE_PARSER;
    public static IntParser NUMERIC_UTILS_INT_PARSER;
    public static FloatParser NUMERIC_UTILS_FLOAT_PARSER;
    public static LongParser NUMERIC_UTILS_LONG_PARSER;
    public static DoubleParser NUMERIC_UTILS_DOUBLE_PARSER;
    private static FieldCache_Fields();
}
internal class Lucene.Net.Search.FieldCacheImpl : object {
    private IDictionary`2<Type, Cache> caches;
    private StreamWriter modreq(System.Runtime.CompilerServices.IsVolatile) infoStream;
    public StreamWriter InfoStream { get; public set; }
    private void Init();
    public virtual void PurgeAllCaches();
    public sealed virtual void Purge(IndexReader r);
    public virtual CacheEntry[] GetCacheEntries();
    public virtual SByte[] GetBytes(IndexReader reader, string field);
    public virtual SByte[] GetBytes(IndexReader reader, string field, ByteParser parser);
    public virtual Int16[] GetShorts(IndexReader reader, string field);
    public virtual Int16[] GetShorts(IndexReader reader, string field, ShortParser parser);
    public virtual Int32[] GetInts(IndexReader reader, string field);
    public virtual Int32[] GetInts(IndexReader reader, string field, IntParser parser);
    public virtual Single[] GetFloats(IndexReader reader, string field);
    public virtual Single[] GetFloats(IndexReader reader, string field, FloatParser parser);
    public virtual Int64[] GetLongs(IndexReader reader, string field);
    public virtual Int64[] GetLongs(IndexReader reader, string field, LongParser parser);
    public virtual Double[] GetDoubles(IndexReader reader, string field);
    public virtual Double[] GetDoubles(IndexReader reader, string field, DoubleParser parser);
    public virtual String[] GetStrings(IndexReader reader, string field);
    public virtual StringIndex GetStringIndex(IndexReader reader, string field);
    public virtual StreamWriter get_InfoStream();
    public virtual void set_InfoStream(StreamWriter value);
}
public static class Lucene.Net.Search.FieldCacheRangeFilter : object {
    public static FieldCacheRangeFilter`1<string> NewStringRange(string field, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<sbyte>> NewByteRange(string field, Nullable`1<sbyte> lowerVal, Nullable`1<sbyte> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<sbyte>> NewByteRange(string field, ByteParser parser, Nullable`1<sbyte> lowerVal, Nullable`1<sbyte> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<short>> NewShortRange(string field, Nullable`1<short> lowerVal, Nullable`1<short> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<short>> NewShortRange(string field, ShortParser parser, Nullable`1<short> lowerVal, Nullable`1<short> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<int>> NewIntRange(string field, Nullable`1<int> lowerVal, Nullable`1<int> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<int>> NewIntRange(string field, IntParser parser, Nullable`1<int> lowerVal, Nullable`1<int> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<long>> NewLongRange(string field, Nullable`1<long> lowerVal, Nullable`1<long> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<long>> NewLongRange(string field, LongParser parser, Nullable`1<long> lowerVal, Nullable`1<long> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<float>> NewFloatRange(string field, Nullable`1<float> lowerVal, Nullable`1<float> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<float>> NewFloatRange(string field, FloatParser parser, Nullable`1<float> lowerVal, Nullable`1<float> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<double>> NewDoubleRange(string field, Nullable`1<double> lowerVal, Nullable`1<double> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<double>> NewDoubleRange(string field, DoubleParser parser, Nullable`1<double> lowerVal, Nullable`1<double> upperVal, bool includeLower, bool includeUpper);
}
public abstract class Lucene.Net.Search.FieldCacheRangeFilter`1 : Filter {
    internal string field;
    internal Parser parser;
    internal T lowerVal;
    internal T upperVal;
    internal bool includeLower;
    internal bool includeUpper;
    public string GetField { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public T LowerValue { get; }
    public T UpperValue { get; }
    public Parser Parser { get; }
    protected internal FieldCacheRangeFilter`1(string field, Parser parser, T lowerVal, T upperVal, bool includeLower, bool includeUpper);
    public abstract virtual DocIdSet GetDocIdSet(IndexReader reader);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public string get_GetField();
    public bool get_IncludesLower();
    public bool get_IncludesUpper();
    public T get_LowerValue();
    public T get_UpperValue();
    public Parser get_Parser();
}
public class Lucene.Net.Search.FieldCacheTermsFilter : Filter {
    private string field;
    private String[] terms;
    public FieldCache FieldCache { get; }
    public FieldCacheTermsFilter(string field, String[] terms);
    public virtual FieldCache get_FieldCache();
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
}
[DefaultMemberAttribute("Item")]
public abstract class Lucene.Net.Search.FieldComparator : object {
    public IComparable Item { get; }
    public abstract virtual int Compare(int slot1, int slot2);
    public abstract virtual void SetBottom(int slot);
    public abstract virtual int CompareBottom(int doc);
    public abstract virtual void Copy(int slot, int doc);
    public abstract virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual void SetScorer(Scorer scorer);
    public abstract virtual IComparable get_Item(int slot);
    protected internal static int BinarySearch(String[] a, string key);
    protected internal static int BinarySearch(String[] a, string key, int low, int high);
}
public abstract class Lucene.Net.Search.FieldComparatorSource : object {
    public abstract virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
public class Lucene.Net.Search.FieldDoc : ScoreDoc {
    public IComparable[] fields;
    internal Object[] fieldsClone;
    public FieldDoc(int doc, float score);
    public FieldDoc(int doc, float score, IComparable[] fields);
    public virtual string ToString();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
internal class Lucene.Net.Search.FieldDocSortedHitQueue : PriorityQueue`1<FieldDoc> {
    internal SortField[] modreq(System.Runtime.CompilerServices.IsVolatile) fields;
    internal CompareInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) collators;
    internal FieldDocSortedHitQueue(int size);
    internal virtual void SetFields(SortField[] fields);
    internal virtual SortField[] GetFields();
    private CompareInfo[] HasCollators(SortField[] fields);
    public virtual bool LessThan(FieldDoc docA, FieldDoc docB);
}
public abstract class Lucene.Net.Search.FieldValueHitQueue : PriorityQueue`1<Entry> {
    protected internal SortField[] fields;
    protected internal FieldComparator[] comparators;
    protected internal Int32[] reverseMul;
    private FieldValueHitQueue(SortField[] fields);
    public static FieldValueHitQueue Create(SortField[] fields, int size);
    internal virtual FieldComparator[] GetComparators();
    internal virtual Int32[] GetReverseMul();
    public abstract virtual bool LessThan(Entry a, Entry b);
    internal virtual FieldDoc FillFields(Entry entry);
    internal virtual SortField[] GetFields();
}
public abstract class Lucene.Net.Search.Filter : object {
    public abstract virtual DocIdSet GetDocIdSet(IndexReader reader);
}
public abstract class Lucene.Net.Search.FilteredDocIdSet : DocIdSet {
    private DocIdSet _innerSet;
    public bool IsCacheable { get; }
    protected FilteredDocIdSet(DocIdSet innerSet);
    public virtual bool get_IsCacheable();
    public abstract virtual bool Match(int docid);
    public virtual DocIdSetIterator Iterator();
}
public abstract class Lucene.Net.Search.FilteredDocIdSetIterator : DocIdSetIterator {
    protected internal DocIdSetIterator internalInnerIter;
    private int doc;
    protected FilteredDocIdSetIterator(DocIdSetIterator innerIter);
    public abstract virtual bool Match(int doc);
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual int Advance(int target);
}
public class Lucene.Net.Search.FilteredQuery : Query {
    internal Query query;
    internal Filter filter;
    public Query Query { get; }
    public Filter Filter { get; }
    public FilteredQuery(Query query, Filter filter);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual Query get_Query();
    public virtual Filter get_Filter();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string s);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Search.FilteredTermEnum : TermEnum {
    protected internal Term currentTerm;
    protected internal TermEnum actualEnum;
    private bool isDisposed;
    public Term Term { get; }
    protected internal abstract virtual bool TermCompare(Term term);
    public abstract virtual float Difference();
    public abstract virtual bool EndEnum();
    protected internal virtual void SetEnum(TermEnum actualEnum);
    public virtual int DocFreq();
    public virtual bool Next();
    public virtual Term get_Term();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Search.FilterManager : object {
    protected internal static FilterManager manager;
    protected internal static int DEFAULT_CACHE_CLEAN_SIZE;
    protected internal static long DEFAULT_CACHE_SLEEP_TIME;
    protected internal IDictionary`2<int, FilterItem> cache;
    protected internal int cacheCleanSize;
    protected internal long cleanSleepTime;
    protected internal FilterCleaner internalFilterCleaner;
    private static object _staticSyncObj;
    public static FilterManager Instance { get; }
    private static FilterManager();
    public static FilterManager get_Instance();
    public virtual void SetCacheSize(int value);
    public virtual void SetCleanThreadSleepTime(long value);
    public virtual Filter GetFilter(Filter filter);
}
public interface Lucene.Net.Search.FloatParser {
    public abstract virtual float ParseFloat(string string_Renamed);
}
public class Lucene.Net.Search.Function.ByteFieldSource : FieldCacheSource {
    private ByteParser parser;
    public ByteFieldSource(string field);
    public ByteFieldSource(string field, ByteParser parser);
    public virtual string Description();
    public virtual DocValues GetCachedFieldValues(FieldCache cache, string field, IndexReader reader);
    public virtual bool CachedFieldSourceEquals(FieldCacheSource o);
    public virtual int CachedFieldSourceHashCode();
}
public class Lucene.Net.Search.Function.CustomScoreProvider : object {
    protected IndexReader reader;
    public CustomScoreProvider(IndexReader reader);
    public virtual float CustomScore(int doc, float subQueryScore, Single[] valSrcScores);
    public virtual float CustomScore(int doc, float subQueryScore, float valSrcScore);
    public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation[] valSrcExpls);
    public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl);
}
public class Lucene.Net.Search.Function.CustomScoreQuery : Query {
    private Query subQuery;
    private ValueSourceQuery[] valSrcQueries;
    private bool strict;
    public CustomScoreQuery(Query subQuery);
    public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQuery);
    public CustomScoreQuery(Query subQuery, ValueSourceQuery[] valSrcQueries);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected virtual CustomScoreProvider GetCustomScoreProvider(IndexReader reader);
    [ObsoleteAttribute("Will be removed in Lucene 3.1")]
public virtual float CustomScore(int doc, float subQueryScore, Single[] valSrcScores);
    [ObsoleteAttribute("Will be removed in Lucene 3.1")]
public virtual float CustomScore(int doc, float subQueryScore, float valSrcScore);
    [ObsoleteAttribute("Will be removed in Lucene 3.1")]
public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation[] valSrcExpls);
    [ObsoleteAttribute("Will be removed in Lucene 3.1")]
public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual bool IsStrict();
    public virtual void SetStrict(bool strict);
    public virtual string Name();
}
public abstract class Lucene.Net.Search.Function.DocValues : object {
    private float minVal;
    private float maxVal;
    private float avgVal;
    private bool computed;
    protected internal object InnerArray { get; }
    public abstract virtual float FloatVal(int doc);
    public virtual int IntVal(int doc);
    public virtual long LongVal(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public abstract virtual string ToString(int doc);
    public virtual Explanation Explain(int doc);
    protected internal virtual object get_InnerArray();
    private void Compute();
    public virtual float GetMinValue();
    public virtual float GetMaxValue();
    public virtual float GetAverageValue();
}
public abstract class Lucene.Net.Search.Function.FieldCacheSource : ValueSource {
    private string field;
    protected FieldCacheSource(string field);
    public virtual DocValues GetValues(IndexReader reader);
    public virtual string Description();
    public abstract virtual DocValues GetCachedFieldValues(FieldCache cache, string field, IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public abstract virtual bool CachedFieldSourceEquals(FieldCacheSource other);
    public abstract virtual int CachedFieldSourceHashCode();
}
public class Lucene.Net.Search.Function.FieldScoreQuery : ValueSourceQuery {
    public FieldScoreQuery(string field, Type type);
    private static ValueSource GetValueSource(string field, Type type);
}
public class Lucene.Net.Search.Function.FloatFieldSource : FieldCacheSource {
    private FloatParser parser;
    public FloatFieldSource(string field);
    public FloatFieldSource(string field, FloatParser parser);
    public virtual string Description();
    public virtual DocValues GetCachedFieldValues(FieldCache cache, string field, IndexReader reader);
    public virtual bool CachedFieldSourceEquals(FieldCacheSource o);
    public virtual int CachedFieldSourceHashCode();
}
public class Lucene.Net.Search.Function.IntFieldSource : FieldCacheSource {
    private IntParser parser;
    public IntFieldSource(string field);
    public IntFieldSource(string field, IntParser parser);
    public virtual string Description();
    public virtual DocValues GetCachedFieldValues(FieldCache cache, string field, IndexReader reader);
    public virtual bool CachedFieldSourceEquals(FieldCacheSource o);
    public virtual int CachedFieldSourceHashCode();
}
public class Lucene.Net.Search.Function.OrdFieldSource : ValueSource {
    protected internal string field;
    private static int hcode;
    public OrdFieldSource(string field);
    private static OrdFieldSource();
    public virtual string Description();
    public virtual DocValues GetValues(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Function.ReverseOrdFieldSource : ValueSource {
    public string field;
    private static int hcode;
    public ReverseOrdFieldSource(string field);
    private static ReverseOrdFieldSource();
    public virtual string Description();
    public virtual DocValues GetValues(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Function.ShortFieldSource : FieldCacheSource {
    private ShortParser parser;
    public ShortFieldSource(string field);
    public ShortFieldSource(string field, ShortParser parser);
    public virtual string Description();
    public virtual DocValues GetCachedFieldValues(FieldCache cache, string field, IndexReader reader);
    public virtual bool CachedFieldSourceEquals(FieldCacheSource o);
    public virtual int CachedFieldSourceHashCode();
}
public abstract class Lucene.Net.Search.Function.ValueSource : object {
    public abstract virtual DocValues GetValues(IndexReader reader);
    public abstract virtual string Description();
    public virtual string ToString();
    public abstract virtual bool Equals(object o);
    public abstract virtual int GetHashCode();
}
public class Lucene.Net.Search.Function.ValueSourceQuery : Query {
    internal ValueSource valSrc;
    public ValueSourceQuery(ValueSource valSrc);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual object Clone();
}
public class Lucene.Net.Search.FuzzyQuery : MultiTermQuery {
    public static float defaultMinSimilarity;
    public static int defaultPrefixLength;
    private float minimumSimilarity;
    private int prefixLength;
    private bool termLongEnough;
    [CompilerGeneratedAttribute]
private Term <Term>k__BackingField;
    public Term Term { get; protected internal set; }
    public float MinSimilarity { get; }
    public int PrefixLength { get; }
    unknown RewriteMethod RewriteMethod {public set; }
    public FuzzyQuery(Term term, float minimumSimilarity, int prefixLength);
    public FuzzyQuery(Term term, float minimumSimilarity);
    public FuzzyQuery(Term term);
    [CompilerGeneratedAttribute]
public Term get_Term();
    [CompilerGeneratedAttribute]
protected internal void set_Term(Term value);
    public virtual float get_MinSimilarity();
    public virtual int get_PrefixLength();
    protected internal virtual FilteredTermEnum GetEnum(IndexReader reader);
    public virtual void set_RewriteMethod(RewriteMethod value);
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.FuzzyTermEnum : FilteredTermEnum {
    private Int32[] p;
    private Int32[] d;
    private float similarity;
    private bool endEnum;
    private bool isDisposed;
    private Term searchTerm;
    private string field;
    private string text;
    private string prefix;
    private float minimumSimilarity;
    private float scale_factor;
    public FuzzyTermEnum(IndexReader reader, Term term);
    public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity);
    public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity, int prefixLength);
    protected internal virtual bool TermCompare(Term term);
    public virtual float Difference();
    public virtual bool EndEnum();
    private float Similarity(string target);
    private int CalculateMaxDistance(int m);
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Search.HitQueue : PriorityQueue`1<ScoreDoc> {
    private bool prePopulate;
    protected internal ScoreDoc SentinelObject { get; }
    public HitQueue(int size, bool prePopulate);
    protected internal virtual ScoreDoc get_SentinelObject();
    public virtual bool LessThan(ScoreDoc hitA, ScoreDoc hitB);
}
public class Lucene.Net.Search.IndexSearcher : Searcher {
    internal IndexReader reader;
    private bool closeReader;
    private bool isDisposed;
    private IndexReader[] subReaders;
    private Int32[] docStarts;
    private bool fieldSortDoTrackScores;
    private bool fieldSortDoMaxScore;
    public IndexReader IndexReader { get; }
    public int MaxDoc { get; }
    public IndexReader reader_ForNUnit { get; }
    public IndexSearcher(Directory path);
    public IndexSearcher(Directory path, bool readOnly);
    public IndexSearcher(IndexReader r);
    public IndexSearcher(IndexReader reader, IndexReader[] subReaders, Int32[] docStarts);
    private IndexSearcher(IndexReader r, bool closeReader);
    protected internal virtual void GatherSubReaders(IList`1<IndexReader> allSubReaders, IndexReader r);
    public virtual IndexReader get_IndexReader();
    protected virtual void Dispose(bool disposing);
    public virtual int DocFreq(Term term);
    public virtual Document Doc(int i);
    public virtual Document Doc(int i, FieldSelector fieldSelector);
    public virtual int get_MaxDoc();
    public virtual TopDocs Search(Weight weight, Filter filter, int nDocs);
    public virtual TopFieldDocs Search(Weight weight, Filter filter, int nDocs, Sort sort);
    public virtual TopFieldDocs Search(Weight weight, Filter filter, int nDocs, Sort sort, bool fillFields);
    public virtual void Search(Weight weight, Filter filter, Collector collector);
    private void SearchWithFilter(IndexReader reader, Weight weight, Filter filter, Collector collector);
    public virtual Query Rewrite(Query original);
    public virtual Explanation Explain(Weight weight, int doc);
    public virtual void SetDefaultFieldSortScoring(bool doTrackScores, bool doMaxScore);
    public IndexReader get_reader_ForNUnit();
}
public interface Lucene.Net.Search.IntParser {
    public abstract virtual int ParseInt(string string_Renamed);
}
public interface Lucene.Net.Search.LongParser {
    public abstract virtual long ParseLong(string string_Renamed);
}
public class Lucene.Net.Search.MatchAllDocsQuery : Query {
    private string normsField;
    public MatchAllDocsQuery(string normsField);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.MultiPhraseQuery : Query {
    private string field;
    private List`1<Term[]> termArrays;
    private List`1<int> positions;
    private int slop;
    public int Slop { get; public set; }
    public virtual int get_Slop();
    public virtual void set_Slop(int value);
    public virtual void Add(Term term);
    public virtual void Add(Term[] terms);
    public virtual void Add(Term[] terms, int position);
    public virtual IList`1<Term[]> GetTermArrays();
    public virtual Int32[] GetPositions();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Query Rewrite(IndexReader reader);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual string ToString(string f);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private int TermArraysHashCode();
    private int ArraysHashCode(Term[] termArray);
    private bool TermArraysEquals(List`1<Term[]> termArrays1, List`1<Term[]> termArrays2);
    public static bool TermEquals(Array array1, Array array2);
}
public class Lucene.Net.Search.MultiSearcher : Searcher {
    private Searchable[] searchables;
    private Int32[] starts;
    private int maxDoc;
    private bool isDisposed;
    internal Func`10<ThreadLock, object, Searchable, Weight, Filter, int, HitQueue, int, Int32[], TopDocs> MultiSearcherCallableNoSort;
    internal Func`11<ThreadLock, object, Searchable, Weight, Filter, int, FieldDocSortedHitQueue, Sort, int, Int32[], TopFieldDocs> MultiSearcherCallableWithSort;
    public int MaxDoc { get; }
    public MultiSearcher(Searchable[] searchables);
    public virtual Searchable[] GetSearchables();
    protected internal virtual Int32[] GetStarts();
    protected virtual void Dispose(bool disposing);
    public virtual int DocFreq(Term term);
    public virtual Document Doc(int n);
    public virtual Document Doc(int n, FieldSelector fieldSelector);
    public virtual int SubSearcher(int n);
    public virtual int SubDoc(int n);
    public virtual int get_MaxDoc();
    public virtual TopDocs Search(Weight weight, Filter filter, int nDocs);
    public virtual TopFieldDocs Search(Weight weight, Filter filter, int n, Sort sort);
    public virtual void Search(Weight weight, Filter filter, Collector collector);
    public virtual Query Rewrite(Query original);
    public virtual Explanation Explain(Weight weight, int doc);
    public virtual Weight CreateWeight(Query original);
}
public abstract class Lucene.Net.Search.MultiTermQuery : Query {
    protected internal RewriteMethod internalRewriteMethod;
    internal int numberOfTerms;
    public static RewriteMethod CONSTANT_SCORE_FILTER_REWRITE;
    public static RewriteMethod SCORING_BOOLEAN_QUERY_REWRITE;
    public static RewriteMethod CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE;
    public static RewriteMethod CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
    public int TotalNumberOfTerms { get; }
    public RewriteMethod RewriteMethod { get; public set; }
    private static MultiTermQuery();
    protected internal abstract virtual FilteredTermEnum GetEnum(IndexReader reader);
    public virtual int get_TotalNumberOfTerms();
    public virtual void ClearTotalNumberOfTerms();
    protected internal virtual void IncTotalNumberOfTerms(int inc);
    public virtual Query Rewrite(IndexReader reader);
    public virtual RewriteMethod get_RewriteMethod();
    public virtual void set_RewriteMethod(RewriteMethod value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.MultiTermQueryWrapperFilter`1 : Filter {
    protected internal T query;
    public int TotalNumberOfTerms { get; }
    protected internal MultiTermQueryWrapperFilter`1(T query);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual int get_TotalNumberOfTerms();
    public virtual void ClearTotalNumberOfTerms();
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
}
public static class Lucene.Net.Search.NumericRangeFilter : object {
    public static NumericRangeFilter`1<long> NewLongRange(string field, int precisionStep, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<long> NewLongRange(string field, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<int> NewIntRange(string field, int precisionStep, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<int> NewIntRange(string field, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<double> NewDoubleRange(string field, int precisionStep, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<double> NewDoubleRange(string field, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<float> NewFloatRange(string field, int precisionStep, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<float> NewFloatRange(string field, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
}
public class Lucene.Net.Search.NumericRangeFilter`1 : MultiTermQueryWrapperFilter`1<NumericRangeQuery`1<T>> {
    public string Field { get; }
    public bool IncludesMin { get; }
    public bool IncludesMax { get; }
    public Nullable`1<T> Min { get; }
    public Nullable`1<T> Max { get; }
    internal NumericRangeFilter`1(NumericRangeQuery`1<T> query);
    public string get_Field();
    public bool get_IncludesMin();
    public bool get_IncludesMax();
    public Nullable`1<T> get_Min();
    public Nullable`1<T> get_Max();
}
public static class Lucene.Net.Search.NumericRangeQuery : object {
    public static NumericRangeQuery`1<long> NewLongRange(string field, int precisionStep, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<long> NewLongRange(string field, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<int> NewIntRange(string field, int precisionStep, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<int> NewIntRange(string field, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<double> NewDoubleRange(string field, int precisionStep, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<double> NewDoubleRange(string field, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<float> NewFloatRange(string field, int precisionStep, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<float> NewFloatRange(string field, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
}
public class Lucene.Net.Search.NumericRangeQuery`1 : MultiTermQuery {
    internal string field;
    internal int precisionStep;
    internal int valSize;
    internal Nullable`1<T> min;
    internal Nullable`1<T> max;
    internal bool minInclusive;
    internal bool maxInclusive;
    public string Field { get; }
    public bool IncludesMin { get; }
    public bool IncludesMax { get; }
    public Nullable`1<T> Min { get; }
    public Nullable`1<T> Max { get; }
    internal NumericRangeQuery`1(string field, int precisionStep, int valSize, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    protected internal virtual FilteredTermEnum GetEnum(IndexReader reader);
    public string get_Field();
    public bool get_IncludesMin();
    public bool get_IncludesMax();
    public Nullable`1<T> get_Min();
    public Nullable`1<T> get_Max();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
}
public enum Lucene.Net.Search.Occur : Enum {
    public int value__;
    public static Occur MUST;
    public static Occur SHOULD;
    public static Occur MUST_NOT;
}
[ExtensionAttribute]
public static class Lucene.Net.Search.OccurExtensions : object {
    [ExtensionAttribute]
public static string ToString(Occur occur);
}
public class Lucene.Net.Search.ParallelMultiSearcher : MultiSearcher {
    private Searchable[] searchables;
    private Int32[] starts;
    public ParallelMultiSearcher(Searchable[] searchables);
    public virtual int DocFreq(Term term);
    public virtual TopDocs Search(Weight weight, Filter filter, int nDocs);
    public virtual TopFieldDocs Search(Weight weight, Filter filter, int nDocs, Sort sort);
    public virtual void Search(Weight weight, Filter filter, Collector collector);
}
public interface Lucene.Net.Search.Parser {
}
public class Lucene.Net.Search.Payloads.AveragePayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.MaxPayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.MinPayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Lucene.Net.Search.Payloads.PayloadFunction : object {
    public abstract virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public abstract virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object o);
}
public class Lucene.Net.Search.Payloads.PayloadNearQuery : SpanNearQuery {
    protected internal string fieldName;
    protected internal PayloadFunction function;
    public PayloadNearQuery(SpanQuery[] clauses, int slop, bool inOrder);
    public PayloadNearQuery(SpanQuery[] clauses, int slop, bool inOrder, PayloadFunction function);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.PayloadSpanUtil : object {
    private IndexReader reader;
    public PayloadSpanUtil(IndexReader reader);
    public virtual ICollection`1<Byte[]> GetPayloadsForQuery(Query query);
    private void QueryToSpanQuery(Query query, ICollection`1<Byte[]> payloads);
    private void GetPayloads(ICollection`1<Byte[]> payloads, SpanQuery query);
}
public class Lucene.Net.Search.Payloads.PayloadTermQuery : SpanTermQuery {
    protected internal PayloadFunction function;
    private bool includeSpanScore;
    public PayloadTermQuery(Term term, PayloadFunction function);
    public PayloadTermQuery(Term term, PayloadFunction function, bool includeSpanScore);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Lucene.Net.Search.PhrasePositions : object {
    internal int doc;
    internal int position;
    internal int count;
    internal int offset;
    internal TermPositions tp;
    internal PhrasePositions next;
    internal bool repeats;
    internal PhrasePositions(TermPositions t, int o);
    internal bool Next();
    internal bool SkipTo(int target);
    internal void FirstPosition();
    internal bool NextPosition();
}
public class Lucene.Net.Search.PhraseQuery : Query {
    private string field;
    private EquatableList`1<Term> terms;
    private EquatableList`1<int> positions;
    private int maxPosition;
    private int slop;
    public int Slop { get; public set; }
    public virtual int get_Slop();
    public virtual void set_Slop(int value);
    public virtual void Add(Term term);
    public virtual void Add(Term term, int position);
    public virtual Term[] GetTerms();
    public virtual Int32[] GetPositions();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> queryTerms);
    public virtual string ToString(string f);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.PhraseQueue : PriorityQueue`1<PhrasePositions> {
    internal PhraseQueue(int size);
    public virtual bool LessThan(PhrasePositions pp1, PhrasePositions pp2);
}
internal abstract class Lucene.Net.Search.PhraseScorer : Scorer {
    private Weight weight;
    protected internal Byte[] norms;
    protected internal float value_Renamed;
    private bool firstTime;
    private bool more;
    protected internal PhraseQueue pq;
    protected internal PhrasePositions first;
    protected internal PhrasePositions last;
    private float freq;
    internal PhraseScorer(Weight weight, TermPositions[] tps, Int32[] offsets, Similarity similarity, Byte[] norms);
    public virtual int DocID();
    public virtual int NextDoc();
    private bool DoNext();
    public virtual float Score();
    public virtual int Advance(int target);
    public float CurrentFreq();
    protected internal abstract virtual float PhraseFreq();
    private void Init();
    private void Sort();
    protected internal void PqToList();
    protected internal void FirstToLast();
    public virtual string ToString();
}
public class Lucene.Net.Search.PositiveScoresOnlyCollector : Collector {
    private Collector c;
    private Scorer scorer;
    public bool AcceptsDocsOutOfOrder { get; }
    public PositiveScoresOnlyCollector(Collector c);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual void SetScorer(Scorer scorer);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.PrefixFilter : MultiTermQueryWrapperFilter`1<PrefixQuery> {
    public Term Prefix { get; }
    public PrefixFilter(Term prefix);
    public virtual Term get_Prefix();
    public virtual string ToString();
}
public class Lucene.Net.Search.PrefixQuery : MultiTermQuery {
    private Term prefix;
    public Term Prefix { get; }
    public PrefixQuery(Term prefix);
    public virtual Term get_Prefix();
    protected internal virtual FilteredTermEnum GetEnum(IndexReader reader);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.PrefixTermEnum : FilteredTermEnum {
    private Term prefix;
    private bool endEnum;
    protected internal Term PrefixTerm { get; }
    public PrefixTermEnum(IndexReader reader, Term prefix);
    public virtual float Difference();
    public virtual bool EndEnum();
    protected internal virtual Term get_PrefixTerm();
    protected internal virtual bool TermCompare(Term term);
}
public abstract class Lucene.Net.Search.Query : object {
    private float boost;
    public float Boost { get; public set; }
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    public abstract virtual string ToString(string field);
    public virtual string ToString();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual Weight Weight(Searcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual Query Combine(Query[] queries);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public static Query MergeBooleanQueries(BooleanQuery[] queries);
    public virtual Similarity GetSimilarity(Searcher searcher);
    public virtual object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.QueryTermVector : object {
    private String[] terms;
    private Int32[] termFreqs;
    public string Field { get; }
    public int Size { get; }
    public QueryTermVector(String[] queryTerms);
    public QueryTermVector(string queryString, Analyzer analyzer);
    public virtual string get_Field();
    private void ProcessTerms(String[] queryTerms);
    public virtual string ToString();
    public virtual int get_Size();
    public virtual String[] GetTerms();
    public virtual Int32[] GetTermFrequencies();
    public virtual int IndexOf(string term);
    public virtual Int32[] IndexesOf(String[] terms, int start, int len);
}
public class Lucene.Net.Search.QueryWrapperFilter : Filter {
    private Query query;
    public QueryWrapperFilter(Query query);
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.ReqExclScorer : Scorer {
    private Scorer reqScorer;
    private DocIdSetIterator exclDisi;
    private int doc;
    public ReqExclScorer(Scorer reqScorer, DocIdSetIterator exclDisi);
    public virtual int NextDoc();
    private int ToNonExcluded();
    public virtual int DocID();
    public virtual float Score();
    public virtual int Advance(int target);
}
internal class Lucene.Net.Search.ReqOptSumScorer : Scorer {
    private Scorer reqScorer;
    private Scorer optScorer;
    public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer);
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual int DocID();
    public virtual float Score();
}
public abstract class Lucene.Net.Search.RewriteMethod : object {
    public abstract virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
}
public class Lucene.Net.Search.ScoreCachingWrappingScorer : Scorer {
    private Scorer scorer;
    private int curDoc;
    private float curScore;
    public Similarity Similarity { get; }
    public ScoreCachingWrappingScorer(Scorer scorer);
    public virtual bool Score(Collector collector, int max, int firstDocID);
    public virtual Similarity get_Similarity();
    public virtual float Score();
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual void Score(Collector collector);
    public virtual int Advance(int target);
}
public class Lucene.Net.Search.ScoreDoc : object {
    [CompilerGeneratedAttribute]
private float <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Doc>k__BackingField;
    public float Score { get; public set; }
    public int Doc { get; public set; }
    public ScoreDoc(int doc, float score);
    [CompilerGeneratedAttribute]
public float get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(float value);
    [CompilerGeneratedAttribute]
public int get_Doc();
    [CompilerGeneratedAttribute]
public void set_Doc(int value);
    public virtual string ToString();
}
public abstract class Lucene.Net.Search.Scorer : DocIdSetIterator {
    private Similarity similarity;
    public Similarity Similarity { get; }
    protected internal Scorer(Similarity similarity);
    public virtual Similarity get_Similarity();
    public virtual void Score(Collector collector);
    public virtual bool Score(Collector collector, int max, int firstDocID);
    public abstract virtual float Score();
}
public interface Lucene.Net.Search.Searchable {
    public int MaxDoc { get; }
    public abstract virtual void Search(Weight weight, Filter filter, Collector collector);
    public abstract virtual void Close();
    public abstract virtual int DocFreq(Term term);
    public abstract virtual Int32[] DocFreqs(Term[] terms);
    public abstract virtual int get_MaxDoc();
    public abstract virtual TopDocs Search(Weight weight, Filter filter, int n);
    public abstract virtual Document Doc(int i);
    public abstract virtual Document Doc(int n, FieldSelector fieldSelector);
    public abstract virtual Query Rewrite(Query query);
    public abstract virtual Explanation Explain(Weight weight, int doc);
    public abstract virtual TopFieldDocs Search(Weight weight, Filter filter, int n, Sort sort);
}
public abstract class Lucene.Net.Search.Searcher : MarshalByRefObject {
    private Similarity similarity;
    public Similarity Similarity { get; public set; }
    public int MaxDoc { get; }
    private void InitBlock();
    public virtual TopFieldDocs Search(Query query, Filter filter, int n, Sort sort);
    public virtual void Search(Query query, Collector results);
    public virtual void Search(Query query, Filter filter, Collector results);
    public virtual TopDocs Search(Query query, Filter filter, int n);
    public virtual TopDocs Search(Query query, int n);
    public virtual Explanation Explain(Query query, int doc);
    public virtual Similarity get_Similarity();
    public virtual void set_Similarity(Similarity value);
    public virtual Weight CreateWeight(Query query);
    public virtual Int32[] DocFreqs(Term[] terms);
    public abstract virtual void Search(Weight weight, Filter filter, Collector results);
    [ObsoleteAttribute("Use Dispose() instead")]
public sealed virtual void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual int DocFreq(Term term);
    public abstract virtual int get_MaxDoc();
    public abstract virtual TopDocs Search(Weight weight, Filter filter, int n);
    public abstract virtual Document Doc(int i);
    public abstract virtual Document Doc(int docid, FieldSelector fieldSelector);
    public abstract virtual Query Rewrite(Query query);
    public abstract virtual Explanation Explain(Weight weight, int doc);
    public abstract virtual TopFieldDocs Search(Weight weight, Filter filter, int n, Sort sort);
}
public interface Lucene.Net.Search.ShortParser {
    public abstract virtual short ParseShort(string string_Renamed);
}
public abstract class Lucene.Net.Search.Similarity : object {
    private static Similarity defaultImpl;
    public static int NO_DOC_ID_PROVIDED;
    private static Single[] NORM_TABLE;
    public static Similarity Default { get; public set; }
    private static Similarity();
    private void InitBlock();
    public static Similarity get_Default();
    public static void set_Default(Similarity value);
    public static float DecodeNorm(byte b);
    public static Single[] GetNormDecoder();
    public virtual float ComputeNorm(string field, FieldInvertState state);
    public abstract virtual float LengthNorm(string fieldName, int numTokens);
    public abstract virtual float QueryNorm(float sumOfSquaredWeights);
    public static byte EncodeNorm(float f);
    public virtual float Tf(int freq);
    public abstract virtual float SloppyFreq(int distance);
    public abstract virtual float Tf(float freq);
    public virtual IDFExplanation IdfExplain(Term term, Searcher searcher);
    public virtual IDFExplanation IdfExplain(ICollection`1<Term> terms, Searcher searcher);
    public abstract virtual float Idf(int docFreq, int numDocs);
    public abstract virtual float Coord(int overlap, int maxOverlap);
    public virtual float ScorePayload(int docId, string fieldName, int start, int end, Byte[] payload, int offset, int length);
}
public class Lucene.Net.Search.SimilarityDelegator : Similarity {
    private Similarity delegee;
    public SimilarityDelegator(Similarity delegee);
    public virtual float ComputeNorm(string fieldName, FieldInvertState state);
    public virtual float LengthNorm(string fieldName, int numTerms);
    public virtual float QueryNorm(float sumOfSquaredWeights);
    public virtual float Tf(float freq);
    public virtual float SloppyFreq(int distance);
    public virtual float Idf(int docFreq, int numDocs);
    public virtual float Coord(int overlap, int maxOverlap);
    public virtual float ScorePayload(int docId, string fieldName, int start, int end, Byte[] payload, int offset, int length);
}
public class Lucene.Net.Search.SingleTermEnum : FilteredTermEnum {
    private Term singleTerm;
    private bool _endEnum;
    public SingleTermEnum(IndexReader reader, Term singleTerm);
    public virtual float Difference();
    public virtual bool EndEnum();
    protected internal virtual bool TermCompare(Term term);
}
internal class Lucene.Net.Search.SloppyPhraseScorer : PhraseScorer {
    private int slop;
    private PhrasePositions[] repeats;
    private PhrasePositions[] tmpPos;
    private bool checkedRepeats;
    internal SloppyPhraseScorer(Weight weight, TermPositions[] tps, Int32[] offsets, Similarity similarity, int slop, Byte[] norms);
    protected internal virtual float PhraseFreq();
    private PhrasePositions Flip(PhrasePositions pp, PhrasePositions pp2);
    private int InitPhrasePositions();
    private PhrasePositions TermPositionsDiffer(PhrasePositions pp);
}
public class Lucene.Net.Search.Sort : object {
    public static Sort RELEVANCE;
    public static Sort INDEXORDER;
    internal SortField[] fields;
    public Sort(SortField field);
    public Sort(SortField[] fields);
    private static Sort();
    public virtual void SetSort(SortField field);
    public virtual void SetSort(SortField[] fields);
    public virtual SortField[] GetSort();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.SortField : object {
    public static int SCORE;
    public static int DOC;
    public static int STRING;
    public static int INT;
    public static int FLOAT;
    public static int LONG;
    public static int DOUBLE;
    public static int SHORT;
    public static int CUSTOM;
    public static int BYTE;
    public static int STRING_VAL;
    public static SortField FIELD_SCORE;
    public static SortField FIELD_DOC;
    private string field;
    private int type;
    private CultureInfo locale;
    internal bool reverse;
    private Parser parser;
    private FieldComparatorSource comparatorSource;
    public string Field { get; }
    public int Type { get; }
    public CultureInfo Locale { get; }
    public Parser Parser { get; }
    public bool Reverse { get; }
    public FieldComparatorSource ComparatorSource { get; }
    public SortField(string field, int type);
    public SortField(string field, int type, bool reverse);
    public SortField(string field, Parser parser);
    public SortField(string field, Parser parser, bool reverse);
    public SortField(string field, CultureInfo locale);
    public SortField(string field, CultureInfo locale, bool reverse);
    public SortField(string field, FieldComparatorSource comparator);
    public SortField(string field, FieldComparatorSource comparator, bool reverse);
    private static SortField();
    private void InitFieldType(string field, int type);
    public virtual string get_Field();
    public virtual int get_Type();
    public virtual CultureInfo get_Locale();
    public virtual Parser get_Parser();
    public virtual bool get_Reverse();
    public virtual FieldComparatorSource get_ComparatorSource();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    public virtual FieldComparator GetComparator(int numHits, int sortPos);
}
public abstract class Lucene.Net.Search.SpanFilter : Filter {
    public abstract virtual SpanFilterResult BitSpans(IndexReader reader);
}
public class Lucene.Net.Search.SpanFilterResult : object {
    private DocIdSet docIdSet;
    private IList`1<PositionInfo> positions;
    public IList`1<PositionInfo> Positions { get; }
    public DocIdSet DocIdSet { get; }
    public SpanFilterResult(DocIdSet docIdSet, IList`1<PositionInfo> positions);
    public virtual IList`1<PositionInfo> get_Positions();
    public virtual DocIdSet get_DocIdSet();
}
public class Lucene.Net.Search.SpanQueryFilter : SpanFilter {
    protected internal SpanQuery internalQuery;
    public SpanQuery Query { get; }
    public SpanQueryFilter(SpanQuery query);
    public virtual DocIdSet GetDocIdSet(IndexReader reader);
    public virtual SpanFilterResult BitSpans(IndexReader reader);
    public virtual SpanQuery get_Query();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.FieldMaskingSpanQuery : SpanQuery {
    private SpanQuery maskedQuery;
    private string field;
    public string Field { get; }
    public SpanQuery MaskedQuery { get; }
    public FieldMaskingSpanQuery(SpanQuery maskedQuery, string maskedField);
    public virtual string get_Field();
    public virtual SpanQuery get_MaskedQuery();
    public virtual Spans GetSpans(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual Similarity GetSimilarity(Searcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.NearSpansOrdered : Spans {
    private int allowedSlop;
    private bool firstTime;
    private bool more;
    private Spans[] subSpans;
    private bool inSameDoc;
    private int matchDoc;
    private int matchStart;
    private int matchEnd;
    private List`1<Byte[]> matchPayload;
    private Spans[] subSpansByDoc;
    private IComparer spanDocComparator;
    private SpanNearQuery query;
    private bool collectPayloads;
    public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader);
    public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader, bool collectPayloads);
    private void InitBlock();
    public virtual int Doc();
    public virtual int Start();
    public virtual int End();
    public virtual Spans[] GetSubSpans();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool IsPayloadAvailable();
    public virtual bool Next();
    public virtual bool SkipTo(int target);
    private bool AdvanceAfterOrdered();
    private bool ToSameDoc();
    internal static bool DocSpansOrdered(Spans spans1, Spans spans2);
    private static bool DocSpansOrdered(int start1, int end1, int start2, int end2);
    private bool StretchToOrder();
    private bool ShrinkToAfterShortestMatch();
    public virtual string ToString();
}
public class Lucene.Net.Search.Spans.NearSpansUnordered : Spans {
    private SpanNearQuery query;
    private IList`1<SpansCell> ordered;
    private Spans[] subSpans;
    private int slop;
    private SpansCell first;
    private SpansCell last;
    private int totalLength;
    private CellQueue queue;
    private SpansCell max;
    private bool more;
    private bool firstTime;
    public NearSpansUnordered(SpanNearQuery query, IndexReader reader);
    public virtual Spans[] GetSubSpans();
    public virtual bool Next();
    public virtual bool SkipTo(int target);
    private SpansCell Min();
    public virtual int Doc();
    public virtual int Start();
    public virtual int End();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool IsPayloadAvailable();
    public virtual string ToString();
    private void InitList(bool next);
    private void AddToList(SpansCell cell);
    private void FirstToLast();
    private void QueueToList();
    private void ListToQueue();
    private bool AtMatch();
}
public class Lucene.Net.Search.Spans.SpanFirstQuery : SpanQuery {
    private SpanQuery match;
    private int end;
    public SpanQuery Match { get; }
    public int End { get; }
    public string Field { get; }
    public SpanFirstQuery(SpanQuery match, int end);
    public virtual SpanQuery get_Match();
    public virtual int get_End();
    public virtual string get_Field();
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Spans GetSpans(IndexReader reader);
    public virtual Query Rewrite(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanNearQuery : SpanQuery {
    protected internal IList`1<SpanQuery> clauses;
    protected internal int internalSlop;
    protected internal bool inOrder;
    protected internal string internalField;
    private bool collectPayloads;
    public int Slop { get; }
    public bool IsInOrder { get; }
    public string Field { get; }
    public SpanNearQuery(SpanQuery[] clauses, int slop, bool inOrder);
    public SpanNearQuery(SpanQuery[] clauses, int slop, bool inOrder, bool collectPayloads);
    public virtual SpanQuery[] GetClauses();
    public virtual int get_Slop();
    public virtual bool get_IsInOrder();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual Spans GetSpans(IndexReader reader);
    public virtual Query Rewrite(IndexReader reader);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanNotQuery : SpanQuery {
    private SpanQuery include;
    private SpanQuery exclude;
    public SpanQuery Include { get; }
    public SpanQuery Exclude { get; }
    public string Field { get; }
    public SpanNotQuery(SpanQuery include, SpanQuery exclude);
    public virtual SpanQuery get_Include();
    public virtual SpanQuery get_Exclude();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual Spans GetSpans(IndexReader reader);
    public virtual Query Rewrite(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanOrQuery : SpanQuery {
    private EquatableList`1<SpanQuery> clauses;
    private string field;
    public string Field { get; }
    public SpanOrQuery(SpanQuery[] clauses);
    public virtual SpanQuery[] GetClauses();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Spans GetSpans(IndexReader reader);
}
public abstract class Lucene.Net.Search.Spans.SpanQuery : Query {
    public string Field { get; }
    public abstract virtual Spans GetSpans(IndexReader reader);
    public abstract virtual string get_Field();
    public virtual Weight CreateWeight(Searcher searcher);
}
public abstract class Lucene.Net.Search.Spans.Spans : object {
    public abstract virtual bool Next();
    public abstract virtual bool SkipTo(int target);
    public abstract virtual int Doc();
    public abstract virtual int Start();
    public abstract virtual int End();
    public abstract virtual ICollection`1<Byte[]> GetPayload();
    public abstract virtual bool IsPayloadAvailable();
}
public class Lucene.Net.Search.Spans.SpanScorer : Scorer {
    protected internal Spans spans;
    protected internal Weight weight;
    protected internal Byte[] norms;
    protected internal float value_Renamed;
    protected internal bool more;
    protected internal int doc;
    protected internal float freq;
    protected internal SpanScorer(Spans spans, Weight weight, Similarity similarity, Byte[] norms);
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual bool SetFreqCurrentDoc();
    public virtual int DocID();
    public virtual float Score();
    protected internal virtual Explanation Explain(int doc);
}
public class Lucene.Net.Search.Spans.SpanTermQuery : SpanQuery {
    protected internal Term internalTerm;
    public Term Term { get; }
    public string Field { get; }
    public SpanTermQuery(Term term);
    public virtual Term get_Term();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Spans GetSpans(IndexReader reader);
}
public class Lucene.Net.Search.Spans.SpanWeight : Weight {
    protected internal Similarity similarity;
    protected internal float value_Renamed;
    protected internal float idf;
    protected internal float queryNorm;
    protected internal float queryWeight;
    protected internal ISet`1<Term> terms;
    protected internal SpanQuery internalQuery;
    private IDFExplanation idfExp;
    public Query Query { get; }
    public float Value { get; }
    public SpanWeight(SpanQuery query, Searcher searcher);
    public virtual Query get_Query();
    public virtual float get_Value();
    public virtual float GetSumOfSquaredWeights();
    public virtual void Normalize(float queryNorm);
    public virtual Scorer Scorer(IndexReader reader, bool scoreDocsInOrder, bool topScorer);
    public virtual Explanation Explain(IndexReader reader, int doc);
}
public class Lucene.Net.Search.Spans.TermSpans : Spans {
    protected internal TermPositions internalPositions;
    protected internal Term term;
    protected internal int internalDoc;
    protected internal int freq;
    protected internal int count;
    protected internal int position;
    public TermPositions Positions { get; }
    public TermSpans(TermPositions positions, Term term);
    public virtual bool Next();
    public virtual bool SkipTo(int target);
    public virtual int Doc();
    public virtual int Start();
    public virtual int End();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool IsPayloadAvailable();
    public virtual string ToString();
    public virtual TermPositions get_Positions();
}
public class Lucene.Net.Search.StringIndex : object {
    public String[] lookup;
    public Int32[] order;
    public StringIndex(Int32[] values, String[] lookup);
    public virtual int BinarySearchLookup(string key);
}
public class Lucene.Net.Search.TermQuery : Query {
    private Term term;
    public Term Term { get; }
    public TermQuery(Term t);
    public virtual Term get_Term();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.TermRangeFilter : MultiTermQueryWrapperFilter`1<TermRangeQuery> {
    public string Field { get; }
    public string LowerTerm { get; }
    public string UpperTerm { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public CompareInfo Collator { get; }
    public TermRangeFilter(string fieldName, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper);
    public TermRangeFilter(string fieldName, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper, CompareInfo collator);
    public static TermRangeFilter Less(string fieldName, string upperTerm);
    public static TermRangeFilter More(string fieldName, string lowerTerm);
    public virtual string get_Field();
    public virtual string get_LowerTerm();
    public virtual string get_UpperTerm();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
    public virtual CompareInfo get_Collator();
}
public class Lucene.Net.Search.TermRangeQuery : MultiTermQuery {
    private string lowerTerm;
    private string upperTerm;
    private CompareInfo collator;
    private string field;
    private bool includeLower;
    private bool includeUpper;
    public string Field { get; }
    public string LowerTerm { get; }
    public string UpperTerm { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public CompareInfo Collator { get; }
    public TermRangeQuery(string field, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper);
    public TermRangeQuery(string field, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper, CompareInfo collator);
    public virtual string get_Field();
    public virtual string get_LowerTerm();
    public virtual string get_UpperTerm();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
    public virtual CompareInfo get_Collator();
    protected internal virtual FilteredTermEnum GetEnum(IndexReader reader);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.TermRangeTermEnum : FilteredTermEnum {
    private CompareInfo collator;
    private bool endEnum;
    private string field;
    private string upperTermText;
    private string lowerTermText;
    private bool includeLower;
    private bool includeUpper;
    public TermRangeTermEnum(IndexReader reader, string field, string lowerTermText, string upperTermText, bool includeLower, bool includeUpper, CompareInfo collator);
    public virtual float Difference();
    public virtual bool EndEnum();
    protected internal virtual bool TermCompare(Term term);
}
public class Lucene.Net.Search.TermScorer : Scorer {
    private static Single[] SIM_NORM_DECODER;
    private Weight weight;
    private TermDocs termDocs;
    private Byte[] norms;
    private float weightValue;
    private int doc;
    private Int32[] docs;
    private Int32[] freqs;
    private int pointer;
    private int pointerMax;
    private static int SCORE_CACHE_SIZE;
    private Single[] scoreCache;
    public TermScorer(Weight weight, TermDocs td, Similarity similarity, Byte[] norms);
    private static TermScorer();
    public virtual void Score(Collector c);
    public virtual bool Score(Collector c, int end, int firstDocID);
    public virtual int DocID();
    public virtual int NextDoc();
    public virtual float Score();
    public virtual int Advance(int target);
    public virtual string ToString();
}
public class Lucene.Net.Search.TimeLimitingCollector : Collector {
    public static int DEFAULT_RESOLUTION;
    public bool DEFAULT_GREEDY;
    private static UInt32 resolution;
    private bool greedy;
    private static TimerThread TIMER_THREAD;
    private long t0;
    private long timeout;
    private Collector collector;
    private int docBase;
    public static long Resolution { get; public set; }
    public bool IsGreedy { get; public set; }
    public bool AcceptsDocsOutOfOrder { get; }
    public TimeLimitingCollector(Collector collector, long timeAllowed);
    private static TimeLimitingCollector();
    private void InitBlock();
    public static long get_Resolution();
    public static void set_Resolution(long value);
    public virtual bool get_IsGreedy();
    public virtual void set_IsGreedy(bool value);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(IndexReader reader, int base_Renamed);
    public virtual void SetScorer(Scorer scorer);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.TopDocs : object {
    private int _totalHits;
    private ScoreDoc[] _scoreDocs;
    private float _maxScore;
    public int TotalHits { get; public set; }
    public ScoreDoc[] ScoreDocs { get; public set; }
    public float MaxScore { get; public set; }
    internal TopDocs(int totalHits, ScoreDoc[] scoreDocs);
    public TopDocs(int totalHits, ScoreDoc[] scoreDocs, float maxScore);
    public int get_TotalHits();
    public void set_TotalHits(int value);
    public ScoreDoc[] get_ScoreDocs();
    public void set_ScoreDocs(ScoreDoc[] value);
    public float get_MaxScore();
    public void set_MaxScore(float value);
}
public abstract class Lucene.Net.Search.TopDocsCollector`1 : Collector {
    protected internal static TopDocs EMPTY_TOPDOCS;
    protected internal PriorityQueue`1<T> pq;
    protected internal int internalTotalHits;
    public int TotalHits { get; }
    protected internal TopDocsCollector`1(PriorityQueue`1<T> pq);
    private static TopDocsCollector`1();
    protected internal virtual void PopulateResults(ScoreDoc[] results, int howMany);
    public virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual int get_TotalHits();
    public TopDocs TopDocs();
    public TopDocs TopDocs(int start);
    public TopDocs TopDocs(int start, int howMany);
}
public abstract class Lucene.Net.Search.TopFieldCollector : TopDocsCollector`1<Entry> {
    private static ScoreDoc[] EMPTY_SCOREDOCS;
    private bool fillFields;
    internal float maxScore;
    internal int numHits;
    internal Entry bottom;
    internal bool queueFull;
    internal int docBase;
    public bool AcceptsDocsOutOfOrder { get; }
    private TopFieldCollector(PriorityQueue`1<Entry> pq, int numHits, bool fillFields);
    private static TopFieldCollector();
    public static TopFieldCollector Create(Sort sort, int numHits, bool fillFields, bool trackDocScores, bool trackMaxScore, bool docsScoredInOrder);
    internal void Add(int slot, int doc, float score);
    protected internal virtual void PopulateResults(ScoreDoc[] results, int howMany);
    public virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.TopFieldDocs : TopDocs {
    public SortField[] fields;
    public TopFieldDocs(int totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore);
}
public abstract class Lucene.Net.Search.TopScoreDocCollector : TopDocsCollector`1<ScoreDoc> {
    internal ScoreDoc pqTop;
    internal int docBase;
    internal Scorer scorer;
    private TopScoreDocCollector(int numHits);
    public static TopScoreDocCollector Create(int numHits, bool docsScoredInOrder);
    public virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual void SetNextReader(IndexReader reader, int base_Renamed);
    public virtual void SetScorer(Scorer scorer);
}
public abstract class Lucene.Net.Search.Weight : object {
    public Query Query { get; }
    public float Value { get; }
    public abstract virtual Explanation Explain(IndexReader reader, int doc);
    public abstract virtual Query get_Query();
    public abstract virtual float get_Value();
    public abstract virtual void Normalize(float norm);
    public abstract virtual Scorer Scorer(IndexReader reader, bool scoreDocsInOrder, bool topScorer);
    public abstract virtual float GetSumOfSquaredWeights();
    public virtual bool GetScoresDocsOutOfOrder();
}
public class Lucene.Net.Search.WildcardQuery : MultiTermQuery {
    private bool _termContainsWildcard;
    private bool _termIsPrefix;
    protected internal Term internalTerm;
    public Term Term { get; }
    public WildcardQuery(Term term);
    protected internal virtual FilteredTermEnum GetEnum(IndexReader reader);
    public Term get_Term();
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.WildcardTermEnum : FilteredTermEnum {
    internal Term searchTerm;
    internal string field;
    internal string text;
    internal string pre;
    internal int preLen;
    internal bool endEnum;
    public static char WILDCARD_STRING;
    public static char WILDCARD_CHAR;
    public WildcardTermEnum(IndexReader reader, Term term);
    protected internal virtual bool TermCompare(Term term);
    public virtual float Difference();
    public virtual bool EndEnum();
    public static bool WildcardEquals(string pattern, int patternIdx, string string_Renamed, int stringIdx);
}
public class Lucene.Net.Store.AlreadyClosedException : SystemException {
    public AlreadyClosedException(string message);
    public AlreadyClosedException(string message, Exception inner);
    protected AlreadyClosedException(SerializationInfo info, StreamingContext context);
}
public abstract class Lucene.Net.Store.BufferedIndexInput : IndexInput {
    public static int BUFFER_SIZE;
    private int _bufferSize;
    protected internal Byte[] buffer;
    private long bufferStart;
    private int bufferLength;
    private int bufferPosition;
    public int BufferSize { get; }
    public long FilePointer { get; }
    protected BufferedIndexInput(int bufferSize);
    public virtual byte ReadByte();
    public virtual void SetBufferSize(int newSize);
    protected internal virtual void NewBuffer(Byte[] newBuffer);
    public virtual int get_BufferSize();
    private void CheckBufferSize(int bufferSize);
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual void ReadBytes(Byte[] b, int offset, int len, bool useBuffer);
    private void Refill();
    public abstract virtual void ReadInternal(Byte[] b, int offset, int length);
    public virtual long get_FilePointer();
    public virtual void Seek(long pos);
    public abstract virtual void SeekInternal(long pos);
    public virtual object Clone();
}
public abstract class Lucene.Net.Store.BufferedIndexOutput : IndexOutput {
    internal static int BUFFER_SIZE;
    private Byte[] buffer;
    private long bufferStart;
    private int bufferPosition;
    private bool isDisposed;
    public long FilePointer { get; }
    public long Length { get; }
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
    public virtual void Flush();
    private void FlushBuffer(Byte[] b, int len);
    public abstract virtual void FlushBuffer(Byte[] b, int offset, int len);
    protected virtual void Dispose(bool disposing);
    public virtual long get_FilePointer();
    public virtual void Seek(long pos);
    public abstract virtual long get_Length();
}
public class Lucene.Net.Store.ChecksumIndexInput : IndexInput {
    internal IndexInput main;
    internal IChecksum digest;
    private bool isDisposed;
    public long Checksum { get; }
    public long FilePointer { get; }
    public ChecksumIndexInput(IndexInput main);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual long get_Checksum();
    protected virtual void Dispose(bool disposing);
    public virtual long get_FilePointer();
    public virtual void Seek(long pos);
    public virtual long Length();
}
public class Lucene.Net.Store.ChecksumIndexOutput : IndexOutput {
    internal IndexOutput main;
    internal IChecksum digest;
    private bool isDisposed;
    public long Checksum { get; }
    public long FilePointer { get; }
    public long Length { get; }
    public ChecksumIndexOutput(IndexOutput main);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
    public virtual long get_Checksum();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long get_FilePointer();
    public virtual void Seek(long pos);
    public virtual void PrepareCommit();
    public virtual void FinishCommit();
    public virtual long get_Length();
}
public abstract class Lucene.Net.Store.Directory : object {
    protected internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isOpen;
    protected internal LockFactory interalLockFactory;
    public LockFactory LockFactory { get; }
    public bool isOpen_ForNUnit { get; }
    public abstract virtual String[] ListAll();
    public abstract virtual bool FileExists(string name);
    public abstract virtual long FileModified(string name);
    public abstract virtual void TouchFile(string name);
    public abstract virtual void DeleteFile(string name);
    public abstract virtual long FileLength(string name);
    public abstract virtual IndexOutput CreateOutput(string name);
    public virtual void Sync(string name);
    public abstract virtual IndexInput OpenInput(string name);
    public virtual IndexInput OpenInput(string name, int bufferSize);
    public virtual Lock MakeLock(string name);
    public virtual void ClearLock(string name);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual void SetLockFactory(LockFactory lockFactory);
    public virtual LockFactory get_LockFactory();
    public virtual string GetLockId();
    public virtual string ToString();
    public static void Copy(Directory src, Directory dest, bool closeDirSrc);
    public void EnsureOpen();
    public bool get_isOpen_ForNUnit();
}
public class Lucene.Net.Store.FileSwitchDirectory : Directory {
    private Directory secondaryDir;
    private Directory primaryDir;
    private HashSet`1<string> primaryExtensions;
    private bool doClose;
    private bool isDisposed;
    public Directory PrimaryDir { get; }
    public Directory SecondaryDir { get; }
    public FileSwitchDirectory(HashSet`1<string> primaryExtensions, Directory primaryDir, Directory secondaryDir, bool doClose);
    public virtual Directory get_PrimaryDir();
    public virtual Directory get_SecondaryDir();
    protected virtual void Dispose(bool disposing);
    public virtual String[] ListAll();
    public static string GetExtension(string name);
    private Directory GetDirectory(string name);
    public virtual bool FileExists(string name);
    public virtual long FileModified(string name);
    public virtual void TouchFile(string name);
    public virtual void DeleteFile(string name);
    public virtual long FileLength(string name);
    public virtual IndexOutput CreateOutput(string name);
    public virtual void Sync(string name);
    public virtual IndexInput OpenInput(string name);
}
public abstract class Lucene.Net.Store.FSDirectory : Directory {
    private static HashAlgorithm DIGESTER;
    private bool checked_Renamed;
    protected internal DirectoryInfo internalDirectory;
    private static Char[] HEX_DIGITS;
    public static int DEFAULT_READ_CHUNK_SIZE;
    private int chunkSize;
    public DirectoryInfo Directory { get; }
    public int ReadChunkSize { get; public set; }
    private static FSDirectory();
    protected internal FSDirectory(DirectoryInfo path, LockFactory lockFactory);
    internal void CreateDir();
    protected internal void InitOutput(string name);
    public static FSDirectory Open(string path);
    public static FSDirectory Open(DirectoryInfo path);
    public static FSDirectory Open(DirectoryInfo path, LockFactory lockFactory);
    public static String[] ListAll(DirectoryInfo dir);
    public virtual String[] ListAll();
    public virtual bool FileExists(string name);
    public virtual long FileModified(string name);
    public static long FileModified(FileInfo directory, string name);
    public virtual void TouchFile(string name);
    public virtual long FileLength(string name);
    public virtual void DeleteFile(string name);
    public virtual void Sync(string name);
    public virtual IndexInput OpenInput(string name);
    public virtual string GetLockId();
    protected virtual void Dispose(bool disposing);
    public virtual DirectoryInfo get_Directory();
    public virtual string ToString();
    public int get_ReadChunkSize();
    public void set_ReadChunkSize(int value);
}
public abstract class Lucene.Net.Store.FSLockFactory : LockFactory {
    protected internal DirectoryInfo internalLockDir;
    public DirectoryInfo LockDir { get; protected internal set; }
    public virtual DirectoryInfo get_LockDir();
    protected internal virtual void set_LockDir(DirectoryInfo value);
}
public abstract class Lucene.Net.Store.IndexInput : object {
    private bool preUTF8Strings;
    public long FilePointer { get; }
    public abstract virtual byte ReadByte();
    public abstract virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual void ReadBytes(Byte[] b, int offset, int len, bool useBuffer);
    public virtual int ReadInt();
    public virtual int ReadVInt();
    public virtual long ReadLong();
    public virtual long ReadVLong();
    public virtual void SetModifiedUTF8StringsMode();
    public virtual string ReadString();
    private string ReadModifiedUTF8String();
    [ObsoleteAttribute("-- please use ReadString or ReadBytes instead, and construct the string from those utf8 bytes")]
public virtual void ReadChars(Char[] buffer, int start, int length);
    [ObsoleteAttribute("this method operates on old "modified utf8" encoded strings")]
public virtual void SkipChars(int length);
    [ObsoleteAttribute("Use Dispose() instead.")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long get_FilePointer();
    public abstract virtual void Seek(long pos);
    public abstract virtual long Length();
    public virtual object Clone();
    public virtual IDictionary`2<string, string> ReadStringStringMap();
}
public abstract class Lucene.Net.Store.IndexOutput : object {
    private static int COPY_BUFFER_SIZE;
    private Byte[] copyBuffer;
    public long FilePointer { get; }
    public long Length { get; }
    private static IndexOutput();
    public abstract virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int length);
    public abstract virtual void WriteBytes(Byte[] b, int offset, int length);
    public virtual void WriteInt(int i);
    public virtual void WriteVInt(int i);
    public virtual void WriteLong(long i);
    public virtual void WriteVLong(long i);
    public virtual void WriteString(string s);
    [ObsoleteAttribute("-- please pre-convert to utf8 bytes instead or use WriteString")]
public virtual void WriteChars(string s, int start, int length);
    [ObsoleteAttribute("-- please pre-convert to utf8 bytes instead or use WriteString")]
public virtual void WriteChars(Char[] s, int start, int length);
    public virtual void CopyBytes(IndexInput input, long numBytes);
    public abstract virtual void Flush();
    [ObsoleteAttribute("Use Dispose() instead.")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long get_FilePointer();
    public abstract virtual void Seek(long pos);
    public abstract virtual long get_Length();
    public virtual void SetLength(long length);
    public virtual void WriteStringStringMap(IDictionary`2<string, string> map);
}
public abstract class Lucene.Net.Store.Lock : object {
    public static long LOCK_POLL_INTERVAL;
    public static long LOCK_OBTAIN_WAIT_FOREVER;
    protected internal Exception failureReason;
    private static Lock();
    public abstract virtual bool Obtain();
    public virtual bool Obtain(long lockWaitTimeout);
    public abstract virtual void Release();
    public abstract virtual bool IsLocked();
}
public abstract class Lucene.Net.Store.LockFactory : object {
    protected internal string internalLockPrefix;
    public string LockPrefix { get; public set; }
    public virtual string get_LockPrefix();
    public virtual void set_LockPrefix(string value);
    public abstract virtual Lock MakeLock(string lockName);
    public abstract virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.LockObtainFailedException : IOException {
    public LockObtainFailedException(string message);
    public LockObtainFailedException(string message, Exception ex);
}
public class Lucene.Net.Store.LockReleaseFailedException : IOException {
    public LockReleaseFailedException(string message);
}
public class Lucene.Net.Store.LockStressTest : object {
    [STAThreadAttribute]
public static void Main(String[] args);
}
public class Lucene.Net.Store.LockVerifyServer : object {
    private static string GetTime(long startTime);
    [STAThreadAttribute]
public static void Main(String[] args);
}
public class Lucene.Net.Store.MMapDirectory : FSDirectory {
    private bool useUnmapHack;
    private int maxBBuf;
    public static bool UNMAP_SUPPORTED;
    public bool UseUnmap { get; public set; }
    public int MaxChunkSize { get; public set; }
    public MMapDirectory(DirectoryInfo path, LockFactory lockFactory);
    public MMapDirectory(DirectoryInfo path);
    private static MMapDirectory();
    private void InitBlock();
    public virtual bool get_UseUnmap();
    public virtual void set_UseUnmap(bool value);
    internal void CleanMapping(MemoryStream buffer);
    public virtual int get_MaxChunkSize();
    public virtual void set_MaxChunkSize(int value);
    public virtual IndexInput OpenInput(string name, int bufferSize);
    public virtual IndexOutput CreateOutput(string name);
}
internal class Lucene.Net.Store.NativeFSLock : Lock {
    private FileStream f;
    private FileStream channel;
    private bool lock_Renamed;
    private FileInfo path;
    private DirectoryInfo lockDir;
    private static HashSet`1<string> LOCK_HELD;
    public NativeFSLock(DirectoryInfo lockDir, string lockFileName);
    private static NativeFSLock();
    private bool LockExists();
    public virtual bool Obtain();
    public virtual void Release();
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.NativeFSLockFactory : FSLockFactory {
    public NativeFSLockFactory(string lockDirName);
    public NativeFSLockFactory(DirectoryInfo lockDir);
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.NIOFSDirectory : FSDirectory {
    public NIOFSDirectory(DirectoryInfo dir, LockFactory lockFactory);
    public virtual IndexOutput CreateOutput(string name);
}
internal class Lucene.Net.Store.NoLock : Lock {
    public virtual bool Obtain();
    public virtual void Release();
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.NoLockFactory : LockFactory {
    private static NoLock singletonLock;
    private static NoLockFactory singleton;
    public static NoLockFactory Instance { get; }
    private static NoLockFactory();
    public static NoLockFactory get_Instance();
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.NoSuchDirectoryException : FileNotFoundException {
    public NoSuchDirectoryException(string message);
}
public class Lucene.Net.Store.RAMDirectory : Directory {
    private static long serialVersionUID;
    protected internal HashMap`2<string, RAMFile> fileMap;
    protected internal long internalSizeInBytes;
    public RAMDirectory(Directory dir);
    private RAMDirectory(Directory dir, bool closeDir);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    public virtual String[] ListAll();
    public virtual bool FileExists(string name);
    public virtual long FileModified(string name);
    public virtual void TouchFile(string name);
    public virtual long FileLength(string name);
    public long SizeInBytes();
    public virtual void DeleteFile(string name);
    public virtual IndexOutput CreateOutput(string name);
    public virtual IndexInput OpenInput(string name);
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Store.RAMFile : object {
    private static long serialVersionUID;
    protected List`1<Byte[]> buffers;
    internal long length;
    internal RAMDirectory directory;
    internal long sizeInBytes;
    private long lastModified;
    internal long Length { get; internal set; }
    internal long LastModified { get; internal set; }
    public long SizeInBytes { get; }
    public RAMFile(RAMDirectory directory);
    internal virtual long get_Length();
    internal virtual void set_Length(long value);
    internal virtual long get_LastModified();
    internal virtual void set_LastModified(long value);
    internal Byte[] AddBuffer(int size);
    public Byte[] GetBuffer(int index);
    public int NumBuffers();
    public virtual Byte[] NewBuffer(int size);
    public virtual long get_SizeInBytes();
}
public class Lucene.Net.Store.RAMInputStream : IndexInput {
    internal static int BUFFER_SIZE;
    private RAMFile file;
    private long length;
    private Byte[] currentBuffer;
    private int currentBufferIndex;
    private int bufferPosition;
    private long bufferStart;
    private int bufferLength;
    public long FilePointer { get; }
    public RAMInputStream(RAMFile f);
    private static RAMInputStream();
    protected virtual void Dispose(bool disposing);
    public virtual long Length();
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    private void SwitchCurrentBuffer(bool enforceEOF);
    public virtual long get_FilePointer();
    public virtual void Seek(long pos);
}
public class Lucene.Net.Store.RAMOutputStream : IndexOutput {
    internal static int BUFFER_SIZE;
    private RAMFile file;
    private Byte[] currentBuffer;
    private int currentBufferIndex;
    private bool isDisposed;
    private int bufferPosition;
    private long bufferStart;
    private int bufferLength;
    public long Length { get; }
    public long FilePointer { get; }
    internal RAMOutputStream(RAMFile f);
    public virtual void WriteTo(IndexOutput out_Renamed);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    public virtual void Seek(long pos);
    public virtual long get_Length();
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int len);
    private void SwitchCurrentBuffer();
    private void SetFileLength();
    public virtual void Flush();
    public virtual long get_FilePointer();
    public virtual long SizeInBytes();
}
public class Lucene.Net.Store.SimpleFSDirectory : FSDirectory {
    public SimpleFSDirectory(DirectoryInfo path, LockFactory lockFactory);
    public SimpleFSDirectory(DirectoryInfo path);
    public virtual IndexOutput CreateOutput(string name);
    public virtual IndexInput OpenInput(string name, int bufferSize);
}
internal class Lucene.Net.Store.SimpleFSLock : Lock {
    internal FileInfo lockFile;
    internal DirectoryInfo lockDir;
    [ObsoleteAttribute("Use the constructor that takes a DirectoryInfo, this will be removed in the 3.0 release")]
public SimpleFSLock(FileInfo lockDir, string lockFileName);
    public SimpleFSLock(DirectoryInfo lockDir, string lockFileName);
    public virtual bool Obtain();
    public virtual void Release();
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.SimpleFSLockFactory : FSLockFactory {
    public SimpleFSLockFactory(DirectoryInfo lockDir);
    public SimpleFSLockFactory(string lockDirName);
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
internal class Lucene.Net.Store.SingleInstanceLock : Lock {
    internal string lockName;
    private HashSet`1<string> locks;
    public SingleInstanceLock(HashSet`1<string> locks, string lockName);
    public virtual bool Obtain();
    public virtual void Release();
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.SingleInstanceLockFactory : LockFactory {
    private HashSet`1<string> locks;
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.VerifyingLockFactory : LockFactory {
    internal LockFactory lf;
    internal sbyte id;
    internal string host;
    internal int port;
    public VerifyingLockFactory(sbyte id, LockFactory lf, string host, int port);
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Support.AppSettings : object {
    private static ListDictionary settings;
    private static AppSettings();
    public static void Set(string key, int defValue);
    public static void Set(string key, long defValue);
    public static void Set(string key, string defValue);
    public static void Set(string key, bool defValue);
    public static int Get(string key, int defValue);
    public static long Get(string key, long defValue);
    public static string Get(string key, string defValue);
    public static bool Get(string key, bool defValue);
}
internal class Lucene.Net.Support.AttributeImplItem : object {
    internal Type Key;
    internal Attribute Value;
    internal AttributeImplItem(Type key, Attribute value);
}
public class Lucene.Net.Support.BitSetSupport : object {
    public static int NextSetBit(BitArray bitArray, int index);
    public static int NextClearBit(BitArray bitArray, int index);
    public static int Cardinality(BitArray bits);
}
public class Lucene.Net.Support.BuildType : object {
    public static bool Debug;
}
public class Lucene.Net.Support.Character : object {
    private static char charNull;
    private static char charZero;
    private static char charA;
    public static int MAX_RADIX { get; }
    public static int MIN_RADIX { get; }
    public static int get_MAX_RADIX();
    public static int get_MIN_RADIX();
    public static char ForDigit(int digit, int radix);
}
public class Lucene.Net.Support.CloseableThreadLocalProfiler : object {
    private static bool _enableCloseableThreadLocalProfiler;
    public static List`1<WeakReference> Instances;
    public static bool EnableCloseableThreadLocalProfiler { get; public set; }
    private static CloseableThreadLocalProfiler();
    public static bool get_EnableCloseableThreadLocalProfiler();
    public static void set_EnableCloseableThreadLocalProfiler(bool value);
}
public class Lucene.Net.Support.CollectionsHelper : object {
    public static void Add(Hashtable hashtable, object item);
    public static void AddIfNotContains(Hashtable hashtable, object item);
    public static void AddIfNotContains(ArrayList hashtable, object item);
    public static void AddAll(Hashtable hashtable, ICollection items);
    public static void AddAllIfNotContains(Hashtable hashtable, IList items);
    public static void AddAllIfNotContains(Hashtable hashtable, ICollection items);
    public static void AddAllIfNotContains(IDictionary`2<string, string> hashtable, ICollection`1<string> items);
    public static void AddAll(IDictionary`2<string, string> hashtable, ICollection`1<string> items);
    public static bool Contains(ICollection`1<string> col, string item);
    public static bool Contains(ICollection col, object item);
    public static string CollectionToString(IDictionary`2<string, string> c);
    public static string CollectionToString(ICollection c);
    public static bool CompareStringArrays(String[] l1, String[] l2);
    public static void Sort(IList list, IComparer Comparator);
    public static void Fill(Array array, int fromindex, int toindex, object val);
    public static void Fill(Array array, object val);
    public static bool Equals(Array array1, Array array2);
}
public class Lucene.Net.Support.Compare : object {
    public static bool CompareTermArrays(Term[] t1, Term[] t2);
}
public static class Lucene.Net.Support.Compatibility.SetFactory : object {
    public static ISet`1<T> CreateHashSet();
    public static ISet`1<T> CreateHashSet(IEnumerable`1<T> other);
}
public class Lucene.Net.Support.CRC32 : object {
    private static UInt32[] crcTable;
    private UInt32 crc;
    public long Value { get; }
    private static CRC32();
    private static UInt32[] InitializeCRCTable();
    public sealed virtual long get_Value();
    public sealed virtual void Reset();
    public sealed virtual void Update(int bval);
    public sealed virtual void Update(Byte[] buf, int off, int len);
    public sealed virtual void Update(Byte[] buf);
}
public static class Lucene.Net.Support.Cryptography : object {
    public static bool FIPSCompliant;
    public static HashAlgorithm HashAlgorithm { get; }
    public static HashAlgorithm get_HashAlgorithm();
}
public class Lucene.Net.Support.Deflater : object {
    private SetLevelDelegate setLevelMethod;
    private SetInputDelegate setInputMethod;
    private FinishDelegate finishMethod;
    private GetIsFinishedDelegate getIsFinishedMethod;
    private DeflateDelegate deflateMethod;
    public static int BEST_COMPRESSION;
    public bool IsFinished { get; }
    internal Deflater(object deflaterInstance);
    public void SetLevel(int level);
    public void SetInput(Byte[] input, int offset, int count);
    public void Finish();
    public bool get_IsFinished();
    public int Deflate(Byte[] output);
}
public class Lucene.Net.Support.Double : object {
    public static double Parse(string s);
}
public class Lucene.Net.Support.EquatableList`1 : List`1<T> {
    public EquatableList`1(IEnumerable`1<T> collection);
    public EquatableList`1(int capacity);
    public void AddRange(ICollection c);
    private static Nullable`1<bool> EnumerableCountsEqual(IEnumerable`1<T> x, IEnumerable`1<T> y);
    private static bool Equals(IEnumerable`1<T> x, IEnumerable`1<T> y);
    public sealed virtual bool Equals(IEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static int GetHashCode(IEnumerable`1<T> source);
    public sealed virtual object Clone();
}
public class Lucene.Net.Support.FileSupport : object {
    public static FileInfo[] GetFiles(FileInfo path);
    public static FileInfo[] GetFiles(DirectoryInfo path);
    public static String[] GetLuceneIndexFiles(string fullName, IndexFileNameFilter indexFileNameFilter);
    public static void Sync(FileStream fileStream);
}
internal class Lucene.Net.Support.GeneralKeyedCollection`2 : KeyedCollection`2<TKey, TItem> {
    private Converter`2<TItem, TKey> converter;
    internal GeneralKeyedCollection`2(Converter`2<TItem, TKey> converter);
    protected virtual TKey GetKeyForItem(TItem item);
    public bool ContainsKey(TKey key);
    public IList`1<TItem> Values();
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Support.HashMap`2 : object {
    internal IEqualityComparer`1<TKey> _comparer;
    internal Dictionary`2<TKey, TValue> _dict;
    private bool _hasNullValue;
    private TValue _nullValue;
    private bool _isValueType;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public HashMap`2(IEqualityComparer`1<TKey> comparer);
    public HashMap`2(int initialCapacity);
    public HashMap`2(int initialCapacity, IEqualityComparer`1<TKey> comparer);
    public HashMap`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> other);
    public bool ContainsValue(TValue value);
    [IteratorStateMachineAttribute("Lucene.Net.Support.HashMap`2/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
public interface Lucene.Net.Support.IChecksum {
    public long Value { get; }
    public abstract virtual void Reset();
    public abstract virtual void Update(int b);
    public abstract virtual void Update(Byte[] b);
    public abstract virtual void Update(Byte[] b, int offset, int length);
    public abstract virtual long get_Value();
}
public class Lucene.Net.Support.Inflater : object {
    private SetInputDelegate setInputMethod;
    private GetIsFinishedDelegate getIsFinishedMethod;
    private InflateDelegate inflateMethod;
    public bool IsFinished { get; }
    internal Inflater(object inflaterInstance);
    public void SetInput(Byte[] buffer);
    public bool get_IsFinished();
    public int Inflate(Byte[] buffer);
}
public interface Lucene.Net.Support.IThreadRunnable {
    public abstract virtual void Run();
}
public class Lucene.Net.Support.Number : object {
    public static int MIN_RADIX;
    public static int MAX_RADIX;
    private static string digits;
    public static string ToString(long number);
    public static string ToString(float f);
    public static string ToString(long i, int radix);
    public static long Parse(string s, int radix);
    public static int URShift(int number, int bits);
    public static long URShift(long number, int bits);
    public static int NextSetBit(BitArray bits, int fromIndex);
    public static long ToInt64(string s);
}
public class Lucene.Net.Support.OS : object {
    private static bool isUnix;
    private static bool isWindows;
    public static bool IsUnix { get; }
    public static bool IsWindows { get; }
    private static OS();
    public static bool get_IsUnix();
    public static bool get_IsWindows();
}
public class Lucene.Net.Support.SharpZipLib : object {
    private static Assembly asm;
    private static SharpZipLib();
    public static Deflater CreateDeflater();
    public static Inflater CreateInflater();
}
public class Lucene.Net.Support.Single : object {
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s);
    public static bool TryParse(string s, Single& f);
    public static string ToString(float f);
    public static string ToString(float f, string format);
    public static int FloatToIntBits(float value);
    public static float IntBitsToFloat(int value);
}
public class Lucene.Net.Support.TextSupport : object {
    public static void GetCharsFromString(string sourceString, int sourceStart, int sourceEnd, Char[] destinationArray, int destinationStart);
}
public class Lucene.Net.Support.ThreadClass : object {
    private Thread threadField;
    [ThreadStaticAttribute]
private static ThreadClass This;
    public Thread Instance { get; public set; }
    public string Name { get; public set; }
    public ThreadPriority Priority { get; public set; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public ThreadClass(string Name);
    public ThreadClass(ThreadStart Start);
    public ThreadClass(ThreadStart Start, string Name);
    public virtual void Run();
    public virtual void Start();
    public virtual void Interrupt();
    public Thread get_Instance();
    public void set_Instance(Thread value);
    public string get_Name();
    public void set_Name(string value);
    public void SetDaemon(bool isDaemon);
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    public void Join();
    public void Join(long MiliSeconds);
    public void Join(long MiliSeconds, int NanoSeconds);
    public void Resume();
    public void Abort();
    public void Abort(object stateInfo);
    public void Suspend();
    public virtual string ToString();
    public static ThreadClass CurrentThread();
    public static void Sleep(long ms);
    public static ThreadClass Current();
    public static bool op_Equality(ThreadClass t1, object t2);
    public static bool op_Inequality(ThreadClass t1, object t2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Support.ThreadLock : object {
    private static ThreadLock _nullLock;
    private static ThreadLock _monitorLock;
    public static ThreadLock NullLock { get; }
    public static ThreadLock MonitorLock { get; }
    private static ThreadLock();
    public abstract virtual void Enter(object obj);
    public abstract virtual void Exit(object obj);
    public static ThreadLock get_NullLock();
    public static ThreadLock get_MonitorLock();
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Support.WeakDictionary`2 : object {
    private HashMap`2<WeakKey`1<TKey, TValue, TKey>, TValue> _hm;
    private int _gcCollections;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public WeakDictionary`2(int initialCapacity);
    public WeakDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> otherDictionary);
    private WeakDictionary`2(int initialCapacity, IEnumerable`1<KeyValuePair`2<TKey, TValue>> otherDict);
    private void Clean();
    private void CleanIfNeeded();
    [IteratorStateMachineAttribute("Lucene.Net.Support.WeakDictionary`2/<GetEnumerator>d__8")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
}
public class Lucene.Net.Util.ArrayUtil : object {
    public static int ParseInt(Char[] chars);
    public static int ParseInt(Char[] chars, int offset, int len);
    public static int ParseInt(Char[] chars, int offset, int len, int radix);
    private static int Parse(Char[] chars, int offset, int len, int radix, bool negative);
    public static int GetNextSize(int targetSize);
    public static int GetShrinkSize(int currentSize, int targetSize);
    public static Int32[] Grow(Int32[] array, int minSize);
    public static Int32[] Grow(Int32[] array);
    public static Int32[] Shrink(Int32[] array, int targetSize);
    public static Int64[] Grow(Int64[] array, int minSize);
    public static Int64[] Grow(Int64[] array);
    public static Int64[] Shrink(Int64[] array, int targetSize);
    public static Byte[] Grow(Byte[] array, int minSize);
    public static Byte[] Grow(Byte[] array);
    public static Byte[] Shrink(Byte[] array, int targetSize);
    public static int HashCode(Char[] array, int start, int end);
    public static int HashCode(Byte[] array, int start, int end);
}
public abstract class Lucene.Net.Util.Attribute : object {
    public abstract virtual void Clear();
    public virtual string ToString();
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object other);
    public abstract virtual void CopyTo(Attribute target);
    public virtual object Clone();
}
public class Lucene.Net.Util.AttributeSource : object {
    private GeneralKeyedCollection`2<Type, AttributeImplItem> attributes;
    private GeneralKeyedCollection`2<Type, AttributeImplItem> attributeImpls;
    private State[] currentState;
    private AttributeFactory factory;
    private static WeakDictionary`2<Type, LinkedList`1<WeakReference>> knownImplClasses;
    public AttributeFactory Factory { get; }
    public bool HasAttributes { get; }
    public AttributeSource(AttributeSource input);
    public AttributeSource(AttributeFactory factory);
    private static AttributeSource();
    public virtual AttributeFactory get_Factory();
    public virtual IEnumerable`1<Type> GetAttributeTypesIterator();
    [IteratorStateMachineAttribute("Lucene.Net.Util.AttributeSource/<GetAttributeImplsIterator>d__11")]
public virtual IEnumerable`1<Attribute> GetAttributeImplsIterator();
    public virtual void AddAttributeImpl(Attribute att);
    public virtual T AddAttribute();
    public virtual bool get_HasAttributes();
    public virtual bool HasAttribute();
    public virtual T GetAttribute();
    private State GetCurrentState();
    public virtual void ClearAttributes();
    public virtual State CaptureState();
    public virtual void RestoreState(State state);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual AttributeSource CloneAttributes();
}
public class Lucene.Net.Util.AverageGuessMemoryModel : MemoryModel {
    private Dictionary`2<Type, int> sizes;
    public int ArraySize { get; }
    public int ClassSize { get; }
    public int ReferenceSize { get; }
    private void InitBlock();
    public virtual int get_ArraySize();
    public virtual int get_ClassSize();
    public virtual int GetPrimitiveSize(Type clazz);
    public virtual int get_ReferenceSize();
}
public class Lucene.Net.Util.BitUtil : object {
    public static Byte[] ntzTable;
    private static BitUtil();
    public static int Pop(long x);
    public static long Pop_array(Int64[] A, int wordOffset, int numWords);
    public static long Pop_intersect(Int64[] A, Int64[] B, int wordOffset, int numWords);
    public static long Pop_union(Int64[] A, Int64[] B, int wordOffset, int numWords);
    public static long Pop_andnot(Int64[] A, Int64[] B, int wordOffset, int numWords);
    public static long Pop_xor(Int64[] A, Int64[] B, int wordOffset, int numWords);
    public static int Ntz(long val);
    public static int Ntz(int val);
    public static int Ntz2(long x);
    public static int Ntz3(long x);
    public static bool IsPowerOfTwo(int v);
    public static bool IsPowerOfTwo(long v);
    public static int NextHighestPowerOfTwo(int v);
    public static long NextHighestPowerOfTwo(long v);
}
public class Lucene.Net.Util.BitVector : object {
    private Byte[] bits;
    private int size;
    private int count;
    private static Byte[] BYTE_COUNTS;
    public BitVector(int n);
    internal BitVector(Byte[] bits, int size);
    public BitVector(Directory d, string name);
    private static BitVector();
    public sealed virtual object Clone();
    public void Set(int bit);
    public bool GetAndSet(int bit);
    public void Clear(int bit);
    public bool Get(int bit);
    public int Size();
    public int Count();
    public int GetRecomputedCount();
    public void Write(Directory d, string name);
    private void WriteBits(IndexOutput output);
    private void WriteDgaps(IndexOutput output);
    private bool IsSparse();
    private void ReadBits(IndexInput input);
    private void ReadDgaps(IndexInput input);
    public BitVector Subset(int start, int end);
}
public abstract class Lucene.Net.Util.Cache.Cache`2 : object {
    public static Cache`2<TKey, TValue> SynchronizedCache(Cache`2<TKey, TValue> cache);
    internal virtual Cache`2<TKey, TValue> GetSynchronizedCache();
    public abstract virtual void Put(TKey key, TValue value_Renamed);
    public abstract virtual TValue Get(object key);
    public abstract virtual bool ContainsKey(object key);
    [ObsoleteAttribute("Use Dispose() instead")]
public void Close();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public class Lucene.Net.Util.Cache.SimpleLRUCache`2 : SimpleMapCache`2<TKey, TValue> {
    private int capacity;
    private LinkedList`1<ListValueEntry`2<TKey, TValue, TKey, TValue>> list;
    private Dictionary`2<TKey, LinkedListNode`1<ListValueEntry`2<TKey, TValue, TKey, TValue>>> lookup;
    private LinkedListNode`1<ListValueEntry`2<TKey, TValue, TKey, TValue>> openNode;
    public SimpleLRUCache`2(int Capacity);
    public virtual void Put(TKey Key, TValue Value);
    public virtual TValue Get(object Key);
}
public class Lucene.Net.Util.Cache.SimpleMapCache`2 : Cache`2<TKey, TValue> {
    internal Dictionary`2<TKey, TValue> map;
    public SimpleMapCache`2(Dictionary`2<TKey, TValue> map);
    public virtual TValue Get(object key);
    public virtual void Put(TKey key, TValue value_Renamed);
    public virtual bool ContainsKey(object key);
    protected virtual void Dispose(bool disposing);
    public virtual HashSet`1<TKey> KeySet();
    internal virtual Cache`2<TKey, TValue> GetSynchronizedCache();
}
public class Lucene.Net.Util.CloseableThreadLocal`1 : object {
    private ThreadLocal`1<WeakReference> t;
    private IDictionary`2<Thread, T> hardRefs;
    private bool isDisposed;
    public virtual T InitialValue();
    public virtual T Get();
    public virtual void Set(T object);
    [ObsoleteAttribute("Use Dispose() instead")]
public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Lucene.Net.Util.CloseableThreadLocalExtensions : object {
    [ExtensionAttribute]
public static void Set(ThreadLocal`1<T> t, T val);
    [ExtensionAttribute]
public static T Get(ThreadLocal`1<T> t);
    [ExtensionAttribute]
public static void Remove(ThreadLocal`1<T> t);
    [ExtensionAttribute]
public static object Get(WeakReference w);
}
public class Lucene.Net.Util.Constants : object {
    public static string JAVA_VERSION;
    public static bool JAVA_1_1;
    public static bool JAVA_1_2;
    public static bool JAVA_1_3;
    public static string OS_NAME;
    public static bool LINUX;
    public static bool WINDOWS;
    public static bool SUN_OS;
    public static string OS_ARCH;
    public static string OS_VERSION;
    public static string JAVA_VENDOR;
    public static bool JRE_IS_64BIT;
    public static string LUCENE_MAIN_VERSION;
    public static string LUCENE_VERSION;
    private static Constants();
    private static string Ident(string s);
    private static string GetEnvironmentVariable(string variable, string defaultValueOnSecurityException);
}
public class Lucene.Net.Util.DocIdBitSet : DocIdSet {
    private BitArray bitSet;
    public bool IsCacheable { get; }
    public BitArray BitSet { get; }
    public DocIdBitSet(BitArray bitSet);
    public virtual DocIdSetIterator Iterator();
    public virtual bool get_IsCacheable();
    public virtual BitArray get_BitSet();
}
public class Lucene.Net.Util.FieldCacheSanityChecker : object {
    private RamUsageEstimator ramCalc;
    public void SetRamUsageEstimator(RamUsageEstimator r);
    public static Insanity[] CheckSanity(FieldCache cache);
    public static Insanity[] CheckSanity(CacheEntry[] cacheEntries);
    public Insanity[] Check(CacheEntry[] cacheEntries);
    private List`1<Insanity> CheckValueMismatch(MapOfSets`2<int, CacheEntry> valIdToItems, MapOfSets`2<ReaderField, int> readerFieldToValIds, HashSet`1<ReaderField> valMismatchKeys);
    private List`1<Insanity> CheckSubreaders(MapOfSets`2<int, CacheEntry> valIdToItems, MapOfSets`2<ReaderField, int> readerFieldToValIds);
    private IList GetAllDecendentReaderKeys(object seed);
}
public interface Lucene.Net.Util.IAttribute {
}
public class Lucene.Net.Util.IdentityDictionary`2 : Dictionary`2<TKey, TValue> {
    public IdentityDictionary`2(IDictionary`2<TKey, TValue> other);
    public IdentityDictionary`2(int capacity);
}
public class Lucene.Net.Util.IndexableBinaryStringTools : object {
    private static CodingCase[] CODING_CASES;
    private static IndexableBinaryStringTools();
    public static int GetEncodedLength(List`1<byte> original);
    public static int GetDecodedLength(List`1<char> encoded);
    public static void Encode(List`1<byte> input, List`1<char> output);
    public static void Decode(List`1<char> input, List`1<byte> output);
    public static List`1<byte> Decode(List`1<char> input);
    public static List`1<char> Encode(List`1<byte> input);
}
public class Lucene.Net.Util.MapOfSets`2 : object {
    private IDictionary`2<TKey, HashSet`1<TValue>> theMap;
    public IDictionary`2<TKey, HashSet`1<TValue>> Map { get; }
    public MapOfSets`2(IDictionary`2<TKey, HashSet`1<TValue>> m);
    public virtual IDictionary`2<TKey, HashSet`1<TValue>> get_Map();
    public virtual int Put(TKey key, TValue val);
    public virtual int PutAll(TKey key, IEnumerable`1<TValue> vals);
}
public abstract class Lucene.Net.Util.MemoryModel : object {
    public int ArraySize { get; }
    public int ClassSize { get; }
    public int ReferenceSize { get; }
    public abstract virtual int get_ArraySize();
    public abstract virtual int get_ClassSize();
    public abstract virtual int GetPrimitiveSize(Type clazz);
    public abstract virtual int get_ReferenceSize();
}
public class Lucene.Net.Util.NumericUtils : object {
    public static int PRECISION_STEP_DEFAULT;
    public static char SHIFT_START_LONG;
    public static int BUF_SIZE_LONG;
    public static char SHIFT_START_INT;
    public static int BUF_SIZE_INT;
    private static NumericUtils();
    public static int LongToPrefixCoded(long val, int shift, Char[] buffer);
    public static string LongToPrefixCoded(long val, int shift);
    public static string LongToPrefixCoded(long val);
    public static int IntToPrefixCoded(int val, int shift, Char[] buffer);
    public static string IntToPrefixCoded(int val, int shift);
    public static string IntToPrefixCoded(int val);
    public static long PrefixCodedToLong(string prefixCoded);
    public static int PrefixCodedToInt(string prefixCoded);
    public static long DoubleToSortableLong(double val);
    public static string DoubleToPrefixCoded(double val);
    public static double SortableLongToDouble(long val);
    public static double PrefixCodedToDouble(string val);
    public static int FloatToSortableInt(float val);
    public static string FloatToPrefixCoded(float val);
    public static float SortableIntToFloat(int val);
    public static float PrefixCodedToFloat(string val);
    public static void SplitLongRange(LongRangeBuilder builder, int precisionStep, long minBound, long maxBound);
    public static void SplitIntRange(IntRangeBuilder builder, int precisionStep, int minBound, int maxBound);
    private static void SplitRange(object builder, int valSize, int precisionStep, long minBound, long maxBound);
    private static void AddRange(object builder, int valSize, long minBound, long maxBound, int shift);
}
public class Lucene.Net.Util.OpenBitSet : DocIdSet {
    protected internal Int64[] internalbits;
    protected internal int wlen;
    public bool IsCacheable { get; }
    public Int64[] Bits { get; public set; }
    public int NumWords { get; public set; }
    public OpenBitSet(long numBits);
    public OpenBitSet(Int64[] bits, int numWords);
    public virtual DocIdSetIterator Iterator();
    public virtual bool get_IsCacheable();
    public virtual long Capacity();
    public virtual long Size();
    public virtual bool IsEmpty();
    public virtual void set_Bits(Int64[] value);
    public virtual Int64[] get_Bits();
    public virtual int get_NumWords();
    public virtual void set_NumWords(int value);
    public virtual bool Get(int index);
    public virtual bool FastGet(int index);
    public virtual bool Get(long index);
    public virtual bool FastGet(long index);
    public virtual int GetBit(int index);
    public virtual void Set(long index);
    public virtual void FastSet(int index);
    public virtual void FastSet(long index);
    public virtual void Set(long startIndex, long endIndex);
    protected internal virtual int ExpandingWordNum(long index);
    public virtual void FastClear(int index);
    public virtual void FastClear(long index);
    public virtual void Clear(long index);
    public virtual void Clear(int startIndex, int endIndex);
    public virtual void Clear(long startIndex, long endIndex);
    public virtual bool GetAndSet(int index);
    public virtual bool GetAndSet(long index);
    public virtual void FastFlip(int index);
    public virtual void FastFlip(long index);
    public virtual void Flip(long index);
    public virtual bool FlipAndGet(int index);
    public virtual bool FlipAndGet(long index);
    public virtual void Flip(long startIndex, long endIndex);
    public virtual long Cardinality();
    public static long IntersectionCount(OpenBitSet a, OpenBitSet b);
    public static long UnionCount(OpenBitSet a, OpenBitSet b);
    public static long AndNotCount(OpenBitSet a, OpenBitSet b);
    public static long XorCount(OpenBitSet a, OpenBitSet b);
    public virtual int NextSetBit(int index);
    public virtual long NextSetBit(long index);
    public virtual object Clone();
    public virtual void Intersect(OpenBitSet other);
    public virtual void Union(OpenBitSet other);
    public virtual void Remove(OpenBitSet other);
    public virtual void Xor(OpenBitSet other);
    public virtual void And(OpenBitSet other);
    public virtual void Or(OpenBitSet other);
    public virtual void AndNot(OpenBitSet other);
    public virtual bool Intersects(OpenBitSet other);
    public virtual void EnsureCapacityWords(int numWords);
    public virtual void EnsureCapacity(long numBits);
    public virtual void TrimTrailingZeros();
    public static int Bits2words(long numBits);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.OpenBitSetDISI : OpenBitSet {
    public OpenBitSetDISI(DocIdSetIterator disi, int maxSize);
    public OpenBitSetDISI(int maxSize);
    public virtual void InPlaceOr(DocIdSetIterator disi);
    public virtual void InPlaceAnd(DocIdSetIterator disi);
    public virtual void InPlaceNot(DocIdSetIterator disi);
    public virtual void InPlaceXor(DocIdSetIterator disi);
}
public class Lucene.Net.Util.OpenBitSetIterator : DocIdSetIterator {
    internal static UInt32[] bitlist;
    private Int64[] arr;
    private int words;
    private int i;
    private long word;
    private int wordShift;
    private int indexArray;
    private int curDocId;
    public OpenBitSetIterator(OpenBitSet obs);
    public OpenBitSetIterator(Int64[] bits, int numWords);
    private static OpenBitSetIterator();
    private void Shift();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual int DocID();
}
public abstract class Lucene.Net.Util.PriorityQueue`1 : object {
    private int size;
    private int maxSize;
    protected internal T[] heap;
    protected internal T SentinelObject { get; }
    public abstract virtual bool LessThan(T a, T b);
    protected internal virtual T get_SentinelObject();
    protected internal void Initialize(int maxSize);
    public T Add(T element);
    public virtual T InsertWithOverflow(T element);
    public T Top();
    public T Pop();
    public T UpdateTop();
    public int Size();
    public void Clear();
    private void UpHeap();
    private void DownHeap();
}
public class Lucene.Net.Util.RamUsageEstimator : object {
    private MemoryModel memoryModel;
    private IDictionary`2<object, object> seen;
    private int refSize;
    private int arraySize;
    private int classSize;
    private bool checkInterned;
    private static long ONE_KB;
    private static long ONE_MB;
    private static long ONE_GB;
    public RamUsageEstimator(bool checkInterned);
    public RamUsageEstimator(MemoryModel memoryModel);
    public RamUsageEstimator(MemoryModel memoryModel, bool checkInterned);
    private static RamUsageEstimator();
    public long EstimateRamUsage(object obj);
    private long Size(object obj);
    private long SizeOfArray(object obj);
    public static string HumanReadableUnits(long bytes, IFormatProvider df);
}
public class Lucene.Net.Util.ReaderUtil : object {
    public static void GatherSubReaders(IList`1<IndexReader> allSubReaders, IndexReader reader);
    public static IndexReader SubReader(int doc, IndexReader reader);
    public static IndexReader SubReader(IndexReader reader, int subIndex);
    public static int SubIndex(int n, Int32[] docStarts);
}
public class Lucene.Net.Util.ScorerDocQueue : object {
    private HeapedScorerDoc[] heap;
    private int maxSize;
    private int size;
    private HeapedScorerDoc topHSD;
    public ScorerDocQueue(int maxSize);
    public void Put(Scorer scorer);
    public virtual bool Insert(Scorer scorer);
    public Scorer Top();
    public int TopDoc();
    public float TopScore();
    public bool TopNextAndAdjustElsePop();
    public bool TopSkipToAndAdjustElsePop(int target);
    private bool CheckAdjustElsePop(bool cond);
    public Scorer Pop();
    private void PopNoResult();
    public void AdjustTop();
    public int Size();
    public void Clear();
    private void UpHeap();
    private void DownHeap();
}
public class Lucene.Net.Util.SimpleStringInterner : StringInterner {
    private Entry[] cache;
    private int maxChainLength;
    public SimpleStringInterner(int tableSize, int maxChainLength);
    public virtual string Intern(string s);
}
public class Lucene.Net.Util.SmallFloat : object {
    public static sbyte FloatToByte(float f, int numMantissaBits, int zeroExp);
    public static float ByteToFloat(byte b, int numMantissaBits, int zeroExp);
    public static sbyte FloatToByte315(float f);
    public static float Byte315ToFloat(byte b);
    public static sbyte FloatToByte52(float f);
    public static float Byte52ToFloat(byte b);
}
public class Lucene.Net.Util.SortedVIntList : DocIdSet {
    internal static int BITS2VINTLIST_SIZE;
    private int size;
    private SByte[] bytes;
    private int lastBytePos;
    private static int VB1;
    private static int BIT_SHIFT;
    private int MAX_BYTES_PER_INT;
    public int Size { get; }
    public int ByteSize { get; }
    public bool IsCacheable { get; }
    public SortedVIntList(Int32[] sortedInts);
    public SortedVIntList(Int32[] sortedInts, int inputSize);
    public SortedVIntList(BitArray bits);
    public SortedVIntList(OpenBitSet bits);
    public SortedVIntList(DocIdSetIterator docIdSetIterator);
    private void InitBytes();
    private void ResizeBytes(int newSize);
    public virtual int get_Size();
    public virtual int get_ByteSize();
    public virtual bool get_IsCacheable();
    public virtual DocIdSetIterator Iterator();
}
public abstract class Lucene.Net.Util.SorterTemplate : object {
    private static int MERGESORT_THRESHOLD;
    private static int QUICKSORT_THRESHOLD;
    protected internal abstract virtual void Swap(int i, int j);
    protected internal abstract virtual int Compare(int i, int j);
    public virtual void QuickSort(int lo, int hi);
    private void QuickSortHelper(int lo, int hi);
    private void InsertionSort(int lo, int hi);
    protected internal virtual void MergeSort(int lo, int hi);
    private void Merge(int lo, int pivot, int hi, int len1, int len2);
    private void Rotate(int lo, int mid, int hi);
    private int Lower(int lo, int hi, int val);
    private int Upper(int lo, int hi, int val);
}
public abstract class Lucene.Net.Util.StringHelper : object {
    public static StringInterner interner;
    private static StringHelper();
    public static string Intern(string s);
    public static int BytesDifference(Byte[] bytes1, int len1, Byte[] bytes2, int len2);
    public static int StringDifference(string s1, string s2);
}
public class Lucene.Net.Util.StringInterner : object {
    public virtual string Intern(string s);
    public virtual string Intern(Char[] arr, int offset, int len);
}
public class Lucene.Net.Util.ToStringUtils : object {
    public static string Boost(float boost);
}
public static class Lucene.Net.Util.UnicodeUtil : object {
    public static int UNI_SUR_HIGH_START;
    public static int UNI_SUR_HIGH_END;
    public static int UNI_SUR_LOW_START;
    public static int UNI_SUR_LOW_END;
    public static int UNI_REPLACEMENT_CHAR;
    private static long UNI_MAX_BMP;
    private static int HALF_BASE;
    private static long HALF_SHIFT;
    private static long HALF_MASK;
    public static void UTF16toUTF8(Char[] source, int offset, UTF8Result result);
    public static void UTF16toUTF8(Char[] source, int offset, int length, UTF8Result result);
    public static void UTF16toUTF8(string s, int offset, int length, UTF8Result result);
    public static void UTF8toUTF16(Byte[] utf8, int offset, int length, UTF16Result result);
}
public enum Lucene.Net.Util.Version : Enum {
    public int value__;
    public static Version LUCENE_20;
    public static Version LUCENE_21;
    public static Version LUCENE_22;
    public static Version LUCENE_23;
    public static Version LUCENE_24;
    public static Version LUCENE_29;
    public static Version LUCENE_30;
    [ObsoleteAttribute("Use an actual version instead.")]
public static Version LUCENE_CURRENT;
}
[ExtensionAttribute]
public static class Lucene.Net.Util.VersionEnumExtensions : object {
    [ExtensionAttribute]
public static bool OnOrAfter(Version first, Version other);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Mono.Documentation.DocLoader : MulticastDelegate {
    public DocLoader(object object, IntPtr method);
    public virtual XmlDocument Invoke(string escapedTypeName);
    public virtual IAsyncResult BeginInvoke(string escapedTypeName, AsyncCallback callback, object object);
    public virtual XmlDocument EndInvoke(IAsyncResult result);
}
public class Mono.Documentation.ManifestResourceResolver : XmlUrlResolver {
    private String[] dirs;
    public ManifestResourceResolver(String[] dirs);
    public virtual Uri ResolveUri(Uri baseUri, string relativeUri);
    public virtual object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);
}
public static class Mono.Documentation.XmlDocUtils : object {
    public static XmlNodeList GetMemberGenericParameters(XmlNode member);
    public static XmlNodeList GetTypeGenericParameters(XmlNode member);
    public static string ToTypeName(string type, XmlNode member);
    public static string ToTypeName(string type, XmlNodeList typeGenParams, XmlNodeList memberGenParams);
    public static string ToEscapedTypeName(string name);
    private static string GetCountedName(string name, string escape);
    private static int GetGenericCount(string name, int start, Int32& end);
    public static string ToEscapedMemberName(string member);
    public static void AddExtensionMethods(XmlDocument typexml, ArrayList extensions, DocLoader loader);
    [IteratorStateMachineAttribute("Mono.Documentation.XmlDocUtils/<GetSupportedTypes>d__9")]
private static IEnumerable GetSupportedTypes(XmlDocument type, DocLoader loader);
    private static string GetEscapedPath(XmlDocument d, string path);
    private static void GetInterfaces(Hashtable ifaces, XmlDocument doc, DocLoader loader);
    public static string GetCacheDirectory(string assembledBase);
    public static string GetCachedFileName(string cacheDir, string url);
}
public class Mono.Utilities.Colorizer : object {
    private static string keywords_cs;
    private static Colorizer();
    public static string Colorize(string text, string lang);
    private static string ColorizeXml(string text);
    private static string ColorizeCs(string text);
    private static string ColorizeVb(string text);
    private static string Escape(string text);
}
public class Mono.Utilities.LRUCache`2 : object {
    [ThreadStaticAttribute]
private static LRUCache`2<TKey, TValue> deflt;
    private int capacity;
    private LinkedList`1<ListValueEntry`2<TKey, TValue, TKey, TValue>> list;
    private Dictionary`2<TKey, LinkedListNode`1<ListValueEntry`2<TKey, TValue, TKey, TValue>>> lookup;
    private LinkedListNode`1<ListValueEntry`2<TKey, TValue, TKey, TValue>> openNode;
    public static LRUCache`2<TKey, TValue> Default { get; }
    public LRUCache`2(int capacity);
    public static LRUCache`2<TKey, TValue> get_Default();
    public void Put(TKey key, TValue value);
    public TValue Get(TKey key);
}
public class Monodoc.Caches.FileCache : object {
    private string baseCacheDir;
    public FileCache(string baseCacheDir);
    public sealed virtual bool IsCached(string id);
    public sealed virtual bool CanCache(DocEntity entity);
    public sealed virtual Stream GetCachedStream(string id);
    public sealed virtual string GetCachedString(string id);
    public sealed virtual void CacheText(string id, string content);
    public sealed virtual void CacheText(string id, Stream stream);
    public sealed virtual void CacheBlob(string id, Byte[] data);
    public sealed virtual void CacheBlob(string id, Stream stream);
    private string MakePath(string id);
    public sealed virtual void Dispose();
}
public class Monodoc.Caches.NullCache : object {
    public sealed virtual bool IsCached(string id);
    public sealed virtual bool CanCache(DocEntity entity);
    public sealed virtual Stream GetCachedStream(string id);
    public sealed virtual string GetCachedString(string id);
    public sealed virtual void CacheText(string id, string content);
    public sealed virtual void CacheText(string id, Stream stream);
    public sealed virtual void CacheBlob(string id, Byte[] data);
    public sealed virtual void CacheBlob(string id, Stream stream);
    public sealed virtual void Dispose();
}
public static class Monodoc.Config : object {
    private static KeyValueConfigurationCollection libConfig;
    private static KeyValueConfigurationCollection exeConfig;
    public static KeyValueConfigurationCollection AppSettings { get; }
    public static KeyValueConfigurationCollection LibSettings { get; }
    private static Config();
    public static string Get(string key);
    public static KeyValueConfigurationCollection get_AppSettings();
    public static KeyValueConfigurationCollection get_LibSettings();
}
public static class Monodoc.DocCacheHelper : object {
    private static string cacheBaseDirectory;
    private static DocCacheHelper();
    public static IDocCache GetDefaultCache(string name);
}
public enum Monodoc.DocEntity : Enum {
    public int value__;
    public static DocEntity Text;
    public static DocEntity Blob;
}
[ExtensionAttribute]
public static class Monodoc.DocRevisionManagerExtensions : object {
    [ExtensionAttribute]
public static Stream RetrieveLatestRevision(IDocRevisionManager revManager, string id);
}
[ExtensionAttribute]
public static class Monodoc.DocStorageExtensions : object {
    [ExtensionAttribute]
public static bool TryRetrieve(IDocStorage storage, string id, Stream& stream);
}
public enum Monodoc.DocumentType : Enum {
    public int value__;
    public static DocumentType EcmaXml;
    public static DocumentType EcmaSpecXml;
    public static DocumentType Man;
    public static DocumentType AddinXml;
    public static DocumentType MonoBook;
    public static DocumentType Html;
    public static DocumentType TocXml;
    public static DocumentType PlainText;
    public static DocumentType ErrorXml;
}
public class Monodoc.Ecma.EcmaDesc : object {
    [CompilerGeneratedAttribute]
private Kind <DescKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Mod <DescModifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private EcmaDesc <NestedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <ArrayDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EcmaDesc> <GenericTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EcmaDesc> <GenericMemberArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EcmaDesc> <MemberArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Etc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EtcFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private EcmaDesc <ExplicitImplMember>k__BackingField;
    public Kind DescKind { get; public set; }
    public Mod DescModifier { get; public set; }
    public string Namespace { get; public set; }
    public string TypeName { get; public set; }
    public string MemberName { get; public set; }
    public EcmaDesc NestedType { get; public set; }
    public IList`1<int> ArrayDimensions { get; public set; }
    public IList`1<EcmaDesc> GenericTypeArguments { get; public set; }
    public int GenericTypeArgumentsCount { get; }
    public bool GenericTypeArgumentsIsNumeric { get; }
    public IList`1<EcmaDesc> GenericMemberArguments { get; public set; }
    public int GenericMemberArgumentsCount { get; }
    public bool GenericMemberArgumentsIsNumeric { get; }
    public IList`1<EcmaDesc> MemberArguments { get; public set; }
    public int MemberArgumentsCount { get; }
    public char Etc { get; public set; }
    public bool IsEtc { get; }
    public string EtcFilter { get; public set; }
    public EcmaDesc ExplicitImplMember { get; public set; }
    private string FormattedNamespace { get; }
    [CompilerGeneratedAttribute]
public Kind get_DescKind();
    [CompilerGeneratedAttribute]
public void set_DescKind(Kind value);
    [CompilerGeneratedAttribute]
public Mod get_DescModifier();
    [CompilerGeneratedAttribute]
public void set_DescModifier(Mod value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public EcmaDesc get_NestedType();
    [CompilerGeneratedAttribute]
public void set_NestedType(EcmaDesc value);
    [CompilerGeneratedAttribute]
public IList`1<int> get_ArrayDimensions();
    [CompilerGeneratedAttribute]
public void set_ArrayDimensions(IList`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<EcmaDesc> get_GenericTypeArguments();
    [CompilerGeneratedAttribute]
public void set_GenericTypeArguments(IList`1<EcmaDesc> value);
    public int get_GenericTypeArgumentsCount();
    public bool get_GenericTypeArgumentsIsNumeric();
    [CompilerGeneratedAttribute]
public IList`1<EcmaDesc> get_GenericMemberArguments();
    [CompilerGeneratedAttribute]
public void set_GenericMemberArguments(IList`1<EcmaDesc> value);
    public int get_GenericMemberArgumentsCount();
    public bool get_GenericMemberArgumentsIsNumeric();
    [CompilerGeneratedAttribute]
public IList`1<EcmaDesc> get_MemberArguments();
    [CompilerGeneratedAttribute]
public void set_MemberArguments(IList`1<EcmaDesc> value);
    public int get_MemberArgumentsCount();
    [CompilerGeneratedAttribute]
public char get_Etc();
    [CompilerGeneratedAttribute]
public void set_Etc(char value);
    public bool get_IsEtc();
    [CompilerGeneratedAttribute]
public string get_EtcFilter();
    [CompilerGeneratedAttribute]
public void set_EtcFilter(string value);
    [CompilerGeneratedAttribute]
public EcmaDesc get_ExplicitImplMember();
    [CompilerGeneratedAttribute]
public void set_ExplicitImplMember(EcmaDesc value);
    public string ToCompleteTypeName(char innerTypeSeparator);
    public string ToCompleteMemberName(Format format);
    public string ToEcmaCref();
    private void ConstructCRef(StringBuilder sb, bool skipLeadingDot);
    private void AppendGenericArguments(StringBuilder sb, IEnumerable`1<EcmaDesc> arguments, bool isNumeric, int argumentsCount);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(EcmaDesc other);
    public virtual int GetHashCode();
    private bool What(bool input);
    private bool WhatT(bool input);
    private string FormatNamespace(EcmaDesc desc);
    private string FormatGenericArgs(IEnumerable`1<EcmaDesc> args);
    private string FormatGenericArgsFull(IEnumerable`1<EcmaDesc> genericArgs);
    private string ModToString(EcmaDesc desc);
    private string get_FormattedNamespace();
    [CompilerGeneratedAttribute]
private string <ToCompleteMemberName>b__68_0(EcmaDesc a);
    [CompilerGeneratedAttribute]
private string <FormatGenericArgs>b__79_0(EcmaDesc t);
}
public class Monodoc.Ecma.EcmaUrlParser : object {
    private int yacc_verbose_flag;
    public TextWriter ErrorOutput;
    public int eof_token;
    internal yyDebug debug;
    protected static int yyFinal;
    protected static String[] yyNames;
    private int yyExpectingState;
    protected int yyMax;
    private static Int32[] global_yyStates;
    private static Object[] global_yyVals;
    protected bool use_global_stacks;
    private Object[] yyVals;
    private object yyVal;
    private int yyToken;
    private int yyTop;
    private static Int16[] yyLhs;
    private static Int16[] yyLen;
    private static Int16[] yyDefRed;
    protected static Int16[] yyDgoto;
    protected static Int16[] yySindex;
    protected static Int16[] yyRindex;
    protected static Int16[] yyGindex;
    protected static Int16[] yyTable;
    protected static Int16[] yyCheck;
    private static EcmaUrlParser();
    public void IsValid(string input);
    public EcmaDesc Parse(string input);
    public bool TryParse(string input, EcmaDesc& desc);
    private EcmaDesc SetEcmaDescType(object result, Kind kind);
    private List`1<T> SafeReverse(List`1<T> input);
    public void yyerror(string message);
    public void yyerror(string message, String[] expected);
    public static string yyname(int token);
    protected Int32[] yyExpectingTokens(int state);
    protected String[] yyExpecting(int state);
    internal object yyparse(yyInput yyLex, object yyd);
    protected object yyDefault(object first);
    internal object yyparse(yyInput yyLex);
    private void case_12();
    private void case_13();
    private void case_14();
    private void case_23();
    private void case_31();
    private void case_32();
    private void case_33();
    private void case_35();
    private void case_44();
    private void case_45();
    private void case_46();
    private void case_49();
}
public class Monodoc.Ecma.EcmaUrlTokenizer : object {
    private static char EndOfStream;
    private string input;
    private object val;
    private int current_token;
    private int current_pos;
    private int real_current_pos;
    private int identCount;
    public object Value { get; }
    public EcmaUrlTokenizer(string input);
    private static bool is_identifier_start_character(char c);
    private static bool is_identifier_part_character(char c);
    public sealed virtual bool advance();
    public object get_Value();
    public sealed virtual object value();
    public sealed virtual int token();
    private int xtoken();
    private int TokenizeIdentifierOrNumber(char current);
    private char Read();
    private char Peek();
}
internal class Monodoc.Ecma.Token : object {
    public static int ERROR;
    public static int IDENTIFIER;
    public static int DIGIT;
    public static int DOT;
    public static int COMMA;
    public static int COLON;
    public static int INNER_TYPE_SEPARATOR;
    public static int OP_GENERICS_LT;
    public static int OP_GENERICS_GT;
    public static int OP_GENERICS_BACKTICK;
    public static int OP_OPEN_PAREN;
    public static int OP_CLOSE_PAREN;
    public static int OP_ARRAY_OPEN;
    public static int OP_ARRAY_CLOSE;
    public static int SLASH_SEPARATOR;
    public static int STAR;
    public static int REF_ARG;
    public static int OUT_ARG;
    public static int EXPLICIT_IMPL_SEP;
    public static int yyErrorCode;
}
internal interface Monodoc.Ecma.yydebug.yyDebug {
    public abstract virtual void push(int state, object value);
    public abstract virtual void lex(int state, int token, string name, object value);
    public abstract virtual void shift(int from, int to, int errorFlag);
    public abstract virtual void pop(int state);
    public abstract virtual void discard(int state, int token, string name, object value);
    public abstract virtual void reduce(int from, int to, int rule, string text, int len);
    public abstract virtual void shift(int from, int to);
    public abstract virtual void accept(object value);
    public abstract virtual void error(string message);
    public abstract virtual void reject();
}
internal class Monodoc.Ecma.yydebug.yyDebugSimple : object {
    private void println(string s);
    public sealed virtual void push(int state, object value);
    public sealed virtual void lex(int state, int token, string name, object value);
    public sealed virtual void shift(int from, int to, int errorFlag);
    public sealed virtual void pop(int state);
    public sealed virtual void discard(int state, int token, string name, object value);
    public sealed virtual void reduce(int from, int to, int rule, string text, int len);
    public sealed virtual void shift(int from, int to);
    public sealed virtual void accept(object value);
    public sealed virtual void error(string message);
    public sealed virtual void reject();
}
internal class Monodoc.Ecma.yyParser.yyException : Exception {
    public yyException(string message);
}
internal interface Monodoc.Ecma.yyParser.yyInput {
    public abstract virtual bool advance();
    public abstract virtual int token();
    public abstract virtual object value();
}
internal class Monodoc.Ecma.yyParser.yyUnexpectedEof : yyException {
    public yyUnexpectedEof(string message);
}
public class Monodoc.Generators.Html.Addin2Html : object {
    public string CssCode { get; }
    public sealed virtual string get_CssCode();
    public sealed virtual string Export(Stream stream, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    private XmlElement GetAddin(TextReader reader, string addinId);
    public string Htmlize(XmlElement addin, string urlType, string addinId, string fileId, string path);
    protected string GetAddinTextFromUrl(XmlElement addin, string addinId, string fileId);
    protected string GetExtensionTextFromUrl(XmlElement addin, string addinId, string fileId, string path);
    protected string GetExtensionNodeTextFromUrl(XmlElement addin, string addinId, string fileId, string nodeId);
}
public class Monodoc.Generators.Html.Ecma2Html : object {
    private static string css_ecma;
    private static string js;
    private static XslCompiledTransform ecma_transform;
    private ExtensionObject ExtObject;
    public string CssCode { get; }
    public string JsCode { get; }
    public sealed virtual string get_CssCode();
    public string get_JsCode();
    public string Htmlize(XmlReader ecma_xml, Dictionary`2<string, string> extraArgs);
    public string Htmlize(XmlReader ecma_xml, XsltArgumentList args);
    protected virtual XmlResolver CreateDocumentResolver();
    public sealed virtual string Export(Stream stream, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    private static void EnsureTransform();
}
public class Monodoc.Generators.Html.Ecmaspec2Html : object {
    private static string css_ecmaspec;
    private static XslTransform ecma_transform;
    private static XsltArgumentList args;
    public string CssCode { get; }
    private static Ecmaspec2Html();
    public sealed virtual string get_CssCode();
    public sealed virtual string Export(Stream stream, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    private static string Htmlize(XPathDocument ecma_xml);
}
public class Monodoc.Generators.Html.Error2Html : object {
    public string CssCode { get; }
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(Stream input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string get_CssCode();
    public string Htmlize(IXPathNavigable doc);
    private void WriteElementWithClass(XmlWriter w, string element, string cls, string content);
}
public class Monodoc.Generators.Html.Idem : object {
    public string CssCode { get; }
    public sealed virtual string get_CssCode();
    public sealed virtual string Export(Stream input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
}
public class Monodoc.Generators.Html.Man2Html : object {
    public string CssCode { get; }
    public sealed virtual string get_CssCode();
    public sealed virtual string Export(Stream input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    public static string GetTextFromReader(TextReader file);
    private static void ProcessLine(string line, StateInfo s);
    private static String[] SplitLine(string line);
    private static void Add(List`1<string> pieces, string line, int start, int end);
    private static void Expect(StateInfo s, String[] expected);
    private static void ClearUntil(StateInfo s, string required);
    private static void ClearAll(StateInfo s);
    private static void Translate(String[] lines, int startIndex, StringBuilder output);
    private static void Translate(string line, StringBuilder output);
}
public class Monodoc.Generators.Html.MonoBook2Html : object {
    public string CssCode { get; }
    public sealed virtual string get_CssCode();
    public sealed virtual string Export(Stream input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    public string FromXmlReader(XmlReader reader);
}
public class Monodoc.Generators.Html.Toc2Html : object {
    private XslTransform transform;
    public string CssCode { get; }
    public sealed virtual string Export(Stream input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string Export(string input, Dictionary`2<string, string> extraArgs);
    public sealed virtual string get_CssCode();
}
public class Monodoc.Generators.HtmlGenerator : object {
    private static string cachePrefix;
    private static string css_code;
    private IDocCache defaultCache;
    private static Dictionary`2<DocumentType, IHtmlExporter> converters;
    public static string InlineCss { get; public set; }
    private static HtmlGenerator();
    public HtmlGenerator(IDocCache defaultCache);
    public sealed virtual string Generate(HelpSource hs, string id, Dictionary`2<string, string> context);
    private string GenerateMultiPart(HelpSource hs, IEnumerable`1<string> ids, string originalId, Dictionary`2<string, string> context);
    private string GenerateMasterRootPage(RootTree rootTree);
    public static string get_InlineCss();
    public static void set_InlineCss(string value);
    private string MakeHtmlError(string error);
    private string MakeEmptySummary();
    private string MakeCacheKey(HelpSource hs, string page, IDictionary`2<string, string> extraParams);
}
internal interface Monodoc.Generators.IHtmlExporter {
    public string CssCode { get; }
    public abstract virtual string get_CssCode();
    public abstract virtual string Export(Stream input, Dictionary`2<string, string> extras);
    public abstract virtual string Export(string input, Dictionary`2<string, string> extras);
}
public class Monodoc.Generators.RawGenerator : object {
    public sealed virtual string Generate(HelpSource hs, string id, Dictionary`2<string, string> context);
    private string GenerateMultiPart(HelpSource hs, IEnumerable`1<string> ids, string originalId, Dictionary`2<string, string> context);
}
public class Monodoc.HelpSource : object {
    private static int id;
    private int source_id;
    private string name;
    private string basePath;
    private Tree tree;
    private string treeFilePath;
    private RootTree rootTree;
    private IDocCache cache;
    private IDocStorage storage;
    [CompilerGeneratedAttribute]
private TraceLevel <TraceLevel>k__BackingField;
    private static HtmlGenerator htmlGenerator;
    [ObsoleteAttribute]
public static bool use_css;
    [ObsoleteAttribute]
public static bool FullHtml;
    [ObsoleteAttribute]
public static bool UseWebdocCache;
    public int SourceID { get; }
    public string Name { get; }
    public string BaseFilePath { get; }
    public TraceLevel TraceLevel { get; public set; }
    public string BaseDir { get; }
    public Tree Tree { get; }
    public RootTree RootTree { get; public set; }
    public IDocCache Cache { get; }
    public IDocStorage Storage { get; protected set; }
    protected string UriPrefix { get; }
    public SortType SortType { get; }
    [ObsoleteAttribute("Use Monodoc.Providers.HtmlGenerator.InlineCss")]
public string InlineCss { get; }
    [ObsoleteAttribute]
public string InlineJavaScript { get; }
    public HelpSource(string base_filename, bool create);
    private static HelpSource();
    public int get_SourceID();
    public string get_Name();
    public string get_BaseFilePath();
    [CompilerGeneratedAttribute]
public TraceLevel get_TraceLevel();
    [CompilerGeneratedAttribute]
public void set_TraceLevel(TraceLevel value);
    public string get_BaseDir();
    public Tree get_Tree();
    public RootTree get_RootTree();
    public void set_RootTree(RootTree value);
    public IDocCache get_Cache();
    public IDocStorage get_Storage();
    protected void set_Storage(IDocStorage value);
    protected virtual string get_UriPrefix();
    public virtual SortType get_SortType();
    public virtual Stream GetHelpStream(string id);
    public virtual Stream GetCachedHelpStream(string id);
    public XmlReader GetHelpXml(string id);
    public virtual XmlDocument GetHelpXmlWithChanges(string id);
    public virtual string GetCachedText(string id);
    public virtual string GetText(string id);
    public virtual bool IsGeneratedContent(string id);
    public virtual bool IsRawContent(string id);
    public virtual bool IsMultiPart(string id, IEnumerable`1& parts);
    public void Save();
    public virtual void RenderPreviewDocs(XmlNode newNode, XmlWriter writer);
    public virtual string GetPublicUrl(Node node);
    public virtual bool CanHandleUrl(string url);
    public virtual string GetInternalIdForUrl(string url, Node& node, Dictionary`2& context);
    public virtual Node MatchNode(string url);
    private Node SlowMatchNode(Node current, LRUCache`2<string, Node> matchCache, string url);
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual Stream GetImage(string url);
    public virtual void PopulateIndex(IndexMaker index_maker);
    public virtual void PopulateSearchableIndex(IndexWriter writer);
    public string get_InlineCss();
    public string get_InlineJavaScript();
    [ObsoleteAttribute("Use RenderUrl")]
public string GetText(string url, Node& node);
    [ObsoleteAttribute("Use RenderUrl")]
public string RenderNamespaceLookup(string url, Node& node);
}
public interface Monodoc.IDocCache {
    public abstract virtual bool IsCached(string id);
    public abstract virtual bool CanCache(DocEntity entity);
    public abstract virtual Stream GetCachedStream(string id);
    public abstract virtual string GetCachedString(string id);
    public abstract virtual void CacheText(string id, string content);
    public abstract virtual void CacheText(string id, Stream stream);
    public abstract virtual void CacheBlob(string id, Byte[] data);
    public abstract virtual void CacheBlob(string id, Stream stream);
}
public interface Monodoc.IDocGenerator`1 {
    public abstract virtual TOutput Generate(HelpSource hs, string internalId, Dictionary`2<string, string> context);
}
public interface Monodoc.IDocRevisionManager {
    public abstract virtual Stream RetrieveWithRevision(string id, string revision);
    public abstract virtual IEnumerable`1<string> AvailableRevisionsForId(string id);
    public abstract virtual string LatestRevisionForId(string id);
    public abstract virtual string GetRevisionDescription(string revision);
}
public interface Monodoc.IDocStorage {
    public bool SupportRevision { get; }
    public IDocRevisionManager RevisionManager { get; }
    public bool SupportChange { get; }
    public abstract virtual bool get_SupportRevision();
    public abstract virtual IDocRevisionManager get_RevisionManager();
    public abstract virtual bool get_SupportChange();
    public abstract virtual string Store(string id, string text);
    public abstract virtual string Store(string id, Byte[] data);
    public abstract virtual string Store(string id, Stream stream);
    public abstract virtual Stream Retrieve(string id);
    public abstract virtual IEnumerable`1<string> GetAvailableIds();
}
[ExtensionAttribute]
internal static class Monodoc.IListExtensions : object {
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> ilist, T item);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> ilist, T item, IComparer`1<T> comparer);
}
public interface Monodoc.IListModel {
    public int Rows { get; }
    public abstract virtual int get_Rows();
    public abstract virtual string GetValue(int row);
    public abstract virtual string GetDescription(int row);
}
[DefaultMemberAttribute("Item")]
public class Monodoc.IndexEntry : object {
    private List`1<Topic> topics;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Position { get; private set; }
    public IList`1<Topic> Topics { get; }
    public int Count { get; private set; }
    public Topic Item { get; }
    public IndexEntry(FileStream fs, BinaryReader reader, int position);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public IList`1<Topic> get_Topics();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Add(Topic t);
    public Topic get_Item(int idx);
    public void WriteTopics(IndexMaker maker, Stream stream, BinaryWriter writer);
}
public class Monodoc.IndexMaker : object {
    private Dictionary`2<string, IndexEntry> entries;
    private Dictionary`2<string, int> all_strings;
    private int index_position;
    private void AddString(string str);
    public void AddTopic(Topic topic);
    public void Add(string caption, string sort_key, string url);
    private void SaveStringTable(Stream stream, BinaryWriter writer);
    public int GetCode(string s);
    private void SaveTopics(Stream stream, BinaryWriter writer);
    private void SaveIndexEntries(Stream stream, BinaryWriter writer);
    public void Save(string filename);
}
public class Monodoc.IndexReader : object {
    private Encoding utf8;
    private FileStream fs;
    private BinaryReader reader;
    private int table_offset;
    private int entries;
    public int Rows { get; }
    private IndexReader(string filename);
    public static IndexReader Load(string filename);
    public sealed virtual int get_Rows();
    public sealed virtual string GetValue(int row);
    public sealed virtual string GetDescription(int row);
    public IndexEntry GetIndexEntry(int row);
}
public class Monodoc.Node : object {
    private Tree parentTree;
    private string caption;
    private string element;
    private string pubUrl;
    public bool Documented;
    private bool loaded;
    private Node parent;
    private List`1<Node> nodes;
    private ArrayList legacyNodes;
    private Dictionary`2<string, Node> childrenLookup;
    private bool elementSort;
    private int address;
    [ObsoleteAttribute("Use ChildNodes")]
public ArrayList Nodes { get; }
    public IList`1<Node> ChildNodes { get; }
    public string Element { get; public set; }
    public string Caption { get; internal set; }
    public Node Parent { get; }
    public Tree Tree { get; }
    internal int Address { get; internal set; }
    public bool IsLeaf { get; }
    public string PublicUrl { get; }
    [ObsoleteAttribute("Use `Tree' instead of 'tree'")]
public Tree tree { get; }
    [ObsoleteAttribute("Tree inheriting Node is being phased out. Use the `Tree.RootNode' property instead")]
public Node(string caption, string element);
    public Node(Node parent, string caption, string element);
    internal Node(Tree tree, string caption, string element);
    internal Node(Node parent, int address);
    internal Node(Tree tree, int address);
    private void LoadNode();
    public void AddNode(Node n);
    public void DeleteNode(Node n);
    private void RegisterFullNode(Node child);
    public ArrayList get_Nodes();
    public IList`1<Node> get_ChildNodes();
    public string get_Element();
    public void set_Element(string value);
    public string get_Caption();
    internal void set_Caption(string value);
    public Node get_Parent();
    public Tree get_Tree();
    internal int get_Address();
    internal void set_Address(int value);
    public Node CreateNode(string c_caption, string c_element);
    public Node GetOrCreateNode(string c_caption, string c_element);
    public void EnsureNodes();
    public void EnsureLoaded();
    private void UpdateLookup();
    public bool get_IsLeaf();
    private void EncodeInt(BinaryWriter writer, int value);
    private int DecodeInt(BinaryReader reader);
    internal void Deserialize(BinaryReader reader);
    internal void Serialize(FileStream output, BinaryWriter writer);
    public void Sort();
    internal string GetInternalUrl();
    public string get_PublicUrl();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<Monodoc.Node>.CompareTo(Node obj);
    private int CompareToInternal(Node other);
    public Tree get_tree();
    [ObsoleteAttribute("Use TreeDumper")]
public static void PrintTree(Tree t);
}
public abstract class Monodoc.Provider : object {
    private static short serial;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    public int Code { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(int value);
    public abstract virtual void PopulateTree(Tree tree);
    public abstract virtual void CloseTree(HelpSource hs, Tree tree);
}
public class Monodoc.Providers.AddinsHelpSource : HelpSource {
    protected internal static string AddinPrefix;
    protected internal static string ExtensionPrefix;
    protected internal static string ExtensionNodePrefix;
    protected string UriPrefix { get; }
    public AddinsHelpSource(string base_file, bool create);
    public virtual bool CanHandleUrl(string url);
    protected virtual string get_UriPrefix();
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual string GetInternalIdForUrl(string url, Node& node, Dictionary`2& context);
    public virtual Node MatchNode(string url);
}
public class Monodoc.Providers.AddinsProvider : Provider {
    private string file;
    public AddinsProvider(string xmlModelFile);
    public virtual void PopulateTree(Tree tree);
    public virtual void CloseTree(HelpSource hs, Tree tree);
}
internal class Monodoc.Providers.DefaultEcmaProviderFileSource : object {
    public static IEcmaProviderFileSource Default;
    private static DefaultEcmaProviderFileSource();
    public sealed virtual XmlReader GetIndexReader(string path);
    public sealed virtual XElement GetNamespaceElement(string path);
    public sealed virtual string GetTypeXmlPath(string basePath, string nsName, string typeName);
    public sealed virtual XDocument GetTypeDocument(string path);
    public sealed virtual string GetNamespaceXmlPath(string basePath, string ns);
    public sealed virtual XElement ExtractNamespaceSummary(string path);
}
internal class Monodoc.Providers.EcmaDoc : object {
    private static EcmaUrlParser parser;
    private static EcmaDoc();
    public static void PopulateTreeFromIndexFile(string indexFilePath, string idPrefix, Tree tree, IDocStorage storage, Dictionary`2<string, XElement> nsSummaries, Func`2<XElement, string> indexGenerator, IEcmaProviderFileSource fileSource);
    public static XDocument LoadTypeDocument(string basePath, string nsName, string typeName, IEcmaProviderFileSource fileSource);
    public static XDocument LoadTypeDocument(string basePath, string nsName, string typeName, String& finalPath, IEcmaProviderFileSource fileSource);
    public static string GetTypeCaptionFromIndex(XElement typeNodeFromIndex, bool full);
    public static string PluralizeMemberType(string memberType);
    public static string GetMemberType(XElement m);
    public static string MakeMemberCaption(XElement member, bool withArguments);
    public static Node MatchNodeWithEcmaUrl(string url, Tree tree);
    private static int GenericTypeBacktickSearch(IList`1<Node> childNodes, EcmaDesc desc);
    public static Dictionary`2<string, string> GetContextForEcmaNode(string hash, string sourceID, Node node);
    public static EcmaNodeType GetNodeType(Node node);
    public static char GetNodeMemberTypeChar(Node node);
    public static int GetNodeLevel(Node node);
    public static string EtcKindToCaption(char etc);
    public static string MemberKindToCaption(Kind kind);
    public static Node FindNodeForCaption(IList`1<Node> nodes, string caption);
    public static int CountTypeGenericArguments(string typeDefinition, int startIndex);
    internal static string MakeOperatorSignature(XElement member, String& memberSignature);
    private static XElement ExtractClassSummary(XDocument typeDoc);
}
public class Monodoc.Providers.EcmaHelpSource : HelpSource {
    internal static string EcmaPrefix;
    private LRUCache`2<string, Node> cache;
    protected string UriPrefix { get; }
    public EcmaHelpSource(string base_file, bool create);
    protected virtual string get_UriPrefix();
    public virtual bool CanHandleUrl(string url);
    public virtual Stream GetHelpStream(string id);
    public virtual Stream GetCachedHelpStream(string id);
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual string GetPublicUrl(Node node);
    private string MakeTypeNodeUrl(Node node);
    private string MakeMemberNodeUrl(char typeChar, Node node);
    private Node GetNodeTypeParent(Node node);
    private string GenerateMetaSuffix(Node node);
    public virtual string GetInternalIdForUrl(string url, Node& node, Dictionary`2& context);
    public string GetInternalIdForInternalUrl(string internalUrl, String& hash);
    public virtual Node MatchNode(string url);
    public virtual void PopulateIndex(IndexMaker index_maker);
    public virtual void PopulateSearchableIndex(IndexWriter writer);
    private string GetKindFromCaption(string s);
    private void GetTextFromNode(XElement n, StringBuilder sb);
    private void GetExamples(XElement n, StringBuilder sb);
    private static string LargeName(Node matched_node);
    private XElement GetMemberFromCaption(XDocument xdoc, string caption, bool isOperator, ILookup`2<string, XElement> prematchedMembers);
    private XElement GetDocsFromCaption(XDocument xdoc, string caption, bool isOperator, ILookup`2<string, XElement> prematchedMembers);
    [IteratorStateMachineAttribute("Monodoc.Providers.EcmaHelpSource/<ExtractArguments>d__26")]
private IEnumerable`1<string> ExtractArguments(string rawArgList);
    private void TryParseCaption(string caption, String& name, IList`1& argList);
    private bool AttrEq(XElement element, string attributeName, string expectedValue);
}
public enum Monodoc.Providers.EcmaNodeType : Enum {
    public int value__;
    public static EcmaNodeType Invalid;
    public static EcmaNodeType Namespace;
    public static EcmaNodeType Type;
    public static EcmaNodeType Member;
    public static EcmaNodeType Meta;
}
public class Monodoc.Providers.EcmaProvider : Provider {
    private HashSet`1<string> directories;
    private IEcmaProviderFileSource fileSource;
    public IEcmaProviderFileSource FileSource { get; public set; }
    public EcmaProvider(string baseDir);
    public IEcmaProviderFileSource get_FileSource();
    public void set_FileSource(IEcmaProviderFileSource value);
    public void AddDirectory(string directory);
    public virtual void PopulateTree(Tree tree);
    public virtual void CloseTree(HelpSource hs, Tree tree);
    private void AddEcmaXml(HelpSource hs);
    private void AddImages(HelpSource hs);
    private void AddExtensionMethods(HelpSource hs);
    private IEnumerable`1<string> GetEcmaXmls();
}
public class Monodoc.Providers.EcmaSpecHelpSource : HelpSource {
    private static string EcmaspecPrefix;
    private static string TocPart;
    private static string SpecPart;
    protected string UriPrefix { get; }
    public EcmaSpecHelpSource(string base_file, bool create);
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual bool IsGeneratedContent(string id);
    public virtual bool IsMultiPart(string id, IEnumerable`1& parts);
    [IteratorStateMachineAttribute("Monodoc.Providers.EcmaSpecHelpSource/<MakeMultiPart>d__7")]
private IEnumerable`1<string> MakeMultiPart(string baseId);
    public virtual string GetText(string id);
    public virtual Stream GetHelpStream(string id);
    public virtual void PopulateSearchableIndex(IndexWriter writer);
    protected virtual string get_UriPrefix();
    private void AddDocuments(IndexWriter writer, Node node);
    private void GetTextNode(XmlNode n, StringBuilder s);
    private void GetExamples(XmlNode n, StringBuilder s);
}
public class Monodoc.Providers.EcmaSpecProvider : Provider {
    private string basedir;
    public EcmaSpecProvider(string base_directory);
    public virtual void PopulateTree(Tree tree);
    private void PopulateNode(XPathNodeIterator nodes, Node treeNode);
    public virtual void CloseTree(HelpSource hs, Tree tree);
}
public class Monodoc.Providers.EcmaUncompiledHelpSource : EcmaHelpSource {
    private DirectoryInfo basedir;
    private string basedoc;
    public string BasePath;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    protected string UriPrefix { get; }
    public EcmaUncompiledHelpSource(string base_file, bool markName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    protected virtual string get_UriPrefix();
    public virtual Stream GetImage(string url);
}
public class Monodoc.Providers.ErrorDetails : object {
    public XmlNode Summary;
    public XmlNode Details;
}
public class Monodoc.Providers.ErrorDocumentation : object {
    public string ErrorName;
    public ErrorDetails Details;
    public List`1<string> Examples;
    public ErrorDocumentation(string ErrorName);
}
public class Monodoc.Providers.ErrorHelpSource : HelpSource {
    protected string UriPrefix { get; }
    public ErrorHelpSource(string base_file, bool create);
    public virtual string GetText(string id);
    protected virtual string get_UriPrefix();
    public virtual bool IsGeneratedContent(string id);
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual string GetInternalIdForUrl(string url, Node& node, Dictionary`2& context);
    public virtual void PopulateIndex(IndexMaker index_maker);
    public virtual void PopulateSearchableIndex(IndexWriter writer);
}
public class Monodoc.Providers.ErrorProvider : Provider {
    private ErrorProviderConfig config;
    public ErrorProvider(string configFile);
    public static ErrorProviderConfig ReadConfig(string file);
    public virtual void PopulateTree(Tree tree);
    public virtual void CloseTree(HelpSource hs, Tree tree);
}
public class Monodoc.Providers.ErrorProviderConfig : object {
    public string FilesPath;
    public string Match;
    public int ErrorNumSubstringStart;
    public int ErrorNumSubstringLength;
    public string FriendlyFormatString;
    public virtual string ToString();
    public Dictionary`2<string, ErrorDocumentation> Compile(HelpSource hs);
}
public interface Monodoc.Providers.IEcmaProviderFileSource {
    public abstract virtual XmlReader GetIndexReader(string path);
    public abstract virtual XDocument GetTypeDocument(string path);
    public abstract virtual XElement GetNamespaceElement(string path);
    public abstract virtual string GetTypeXmlPath(string basePath, string nsName, string typeName);
    public abstract virtual string GetNamespaceXmlPath(string basePath, string ns);
    public abstract virtual XElement ExtractNamespaceSummary(string path);
}
public class Monodoc.Providers.ManHelpSource : HelpSource {
    private static string ManPrefix;
    private Dictionary`2<string, Node> nodesMap;
    protected string UriPrefix { get; }
    public ManHelpSource(string base_file, bool create);
    public virtual Node MatchNode(string url);
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual bool IsGeneratedContent(string id);
    public virtual string GetText(string url);
    protected virtual string get_UriPrefix();
}
public class Monodoc.Providers.ManProvider : Provider {
    private String[] tocFiles;
    public ManProvider(String[] handbookTocFiles);
    public virtual void PopulateTree(Tree tree);
    public virtual void CloseTree(HelpSource hs, Tree tree);
}
public class Monodoc.Providers.XhtmlHelpSource : HelpSource {
    internal static string XhtmlPrefix;
    protected string UriPrefix { get; }
    public SortType SortType { get; }
    public XhtmlHelpSource(string base_file, bool create);
    protected virtual string get_UriPrefix();
    public virtual SortType get_SortType();
    public virtual DocumentType GetDocumentTypeForId(string id);
    public virtual bool IsGeneratedContent(string id);
    public virtual string GetText(string url);
    public static string GetAbsoluteLink(string target, string url);
    private XmlDocument RewriteLinks(XmlDocument docToProcess, string url);
    public virtual void PopulateIndex(IndexMaker index_maker);
    private void PopulateIndexFromNodes(Node start);
}
public class Monodoc.Providers.XhtmlProvider : Provider {
    private string tocFile;
    private XNamespace ns;
    public XhtmlProvider(string handbookTocFile);
    public virtual void PopulateTree(Tree tree);
    private void ParseUl(Tree tree, Node parent, XElement ul);
    private void ObjectEntryToParams(XElement obj, String& caption, String& element);
    public virtual void CloseTree(HelpSource hs, Tree tree);
}
[DefaultMemberAttribute("Item")]
public class Monodoc.Result : object {
    private string term;
    private Searcher searcher;
    private ScoreDoc[] docs;
    public string Term { get; }
    public int Count { get; }
    public Document Item { get; }
    public Result(string Term, Searcher searcher, ScoreDoc[] docs);
    public string get_Term();
    public int get_Count();
    public Document get_Item(int i);
    public string GetTitle(int i);
    public string GetUrl(int i);
    public string GetFullTitle(int i);
    public float Score(int i);
}
public class Monodoc.RootTree : Tree {
    public static int MonodocVersion;
    private static string RootNamespace;
    private string basedir;
    private static List`1<string> uncompiledHelpSourcePaths;
    private HashSet`1<string> loadedSourceFiles;
    private List`1<HelpSource> helpSources;
    private Dictionary`2<string, Node> nameToNode;
    private Dictionary`2<string, HelpSource> nameToHelpSource;
    [CompilerGeneratedAttribute]
private DateTime <LastHelpSourceTime>k__BackingField;
    private static IDocGenerator`1<string> rawGenerator;
    private static HtmlGenerator htmlGenerator;
    public IList`1<HelpSource> HelpSources { get; }
    public DateTime LastHelpSourceTime { get; public set; }
    private static bool IsUnix { get; }
    private static RootTree();
    public IList`1<HelpSource> get_HelpSources();
    [CompilerGeneratedAttribute]
public DateTime get_LastHelpSourceTime();
    [CompilerGeneratedAttribute]
public void set_LastHelpSourceTime(DateTime value);
    private static bool get_IsUnix();
    public static void AddUncompiledSource(string path);
    public static RootTree LoadTree();
    private static string ProbeBaseDirectories();
    public static RootTree LoadTree(string basedir, bool includeExternal);
    private static IEnumerable`1<string> ProbeExternalDirectorySources();
    public static RootTree LoadTree(string indexDir, XmlDocument docTree, IEnumerable`1<string> sourceFiles);
    public void AddSource(string sourcesDir);
    public bool AddSourceFile(string sourceFile);
    private static bool PurgeNode(Node node);
    public static String[] GetSupportedFormats();
    public static HelpSource GetHelpSource(string provider, string basefilepath);
    public static Provider GetProvider(string provider, String[] basefilepaths);
    private void Populate(Node parent, XmlNodeList xml_node_list);
    public Node LookupEntryPoint(string name);
    public TOutput RenderUrl(string url, IDocGenerator`1<TOutput> generator, HelpSource hintSource);
    public TOutput RenderUrl(string url, IDocGenerator`1<TOutput> generator, Node& node, HelpSource hintSource);
    public HelpSource GetHelpSourceAndIdForUrl(string url, String& internalId, Dictionary`2& context);
    public HelpSource GetHelpSourceAndIdForUrl(string url, String& internalId, Dictionary`2& context, Node& node);
    public HelpSource GetHelpSourceAndIdForUrl(string url, HelpSource hintSource, String& internalId, Dictionary`2& context, Node& node);
    public HelpSource GetHelpSourceAndIdFromName(string name, String& internalId, Node& node);
    public HelpSource GetHelpSourceFromId(int id);
    public Stream GetImage(string url);
    public IndexReader GetIndex();
    public static void MakeIndex();
    public bool GenerateIndex();
    public SearchableIndex GetSearchIndex();
    public static void MakeSearchIndex();
    public bool GenerateSearchIndex();
    private static int chmod(string filename, int mode);
    [IteratorStateMachineAttribute("Monodoc.RootTree/<GetIndexesPathPrefixes>d__46")]
private IEnumerable`1<string> GetIndexesPathPrefixes();
    [ObsoleteAttribute]
public string GetTitle(string url);
    [ObsoleteAttribute("Use RawGenerator directly")]
public XmlDocument GetHelpXml(string id);
    [ObsoleteAttribute("Use the RenderUrl variant accepting a generator")]
public string RenderUrl(string url, Node& n);
    [ObsoleteAttribute("Use GenerateIndex")]
public static void MakeIndex(RootTree root);
    [ObsoleteAttribute("Use GenerateSearchIndex")]
public static void MakeSearchIndex(RootTree root);
}
internal class Monodoc.SearchableDocument : ValueType {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HotText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Examples>k__BackingField;
    public string Title { get; public set; }
    public string Url { get; public set; }
    public string FullTitle { get; public set; }
    public string HotText { get; public set; }
    public string Text { get; public set; }
    public string Examples { get; public set; }
    public Document LuceneDoc { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FullTitle();
    [CompilerGeneratedAttribute]
public void set_FullTitle(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_HotText();
    [CompilerGeneratedAttribute]
public void set_HotText(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Examples();
    [CompilerGeneratedAttribute]
public void set_Examples(string value);
    public SearchableDocument Reset();
    public Document get_LuceneDoc();
    private static Field UnIndexed(string name, string value_Renamed);
    private static Field UnStored(string name, string value_Renamed);
}
public class Monodoc.SearchableIndex : object {
    private static int maxSearchCount;
    private IndexSearcher searcher;
    private string dir;
    public string Dir { get; public set; }
    public string get_Dir();
    public void set_Dir(string value);
    public static SearchableIndex Load(string dir);
    public Result Search(string term);
    public Result Search(string term, int count);
    public Result Search(string term, int count, int start);
    private TopDocs SearchInternal(Query q, int count, int start);
    public Result FastSearch(string term, int number);
}
[ObsoleteAttribute]
public class Monodoc.Settings : object {
    [ObsoleteAttribute]
public bool EnableEditing;
    [ObsoleteAttribute]
public int SerialNumber;
    [ObsoleteAttribute]
public bool ShowInheritedMembers;
    [ObsoleteAttribute]
public bool ShowComments;
    [ObsoleteAttribute]
public string Email;
    [ObsoleteAttribute]
public string Key;
    [ObsoleteAttribute]
public int LastSeenVersion;
    [ObsoleteAttribute]
public static bool RunningGUI;
    [ObsoleteAttribute]
public string preferred_font_family;
    [ObsoleteAttribute]
public double preferred_font_size;
}
[ObsoleteAttribute]
public class Monodoc.SettingsHandler : object {
    private static string settingsFile;
    private static XmlSerializer settingsSerializer;
    [ObsoleteAttribute]
public static Settings Settings;
    [ObsoleteAttribute]
public static string Path;
    private static SettingsHandler();
    [ObsoleteAttribute]
public static void CheckUpgrade();
    [ObsoleteAttribute]
public static void Save();
    [ObsoleteAttribute]
public static void EnsureSettingsDirectory();
}
public enum Monodoc.SortType : Enum {
    public int value__;
    public static SortType Caption;
    public static SortType Element;
}
public class Monodoc.Storage.NullStorage : object {
    public bool SupportRevision { get; }
    public IDocRevisionManager RevisionManager { get; }
    public bool SupportChange { get; }
    public sealed virtual bool get_SupportRevision();
    public sealed virtual IDocRevisionManager get_RevisionManager();
    public sealed virtual bool get_SupportChange();
    public sealed virtual string Store(string id, string text);
    public sealed virtual string Store(string id, Byte[] data);
    public sealed virtual string Store(string id, Stream stream);
    public sealed virtual Stream Retrieve(string id);
    public sealed virtual IEnumerable`1<string> GetAvailableIds();
    public sealed virtual void Dispose();
}
public class Monodoc.Storage.UncompiledDocStorage : object {
    private string basePath;
    public bool SupportRevision { get; }
    public IDocRevisionManager RevisionManager { get; }
    public bool SupportChange { get; }
    public UncompiledDocStorage(string basePath);
    public sealed virtual bool get_SupportRevision();
    public sealed virtual IDocRevisionManager get_RevisionManager();
    public sealed virtual bool get_SupportChange();
    public sealed virtual string Store(string id, string text);
    public sealed virtual string Store(string id, Byte[] data);
    public sealed virtual string Store(string id, Stream stream);
    public sealed virtual Stream Retrieve(string id);
    public sealed virtual IEnumerable`1<string> GetAvailableIds();
    public sealed virtual void Dispose();
}
public class Monodoc.Storage.ZipStorage : object {
    private string zipFileName;
    private int code;
    private ZipOutputStream zipOutput;
    private ZipFile zipFile;
    private Dictionary`2<string, int> entries;
    public bool SupportRevision { get; }
    public IDocRevisionManager RevisionManager { get; }
    public bool SupportChange { get; }
    public ZipStorage(string zipFileName);
    public sealed virtual bool get_SupportRevision();
    public sealed virtual IDocRevisionManager get_RevisionManager();
    public sealed virtual bool get_SupportChange();
    public sealed virtual string Store(string id, string text);
    public sealed virtual string Store(string id, Byte[] data);
    public sealed virtual string Store(string id, Stream stream);
    private void SetupEntry(ZipOutputStream zipOutput, String& id);
    public sealed virtual Stream Retrieve(string id);
    public sealed virtual IEnumerable`1<string> GetAvailableIds();
    private void EnsureOutput();
    private void EnsureInput();
    public sealed virtual void Dispose();
    private string GetNewCode();
    [CompilerGeneratedAttribute]
private string <EnsureInput>b__19_0(int i);
}
public class Monodoc.Topic : object {
    public string Caption;
    public string SortKey;
    public string Url;
    public Topic(string caption, string sort_key, string url);
}
public class Monodoc.Tree : Node {
    public static long CurrentVersionNumber;
    private static int VersionNumberKey;
    public HelpSource HelpSource;
    private FileStream InputStream;
    private BinaryReader InputReader;
    [CompilerGeneratedAttribute]
private long <VersionNumber>k__BackingField;
    public Node RootNode { get; }
    public long VersionNumber { get; private set; }
    internal bool ForceResort { get; }
    public Tree(HelpSource hs, string filename);
    public Tree(HelpSource hs, string caption, string url);
    public Tree(HelpSource hs, Node parent, string caption, string element);
    public void Save(string file);
    public Node get_RootNode();
    [CompilerGeneratedAttribute]
public long get_VersionNumber();
    [CompilerGeneratedAttribute]
private void set_VersionNumber(long value);
    private static bool GoodSig(Byte[] sig);
    public void InflateNode(Node baseNode);
    internal bool get_ForceResort();
}
public static class Monodoc.TreeDumper : object {
    private static int indent;
    private static void Indent();
    public static void PrintTree(Node node);
    public static string ExportToTocXml(Node root, string title, string desc);
}
public static class Monodoc.TypeUtils : object {
    public static bool GetNamespaceAndType(string url, String& ns, String& type);
}
public class Simplicit.Net.Lzo.LZOCompressor : object {
    private static TraceSwitch _traceSwitch;
    private Byte[] _workMemory;
    public string Version { get; }
    public string VersionDate { get; }
    private static LZOCompressor();
    private static int __lzo_init3();
    private static string lzo_version_string();
    private static string lzo_version_date();
    private static int lzo1x_1_compress(Byte[] src, int src_len, Byte[] dst, Int32& dst_len, Byte[] wrkmem);
    private static int lzo1x_decompress(Byte[] src, int src_len, Byte[] dst, Int32& dst_len, Byte[] wrkmem);
    public string get_Version();
    public string get_VersionDate();
    public Byte[] Compress(Byte[] src);
    public Byte[] Decompress(Byte[] src);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
