[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class ProtoBuf.BclHelpers : object {
    private static Func`2<Type, object> getUninitializedObject;
    private static int FieldTimeSpanValue;
    private static int FieldTimeSpanScale;
    private static int FieldTimeSpanKind;
    internal static DateTime[] EpochOrigin;
    private static DateTime TimestampEpoch;
    private static int FieldDecimalLow;
    private static int FieldDecimalHigh;
    private static int FieldDecimalSignScale;
    private static int FieldGuidLow;
    private static int FieldGuidHigh;
    private static int FieldExistingObjectKey;
    private static int FieldNewObjectKey;
    private static int FieldExistingTypeKey;
    private static int FieldNewTypeKey;
    private static int FieldTypeName;
    private static int FieldObject;
    private static BclHelpers();
    public static object GetUninitializedObject(Type type);
    internal static object TryGetUninitializedObjectWithFormatterServices(Type type);
    public static void WriteTimeSpan(TimeSpan timeSpan, ProtoWriter dest);
    private static void WriteTimeSpanImpl(TimeSpan timeSpan, ProtoWriter dest, DateTimeKind kind);
    public static TimeSpan ReadTimeSpan(ProtoReader source);
    public static TimeSpan ReadDuration(ProtoReader source);
    public static void WriteDuration(TimeSpan value, ProtoWriter dest);
    private static void WriteSecondsNanos(long seconds, int nanos, ProtoWriter dest);
    public static DateTime ReadTimestamp(ProtoReader source);
    public static void WriteTimestamp(DateTime value, ProtoWriter dest);
    private static TimeSpan FromDurationSeconds(long seconds, int nanos);
    private static long ToDurationSeconds(TimeSpan value, Int32& nanos);
    public static DateTime ReadDateTime(ProtoReader source);
    public static void WriteDateTime(DateTime value, ProtoWriter dest);
    public static void WriteDateTimeWithKind(DateTime value, ProtoWriter dest);
    private static void WriteDateTimeImpl(DateTime value, ProtoWriter dest, bool includeKind);
    private static long ReadTimeSpanTicks(ProtoReader source, DateTimeKind& kind);
    public static decimal ReadDecimal(ProtoReader reader);
    public static void WriteDecimal(decimal value, ProtoWriter writer);
    public static void WriteGuid(Guid value, ProtoWriter dest);
    public static Guid ReadGuid(ProtoReader source);
    public static object ReadNetObject(object value, ProtoReader source, int key, Type type, NetObjectOptions options);
    public static void WriteNetObject(object value, ProtoWriter dest, int key, NetObjectOptions options);
}
public class ProtoBuf.BufferExtension : object {
    private Byte[] buffer;
    private sealed virtual override void ProtoBuf.IExtensionResettable.Reset();
    private sealed virtual override int ProtoBuf.IExtension.GetLength();
    private sealed virtual override Stream ProtoBuf.IExtension.BeginAppend();
    private sealed virtual override void ProtoBuf.IExtension.EndAppend(Stream stream, bool commit);
    private sealed virtual override Stream ProtoBuf.IExtension.BeginQuery();
    private sealed virtual override void ProtoBuf.IExtension.EndQuery(Stream stream);
}
internal class ProtoBuf.BufferPool : object {
    private static int POOL_SIZE;
    internal static int BUFFER_LENGTH;
    private static CachedBuffer[] Pool;
    private static int MaxByteArraySize;
    private static BufferPool();
    internal static void Flush();
    internal static Byte[] GetBuffer();
    internal static Byte[] GetBuffer(int minSize);
    internal static Byte[] GetCachedBuffer(int minSize);
    internal static void ResizeAndFlushLeft(Byte[]& buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes);
    internal static void ReleaseBufferToPool(Byte[]& buffer);
}
[IsReadOnlyAttribute]
internal class ProtoBuf.Compiler.CodeLabel : ValueType {
    public Label Value;
    public int Index;
    public CodeLabel(Label value, int index);
}
internal class ProtoBuf.Compiler.CompilerContext : object {
    private DynamicMethod method;
    private static int next;
    private bool isStatic;
    private SerializerPair[] methodPairs;
    private bool isWriter;
    private bool nonPublic;
    private Local inputValue;
    private string assemblyName;
    private ILGenerator il;
    private MutableList locals;
    private int nextLabel;
    private BasicList knownTrustedAssemblies;
    private BasicList knownUntrustedAssemblies;
    private TypeModel model;
    private ILVersion metadataVersion;
    public TypeModel Model { get; }
    internal bool NonPublic { get; }
    public Local InputValue { get; }
    public ILVersion MetadataVersion { get; }
    internal CompilerContext(ILGenerator il, bool isStatic, bool isWriter, SerializerPair[] methodPairs, TypeModel model, ILVersion metadataVersion, string assemblyName, Type inputType, string traceName);
    private CompilerContext(Type associatedType, bool isWriter, bool isStatic, TypeModel model, Type inputType);
    public TypeModel get_Model();
    internal CodeLabel DefineLabel();
    [ConditionalAttribute("DEBUG_COMPILE")]
private void TraceCompile(string value);
    internal void MarkLabel(CodeLabel label);
    public static ProtoSerializer BuildSerializer(IProtoSerializer head, TypeModel model);
    public static ProtoDeserializer BuildDeserializer(IProtoSerializer head, TypeModel model);
    internal void Return();
    private static bool IsObject(Type type);
    internal void CastToObject(Type type);
    internal void CastFromObject(Type type);
    internal MethodBuilder GetDedicatedMethod(int metaKey, bool read);
    internal int MapMetaKeyToCompiledKey(int metaKey);
    internal bool get_NonPublic();
    public Local get_InputValue();
    private void Emit(OpCode opcode);
    public void LoadValue(string value);
    public void LoadValue(float value);
    public void LoadValue(double value);
    public void LoadValue(long value);
    public void LoadValue(int value);
    internal LocalBuilder GetFromPool(Type type);
    internal void ReleaseToPool(LocalBuilder value);
    public void LoadReaderWriter();
    public void StoreValue(Local local);
    public void LoadValue(Local local);
    public Local GetLocalWithValue(Type type, Local fromValue);
    internal void EmitBasicRead(string methodName, Type expectedType);
    internal void EmitBasicRead(Type helperType, string methodName, Type expectedType);
    internal void EmitBasicWrite(string methodName, Local fromValue);
    private MethodInfo GetWriterMethod(string methodName);
    internal void EmitWrite(Type helperType, string methodName, Local valueFrom);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, Type targetType);
    public void LoadNullRef();
    internal void WriteNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom);
    internal void ReadNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom);
    public void EmitCtor(Type type);
    public void EmitCtor(ConstructorInfo ctor);
    public void InitLocal(Type type, Local target);
    public void EmitCtor(Type type, Type[] parameterTypes);
    private bool InternalsVisible(Assembly assembly);
    internal void CheckAccessibility(MemberInfo& member);
    public void LoadValue(FieldInfo field);
    public void StoreValue(FieldInfo field);
    public void LoadValue(PropertyInfo property);
    public void StoreValue(PropertyInfo property);
    internal static void LoadValue(ILGenerator il, int value);
    private bool UseShortForm(Local local);
    internal void LoadAddress(Local local, Type type, bool evenIfClass);
    internal void Branch(CodeLabel label, bool short);
    internal void BranchIfFalse(CodeLabel label, bool short);
    internal void BranchIfTrue(CodeLabel label, bool short);
    internal void BranchIfEqual(CodeLabel label, bool short);
    internal void CopyValue();
    internal void BranchIfGreater(CodeLabel label, bool short);
    internal void BranchIfLess(CodeLabel label, bool short);
    internal void DiscardValue();
    public void Subtract();
    public void Switch(CodeLabel[] jumpTable);
    internal void EndFinally();
    internal void BeginFinally();
    internal void EndTry(CodeLabel label, bool short);
    internal CodeLabel BeginTry();
    internal void Constrain(Type type);
    internal void TryCast(Type type);
    internal void Cast(Type type);
    public IDisposable Using(Local local);
    internal void Add();
    internal void LoadLength(Local arr, bool zeroIfNull);
    internal void CreateArray(Type elementType, Local length);
    internal void LoadArrayValue(Local arr, Local i);
    internal void LoadValue(Type type);
    internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void LoadValue(decimal value);
    internal void LoadValue(Guid value);
    internal void LoadSerializationContext();
    internal Type MapType(Type type);
    public ILVersion get_MetadataVersion();
    internal bool AllowInternal(PropertyInfo property);
}
internal class ProtoBuf.Compiler.Local : object {
    private LocalBuilder value;
    private Type type;
    private CompilerContext ctx;
    internal LocalBuilder Value { get; }
    public Type Type { get; }
    private Local(LocalBuilder value, Type type);
    internal Local(CompilerContext ctx, Type type);
    internal LocalBuilder get_Value();
    public Type get_Type();
    public Local AsCopy();
    public sealed virtual void Dispose();
    internal bool IsSame(Local other);
}
internal class ProtoBuf.Compiler.ProtoDeserializer : MulticastDelegate {
    public ProtoDeserializer(object object, IntPtr method);
    public virtual object Invoke(object value, ProtoReader source);
    public virtual IAsyncResult BeginInvoke(object value, ProtoReader source, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class ProtoBuf.Compiler.ProtoSerializer : MulticastDelegate {
    public ProtoSerializer(object object, IntPtr method);
    public virtual void Invoke(object value, ProtoWriter dest);
    public virtual IAsyncResult BeginInvoke(object value, ProtoWriter dest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum ProtoBuf.DataFormat : Enum {
    public int value__;
    public static DataFormat Default;
    public static DataFormat ZigZag;
    public static DataFormat TwosComplement;
    public static DataFormat FixedSize;
    public static DataFormat Group;
    public static DataFormat WellKnown;
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion128 : ValueType {
    private int _discriminator;
    public long Int64;
    public ulong UInt64;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public double Double;
    public DateTime DateTime;
    public TimeSpan TimeSpan;
    public Guid Guid;
    private long _lo;
    private long _hi;
    public int Discriminator { get; }
    private static DiscriminatedUnion128();
    private DiscriminatedUnion128(int discriminator);
    public DiscriminatedUnion128(int discriminator, long value);
    public DiscriminatedUnion128(int discriminator, int value);
    public DiscriminatedUnion128(int discriminator, ulong value);
    public DiscriminatedUnion128(int discriminator, UInt32 value);
    public DiscriminatedUnion128(int discriminator, float value);
    public DiscriminatedUnion128(int discriminator, double value);
    public DiscriminatedUnion128(int discriminator, bool value);
    public DiscriminatedUnion128(int discriminator, Nullable`1<DateTime> value);
    public DiscriminatedUnion128(int discriminator, Nullable`1<TimeSpan> value);
    public DiscriminatedUnion128(int discriminator, Nullable`1<Guid> value);
    private DiscriminatedUnion128(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion128& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion128Object : ValueType {
    private int _discriminator;
    public long Int64;
    public ulong UInt64;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public double Double;
    public DateTime DateTime;
    public TimeSpan TimeSpan;
    public Guid Guid;
    public object Object;
    private long _lo;
    private long _hi;
    public int Discriminator { get; }
    private static DiscriminatedUnion128Object();
    private DiscriminatedUnion128Object(int discriminator);
    public DiscriminatedUnion128Object(int discriminator, long value);
    public DiscriminatedUnion128Object(int discriminator, int value);
    public DiscriminatedUnion128Object(int discriminator, ulong value);
    public DiscriminatedUnion128Object(int discriminator, UInt32 value);
    public DiscriminatedUnion128Object(int discriminator, float value);
    public DiscriminatedUnion128Object(int discriminator, double value);
    public DiscriminatedUnion128Object(int discriminator, bool value);
    public DiscriminatedUnion128Object(int discriminator, object value);
    public DiscriminatedUnion128Object(int discriminator, Nullable`1<DateTime> value);
    public DiscriminatedUnion128Object(int discriminator, Nullable`1<TimeSpan> value);
    public DiscriminatedUnion128Object(int discriminator, Nullable`1<Guid> value);
    private DiscriminatedUnion128Object(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion128Object& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion32 : ValueType {
    private int _discriminator;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public int Discriminator { get; }
    private DiscriminatedUnion32(int discriminator);
    public DiscriminatedUnion32(int discriminator, int value);
    public DiscriminatedUnion32(int discriminator, UInt32 value);
    public DiscriminatedUnion32(int discriminator, float value);
    public DiscriminatedUnion32(int discriminator, bool value);
    private DiscriminatedUnion32(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion32& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion32Object : ValueType {
    private int _discriminator;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public object Object;
    public int Discriminator { get; }
    private DiscriminatedUnion32Object(int discriminator);
    public DiscriminatedUnion32Object(int discriminator, int value);
    public DiscriminatedUnion32Object(int discriminator, UInt32 value);
    public DiscriminatedUnion32Object(int discriminator, float value);
    public DiscriminatedUnion32Object(int discriminator, bool value);
    public DiscriminatedUnion32Object(int discriminator, object value);
    private DiscriminatedUnion32Object(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion32Object& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion64 : ValueType {
    private int _discriminator;
    public long Int64;
    public ulong UInt64;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public double Double;
    public DateTime DateTime;
    public TimeSpan TimeSpan;
    public int Discriminator { get; }
    private static DiscriminatedUnion64();
    private DiscriminatedUnion64(int discriminator);
    public DiscriminatedUnion64(int discriminator, long value);
    public DiscriminatedUnion64(int discriminator, int value);
    public DiscriminatedUnion64(int discriminator, ulong value);
    public DiscriminatedUnion64(int discriminator, UInt32 value);
    public DiscriminatedUnion64(int discriminator, float value);
    public DiscriminatedUnion64(int discriminator, double value);
    public DiscriminatedUnion64(int discriminator, bool value);
    public DiscriminatedUnion64(int discriminator, Nullable`1<DateTime> value);
    public DiscriminatedUnion64(int discriminator, Nullable`1<TimeSpan> value);
    private DiscriminatedUnion64(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion64& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnion64Object : ValueType {
    private int _discriminator;
    public long Int64;
    public ulong UInt64;
    public int Int32;
    public UInt32 UInt32;
    public bool Boolean;
    public float Single;
    public double Double;
    public DateTime DateTime;
    public TimeSpan TimeSpan;
    public object Object;
    public int Discriminator { get; }
    private static DiscriminatedUnion64Object();
    private DiscriminatedUnion64Object(int discriminator);
    public DiscriminatedUnion64Object(int discriminator, long value);
    public DiscriminatedUnion64Object(int discriminator, int value);
    public DiscriminatedUnion64Object(int discriminator, ulong value);
    public DiscriminatedUnion64Object(int discriminator, UInt32 value);
    public DiscriminatedUnion64Object(int discriminator, float value);
    public DiscriminatedUnion64Object(int discriminator, double value);
    public DiscriminatedUnion64Object(int discriminator, bool value);
    public DiscriminatedUnion64Object(int discriminator, object value);
    public DiscriminatedUnion64Object(int discriminator, Nullable`1<DateTime> value);
    public DiscriminatedUnion64Object(int discriminator, Nullable`1<TimeSpan> value);
    private DiscriminatedUnion64Object(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnion64Object& value, int discriminator);
    public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class ProtoBuf.DiscriminatedUnionObject : ValueType {
    public object Object;
    [CompilerGeneratedAttribute]
private int <Discriminator>k__BackingField;
    public int Discriminator { get; }
    public DiscriminatedUnionObject(int discriminator, object value);
    private DiscriminatedUnionObject(SerializationInfo info, StreamingContext context);
    public bool Is(int discriminator);
    public static void Reset(DiscriminatedUnionObject& value, int discriminator);
    [CompilerGeneratedAttribute]
public int get_Discriminator();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class ProtoBuf.Extensible : object {
    private IExtension extensionObject;
    private sealed virtual override IExtension ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing);
    protected virtual IExtension GetExtensionObject(bool createIfMissing);
    public static IExtension GetExtensionObject(IExtension& extensionObject, bool createIfMissing);
    public static void AppendValue(IExtensible instance, int tag, TValue value);
    public static void AppendValue(IExtensible instance, int tag, DataFormat format, TValue value);
    public static TValue GetValue(IExtensible instance, int tag);
    public static TValue GetValue(IExtensible instance, int tag, DataFormat format);
    public static bool TryGetValue(IExtensible instance, int tag, TValue& value);
    public static bool TryGetValue(IExtensible instance, int tag, DataFormat format, TValue& value);
    public static bool TryGetValue(IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, TValue& value);
    public static IEnumerable`1<TValue> GetValues(IExtensible instance, int tag);
    public static IEnumerable`1<TValue> GetValues(IExtensible instance, int tag, DataFormat format);
    public static bool TryGetValue(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, Object& value);
    public static IEnumerable GetValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format);
    public static void AppendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value);
}
internal static class ProtoBuf.ExtensibleUtil : object {
    [IteratorStateMachineAttribute("ProtoBuf.ExtensibleUtil/<GetExtendedValues>d__0`1")]
internal static IEnumerable`1<TValue> GetExtendedValues(IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag);
    [IteratorStateMachineAttribute("ProtoBuf.ExtensibleUtil/<GetExtendedValues>d__1")]
internal static IEnumerable GetExtendedValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag);
    internal static void AppendExtendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value);
}
internal class ProtoBuf.Helpers : object {
    public static Type[] EmptyTypes;
    private static Type[] knownTypes;
    private static ProtoTypeCode[] knownCodes;
    private static Helpers();
    public static StringBuilder AppendLine(StringBuilder builder);
    [ConditionalAttribute("DEBUG")]
public static void DebugWriteLine(string message, object obj);
    [ConditionalAttribute("DEBUG")]
public static void DebugWriteLine(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceWriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition);
    public static void Sort(Int32[] keys, Object[] values);
    internal static MemberInfo GetInstanceMember(TypeInfo declaringType, string name);
    internal static MethodInfo GetInstanceMethod(Type declaringType, string name);
    internal static MethodInfo GetInstanceMethod(TypeInfo declaringType, string name);
    internal static MethodInfo GetStaticMethod(Type declaringType, string name);
    internal static MethodInfo GetStaticMethod(TypeInfo declaringType, string name);
    internal static MethodInfo GetStaticMethod(Type declaringType, string name, Type[] parameterTypes);
    internal static MethodInfo GetInstanceMethod(Type declaringType, string name, Type[] parameterTypes);
    internal static MethodInfo GetInstanceMethod(TypeInfo declaringType, string name, Type[] types);
    internal static bool IsSubclassOf(Type type, Type baseClass);
    public static ProtoTypeCode GetTypeCode(Type type);
    internal static Type GetUnderlyingType(Type type);
    internal static bool IsValueType(Type type);
    internal static bool IsSealed(Type type);
    internal static bool IsClass(Type type);
    internal static bool IsEnum(Type type);
    internal static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic, bool allowInternal);
    internal static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic, bool allowInternal);
    private static bool IsMatch(ParameterInfo[] parameters, Type[] parameterTypes);
    internal static ConstructorInfo GetConstructor(Type type, Type[] parameterTypes, bool nonPublic);
    internal static ConstructorInfo GetConstructor(TypeInfo type, Type[] parameterTypes, bool nonPublic);
    internal static ConstructorInfo[] GetConstructors(TypeInfo typeInfo, bool nonPublic);
    internal static PropertyInfo GetProperty(Type type, string name, bool nonPublic);
    internal static PropertyInfo GetProperty(TypeInfo type, string name, bool nonPublic);
    internal static object ParseEnum(Type type, string value);
    internal static MemberInfo[] GetInstanceFieldsAndProperties(Type type, bool publicOnly);
    internal static Type GetMemberType(MemberInfo member);
    internal static bool IsAssignableFrom(Type target, Type type);
    internal static Assembly GetAssembly(Type type);
    internal static Byte[] GetBuffer(MemoryStream ms);
}
public interface ProtoBuf.IExtensible {
    public abstract virtual IExtension GetExtensionObject(bool createIfMissing);
}
public interface ProtoBuf.IExtension {
    public abstract virtual Stream BeginAppend();
    public abstract virtual void EndAppend(Stream stream, bool commit);
    public abstract virtual Stream BeginQuery();
    public abstract virtual void EndQuery(Stream stream);
    public abstract virtual int GetLength();
}
public interface ProtoBuf.IExtensionResettable {
    public abstract virtual void Reset();
}
public interface ProtoBuf.IMeasuredProtoOutput`1 {
    public abstract virtual MeasureState`1<T> Measure(T value, object userState);
    public abstract virtual void Serialize(MeasureState`1<T> measured, TOutput destination);
}
public enum ProtoBuf.ImplicitFields : Enum {
    public int value__;
    public static ImplicitFields None;
    public static ImplicitFields AllPublic;
    public static ImplicitFields AllFields;
}
public interface ProtoBuf.IProtoInput`1 {
    public abstract virtual T Deserialize(TInput source, T value, object userState);
}
public interface ProtoBuf.IProtoOutput`1 {
    public abstract virtual void Serialize(TOutput destination, T value, object userState);
}
public class ProtoBuf.MeasureState`1 : ValueType {
    public long Length { get; }
    public sealed virtual void Dispose();
    public long get_Length();
}
[FlagsAttribute]
public enum ProtoBuf.MemberSerializationOptions : Enum {
    public int value__;
    public static MemberSerializationOptions None;
    public static MemberSerializationOptions Packed;
    public static MemberSerializationOptions Required;
    public static MemberSerializationOptions AsReference;
    public static MemberSerializationOptions DynamicType;
    public static MemberSerializationOptions OverwriteList;
    public static MemberSerializationOptions AsReferenceHasValue;
}
internal abstract class ProtoBuf.Meta.AttributeMap : object {
    public Type AttributeType { get; }
    public object Target { get; }
    public virtual string ToString();
    public abstract virtual bool TryGet(string key, bool publicOnly, Object& value);
    public bool TryGet(string key, Object& value);
    public abstract virtual Type get_AttributeType();
    public static AttributeMap[] Create(TypeModel model, Type type, bool inherit);
    public static AttributeMap[] Create(TypeModel model, MemberInfo member, bool inherit);
    public static AttributeMap[] Create(TypeModel model, Assembly assembly);
    public abstract virtual object get_Target();
}
[DefaultMemberAttribute("Item")]
internal class ProtoBuf.Meta.BasicList : object {
    private static Node nil;
    protected Node head;
    public object Item { get; }
    public int Count { get; }
    private static BasicList();
    public void CopyTo(Array array, int offset);
    public int Add(object value);
    public object get_Item(int index);
    public void Trim();
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public NodeEnumerator GetEnumerator();
    internal int IndexOf(MatchPredicate predicate, object ctx);
    internal int IndexOfString(string value);
    internal int IndexOfReference(object instance);
    internal bool Contains(object value);
    internal static BasicList GetContiguousGroups(Int32[] keys, Object[] values);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.CallbackSet : object {
    private MetaType metaType;
    private MethodInfo beforeSerialize;
    private MethodInfo afterSerialize;
    private MethodInfo beforeDeserialize;
    private MethodInfo afterDeserialize;
    internal MethodInfo Item { get; }
    public MethodInfo BeforeSerialize { get; public set; }
    public MethodInfo BeforeDeserialize { get; public set; }
    public MethodInfo AfterSerialize { get; public set; }
    public MethodInfo AfterDeserialize { get; public set; }
    public bool NonTrivial { get; }
    internal CallbackSet(MetaType metaType);
    internal MethodInfo get_Item(CallbackType callbackType);
    internal static bool CheckCallbackParameters(TypeModel model, MethodInfo method);
    private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback);
    internal static Exception CreateInvalidCallbackSignature(MethodInfo method);
    public MethodInfo get_BeforeSerialize();
    public void set_BeforeSerialize(MethodInfo value);
    public MethodInfo get_BeforeDeserialize();
    public void set_BeforeDeserialize(MethodInfo value);
    public MethodInfo get_AfterSerialize();
    public void set_AfterSerialize(MethodInfo value);
    public MethodInfo get_AfterDeserialize();
    public void set_AfterDeserialize(MethodInfo value);
    public bool get_NonTrivial();
}
public class ProtoBuf.Meta.LockContentedEventArgs : EventArgs {
    private string ownerStackTrace;
    public string OwnerStackTrace { get; }
    internal LockContentedEventArgs(string ownerStackTrace);
    public string get_OwnerStackTrace();
}
public class ProtoBuf.Meta.LockContentedEventHandler : MulticastDelegate {
    public LockContentedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LockContentedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, LockContentedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.MetaType : object {
    private MetaType baseType;
    private BasicList subTypes;
    internal static TypeInfo ienumerable;
    private CallbackSet callbacks;
    private string name;
    private MethodInfo factory;
    private RuntimeTypeModel model;
    private TypeInfo typeInfo;
    private Type type;
    private IProtoTypeSerializer serializer;
    private Type constructType;
    private Type surrogate;
    private BasicList fields;
    private static ushort OPTIONS_Pending;
    private static ushort OPTIONS_EnumPassThru;
    private static ushort OPTIONS_Frozen;
    private static ushort OPTIONS_PrivateOnApi;
    private static ushort OPTIONS_SkipConstructor;
    private static ushort OPTIONS_AsReferenceDefault;
    private static ushort OPTIONS_AutoTuple;
    private static ushort OPTIONS_IgnoreListHandling;
    private static ushort OPTIONS_IsGroup;
    private UInt16 modreq(System.Runtime.CompilerServices.IsVolatile) flags;
    private IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.Serializer { get; }
    public MetaType BaseType { get; }
    internal TypeModel Model { get; }
    public bool IncludeSerializerMethod { get; public set; }
    public bool AsReferenceDefault { get; public set; }
    public bool HasCallbacks { get; }
    public bool HasSubtypes { get; }
    public CallbackSet Callbacks { get; }
    private bool IsValueType { get; }
    public string Name { get; public set; }
    public Type Type { get; }
    internal IProtoTypeSerializer Serializer { get; }
    internal bool IsList { get; }
    public bool UseConstructor { get; public set; }
    public Type ConstructType { get; public set; }
    public ValueMember Item { get; }
    public ValueMember Item { get; }
    public bool EnumPassthru { get; public set; }
    public bool IgnoreListHandling { get; public set; }
    internal bool Pending { get; internal set; }
    internal IEnumerable Fields { get; }
    internal bool IsAutoTuple { get; }
    public bool IsGroup { get; public set; }
    internal MetaType(RuntimeTypeModel model, Type type, MethodInfo factory);
    private static MetaType();
    public virtual string ToString();
    private sealed virtual override IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.get_Serializer();
    public MetaType get_BaseType();
    internal TypeModel get_Model();
    public bool get_IncludeSerializerMethod();
    public void set_IncludeSerializerMethod(bool value);
    public bool get_AsReferenceDefault();
    public void set_AsReferenceDefault(bool value);
    private bool IsValidSubType(Type subType);
    public MetaType AddSubType(int fieldNumber, Type derivedType);
    public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat);
    private void SetBaseType(MetaType baseType);
    public bool get_HasCallbacks();
    public bool get_HasSubtypes();
    public CallbackSet get_Callbacks();
    private bool get_IsValueType();
    public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize);
    public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize);
    internal string GetSchemaTypeName();
    public string get_Name();
    public void set_Name(string value);
    public MetaType SetFactory(MethodInfo factory);
    public MetaType SetFactory(string factory);
    private MethodInfo ResolveMethod(string name, bool instance);
    internal static Exception InbuiltType(Type type);
    protected internal void ThrowIfFrozen();
    public Type get_Type();
    internal IProtoTypeSerializer get_Serializer();
    internal bool get_IsList();
    private IProtoTypeSerializer BuildSerializer();
    private static Type GetBaseType(MetaType type);
    internal static bool GetAsReferenceDefault(RuntimeTypeModel model, Type type);
    internal void ApplyDefaultBehaviour();
    private static void ApplyDefaultBehaviour_AddMembers(TypeModel model, AttributeFamily family, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, BasicList members, MemberInfo member, Boolean& forced, bool isPublic, bool isField, Type& effectiveType, Boolean& hasConflictingEnumValue, MemberInfo backingMember);
    private static MethodInfo Coalesce(MethodInfo[] arr, int x, int y);
    internal static AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes);
    internal static ConstructorInfo ResolveTupleConstructor(Type type, MemberInfo[]& mappedMembers);
    private static void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, MethodInfo[]& callbacks, int index);
    private static bool HasFamily(AttributeFamily value, AttributeFamily required);
    private static ProtoMemberAttribute NormalizeProtoMember(TypeModel model, MemberInfo member, AttributeFamily family, bool forced, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferByTagName, Boolean& hasConflictingEnumValue, MemberInfo backingMember);
    private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute);
    private static void GetDataFormat(DataFormat& value, AttributeMap attrib, string memberName);
    private static void GetIgnore(Boolean& ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName);
    private static void GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName);
    private static bool GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName, bool publicOnly);
    private static void GetFieldNumber(Int32& value, AttributeMap attrib, string memberName);
    private static void GetFieldName(String& name, AttributeMap attrib, string memberName);
    private static AttributeMap GetAttribute(AttributeMap[] attribs, string fullName);
    public MetaType Add(int fieldNumber, string memberName);
    public ValueMember AddField(int fieldNumber, string memberName);
    public bool get_UseConstructor();
    public void set_UseConstructor(bool value);
    public Type get_ConstructType();
    public void set_ConstructType(Type value);
    public MetaType Add(string memberName);
    public void SetSurrogate(Type surrogateType);
    internal MetaType GetSurrogateOrSelf();
    internal MetaType GetSurrogateOrBaseOrSelf(bool deep);
    private int GetNextFieldNumber();
    public MetaType Add(String[] memberNames);
    public MetaType Add(int fieldNumber, string memberName, object defaultValue);
    public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType);
    public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType);
    private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue);
    internal static void ResolveListTypes(TypeModel model, Type type, Type& itemType, Type& defaultType);
    private void Add(ValueMember member);
    public ValueMember get_Item(int fieldNumber);
    public ValueMember get_Item(MemberInfo member);
    public ValueMember[] GetFields();
    public SubType[] GetSubtypes();
    internal IEnumerable`1<Type> GetAllGenericArguments();
    [IteratorStateMachineAttribute("ProtoBuf.Meta.MetaType/<GetAllGenericArguments>d__104")]
private static IEnumerable`1<Type> GetAllGenericArguments(Type type);
    public void CompileInPlace();
    internal bool IsDefined(int fieldNumber);
    internal int GetKey(bool demand, bool getBaseKey);
    internal EnumPair[] GetEnumMap();
    public bool get_EnumPassthru();
    public void set_EnumPassthru(bool value);
    public bool get_IgnoreListHandling();
    public void set_IgnoreListHandling(bool value);
    internal bool get_Pending();
    internal void set_Pending(bool value);
    private bool HasFlag(ushort flag);
    private void SetFlag(ushort flag, bool value, bool throwIfFrozen);
    internal static MetaType GetRootType(MetaType source);
    internal bool IsPrepared();
    internal IEnumerable get_Fields();
    internal static StringBuilder NewLine(StringBuilder builder, int indent);
    internal bool get_IsAutoTuple();
    public bool get_IsGroup();
    public void set_IsGroup(bool value);
    internal void WriteSchema(StringBuilder builder, int indent, CommonImports& imports, ProtoSyntax syntax);
    private static StringBuilder AddOption(StringBuilder builder, Boolean& hasOption);
    private static StringBuilder CloseOption(StringBuilder builder, Boolean& hasOption);
    private static bool IsImplicitDefault(object value);
    private static bool CanPack(Type type);
}
[DefaultMemberAttribute("Item")]
internal class ProtoBuf.Meta.MutableList : BasicList {
    public object Item { get; public set; }
    public object get_Item(int index);
    public void set_Item(int index, object value);
    public void RemoveLast();
    public void Clear();
}
public enum ProtoBuf.Meta.ProtoSyntax : Enum {
    public int value__;
    public static ProtoSyntax Proto2;
    public static ProtoSyntax Proto3;
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.RuntimeTypeModel : TypeModel {
    private ushort options;
    private static ushort OPTIONS_InferTagFromNameDefault;
    private static ushort OPTIONS_IsDefaultModel;
    private static ushort OPTIONS_Frozen;
    private static ushort OPTIONS_AutoAddMissingTypes;
    private static ushort OPTIONS_AutoCompile;
    private static ushort OPTIONS_UseImplicitZeroDefaults;
    private static ushort OPTIONS_AllowParseableTypes;
    private static ushort OPTIONS_AutoAddProtoContractTypesOnly;
    private static ushort OPTIONS_IncludeDateTimeKind;
    private static ushort OPTIONS_DoNotInternStrings;
    private static MatchPredicate MetaTypeFinder;
    private static MatchPredicate BasicTypeFinder;
    private BasicList basicTypes;
    private BasicList types;
    private static int KnownTypes_Array;
    private static int KnownTypes_Dictionary;
    private static int KnownTypes_Hashtable;
    private static int KnownTypes_ArrayCutoff;
    private int metadataTimeoutMilliseconds;
    private int contentionCounter;
    [CompilerGeneratedAttribute]
private LockContentedEventHandler LockContended;
    private MethodInfo defaultFactory;
    public bool InferTagFromNameDefault { get; public set; }
    public bool AutoAddProtoContractTypesOnly { get; public set; }
    public bool UseImplicitZeroDefaults { get; public set; }
    public bool AllowParseableTypes { get; public set; }
    public bool IncludeDateTimeKind { get; public set; }
    public bool InternStrings { get; public set; }
    public static RuntimeTypeModel Default { get; }
    public MetaType Item { get; }
    public bool AutoCompile { get; public set; }
    public bool AutoAddMissingTypes { get; public set; }
    public int MetadataTimeoutMilliseconds { get; public set; }
    internal RuntimeTypeModel(bool isDefault);
    private static RuntimeTypeModel();
    private bool GetOption(ushort option);
    private void SetOption(ushort option, bool value);
    public bool get_InferTagFromNameDefault();
    public void set_InferTagFromNameDefault(bool value);
    public bool get_AutoAddProtoContractTypesOnly();
    public void set_AutoAddProtoContractTypesOnly(bool value);
    public bool get_UseImplicitZeroDefaults();
    public void set_UseImplicitZeroDefaults(bool value);
    public bool get_AllowParseableTypes();
    public void set_AllowParseableTypes(bool value);
    public bool get_IncludeDateTimeKind();
    public void set_IncludeDateTimeKind(bool value);
    public bool get_InternStrings();
    public void set_InternStrings(bool value);
    protected internal virtual bool SerializeDateTimeKind();
    public static RuntimeTypeModel get_Default();
    public IEnumerable GetTypes();
    public virtual string GetSchema(Type type, ProtoSyntax syntax);
    private void CascadeDependents(BasicList list, MetaType metaType);
    private void TryGetCoreSerializer(BasicList list, Type itemType);
    internal static bool EnableAutoCompile();
    public MetaType get_Item(Type type);
    internal MetaType FindWithoutAdd(Type type);
    private static bool MetaTypeFinderImpl(object value, object ctx);
    private static bool BasicTypeFinderImpl(object value, object ctx);
    private void WaitOnLock(MetaType type);
    internal IProtoSerializer TryGetBasicTypeSerializer(Type type);
    internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled);
    private MetaType RecogniseCommonTypes(Type type);
    private MetaType Create(Type type);
    public MetaType Add(Type type, bool applyDefaultBehaviour);
    public bool get_AutoCompile();
    public void set_AutoCompile(bool value);
    public bool get_AutoAddMissingTypes();
    public void set_AutoAddMissingTypes(bool value);
    private void ThrowIfFrozen();
    public void Freeze();
    protected virtual int GetKeyImpl(Type type);
    internal int GetKey(Type type, bool demand, bool getBaseKey);
    protected internal virtual void Serialize(int key, object value, ProtoWriter dest);
    protected internal virtual object Deserialize(int key, object value, ProtoReader source);
    internal ProtoSerializer GetSerializer(IProtoSerializer serializer, bool compiled);
    public void CompileInPlace();
    private void BuildAllSerializers();
    public TypeModel Compile();
    private static ILGenerator Override(TypeBuilder type, string name);
    public TypeModel Compile(CompilerOptions options);
    private void WriteConstructors(TypeBuilder type, Int32& index, SerializerPair[] methodPairs, ILGenerator& il, int knownTypesCategory, FieldBuilder knownTypes, Type knownTypesLookupType, CompilerContext ctx);
    private CompilerContext WriteSerializeDeserialize(string assemblyName, TypeBuilder type, SerializerPair[] methodPairs, ILVersion ilVersion, ILGenerator& il);
    private void WriteGetKeyImpl(TypeBuilder type, bool hasInheritance, SerializerPair[] methodPairs, ILVersion ilVersion, string assemblyName, ILGenerator& il, Int32& knownTypesCategory, FieldBuilder& knownTypes, Type& knownTypesLookupType);
    private void WriteSerializers(CompilerOptions options, string assemblyName, TypeBuilder type, Int32& index, Boolean& hasInheritance, SerializerPair[]& methodPairs, ILVersion& ilVersion);
    private TypeBuilder WriteBasicTypeModel(CompilerOptions options, string typeName, ModuleBuilder module);
    private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm);
    private static MethodBuilder EmitBoxedSerializer(TypeBuilder type, int i, Type valueType, SerializerPair[] methodPairs, TypeModel model, ILVersion ilVersion, string assemblyName);
    internal bool IsPrepared(Type type);
    internal EnumPair[] GetEnumMap(Type type);
    public int get_MetadataTimeoutMilliseconds();
    public void set_MetadataTimeoutMilliseconds(int value);
    internal void TakeLock(Int32& opaqueToken);
    private int GetContention();
    private void AddContention();
    internal void ReleaseLock(int opaqueToken);
    [CompilerGeneratedAttribute]
public void add_LockContended(LockContentedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LockContended(LockContentedEventHandler value);
    internal void ResolveListTypes(Type type, Type& itemType, Type& defaultType);
    internal string GetSchemaTypeName(Type effectiveType, DataFormat dataFormat, bool asReference, bool dynamicType, CommonImports& imports);
    public void SetDefaultFactory(MethodInfo methodInfo);
    internal void VerifyFactory(MethodInfo factory, Type type);
}
public class ProtoBuf.Meta.SubType : object {
    private int fieldNumber;
    private MetaType derivedType;
    private DataFormat dataFormat;
    private IProtoSerializer serializer;
    public int FieldNumber { get; }
    public MetaType DerivedType { get; }
    internal IProtoSerializer Serializer { get; }
    public SubType(int fieldNumber, MetaType derivedType, DataFormat format);
    public int get_FieldNumber();
    public MetaType get_DerivedType();
    internal IProtoSerializer get_Serializer();
    private IProtoSerializer BuildSerializer();
}
public class ProtoBuf.Meta.TypeFormatEventArgs : EventArgs {
    private Type type;
    private string formattedName;
    private bool typeFixed;
    public Type Type { get; public set; }
    public string FormattedName { get; public set; }
    internal TypeFormatEventArgs(string formattedName);
    internal TypeFormatEventArgs(Type type);
    public Type get_Type();
    public void set_Type(Type value);
    public string get_FormattedName();
    public void set_FormattedName(string value);
}
public class ProtoBuf.Meta.TypeFormatEventHandler : MulticastDelegate {
    public TypeFormatEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TypeFormatEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, TypeFormatEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class ProtoBuf.Meta.TypeModel : object {
    private static TypeInfo ilist;
    private Dictionary`2<Type, KnownTypeKey> knownKeys;
    [CompilerGeneratedAttribute]
private TypeFormatEventHandler DynamicTypeFormatting;
    private static TypeModel();
    internal TypeInfo MapType(TypeInfo type);
    protected internal virtual bool SerializeDateTimeKind();
    protected internal Type MapType(Type type);
    protected internal virtual Type MapType(Type type, bool demand);
    private WireType GetWireType(ProtoTypeCode code, DataFormat format, Type& type, Int32& modelKey);
    internal bool TrySerializeAuxiliaryType(ProtoWriter writer, Type type, DataFormat format, int tag, object value, bool isInsideList, object parentList);
    private void SerializeCore(ProtoWriter writer, object value);
    public void Serialize(Stream dest, object value);
    public void Serialize(Stream dest, object value, SerializationContext context);
    public void Serialize(ProtoWriter dest, object value);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int fieldNumber);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int32& bytesRead);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int64& bytesRead);
    private object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int64& bytesRead, Boolean& haveObject, SerializationContext context);
    public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver);
    public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, SerializationContext context);
    public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField);
    public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField, SerializationContext context);
    public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber);
    public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber, SerializationContext context);
    public object Deserialize(Stream source, object value, Type type);
    public object Deserialize(Stream source, object value, Type type, SerializationContext context);
    private bool PrepareDeserialize(object value, Type& type);
    public object Deserialize(Stream source, object value, Type type, int length);
    public object Deserialize(Stream source, object value, Type type, long length);
    public object Deserialize(Stream source, object value, Type type, int length, SerializationContext context);
    public object Deserialize(Stream source, object value, Type type, long length, SerializationContext context);
    public object Deserialize(ProtoReader source, object value, Type type);
    private object DeserializeCore(ProtoReader reader, Type type, object value, bool noAutoCreate);
    internal static MethodInfo ResolveListAdd(TypeModel model, Type listType, Type itemType, Boolean& isList);
    internal static Type GetListItemType(TypeModel model, Type listType);
    private static void TestEnumerableListPatterns(TypeModel model, BasicList candidates, Type iType);
    private static bool CheckDictionaryAccessors(TypeModel model, Type pair, Type value);
    private bool TryDeserializeList(TypeModel model, ProtoReader reader, DataFormat format, int tag, Type listType, Type itemType, Object& value);
    private static object CreateListInstance(Type listType, Type itemType);
    internal bool TryDeserializeAuxiliaryType(ProtoReader reader, DataFormat format, int tag, Type type, Object& value, bool skipOtherFields, bool asListItem, bool autoCreate, bool insideList, object parentListOrType);
    public static RuntimeTypeModel Create();
    protected internal static Type ResolveProxies(Type type);
    public bool IsDefined(Type type);
    protected internal int GetKey(Type& type);
    internal void ResetKeyCache();
    protected abstract virtual int GetKeyImpl(Type type);
    protected internal abstract virtual void Serialize(int key, object value, ProtoWriter dest);
    protected internal abstract virtual object Deserialize(int key, object value, ProtoReader source);
    public object DeepClone(object value);
    protected internal static void ThrowUnexpectedSubtype(Type expected, Type actual);
    protected internal static void ThrowUnexpectedType(Type type);
    internal static Exception CreateNestedListsNotSupported(Type type);
    public static void ThrowCannotCreateInstance(Type type);
    internal static string SerializeType(TypeModel model, Type type);
    internal static Type DeserializeType(TypeModel model, string value);
    public bool CanSerializeContractType(Type type);
    public bool CanSerialize(Type type);
    public bool CanSerializeBasicType(Type type);
    private bool CanSerialize(Type type, bool allowBasic, bool allowContract, bool allowLists);
    public virtual string GetSchema(Type type);
    public virtual string GetSchema(Type type, ProtoSyntax syntax);
    [CompilerGeneratedAttribute]
public void add_DynamicTypeFormatting(TypeFormatEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DynamicTypeFormatting(TypeFormatEventHandler value);
    internal virtual Type GetType(string fullName, Assembly context);
    internal static Type ResolveKnownType(string name, TypeModel model, Assembly assembly);
    private static SerializationContext CreateContext(object userState);
    private sealed virtual override T ProtoBuf.IProtoInput<System.IO.Stream>.Deserialize(Stream source, T value, object userState);
    private sealed virtual override T ProtoBuf.IProtoInput<System.ArraySegment<System.Byte>>.Deserialize(ArraySegment`1<byte> source, T value, object userState);
    private sealed virtual override T ProtoBuf.IProtoInput<System.Byte[]>.Deserialize(Byte[] source, T value, object userState);
    private sealed virtual override void ProtoBuf.IProtoOutput<System.IO.Stream>.Serialize(Stream destination, T value, object userState);
}
public class ProtoBuf.Meta.ValueMember : object {
    private int fieldNumber;
    private MemberInfo originalMember;
    private MemberInfo backingMember;
    private Type parentType;
    private Type itemType;
    private Type defaultType;
    private Type memberType;
    private object defaultValue;
    private RuntimeTypeModel model;
    private IProtoSerializer serializer;
    private DataFormat dataFormat;
    private DataFormat mapKeyFormat;
    private DataFormat mapValueFormat;
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    private string name;
    private static byte OPTIONS_IsStrict;
    private static byte OPTIONS_IsPacked;
    private static byte OPTIONS_IsRequired;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private static byte OPTIONS_AsReference;
    private static byte OPTIONS_IsMap;
    private static byte OPTIONS_DynamicType;
    private byte flags;
    public int FieldNumber { get; }
    public MemberInfo Member { get; }
    public MemberInfo BackingMember { get; public set; }
    public Type ItemType { get; }
    public Type MemberType { get; }
    public Type DefaultType { get; }
    public Type ParentType { get; }
    public object DefaultValue { get; public set; }
    internal IProtoSerializer Serializer { get; }
    public DataFormat DataFormat { get; public set; }
    public bool IsStrict { get; public set; }
    public bool IsPacked { get; public set; }
    public bool OverwriteList { get; public set; }
    public bool IsRequired { get; public set; }
    public bool AsReference { get; public set; }
    public bool DynamicType { get; public set; }
    public bool IsMap { get; public set; }
    public DataFormat MapKeyFormat { get; public set; }
    public DataFormat MapValueFormat { get; public set; }
    public string Name { get; public set; }
    public bool SupportNull { get; public set; }
    public ValueMember(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue);
    internal ValueMember(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat);
    public int get_FieldNumber();
    public MemberInfo get_Member();
    public MemberInfo get_BackingMember();
    public void set_BackingMember(MemberInfo value);
    public Type get_ItemType();
    public Type get_MemberType();
    public Type get_DefaultType();
    public Type get_ParentType();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetRawEnumValue();
    private static object ParseDefaultValue(Type type, object value);
    internal IProtoSerializer get_Serializer();
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public bool get_IsStrict();
    public void set_IsStrict(bool value);
    public bool get_IsPacked();
    public void set_IsPacked(bool value);
    public bool get_OverwriteList();
    public void set_OverwriteList(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_AsReference();
    public void set_AsReference(bool value);
    public bool get_DynamicType();
    public void set_DynamicType(bool value);
    public bool get_IsMap();
    public void set_IsMap(bool value);
    public DataFormat get_MapKeyFormat();
    public void set_MapKeyFormat(DataFormat value);
    public DataFormat get_MapValueFormat();
    public void set_MapValueFormat(DataFormat value);
    public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified);
    private void ThrowIfFrozen();
    internal bool ResolveMapTypes(Type& dictionaryType, Type& keyType, Type& valueType);
    private static bool IsValidMapKeyType(Type type);
    private IProtoSerializer BuildSerializer();
    private static WireType GetIntWireType(DataFormat format, int width);
    private static WireType GetDateTimeWireType(DataFormat format);
    internal static IProtoSerializer TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, Type type, WireType& defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes);
    internal void SetName(string name);
    public string get_Name();
    public void set_Name(string value);
    private bool HasFlag(byte flag);
    private void SetFlag(byte flag, bool value, bool throwIfFrozen);
    public bool get_SupportNull();
    public void set_SupportNull(bool value);
    internal string GetSchemaTypeName(bool applyNetObjectProxy, CommonImports& imports);
}
internal class ProtoBuf.NetObjectCache : object {
    internal static int Root;
    private MutableList underlyingList;
    private object rootObject;
    private int trapStartIndex;
    private Dictionary`2<string, int> stringKeys;
    private Dictionary`2<object, int> objectKeys;
    private MutableList List { get; }
    private MutableList get_List();
    internal object GetKeyedObject(int key);
    internal void SetKeyedObject(int key, object value);
    internal int AddObjectKey(object value, Boolean& existing);
    internal void RegisterTrappedObject(object value);
    internal void Clear();
}
public enum ProtoBuf.PrefixStyle : Enum {
    public int value__;
    public static PrefixStyle None;
    public static PrefixStyle Base128;
    public static PrefixStyle Fixed32;
    public static PrefixStyle Fixed32BigEndian;
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ProtoAfterDeserializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ProtoAfterSerializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ProtoBeforeDeserializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ProtoBeforeSerializationAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
public class ProtoBuf.ProtoContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private int implicitFirstTag;
    [CompilerGeneratedAttribute]
private ImplicitFields <ImplicitFields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataMemberOffset>k__BackingField;
    private ushort flags;
    private static ushort OPTIONS_InferTagFromName;
    private static ushort OPTIONS_InferTagFromNameHasValue;
    private static ushort OPTIONS_UseProtoMembersOnly;
    private static ushort OPTIONS_SkipConstructor;
    private static ushort OPTIONS_IgnoreListHandling;
    private static ushort OPTIONS_AsReferenceDefault;
    private static ushort OPTIONS_EnumPassthru;
    private static ushort OPTIONS_EnumPassthruHasValue;
    private static ushort OPTIONS_IsGroup;
    [CompilerGeneratedAttribute]
private Type <Surrogate>k__BackingField;
    public string Name { get; public set; }
    public int ImplicitFirstTag { get; public set; }
    public bool UseProtoMembersOnly { get; public set; }
    public bool IgnoreListHandling { get; public set; }
    public ImplicitFields ImplicitFields { get; public set; }
    public bool InferTagFromName { get; public set; }
    internal bool InferTagFromNameHasValue { get; }
    public int DataMemberOffset { get; public set; }
    public bool SkipConstructor { get; public set; }
    public bool AsReferenceDefault { get; public set; }
    public bool IsGroup { get; public set; }
    public bool EnumPassthru { get; public set; }
    public Type Surrogate { get; public set; }
    internal bool EnumPassthruHasValue { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public int get_ImplicitFirstTag();
    public void set_ImplicitFirstTag(int value);
    public bool get_UseProtoMembersOnly();
    public void set_UseProtoMembersOnly(bool value);
    public bool get_IgnoreListHandling();
    public void set_IgnoreListHandling(bool value);
    [CompilerGeneratedAttribute]
public ImplicitFields get_ImplicitFields();
    [CompilerGeneratedAttribute]
public void set_ImplicitFields(ImplicitFields value);
    public bool get_InferTagFromName();
    public void set_InferTagFromName(bool value);
    internal bool get_InferTagFromNameHasValue();
    [CompilerGeneratedAttribute]
public int get_DataMemberOffset();
    [CompilerGeneratedAttribute]
public void set_DataMemberOffset(int value);
    public bool get_SkipConstructor();
    public void set_SkipConstructor(bool value);
    public bool get_AsReferenceDefault();
    public void set_AsReferenceDefault(bool value);
    public bool get_IsGroup();
    public void set_IsGroup(bool value);
    private bool HasFlag(ushort flag);
    private void SetFlag(ushort flag, bool value);
    public bool get_EnumPassthru();
    public void set_EnumPassthru(bool value);
    [CompilerGeneratedAttribute]
public Type get_Surrogate();
    [CompilerGeneratedAttribute]
public void set_Surrogate(Type value);
    internal bool get_EnumPassthruHasValue();
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ProtoConverterAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class ProtoBuf.ProtoEnumAttribute : Attribute {
    private bool hasValue;
    private int enumValue;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Value { get; public set; }
    public string Name { get; public set; }
    public int get_Value();
    public void set_Value(int value);
    public bool HasValue();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class ProtoBuf.ProtoException : Exception {
    public ProtoException(string message);
    public ProtoException(string message, Exception innerException);
}
[AttributeUsageAttribute("384")]
public class ProtoBuf.ProtoIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public class ProtoBuf.ProtoIncludeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KnownTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private DataFormat <DataFormat>k__BackingField;
    public int Tag { get; }
    public string KnownTypeName { get; }
    public Type KnownType { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DataFormat DataFormat { get; public set; }
    public ProtoIncludeAttribute(int tag, Type knownType);
    public ProtoIncludeAttribute(int tag, string knownTypeName);
    [CompilerGeneratedAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public string get_KnownTypeName();
    public Type get_KnownType();
    [CompilerGeneratedAttribute]
public DataFormat get_DataFormat();
    [CompilerGeneratedAttribute]
public void set_DataFormat(DataFormat value);
}
[AttributeUsageAttribute("384")]
public class ProtoBuf.ProtoMapAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DataFormat <KeyFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private DataFormat <ValueFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableMap>k__BackingField;
    public DataFormat KeyFormat { get; public set; }
    public DataFormat ValueFormat { get; public set; }
    public bool DisableMap { get; public set; }
    [CompilerGeneratedAttribute]
public DataFormat get_KeyFormat();
    [CompilerGeneratedAttribute]
public void set_KeyFormat(DataFormat value);
    [CompilerGeneratedAttribute]
public DataFormat get_ValueFormat();
    [CompilerGeneratedAttribute]
public void set_ValueFormat(DataFormat value);
    [CompilerGeneratedAttribute]
public bool get_DisableMap();
    [CompilerGeneratedAttribute]
public void set_DisableMap(bool value);
}
[AttributeUsageAttribute("384")]
public class ProtoBuf.ProtoMemberAttribute : Attribute {
    internal MemberInfo Member;
    internal MemberInfo BackingMember;
    internal bool TagIsPinned;
    private string name;
    private DataFormat dataFormat;
    private int tag;
    private MemberSerializationOptions options;
    public string Name { get; public set; }
    public DataFormat DataFormat { get; public set; }
    public int Tag { get; }
    public bool IsRequired { get; public set; }
    public bool IsPacked { get; public set; }
    public bool OverwriteList { get; public set; }
    public bool AsReference { get; public set; }
    internal bool AsReferenceHasValue { get; internal set; }
    public bool DynamicType { get; public set; }
    public MemberSerializationOptions Options { get; public set; }
    public ProtoMemberAttribute(int tag);
    internal ProtoMemberAttribute(int tag, bool forced);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(ProtoMemberAttribute other);
    public string get_Name();
    public void set_Name(string value);
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public int get_Tag();
    internal void Rebase(int tag);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_IsPacked();
    public void set_IsPacked(bool value);
    public bool get_OverwriteList();
    public void set_OverwriteList(bool value);
    public bool get_AsReference();
    public void set_AsReference(bool value);
    internal bool get_AsReferenceHasValue();
    internal void set_AsReferenceHasValue(bool value);
    public bool get_DynamicType();
    public void set_DynamicType(bool value);
    public MemberSerializationOptions get_Options();
    public void set_Options(MemberSerializationOptions value);
}
[AttributeUsageAttribute("4")]
public class ProtoBuf.ProtoPartialIgnoreAttribute : ProtoIgnoreAttribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public ProtoPartialIgnoreAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
[AttributeUsageAttribute("4")]
public class ProtoBuf.ProtoPartialMemberAttribute : ProtoMemberAttribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; private set; }
    public ProtoPartialMemberAttribute(int tag, string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
}
public class ProtoBuf.ProtoReader : object {
    private Stream source;
    private Byte[] ioBuffer;
    private TypeModel model;
    private int fieldNumber;
    private int depth;
    private int ioIndex;
    private int available;
    private long position64;
    private long blockEnd64;
    private long dataRemaining64;
    private WireType wireType;
    private bool isFixedLength;
    private bool internStrings;
    private NetObjectCache netCache;
    private UInt32 trapCount;
    internal static long TO_EOF;
    private SerializationContext context;
    private static long Int64Msb;
    private static int Int32Msb;
    private Dictionary`2<string, string> stringInterner;
    private static Encoding encoding;
    private static Byte[] EmptyBlob;
    [ThreadStaticAttribute]
private static ProtoReader lastReader;
    public int FieldNumber { get; }
    public WireType WireType { get; }
    public bool InternStrings { get; public set; }
    public SerializationContext Context { get; }
    public int Position { get; }
    public long LongPosition { get; }
    public TypeModel Model { get; }
    internal NetObjectCache NetCache { get; }
    [ObsoleteAttribute("Please use ProtoReader.Create; this API may be removed in a future version", "False")]
public ProtoReader(Stream source, TypeModel model, SerializationContext context);
    [ObsoleteAttribute("Please use ProtoReader.Create; this API may be removed in a future version", "False")]
public ProtoReader(Stream source, TypeModel model, SerializationContext context, int length);
    [ObsoleteAttribute("Please use ProtoReader.Create; this API may be removed in a future version", "False")]
public ProtoReader(Stream source, TypeModel model, SerializationContext context, long length);
    private static ProtoReader();
    public int get_FieldNumber();
    public WireType get_WireType();
    public bool get_InternStrings();
    public void set_InternStrings(bool value);
    private static void Init(ProtoReader reader, Stream source, TypeModel model, SerializationContext context, long length);
    public SerializationContext get_Context();
    public sealed virtual void Dispose();
    internal int TryReadUInt32VariantWithoutMoving(bool trimNegative, UInt32& value);
    private UInt32 ReadUInt32Variant(bool trimNegative);
    private bool TryReadUInt32Variant(UInt32& value);
    public UInt32 ReadUInt32();
    public int get_Position();
    public long get_LongPosition();
    internal void Ensure(int count, bool strict);
    public short ReadInt16();
    public ushort ReadUInt16();
    public byte ReadByte();
    public sbyte ReadSByte();
    public int ReadInt32();
    private static int Zag(UInt32 ziggedValue);
    private static long Zag(ulong ziggedValue);
    public long ReadInt64();
    private int TryReadUInt64VariantWithoutMoving(UInt64& value);
    private ulong ReadUInt64Variant();
    private string Intern(string value);
    public string ReadString();
    public void ThrowEnumException(Type type, int value);
    private Exception CreateWireTypeException();
    private Exception CreateException(string message);
    public double ReadDouble();
    public static object ReadObject(object value, int key, ProtoReader reader);
    internal static object ReadTypedObject(object value, int key, ProtoReader reader, Type type);
    public static void EndSubItem(SubItemToken token, ProtoReader reader);
    public static SubItemToken StartSubItem(ProtoReader reader);
    public int ReadFieldHeader();
    public bool TryReadFieldHeader(int field);
    public TypeModel get_Model();
    public void Hint(WireType wireType);
    public void Assert(WireType wireType);
    public void SkipField();
    public ulong ReadUInt64();
    public float ReadSingle();
    public bool ReadBoolean();
    public static Byte[] AppendBytes(Byte[] value, ProtoReader reader);
    private static int ReadByteOrThrow(Stream source);
    public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber);
    public static int DirectReadLittleEndianInt32(Stream source);
    public static int DirectReadBigEndianInt32(Stream source);
    public static int DirectReadVarintInt32(Stream source);
    public static void DirectReadBytes(Stream source, Byte[] buffer, int offset, int count);
    public static Byte[] DirectReadBytes(Stream source, int count);
    public static string DirectReadString(Stream source, int length);
    public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber, Int32& bytesRead);
    public static long ReadLongLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber, Int32& bytesRead);
    private static int TryReadUInt64Variant(Stream source, UInt64& value);
    internal static void Seek(Stream source, long count, Byte[] buffer);
    internal static Exception AddErrorData(Exception exception, ProtoReader source);
    private static Exception EoF(ProtoReader source);
    public void AppendExtensionData(IExtensible instance);
    private void AppendExtensionField(ProtoWriter writer);
    public static bool HasSubValue(WireType wireType, ProtoReader source);
    internal int GetTypeKey(Type& type);
    internal NetObjectCache get_NetCache();
    internal Type DeserializeType(string value);
    internal void SetRootObject(object value);
    public static void NoteObject(object value, ProtoReader reader);
    public Type ReadType();
    internal void TrapNextObject(int newObjectKey);
    internal void CheckFullyConsumed();
    public static object Merge(ProtoReader parent, object from, object to);
    internal static ProtoReader Create(Stream source, TypeModel model, SerializationContext context, int len);
    public static ProtoReader Create(Stream source, TypeModel model, SerializationContext context, long length);
    private static ProtoReader GetRecycled();
    internal static void Recycle(ProtoReader reader);
}
internal enum ProtoBuf.ProtoTypeCode : Enum {
    public int value__;
    public static ProtoTypeCode Empty;
    public static ProtoTypeCode Unknown;
    public static ProtoTypeCode Boolean;
    public static ProtoTypeCode Char;
    public static ProtoTypeCode SByte;
    public static ProtoTypeCode Byte;
    public static ProtoTypeCode Int16;
    public static ProtoTypeCode UInt16;
    public static ProtoTypeCode Int32;
    public static ProtoTypeCode UInt32;
    public static ProtoTypeCode Int64;
    public static ProtoTypeCode UInt64;
    public static ProtoTypeCode Single;
    public static ProtoTypeCode Double;
    public static ProtoTypeCode Decimal;
    public static ProtoTypeCode DateTime;
    public static ProtoTypeCode String;
    public static ProtoTypeCode TimeSpan;
    public static ProtoTypeCode ByteArray;
    public static ProtoTypeCode Guid;
    public static ProtoTypeCode Uri;
    public static ProtoTypeCode Type;
}
public class ProtoBuf.ProtoWriter : object {
    private Stream dest;
    private TypeModel model;
    private NetObjectCache netCache;
    private int fieldNumber;
    private int flushLock;
    private WireType wireType;
    private int depth;
    private static int RecursionCheckDepth;
    private MutableList recursionStack;
    private SerializationContext context;
    private Byte[] ioBuffer;
    private int ioIndex;
    private long position64;
    private static Encoding encoding;
    private int packedFieldNumber;
    internal NetObjectCache NetCache { get; }
    internal WireType WireType { get; }
    public SerializationContext Context { get; }
    public TypeModel Model { get; }
    [ObsoleteAttribute("Please use ProtoWriter.Create; this API may be removed in a future version", "False")]
public ProtoWriter(Stream dest, TypeModel model, SerializationContext context);
    private static ProtoWriter();
    public static void WriteObject(object value, int key, ProtoWriter writer);
    public static void WriteRecursionSafeObject(object value, int key, ProtoWriter writer);
    internal static void WriteObject(object value, int key, ProtoWriter writer, PrefixStyle style, int fieldNumber);
    internal int GetTypeKey(Type& type);
    internal NetObjectCache get_NetCache();
    internal WireType get_WireType();
    public static void WriteFieldHeader(int fieldNumber, WireType wireType, ProtoWriter writer);
    internal static void WriteHeaderCore(int fieldNumber, WireType wireType, ProtoWriter writer);
    public static void WriteBytes(Byte[] data, ProtoWriter writer);
    public static void WriteBytes(Byte[] data, int offset, int length, ProtoWriter writer);
    private static void CopyRawFromStream(Stream source, ProtoWriter writer);
    private static void IncrementedAndReset(int length, ProtoWriter writer);
    public static SubItemToken StartSubItem(object instance, ProtoWriter writer);
    private void CheckRecursionStackAndPush(object instance);
    private void PopRecursionStack();
    private static SubItemToken StartSubItem(object instance, ProtoWriter writer, bool allowFixed);
    public static void EndSubItem(SubItemToken token, ProtoWriter writer);
    private static void EndSubItem(SubItemToken token, ProtoWriter writer, PrefixStyle style);
    public static ProtoWriter Create(Stream dest, TypeModel model, SerializationContext context);
    public SerializationContext get_Context();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose();
    internal static long GetLongPosition(ProtoWriter writer);
    internal static int GetPosition(ProtoWriter writer);
    private static void DemandSpace(int required, ProtoWriter writer);
    private static void TryFlushOrResize(int required, ProtoWriter writer);
    public void Close();
    internal void CheckDepthFlushlock();
    public TypeModel get_Model();
    internal static void Flush(ProtoWriter writer);
    private static void WriteUInt32Variant(UInt32 value, ProtoWriter writer);
    internal static UInt32 Zig(int value);
    internal static ulong Zig(long value);
    private static void WriteUInt64Variant(ulong value, ProtoWriter writer);
    public static void WriteString(string value, ProtoWriter writer);
    public static void WriteUInt64(ulong value, ProtoWriter writer);
    public static void WriteInt64(long value, ProtoWriter writer);
    public static void WriteUInt32(UInt32 value, ProtoWriter writer);
    public static void WriteInt16(short value, ProtoWriter writer);
    public static void WriteUInt16(ushort value, ProtoWriter writer);
    public static void WriteByte(byte value, ProtoWriter writer);
    public static void WriteSByte(sbyte value, ProtoWriter writer);
    private static void WriteInt32ToBuffer(int value, Byte[] buffer, int index);
    public static void WriteInt32(int value, ProtoWriter writer);
    public static void WriteDouble(double value, ProtoWriter writer);
    public static void WriteSingle(float value, ProtoWriter writer);
    public static void ThrowEnumException(ProtoWriter writer, object enumValue);
    internal static Exception CreateException(ProtoWriter writer);
    public static void WriteBoolean(bool value, ProtoWriter writer);
    public static void AppendExtensionData(IExtensible instance, ProtoWriter writer);
    public static void SetPackedField(int fieldNumber, ProtoWriter writer);
    public static void ClearPackedField(int fieldNumber, ProtoWriter writer);
    public static void WritePackedPrefix(int elementCount, WireType wireType, ProtoWriter writer);
    internal string SerializeType(Type type);
    public void SetRootObject(object value);
    public static void WriteType(Type value, ProtoWriter writer);
}
public class ProtoBuf.SerializationContext : object {
    private bool frozen;
    private object context;
    private static SerializationContext default;
    public object Context { get; public set; }
    internal static SerializationContext Default { get; }
    private static SerializationContext();
    internal void Freeze();
    private void ThrowIfFrozen();
    public object get_Context();
    public void set_Context(object value);
    internal static SerializationContext get_Default();
    public static StreamingContext op_Implicit(SerializationContext ctx);
    public static SerializationContext op_Implicit(StreamingContext ctx);
}
public static class ProtoBuf.Serializer : object {
    private static string ProtoBinaryField;
    public static int ListItemTag;
    public static string GetProto();
    public static string GetProto(ProtoSyntax syntax);
    public static T DeepClone(T instance);
    public static T Merge(Stream source, T instance);
    public static T Deserialize(Stream source);
    public static object Deserialize(Type type, Stream source);
    public static void Serialize(Stream destination, T instance);
    public static TTo ChangeType(TFrom instance);
    public static void Serialize(XmlWriter writer, T instance);
    public static void Merge(XmlReader reader, T instance);
    public static void PrepareSerializer();
    public static IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int fieldNumber);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style, int fieldNumber);
    public static T MergeWithLengthPrefix(Stream source, T instance, PrefixStyle style);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style, int fieldNumber);
    public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, Int32& length);
    public static bool TryReadLengthPrefix(Byte[] buffer, int index, int count, PrefixStyle style, Int32& length);
    public static void FlushPool();
}
internal class ProtoBuf.Serializers.ArrayDecorator : ProtoDecoratorBase {
    private int fieldNumber;
    private static byte OPTIONS_WritePacked;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private byte options;
    private WireType packedWireType;
    private Type arrayType;
    private Type itemType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool AppendToCollection { get; }
    private bool SupportNull { get; }
    public ArrayDecorator(TypeModel model, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, Type arrayType, bool overwriteList, bool supportNull);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private bool CanUsePackedPrefix();
    internal static bool CanUsePackedPrefix(WireType packedWireType, Type itemType);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private void EmitWriteArrayLoop(CompilerContext ctx, Local i, Local arr);
    private bool get_AppendToCollection();
    private bool get_SupportNull();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.BlobSerializer : object {
    private static Type expectedType;
    private bool overwriteList;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public BlobSerializer(TypeModel model, bool overwriteList);
    private static BlobSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.BooleanSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public BooleanSerializer(TypeModel model);
    private static BooleanSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.ByteSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public ByteSerializer(TypeModel model);
    private static ByteSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.CharSerializer : UInt16Serializer {
    private static Type expectedType;
    public Type ExpectedType { get; }
    public CharSerializer(TypeModel model);
    private static CharSerializer();
    public virtual Type get_ExpectedType();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
}
internal class ProtoBuf.Serializers.CompiledSerializer : object {
    private IProtoTypeSerializer head;
    private ProtoSerializer serializer;
    private ProtoDeserializer deserializer;
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType { get; }
    private CompiledSerializer(IProtoTypeSerializer head, TypeModel model);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public static CompiledSerializer Wrap(IProtoTypeSerializer head, TypeModel model);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
}
internal class ProtoBuf.Serializers.DateTimeSerializer : object {
    private static Type expectedType;
    private bool includeKind;
    private bool wellKnown;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DateTimeSerializer(DataFormat dataFormat, TypeModel model);
    private static DateTimeSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Serializers.DecimalSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DecimalSerializer(TypeModel model);
    private static DecimalSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.DefaultValueDecorator : ProtoDecoratorBase {
    private object defaultValue;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public DefaultValueDecorator(TypeModel model, object defaultValue, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private void EmitBeq(CompilerContext ctx, CodeLabel label, Type type);
    private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.DoubleSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DoubleSerializer(TypeModel model);
    private static DoubleSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.EnumSerializer : object {
    private Type enumType;
    private EnumPair[] map;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public EnumSerializer(Type enumType, EnumPair[] map);
    private ProtoTypeCode GetTypeCode();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private int EnumToWire(object value);
    private object WireToEnum(int value);
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, object value);
    private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, CodeLabel handler, CodeLabel continue, object value, Local local);
}
internal class ProtoBuf.Serializers.FieldDecorator : ProtoDecoratorBase {
    private FieldInfo field;
    private Type forType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public FieldDecorator(Type forType, FieldInfo field, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.GuidSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public GuidSerializer(TypeModel model);
    private static GuidSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.ImmutableCollectionDecorator : ListDecorator {
    private MethodInfo builderFactory;
    private MethodInfo add;
    private MethodInfo addRange;
    private MethodInfo finish;
    private PropertyInfo isEmpty;
    private PropertyInfo length;
    protected bool RequireAdd { get; }
    internal ImmutableCollectionDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull, MethodInfo builderFactory, PropertyInfo isEmpty, PropertyInfo length, MethodInfo add, MethodInfo addRange, MethodInfo finish);
    protected virtual bool get_RequireAdd();
    private static Type ResolveIReadOnlyCollection(Type declaredType, Type t);
    private static bool CheckIsIReadOnlyCollectionExactly(TypeInfo t);
    internal static bool IdentifyImmutable(TypeModel model, Type declaredType, MethodInfo& builderFactory, PropertyInfo& isEmpty, PropertyInfo& length, MethodInfo& add, MethodInfo& addRange, MethodInfo& finish);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int16Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int16Serializer(TypeModel model);
    private static Int16Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int32Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int32Serializer(TypeModel model);
    private static Int32Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int64Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int64Serializer(TypeModel model);
    private static Int64Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal interface ProtoBuf.Serializers.IProtoSerializer {
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public abstract virtual Type get_ExpectedType();
    public abstract virtual void Write(object value, ProtoWriter dest);
    public abstract virtual object Read(object value, ProtoReader source);
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public abstract virtual void EmitRead(CompilerContext ctx, Local entity);
}
internal interface ProtoBuf.Serializers.IProtoTypeSerializer {
    public abstract virtual bool HasCallbacks(CallbackType callbackType);
    public abstract virtual bool CanCreateInstance();
    public abstract virtual object CreateInstance(ProtoReader source);
    public abstract virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public abstract virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public abstract virtual void EmitCreateInstance(CompilerContext ctx);
}
internal interface ProtoBuf.Serializers.ISerializerProxy {
    public IProtoSerializer Serializer { get; }
    public abstract virtual IProtoSerializer get_Serializer();
}
internal class ProtoBuf.Serializers.ListDecorator : ProtoDecoratorBase {
    private byte options;
    private static byte OPTIONS_IsList;
    private static byte OPTIONS_SuppressIList;
    private static byte OPTIONS_WritePacked;
    private static byte OPTIONS_ReturnList;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private Type declaredType;
    private Type concreteType;
    private MethodInfo add;
    private int fieldNumber;
    protected WireType packedWireType;
    private static TypeInfo ienumeratorType;
    private static TypeInfo ienumerableType;
    private bool IsList { get; }
    private bool SuppressIList { get; }
    private bool WritePacked { get; }
    private bool SupportNull { get; }
    private bool ReturnList { get; }
    protected bool RequireAdd { get; }
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    protected bool AppendToCollection { get; }
    protected ListDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull);
    private static ListDecorator();
    internal static bool CanPack(WireType wireType);
    private bool get_IsList();
    private bool get_SuppressIList();
    private bool get_WritePacked();
    private bool get_SupportNull();
    private bool get_ReturnList();
    internal static ListDecorator Create(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull);
    protected virtual bool get_RequireAdd();
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    protected bool get_AppendToCollection();
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    internal static void EmitReadList(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, WireType packedWireType, bool castListForAdd);
    private static void EmitReadAndAddItem(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, bool castListForAdd);
    protected MethodInfo GetEnumeratorInfo(TypeModel model, MethodInfo& moveNext, MethodInfo& current);
    internal static MethodInfo GetEnumeratorInfo(TypeModel model, Type expectedType, Type itemType, MethodInfo& moveNext, MethodInfo& current);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public virtual void Write(object value, ProtoWriter dest);
    private bool CanUsePackedPrefix(object obj);
    public virtual object Read(object value, ProtoReader source);
}
internal class ProtoBuf.Serializers.MapDecorator`3 : ProtoDecoratorBase {
    private Type concreteType;
    private IProtoSerializer keyTail;
    private int fieldNumber;
    private WireType wireType;
    private static MethodInfo indexerSet;
    private static TKey DefaultKey;
    private static TValue DefaultValue;
    [CompilerGeneratedAttribute]
private bool <AppendToCollection>k__BackingField;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    private bool AppendToCollection { get; }
    internal MapDecorator`3(TypeModel model, Type concreteType, IProtoSerializer keyTail, IProtoSerializer valueTail, int fieldNumber, WireType wireType, WireType keyWireType, WireType valueWireType, bool overwriteList);
    private static MapDecorator`3();
    private static MethodInfo GetIndexerSetter();
    public virtual Type get_ExpectedType();
    public virtual bool get_ReturnsValue();
    public virtual bool get_RequiresOldValue();
    [CompilerGeneratedAttribute]
private bool get_AppendToCollection();
    public virtual object Read(object untyped, ProtoReader source);
    public virtual void Write(object untyped, ProtoWriter dest);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.MemberSpecifiedDecorator : ProtoDecoratorBase {
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public MemberSpecifiedDecorator(MethodInfo getSpecified, MethodInfo setSpecified, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.NetObjectSerializer : object {
    private int key;
    private Type type;
    private NetObjectOptions options;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public NetObjectSerializer(TypeModel model, Type type, int key, NetObjectOptions options);
    public sealed virtual Type get_ExpectedType();
    public sealed virtual bool get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.NullDecorator : ProtoDecoratorBase {
    private Type expectedType;
    public static int Tag;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public NullDecorator(TypeModel model, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_ReturnsValue();
    public virtual bool get_RequiresOldValue();
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
}
internal class ProtoBuf.Serializers.ParseableSerializer : object {
    private MethodInfo parse;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    private ParseableSerializer(MethodInfo parse);
    public static ParseableSerializer TryCreate(Type type, TypeModel model);
    private static MethodInfo GetCustomToString(Type type);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.PropertyDecorator : ProtoDecoratorBase {
    private PropertyInfo property;
    private Type forType;
    private bool readOptionsWriteValue;
    private MethodInfo shadowSetter;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public PropertyDecorator(TypeModel model, Type forType, PropertyInfo property, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private static void SanityCheck(TypeModel model, PropertyInfo property, IProtoSerializer tail, Boolean& writeValue, bool nonPublic, bool allowInternal);
    private static MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property);
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    internal static bool CanWrite(TypeModel model, MemberInfo member);
}
internal abstract class ProtoBuf.Serializers.ProtoDecoratorBase : object {
    protected IProtoSerializer Tail;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    protected ProtoDecoratorBase(IProtoSerializer tail);
    public abstract virtual Type get_ExpectedType();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual void Write(object value, ProtoWriter dest);
    public abstract virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    protected abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    protected abstract virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SByteSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SByteSerializer(TypeModel model);
    private static SByteSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SingleSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SingleSerializer(TypeModel model);
    private static SingleSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.StringSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public StringSerializer(TypeModel model);
    private static StringSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SubItemSerializer : object {
    private int key;
    private Type type;
    private ISerializerProxy proxy;
    private bool recursionCheck;
    private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SubItemSerializer(Type type, int key, ISerializerProxy proxy, bool recursionCheck);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private sealed virtual override Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private bool EmitDedicatedMethod(CompilerContext ctx, Local valueFrom, bool read);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SurrogateSerializer : object {
    private Type forType;
    private Type declaredType;
    private MethodInfo toTail;
    private MethodInfo fromTail;
    private IProtoTypeSerializer rootTail;
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public Type ExpectedType { get; }
    public SurrogateSerializer(TypeModel model, Type forType, Type declaredType, IProtoTypeSerializer rootTail);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    public sealed virtual bool get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual Type get_ExpectedType();
    private static bool HasCast(TypeModel model, Type type, Type from, Type to, MethodInfo& op);
    public MethodInfo GetConversion(TypeModel model, bool toTail);
    public sealed virtual void Write(object value, ProtoWriter writer);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SystemTypeSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SystemTypeSerializer(TypeModel model);
    private static SystemTypeSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TagDecorator : ProtoDecoratorBase {
    private bool strict;
    private int fieldNumber;
    private WireType wireType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool NeedsHint { get; }
    public TagDecorator(int fieldNumber, WireType wireType, bool strict, IProtoSerializer tail);
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual bool CanCreateInstance();
    public sealed virtual object CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual void EmitCreateInstance(CompilerContext ctx);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private bool get_NeedsHint();
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TimeSpanSerializer : object {
    private static Type expectedType;
    private bool wellKnown;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public TimeSpanSerializer(DataFormat dataFormat, TypeModel model);
    private static TimeSpanSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TupleSerializer : object {
    private MemberInfo[] members;
    private ConstructorInfo ctor;
    private IProtoSerializer[] tails;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public TupleSerializer(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members);
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private object GetValue(object obj, int index);
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual bool get_ReturnsValue();
    private Type GetMemberType(int index);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    public sealed virtual void EmitRead(CompilerContext ctx, Local incoming);
}
internal class ProtoBuf.Serializers.TypeSerializer : object {
    private Type forType;
    private Type constructType;
    private TypeInfo typeInfo;
    private IProtoSerializer[] serializers;
    private Int32[] fieldNumbers;
    private bool isRootType;
    private bool useConstructor;
    private bool isExtensible;
    private bool hasConstructor;
    private CallbackSet callbacks;
    private MethodInfo[] baseCtorCallbacks;
    private MethodInfo factory;
    private static TypeInfo iextensible;
    public Type ExpectedType { get; }
    private bool CanHaveInheritance { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public TypeSerializer(TypeModel model, Type forType, Int32[] fieldNumbers, IProtoSerializer[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, CallbackSet callbacks, Type constructType, MethodInfo factory);
    private static TypeSerializer();
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    private bool get_CanHaveInheritance();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    private IProtoSerializer GetMoreSpecificSerializer(object value);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private object InvokeCallback(MethodInfo method, object obj, SerializationContext context);
    private object CreateInstance(ProtoReader source, bool includeLocalCallback);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private static void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, bool copyValue, Type constructType, Type type);
    private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel continue, IProtoSerializer serializer);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private void EmitCreateIfNull(CompilerContext ctx, Local storage);
}
internal class ProtoBuf.Serializers.UInt16Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt16Serializer(TypeModel model);
    private static UInt16Serializer();
    public virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UInt32Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt32Serializer(TypeModel model);
    private static UInt32Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UInt64Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt64Serializer(TypeModel model);
    private static UInt64Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UriDecorator : ProtoDecoratorBase {
    private static Type expectedType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public UriDecorator(TypeModel model, IProtoSerializer tail);
    private static UriDecorator();
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
[AttributeUsageAttribute("64")]
public class ProtoBuf.ServiceModel.ProtoBehaviorAttribute : Attribute {
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription operationDescription);
}
public class ProtoBuf.ServiceModel.ProtoEndpointBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint endpoint);
    private static void ReplaceDataContractSerializerOperationBehavior(ServiceEndpoint serviceEndpoint);
    private static void ReplaceDataContractSerializerOperationBehavior(OperationDescription description);
}
public class ProtoBuf.ServiceModel.ProtoOperationBehavior : DataContractSerializerOperationBehavior {
    private TypeModel model;
    public TypeModel Model { get; public set; }
    public ProtoOperationBehavior(OperationDescription operation);
    public TypeModel get_Model();
    public void set_Model(TypeModel value);
    public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList`1<Type> knownTypes);
}
public class ProtoBuf.ServiceModel.XmlProtoSerializer : XmlObjectSerializer {
    private TypeModel model;
    private int key;
    private bool isList;
    private bool isEnum;
    private Type type;
    private static string PROTO_ELEMENT;
    internal XmlProtoSerializer(TypeModel model, int key, Type type, bool isList);
    public XmlProtoSerializer(TypeModel model, Type type);
    public static XmlProtoSerializer TryCreate(TypeModel model, Type type);
    private static int GetKey(TypeModel model, Type& type, Boolean& isList);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
}
[IsReadOnlyAttribute]
public class ProtoBuf.SubItemToken : ValueType {
    internal long value64;
    internal SubItemToken(int value);
    internal SubItemToken(long value);
}
internal enum ProtoBuf.TimeSpanScale : Enum {
    public int value__;
    public static TimeSpanScale Days;
    public static TimeSpanScale Hours;
    public static TimeSpanScale Minutes;
    public static TimeSpanScale Seconds;
    public static TimeSpanScale Milliseconds;
    public static TimeSpanScale Ticks;
    public static TimeSpanScale MinMax;
}
public enum ProtoBuf.WireType : Enum {
    public int value__;
    public static WireType None;
    public static WireType Variant;
    public static WireType Fixed64;
    public static WireType String;
    public static WireType StartGroup;
    public static WireType EndGroup;
    public static WireType Fixed32;
    public static WireType SignedVariant;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
