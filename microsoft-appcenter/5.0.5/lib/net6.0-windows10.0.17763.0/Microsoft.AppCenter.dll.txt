public class Microsoft.AppCenter.AppCenter : object {
    private static string PlatformIdentifier;
    private static string SecretDelimiter;
    private static string PlatformKeyValueDelimiter;
    private static string TargetKeyName;
    private static string TargetKeyNameUpper;
    private static string AppSecretKeyName;
    private static string SecretsPattern;
    private static Regex _secretsRegex;
    internal static string EnabledKey;
    internal static string InstallIdKey;
    internal static string AllowedNetworkRequestsKey;
    private static string ConfigurationErrorMessage;
    private static string StartErrorMessage;
    private static string NotConfiguredMessage;
    private static string ChannelName;
    private static long MinimumStorageSize;
    private static long DefaultStorageMaxSize;
    private static object AppCenterLock;
    private static IApplicationSettingsFactory _applicationSettingsFactory;
    private static IChannelGroupFactory _channelGroupFactory;
    private IApplicationSettings _applicationSettings;
    private INetworkStateAdapter _networkStateAdapter;
    private IChannelGroup _channelGroup;
    private IChannelUnit _channel;
    private HashSet`1<IAppCenterService> _services;
    private List`1<string> _startedServiceNames;
    private string _logUrl;
    private bool _instanceConfigured;
    private string _appSecret;
    private long _storageMaxSize;
    private string _dataResidencyResion;
    private TaskCompletionSource`1<bool> _storageTaskCompletionSource;
    private static AppCenter modreq(System.Runtime.CompilerServices.IsVolatile) _instanceField;
    public static LogLevel LogLevel { get; public set; }
    public static bool IsNetworkRequestsAllowed { get; public set; }
    public static string SdkVersion { get; }
    public static bool Configured { get; }
    internal static AppCenter Instance { get; internal set; }
    private static LogLevel PlatformLogLevel { get; private set; }
    public static bool PlatformIsNetworkRequestsAllowed { get; public set; }
    private static bool PlatformConfigured { get; }
    internal IApplicationSettings ApplicationSettings { get; }
    internal INetworkStateAdapter NetworkStateAdapter { get; }
    private bool InstanceEnabled { get; }
    private static AppCenter();
    internal static string GetSecretAndTargetForPlatform(string secrets, string platformIdentifier);
    public static LogLevel get_LogLevel();
    public static void set_LogLevel(LogLevel value);
    public static bool get_IsNetworkRequestsAllowed();
    public static void set_IsNetworkRequestsAllowed(bool value);
    public static void SetCountryCode(string countryCode);
    public static void SetDataResidencyRegion(string dataResidencyRegion);
    public static string GetDataResidencyRegion();
    public static void SetUserId(string userId);
    public static string get_SdkVersion();
    public static Task`1<bool> IsEnabledAsync();
    public static Task SetEnabledAsync(bool enabled);
    public static Task`1<Nullable`1<Guid>> GetInstallIdAsync();
    public static void SetLogUrl(string logUrl);
    public static bool get_Configured();
    public static void Configure(string appSecret);
    public static void Start(Type[] services);
    public static void Start(string appSecret, Type[] services);
    public static Task`1<bool> SetMaxStorageSizeAsync(long sizeInBytes);
    internal static void UnsetInstance();
    internal static AppCenter get_Instance();
    internal static void set_Instance(AppCenter value);
    private static LogLevel get_PlatformLogLevel();
    private static void set_PlatformLogLevel(LogLevel value);
    public static bool get_PlatformIsNetworkRequestsAllowed();
    public static void set_PlatformIsNetworkRequestsAllowed(bool value);
    public static void PlatformSetCountryCode(string countryCode);
    public static void PlatformSetDataResidencyRegion(string dataResidencyRegion);
    public static string PlatformGetDataResidencyRegion();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static void SetApplicationSettingsFactory(IApplicationSettingsFactory factory);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static void SetChannelGroupFactory(IChannelGroupFactory factory);
    private static Task`1<bool> PlatformIsEnabledAsync();
    private static void PlatformSetUserId(string userId);
    private static Task PlatformSetEnabledAsync(bool enabled);
    private static Task`1<Nullable`1<Guid>> PlatformGetInstallIdAsync();
    private static void PlatformSetLogUrl(string logUrl);
    internal static void PlatformUnsetInstance();
    private static bool get_PlatformConfigured();
    private static void PlatformConfigure(string appSecret);
    private static void PlatformStart(Type[] services);
    private static void PlatformStart(string appSecret, Type[] services);
    private static Task`1<bool> PlatformSetMaxStorageSizeAsync(long sizeInBytes);
    public static void SetWrapperSdk(WrapperSdk wrapperSdk);
    internal IApplicationSettings get_ApplicationSettings();
    internal INetworkStateAdapter get_NetworkStateAdapter();
    private bool get_InstanceEnabled();
    private Task SetInstanceEnabled(bool value);
    private void SetInstanceLogUrl(string logUrl);
    private Task`1<bool> SetInstanceStorageMaxSize(long storageMaxSize);
    private void OnUnhandledExceptionOccurred(object sender, UnhandledExceptionOccurredEventArgs args);
    internal void InstanceConfigure(string appSecretOrSecrets);
    internal void StartInstance(Type[] services);
    private void StartService(IAppCenterService service);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InstanceConfigure>b__95_0(Task`1<bool> task);
}
public class Microsoft.AppCenter.AppCenterException : Exception {
    public AppCenterException(string message);
    public AppCenterException(string message, Exception innerException);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.AppCenter.AppCenterLog : object {
    [EditorBrowsableAttribute("1")]
public static string LogTag;
    private static object LogLock;
    private static LogLevel modreq(System.Runtime.CompilerServices.IsVolatile) _level;
    internal static LogLevel Level { get; internal set; }
    private static AppCenterLog();
    [EditorBrowsableAttribute("1")]
public static void Verbose(string tag, string message, Exception exception);
    [EditorBrowsableAttribute("1")]
public static void Debug(string tag, string message, Exception exception);
    [EditorBrowsableAttribute("1")]
public static void Info(string tag, string message, Exception exception);
    [EditorBrowsableAttribute("1")]
public static void Warn(string tag, string message, Exception exception);
    [EditorBrowsableAttribute("1")]
public static void Error(string tag, string message, Exception exception);
    [EditorBrowsableAttribute("1")]
public static void Assert(string tag, string message, Exception exception);
    private static string ConcatMessageException(string message, Exception exception);
    internal static LogLevel get_Level();
    internal static void set_Level(LogLevel value);
    [EditorBrowsableAttribute("1")]
public static void Verbose(string tag, string message);
    [EditorBrowsableAttribute("1")]
public static void Debug(string tag, string message);
    [EditorBrowsableAttribute("1")]
public static void Info(string tag, string message);
    [EditorBrowsableAttribute("1")]
public static void Warn(string tag, string message);
    [EditorBrowsableAttribute("1")]
public static void Error(string tag, string message);
    [EditorBrowsableAttribute("1")]
public static void Assert(string tag, string message);
    private static void LogMessage(string tag, string message, LogLevel level, string levelName);
}
public abstract class Microsoft.AppCenter.AppCenterService : object {
    private static string PreferenceKeySeparator;
    private static string KeyEnabled;
    protected object _serviceLock;
    [CompilerGeneratedAttribute]
private IChannelUnit <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelGroup <ChannelGroup>k__BackingField;
    protected IApplicationSettings ApplicationSettings { get; }
    protected INetworkStateAdapter NetworkStateAdapter { get; }
    protected IChannelUnit Channel { get; private set; }
    protected IChannelGroup ChannelGroup { get; private set; }
    protected string ChannelName { get; }
    public string ServiceName { get; }
    protected string EnabledPreferenceKey { get; }
    protected int TriggerCount { get; }
    protected TimeSpan TriggerInterval { get; }
    protected int TriggerMaxParallelRequests { get; }
    public bool InstanceEnabled { get; public set; }
    protected bool IsInactive { get; }
    protected virtual IApplicationSettings get_ApplicationSettings();
    protected virtual INetworkStateAdapter get_NetworkStateAdapter();
    [CompilerGeneratedAttribute]
protected IChannelUnit get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(IChannelUnit value);
    [CompilerGeneratedAttribute]
protected IChannelGroup get_ChannelGroup();
    [CompilerGeneratedAttribute]
private void set_ChannelGroup(IChannelGroup value);
    protected abstract virtual string get_ChannelName();
    public abstract virtual string get_ServiceName();
    protected virtual string get_EnabledPreferenceKey();
    protected virtual int get_TriggerCount();
    protected virtual TimeSpan get_TriggerInterval();
    protected virtual int get_TriggerMaxParallelRequests();
    public virtual bool get_InstanceEnabled();
    public virtual void set_InstanceEnabled(bool value);
    public virtual void OnChannelGroupReady(IChannelGroup channelGroup, string appSecret);
    protected bool get_IsInactive();
}
public abstract class Microsoft.AppCenter.ApplicationLifecycleHelper : object {
    private static IApplicationLifecycleHelper _instance;
    protected static bool _suspended;
    protected static bool _started;
    [CompilerGeneratedAttribute]
private EventHandler ApplicationSuspended;
    [CompilerGeneratedAttribute]
private EventHandler ApplicationResuming;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnhandledExceptionOccurredEventArgs> UnhandledExceptionOccurred;
    public bool IsSuspended { get; }
    public static IApplicationLifecycleHelper Instance { get; internal set; }
    private static ApplicationLifecycleHelper();
    public sealed virtual bool get_IsSuspended();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ApplicationSuspended(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ApplicationSuspended(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ApplicationResuming(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ApplicationResuming(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_UnhandledExceptionOccurred(EventHandler`1<UnhandledExceptionOccurredEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UnhandledExceptionOccurred(EventHandler`1<UnhandledExceptionOccurredEventArgs> value);
    public static IApplicationLifecycleHelper get_Instance();
    internal static void set_Instance(IApplicationLifecycleHelper value);
    protected static void InvokeResuming();
    private void _InvokeResuming();
    protected static void InvokeSuspended();
    private void _InvokeSuspended();
    protected void InvokeUnhandledExceptionOccurred(object sender, UnhandledExceptionOccurredEventArgs args);
}
public class Microsoft.AppCenter.CancellationException : AppCenterException {
}
public class Microsoft.AppCenter.Channel.Channel : object {
    private static int ClearBatchSize;
    private Device _device;
    private string _appSecret;
    private IStorage _storage;
    private IIngestion _ingestion;
    private IDeviceInformationHelper _deviceInfoHelper;
    private IDictionary`2<string, List`1<Log>> _sendingBatches;
    private ISet`1<IServiceCall> _calls;
    private int _maxParallelBatches;
    private int _maxLogsPerBatch;
    private Task _pendingLogCountInitTask;
    private long _pendingLogCount;
    private bool _enabled;
    private bool _discardLogs;
    private bool _batchScheduled;
    private TimeSpan _batchTimeInterval;
    private StatefulMutex _mutex;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EnqueuingLogEventArgs> EnqueuingLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<FilteringLogEventArgs> FilteringLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingLogEventArgs> SendingLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentLogEventArgs> SentLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<FailedToSendLogEventArgs> FailedToSendLog;
    public bool IsEnabled { get; }
    public string Name { get; }
    internal Channel(string name, int maxLogsPerBatch, TimeSpan batchTimeInterval, int maxParallelBatches, string appSecret, IIngestion ingestion, IStorage storage);
    public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void add_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    public sealed virtual void SetEnabled(bool enabled);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<EnqueueAsync>d__39")]
public sealed virtual Task EnqueueAsync(Log log);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<PrepareLogAsync>d__40")]
private Task PrepareLogAsync(Log log, State state);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<PersistLogAsync>d__41")]
private Task PersistLogAsync(Log log, State state);
    public void InvalidateDeviceCache();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<ClearAsync>d__43")]
public Task ClearAsync();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<Resume>d__44")]
private Task Resume(State state, bool needEnableChannel);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<Suspend>d__45")]
private Task Suspend(State state, bool deleteLogs, Exception exception, bool needDisableChannel);
    private void TriggerDeleteLogsOnSuspending(IList`1<string> sendingBatches);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<SignalDeletingLogs>d__47")]
private Task SignalDeletingLogs(IList`1<string> sendingBatches);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<TriggerIngestionAsync>d__48")]
private Task TriggerIngestionAsync(State state);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<HandleSendingResult>d__49")]
private Task HandleSendingResult(State state, string batchId, IServiceCall call);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<HandleSendingSuccess>d__50")]
private Task HandleSendingSuccess(State state, string batchId);
    private void HandleSendingFailure(State state, string batchId, Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<CheckPendingLogsInternal>d__52")]
private Task CheckPendingLogsInternal(State state);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<InitializeLogCount>d__53")]
private Task InitializeLogCount();
    public sealed virtual void SetNetworkRequestAllowed(bool isAllowed);
    public sealed virtual void CheckPendingLogs();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.Channel/<ShutdownAsync>d__56")]
public sealed virtual Task ShutdownAsync();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__17_0(object sender, EventArgs e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <TriggerDeleteLogsOnSuspending>b__46_0(Task completedTask);
}
public abstract class Microsoft.AppCenter.Channel.ChannelEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Log <Log>k__BackingField;
    public Log Log { get; }
    protected ChannelEventArgs(Log log);
    [CompilerGeneratedAttribute]
public Log get_Log();
}
public class Microsoft.AppCenter.Channel.ChannelGroup : object {
    private static TimeSpan WaitStorageTimeout;
    private HashSet`1<IChannelUnit> _channels;
    private IIngestion _ingestion;
    private IStorage _storage;
    private object _channelGroupLock;
    private bool _isDisposed;
    private bool _isShutdown;
    [CompilerGeneratedAttribute]
private string <AppSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EnqueuingLogEventArgs> EnqueuingLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<FilteringLogEventArgs> FilteringLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingLogEventArgs> SendingLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentLogEventArgs> SentLog;
    [CompilerGeneratedAttribute]
private EventHandler`1<FailedToSendLogEventArgs> FailedToSendLog;
    public string AppSecret { get; internal set; }
    public ChannelGroup(string appSecret);
    public ChannelGroup(string appSecret, IHttpNetworkAdapter httpNetwork, INetworkStateAdapter networkState);
    internal ChannelGroup(IIngestion ingestion, IStorage storage, string appSecret);
    private static ChannelGroup();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AppSecret();
    [CompilerGeneratedAttribute]
internal void set_AppSecret(string value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    public sealed virtual void SetLogUrl(string logUrl);
    public sealed virtual IChannelUnit AddChannel(string name, int maxLogsPerBatch, TimeSpan batchTimeInterval, int maxParallelBatches);
    public sealed virtual void AddChannel(IChannelUnit channel);
    public sealed virtual void SetEnabled(bool enabled);
    public sealed virtual void SetNetworkRequestAllowed(bool isAllowed);
    public sealed virtual Task`1<bool> SetMaxStorageSizeAsync(long sizeInBytes);
    public sealed virtual Task WaitStorageOperationsAsync();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Channel.ChannelGroup/<ShutdownAsync>d__36")]
public sealed virtual Task ShutdownAsync();
    private static IIngestion DefaultIngestion(IHttpNetworkAdapter httpNetwork, INetworkStateAdapter networkState);
    private static IStorage DefaultStorage();
    private void AnyChannelEnqueuingLog(object sender, EnqueuingLogEventArgs e);
    private void AnyChannelFilteringLog(object sender, FilteringLogEventArgs e);
    private void AnyChannelSendingLog(object sender, SendingLogEventArgs e);
    private void AnyChannelSentLog(object sender, SentLogEventArgs e);
    private void AnyChannelFailedToSendLog(object sender, FailedToSendLogEventArgs e);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class Microsoft.AppCenter.Channel.EnqueuingLogEventArgs : ChannelEventArgs {
    public EnqueuingLogEventArgs(Log log);
}
public class Microsoft.AppCenter.Channel.FailedToSendLogEventArgs : ChannelEventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FailedToSendLogEventArgs(Log log, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class Microsoft.AppCenter.Channel.FilteringLogEventArgs : ChannelEventArgs {
    [CompilerGeneratedAttribute]
private bool <FilterRequested>k__BackingField;
    public bool FilterRequested { get; public set; }
    public FilteringLogEventArgs(Log log);
    [CompilerGeneratedAttribute]
public bool get_FilterRequested();
    [CompilerGeneratedAttribute]
public void set_FilterRequested(bool value);
}
public interface Microsoft.AppCenter.Channel.IAppSecretHolder {
    public string AppSecret { get; }
    public abstract virtual string get_AppSecret();
}
public interface Microsoft.AppCenter.Channel.IChannel {
    [CompilerGeneratedAttribute]
public abstract virtual void add_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EnqueuingLog(EventHandler`1<EnqueuingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FilteringLog(EventHandler`1<FilteringLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SendingLog(EventHandler`1<SendingLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SentLog(EventHandler`1<SentLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FailedToSendLog(EventHandler`1<FailedToSendLogEventArgs> value);
    public abstract virtual void SetEnabled(bool enabled);
    public abstract virtual Task ShutdownAsync();
    public abstract virtual void SetNetworkRequestAllowed(bool isAllowed);
}
public interface Microsoft.AppCenter.Channel.IChannelGroup {
    public abstract virtual void AddChannel(IChannelUnit channel);
    public abstract virtual IChannelUnit AddChannel(string name, int maxLogsPerBatch, TimeSpan batchTimeInterval, int maxParallelBatches);
    public abstract virtual void SetLogUrl(string logUrl);
    public abstract virtual Task WaitStorageOperationsAsync();
    public abstract virtual Task`1<bool> SetMaxStorageSizeAsync(long sizeInBytes);
}
public interface Microsoft.AppCenter.Channel.IChannelGroupFactory {
    public abstract virtual IChannelGroup CreateChannelGroup(string appSecret, INetworkStateAdapter networkState);
}
public interface Microsoft.AppCenter.Channel.IChannelUnit {
    public abstract virtual Task EnqueueAsync(Log log);
    public abstract virtual void CheckPendingLogs();
}
public class Microsoft.AppCenter.Channel.SendingLogEventArgs : ChannelEventArgs {
    public SendingLogEventArgs(Log log);
}
public class Microsoft.AppCenter.Channel.SentLogEventArgs : ChannelEventArgs {
    public SentLogEventArgs(Log log);
}
public class Microsoft.AppCenter.Device : object {
    [CompilerGeneratedAttribute]
private string <SdkName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OsApiLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeZoneOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScreenSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CarrierName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CarrierCountry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppNamespace>k__BackingField;
    public string SdkName { get; }
    public string SdkVersion { get; }
    public string Model { get; }
    public string OemName { get; }
    public string OsName { get; }
    public string OsVersion { get; }
    public string OsBuild { get; }
    public Nullable`1<int> OsApiLevel { get; }
    public string Locale { get; }
    public int TimeZoneOffset { get; }
    public string ScreenSize { get; }
    public string AppVersion { get; }
    public string CarrierName { get; }
    public string CarrierCountry { get; }
    public string AppBuild { get; }
    public string AppNamespace { get; }
    public Device(Device device);
    [CompilerGeneratedAttribute]
public string get_SdkName();
    [CompilerGeneratedAttribute]
public string get_SdkVersion();
    [CompilerGeneratedAttribute]
public string get_Model();
    [CompilerGeneratedAttribute]
public string get_OemName();
    [CompilerGeneratedAttribute]
public string get_OsName();
    [CompilerGeneratedAttribute]
public string get_OsVersion();
    [CompilerGeneratedAttribute]
public string get_OsBuild();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OsApiLevel();
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public int get_TimeZoneOffset();
    [CompilerGeneratedAttribute]
public string get_ScreenSize();
    [CompilerGeneratedAttribute]
public string get_AppVersion();
    [CompilerGeneratedAttribute]
public string get_CarrierName();
    [CompilerGeneratedAttribute]
public string get_CarrierCountry();
    [CompilerGeneratedAttribute]
public string get_AppBuild();
    [CompilerGeneratedAttribute]
public string get_AppNamespace();
}
public interface Microsoft.AppCenter.IAppCenterService {
    public string ServiceName { get; }
    public bool InstanceEnabled { get; public set; }
    public abstract virtual string get_ServiceName();
    public abstract virtual bool get_InstanceEnabled();
    public abstract virtual void set_InstanceEnabled(bool value);
    public abstract virtual void OnChannelGroupReady(IChannelGroup channelGroup, string appSecret);
}
internal interface Microsoft.AppCenter.IManagmentClassFactory {
    public abstract virtual ManagementClass GetComputerSystemClass();
    public abstract virtual ManagementClass GetOperatingSystemClass();
}
public class Microsoft.AppCenter.Ingestion.Http.HttpIngestionException : IngestionException {
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestContent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseContent>k__BackingField;
    public string Method { get; public set; }
    public Uri RequestUri { get; public set; }
    public string RequestContent { get; public set; }
    public int StatusCode { get; public set; }
    public string ResponseContent { get; public set; }
    public bool IsRecoverable { get; }
    public HttpIngestionException(string message);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_RequestContent();
    [CompilerGeneratedAttribute]
public void set_RequestContent(string value);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_ResponseContent();
    [CompilerGeneratedAttribute]
public void set_ResponseContent(string value);
    public virtual bool get_IsRecoverable();
}
public class Microsoft.AppCenter.Ingestion.Http.HttpNetworkAdapter : object {
    internal static string ContentTypeValue;
    private HttpClient _httpClient;
    private object _lockObject;
    internal static Func`1<HttpMessageHandler> HttpMessageHandlerOverride;
    private static UInt32[] NetworkUnavailableCodes;
    private HttpClient HttpClient { get; }
    private static HttpNetworkAdapter();
    internal HttpNetworkAdapter(HttpClient httpClient);
    private HttpClient get_HttpClient();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Ingestion.Http.HttpNetworkAdapter/<SendAsync>d__10")]
public sealed virtual Task`1<string> SendAsync(string uri, string method, IDictionary`2<string, string> headers, string jsonContent, CancellationToken cancellationToken);
    internal HttpRequestMessage CreateRequest(string uri, string method, IDictionary`2<string, string> headers, string jsonContent);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Ingestion.Http.HttpNetworkAdapter/<SendRequestAsync>d__12")]
private Task`1<HttpResponseMessage> SendRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public interface Microsoft.AppCenter.Ingestion.Http.IHttpNetworkAdapter {
    public abstract virtual Task`1<string> SendAsync(string uri, string method, IDictionary`2<string, string> headers, string jsonContent, CancellationToken cancellationToken);
}
public interface Microsoft.AppCenter.Ingestion.Http.INetworkStateAdapter {
    public bool IsConnected { get; }
    public abstract virtual bool get_IsConnected();
    [CompilerGeneratedAttribute]
public abstract virtual void add_NetworkStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NetworkStatusChanged(EventHandler value);
}
public abstract class Microsoft.AppCenter.Ingestion.Http.IngestionDecorator : object {
    [CompilerGeneratedAttribute]
private IIngestion <DecoratedApi>k__BackingField;
    protected IIngestion DecoratedApi { get; }
    public bool IsEnabled { get; }
    protected IngestionDecorator(IIngestion decoratedApi);
    [CompilerGeneratedAttribute]
protected IIngestion get_DecoratedApi();
    public virtual void SetLogUrl(string logUrl);
    public virtual IServiceCall Call(string appSecret, Guid installId, IList`1<Log> logs);
    public virtual void Close();
    public virtual void Dispose();
    public sealed virtual bool get_IsEnabled();
}
internal class Microsoft.AppCenter.Ingestion.Http.IngestionHttp : object {
    internal static string DefaultBaseUrl;
    internal static string ApiVersion;
    internal static string AppSecret;
    internal static string InstallId;
    private static int MaximumCharactersDisplayedForAppSecret;
    private string _baseLogUrl;
    private IHttpNetworkAdapter _httpNetwork;
    public bool IsEnabled { get; }
    public IngestionHttp(IHttpNetworkAdapter httpNetwork);
    public sealed virtual IServiceCall Call(string appSecret, Guid installId, IList`1<Log> logs);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Ingestion.Http.IngestionHttp/<CallAsync>d__9")]
private Task`1<string> CallAsync(string appSecret, Guid installId, IList`1<Log> logs, CancellationToken token);
    public sealed virtual void Close();
    public sealed virtual void SetLogUrl(string logUrl);
    private static string GetRedactedAppSecret(string appSecret);
    internal IDictionary`2<string, string> CreateHeaders(string appSecret, Guid installId);
    private string CreateLogsContent(IList`1<Log> logs);
    public sealed virtual void Dispose();
    public sealed virtual bool get_IsEnabled();
}
public class Microsoft.AppCenter.Ingestion.Http.NetworkIngestionException : IngestionException {
    public bool IsRecoverable { get; }
    public NetworkIngestionException(Exception innerException);
    public virtual bool get_IsRecoverable();
}
public class Microsoft.AppCenter.Ingestion.Http.NetworkStateAdapter : object {
    [CompilerGeneratedAttribute]
private EventHandler NetworkStatusChanged;
    public bool IsConnected { get; }
    public sealed virtual bool get_IsConnected();
    [CompilerGeneratedAttribute]
public sealed virtual void add_NetworkStatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NetworkStatusChanged(EventHandler value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__0_0(object sender, EventArgs args);
}
internal class Microsoft.AppCenter.Ingestion.Http.NetworkStateIngestion : IngestionDecorator {
    private ISet`1<ServiceCall> _calls;
    private INetworkStateAdapter _networkStateAdapter;
    public NetworkStateIngestion(IIngestion decoratedApi, INetworkStateAdapter networkStateAdapter);
    private void OnNetworkStateChange(object sender, EventArgs e);
    private void RetryCall(ServiceCall call);
    public virtual IServiceCall Call(string appSecret, Guid installId, IList`1<Log> logs);
    public virtual void Close();
    public virtual void Dispose();
    private void CancelAllCalls();
}
internal class Microsoft.AppCenter.Ingestion.Http.RetryableIngestion : IngestionDecorator {
    private static TimeSpan[] DefaultIntervals;
    private IDictionary`2<ServiceCall, Timer> _calls;
    private TimeSpan[] _retryIntervals;
    public RetryableIngestion(IIngestion decoratedApi);
    public RetryableIngestion(IIngestion decoratedApi, TimeSpan[] retryIntervals);
    private static RetryableIngestion();
    private Timer IntervalCall(int retry, Action action);
    private void RetryCall(ServiceCall call, int retry);
    private void RetryCallContinuation(ServiceCall call, IServiceCall result, int retry);
    public virtual IServiceCall Call(string appSecret, Guid installId, IList`1<Log> logs);
    public virtual void Close();
    public virtual void Dispose();
    private void CancelAllCalls();
}
public interface Microsoft.AppCenter.Ingestion.IIngestion {
    public bool IsEnabled { get; }
    public abstract virtual void SetLogUrl(string logUrl);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual IServiceCall Call(string appSecret, Guid installId, IList`1<Log> logs);
    public abstract virtual void Close();
}
public class Microsoft.AppCenter.Ingestion.IngestionException : AppCenterException {
    private static string DefaultMessage;
    public bool IsRecoverable { get; }
    public IngestionException(string message);
    public IngestionException(Exception innerException);
    public virtual bool get_IsRecoverable();
}
public interface Microsoft.AppCenter.Ingestion.IServiceCall {
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsFaulted { get; }
    public string Result { get; }
    public Exception Exception { get; }
    public abstract virtual bool get_IsCanceled();
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool get_IsFaulted();
    public abstract virtual string get_Result();
    public abstract virtual Exception get_Exception();
    public abstract virtual void ContinueWith(Action`1<IServiceCall> continuationAction);
    public abstract virtual void Cancel();
}
public class Microsoft.AppCenter.Ingestion.Models.Device : object {
    [CompilerGeneratedAttribute]
private string <SdkName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperSdkName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OsApiLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeZoneOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScreenSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CarrierName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CarrierCountry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdateReleaseLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdateDeploymentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdatePackageHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperRuntimeVersion>k__BackingField;
    [JsonPropertyAttribute]
public string SdkName { get; public set; }
    [JsonPropertyAttribute]
public string SdkVersion { get; public set; }
    [JsonPropertyAttribute]
public string WrapperSdkVersion { get; public set; }
    [JsonPropertyAttribute]
public string WrapperSdkName { get; public set; }
    [JsonPropertyAttribute]
public string Model { get; public set; }
    [JsonPropertyAttribute]
public string OemName { get; public set; }
    [JsonPropertyAttribute]
public string OsName { get; public set; }
    [JsonPropertyAttribute]
public string OsVersion { get; public set; }
    [JsonPropertyAttribute]
public string OsBuild { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<int> OsApiLevel { get; public set; }
    [JsonPropertyAttribute]
public string Locale { get; public set; }
    [JsonPropertyAttribute]
public int TimeZoneOffset { get; public set; }
    [JsonPropertyAttribute]
public string ScreenSize { get; public set; }
    [JsonPropertyAttribute]
public string AppVersion { get; public set; }
    [JsonPropertyAttribute]
public string CarrierName { get; public set; }
    [JsonPropertyAttribute]
public string CarrierCountry { get; public set; }
    [JsonPropertyAttribute]
public string AppBuild { get; public set; }
    [JsonPropertyAttribute]
public string AppNamespace { get; public set; }
    [JsonPropertyAttribute]
public string LiveUpdateReleaseLabel { get; public set; }
    [JsonPropertyAttribute]
public string LiveUpdateDeploymentKey { get; public set; }
    [JsonPropertyAttribute]
public string LiveUpdatePackageHash { get; public set; }
    [JsonPropertyAttribute]
public string WrapperRuntimeVersion { get; public set; }
    public Device(string sdkName, string sdkVersion, string osName, string osVersion, string locale, int timeZoneOffset, string appVersion, string appBuild, string wrapperSdkVersion, string wrapperSdkName, string model, string oemName, string osBuild, Nullable`1<int> osApiLevel, string screenSize, string carrierName, string carrierCountry, string appNamespace, string liveUpdateReleaseLabel, string liveUpdateDeploymentKey, string liveUpdatePackageHash, string wrapperRuntimeVersion);
    [CompilerGeneratedAttribute]
public string get_SdkName();
    [CompilerGeneratedAttribute]
public void set_SdkName(string value);
    [CompilerGeneratedAttribute]
public string get_SdkVersion();
    [CompilerGeneratedAttribute]
public void set_SdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperSdkVersion();
    [CompilerGeneratedAttribute]
public void set_WrapperSdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperSdkName();
    [CompilerGeneratedAttribute]
public void set_WrapperSdkName(string value);
    [CompilerGeneratedAttribute]
public string get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(string value);
    [CompilerGeneratedAttribute]
public string get_OemName();
    [CompilerGeneratedAttribute]
public void set_OemName(string value);
    [CompilerGeneratedAttribute]
public string get_OsName();
    [CompilerGeneratedAttribute]
public void set_OsName(string value);
    [CompilerGeneratedAttribute]
public string get_OsVersion();
    [CompilerGeneratedAttribute]
public void set_OsVersion(string value);
    [CompilerGeneratedAttribute]
public string get_OsBuild();
    [CompilerGeneratedAttribute]
public void set_OsBuild(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OsApiLevel();
    [CompilerGeneratedAttribute]
public void set_OsApiLevel(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public int get_TimeZoneOffset();
    [CompilerGeneratedAttribute]
public void set_TimeZoneOffset(int value);
    [CompilerGeneratedAttribute]
public string get_ScreenSize();
    [CompilerGeneratedAttribute]
public void set_ScreenSize(string value);
    [CompilerGeneratedAttribute]
public string get_AppVersion();
    [CompilerGeneratedAttribute]
public void set_AppVersion(string value);
    [CompilerGeneratedAttribute]
public string get_CarrierName();
    [CompilerGeneratedAttribute]
public void set_CarrierName(string value);
    [CompilerGeneratedAttribute]
public string get_CarrierCountry();
    [CompilerGeneratedAttribute]
public void set_CarrierCountry(string value);
    [CompilerGeneratedAttribute]
public string get_AppBuild();
    [CompilerGeneratedAttribute]
public void set_AppBuild(string value);
    [CompilerGeneratedAttribute]
public string get_AppNamespace();
    [CompilerGeneratedAttribute]
public void set_AppNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdateReleaseLabel();
    [CompilerGeneratedAttribute]
public void set_LiveUpdateReleaseLabel(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdateDeploymentKey();
    [CompilerGeneratedAttribute]
public void set_LiveUpdateDeploymentKey(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdatePackageHash();
    [CompilerGeneratedAttribute]
public void set_LiveUpdatePackageHash(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperRuntimeVersion();
    [CompilerGeneratedAttribute]
public void set_WrapperRuntimeVersion(string value);
    public virtual void Validate();
}
public class Microsoft.AppCenter.Ingestion.Models.Log : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Sid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private Device <Device>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataResidencyRegion>k__BackingField;
    [JsonPropertyAttribute]
public Nullable`1<DateTime> Timestamp { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<Guid> Sid { get; public set; }
    [JsonPropertyAttribute]
public string UserId { get; public set; }
    [JsonPropertyAttribute]
public Device Device { get; public set; }
    [JsonPropertyAttribute]
public string DataResidencyRegion { get; public set; }
    public Log(Device device, Nullable`1<DateTime> timestamp, Nullable`1<Guid> sid, string userId, string dataResidencyRegion);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Sid();
    [CompilerGeneratedAttribute]
public void set_Sid(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public Device get_Device();
    [CompilerGeneratedAttribute]
public void set_Device(Device value);
    [CompilerGeneratedAttribute]
public string get_DataResidencyRegion();
    [CompilerGeneratedAttribute]
public void set_DataResidencyRegion(string value);
    public virtual void Validate();
}
public class Microsoft.AppCenter.Ingestion.Models.LogContainer : object {
    [CompilerGeneratedAttribute]
private IList`1<Log> <Logs>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<Log> Logs { get; public set; }
    public LogContainer(IList`1<Log> logs);
    [CompilerGeneratedAttribute]
public IList`1<Log> get_Logs();
    [CompilerGeneratedAttribute]
public void set_Logs(IList`1<Log> value);
    public virtual void Validate();
}
public class Microsoft.AppCenter.Ingestion.Models.LogWithProperties : Log {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [JsonPropertyAttribute]
public IDictionary`2<string, string> Properties { get; public set; }
    public LogWithProperties(Device device, Nullable`1<DateTime> timestamp, Nullable`1<Guid> sid, string userId, string dataResidencyRegion, IDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    public virtual void Validate();
}
public class Microsoft.AppCenter.Ingestion.Models.Serialization.LogJsonConverter : JsonConverter {
    private Dictionary`2<string, Type> _logTypes;
    private object _jsonConverterLock;
    private static JsonSerializerSettings SerializationSettings;
    internal static string TypeIdKey;
    private static LogJsonConverter();
    public void AddLogType(string typeName, Type type);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public static class Microsoft.AppCenter.Ingestion.Models.Serialization.LogSerializer : object {
    internal static JsonSerializerSettings SerializationSettings;
    private static LogJsonConverter Converter;
    private static LogSerializer();
    public static void AddLogType(string typeName, Type type);
    public static string Serialize(LogContainer logContainer);
    public static string Serialize(Log log);
    public static Log DeserializeLog(string json);
}
[JsonObjectAttribute("startService")]
public class Microsoft.AppCenter.Ingestion.Models.StartServiceLog : Log {
    internal static string JsonIdentifier;
    [CompilerGeneratedAttribute]
private IList`1<string> <Services>k__BackingField;
    [JsonPropertyAttribute]
public IList`1<string> Services { get; public set; }
    public StartServiceLog(Device device, Nullable`1<DateTime> timestamp, Nullable`1<Guid> sid, IList`1<string> services, string dataResidencyRegion);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Services();
    [CompilerGeneratedAttribute]
public void set_Services(IList`1<string> value);
    public virtual void Validate();
}
public class Microsoft.AppCenter.Ingestion.Models.ValidationException : IngestionException {
    private static string DefaultMessage;
    public ValidationException(string message);
    public ValidationException(Rule validationRule, string propertyName, object detail);
    private static string GetRuleString(Rule rule, string extraValue);
    private static string GetErrorString(Rule validationRule, string propertyName, object detail);
}
internal class Microsoft.AppCenter.Ingestion.ServiceCall : object {
    private CancellationTokenSource _tokenSource;
    private Action`1<IServiceCall> _continuationAction;
    private object _lock;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstallId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Log> <Logs>k__BackingField;
    public bool IsCanceled { get; }
    public bool IsCompleted { get; private set; }
    public bool IsFaulted { get; }
    public string Result { get; private set; }
    public Exception Exception { get; private set; }
    public CancellationToken CancellationToken { get; }
    public string AppSecret { get; }
    public Guid InstallId { get; }
    public IList`1<Log> Logs { get; }
    public ServiceCall(string appSecret, Guid installId, IList`1<Log> logs);
    public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    public sealed virtual bool get_IsFaulted();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public string get_AppSecret();
    [CompilerGeneratedAttribute]
public Guid get_InstallId();
    [CompilerGeneratedAttribute]
public IList`1<Log> get_Logs();
    public sealed virtual void ContinueWith(Action`1<IServiceCall> continuationAction);
    public void CopyState(IServiceCall source);
    public void SetResult(string result);
    public void SetException(Exception exception);
    public sealed virtual void Cancel();
    public sealed virtual void Dispose();
}
public enum Microsoft.AppCenter.LogLevel : Enum {
    public int value__;
    public static LogLevel Verbose;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Assert;
    public static LogLevel None;
}
internal class Microsoft.AppCenter.ManagmentClassFactory : object {
    private static ManagmentClassFactory _instanceField;
    internal static ManagmentClassFactory Instance { get; }
    internal static ManagmentClassFactory get_Instance();
    public sealed virtual ManagementClass GetComputerSystemClass();
    public sealed virtual ManagementClass GetOperatingSystemClass();
}
internal class Microsoft.AppCenter.NamespaceDoc : object {
}
public interface Microsoft.AppCenter.Storage.IStorage {
    public abstract virtual Task PutLog(string channelName, Log log);
    public abstract virtual Task DeleteLogs(string channelName, string batchId);
    public abstract virtual Task DeleteLogs(string channelName);
    public abstract virtual Task`1<int> CountLogsAsync(string channelName);
    public abstract virtual Task ClearPendingLogState(string channelName);
    public abstract virtual Task`1<string> GetLogsAsync(string channelName, int limit, List`1<Log> logs);
    public abstract virtual Task WaitOperationsAsync(TimeSpan timeout);
    public abstract virtual Task`1<bool> ShutdownAsync(TimeSpan timeout);
    public abstract virtual Task`1<bool> SetMaxStorageSizeAsync(long sizeInBytes);
}
public interface Microsoft.AppCenter.Storage.IStorageAdapter {
    public abstract virtual void Initialize(string databasePath);
    public abstract virtual void CreateTable(string tableName, String[] columnNames, String[] columnTypes);
    public abstract virtual int Count(string tableName, string columnName, object value);
    public abstract virtual IList`1<Object[]> Select(string tableName, string columnName, object value, string excludeColumnName, Object[] excludeValues, Nullable`1<int> limit, String[] orderList);
    public abstract virtual void Insert(string tableName, String[] columnNames, ICollection`1<Object[]> values);
    public abstract virtual void Delete(string tableName, string columnName, Object[] values);
    public abstract virtual bool SetMaxStorageSize(long sizeInBytes);
    public abstract virtual long GetMaxStorageSize();
}
internal class Microsoft.AppCenter.Storage.Storage : object {
    private static string TableName;
    private static string ColumnChannelName;
    private static string ColumnLogName;
    private static string ColumnIdName;
    private static string DbIdentifierDelimiter;
    private IStorageAdapter _storageAdapter;
    private string _databasePath;
    private Dictionary`2<string, IList`1<long>> _pendingDbIdentifierGroups;
    private HashSet`1<long> _pendingDbIdentifiers;
    private BlockingCollection`1<Task> _queue;
    private SemaphoreSlim _flushSemaphore;
    private Task _queueFlushTask;
    internal Storage(IStorageAdapter adapter, string databasePath);
    private static IStorageAdapter DefaultAdapter();
    public sealed virtual Task PutLog(string channelName, Log log);
    public sealed virtual Task DeleteLogs(string channelName, string batchId);
    public sealed virtual Task DeleteLogs(string channelName);
    public sealed virtual Task`1<int> CountLogsAsync(string channelName);
    public sealed virtual Task ClearPendingLogState(string channelName);
    private void ClearPendingLogStateWithoutEnqueue(string channelName);
    public sealed virtual Task`1<string> GetLogsAsync(string channelName, int limit, List`1<Log> logs);
    public sealed virtual Task`1<bool> SetMaxStorageSizeAsync(long sizeInBytes);
    private void ProcessLogIds(string channelName, string batchId, IEnumerable`1<Tuple`2<Nullable`1<Guid>, long>> idPairs);
    private void InitializeDatabase();
    private void EnsureDatabaseDirectoryExists();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Storage.Storage/<WaitOperationsAsync>d__27")]
public sealed virtual Task WaitOperationsAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Storage.Storage/<ShutdownAsync>d__28")]
public sealed virtual Task`1<bool> ShutdownAsync(TimeSpan timeout);
    private static string GetFullIdentifier(string channelName, string identifier);
    private static bool ChannelMatchesIdentifier(string channelName, string identifier);
    private Task AddTaskToQueue(Action action);
    private Task`1<T> AddTaskToQueue(Func`1<T> action);
    private Exception HandleStorageRelatedException(Exception e);
    private void AddTaskToQueue(Task task);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Storage.Storage/<FlushQueueAsync>d__35")]
private Task FlushQueueAsync();
    public sealed virtual void Dispose();
}
internal class Microsoft.AppCenter.Storage.StorageAdapter : object {
    private sqlite3 _db;
    private static StorageAdapter();
    public sealed virtual void Initialize(string databasePath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void BindParameter(sqlite3_stmt stmt, int index, object value);
    private void BindParameters(sqlite3_stmt stmt, IList`1<object> values);
    private object GetColumnValue(sqlite3_stmt stmt, int index);
    private int ExecuteNonSelectionSqlQuery(string query, IList`1<object> args);
    private List`1<Object[]> ExecuteSelectionSqlQuery(string query, IList`1<object> args);
    private long GetMaxPageCount();
    private long GetPageCount();
    private long GetPageSize();
    private long GetPragmaValue(string valueName);
    public sealed virtual long GetMaxStorageSize();
    public sealed virtual bool SetMaxStorageSize(long sizeInBytes);
    public sealed virtual void CreateTable(string tableName, String[] columnNames, String[] columnTypes);
    public sealed virtual int Count(string tableName, string columnName, object value);
    public sealed virtual IList`1<Object[]> Select(string tableName, string columnName, object value, string excludeColumnName, Object[] excludeValues, Nullable`1<int> limit, String[] orderList);
    public sealed virtual void Insert(string tableName, String[] columnNames, ICollection`1<Object[]> values);
    public sealed virtual void Delete(string tableName, string columnName, Object[] values);
    private StorageException ToStorageException(int result, string message);
    private static string BuildBindingMask(int amount);
}
internal class Microsoft.AppCenter.Storage.StorageCorruptedException : StorageException {
    private static string DefaultMessage;
    public StorageCorruptedException(string message);
}
internal class Microsoft.AppCenter.Storage.StorageException : AppCenterException {
    private static string DefaultMessage;
    public StorageException(string message);
    public StorageException(string message, Exception innerException);
    public StorageException(Exception innerException);
}
internal class Microsoft.AppCenter.Storage.StorageFullException : StorageException {
    private static string DefaultMessage;
    public StorageFullException(string message);
}
public abstract class Microsoft.AppCenter.Utils.AbstractDeviceInformationHelper : object {
    public static string DefaultSystemManufacturer;
    public static string DefaultSystemProductName;
    public static string DefaultSystemSku;
    [CompilerGeneratedAttribute]
private static EventHandler InformationInvalidated;
    private static string _country;
    private static WrapperSdk _wrapperSdk;
    private static AbstractDeviceInformationHelper();
    [CompilerGeneratedAttribute]
public static void add_InformationInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_InformationInvalidated(EventHandler value);
    internal static void SetCountryCode(string countryCode);
    public virtual Task`1<Device> GetDeviceInformationAsync();
    public virtual Device GetDeviceInformation();
    internal static void SetWrapperSdk(WrapperSdk wrapperSdk);
    protected static void InvalidateInformation(object sender, EventArgs e);
    protected abstract virtual string GetSdkName();
    protected abstract virtual string GetDeviceModel();
    protected abstract virtual string GetDeviceOemName();
    protected abstract virtual string GetOsName();
    protected abstract virtual string GetOsBuild();
    protected abstract virtual string GetOsVersion();
    protected abstract virtual string GetAppVersion();
    protected abstract virtual string GetAppBuild();
    protected abstract virtual string GetScreenSize();
    protected virtual string GetCarrierName();
    protected virtual string GetCarrierCountry();
    protected virtual string GetAppNamespace();
    protected virtual string GetLiveUpdateReleaseLabel();
    protected virtual string GetLiveUpdateDevelopmentKey();
    protected virtual string GetLiveUpdatePackageHash();
    private string GetSdkVersion();
    private string GetLocale();
    private int GetTimeZoneOffset();
    private string GetWrapperSdkVersion();
    private string GetWrapperSdkName();
    private string GetWrapperRuntimeVersion();
    private Nullable`1<int> GetOsApiLevel();
    [CompilerGeneratedAttribute]
private Device <GetDeviceInformationAsync>b__9_0();
}
public class Microsoft.AppCenter.Utils.ApplicationLifecycleHelperDesktop : ApplicationLifecycleHelper {
    private static WinEventDelegate _OnMinimizedDelegate;
    private static ApplicationLifecycleHelperDesktop();
    private static void OnMinimized(IntPtr winEventHookHandle, UInt32 eventType, IntPtr windowHandle, int objectId, int childId, UInt32 eventThreadId, UInt32 eventTimeInMilliseconds);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_1(object sender, object eventArgs);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object sender, UnhandledExceptionEventArgs eventArgs);
}
public class Microsoft.AppCenter.Utils.ApplicationLifecycleHelperWinUI : ApplicationLifecycleHelper {
    internal void InvokeUnhandledExceptionOccurred(object sender, Exception exception);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_3(object sender, UnhandledErrorDetectedEventArgs eventArgs);
}
public static class Microsoft.AppCenter.Utils.Constants : object {
    private static string AppCenterFilesDirectoryPathBacking;
    public static string AppCenterDatabasePath;
    [CompilerGeneratedAttribute]
private static string <UserName>k__BackingField;
    public static string KeyPrefix;
    public static int DefaultTriggerCount;
    public static TimeSpan DefaultTriggerInterval;
    public static int DefaultTriggerMaxParallelRequests;
    public static string AppCenterFilesDirectoryPath { get; }
    public static string LocalAppData { get; }
    public static string UserName { get; internal set; }
    private static Constants();
    public static string get_AppCenterFilesDirectoryPath();
    public static string get_LocalAppData();
    [CompilerGeneratedAttribute]
public static string get_UserName();
    [CompilerGeneratedAttribute]
internal static void set_UserName(string value);
}
public class Microsoft.AppCenter.Utils.DefaultApplicationSettings : object {
    private static string FileName;
    private static string CorruptedConfigurationWarning;
    private static object configLock;
    private static Configuration configuration;
    [CompilerGeneratedAttribute]
private static string <FilePath>k__BackingField;
    internal static string FilePath { get; private set; }
    private static DefaultApplicationSettings();
    [CompilerGeneratedAttribute]
internal static string get_FilePath();
    [CompilerGeneratedAttribute]
private static void set_FilePath(string value);
    public sealed virtual T GetValue(string key, T defaultValue);
    public sealed virtual void SetValue(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Remove(string key);
    private void SaveValue(string key, string value);
    private void SaveConfiguration();
    private static Configuration OpenConfiguration();
    private void RestoreConfigurationFile();
}
public class Microsoft.AppCenter.Utils.DeviceInformationHelper : AbstractDeviceInformationHelper {
    private IManagmentClassFactory _managmentClassFactory;
    private static string _defaultVersion;
    private static string ProductVersion { get; }
    private static string DeploymentVersion { get; }
    private static FileVersionInfo AssemblyVersion { get; }
    internal void SetManagmentClassFactory(IManagmentClassFactory factory);
    protected virtual string GetSdkName();
    protected virtual string GetDeviceModel();
    protected virtual string GetAppNamespace();
    protected virtual string GetDeviceOemName();
    protected virtual string GetOsName();
    protected virtual string GetOsBuild();
    protected virtual string GetOsVersion();
    protected virtual string GetAppVersion();
    protected virtual string GetAppBuild();
    protected virtual string GetScreenSize();
    private static string get_ProductVersion();
    private static string get_DeploymentVersion();
    private static FileVersionInfo get_AssemblyVersion();
}
public class Microsoft.AppCenter.Utils.Files.Directory : object {
    private DirectoryInfo _underlyingDirectoryInfo;
    public string FullName { get; }
    public Directory(string directoryPath);
    public virtual string get_FullName();
    public virtual IEnumerable`1<File> EnumerateFiles(string searchPattern);
    public virtual void CreateFile(string name, string contents);
    public virtual void Create();
    public virtual void Delete(bool recursive);
    public virtual bool Exists();
    public virtual void Refresh();
}
public class Microsoft.AppCenter.Utils.Files.File : object {
    private FileInfo _underlyingFileInfo;
    public string Name { get; }
    public string FullName { get; }
    public File(string filePath);
    internal File(FileInfo fileInfo);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual void Delete();
    public virtual string ReadAllText();
}
public interface Microsoft.AppCenter.Utils.IApplicationLifecycleHelper {
    public bool IsSuspended { get; }
    public abstract virtual bool get_IsSuspended();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ApplicationSuspended(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ApplicationSuspended(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ApplicationResuming(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ApplicationResuming(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnhandledExceptionOccurred(EventHandler`1<UnhandledExceptionOccurredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnhandledExceptionOccurred(EventHandler`1<UnhandledExceptionOccurredEventArgs> value);
}
public interface Microsoft.AppCenter.Utils.IApplicationSettings {
    public abstract virtual T GetValue(string key, T defaultValue);
    public abstract virtual void SetValue(string key, object value);
    public abstract virtual bool ContainsKey(string key);
    public abstract virtual void Remove(string key);
}
public interface Microsoft.AppCenter.Utils.IApplicationSettingsFactory {
    public abstract virtual IApplicationSettings CreateApplicationSettings();
}
public interface Microsoft.AppCenter.Utils.IDeviceInformationHelper {
    public abstract virtual Task`1<Device> GetDeviceInformationAsync();
    public abstract virtual Device GetDeviceInformation();
}
public class Microsoft.AppCenter.Utils.Synchronization.State : object {
    private int _stateNum;
    private State(int stateNum);
    public State GetNextState();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.AppCenter.Utils.Synchronization.StatefulMutex : object {
    private SemaphoreSlim _mutex;
    private State _state;
    public State State { get; }
    public State get_State();
    public State InvalidateState();
    public bool IsCurrent(State state);
    public LockHolder GetLock();
    public LockHolder GetLock(State state);
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Utils.Synchronization.StatefulMutex/<GetLockAsync>d__8")]
public Task`1<LockHolder> GetLockAsync();
    [AsyncStateMachineAttribute("Microsoft.AppCenter.Utils.Synchronization.StatefulMutex/<GetLockAsync>d__9")]
public Task`1<LockHolder> GetLockAsync(State state);
    public sealed virtual void Dispose();
}
public class Microsoft.AppCenter.Utils.Synchronization.StatefulMutexException : AppCenterException {
    public StatefulMutexException(string message);
    public StatefulMutexException(string message, Exception innerException);
}
public static class Microsoft.AppCenter.Utils.TimeHelper : object {
    public static long CurrentTimeInMilliseconds();
}
public class Microsoft.AppCenter.Utils.UnhandledExceptionOccurredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public UnhandledExceptionOccurredEventArgs(Exception e);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public static class Microsoft.AppCenter.Utils.WindowsHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsRunningAsWpf>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsRunningAsUwp>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsRunningAsWinUI>k__BackingField;
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private static object <WpfApplication>k__BackingField;
    private static long APPMODEL_ERROR_NO_PACKAGE;
    private static UInt32 EVENT_SYSTEM_MINIMIZESTART;
    private static UInt32 EVENT_SYSTEM_MINIMIZEEND;
    private static UInt32 WINEVENT_OUTOFCONTEXT;
    private static IDictionary`2<WinEventDelegate, IntPtr> _hooks;
    private static int DESKTOPVERTRES;
    private static int DESKTOPHORZRES;
    private static int Minimized;
    public static bool IsRunningAsWpf { get; }
    public static bool IsRunningAsUwp { get; }
    public static bool IsRunningAsWinUI { get; }
    [DynamicAttribute]
public static object WpfApplication { get; }
    private static WindowsHelper();
    [CompilerGeneratedAttribute]
public static bool get_IsRunningAsWpf();
    [CompilerGeneratedAttribute]
public static bool get_IsRunningAsUwp();
    [CompilerGeneratedAttribute]
public static bool get_IsRunningAsWinUI();
    [CompilerGeneratedAttribute]
public static object get_WpfApplication();
    private static int GetCurrentPackageFullName(Int32& packageFullNameLength, StringBuilder packageFullName);
    private static bool _IsRunningAsUwp();
    private static bool _IsRunningAsWinUI();
    private static IntPtr SetWinEventHook(UInt32 eventMin, UInt32 eventMax, IntPtr eventHookAssemblyHandle, WinEventDelegate eventHookHandle, UInt32 processId, UInt32 threadId, UInt32 dwFlags);
    private static bool UnhookWinEvent(IntPtr hWinEventHook);
    public static void add_OnMinimized(WinEventDelegate value);
    public static void remove_OnMinimized(WinEventDelegate value);
    private static int GetDeviceCaps(IntPtr hdc, int nIndex);
    public static void GetScreenSize(Int32& width, Int32& height);
    private static Assembly GetAssembly(string name);
    private static Rectangle WindowsRectToRectangle(object windowsRect);
    private static bool WindowIntersectsWithAnyScreen(object window);
    public static bool IsAnyWindowNotMinimized();
    public static string GetWinFormsProductVersion();
}
public class Microsoft.AppCenter.Utils.WinEventDelegate : MulticastDelegate {
    public WinEventDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr winEventHookHandle, UInt32 eventType, IntPtr windowHandle, int objectId, int childId, UInt32 eventThreadId, UInt32 eventTimeInMilliseconds);
    public virtual IAsyncResult BeginInvoke(IntPtr winEventHookHandle, UInt32 eventType, IntPtr windowHandle, int objectId, int childId, UInt32 eventThreadId, UInt32 eventTimeInMilliseconds, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.AppCenter.Windows.Shared.Utils.CultureInfoHelper : object {
    private static UInt32 LOCALE_SNAME;
    private static string LOCALE_NAME_USER_DEFAULT;
    private static string LOCALE_NAME_SYSTEM_DEFAULT;
    private static int BUFFER_SIZE;
    private static int GetLocaleInfoEx(string lpLocaleName, UInt32 LCType, StringBuilder lpLCData, int cchData);
    public static CultureInfo GetCurrentCulture();
    private static string InvokeGetLocaleInfoEx(string lpLocaleName, UInt32 LCType);
}
public static class Microsoft.AppCenter.Windows.Shared.Utils.PropertyValidator : object {
    internal static int MaxProperties;
    internal static int MaxPropertyKeyLength;
    internal static int MaxPropertyValueLength;
    public static IDictionary`2<string, string> ValidateProperties(IDictionary`2<string, string> properties, string logName);
}
public static class Microsoft.AppCenter.Windows.Shared.Utils.SessionContext : object {
    [CompilerGeneratedAttribute]
private static Nullable`1<Guid> <SessionId>k__BackingField;
    public static Nullable`1<Guid> SessionId { get; public set; }
    [CompilerGeneratedAttribute]
public static Nullable`1<Guid> get_SessionId();
    [CompilerGeneratedAttribute]
public static void set_SessionId(Nullable`1<Guid> value);
}
public class Microsoft.AppCenter.Windows.Shared.Utils.UserIdContext : object {
    private static object UserIdLock;
    private static UserIdContext _instanceField;
    private string _userId;
    private object UserIdContextLock;
    public static int UserIdMaxLength;
    [CompilerGeneratedAttribute]
private static EventHandler`1<UserIdUpdatedEventArgs> UserIdUpdated;
    public static UserIdContext Instance { get; public set; }
    public string UserId { get; public set; }
    private static UserIdContext();
    [CompilerGeneratedAttribute]
public static void add_UserIdUpdated(EventHandler`1<UserIdUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_UserIdUpdated(EventHandler`1<UserIdUpdatedEventArgs> value);
    public static UserIdContext get_Instance();
    public static void set_Instance(UserIdContext value);
    public string get_UserId();
    public void set_UserId(string value);
    public static bool CheckUserIdValidForAppCenter(string userId);
}
public class Microsoft.AppCenter.Windows.Shared.Utils.UserIdUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    public string UserId { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
internal void set_UserId(string value);
}
public class Microsoft.AppCenter.WrapperSdk : object {
    public static string Name;
    internal static string Version;
    [CompilerGeneratedAttribute]
private string <WrapperSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperSdkName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdateReleaseLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdateDeploymentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiveUpdatePackageHash>k__BackingField;
    public string WrapperSdkVersion { get; private set; }
    public string WrapperSdkName { get; private set; }
    public string WrapperRuntimeVersion { get; private set; }
    public string LiveUpdateReleaseLabel { get; private set; }
    public string LiveUpdateDeploymentKey { get; private set; }
    public string LiveUpdatePackageHash { get; private set; }
    public WrapperSdk(string wrapperSdkName, string wrapperSdkVersion, string wrapperRuntimeVersion, string liveUpdateReleaseLabel, string liveUpdateDeploymentKey, string liveUpdatePackageHash);
    [CompilerGeneratedAttribute]
public string get_WrapperSdkVersion();
    [CompilerGeneratedAttribute]
private void set_WrapperSdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperSdkName();
    [CompilerGeneratedAttribute]
private void set_WrapperSdkName(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperRuntimeVersion();
    [CompilerGeneratedAttribute]
private void set_WrapperRuntimeVersion(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdateReleaseLabel();
    [CompilerGeneratedAttribute]
private void set_LiveUpdateReleaseLabel(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdateDeploymentKey();
    [CompilerGeneratedAttribute]
private void set_LiveUpdateDeploymentKey(string value);
    [CompilerGeneratedAttribute]
public string get_LiveUpdatePackageHash();
    [CompilerGeneratedAttribute]
private void set_LiveUpdatePackageHash(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
