internal class Microsoft.ApplicationInsights.SnapshotCollector.AppInsightsProfileFetcher : object {
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.AppInsightsProfileFetcher/<FetchAppIdAsync>d__0")]
public sealed virtual Task`1<Guid> FetchAppIdAsync(ConnectionString connectionString, int retryCount, CancellationToken cancellationToken);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ApplicationInsightsProfilerEventSource : object {
    private EventSource _innerEventSource;
    public static string ProviderName;
    private static ApplicationInsightsProfilerEventSource s_instance;
    public static ApplicationInsightsProfilerEventSource Instance { get; }
    public bool IsActivityMonitoringActive { get; }
    public bool IsDetailedTracingActive { get; }
    internal ApplicationInsightsProfilerEventSource(string eventSourceName);
    public static ApplicationInsightsProfilerEventSource get_Instance();
    public sealed virtual void Dispose();
    public bool get_IsActivityMonitoringActive();
    public bool get_IsDetailedTracingActive();
}
internal abstract class Microsoft.ApplicationInsights.SnapshotCollector.ApplicationLifetimeBase : object {
    private CancellationTokenSource _stoppingCancellationTokenSource;
    public CancellationToken ApplicationStopping { get; }
    public sealed virtual CancellationToken get_ApplicationStopping();
    protected void Stop();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ApplicationLifetimeManager : ApplicationLifetimeBase {
    private void OnCurrentAppDomainUnload(object sender, EventArgs e);
    private void OnAssemblyLoadContextUnloading(object _);
}
[IsReadOnlyAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.AuthToken : ValueType {
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    public string Token { get; }
    public DateTimeOffset ExpiresOn { get; }
    public AuthToken(string token, DateTimeOffset expiresOn);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.AuthTokenProvider : object {
    private static PropertyInfo s_credentialEnvelopePropertyInfo;
    private static MethodInfo s_getTokenAsyncMethodInfo;
    private static PropertyInfo s_taskOfAuthTokenResultPropertyInfo;
    private static PropertyInfo s_tokenPropertyInfo;
    private static PropertyInfo s_expiresOnPropertyInfo;
    private TelemetryConfiguration _telemetryConfiguration;
    private GetTokenAsyncDelegate _delegate;
    public bool IsAadAuthenticationEnabled { get; }
    private static AuthTokenProvider();
    private AuthTokenProvider(TelemetryConfiguration telemetryConfiguration);
    public static IAuthTokenProvider FromCredentialEnvelope(TelemetryConfiguration telemetryConfiguration);
    public sealed virtual bool get_IsAadAuthenticationEnabled();
    public sealed virtual Task`1<AuthToken> GetTokenAsync(CancellationToken cancellationToken);
    private object GetCredentialEnvelope();
    private static GetTokenAsyncDelegate CreateDelegate(object credentialEnvelope);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.AuthTokenProvider/<AwaitAndUnwrap>d__16")]
private static Task`1<AuthToken> AwaitAndUnwrap(Task task);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.CannotGetMachineMemoryException : Exception {
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.CollectionPlan : object {
    private int _snapshotsRemaining;
    private DateTime _expiryTime;
    public static TimeSpan DefaultTimeToLive;
    [CompilerGeneratedAttribute]
private ProblemId <ProblemId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTracked>k__BackingField;
    public ProblemId ProblemId { get; }
    public bool IsTracked { get; public set; }
    public bool IsEnabled { get; }
    public bool HasExpired { get; }
    public bool IsComplete { get; }
    public CollectionPlan(ProblemId problem, int desiredSnapshots);
    public CollectionPlan(ProblemId problem, int desiredSnapshots, TimeSpan timeToLive);
    private static CollectionPlan();
    public void SnapshotCreated();
    [CompilerGeneratedAttribute]
public ProblemId get_ProblemId();
    [CompilerGeneratedAttribute]
public bool get_IsTracked();
    [CompilerGeneratedAttribute]
public void set_IsTracked(bool value);
    public bool get_IsEnabled();
    public bool get_HasExpired();
    public bool get_IsComplete();
    public void Reset(int desiredSnapshots);
    public void Reset(int desiredSnapshots, TimeSpan timeToLive);
    public void Disable();
    public virtual string ToString();
    public string GetTriggerDescription();
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.ConnectionString : object {
    [CompilerGeneratedAttribute]
private Guid <InstrumentationKeyGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Token[] <Tokens>k__BackingField;
    private static string FeatureSuffix;
    private static string TokenSeparator;
    private static char KeyValueSeparator;
    public string InstrumentationKey { get; }
    public Guid InstrumentationKeyGuid { get; private set; }
    public string EndpointSuffix { get; }
    internal Token[] Tokens { get; }
    public string Item { get; }
    private ConnectionString(IReadOnlyCollection`1<Token> tokens, Guid validatedGuidIkey);
    public static bool TryParse(string input, ConnectionString& connectionString);
    public static bool FromInstrumentationKey(string instrumentationKey, ConnectionString& connectionString);
    public ConnectionString WithInstrumentationKey(string instrumentationKey);
    public ConnectionString WithFeatureEndpoint(string feature, Uri endpoint);
    public ConnectionString WithEndpointSuffix(string endpointSuffix);
    public Uri GetFeatureEndpoint(string feature);
    public string get_InstrumentationKey();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Guid get_InstrumentationKeyGuid();
    [CompilerGeneratedAttribute]
private void set_InstrumentationKeyGuid(Guid value);
    public string get_EndpointSuffix();
    [CompilerGeneratedAttribute]
internal Token[] get_Tokens();
    [IteratorStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ConnectionString/<Tokenize>d__19")]
internal static IEnumerable`1<Token> Tokenize(string input);
    public ConnectionString WithToken(string key, string value);
    private ConnectionString WithToken(Token newToken);
    private ConnectionString WithToken(Token newToken, Guid instrumentationKeyGuid);
    private static string ResolveFeaturePrefix(string feature);
    private string FindFeatureEndpoint(string feature);
    private static string ComposeFeatureKey(string feature);
    private string FindTokenValueByKey(string key);
    private static string FindTokenValueByKey(IEnumerable`1<Token> tokens, string key);
    public string get_Item(string key);
    public bool TryGetValue(string key, String& value);
    public bool ContainsKey(string key);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ConnectionStringDiagnosticServicesExtension : object {
    [ExtensionAttribute]
public static Uri ResolveIngestionEndpoint(ConnectionString connectionString);
    [ExtensionAttribute]
public static Uri ResolveSnapshotEndpoint(ConnectionString connectionString);
    [ExtensionAttribute]
public static Uri ResolveAppIdFetchUri(ConnectionString connectionString);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ConnectionStringExtensions : object {
    [ExtensionAttribute]
public static ConnectionString WithIngestionEndpoint(ConnectionString connectionString, Uri ingestionEndpoint);
    [ExtensionAttribute]
public static ConnectionString WithSnapshotEndpoint(ConnectionString connectionString, Uri snapshotEndpoint);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ConnectionStringFeatures : object {
    public static Uri GetIngestionEndpoint(ConnectionString connectionString);
    public static Uri GetLiveMetricsEndpoint(ConnectionString connectionString);
    public static Uri GetProfilerEndpoint(ConnectionString connectionString);
    public static Uri GetSnapshotEndpoint(ConnectionString connectionString);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.CurrentAppDomainFirstChanceExceptionSource : object {
    private AppDomain _appDomain;
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> _firstChanceExceptionHandler;
    [CompilerGeneratedAttribute]
private void add__firstChanceExceptionHandler(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
private void remove__firstChanceExceptionHandler(EventHandler`1<Exception> value);
    public sealed virtual void add_FirstChanceException(EventHandler`1<Exception> value);
    public sealed virtual void remove_FirstChanceException(EventHandler`1<Exception> value);
    private void OnAppDomainFirstChanceException(object sender, FirstChanceExceptionEventArgs e);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.DeclaredPropertiesCache : object {
    private static int MaxCacheSize;
    private static ConcurrentDictionary`2<Type, IEnumerable`1<PropertyInfo>> s_cache;
    private static DeclaredPropertiesCache();
    public static IEnumerable`1<PropertyInfo> GetDeclaredProperties(object obj);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.DeOptimizationRequests : object {
    private ISnapshotCreator _snapshotCreator;
    private ILogger _logger;
    private ConcurrentDictionary`2<MethodBase, RefCounted`1<Guid>> _requests;
    internal SemaphoreSlim _testSemaphore;
    private ConcurrentDictionary`2<MethodBase, RefCounted`1<Guid>> Requests { get; }
    public DeOptimizationRequests(ISnapshotCreator snapshotCreator, ILogger logger);
    public sealed virtual void Dispose();
    public void DeOptimize(ProblemId problem);
    public void ReOptimize(ProblemId problem);
    private void DeOptimizeMethod(MethodBase method, bool throwOnFailure);
    private void ReOptimizeMethod(MethodBase method);
    public void Clear();
    private ConcurrentDictionary`2<MethodBase, RefCounted`1<Guid>> get_Requests();
    private void ReOptimizeInternal(MethodBase method, RefCounted`1<Guid> refCountedId);
    private RefCounted`1<Guid> CreateNewDeOptimizationRequest(MethodBase method);
    [CompilerGeneratedAttribute]
private RefCounted`1<Guid> <DeOptimizeMethod>b__8_0(MethodBase key);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.DeserializationFactory : object {
    private static Dictionary`2<Type, Func`2<BinaryReader, ISerializable>> s_factories;
    private static DeserializationFactory();
    public static void Register(Func`2<BinaryReader, T> creator);
    public static void Register();
    private static Func`2<BinaryReader, T> CreateCreator();
    public static T Deserialize(Byte[] data);
    [CompilerGeneratedAttribute]
internal static T <CreateCreator>g__creator|3_0(BinaryReader reader);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.EmittedMethod : MethodInfo {
    private MethodInfo _runtimeDynamicMethod;
    private Guid _ilHash;
    private static ReflectionHelperBase s_reflectionHelper;
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    private EmittedMethod(MethodInfo runtimeDynamicMethod, Guid ilHash);
    private static EmittedMethod();
    public static MethodBase CreateFromTargetSite(MethodBase targetSite);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmittedMethod other);
    public virtual int GetHashCode();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual string ToString();
    private static bool TryGetILStream(MethodBase targetSite, ArraySegment`1& ilStream);
    private static ReflectionHelperBase CreateReflectionHelper();
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.EncodingUtilities : object {
    private static string PIIMarker;
    public static string Sha256(string input);
    public static string Anonymize(string input);
    public static string AnonymizeBase64(string input);
    public static string MarkAsPII(string input);
    public static bool IsPII(string input);
    private static string Sha256(Byte[] input, int bytesNeeded);
    private static string Sha256Base64(Byte[] input, int bytesNeeded);
    public static Byte[] GetRandomBytes(int length);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Endpoints : object {
    public static string IngestionFeature;
    public static string LiveMetricsFeature;
    public static string ProfilerFeature;
    public static string SnapshotFeature;
    public static CloudType ResolveCloudType(string ingestionEndpointHost);
    public static ConnectionString GetInternalTelemetryConnectionString(Uri customerIngestionEndpoint);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.EnvironmentMemoryHelper : object {
    private static ulong FourGBInBytes;
    private static ulong OneGBInBytes;
    private static ulong OneAndHalfGBInBytes;
    private RuntimeEnvironment _runtimeEnvironment;
    private SnapshotCollectorConfiguration _configuration;
    public EnvironmentMemoryHelper(RuntimeEnvironment runtimeEnvironment, SnapshotCollectorConfiguration configuration);
    public sealed virtual bool IsMemorySafeForSnapshot(String& notSafeReason);
    public static void GetSandboxMemoryUsage(UInt64& sandboxCommitSize);
    internal static string PrettifyBytesValue(ulong size);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.EnvironmentUtilities : object {
    private static string s_hashedMachineNameWithoutSiteName;
    public static string EnablingSiteExtensionVersion { get; }
    public static string SnapshotFeatureVersion { get; }
    public static string MachineNameWithoutSiteName { get; }
    public static string HashedMachineNameWithoutSiteName { get; }
    public static string ExecutingAssemblyInformationalVersion { get; }
    public static string get_EnablingSiteExtensionVersion();
    public static string get_SnapshotFeatureVersion();
    public static string CheckAndSanitizeMachineName(string input, bool throwIfInvalid);
    public static string CreateSessionId();
    public static string get_MachineNameWithoutSiteName();
    public static string get_HashedMachineNameWithoutSiteName();
    public static bool IsRunningInAntares();
    public static string GetAppServiceSiteName();
    public static string GetAntaresVersion();
    public static bool IsRunningInAzureFunction();
    public static string GetAzureFunctionVersion();
    public static bool IsRunningInServiceFabric();
    public static bool IsRunningInCloudService();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.EnvironmentUtilities/<IsRunningInAzureVmAsync>d__17")]
public static Task`1<bool> IsRunningInAzureVmAsync(CancellationToken cancellationToken);
    public static bool IsRunningInWindowsContainer();
    public static bool IsSingleFileApplication();
    public static bool IsRunningNetCore30OrAbove();
    public static string get_ExecutingAssemblyInformationalVersion();
    private static string GetAssemblyFileVersion(Assembly assembly);
    private static string GetAssemblyInformationalVersion(Assembly assembly);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.EventHandlerHelpers : object {
    public static bool CombineDelegate(EventHandler`1& field, EventHandler`1<T> delegateToCombine);
    public static bool RemoveDelegate(EventHandler`1& field, EventHandler`1<T> delegateToRemove);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.SnapshotCollector.ExceptionExtensions : object {
    private static object s_snapshotContextKey;
    private static object s_processedKey;
    private static object s_snappointKey;
    private static ExceptionExtensions();
    [ExtensionAttribute]
public static Exception ExcludeFromSnapshotCollector(Exception exception);
    [ExtensionAttribute]
internal static void AddSnapshotContext(Exception ex, SnapshotContext snapshotContext);
    [ExtensionAttribute]
internal static SnapshotContext GetSnapshotContext(Exception ex);
    [ExtensionAttribute]
internal static bool HasSnapshotContext(Exception ex);
    [ExtensionAttribute]
internal static bool HasBeenProcessed(Exception ex);
    [ExtensionAttribute]
internal static bool IsSnappointAttached(Exception ex);
    [ExtensionAttribute]
internal static void AttachSnappoint(Exception ex, ExceptionSnappoint exceptionSnappoint);
    [ExtensionAttribute]
internal static bool TryUpdateHasBeenProcessed(Exception ex);
    [ExtensionAttribute]
internal static Exception GetInnermostExceptionWithValidTargetSite(Exception exception);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ExceptionTelemetryExtensions : object {
    [ExtensionAttribute]
public static bool HasSnapshotContext(ExceptionTelemetry exceptionTelemetry);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ExtractWasCalledMultipleTimesException : Exception {
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Filters.CallStackInfo : object {
    [CompilerGeneratedAttribute]
private int <CallstackDepthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <TypeSignatureMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MethodSignatureMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [DataMemberAttribute]
public int CallstackDepthLimit { get; public set; }
    [DataMemberAttribute]
public string TypeSignature { get; public set; }
    public MatchType TypeSignatureMatch { get; public set; }
    [DataMemberAttribute]
private string TypeSignatureMatchString { get; private set; }
    [DataMemberAttribute]
public string MethodSignature { get; public set; }
    public MatchType MethodSignatureMatch { get; public set; }
    [DataMemberAttribute]
private string MethodSignatureMatchString { get; private set; }
    [DataMemberAttribute]
public bool IsRequired { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CallstackDepthLimit();
    [CompilerGeneratedAttribute]
public void set_CallstackDepthLimit(int value);
    [CompilerGeneratedAttribute]
public string get_TypeSignature();
    [CompilerGeneratedAttribute]
public void set_TypeSignature(string value);
    [CompilerGeneratedAttribute]
public MatchType get_TypeSignatureMatch();
    [CompilerGeneratedAttribute]
public void set_TypeSignatureMatch(MatchType value);
    private string get_TypeSignatureMatchString();
    private void set_TypeSignatureMatchString(string value);
    [CompilerGeneratedAttribute]
public string get_MethodSignature();
    [CompilerGeneratedAttribute]
public void set_MethodSignature(string value);
    [CompilerGeneratedAttribute]
public MatchType get_MethodSignatureMatch();
    [CompilerGeneratedAttribute]
public void set_MethodSignatureMatch(MatchType value);
    private string get_MethodSignatureMatchString();
    private void set_MethodSignatureMatchString(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Filters.ExceptionInfo : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <TypeMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MessageMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExceptionCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [DataMemberAttribute]
public string TypeName { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    public MatchType TypeMatch { get; public set; }
    [DataMemberAttribute]
private string TypeMatchString { get; private set; }
    public MatchType MessageMatch { get; public set; }
    [DataMemberAttribute]
private string MessageMatchString { get; private set; }
    [DataMemberAttribute]
public int ExceptionCode { get; public set; }
    [DataMemberAttribute]
public bool IsRequired { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public MatchType get_TypeMatch();
    [CompilerGeneratedAttribute]
public void set_TypeMatch(MatchType value);
    private string get_TypeMatchString();
    private void set_TypeMatchString(string value);
    [CompilerGeneratedAttribute]
public MatchType get_MessageMatch();
    [CompilerGeneratedAttribute]
public void set_MessageMatch(MatchType value);
    private string get_MessageMatchString();
    private void set_MessageMatchString(string value);
    [CompilerGeneratedAttribute]
public int get_ExceptionCode();
    [CompilerGeneratedAttribute]
public void set_ExceptionCode(int value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Filters.ExceptionSnappoint : SnappointBase {
    [CompilerGeneratedAttribute]
private string <ProblemId>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchOptions <MatchOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo <ExceptionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CallStackInfo <CallstackInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSnapshotsLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SnapshotOnFirstOccurrence>k__BackingField;
    private ProblemIdInfo _problemIdInfo;
    [DataMemberAttribute]
public string ProblemId { get; public set; }
    public MatchOptions MatchOptions { get; public set; }
    [DataMemberAttribute]
private string MatchOptionsString { get; private set; }
    [DataMemberAttribute]
public ExceptionInfo ExceptionInfo { get; public set; }
    [DataMemberAttribute]
public CallStackInfo CallstackInfo { get; public set; }
    [DataMemberAttribute]
public int MaxSnapshotsLimit { get; public set; }
    [DataMemberAttribute]
public bool SnapshotOnFirstOccurrence { get; public set; }
    public bool IsMatchByProblemId { get; }
    public bool IsMatchByExceptionCode { get; }
    public bool IsMatchByExceptionType { get; }
    public bool IsMatchByExceptionMessage { get; }
    public bool IsMatchByExceptionCallstack { get; }
    public bool IsMatchAll { get; }
    [CompilerGeneratedAttribute]
public string get_ProblemId();
    [CompilerGeneratedAttribute]
public void set_ProblemId(string value);
    [CompilerGeneratedAttribute]
public MatchOptions get_MatchOptions();
    [CompilerGeneratedAttribute]
public void set_MatchOptions(MatchOptions value);
    private string get_MatchOptionsString();
    private void set_MatchOptionsString(string value);
    [CompilerGeneratedAttribute]
public ExceptionInfo get_ExceptionInfo();
    [CompilerGeneratedAttribute]
public void set_ExceptionInfo(ExceptionInfo value);
    [CompilerGeneratedAttribute]
public CallStackInfo get_CallstackInfo();
    [CompilerGeneratedAttribute]
public void set_CallstackInfo(CallStackInfo value);
    [CompilerGeneratedAttribute]
public int get_MaxSnapshotsLimit();
    [CompilerGeneratedAttribute]
public void set_MaxSnapshotsLimit(int value);
    [CompilerGeneratedAttribute]
public bool get_SnapshotOnFirstOccurrence();
    [CompilerGeneratedAttribute]
public void set_SnapshotOnFirstOccurrence(bool value);
    public bool IsMatchBy(MatchOptions matchOption);
    public bool get_IsMatchByProblemId();
    public bool get_IsMatchByExceptionCode();
    public bool get_IsMatchByExceptionType();
    public bool get_IsMatchByExceptionMessage();
    public bool get_IsMatchByExceptionCallstack();
    public bool get_IsMatchAll();
    public ProblemIdInfo GetProblemIdInfo();
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Filters.ExceptionSnappointSettingsContract : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExceptionSnappoint> <ExceptionSnappoints>k__BackingField;
    [DataMemberAttribute]
public Guid Id { get; public set; }
    [DataMemberAttribute]
public string Version { get; public set; }
    [DataMemberAttribute]
public DateTime LastModified { get; public set; }
    [DataMemberAttribute]
public List`1<ExceptionSnappoint> ExceptionSnappoints { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
    [CompilerGeneratedAttribute]
public List`1<ExceptionSnappoint> get_ExceptionSnappoints();
    [CompilerGeneratedAttribute]
public void set_ExceptionSnappoints(List`1<ExceptionSnappoint> value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Filters.ExceptionSnappointSettingsExtensions : object {
    [ExtensionAttribute]
public static ExceptionSnappoint GetFirstMatch(ExceptionSnappointSettingsContract filters, Exception ex);
    [ExtensionAttribute]
public static ExceptionSnappoint GetFirstMatch(ExceptionSnappointSettingsContract filters, Exception ex, ProblemId problemId);
    public static bool IsMatch(ExceptionSnappoint filter, Exception ex, ProblemId problemId);
    private static bool CheckMethodSignature(Exception ex, CallStackInfo frameInfo);
    private static bool CheckExceptionType(Exception ex, ExceptionInfo exInfo);
    private static bool TokenMatch(MatchType matchType, string originalValue, string valueToMatch);
    private static bool CheckExceptionMessage(Exception ex, ExceptionInfo exInfo);
}
[DataContractAttribute]
[FlagsAttribute]
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Filters.MatchOptions : Enum {
    public int value__;
    [EnumMemberAttribute]
public static MatchOptions MatchOnProblemId;
    [EnumMemberAttribute]
public static MatchOptions MatchOnExceptionType;
    [EnumMemberAttribute]
public static MatchOptions MatchOnExceptionMessage;
    [EnumMemberAttribute]
public static MatchOptions MatchOnExceptionCode;
    [EnumMemberAttribute]
public static MatchOptions MatchOnCallstack;
    [EnumMemberAttribute]
public static MatchOptions CaptureAll;
}
[DataContractAttribute]
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Filters.MatchType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static MatchType Exact;
    [EnumMemberAttribute]
public static MatchType Contains;
    [EnumMemberAttribute]
public static MatchType Regex;
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Filters.ProblemIdInfo : object {
    [CompilerGeneratedAttribute]
private string <ExceptionTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThrowingMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThrowingModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IlOffset>k__BackingField;
    public string ExceptionTypeName { get; public set; }
    public string ThrowingMethodName { get; public set; }
    public string ThrowingModuleName { get; public set; }
    public int IlOffset { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExceptionTypeName();
    [CompilerGeneratedAttribute]
public void set_ExceptionTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_ThrowingMethodName();
    [CompilerGeneratedAttribute]
public void set_ThrowingMethodName(string value);
    [CompilerGeneratedAttribute]
public string get_ThrowingModuleName();
    [CompilerGeneratedAttribute]
public void set_ThrowingModuleName(string value);
    [CompilerGeneratedAttribute]
public int get_IlOffset();
    [CompilerGeneratedAttribute]
public void set_IlOffset(int value);
}
[DataContractAttribute]
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Filters.SnappointAction : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SnappointAction CaptureFullDump;
    [EnumMemberAttribute]
public static SnappointAction CaptureTrace;
    [EnumMemberAttribute]
public static SnappointAction CaptureMiniDump;
}
[DataContractAttribute]
internal abstract class Microsoft.ApplicationInsights.SnapshotCollector.Filters.SnappointBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SnappointType <SnappointType>k__BackingField;
    [CompilerGeneratedAttribute]
private SnappointAction <Action>k__BackingField;
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public Guid Id { get; public set; }
    public SnappointType SnappointType { get; public set; }
    [DataMemberAttribute]
private string SnappointTypeString { get; private set; }
    public SnappointAction Action { get; public set; }
    [DataMemberAttribute]
private string ActionString { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public SnappointType get_SnappointType();
    [CompilerGeneratedAttribute]
public void set_SnappointType(SnappointType value);
    private string get_SnappointTypeString();
    private void set_SnappointTypeString(string value);
    [CompilerGeneratedAttribute]
public SnappointAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SnappointAction value);
    private string get_ActionString();
    private void set_ActionString(string value);
}
[DataContractAttribute]
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Filters.SnappointType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SnappointType Collect;
    [EnumMemberAttribute]
public static SnappointType Skip;
    [EnumMemberAttribute]
public static SnappointType CollectAndAnalyze;
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.GetStampIdResponse : object {
    [CompilerGeneratedAttribute]
private string <stampID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <appId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <failStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private QuotaInformation <quota>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionSnappointSettingsContract <ExceptionSnappointSettings>k__BackingField;
    [DataMemberAttribute]
public string stampID { get; public set; }
    [DataMemberAttribute]
public string appId { get; public set; }
    [DataMemberAttribute]
public string failStatus { get; public set; }
    [DataMemberAttribute]
public QuotaInformation quota { get; public set; }
    [DataMemberAttribute]
public ExceptionSnappointSettingsContract ExceptionSnappointSettings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_stampID();
    [CompilerGeneratedAttribute]
public void set_stampID(string value);
    [CompilerGeneratedAttribute]
public string get_appId();
    [CompilerGeneratedAttribute]
public void set_appId(string value);
    [CompilerGeneratedAttribute]
public string get_failStatus();
    [CompilerGeneratedAttribute]
public void set_failStatus(string value);
    [CompilerGeneratedAttribute]
public QuotaInformation get_quota();
    [CompilerGeneratedAttribute]
public void set_quota(QuotaInformation value);
    [CompilerGeneratedAttribute]
public ExceptionSnappointSettingsContract get_ExceptionSnappointSettings();
    [CompilerGeneratedAttribute]
public void set_ExceptionSnappointSettings(ExceptionSnappointSettingsContract value);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.HashHelpers : object {
    public static int Combine(int h1, int h2);
    public static int Combine(object o1, object o2);
    public static int HashCodeOrZeroIfNull(object o);
}
internal enum Microsoft.ApplicationInsights.SnapshotCollector.HeartbeatMetricIndex : Enum {
    public int value__;
    public static HeartbeatMetricIndex TrackExceptionCalls;
    public static HeartbeatMetricIndex FirstChanceExceptions;
    public static HeartbeatMetricIndex SkippedExceptions;
    public static HeartbeatMetricIndex SnappointMatchExceptions;
    public static HeartbeatMetricIndex CannotSnapshotDueToMemoryUsage;
    public static HeartbeatMetricIndex SnapshotDailyRateLimitReached;
    public static HeartbeatMetricIndex SnapshotRateLimitExceeded;
    public static HeartbeatMetricIndex CollectionPlanComplete;
    public static HeartbeatMetricIndex MaxMetricIndex;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ApplicationInsights.SnapshotCollector.HeartbeatMetrics : object {
    private Int32[] _counts;
    private double Item { get; }
    public sealed virtual void IncrementMetric(HeartbeatMetricIndex index);
    public Dictionary`2<string, double> MetricsToDictionary();
    private double get_Item(HeartbeatMetricIndex index);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.HttpRequest : object {
    private static HttpClient s_httpClient;
    private static HttpRequest();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.HttpRequest/<GetAsStringAsync>d__0")]
public static Task`1<HttpResponse`1<string>> GetAsStringAsync(Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.HttpRequest/<SendAsync>d__1`1")]
public static Task`1<HttpResponse`1<T>> SendAsync(HttpRequestMessage requestMessage, Func`2<Stream, T> responseStreamFunction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.HttpRequest/<FromErrorResponse>d__2")]
private static Task`1<HttpRequestException> FromErrorResponse(HttpResponseMessage response);
    public static bool IsTlsProtocolException(Exception ex);
    private static HttpClientHandler GetHandler();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.HttpResponse`1 : object {
    [CompilerGeneratedAttribute]
private T <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <RequestException>k__BackingField;
    public T Content { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public Exception RequestException { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(T value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public Exception get_RequestException();
    [CompilerGeneratedAttribute]
public void set_RequestException(Exception value);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IAppInsightsProfileFetcher {
    public abstract virtual Task`1<Guid> FetchAppIdAsync(ConnectionString connectionString, int retryCount, CancellationToken cancellationToken);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IApplicationLifetime {
    public CancellationToken ApplicationStopping { get; }
    public abstract virtual CancellationToken get_ApplicationStopping();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IAuthTokenProvider {
    public bool IsAadAuthenticationEnabled { get; }
    public abstract virtual bool get_IsAadAuthenticationEnabled();
    public abstract virtual Task`1<AuthToken> GetTokenAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IEnvironmentMemory {
    public abstract virtual bool IsMemorySafeForSnapshot(String& notSafeReason);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IFirstChanceExceptionSource {
    [CompilerGeneratedAttribute]
public abstract virtual void add_FirstChanceException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FirstChanceException(EventHandler`1<Exception> value);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IHeartbeatMetrics {
    public abstract virtual void IncrementMetric(HeartbeatMetricIndex index);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ILogger {
    public abstract virtual void Log(string name, object value);
    public abstract virtual void LogWithMemory(string name, object value);
    public abstract virtual void LogQuiet(string name, object value);
    public abstract virtual bool IsEnabled(string name);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.INativeComponentsManager {
    public abstract virtual Task ExtractNativeComponentsAsync(string destinationFolder, CancellationToken cancellationToken);
    public abstract virtual bool AttachCLRProfilerIfNecessary();
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ActivityContext : object {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityRootId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityId>k__BackingField;
    [DataMemberAttribute]
public string SessionId { get; public set; }
    [DataMemberAttribute]
public string ActivityRootId { get; public set; }
    [DataMemberAttribute]
public string ActivityId { get; public set; }
    public static ActivityContext FromCurrentActivity(string sessionId);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityRootId();
    [CompilerGeneratedAttribute]
public void set_ActivityRootId(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(string value);
    public virtual string ToString();
}
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Interop.DumpRequestType : Enum {
    public int value__;
    public static DumpRequestType Minidump;
    public static DumpRequestType FullMemory;
    public static DumpRequestType GCHeap;
}
internal abstract class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ExceptionPointers : object {
    private static Func`1<IntPtr> s_getExceptionPointersMethod;
    public static ExceptionPointers Empty { get; }
    public UInt32 ExceptionCode { get; public set; }
    private static ExceptionPointers();
    public static ExceptionPointers get_Empty();
    public static ExceptionPointers CreateFromCurrentExceptionPointers();
    public static ExceptionPointers CreateFromNativePointers(IntPtr nativeExceptionPointers);
    public abstract virtual void Serialize(BinaryWriter writer);
    public abstract virtual UInt32 get_ExceptionCode();
    public abstract virtual void set_ExceptionCode(UInt32 value);
    public abstract virtual void CopyContext(Void* context, int sizeOfContextRecord);
    public abstract virtual EXCEPTION_POINTERS GetPinnedEXCEPTION_POINTERS(GCHandle& pinnedHandle);
    protected static void Serialize(BinaryWriter writer, Void* pv, int len);
    protected static void MemoryCopy(Void* source, Void* destination, int destinationSizeInBytes, int sourceBytesToCopy);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ExceptionPointers32 : ExceptionPointers {
    private EP32 _ep;
    public static ExceptionPointers Empty;
    public UInt32 ExceptionCode { get; public set; }
    public ExceptionPointers32(IntPtr exceptionPointers);
    private ExceptionPointers32(BinaryReader reader);
    private static ExceptionPointers32();
    public virtual UInt32 get_ExceptionCode();
    public virtual void set_ExceptionCode(UInt32 value);
    public virtual void CopyContext(Void* context, int sizeOfContextRecord);
    public virtual EXCEPTION_POINTERS GetPinnedEXCEPTION_POINTERS(GCHandle& pinnedHandle);
    public virtual void Serialize(BinaryWriter writer);
    public static ExceptionPointers32 Deserialize(BinaryReader reader);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ExceptionPointers64 : ExceptionPointers {
    private EP64 _ep;
    public static ExceptionPointers Empty;
    public UInt32 ExceptionCode { get; public set; }
    public ExceptionPointers64(IntPtr exceptionPointers);
    private ExceptionPointers64(BinaryReader reader);
    private static ExceptionPointers64();
    public virtual UInt32 get_ExceptionCode();
    public virtual void set_ExceptionCode(UInt32 value);
    public virtual void CopyContext(Void* context, int sizeOfContextRecord);
    public virtual EXCEPTION_POINTERS GetPinnedEXCEPTION_POINTERS(GCHandle& pinnedHandle);
    public virtual void Serialize(BinaryWriter writer);
    public static ExceptionPointers64 Deserialize(BinaryReader reader);
}
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Interop.ExitCode : Enum {
    public int value__;
    public static ExitCode Unknown;
    public static ExitCode Unavailable;
    public static ExitCode Success;
    public static ExitCode InvalidArgs;
    public static ExitCode IKeyIsNotGUID;
    public static ExitCode Exception_WebProxy;
    public static ExitCode Exception_CreateDumpFolder;
    public static ExitCode ProcessWatcherCouldNotStart;
    public static ExitCode AnotherInstanceRunning;
    public static ExitCode InvalidProcessId;
    public static ExitCode Exception_FeatureUnavailable;
    public static ExitCode Exception_Handled;
    public static ExitCode Exception_RequestTimeout;
    public static ExitCode MissingConnectionStringAndIkey;
    public static ExitCode UnableToParseConnectionString;
    public static ExitCode UnableToParseAuthenticationString;
    public static ExitCode AadAuthenticationFailed;
    public static ExitCode Exception_InvalidOperationException;
    public static ExitCode Exception_RemoteCouldNotBeResolved;
    public static ExitCode UnhandledException;
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ExitCodeParser : object {
    public static ExitCode Parse(int exitCode);
    public static ExitCode FromException(Exception ex);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.PdbScanRequest : Request {
    internal static int Version;
    [CompilerGeneratedAttribute]
private string <SearchPaths>k__BackingField;
    public UInt32 SendingProcessId;
    public string SearchPaths { get; }
    public PdbScanRequest(string searchPaths);
    protected virtual void WriteTo(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public string get_SearchPaths();
    public virtual string ToString();
}
internal abstract class Microsoft.ApplicationInsights.SnapshotCollector.Interop.Request : object {
    [CompilerGeneratedAttribute]
private bool <IsFullyConstructed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDetached>k__BackingField;
    protected static UInt32 s_currentProcessId;
    protected bool IsFullyConstructed { get; }
    public bool IsDisposed { get; protected set; }
    public bool IsDetached { get; private set; }
    private static Request();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public void Serialize(Stream stream);
    protected abstract virtual void WriteTo(BinaryWriter writer);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
protected bool get_IsFullyConstructed();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
protected void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public bool get_IsDetached();
    [CompilerGeneratedAttribute]
private void set_IsDetached(bool value);
    public void Detach();
    protected virtual void DisposeNative();
    private static UInt32 GetCurrentProcessId();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.ShutdownRequest : Request {
    internal static int Version;
    public UInt32 SendingProcessId;
    protected virtual void WriteTo(BinaryWriter writer);
    public virtual string ToString();
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.SnapshotContext : object {
    [CompilerGeneratedAttribute]
private Guid <SnapshotId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StoppingProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StoppingProcessStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StoppingThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private DumpRequestType <DumpType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLowPriorityIO>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedSnapshotId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleName>k__BackingField;
    [DataMemberAttribute]
public Guid SnapshotId { get; public set; }
    [DataMemberAttribute]
public UInt32 StoppingProcessId { get; public set; }
    [DataMemberAttribute]
public DateTime StoppingProcessStartTime { get; public set; }
    [DataMemberAttribute]
public UInt32 StoppingThreadId { get; public set; }
    [DataMemberAttribute]
public DumpRequestType DumpType { get; public set; }
    [DataMemberAttribute]
public bool UseLowPriorityIO { get; public set; }
    [DataMemberAttribute]
public Guid RelatedSnapshotId { get; public set; }
    [DataMemberAttribute]
public string ProcessorArch { get; public set; }
    [DataMemberAttribute]
public string Platform { get; public set; }
    [DataMemberAttribute]
public string RoleName { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_SnapshotId();
    [CompilerGeneratedAttribute]
public void set_SnapshotId(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_StoppingProcessId();
    [CompilerGeneratedAttribute]
public void set_StoppingProcessId(UInt32 value);
    [CompilerGeneratedAttribute]
public DateTime get_StoppingProcessStartTime();
    [CompilerGeneratedAttribute]
public void set_StoppingProcessStartTime(DateTime value);
    [CompilerGeneratedAttribute]
public UInt32 get_StoppingThreadId();
    [CompilerGeneratedAttribute]
public void set_StoppingThreadId(UInt32 value);
    [CompilerGeneratedAttribute]
public DumpRequestType get_DumpType();
    [CompilerGeneratedAttribute]
public void set_DumpType(DumpRequestType value);
    [CompilerGeneratedAttribute]
public bool get_UseLowPriorityIO();
    [CompilerGeneratedAttribute]
public void set_UseLowPriorityIO(bool value);
    [CompilerGeneratedAttribute]
public Guid get_RelatedSnapshotId();
    [CompilerGeneratedAttribute]
public void set_RelatedSnapshotId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ProcessorArch();
    [CompilerGeneratedAttribute]
public void set_ProcessorArch(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_RoleName();
    [CompilerGeneratedAttribute]
public void set_RoleName(string value);
    public virtual string ToString();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.SnapshotRequest : Request {
    internal static int Version;
    public ExceptionPointers ExceptionPointers;
    public PssSnapshotInformation PssSnapshotInformation;
    [CompilerGeneratedAttribute]
private SnapshotRequestMetadata <Metadata>k__BackingField;
    private static DateTime s_stoppingProcessStartTime;
    public SnapshotRequestMetadata Metadata { get; }
    public Guid SnapshotId { get; }
    public SnapshotRequest(PssSnapshotInformation pssSnapshotInformation, ExceptionPointers exceptionPointers);
    private static SnapshotRequest();
    protected virtual void WriteTo(BinaryWriter writer);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public SnapshotRequestMetadata get_Metadata();
    public Guid get_SnapshotId();
    protected virtual void DisposeNative();
    public virtual string ToString();
    private static DateTime GetCurrentProcessStartTime();
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.SnapshotRequestMetadata : object {
    [CompilerGeneratedAttribute]
private SnapshotContext <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private TriggerInfo <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityContext <Activity>k__BackingField;
    [DataMemberAttribute]
public SnapshotContext Snapshot { get; public set; }
    [DataMemberAttribute]
public TriggerInfo Trigger { get; public set; }
    [DataMemberAttribute]
public ActivityContext Activity { get; public set; }
    [CompilerGeneratedAttribute]
public SnapshotContext get_Snapshot();
    [CompilerGeneratedAttribute]
public void set_Snapshot(SnapshotContext value);
    [CompilerGeneratedAttribute]
public TriggerInfo get_Trigger();
    [CompilerGeneratedAttribute]
public void set_Trigger(TriggerInfo value);
    [CompilerGeneratedAttribute]
public ActivityContext get_Activity();
    [CompilerGeneratedAttribute]
public void set_Activity(ActivityContext value);
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.Interop.TriggerInfo : object {
    public static TriggerInfo None;
    [CompilerGeneratedAttribute]
private TriggerType <TriggerType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TriggerTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TriggerDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerDescription>k__BackingField;
    [DataMemberAttribute]
public TriggerType TriggerType { get; public set; }
    [DataMemberAttribute]
public DateTime TriggerTime { get; public set; }
    [DataMemberAttribute]
public TimeSpan TriggerDuration { get; public set; }
    [DataMemberAttribute]
public string TriggerDescription { get; public set; }
    public TriggerInfo(TriggerType type, string description);
    public TriggerInfo(TriggerType type, DateTime time, string description);
    public TriggerInfo(TriggerType type, DateTime time, TimeSpan duration, string description);
    private static TriggerInfo();
    [CompilerGeneratedAttribute]
public TriggerType get_TriggerType();
    [CompilerGeneratedAttribute]
public void set_TriggerType(TriggerType value);
    [CompilerGeneratedAttribute]
public DateTime get_TriggerTime();
    [CompilerGeneratedAttribute]
public void set_TriggerTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TriggerDuration();
    [CompilerGeneratedAttribute]
public void set_TriggerDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_TriggerDescription();
    [CompilerGeneratedAttribute]
public void set_TriggerDescription(string value);
    public virtual string ToString();
}
internal enum Microsoft.ApplicationInsights.SnapshotCollector.Interop.TriggerType : Enum {
    public int value__;
    public static TriggerType None;
    public static TriggerType SelfTest;
    public static TriggerType FirstChanceException;
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IPlatformServices {
    public IFirstChanceExceptionSource FirstChanceExceptionSource { get; }
    public ISnapshotCreator SnapshotCreator { get; }
    public IServiceProfilerClient ServiceProfilerClient { get; }
    public ITimeSource TimeSource { get; }
    public IWorkingFolders WorkingFolders { get; }
    public ITelemetryTracker TelemetryTracker { get; }
    public IEnvironmentMemory EnvironmentMemory { get; }
    public IUploader Uploader { get; }
    public ILogger Logger { get; }
    public IAppInsightsProfileFetcher AppInsightsProfileFetcher { get; }
    public IApplicationLifetime ApplicationLifetimeManager { get; }
    public INativeComponentsManager NativeComponentsManager { get; }
    public IAuthTokenProvider AuthTokenProvider { get; }
    public abstract virtual IFirstChanceExceptionSource get_FirstChanceExceptionSource();
    public abstract virtual ISnapshotCreator get_SnapshotCreator();
    public abstract virtual IServiceProfilerClient get_ServiceProfilerClient();
    public abstract virtual ITimeSource get_TimeSource();
    public abstract virtual IWorkingFolders get_WorkingFolders();
    public abstract virtual ITelemetryTracker get_TelemetryTracker();
    public abstract virtual IEnvironmentMemory get_EnvironmentMemory();
    public abstract virtual IUploader get_Uploader();
    public abstract virtual ILogger get_Logger();
    public abstract virtual IAppInsightsProfileFetcher get_AppInsightsProfileFetcher();
    public abstract virtual IApplicationLifetime get_ApplicationLifetimeManager();
    public abstract virtual INativeComponentsManager get_NativeComponentsManager();
    public abstract virtual IAuthTokenProvider get_AuthTokenProvider();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IReflectionHelper {
    public abstract virtual Type GetType(string typeName, string assemblyName);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ISerializable {
    public abstract virtual void WriteTo(BinaryWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ISerializableExtensions : object {
    [ExtensionAttribute]
public static Byte[] SerializeToByteArray(ISerializable serializableObject);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IServiceProfilerClient {
    public bool IsEnabled { get; }
    public string StampId { get; }
    public Guid AppId { get; }
    public ExceptionSnappointSettingsContract ExceptionSnappointSettings { get; }
    public string DisabledReason { get; }
    public bool IsCollectionTemporarilyDisabled { get; }
    public abstract virtual Task ConnectAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual string get_StampId();
    public abstract virtual Guid get_AppId();
    public abstract virtual ExceptionSnappointSettingsContract get_ExceptionSnappointSettings();
    public abstract virtual string get_DisabledReason();
    public abstract virtual bool get_IsCollectionTemporarilyDisabled();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ISessionSource {
    public string SessionId { get; }
    public string RoleName { get; }
    public abstract virtual string get_SessionId();
    public abstract virtual string get_RoleName();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ISnapshotCreator {
    public bool SnapshottingApisArePresent { get; }
    public abstract virtual bool get_SnapshottingApisArePresent();
    public abstract virtual Guid SnapshotExceptionOnCurrentThread(string triggerDescription);
    public abstract virtual Guid CreateSnapshot(TriggerInfo trigger);
    public abstract virtual Guid DeOptimizeMethod(MethodBase methodBase);
    public abstract virtual void ReOptimizeMethod(Guid deOptimizationId);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IStampFrontEnd {
    public abstract virtual Task`1<GetStampIdResponse> GetStampIdAndAppIdAsync(ConnectionString connectionString, string machineName, string featureVersion, string siteExtensionVersion, CancellationToken cancellationToken);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ITelemetryChannelFactory {
    public abstract virtual ITelemetryChannel Create();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ITelemetryConfigurationFactory {
    public abstract virtual TelemetryConfiguration Create();
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ITelemetryTracker {
    public abstract virtual void SetCustomerConnectionString(ConnectionString connectionString);
    public abstract virtual void SetCustomerAppInfo(Guid appId);
    public abstract virtual void SetUnhealthy(string reason);
    public abstract virtual void SetHealthy();
    public abstract virtual void IncrementHeartbeatMetric(HeartbeatMetricIndex index);
    public abstract virtual void InitializeCustomerTelemetry(TelemetryConfiguration configuration);
    public abstract virtual void TrackCustomerException(ExceptionTelemetry exception);
    public abstract virtual void SetRoleName(string roleName);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.ITimeSource {
    public DateTime UtcNow { get; }
    public abstract virtual DateTime get_UtcNow();
    public abstract virtual Task Delay(TimeSpan timeSpan, CancellationToken cancellationToken);
    public abstract virtual IDisposable StartIntervalTimer(TimeSpan dueTime, TimeSpan period, TimerCallback callback, object state);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IUploader {
    public abstract virtual Task StartAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    public abstract virtual void EnqueueRequest(SnapshotRequest request);
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.IWorkingFolders {
    public string DumpsFolder { get; }
    public string ShadowCopyFolder { get; }
    public abstract virtual string get_DumpsFolder();
    public abstract virtual bool TrySetDumpsFolder(string value);
    public abstract virtual string get_ShadowCopyFolder();
    public abstract virtual bool TrySetShadowCopyFolder(string value);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Logging.AppInsightsLogger : object {
    private TelemetryClient _telemetryClient;
    private TelemetryConfiguration _telemetryConfiguration;
    private ConnectionString _connectionString;
    public ConnectionString ConnectionString { get; public set; }
    private bool IsEnabled { get; }
    public AppInsightsLogger(TelemetryConfiguration telemetryConfiguration, ConnectionString connectionString);
    public sealed virtual ConnectionString get_ConnectionString();
    public sealed virtual void set_ConnectionString(ConnectionString value);
    public sealed virtual void SetCommonProperty(string key, string value);
    public sealed virtual void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics, string operationId, string roleName, bool preventSampling);
    public sealed virtual void TrackException(Exception exception, string operationName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public sealed virtual void TrackTrace(string message, SeverityLevel severityLevel, IDictionary`2<string, string> properties, bool preventSampling);
    private bool get_IsEnabled();
    private static void MergeDictionaries(IDictionary`2<K, V> target, IDictionary`2<K, V> dictionaryToMerge);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Logging.Constants : object {
    public static string AuthenticatedUserId;
    public static string ComponentVersion;
    public static string SdkVersion;
    public static string SessionId;
    public static string CloudRoleInstance;
    public static string CloudRoleName;
    public static string OS;
    public static string Runtime;
    public static string ProcessWorkingSetInMB;
    public static string ProcessPagedMemoryInMB;
    public static string StartTimeUTC;
    public static string Heartbeat;
    public static string DurationInSeconds;
    public static string RunningMode;
    public static string EventName;
    public static string ProcessId;
    public static string EnablingExtensionVersion;
    public static string FeatureVersion;
    public static string FunctionHostVersion;
    public static string InContainer;
    public static string CollectorSession;
    public static string SingleFileApp;
}
internal interface Microsoft.ApplicationInsights.SnapshotCollector.Logging.IAppInsightsLogger {
    public ConnectionString ConnectionString { get; public set; }
    public abstract virtual ConnectionString get_ConnectionString();
    public abstract virtual void set_ConnectionString(ConnectionString value);
    public abstract virtual void SetCommonProperty(string key, string value);
    public abstract virtual void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics, string operationId, string roleName, bool preventSampling);
    public abstract virtual void TrackException(Exception exception, string operationName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public abstract virtual void TrackTrace(string message, SeverityLevel severityLevel, IDictionary`2<string, string> properties, bool preventSampling);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Logging.ISupportSamplingExtensions : object {
    private static Nullable`1<double> s_noSampling;
    private static ISupportSamplingExtensions();
    [ExtensionAttribute]
public static void PreventSampling(ISupportSampling supportSampling);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.MemoryThrottler : object {
    private IEnvironmentMemory _environmentMemory;
    private ITimeSource _timeSource;
    private DateTimeOffset _lastHighMemory;
    internal TimeSpan _highMemoryWaitInterval;
    internal static TimeSpan s_minInterval;
    internal static TimeSpan s_maxInterval;
    public MemoryThrottler(ITimeSource timeSource, IEnvironmentMemory environmentMemory);
    private static MemoryThrottler();
    public bool IsMemorySafeForSnapshot(String& memoryUsageIssue);
    public bool IsInHighMemoryWaitPeriod();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.NativeComponentsManager : object {
    private FileStream _fileHandle;
    private object _lock;
    private static string NativeComponentName;
    private static String[] s_embeddedNativeComponentsResourceNames;
    private ILogger _logger;
    private SnapshotCollectorConfiguration _configuration;
    private string _nativeFolderName;
    public static string CLRProfilerFileName { get; }
    public NativeComponentsManager(SnapshotCollectorConfiguration configuration, ILogger logger);
    internal NativeComponentsManager(SnapshotCollectorConfiguration configuration, ILogger logger, string nativeFolderName);
    private static NativeComponentsManager();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.NativeComponentsManager/<ExtractNativeComponentsAsync>d__2")]
public sealed virtual Task ExtractNativeComponentsAsync(string destinationFolder, CancellationToken cancellationToken);
    public sealed virtual bool AttachCLRProfilerIfNecessary();
    public sealed virtual void Dispose();
    public static string get_CLRProfilerFileName();
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.NativeMethods : object {
    public static string Kernel32;
    public static int HKEY_LOCAL_MACHINE;
    public static UInt32 RRF_RT_DWORD;
    public static UInt32 REG_DWORD;
    public static IntPtr GetModuleHandleW(string lpModuleName);
    public static IntPtr GetProcAddress(IntPtr hModule, string proc);
    public static int RegGetValueW(IntPtr hKey, string subKey, string value, UInt32 flags, UInt32& type, UInt32& data, UInt32& pcbData);
    public static IntPtr LoadLibraryW(string lpFileName);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.NoOpNativeComponentsManager : object {
    public sealed virtual bool AttachCLRProfilerIfNecessary();
    public sealed virtual void Dispose();
    public sealed virtual Task ExtractNativeComponentsAsync(string destinationFolder, CancellationToken cancellationToken);
}
internal abstract class Microsoft.ApplicationInsights.SnapshotCollector.Pipeline.Consumer`1 : object {
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual Task ConsumeAsync(T item, CancellationToken cancellationToken);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Pipeline.Pipe : object {
    public static string GetSnapshotUploaderPipeName(string applicationName, string discriminator);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Pipeline.ProducerConsumerQueue`1 : object {
    private SemaphoreSlim _workAvailable;
    private ConcurrentQueue`1<T> _workQueue;
    private Task _workerTask;
    private CancellationTokenSource _cancellationTokenSource;
    private Func`1<Consumer`1<T>> _consumerFactory;
    private Consumer`1<T> _consumer;
    private bool _draining;
    public ProducerConsumerQueue`1(Consumer`1<T> consumer);
    public ProducerConsumerQueue`1(Func`1<Consumer`1<T>> consumerFactory);
    public sealed virtual void Dispose();
    public void Produce(T workItem);
    public void DrainQueue();
    public Task DrainQueueAsync();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.Pipeline.ProducerConsumerQueue`1/<DoWork>d__13")]
private Task DoWork();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.PlatformServices : object {
    [CompilerGeneratedAttribute]
private IFirstChanceExceptionSource <FirstChanceExceptionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private ISnapshotCreator <SnapshotCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProfilerClient <ServiceProfilerClient>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeSource <TimeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IWorkingFolders <WorkingFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnvironmentMemory <EnvironmentMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private IApplicationLifetime <ApplicationLifetimeManager>k__BackingField;
    [CompilerGeneratedAttribute]
private INativeComponentsManager <NativeComponentsManager>k__BackingField;
    private SnapshotCollectorConfiguration _configuration;
    private Uploader _uploader;
    private TelemetryTracker _telemetryTracker;
    private AppInsightsProfileFetcher _appInsightsProfileFetcher;
    public IFirstChanceExceptionSource FirstChanceExceptionSource { get; }
    public ISnapshotCreator SnapshotCreator { get; }
    public IServiceProfilerClient ServiceProfilerClient { get; }
    public ITimeSource TimeSource { get; }
    public IWorkingFolders WorkingFolders { get; }
    public ITelemetryTracker TelemetryTracker { get; }
    public IEnvironmentMemory EnvironmentMemory { get; }
    public IUploader Uploader { get; }
    public ILogger Logger { get; }
    public IAppInsightsProfileFetcher AppInsightsProfileFetcher { get; }
    public IApplicationLifetime ApplicationLifetimeManager { get; }
    public INativeComponentsManager NativeComponentsManager { get; private set; }
    public IAuthTokenProvider AuthTokenProvider { get; }
    public PlatformServices(SnapshotCollectorConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual IFirstChanceExceptionSource get_FirstChanceExceptionSource();
    [CompilerGeneratedAttribute]
public sealed virtual ISnapshotCreator get_SnapshotCreator();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProfilerClient get_ServiceProfilerClient();
    [CompilerGeneratedAttribute]
public sealed virtual ITimeSource get_TimeSource();
    [CompilerGeneratedAttribute]
public sealed virtual IWorkingFolders get_WorkingFolders();
    public sealed virtual ITelemetryTracker get_TelemetryTracker();
    [CompilerGeneratedAttribute]
public sealed virtual IEnvironmentMemory get_EnvironmentMemory();
    public sealed virtual IUploader get_Uploader();
    public sealed virtual ILogger get_Logger();
    public sealed virtual IAppInsightsProfileFetcher get_AppInsightsProfileFetcher();
    [CompilerGeneratedAttribute]
public sealed virtual IApplicationLifetime get_ApplicationLifetimeManager();
    [CompilerGeneratedAttribute]
public sealed virtual INativeComponentsManager get_NativeComponentsManager();
    [CompilerGeneratedAttribute]
private void set_NativeComponentsManager(INativeComponentsManager value);
    public sealed virtual IAuthTokenProvider get_AuthTokenProvider();
    public sealed virtual void Dispose();
    private static RuntimeEnvironment DetectRuntimeEnvironment();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProblemCounter : object {
    private ConcurrentDictionary`2<ProblemId, int> _problemIdCounts;
    private SnapshotCollectorConfiguration _configuration;
    private ITimeSource _timeSource;
    private ILogger _logger;
    private IDisposable _resetTimer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProblemId> SnapshotRequested;
    public int Count { get; }
    public ProblemCounter(SnapshotCollectorConfiguration configuration, ITimeSource timeSource, ILogger logger);
    public int get_Count();
    [CompilerGeneratedAttribute]
public void add_SnapshotRequested(EventHandler`1<ProblemId> value);
    [CompilerGeneratedAttribute]
public void remove_SnapshotRequested(EventHandler`1<ProblemId> value);
    public sealed virtual void Dispose();
    private static int IncrementProblemCount(ProblemId _, int count);
    public void RecordException(Exception exception);
    public virtual string ToString();
    private static void ResetProblemCounts(object state);
    private void ResetProblemCounts();
    private IDisposable CreateTimer();
    private void OnConfigurationPropertyChanged(object sender, PropertyChangedEventArgs e);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProblemId : object {
    public Type ExceptionType;
    private int _ilOffset;
    [CompilerGeneratedAttribute]
private MethodBase <ThrowingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<MethodBase> <MethodsRequiringDeoptimization>k__BackingField;
    private static string ProblemIdFormatString;
    private static string ProblemIdFormatRegexExpression;
    private static ISet`1<string> s_frameworkModuleNames;
    private static IReadOnlyCollection`1<MethodBase> s_emptyMethodCollection;
    public string ThrowingMethodName { get; }
    public string ThrowingModuleName { get; }
    public string ThrowingMethodDeclaringTypeName { get; }
    public MethodBase ThrowingMethod { get; }
    public IReadOnlyCollection`1<MethodBase> MethodsRequiringDeoptimization { get; }
    public ProblemId(Exception ex, int deoptimizeMethodCount, ISet`1<string> uninterestingModules);
    private static ProblemId();
    public static ProblemId FromExceptionWithoutDeoptimization(Exception ex);
    public string get_ThrowingMethodName();
    public string get_ThrowingModuleName();
    public string get_ThrowingMethodDeclaringTypeName();
    [CompilerGeneratedAttribute]
public MethodBase get_ThrowingMethod();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProblemId other);
    public sealed virtual bool Equals(ProblemIdInfo other);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<MethodBase> get_MethodsRequiringDeoptimization();
    public static ProblemIdInfo GetProblemIdInfo(string problemId);
    public static bool op_Equality(ProblemId lhs, ProblemId rhs);
    public static bool op_Inequality(ProblemId lhs, ProblemId rhs);
    private static bool ILOffsetsAreEquivalent(int lhs, int rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static IReadOnlyCollection`1<MethodBase> ComputeListOfInterestingMethods(StackFrame[] stackFrames, int frameCount, ISet`1<string> uninterestingModules);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.NativeMethods : object {
    private static string Kernel32;
    public static UInt32 ERROR_SUCCESS;
    public static int S_OK;
    public static int S_FALSE;
    public static UInt32 SYNCHRONIZE;
    public static UInt32 PROCESS_TERMINATE;
    public static UInt32 PROCESS_DUP_HANDLE;
    public static UInt32 PROCESS_VM_READ;
    public static UInt32 EXCEPTION_BREAKPOINT;
    public static void ThrowIfFailed(int status, string operation);
    public static UInt32 GetCurrentThreadId();
    public static UInt32 GetProcessId(IntPtr hProcess);
    public static SafeProcessHandle GetCurrentProcess();
    public static SafeProcessHandle OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);
    public static bool TerminateProcess(SafeHandle hProcess, UInt32 uExitCode);
    public static int PssCaptureSnapshot(SafeHandle processHandle, PSS_CAPTURE_FLAGS captureFlags, UInt32 threadContextFlags, IntPtr& snapshotHandle);
    public static int PssFreeSnapshot(SafeHandle processHandle, IntPtr snapshotHandle);
    public static int PssQuerySnapshot(IntPtr snapshotHandle, PSS_QUERY_INFORMATION_CLASS informationClass, Void* buffer, int bufferLength);
    public static int PssDuplicateSnapshot(SafeHandle SourceProcessHandle, IntPtr SnapshotHandle, SafeHandle TargetProcessHandle, IntPtr& TargetSnapshotHandle, PSS_DUPLICATE_FLAGS Flags);
    public static int PssWalkMarkerCreate(IntPtr allocator, IntPtr& WalkMarkerHandle);
    public static int PssWalkMarkerFree(IntPtr WalkMarkerHandle);
    public static int PssWalkSnapshot(IntPtr snapshotHandle, PSS_WALK_INFORMATION_CLASS informationClass, IntPtr WalkMarkerHandle, Void* buffer, int bufferLength);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.NativeProcess : object {
    public static void TerminateProcess(UInt32 processId);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.ProductionBreakpointsNativeException : Win32Exception {
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    public string Operation { get; }
    public string Message { get; }
    public ProductionBreakpointsNativeException(string operation);
    public ProductionBreakpointsNativeException(int errorCode, string operation);
    [CompilerGeneratedAttribute]
public string get_Operation();
    public virtual string get_Message();
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.PssSnapshot : object {
    private static UInt32 CONTEXT_AMD64;
    private static UInt32 CONTEXT_CONTROL;
    private static UInt32 CONTEXT_INTEGER;
    private static UInt32 CONTEXT_SEGMENTS;
    private static UInt32 CONTEXT_FLOATING_POINT;
    private static UInt32 CONTEXT_DEBUG_REGISTERS;
    private static UInt32 CONTEXT_ALL;
    internal static Action`1<PssSnapshotInformation> s_onClose;
    private static PssSnapshot();
    public static PssSnapshotInformation CaptureSnapshot();
    public static bool IsPssCaptureSnapshotApiPresent();
    private static UInt32 GetProcessIdFromPssSnapshot(IntPtr pssSnapshotHandle);
    public static void Close(PssSnapshotInformation snapshotInformation);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.PssSnapshotInformation : ValueType {
    public IntPtr SnapshotHandle;
    public PssSnapshotInformation(IntPtr snapshot);
    public void Serialize(BinaryWriter writer);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.RequestHandler : Consumer`1<Request> {
    private SnapshotUploaderClient _snapshotUploaderClient;
    private ILogger _logger;
    public RequestHandler(SnapshotUploaderClient upholderClient, ILogger logger);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.RequestHandler/<ConsumeAsync>d__5")]
public virtual Task ConsumeAsync(Request request, CancellationToken cancellationToken);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.SelfTest : object {
    public static IDisposable SnapshotExceptionOnCurrentThread(DumpRequestType dumpType);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.SnapshotUploaderClient : object {
    private string _pipeName;
    private int _connectTimeoutInMilliseconds;
    private NamedPipeClientStream _pipe;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private EventHandler`1<UploaderConnectTimeoutEventArgs> OnConnectionTimedOut;
    public SnapshotUploaderClient(string pipeName, TimeSpan connectTimeout, ILogger logger);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public void add_OnConnectionTimedOut(EventHandler`1<UploaderConnectTimeoutEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnConnectionTimedOut(EventHandler`1<UploaderConnectTimeoutEventArgs> value);
    private bool ShouldRetryConnection(int retryCount);
    public Task SendMessageAsync(Byte[] buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.SnapshotUploaderClient/<SendMessageAsync>d__11")]
public Task SendMessageAsync(Byte[] buffer, int offset, int length, CancellationToken cancellationToken);
    private static bool IsBrokenPipe(IOException ioex);
    private static bool IsConnectTimeout(IOException ioex);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.SnapshotUploaderClient/<ConnectToServerAsync>d__14")]
private Task ConnectToServerAsync(CancellationToken cancellationToken);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpoints.UploaderConnectTimeoutEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldRetry>k__BackingField;
    public int RetryCount { get; }
    public bool ShouldRetry { get; public set; }
    public UploaderConnectTimeoutEventArgs(int retryCount);
    [CompilerGeneratedAttribute]
public int get_RetryCount();
    [CompilerGeneratedAttribute]
public bool get_ShouldRetry();
    [CompilerGeneratedAttribute]
public void set_ShouldRetry(bool value);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ProductionBreakpointsNativeMethods : object {
    private static string RequestMethodDeOptimizationProc;
    private static string RequestMethodReOptimizationProc;
    private static RequestMethodDeOptimizationDelegate s_requestMethodDeOptimization;
    private static RequestMethodReOptimizationDelegate s_requestMethodReOptimization;
    public static bool IsDeOptimizationAvailable { get; }
    private static ProductionBreakpointsNativeMethods();
    internal static void InitializeProductionBreakpointsNativeMethods();
    public static bool get_IsDeOptimizationAvailable();
    public static Guid DeOptimizeMethod(MethodBase method);
    public static void ReOptimizeMethod(Guid deOptimizationId);
    private static T ImportProc(IntPtr hModule, string proc);
    private static void ImportProc(T& field, IntPtr hModule, string proc);
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.QuotaInformation : ValueType {
    [CompilerGeneratedAttribute]
private int <remainingOperationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <cacheHintSeconds>k__BackingField;
    [DataMemberAttribute]
public int remainingOperationCount { get; public set; }
    [DataMemberAttribute]
public int cacheHintSeconds { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_remainingOperationCount();
    [CompilerGeneratedAttribute]
public void set_remainingOperationCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_cacheHintSeconds();
    [CompilerGeneratedAttribute]
public void set_cacheHintSeconds(int value);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.RateLimiter : object {
    private ITimeSource _timeSource;
    private int _operationCount;
    private int _operationLimit;
    [CompilerGeneratedAttribute]
private DateTime <LastResetTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Interval>k__BackingField;
    public int OperationLimit { get; public set; }
    public int RemainingOperationCount { get; }
    public DateTime LastResetTime { get; private set; }
    public TimeSpan Interval { get; }
    public RateLimiter(ITimeSource timeSource, TimeSpan interval, int operationLimit);
    public int get_OperationLimit();
    public void set_OperationLimit(int value);
    public int get_RemainingOperationCount();
    [CompilerGeneratedAttribute]
public DateTime get_LastResetTime();
    [CompilerGeneratedAttribute]
private void set_LastResetTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Interval();
    public bool CheckOperation();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.RedirectHttpHandler : HttpClientHandler {
    private static int MaxRedirect;
    public void TryEnableTLS12Protocol();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.RedirectHttpHandler/<SendAsync>d__3")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool TryGetRedirectLocation(HttpResponseMessage response, Uri& location);
    private static bool IsRedirection(HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.RefCounted`1 : ValueType {
    public T Value;
    public int RefCount;
    public RefCounted`1(T value);
    private RefCounted`1(T value, int refCount);
    public RefCounted`1<T> AddRef();
    public RefCounted`1<T> Release();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ReflectionHelper : object {
    public sealed virtual Type GetType(string typeName, string assemblyName);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ReJIT.CLRProfiler : object {
    private static int s_attachWasCalled;
    public static string ProductionBreakpointsFileName { get; }
    public static bool AttachCLRProfilerIfNecessary(SnapshotCollectorConfiguration configuration, ILogger logger);
    public static IntPtr GetHModule();
    private static bool Attach(SnapshotCollectorConfiguration configuration, ILogger logger);
    public static string get_ProductionBreakpointsFileName();
}
internal enum Microsoft.ApplicationInsights.SnapshotCollector.RuntimeEnvironment : Enum {
    public int value__;
    public static RuntimeEnvironment Unknown;
    public static RuntimeEnvironment AzureCompute;
    public static RuntimeEnvironment Antares;
    public static RuntimeEnvironment ServiceFabric;
    public static RuntimeEnvironment CloudService;
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SecurityProtocolMissingException : Exception {
    public SecurityProtocolMissingException(string message);
    public SecurityProtocolMissingException(string message, Exception innerException);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SemaphoreReleaser : ValueType {
    private SemaphoreSlim _semaphore;
    private SemaphoreReleaser(SemaphoreSlim semaphore);
    public sealed virtual void Dispose();
    public static SemaphoreReleaser Wait(SemaphoreSlim semaphore);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.SemaphoreReleaser/<WaitAsync>d__4")]
public static Task`1<SemaphoreReleaser> WaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Serialization.JsonSerializer : object {
    private static string DateTimeFormatString;
    private static DataContractJsonSerializerSettings s_settings;
    private static JsonSerializer();
    public static DataContractJsonSerializer CreateSerializer();
    public static string ToJson(T value);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.Serialization.JsonSerializer`1 : object {
    private static DataContractJsonSerializer s_serializer;
    private static JsonSerializer`1();
    public static string ToJson(T value);
    public static void ToJson(Stream stream, T value);
    public static T FromJson(string json);
    public static T FromJson(Stream stream);
    public static T LoadFromFile(string fileName);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ServerTelemetryChannelFactory : TelemetryChannelFactory {
    private IReflectionHelper _reflectionHelper;
    internal ServerTelemetryChannelFactory(IReflectionHelper reflectionHelper);
    protected virtual ITelemetryChannel CreateCore();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.ServiceProfilerClient : object {
    [CompilerGeneratedAttribute]
private ExceptionSnappointSettingsContract <ExceptionSnappointSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisabledReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LocalExceptionSnappointSettingsLoaded>k__BackingField;
    private SnapshotCollectorConfiguration _configuration;
    private IStampFrontEnd _stampFrontEnd;
    private ITimeSource _timeSource;
    private Nullable`1<bool> _isEnabled;
    private string _stampId;
    private Guid _appId;
    private DateTime _disableCollectionUntil;
    private ILogger _logger;
    private bool _localSnappointConfigFileLoadingTried;
    public bool IsEnabled { get; }
    public string StampId { get; }
    public ExceptionSnappointSettingsContract ExceptionSnappointSettings { get; private set; }
    public Guid AppId { get; }
    public string DisabledReason { get; private set; }
    public bool IsCollectionTemporarilyDisabled { get; }
    internal bool LocalExceptionSnappointSettingsLoaded { get; private set; }
    public ServiceProfilerClient(SnapshotCollectorConfiguration configuration, IAuthTokenProvider authTokenProvider, ILogger logger);
    internal ServiceProfilerClient(SnapshotCollectorConfiguration configuration, ILogger logger, IStampFrontEnd stampFrontEnd, ITimeSource timeSource);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ServiceProfilerClient/<ConnectAsync>d__2")]
public sealed virtual Task ConnectAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    public sealed virtual bool get_IsEnabled();
    public sealed virtual string get_StampId();
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionSnappointSettingsContract get_ExceptionSnappointSettings();
    [CompilerGeneratedAttribute]
private void set_ExceptionSnappointSettings(ExceptionSnappointSettingsContract value);
    public sealed virtual Guid get_AppId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisabledReason();
    [CompilerGeneratedAttribute]
private void set_DisabledReason(string value);
    public sealed virtual bool get_IsCollectionTemporarilyDisabled();
    [CompilerGeneratedAttribute]
internal bool get_LocalExceptionSnappointSettingsLoaded();
    [CompilerGeneratedAttribute]
private void set_LocalExceptionSnappointSettingsLoaded(bool value);
    private void TryLoadLocalExceptionSnappointSettings();
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ShadowCopy : object {
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.ShadowCopy/<ExtractResourcesAsync>d__0")]
public static Task ExtractResourcesAsync(Assembly assembly, IEnumerable`1<string> resourceNames, string destinationFolder, CancellationToken cancellationToken);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.ShadowCopyUtilities : object {
    public static string DetermineShadowCopyFolder(string appName, string version);
    public static string GetShadowCopyEnvironmentVariableName(string appName);
    public static bool TryEnsureFolderIsSuitableForShadowCopy(string folder);
    private static bool UserHasNeededFileSystemRights(WindowsIdentity userIdentity, FileSystemSecurity accessControlList, FileSystemRights rightsNeeded);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.SingletonProcess : object {
    public static string CompatibilityVersion;
    public static string GetEncodedDiscriminatorName(string discriminator);
    private static string GetMutexName(string applicationName, string discriminator);
    public static bool TryAcquireSingleton(string applicationName, string discriminator, Mutex& mutex);
    public static bool IsAnotherInstanceRunning(string applicationName, string discriminator);
}
internal static class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotAppInsightsDataContract : object {
    public static string ExceptionTelemetry_PropertyName_SnapshotId;
    public static string ExceptionTelemetry_PropertyName_SnapshotVersion;
    public static string ExceptionTelemetry_PropertyName_StampId;
    public static string SnapshotUploadFinishIndexEvent_PropertyName_SnapshotId;
    public static string SnapshotUploadFinishIndexEvent_PropertyName_SnapshotVersion;
    public static string SnapshotUploadFinishIndexEvent_PropertyName_StampId;
    public static string SnapshotVersionV2;
    public static string NormalizeSnapshotId(Guid snapshotId);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollector : object {
    private IPlatformServices _platformServices;
    private SnapshotCollectorConfiguration _configuration;
    private ConcurrentDictionary`2<ProblemId, CollectionPlan> _collectionPlans;
    private RateLimiter _rateLimiter;
    private RateLimiter _dailyRateLimiter;
    private MemoryThrottler _memoryThrottler;
    private DeOptimizationRequests _deOptimizationRequests;
    [CompilerGeneratedAttribute]
private EventHandler`1<SnapshotContext> SnapshotCreated;
    private string StampId { get; }
    private ExceptionSnappointSettingsContract ExceptionSnappointSettings { get; }
    private ILogger Logger { get; }
    public SnapshotCollector(IPlatformServices platformServices, SnapshotCollectorConfiguration configuration);
    [CompilerGeneratedAttribute]
internal void add_SnapshotCreated(EventHandler`1<SnapshotContext> value);
    [CompilerGeneratedAttribute]
internal void remove_SnapshotCreated(EventHandler`1<SnapshotContext> value);
    private string get_StampId();
    private ExceptionSnappointSettingsContract get_ExceptionSnappointSettings();
    private ILogger get_Logger();
    public void RequestSnapshots(ProblemId problemId, int numberOfExamplesDesired);
    private CollectionPlan RequestSnapshots(ProblemId problemId, int numberOfExamplesDesired, bool isTracked);
    private bool EnsureRoomForOneRequest();
    private int ScavengeCompletePlans();
    internal void OnFirstChanceException(object sender, Exception exception);
    private void ProcessExceptionSnapshot(Exception exception, CollectionPlan collectionPlan);
    private void CollectExceptionSnapshot(Exception exception, CollectionPlan collectionPlan);
    private void DeOptimize(ProblemId problem);
    private CollectionPlan AddOrUpdatePlan(ProblemId problem, int numberOfSnapshotsDesired, bool isTracked);
    private bool TryRemovePlan(ProblemId problem);
    private SnapshotContext CreateSnapshot(CollectionPlan collectionPlan);
    private void OnConfigurationPropertyChanged(object sender, PropertyChangedEventArgs e);
    public sealed virtual void Dispose();
    public void Clear();
}
[DataContractAttribute]
public class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorConfiguration : object {
    private bool _isEnabled;
    private bool _isEnabledInDeveloperMode;
    private int _thresholdForSnapshotting;
    private int _maximumExamplesRequired;
    private int _maximumCollectionPlanSize;
    private string _agentEndpoint;
    private TimeSpan _reconnectInterval;
    private TimeSpan _problemCounterResetInterval;
    private int _snapshotsPerTenMinutesLimit;
    private int _snapshotsPerDayLimit;
    private bool _snapshotInLowPriorityThread;
    private string _tempFolder;
    private string _shadowCopyFolder;
    private bool _provideAnonymousTelemetry;
    private int _failedRequestLimit;
    private bool _isEnabledWhenProfiling;
    private bool _isLowPrioritySnapshotUploader;
    private string _uploaderProxy;
    private double _captureSnapshotMemoryWeight;
    private bool _shareUploaderProcess;
    private bool _isExceptionSnappointsEnabled;
    private string _exceptionSnappointSettingsFile;
    private int _deoptimizeMethodCount;
    private ISet`1<string> _deoptimizeIgnoredModulesSet;
    private int _logRotationDays;
    private bool _enableReJit;
    private TimeSpan _pdbRescanInterval;
    private string _authenticationString;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <HasBeenModified>k__BackingField;
    [DataMemberAttribute]
public bool IsEnabled { get; public set; }
    [DataMemberAttribute]
public bool IsEnabledInDeveloperMode { get; public set; }
    [DataMemberAttribute]
public int ThresholdForSnapshotting { get; public set; }
    [DataMemberAttribute]
public int MaximumSnapshotsRequired { get; public set; }
    [DataMemberAttribute]
public int MaximumCollectionPlanSize { get; public set; }
    [DataMemberAttribute]
public string AgentEndpoint { get; public set; }
    [DataMemberAttribute]
public TimeSpan ReconnectInterval { get; public set; }
    [DataMemberAttribute]
public TimeSpan ProblemCounterResetInterval { get; public set; }
    [DataMemberAttribute]
public int SnapshotsPerTenMinutesLimit { get; public set; }
    [DataMemberAttribute]
public int SnapshotsPerDayLimit { get; public set; }
    [DataMemberAttribute]
public bool SnapshotInLowPriorityThread { get; public set; }
    [DataMemberAttribute]
public string ShadowCopyFolder { get; public set; }
    [DataMemberAttribute]
public string TempFolder { get; public set; }
    [DataMemberAttribute]
public bool ProvideAnonymousTelemetry { get; public set; }
    [DataMemberAttribute]
public int FailedRequestLimit { get; public set; }
    [DataMemberAttribute]
public bool IsEnabledWhenProfiling { get; public set; }
    [DataMemberAttribute]
public bool IsLowPrioritySnapshotUploader { get; public set; }
    [DataMemberAttribute]
public string UploaderProxy { get; public set; }
    [DataMemberAttribute]
public double CaptureSnapshotMemoryWeight { get; public set; }
    [DataMemberAttribute]
public bool ShareUploaderProcess { get; public set; }
    [DataMemberAttribute]
public string ExceptionSnappointSettingsFile { get; public set; }
    [ObsoleteAttribute("This property is always true and should not be used.")]
public bool HandleUntrackedExceptions { get; public set; }
    [DataMemberAttribute]
public bool IsExceptionSnappointsEnabled { get; public set; }
    [DataMemberAttribute]
public int DeoptimizeMethodCount { get; public set; }
    [DataMemberAttribute]
public string DeoptimizeIgnoredModules { get; public set; }
    [IgnoreDataMemberAttribute]
internal ISet`1<string> DeoptimizeIgnoredModulesSet { get; private set; }
    [DataMemberAttribute]
public int LogRotationInDays { get; public set; }
    [DataMemberAttribute]
public bool IsInProcReJitEnabled { get; public set; }
    [DataMemberAttribute]
public TimeSpan PdbRescanInterval { get; public set; }
    [IgnoreDataMemberAttribute]
public string AuthenticationString { get; public set; }
    private bool HasBeenModified { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsEnabledInDeveloperMode();
    public void set_IsEnabledInDeveloperMode(bool value);
    public int get_ThresholdForSnapshotting();
    public void set_ThresholdForSnapshotting(int value);
    public int get_MaximumSnapshotsRequired();
    public void set_MaximumSnapshotsRequired(int value);
    public int get_MaximumCollectionPlanSize();
    public void set_MaximumCollectionPlanSize(int value);
    public string get_AgentEndpoint();
    public void set_AgentEndpoint(string value);
    public TimeSpan get_ReconnectInterval();
    public void set_ReconnectInterval(TimeSpan value);
    public TimeSpan get_ProblemCounterResetInterval();
    public void set_ProblemCounterResetInterval(TimeSpan value);
    public int get_SnapshotsPerTenMinutesLimit();
    public void set_SnapshotsPerTenMinutesLimit(int value);
    public int get_SnapshotsPerDayLimit();
    public void set_SnapshotsPerDayLimit(int value);
    public bool get_SnapshotInLowPriorityThread();
    public void set_SnapshotInLowPriorityThread(bool value);
    public string get_ShadowCopyFolder();
    public void set_ShadowCopyFolder(string value);
    public string get_TempFolder();
    public void set_TempFolder(string value);
    public bool get_ProvideAnonymousTelemetry();
    public void set_ProvideAnonymousTelemetry(bool value);
    public int get_FailedRequestLimit();
    public void set_FailedRequestLimit(int value);
    public bool get_IsEnabledWhenProfiling();
    public void set_IsEnabledWhenProfiling(bool value);
    public bool get_IsLowPrioritySnapshotUploader();
    public void set_IsLowPrioritySnapshotUploader(bool value);
    public string get_UploaderProxy();
    public void set_UploaderProxy(string value);
    public double get_CaptureSnapshotMemoryWeight();
    public void set_CaptureSnapshotMemoryWeight(double value);
    public bool get_ShareUploaderProcess();
    public void set_ShareUploaderProcess(bool value);
    public string get_ExceptionSnappointSettingsFile();
    public void set_ExceptionSnappointSettingsFile(string value);
    public bool get_HandleUntrackedExceptions();
    public void set_HandleUntrackedExceptions(bool value);
    public bool get_IsExceptionSnappointsEnabled();
    public void set_IsExceptionSnappointsEnabled(bool value);
    public int get_DeoptimizeMethodCount();
    public void set_DeoptimizeMethodCount(int value);
    public string get_DeoptimizeIgnoredModules();
    public void set_DeoptimizeIgnoredModules(string value);
    internal ISet`1<string> get_DeoptimizeIgnoredModulesSet();
    private void set_DeoptimizeIgnoredModulesSet(ISet`1<string> value);
    public int get_LogRotationInDays();
    public void set_LogRotationInDays(int value);
    public bool get_IsInProcReJitEnabled();
    public void set_IsInProcReJitEnabled(bool value);
    public TimeSpan get_PdbRescanInterval();
    public void set_PdbRescanInterval(TimeSpan value);
    public string get_AuthenticationString();
    public void set_AuthenticationString(string value);
    public virtual string ToString();
    private void UpdateProperty(T& field, T newValue, string propertyName);
    private void NotifyPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private bool get_HasBeenModified();
    [CompilerGeneratedAttribute]
private void set_HasBeenModified(bool value);
}
public static class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorDiagnosticSource : object {
    public static string ListenerName;
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorTelemetryInitializer : object {
    public sealed virtual void Initialize(ITelemetry telemetry);
}
public class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorTelemetryProcessor : object {
    private static String[] s_firstChanceExceptionStatisticsMarkerPropertyNames;
    private ITelemetryProcessor _nextTelemetryProcessor;
    private IPlatformServices _platformServices;
    internal ProblemCounter _problemCounter;
    private Lazy`1<SnapshotCollector> _snapshotCollector;
    private SnapshotCollectorConfiguration _configuration;
    private TelemetryConfiguration _telemetryConfiguration;
    private int _failedSnapshotRequests;
    private bool _unexpandedEnvironmentVariablesReported;
    private bool _isRoleNameSet;
    internal CancellationTokenSource _connectTaskCancellationToken;
    internal Task`1<bool> _connectTask;
    internal bool _isPlatformSupported;
    private int _failedConnects;
    private CancellationTokenSource _initializedCancellationTokenSource;
    public CancellationToken Initialized { get; }
    public bool IsEnabled { get; public set; }
    public bool IsEnabledInDeveloperMode { get; public set; }
    public int ThresholdForSnapshotting { get; public set; }
    public int MaximumSnapshotsRequired { get; public set; }
    public int MaximumCollectionPlanSize { get; public set; }
    public string AgentEndpoint { get; public set; }
    public TimeSpan ReconnectInterval { get; public set; }
    public TimeSpan ProblemCounterResetInterval { get; public set; }
    public int SnapshotsPerTenMinutesLimit { get; public set; }
    public int SnapshotsPerDayLimit { get; public set; }
    public bool SnapshotInLowPriorityThread { get; public set; }
    public int DeoptimizeMethodCount { get; public set; }
    public string DeoptimizeIgnoredModules { get; public set; }
    public int LogRotationInDays { get; public set; }
    public string ShadowCopyFolder { get; public set; }
    public bool IsExceptionSnappointsEnabled { get; public set; }
    public string ExceptionSnappointSettingsFile { get; public set; }
    public string TempFolder { get; public set; }
    public bool ProvideAnonymousTelemetry { get; public set; }
    public int FailedRequestLimit { get; public set; }
    public bool IsEnabledWhenProfiling { get; public set; }
    public bool IsLowPrioritySnapshotUploader { get; public set; }
    public string UploaderProxy { get; public set; }
    public double CaptureSnapshotMemoryWeight { get; public set; }
    public bool ShareUploaderProcess { get; public set; }
    public bool IsInProcReJitEnabled { get; public set; }
    public TimeSpan PdbRescanInterval { get; public set; }
    public string AuthenticationString { get; public set; }
    private ILogger Logger { get; }
    private bool IsInDeveloperMode { get; }
    [ActivatorUtilitiesConstructorAttribute]
public SnapshotCollectorTelemetryProcessor(ITelemetryProcessor nextTelemetryProcessor, IOptions`1<SnapshotCollectorConfiguration> options);
    public SnapshotCollectorTelemetryProcessor(ITelemetryProcessor nextTelemetryProcessor);
    public SnapshotCollectorTelemetryProcessor(ITelemetryProcessor nextTelemetryProcessor, SnapshotCollectorConfiguration configuration);
    internal SnapshotCollectorTelemetryProcessor(ITelemetryProcessor nextTelemetryProcessor, IPlatformServices platformServices, SnapshotCollectorConfiguration configuration);
    private static SnapshotCollectorTelemetryProcessor();
    public CancellationToken get_Initialized();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsEnabledInDeveloperMode();
    public void set_IsEnabledInDeveloperMode(bool value);
    public int get_ThresholdForSnapshotting();
    public void set_ThresholdForSnapshotting(int value);
    public int get_MaximumSnapshotsRequired();
    public void set_MaximumSnapshotsRequired(int value);
    public int get_MaximumCollectionPlanSize();
    public void set_MaximumCollectionPlanSize(int value);
    public string get_AgentEndpoint();
    public void set_AgentEndpoint(string value);
    public TimeSpan get_ReconnectInterval();
    public void set_ReconnectInterval(TimeSpan value);
    public TimeSpan get_ProblemCounterResetInterval();
    public void set_ProblemCounterResetInterval(TimeSpan value);
    public int get_SnapshotsPerTenMinutesLimit();
    public void set_SnapshotsPerTenMinutesLimit(int value);
    public int get_SnapshotsPerDayLimit();
    public void set_SnapshotsPerDayLimit(int value);
    public bool get_SnapshotInLowPriorityThread();
    public void set_SnapshotInLowPriorityThread(bool value);
    public int get_DeoptimizeMethodCount();
    public void set_DeoptimizeMethodCount(int value);
    public string get_DeoptimizeIgnoredModules();
    public void set_DeoptimizeIgnoredModules(string value);
    public int get_LogRotationInDays();
    public void set_LogRotationInDays(int value);
    public string get_ShadowCopyFolder();
    public void set_ShadowCopyFolder(string value);
    public bool get_IsExceptionSnappointsEnabled();
    public void set_IsExceptionSnappointsEnabled(bool value);
    public string get_ExceptionSnappointSettingsFile();
    public void set_ExceptionSnappointSettingsFile(string value);
    public string get_TempFolder();
    public void set_TempFolder(string value);
    public bool get_ProvideAnonymousTelemetry();
    public void set_ProvideAnonymousTelemetry(bool value);
    public int get_FailedRequestLimit();
    public void set_FailedRequestLimit(int value);
    public bool get_IsEnabledWhenProfiling();
    public void set_IsEnabledWhenProfiling(bool value);
    public bool get_IsLowPrioritySnapshotUploader();
    public void set_IsLowPrioritySnapshotUploader(bool value);
    public string get_UploaderProxy();
    public void set_UploaderProxy(string value);
    public double get_CaptureSnapshotMemoryWeight();
    public void set_CaptureSnapshotMemoryWeight(double value);
    public bool get_ShareUploaderProcess();
    public void set_ShareUploaderProcess(bool value);
    public bool get_IsInProcReJitEnabled();
    public void set_IsInProcReJitEnabled(bool value);
    public TimeSpan get_PdbRescanInterval();
    public void set_PdbRescanInterval(TimeSpan value);
    public string get_AuthenticationString();
    public void set_AuthenticationString(string value);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public sealed virtual void Dispose();
    public sealed virtual void Process(ITelemetry item);
    public virtual string ToString();
    private ILogger get_Logger();
    private bool IsProcessorEnabled(ITelemetry item);
    internal bool TryGetConnectionString(ITelemetry item, ConnectionString& connectionString);
    private bool SetAndVerifyWorkingFolders(ConnectionString connectionString);
    private bool get_IsInDeveloperMode();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorTelemetryProcessor/<ConnectAsync>d__116")]
private Task`1<bool> ConnectAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    private static bool IsNonRetryableConnectException(Exception ex);
    private void VerifyPlatformIsSupported();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorTelemetryProcessor/<StartReconnectTimerAsync>d__119")]
private Task StartReconnectTimerAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCollectorTelemetryProcessor/<StartSupportingWorkersAsync>d__120")]
private Task StartSupportingWorkersAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    private void Disable(string reason);
    private void UpdateProcessorState();
    private void OnFirstChanceException(object sender, Exception e);
    private void ProcessExceptionTelemetry(ExceptionTelemetry exceptionTelemetry);
    private static bool TelemetryIsFromFirstChanceExceptionStatisticsTelemetryModule(ISupportProperties telemetryItem);
    private void OnRequestSnapshotCollection(object sender, ProblemId problem);
    private void EnsureDumpFolderExists();
    private void SetRoleName(string roleName);
    private static Task`1<bool> NeverReturnsAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SnapshotCollector <.ctor>b__104_0();
    [CompilerGeneratedAttribute]
private void <OnRequestSnapshotCollection>b__126_0();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotContext : object {
    public Guid SnapshotId;
    public string StampId;
    public SnapshotContext(BinaryReader reader);
    public void AddPropertiesToTelemetry(ISupportProperties telemetry);
    public virtual string ToString();
    public sealed virtual bool Equals(SnapshotContext other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void WriteTo(BinaryWriter writer);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SnapshotCreator : object {
    [CompilerGeneratedAttribute]
private bool <SnapshottingApisArePresent>k__BackingField;
    private SnapshotCollectorConfiguration _configuration;
    private IUploader _uploader;
    private ISessionSource _sessionSource;
    public bool SnapshottingApisArePresent { get; }
    public SnapshotCreator(SnapshotCollectorConfiguration configuration, IUploader uploader, ISessionSource sessionSource);
    public sealed virtual Guid SnapshotExceptionOnCurrentThread(string triggerDescription);
    public sealed virtual Guid CreateSnapshot(TriggerInfo trigger);
    public sealed virtual Guid DeOptimizeMethod(MethodBase methodBase);
    public sealed virtual void ReOptimizeMethod(Guid deOptimizationId);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SnapshottingApisArePresent();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.StampFrontEnd : object {
    private IAuthTokenProvider _authTokenProvider;
    private ILogger _logger;
    private AuthToken _authToken;
    private static string SnapshotStampidPath;
    public StampFrontEnd(IAuthTokenProvider authTokenProvider, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.StampFrontEnd/<GetStampIdAndAppIdAsync>d__4")]
public sealed virtual Task`1<GetStampIdResponse> GetStampIdAndAppIdAsync(ConnectionString connectionString, string machineName, string featureVersion, string siteExtensionVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.StampFrontEnd/<AuthenticateRequestAsync>d__5")]
private Task AuthenticateRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static Exception TranslateRequestException(Exception ex, HttpStatusCode statusCode);
    internal static GetStampIdResponse DeserializeStampIdResponse(Stream stream);
    private static string GetQueryString(string iKey, string machineName, string featureVersion, string siteExtensionVersion);
    private static string QueryParameterIfValueNotNullOrEmpty(string parameterName, string value);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.StringExtensions : object {
    [ExtensionAttribute]
public static string NeedsLocalization(string s);
    [ExtensionAttribute]
public static ISet`1<string> SplitToSet(string str, char separator, IEqualityComparer`1<string> comparer);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.StructuredInstrumentationKeyExtensions : object {
    [ExtensionAttribute]
public static bool TryParseInstrumentationKey(string structuredIKey, Guid& instrumentationKey);
    [ExtensionAttribute]
public static bool TryParseStructuredInstrumentationKey(string structuredIKey, String& domainId, String& applicationId);
    private static bool IsUppercaseAlpha(char ch);
    private static bool IsLowercaseAlpha(char ch);
    private static bool IsDecimalDigit(char ch);
    private static bool IsValidDomainIdChar(char ch);
    private static bool IsValidApplicationIdChar(char ch);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.SystemTimeSource : object {
    public DateTime UtcNow { get; }
    public sealed virtual DateTime get_UtcNow();
    public sealed virtual Task Delay(TimeSpan timeSpan, CancellationToken cancellationToken);
    public sealed virtual IDisposable StartIntervalTimer(TimeSpan dueTime, TimeSpan period, TimerCallback callback, object state);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.TelemetryChannelFactory : object {
    public sealed virtual ITelemetryChannel Create();
    protected virtual ITelemetryChannel CreateCore();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.SnapshotCollector.TelemetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static SnapshotCollectorTelemetryProcessor GetSnapshotCollector(TelemetryConfiguration telemetryConfiguration);
    [IteratorStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.TelemetryConfigurationExtensions/<GetTelemetrySinkTelemetryProcessors>d__1")]
private static IEnumerable`1<IEnumerable`1<ITelemetryProcessor>> GetTelemetrySinkTelemetryProcessors(TelemetryConfiguration telemetryConfiguration);
    private static SnapshotCollectorTelemetryProcessor GetSnapshotCollector(IEnumerable`1<ITelemetryProcessor> telemetryProcessors);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.TelemetryConfigurationFactory : object {
    private ITelemetryChannelFactory _telemetryChannelFactory;
    internal TelemetryConfigurationFactory(ITelemetryChannelFactory telemetryChannelFactory);
    public sealed virtual TelemetryConfiguration Create();
    private static void TryInitializeTelemetryChannel(ITelemetryChannel telemetryChannel, TelemetryConfiguration telemetryConfiguration);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.SnapshotCollector.TelemetryProcessorChainBuilderExtensions : object {
    [ExtensionAttribute]
public static void UseSnapshotCollector(TelemetryProcessorChainBuilder builder, SnapshotCollectorConfiguration configuration);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.TelemetryTracker : object {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleName>k__BackingField;
    private SnapshotCollectorConfiguration _configuration;
    private IAppInsightsLogger _msAILogger;
    private IDisposable _heartbeatTimer;
    private ITimeSource _timeSource;
    private TelemetryConfiguration _msAITelemetryConfiguration;
    private DiagnosticSource _diagnosticSource;
    private string _unhealthyReason;
    private static string EventNameSnapshotCollectorLog;
    private HeartbeatMetrics _heartbeatMetrics;
    private TelemetryClient _customerTelemetryClient;
    private IAuthTokenProvider _authTokenProvider;
    internal static TimeSpan s_firstHeartbeatDelay;
    internal static TimeSpan s_heartbeatInterval;
    public string SessionId { get; private set; }
    private bool Microsoft.ApplicationInsights.SnapshotCollector.IAuthTokenProvider.IsAadAuthenticationEnabled { get; }
    public string RoleName { get; private set; }
    public TelemetryTracker(SnapshotCollectorConfiguration configuration, RuntimeEnvironment runtimeEnvironment, ITimeSource timeSource);
    internal TelemetryTracker(SnapshotCollectorConfiguration configuration, RuntimeEnvironment runtimeEnvironment, ITimeSource timeSource, ITelemetryConfigurationFactory telemetryConfigurationFactory);
    internal TelemetryTracker(SnapshotCollectorConfiguration configuration, RuntimeEnvironment runtimeEnvironment, ITimeSource timeSource, TelemetryConfiguration msAITelemetryConfiguration);
    internal TelemetryTracker(SnapshotCollectorConfiguration configuration, IAppInsightsLogger msAILogger, RuntimeEnvironment runtimeEnvironment, ITimeSource timeSource, TelemetryConfiguration msAITelemetryConfiguration);
    private static TelemetryTracker();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.TelemetryTracker/<ModifyRuntimeEnvironmentAsync>d__4")]
private Task`1<RuntimeEnvironment> ModifyRuntimeEnvironmentAsync(RuntimeEnvironment runtimeEnvironment);
    public sealed virtual void SetCustomerConnectionString(ConnectionString connectionString);
    public sealed virtual void SetCustomerAppInfo(Guid appId);
    public sealed virtual void Dispose();
    public sealed virtual void SetUnhealthy(string reason);
    public sealed virtual void SetHealthy();
    public sealed virtual void IncrementHeartbeatMetric(HeartbeatMetricIndex index);
    public sealed virtual void Log(string name, object value);
    public sealed virtual void LogWithMemory(string name, object value);
    private void LogCustomEvent(string name, object value, IDictionary`2<string, double> metrics);
    public sealed virtual bool IsEnabled(string name);
    public sealed virtual void LogQuiet(string name, object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionId();
    [CompilerGeneratedAttribute]
private void set_SessionId(string value);
    public sealed virtual void InitializeCustomerTelemetry(TelemetryConfiguration configuration);
    public sealed virtual void TrackCustomerException(ExceptionTelemetry exception);
    private sealed virtual override bool Microsoft.ApplicationInsights.SnapshotCollector.IAuthTokenProvider.get_IsAadAuthenticationEnabled();
    private sealed virtual override Task`1<AuthToken> Microsoft.ApplicationInsights.SnapshotCollector.IAuthTokenProvider.GetTokenAsync(CancellationToken cancellationToken);
    public sealed virtual void SetRoleName(string roleName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RoleName();
    [CompilerGeneratedAttribute]
private void set_RoleName(string value);
    private static Dictionary`2<string, string> ExtractPropertiesDictionaryFromAnonymousType(object value);
    private static void HeartbeatCallback(object state);
    private void OnHeartbeat();
    private void TrackCustomEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    private static IDictionary`2<string, double> GetMemoryMetrics();
    private static string GetSdkVersionPrefix();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(Task`1<RuntimeEnvironment> rm);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.TooManyRedirectsException : Exception {
    public TooManyRedirectsException(int maxRedirectAllowed);
    public TooManyRedirectsException(string message);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.Uploader : object {
    public static string UploaderBaseName;
    private static string s_uploaderProcessName;
    private static String[] s_embeddedResourceNames;
    private SnapshotCollectorConfiguration _configuration;
    private IWorkingFolders _workingFolders;
    private IWebProxy _defaultWebProxy;
    private ProducerConsumerQueue`1<Request> _requestQueue;
    private SemaphoreSlim _semaphore;
    private ILogger _logger;
    private object _startUploaderLock;
    private UploaderProcessStartInfo _uploaderProcessStartInfo;
    private UploaderProcess _uploaderProcess;
    private ConnectionString _connectionString;
    private DateTime _nextPdbScanDueTime;
    private bool _isShuttingDown;
    private static Char[] s_directorySeparators;
    private string DumpsFolder { get; }
    private string ShadowCopyFolder { get; private set; }
    private bool IsUploaderRunning { get; }
    private string SnapshotUploaderPipeName { get; }
    public Uploader(SnapshotCollectorConfiguration configuration, IWorkingFolders workingFolders, ILogger logger, IWebProxy defaultWebProxy, CancellationToken shutdownToken);
    private static Uploader();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.Uploader/<StartAsync>d__2")]
public sealed virtual Task StartAsync(ConnectionString connectionString, CancellationToken cancellationToken);
    private string get_DumpsFolder();
    private string get_ShadowCopyFolder();
    private void set_ShadowCopyFolder(string value);
    private bool TryStartUploader();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.Uploader/<TryStartUploaderAsync>d__12")]
private Task`1<bool> TryStartUploaderAsync(CancellationToken cancellationToken);
    private void RequestPdbScan();
    private string GetUploaderProxy();
    private bool TryStartUploader(string processPath, UploaderArguments arguments);
    private bool TryStartUploader(UploaderProcessStartInfo processStartInfo);
    private UploaderProcess StartUploader(UploaderProcessStartInfo processStartInfo);
    private void UploaderExited(int exitCode, TimeSpan elapsedTime, OutputData capturedOutput);
    [IteratorStateMachineAttribute("Microsoft.ApplicationInsights.SnapshotCollector.Uploader/<EnumerateSearchPaths>d__19")]
private static IEnumerable`1<string> EnumerateSearchPaths();
    private static string GetSymbolSearchPaths();
    private bool get_IsUploaderRunning();
    private string get_SnapshotUploaderPipeName();
    private Consumer`1<Request> SnapshotRequestClientPipelineFactory();
    private void OnServerConnectionTimedOut(object sender, UploaderConnectTimeoutEventArgs e);
    public sealed virtual void EnqueueRequest(SnapshotRequest request);
    private void Shutdown();
    private void SendShutdownRequest();
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.SnapshotCollector.UploaderArguments : object {
    [CompilerGeneratedAttribute]
private ConnectionString <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolsFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DumpsFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProvideTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LogRotationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationString>k__BackingField;
    [DataMemberAttribute]
public ConnectionString ConnectionString { get; private set; }
    [DataMemberAttribute]
public int ParentProcessId { get; private set; }
    [DataMemberAttribute]
public string SymbolsFolder { get; private set; }
    [DataMemberAttribute]
public string DumpsFolder { get; private set; }
    [DataMemberAttribute]
public bool ProvideTelemetry { get; private set; }
    [DataMemberAttribute]
public string Proxy { get; private set; }
    [DataMemberAttribute]
public TimeSpan LogRotationInterval { get; private set; }
    [IgnoreDataMemberAttribute]
public string AuthenticationString { get; private set; }
    public UploaderArguments(ConnectionString connectionString, int parentProcessId, string symbolsFolder, string dumpsFolder, bool provideTelemetry, string proxy, TimeSpan logRotationInterval, string authenticationString);
    [CompilerGeneratedAttribute]
public ConnectionString get_ConnectionString();
    [CompilerGeneratedAttribute]
private void set_ConnectionString(ConnectionString value);
    [CompilerGeneratedAttribute]
public int get_ParentProcessId();
    [CompilerGeneratedAttribute]
private void set_ParentProcessId(int value);
    [CompilerGeneratedAttribute]
public string get_SymbolsFolder();
    [CompilerGeneratedAttribute]
private void set_SymbolsFolder(string value);
    [CompilerGeneratedAttribute]
public string get_DumpsFolder();
    [CompilerGeneratedAttribute]
private void set_DumpsFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_ProvideTelemetry();
    [CompilerGeneratedAttribute]
private void set_ProvideTelemetry(bool value);
    [CompilerGeneratedAttribute]
public string get_Proxy();
    [CompilerGeneratedAttribute]
private void set_Proxy(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LogRotationInterval();
    [CompilerGeneratedAttribute]
private void set_LogRotationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationString();
    [CompilerGeneratedAttribute]
private void set_AuthenticationString(string value);
    public string ToCommandLine();
    public virtual string ToString();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.UploaderProcess : object {
    private Process _process;
    private OnProcessExitDelegate _onProcessExit;
    public static TimeSpan c_monitorProcessTimeout;
    private bool _monitorOutput;
    private DateTime _monitorEndTimeUtc;
    private ConcurrentQueue`1<string> _outputData;
    public ProcessPriorityClass PriorityClass { get; public set; }
    public UploaderProcess(UploaderProcessStartInfo startInfo, OnProcessExitDelegate onProcessExit);
    internal UploaderProcess(UploaderProcessStartInfo startInfo, OnProcessExitDelegate onProcessExit, TimeSpan processMonitorTimeout);
    private static UploaderProcess();
    public ProcessPriorityClass get_PriorityClass();
    public void set_PriorityClass(ProcessPriorityClass value);
    public sealed virtual void Dispose();
    public static bool ShouldLogOutput(TimeSpan processLifeTime, ExitCode processExitCode);
    private void ProcessExited(object sender, EventArgs e);
    private void ProcessDataHandler(object sender, DataReceivedEventArgs e);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.UploaderProcessStartInfo : object {
    public ProcessStartInfo StartInfo;
    public UploaderArguments Arguments;
    public bool MonitorProcessOutput;
    public string Path { get; }
    public UploaderProcessStartInfo(string processPath, UploaderArguments arguments, bool showConsole);
    internal UploaderProcessStartInfo(string processPath, string argumentsAsCommandLine, bool showConsole);
    public string get_Path();
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.UploaderStartException : Exception {
    private IEnumerable`1<string> _searchPaths;
    public string Message { get; }
    public UploaderStartException(string message);
    public UploaderStartException(string message, IEnumerable`1<string> searchPaths);
    public virtual string get_Message();
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.SnapshotCollector.UriExtensions : object {
    [ExtensionAttribute]
public static Uri Anonymize(Uri uri);
}
internal class Microsoft.ApplicationInsights.SnapshotCollector.WorkingFolders : object {
    private string _dumpsFolder;
    private string _shadowCopyFolder;
    public string DumpsFolder { get; }
    public string ShadowCopyFolder { get; }
    public sealed virtual string get_DumpsFolder();
    public sealed virtual string get_ShadowCopyFolder();
    public sealed virtual bool TrySetDumpsFolder(string value);
    public sealed virtual bool TrySetShadowCopyFolder(string value);
    private static bool UpdateWithExpandedValue(String& field, string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsHelpers : object {
    public static int GenerateCoreDump(int processId, string dumpName, DumpType dumpType, bool diagnostics);
    public static int AttachProfiler(int processId, UInt32 attachTimeout, Guid profilerGuid, string profilerPath, Byte[] additionalData);
    private static Byte[] SerializeProfilerAttach(UInt32 attachTimeout, Guid profilerGuid, string profilerPath, Byte[] additionalData);
    private static Byte[] SerializeCoreDump(string dumpName, DumpType dumpType, bool diagnostics);
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.DiagnosticsServerCommandId : Enum {
    public byte value__;
    public static DiagnosticsServerCommandId OK;
    public static DiagnosticsServerCommandId Error;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.DiagnosticsServerCommandSet : Enum {
    public byte value__;
    public static DiagnosticsServerCommandSet Dump;
    public static DiagnosticsServerCommandSet EventPipe;
    public static DiagnosticsServerCommandSet Profiler;
    public static DiagnosticsServerCommandSet Server;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.DumpCommandId : Enum {
    public byte value__;
    public static DumpCommandId GenerateCoreDump;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.EventPipeCommandId : Enum {
    public byte value__;
    public static EventPipeCommandId StopTracing;
    public static EventPipeCommandId CollectTracing;
    public static EventPipeCommandId CollectTracing2;
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.IpcClient : object {
    [CompilerGeneratedAttribute]
private static string <IpcRootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static double <ConnectTimeoutMilliseconds>k__BackingField;
    private static string IpcRootPath { get; }
    private static double ConnectTimeoutMilliseconds { get; }
    private static IpcClient();
    [CompilerGeneratedAttribute]
private static string get_IpcRootPath();
    [CompilerGeneratedAttribute]
private static double get_ConnectTimeoutMilliseconds();
    private static Stream GetTransport(int processId);
    public static IpcMessage SendMessage(int processId, IpcMessage message);
    public static Stream SendMessage(int processId, IpcMessage message, IpcMessage& response);
    private static void Write(Stream stream, IpcMessage message);
    private static IpcMessage Read(Stream stream);
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.IpcHeader : object {
    public static ushort HeaderSizeInBytes;
    private static ushort s_magicSizeInBytes;
    public Byte[] Magic;
    public ushort Size;
    public byte CommandSet;
    public byte CommandId;
    public ushort Reserved;
    public static Byte[] DOTNET_IPC_V1 { get; }
    public IpcHeader(DiagnosticsServerCommandSet commandSet, byte commandId);
    private static IpcHeader();
    public static Byte[] get_DOTNET_IPC_V1();
    public Byte[] Serialize();
    public static IpcHeader TryParse(BinaryReader reader);
    public virtual string ToString();
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.IpcMessage : object {
    [CompilerGeneratedAttribute]
private Byte[] <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private IpcHeader <Header>k__BackingField;
    public Byte[] Payload { get; private set; }
    public IpcHeader Header { get; private set; }
    public IpcMessage(IpcHeader header, Byte[] payload);
    internal IpcMessage(DiagnosticsServerCommandSet commandSet, byte commandId, Byte[] payload);
    [CompilerGeneratedAttribute]
public Byte[] get_Payload();
    [CompilerGeneratedAttribute]
private void set_Payload(Byte[] value);
    [CompilerGeneratedAttribute]
public IpcHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(IpcHeader value);
    public Byte[] Serialize();
    public static IpcMessage Parse(Stream stream);
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsIpc.ProfilerCommandId : Enum {
    public byte value__;
    public static ProfilerCommandId AttachProfiler;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.DiagnosticsMessageType : Enum {
    public UInt32 value__;
    public static DiagnosticsMessageType GenerateCoreDump;
    public static DiagnosticsMessageType StartEventPipeTracing;
    public static DiagnosticsMessageType StopEventPipeTracing;
    public static DiagnosticsMessageType CollectEventPipeTracing;
    public static DiagnosticsMessageType AttachProfiler;
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeBadEncodingException : Exception {
    public EventPipeBadEncodingException(string msg);
}
internal static class Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeClient : object {
    [CompilerGeneratedAttribute]
private static string <DiagnosticsPortPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <IpcRootPath>k__BackingField;
    private static string DiagnosticsPortPattern { get; }
    private static string IpcRootPath { get; }
    private static EventPipeClient();
    [CompilerGeneratedAttribute]
private static string get_DiagnosticsPortPattern();
    [CompilerGeneratedAttribute]
private static string get_IpcRootPath();
    public static IEnumerable`1<int> ListAvailablePorts();
    public static Stream CollectTracing(int processId, SessionConfiguration configuration, UInt64& sessionId);
    public static Stream CollectTracing2(int processId, SessionConfigurationV2 configuration, UInt64& sessionId);
    public static ulong StopTracing(int processId, ulong sessionId);
    private static Exception ConvertHRToException(UInt32 hr, string msg);
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeErrorCode : Enum {
    public UInt32 value__;
    public static EventPipeErrorCode BAD_ENCODING;
    public static EventPipeErrorCode UNKNOWN_COMMAND;
    public static EventPipeErrorCode UNKNOWN_MAGIC;
    public static EventPipeErrorCode UNKNOWN_ERROR;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeSerializationFormat : Enum {
    public int value__;
    public static EventPipeSerializationFormat NetPerf;
    public static EventPipeSerializationFormat NetTrace;
}
internal enum Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeSessionType : Enum {
    public UInt32 value__;
    public static EventPipeSessionType TraceToFile;
    public static EventPipeSessionType CallbackListener;
    public static EventPipeSessionType TraceToStream;
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeUnknownCommandException : Exception {
    public EventPipeUnknownCommandException(string msg);
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeUnknownErrorException : Exception {
    public EventPipeUnknownErrorException(string msg);
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.EventPipeUnknownMagicException : Exception {
    public EventPipeUnknownMagicException(string msg);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Tools.RuntimeClient.Extensions : object {
    [ExtensionAttribute]
public static void WriteString(BinaryWriter this, string value);
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.MessageHeader : ValueType {
    public DiagnosticsMessageType RequestType;
    public UInt32 Pid;
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.Provider : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <EventLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterData>k__BackingField;
    public ulong Keywords { get; }
    public EventLevel EventLevel { get; }
    public string Name { get; }
    public string FilterData { get; }
    public Provider(string name, ulong keywords, EventLevel eventLevel, string filterData);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Keywords();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EventLevel get_EventLevel();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FilterData();
    public virtual string ToString();
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.SessionConfiguration : object {
    [CompilerGeneratedAttribute]
private UInt32 <CircularBufferSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPipeSerializationFormat <Format>k__BackingField;
    private List`1<Provider> _providers;
    public UInt32 CircularBufferSizeInMB { get; }
    public EventPipeSerializationFormat Format { get; }
    public IReadOnlyCollection`1<Provider> Providers { get; }
    public SessionConfiguration(UInt32 circularBufferSizeMB, EventPipeSerializationFormat format, IReadOnlyCollection`1<Provider> providers);
    [CompilerGeneratedAttribute]
public UInt32 get_CircularBufferSizeInMB();
    [CompilerGeneratedAttribute]
public EventPipeSerializationFormat get_Format();
    public IReadOnlyCollection`1<Provider> get_Providers();
    public virtual Byte[] Serialize();
}
internal class Microsoft.Diagnostics.Tools.RuntimeClient.SessionConfigurationV2 : SessionConfiguration {
    [CompilerGeneratedAttribute]
private bool <RequestRundown>k__BackingField;
    public bool RequestRundown { get; }
    public SessionConfigurationV2(UInt32 circularBufferSizeMB, EventPipeSerializationFormat format, bool requestRundown, IReadOnlyCollection`1<Provider> providers);
    [CompilerGeneratedAttribute]
public bool get_RequestRundown();
    public virtual Byte[] Serialize();
}
internal static class Microsoft.Diagnostics.Utilities.DirectoryUtilities : object {
    public static void CleanDirectories(string baseDir, string searchPattern, string excludedDirPath);
    public static int Clean(string directory);
}
internal static class Microsoft.Diagnostics.Utilities.FileUtilities : object {
    public static bool ForceDelete(string fileName);
    public static bool TryDelete(string fileName);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.Extensions.DependencyInjection.SnapshotCollectorServiceCollectionExtensions : object {
    private static string ApplicationInsightsExtensionsTypeName;
    [ExtensionAttribute]
public static IServiceCollection AddSnapshotCollector(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddSnapshotCollector(IServiceCollection services, Action`1<SnapshotCollectorConfiguration> configure);
    private static void TryAddSnapshotCollectorTelemetryProcessor(IServiceCollection services);
    private static bool TryAddSnapshotCollectorTelemetryProcessor(IServiceCollection services, Type applicationInsightsExtensionsType);
    [IteratorStateMachineAttribute("Microsoft.Extensions.DependencyInjection.SnapshotCollectorServiceCollectionExtensions/<GetApplicationInsightsExtensionsTypes>d__5")]
private static IEnumerable`1<Type> GetApplicationInsightsExtensionsTypes();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
