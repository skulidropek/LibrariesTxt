internal static class AssemblyInfo : object {
    public static string PublicKey;
    public static string MoqPublicKey;
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.ActivityExtensions : object {
    private static string OperationNameTag;
    private static bool isInitialized;
    private static bool isAvailable;
    public static bool TryRun(Action action);
    [ExtensionAttribute]
internal static string GetOperationName(Activity activity);
    [ExtensionAttribute]
internal static void SetOperationName(Activity activity, string operationName);
    private static bool Initialize();
}
internal interface Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry {
    public string TelemetryName { get; public set; }
    public string BaseType { get; }
    public abstract virtual string get_TelemetryName();
    public abstract virtual void set_TelemetryName(string value);
    public abstract virtual string get_BaseType();
}
public interface Microsoft.ApplicationInsights.Channel.IAsyncFlushable {
    public abstract virtual Task`1<bool> FlushAsync(CancellationToken cancellationToken);
}
public class Microsoft.ApplicationInsights.Channel.InMemoryChannel : object {
    private TelemetryBuffer buffer;
    private InMemoryTransmitter transmitter;
    private InterlockedThrottle throttleEmptyIkeyLog;
    private Nullable`1<bool> developerMode;
    private int bufferSize;
    private bool isDisposed;
    public Nullable`1<bool> DeveloperMode { get; public set; }
    public TimeSpan SendingInterval { get; public set; }
    private CredentialEnvelope Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.CredentialEnvelope { get; private set; }
    public string EndpointAddress { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    public int BacklogSize { get; public set; }
    internal bool IsDisposed { get; }
    internal InMemoryChannel(TelemetryBuffer telemetryBuffer, InMemoryTransmitter transmitter);
    public sealed virtual Nullable`1<bool> get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(Nullable`1<bool> value);
    public TimeSpan get_SendingInterval();
    public void set_SendingInterval(TimeSpan value);
    private sealed virtual override CredentialEnvelope Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.get_CredentialEnvelope();
    private sealed virtual override void Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.set_CredentialEnvelope(CredentialEnvelope value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public int get_BacklogSize();
    public void set_BacklogSize(int value);
    internal bool get_IsDisposed();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    public void Flush(TimeSpan timeout);
    public sealed virtual Task`1<bool> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task`1<bool> <FlushAsync>b__31_0();
}
internal class Microsoft.ApplicationInsights.Channel.InMemoryTransmitter : object {
    private TelemetryBuffer buffer;
    private object sendingLockObj;
    private AutoResetEvent startRunnerEvent;
    private bool enabled;
    private int disposeCount;
    private TimeSpan sendingInterval;
    [CompilerGeneratedAttribute]
private Uri <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialEnvelope <CredentialEnvelope>k__BackingField;
    internal Uri EndpointAddress { get; internal set; }
    internal TimeSpan SendingInterval { get; internal set; }
    internal CredentialEnvelope CredentialEnvelope { get; internal set; }
    internal InMemoryTransmitter(TelemetryBuffer buffer);
    [CompilerGeneratedAttribute]
internal Uri get_EndpointAddress();
    [CompilerGeneratedAttribute]
internal void set_EndpointAddress(Uri value);
    internal TimeSpan get_SendingInterval();
    internal void set_SendingInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
internal CredentialEnvelope get_CredentialEnvelope();
    [CompilerGeneratedAttribute]
internal void set_CredentialEnvelope(CredentialEnvelope value);
    public sealed virtual void Dispose();
    internal void Flush(TimeSpan timeout);
    private void Runner();
    private void OnBufferFull();
    private void DequeueAndSend(TimeSpan timeout);
    private Task Send(IEnumerable`1<ITelemetry> telemetryItems, TimeSpan timeout);
    private void Dispose(bool disposing);
}
public interface Microsoft.ApplicationInsights.Channel.ITelemetry {
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Sequence { get; public set; }
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual void set_Timestamp(DateTimeOffset value);
    public abstract virtual TelemetryContext get_Context();
    public abstract virtual IExtension get_Extension();
    public abstract virtual void set_Extension(IExtension value);
    public abstract virtual string get_Sequence();
    public abstract virtual void set_Sequence(string value);
    public abstract virtual void Sanitize();
    public abstract virtual ITelemetry DeepClone();
    public abstract virtual void SerializeData(ISerializationWriter serializationWriter);
}
public interface Microsoft.ApplicationInsights.Channel.ITelemetryChannel {
    public Nullable`1<bool> DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    public abstract virtual Nullable`1<bool> get_DeveloperMode();
    public abstract virtual void set_DeveloperMode(Nullable`1<bool> value);
    public abstract virtual string get_EndpointAddress();
    public abstract virtual void set_EndpointAddress(string value);
    public abstract virtual void Send(ITelemetry item);
    public abstract virtual void Flush();
}
internal class Microsoft.ApplicationInsights.Channel.RedirectHttpHandler : HttpClientHandler {
    internal static int MaxRedirect;
    internal TimeSpan DefaultCacheExpirationDuration;
    private Cache`1<Uri> cache;
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Channel.RedirectHttpHandler/<SendAsync>d__4")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool IsRedirection(HttpStatusCode statusCode);
    private static bool TryGetRedirectUri(HttpResponseMessage httpResponseMessage, Uri& redirectUri);
    private static bool TryGetRedirectCacheTimeSpan(HttpResponseMessage httpResponseMessage, TimeSpan& cacheExpirationDuration);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Channel.RedirectHttpHandler/<HandleRedirectAsync>d__8")]
private Task`1<HttpResponseMessage> HandleRedirectAsync(HttpRequestMessage request, HttpResponseMessage response, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Channel.SamplingScoreGenerator : object {
    public static double GetSamplingScore(string value);
    public static double GetSamplingScore(ITelemetry telemetry);
    [ExtensionAttribute]
internal static int GetSamplingHashCode(string input);
}
internal static class Microsoft.ApplicationInsights.Channel.TaskEx : object {
    internal static Task FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
}
internal class Microsoft.ApplicationInsights.Channel.TelemetryBuffer : object {
    public Action OnFull;
    private static int DefaultCapacity;
    private static int DefaultBacklogSize;
    private object lockObj;
    private int capacity;
    private int backlogSize;
    private int minimumBacklogSize;
    private List`1<ITelemetry> items;
    private bool itemDroppedMessageLogged;
    public int Capacity { get; public set; }
    public int BacklogSize { get; public set; }
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_BacklogSize();
    public void set_BacklogSize(int value);
    public void Enqueue(ITelemetry item);
    public virtual IEnumerable`1<ITelemetry> Dequeue();
}
public class Microsoft.ApplicationInsights.Channel.Transmission : object {
    internal static string ContentEncodingHeader;
    private static TimeSpan DefaultTimeout;
    private static HttpClient client;
    private static long flushAsyncCounter;
    private int isSending;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransmissionStatusEventArgs> <TransmissionStatusEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITelemetry> <TelemetryItems>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialEnvelope <CredentialEnvelope>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FlushAsyncId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFlushAsyncInProgress>k__BackingField;
    public EventHandler`1<TransmissionStatusEventArgs> TransmissionStatusEvent { get; public set; }
    public Uri EndpointAddress { get; private set; }
    public Byte[] Content { get; private set; }
    public string ContentType { get; private set; }
    public string ContentEncoding { get; private set; }
    public TimeSpan Timeout { get; internal set; }
    public string Id { get; private set; }
    public ICollection`1<ITelemetry> TelemetryItems { get; private set; }
    internal CredentialEnvelope CredentialEnvelope { get; internal set; }
    internal long FlushAsyncId { get; }
    internal bool IsFlushAsyncInProgress { get; internal set; }
    public Transmission(Uri address, Byte[] content, string contentType, string contentEncoding, TimeSpan timeout);
    public Transmission(Uri address, ICollection`1<ITelemetry> telemetryItems, TimeSpan timeout);
    internal Transmission(Uri address, IEnumerable`1<ITelemetry> telemetryItems, string contentType, string contentEncoding, TimeSpan timeout);
    internal Transmission(Uri address, Byte[] content, HttpClient passedClient, string contentType, string contentEncoding, TimeSpan timeout);
    private static Transmission();
    [CompilerGeneratedAttribute]
public EventHandler`1<TransmissionStatusEventArgs> get_TransmissionStatusEvent();
    [CompilerGeneratedAttribute]
public void set_TransmissionStatusEvent(EventHandler`1<TransmissionStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public Uri get_EndpointAddress();
    [CompilerGeneratedAttribute]
private void set_EndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
private void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
internal void set_Timeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<ITelemetry> get_TelemetryItems();
    [CompilerGeneratedAttribute]
private void set_TelemetryItems(ICollection`1<ITelemetry> value);
    [CompilerGeneratedAttribute]
internal CredentialEnvelope get_CredentialEnvelope();
    [CompilerGeneratedAttribute]
internal void set_CredentialEnvelope(CredentialEnvelope value);
    [CompilerGeneratedAttribute]
internal long get_FlushAsyncId();
    [CompilerGeneratedAttribute]
internal bool get_IsFlushAsyncInProgress();
    [CompilerGeneratedAttribute]
internal void set_IsFlushAsyncInProgress(bool value);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Channel.Transmission/<SendAsync>d__53")]
public virtual Task`1<HttpWebResponseWrapper> SendAsync();
    public virtual Tuple`2<Transmission, Transmission> Split(Func`2<int, int> calculateLength);
    internal void Serialize(Uri address, IEnumerable`1<ITelemetry> telemetryItems, TimeSpan timeout);
    protected virtual HttpRequestMessage CreateRequestMessage(Uri address, Stream contentStream);
    [ObsoleteAttribute("Use CreateRequestMessage instead as SendAsync is now using HttpClient to send HttpRequest.")]
protected virtual WebRequest CreateRequest(Uri address);
}
public class Microsoft.ApplicationInsights.Channel.TransmissionStatusEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpWebResponseWrapper <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResponseDurationInMs>k__BackingField;
    public HttpWebResponseWrapper Response { get; }
    public long ResponseDurationInMs { get; }
    [ObsoleteAttribute("This constructor is deprecated. Please use a constructor that accepts response and responseDurationInMs instead.", "False")]
public TransmissionStatusEventArgs(HttpWebResponseWrapper response);
    public TransmissionStatusEventArgs(HttpWebResponseWrapper response, long responseDurationInMs);
    [CompilerGeneratedAttribute]
public HttpWebResponseWrapper get_Response();
    [CompilerGeneratedAttribute]
public long get_ResponseDurationInMs();
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Common.Extensions.DateTimeExtensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(DateTime input, string format);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Common.Extensions.ExceptionExtensions : object {
    [ExtensionAttribute]
public static string FlattenMessages(Exception ex);
    [ExtensionAttribute]
public static string ToLogString(Exception ex);
}
internal class Microsoft.ApplicationInsights.Common.InterlockedThrottle : object {
    private TimeSpan interval;
    private long timeStamp;
    public InterlockedThrottle(TimeSpan interval);
    public void PerformThrottledAction(Action action);
}
internal class Microsoft.ApplicationInsights.Constants : object {
    internal static string ProfileQueryEndpoint;
    internal static string EventNameForUnknownTelemetry;
    internal static int MaxExceptionCountToSave;
}
public class Microsoft.ApplicationInsights.DataContracts.AvailabilityTelemetry : object {
    internal static string EtwEnvelopeName;
    internal AvailabilityData Data;
    internal string EnvelopeName;
    private TelemetryContext context;
    private IExtension extension;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public TimeSpan Duration { get; public set; }
    public bool Success { get; public set; }
    public string RunLocation { get; public set; }
    public string Message { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public IDictionary`2<string, double> Metrics { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public AvailabilityTelemetry(string name, DateTimeOffset timeStamp, TimeSpan duration, string runLocation, bool success, string message);
    private AvailabilityTelemetry(AvailabilityTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public bool get_Success();
    public void set_Success(bool value);
    public string get_RunLocation();
    public void set_RunLocation(string value);
    public string get_Message();
    public void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public sealed virtual IDictionary`2<string, double> get_Metrics();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.ApplicationInsights.DataContracts.DependencyTelemetry : OperationTelemetry {
    internal static string EtwEnvelopeName;
    internal string EnvelopeName;
    private TelemetryContext context;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    private bool successFieldSet;
    private bool success;
    private IDictionary`2<string, double> measurementsValue;
    private RemoteDependencyData internalDataPrivate;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricExtractorInfo>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Id { get; public set; }
    public string ResultCode { get; public set; }
    public string Name { get; public set; }
    [ObsoleteAttribute("Renamed to Data")]
public string CommandName { get; public set; }
    public string Data { get; public set; }
    public string Target { get; public set; }
    [ObsoleteAttribute("Renamed to Type")]
public string DependencyTypeName { get; public set; }
    public string Type { get; public set; }
    public TimeSpan Duration { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public IDictionary`2<string, double> Metrics { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Type")]
public string DependencyKind { get; public set; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    internal string MetricExtractorInfo { get; internal set; }
    internal RemoteDependencyData InternalData { get; private set; }
    [ObsoleteAttribute("Use other constructors which allows to define dependency call with all the properties.")]
public DependencyTelemetry(string dependencyName, string data, DateTimeOffset startTime, TimeSpan duration, bool success);
    public DependencyTelemetry(string dependencyTypeName, string target, string dependencyName, string data);
    public DependencyTelemetry(string dependencyTypeName, string target, string dependencyName, string data, DateTimeOffset startTime, TimeSpan duration, string resultCode, bool success);
    private DependencyTelemetry(DependencyTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public virtual void set_Sequence(string value);
    public virtual TelemetryContext get_Context();
    public virtual IExtension get_Extension();
    public virtual void set_Extension(IExtension value);
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    [CompilerGeneratedAttribute]
public virtual void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ResultCode();
    [CompilerGeneratedAttribute]
public void set_ResultCode(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    public string get_CommandName();
    public void set_CommandName(string value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    public string get_DependencyTypeName();
    public void set_DependencyTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public virtual void set_Duration(TimeSpan value);
    public virtual Nullable`1<bool> get_Success();
    public virtual void set_Success(Nullable`1<bool> value);
    public virtual IDictionary`2<string, string> get_Properties();
    public virtual IDictionary`2<string, double> get_Metrics();
    public string get_DependencyKind();
    public void set_DependencyKind(string value);
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    [CompilerGeneratedAttribute]
internal string get_MetricExtractorInfo();
    [CompilerGeneratedAttribute]
internal void set_MetricExtractorInfo(string value);
    internal RemoteDependencyData get_InternalData();
    private void set_InternalData(RemoteDependencyData value);
    public virtual ITelemetry DeepClone();
    public bool TryGetOperationDetail(string key, Object& detail);
    [EditorBrowsableAttribute("1")]
public void SetOperationDetail(string key, object detail);
    public virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    [CompilerGeneratedAttribute]
private RemoteDependencyData <get_InternalData>b__90_0();
}
public class Microsoft.ApplicationInsights.DataContracts.EventTelemetry : object {
    internal static string EtwEnvelopeName;
    internal static string DefaultEnvelopeName;
    internal EventData Data;
    internal string EnvelopeName;
    private TelemetryContext context;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Name { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    public EventTelemetry(string name);
    private EventTelemetry(EventTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    public sealed virtual ITelemetry DeepClone();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
}
public class Microsoft.ApplicationInsights.DataContracts.ExceptionDetailsInfo : object {
    internal ExceptionDetails InternalExceptionDetails;
    public string TypeName { get; public set; }
    public string Message { get; public set; }
    internal ExceptionDetails ExceptionDetails { get; }
    public ExceptionDetailsInfo(int id, int outerId, string typeName, string message, bool hasFullStack, string stack, IEnumerable`1<StackFrame> parsedStack);
    internal ExceptionDetailsInfo(ExceptionDetails exceptionDetails);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_Message();
    public void set_Message(string value);
    internal ExceptionDetails get_ExceptionDetails();
}
[ObsoleteAttribute("Use custom properties to report exception handling layer")]
public enum Microsoft.ApplicationInsights.DataContracts.ExceptionHandledAt : Enum {
    public int value__;
    public static ExceptionHandledAt Unhandled;
    public static ExceptionHandledAt UserCode;
    public static ExceptionHandledAt Platform;
}
internal class Microsoft.ApplicationInsights.DataContracts.ExceptionInfo : object {
    private ExceptionData data;
    public IReadOnlyList`1<ExceptionDetailsInfo> ExceptionDetailsInfoList { get; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    public string ProblemId { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    public IDictionary`2<string, double> Measurements { get; public set; }
    internal ExceptionData Data { get; }
    public ExceptionInfo(IEnumerable`1<ExceptionDetailsInfo> exceptionDetailsInfoList, Nullable`1<SeverityLevel> severityLevel, string problemId, IDictionary`2<string, string> properties, IDictionary`2<string, double> measurements);
    internal ExceptionInfo(ExceptionData data);
    public IReadOnlyList`1<ExceptionDetailsInfo> get_ExceptionDetailsInfoList();
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    public string get_ProblemId();
    public void set_ProblemId(string value);
    public IDictionary`2<string, string> get_Properties();
    public void set_Properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, double> get_Measurements();
    public void set_Measurements(IDictionary`2<string, double> value);
    internal ExceptionData get_Data();
    internal ExceptionInfo DeepClone();
}
public class Microsoft.ApplicationInsights.DataContracts.ExceptionTelemetry : object {
    internal static string EtwEnvelopeName;
    internal string EnvelopeName;
    internal ExceptionInfo Data;
    private bool isCreatedFromExceptionInfo;
    private TelemetryContext context;
    private IExtension extension;
    private Exception exception;
    private string message;
    private Nullable`1<double> samplingPercentage;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricExtractorInfo>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string ProblemId { get; public set; }
    [ObsoleteAttribute("Use custom properties to report exception handling layer")]
public ExceptionHandledAt HandledAt { get; public set; }
    public Exception Exception { get; public set; }
    public string Message { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IReadOnlyList`1<ExceptionDetailsInfo> ExceptionDetailsInfoList { get; }
    public IDictionary`2<string, string> Properties { get; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    internal IList`1<ExceptionDetails> Exceptions { get; }
    internal string MetricExtractorInfo { get; internal set; }
    public ExceptionTelemetry(Exception exception);
    public ExceptionTelemetry(IEnumerable`1<ExceptionDetailsInfo> exceptionDetailsInfoList, Nullable`1<SeverityLevel> severityLevel, string problemId, IDictionary`2<string, string> properties, IDictionary`2<string, double> measurements);
    private ExceptionTelemetry(ExceptionTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_ProblemId();
    public void set_ProblemId(string value);
    public ExceptionHandledAt get_HandledAt();
    public void set_HandledAt(ExceptionHandledAt value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public string get_Message();
    public void set_Message(string value);
    public sealed virtual IDictionary`2<string, double> get_Metrics();
    public IReadOnlyList`1<ExceptionDetailsInfo> get_ExceptionDetailsInfoList();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    internal IList`1<ExceptionDetails> get_Exceptions();
    [CompilerGeneratedAttribute]
internal string get_MetricExtractorInfo();
    [CompilerGeneratedAttribute]
internal void set_MetricExtractorInfo(string value);
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    public void SetParsedStack(StackFrame[] frames);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private void ConvertExceptionTree(Exception exception, ExceptionDetails parentExceptionDetails, List`1<ExceptionDetails> exceptions);
    private void UpdateData(Exception exception);
    private void UpdateData(ExceptionInfo exceptionInfo);
    private Exception ConstructExceptionFromDetailsInfo(IReadOnlyList`1<ExceptionDetailsInfo> exceptionInfos);
    private Exception ConstructInnerException(IReadOnlyList`1<ExceptionDetailsInfo> exceptionInfos, int parentExceptionIndex);
}
public interface Microsoft.ApplicationInsights.DataContracts.IJsonWriter {
    public abstract virtual void WriteStartArray();
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteEndArray();
    public abstract virtual void WriteEndObject();
    public abstract virtual void WriteComma();
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteProperty(string name, Nullable`1<bool> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<int> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<double> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public abstract virtual void WritePropertyName(string name);
    public abstract virtual void WriteRawValue(object value);
}
internal class Microsoft.ApplicationInsights.DataContracts.InnerExceptionCountExceededException : Exception {
    public InnerExceptionCountExceededException(string message);
    public InnerExceptionCountExceededException(string message, Exception innerException);
    protected InnerExceptionCountExceededException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.ApplicationInsights.DataContracts.ISupportAdvancedSampling {
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    public abstract virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    public abstract virtual SamplingDecision get_ProactiveSamplingDecision();
    public abstract virtual void set_ProactiveSamplingDecision(SamplingDecision value);
}
public interface Microsoft.ApplicationInsights.DataContracts.ISupportMetrics {
    public IDictionary`2<string, double> Metrics { get; }
    public abstract virtual IDictionary`2<string, double> get_Metrics();
}
public interface Microsoft.ApplicationInsights.DataContracts.ISupportProperties {
    public IDictionary`2<string, string> Properties { get; }
    public abstract virtual IDictionary`2<string, string> get_Properties();
}
public interface Microsoft.ApplicationInsights.DataContracts.ISupportSampling {
    public Nullable`1<double> SamplingPercentage { get; public set; }
    public abstract virtual Nullable`1<double> get_SamplingPercentage();
    public abstract virtual void set_SamplingPercentage(Nullable`1<double> value);
}
public class Microsoft.ApplicationInsights.DataContracts.MetricTelemetry : object {
    internal static string EtwEnvelopeName;
    internal MetricData Data;
    internal DataPoint Metric;
    internal string EnvelopeName;
    private IExtension extension;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryContext <Context>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string MetricNamespace { get; public set; }
    public string Name { get; public set; }
    [ObsoleteAttribute("This property is obsolete. Use Sum property instead.")]
public double Value { get; public set; }
    public double Sum { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> StandardDeviation { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public MetricTelemetry(string metricName, double metricValue);
    public MetricTelemetry(string name, int count, double sum, double min, double max, double standardDeviation);
    public MetricTelemetry(string metricNamespace, string name, int count, double sum, double min, double max, double standardDeviation);
    private MetricTelemetry(MetricTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_MetricNamespace();
    public void set_MetricNamespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public double get_Value();
    public void set_Value(double value);
    public double get_Sum();
    public void set_Sum(double value);
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
    public Nullable`1<double> get_Min();
    public void set_Min(Nullable`1<double> value);
    public Nullable`1<double> get_Max();
    public void set_Max(Nullable`1<double> value);
    public Nullable`1<double> get_StandardDeviation();
    public void set_StandardDeviation(Nullable`1<double> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.ApplicationInsights.DataContracts.PageViewPerformanceTelemetry : object {
    internal static string EtwEnvelopeName;
    internal PageViewPerfData Data;
    internal string EnvelopeName;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; private set; }
    public IExtension Extension { get; public set; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public Uri Url { get; public set; }
    public TimeSpan Duration { get; public set; }
    public TimeSpan DomProcessing { get; public set; }
    public TimeSpan PerfTotal { get; public set; }
    public TimeSpan NetworkConnect { get; public set; }
    public TimeSpan SentRequest { get; public set; }
    public TimeSpan ReceivedResponse { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    public PageViewPerformanceTelemetry(string pageName);
    private PageViewPerformanceTelemetry(PageViewPerformanceTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TelemetryContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(TelemetryContext value);
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public TimeSpan get_DomProcessing();
    public void set_DomProcessing(TimeSpan value);
    public TimeSpan get_PerfTotal();
    public void set_PerfTotal(TimeSpan value);
    public TimeSpan get_NetworkConnect();
    public void set_NetworkConnect(TimeSpan value);
    public TimeSpan get_SentRequest();
    public void set_SentRequest(TimeSpan value);
    public TimeSpan get_ReceivedResponse();
    public void set_ReceivedResponse(TimeSpan value);
    public IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    public sealed virtual ITelemetry DeepClone();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
}
public class Microsoft.ApplicationInsights.DataContracts.PageViewTelemetry : object {
    internal static string EtwEnvelopeName;
    internal PageViewData Data;
    internal string EnvelopeName;
    private TelemetryContext context;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public Uri Url { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    public PageViewTelemetry(string pageName);
    private PageViewTelemetry(PageViewTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_Id();
    public void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public sealed virtual IDictionary`2<string, double> get_Metrics();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
[ObsoleteAttribute("Use MetricTelemetry instead.")]
public class Microsoft.ApplicationInsights.DataContracts.PerformanceCounterTelemetry : object {
    internal MetricTelemetry Data;
    private string categoryName;
    private string counterName;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public double Value { get; public set; }
    public string CategoryName { get; public set; }
    public string CounterName { get; public set; }
    public string InstanceName { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public PerformanceCounterTelemetry(string categoryName, string counterName, string instanceName, double value);
    private PerformanceCounterTelemetry(PerformanceCounterTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual void set_Timestamp(DateTimeOffset value);
    public sealed virtual string get_Sequence();
    public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public double get_Value();
    public void set_Value(double value);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CounterName();
    public void set_CounterName(string value);
    public string get_InstanceName();
    public void set_InstanceName(string value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    private void UpdateName();
}
public class Microsoft.ApplicationInsights.DataContracts.RequestTelemetry : OperationTelemetry {
    internal static string EtwEnvelopeName;
    internal string EnvelopeName;
    private TelemetryContext context;
    private RequestData dataPrivate;
    private bool successFieldSet;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    private bool success;
    private IDictionary`2<string, double> measurementsValue;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricExtractorInfo>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string ResponseCode { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public Uri Url { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    [ObsoleteAttribute("Include http verb into request telemetry name and use custom properties to report http method as a dimension.")]
public string HttpMethod { get; public set; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    public string Source { get; public set; }
    internal string MetricExtractorInfo { get; internal set; }
    internal RequestData Data { get; private set; }
    public RequestTelemetry(string name, DateTimeOffset startTime, TimeSpan duration, string responseCode, bool success);
    private RequestTelemetry(RequestTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public virtual void set_Sequence(string value);
    public virtual TelemetryContext get_Context();
    public virtual IExtension get_Extension();
    public virtual void set_Extension(IExtension value);
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    [CompilerGeneratedAttribute]
public virtual void set_Id(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseCode();
    [CompilerGeneratedAttribute]
public void set_ResponseCode(string value);
    public virtual Nullable`1<bool> get_Success();
    public virtual void set_Success(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public virtual void set_Duration(TimeSpan value);
    public virtual IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Uri value);
    public virtual IDictionary`2<string, double> get_Metrics();
    public string get_HttpMethod();
    public void set_HttpMethod(string value);
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
internal string get_MetricExtractorInfo();
    [CompilerGeneratedAttribute]
internal void set_MetricExtractorInfo(string value);
    internal RequestData get_Data();
    private void set_Data(RequestData value);
    public virtual ITelemetry DeepClone();
    public virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    [CompilerGeneratedAttribute]
private RequestData <get_Data>b__78_0();
}
public enum Microsoft.ApplicationInsights.DataContracts.SamplingDecision : Enum {
    public int value__;
    public static SamplingDecision None;
    public static SamplingDecision SampledIn;
    public static SamplingDecision SampledOut;
}
[FlagsAttribute]
public enum Microsoft.ApplicationInsights.DataContracts.SamplingTelemetryItemTypes : Enum {
    public int value__;
    public static SamplingTelemetryItemTypes None;
    public static SamplingTelemetryItemTypes Event;
    public static SamplingTelemetryItemTypes Exception;
    public static SamplingTelemetryItemTypes Message;
    public static SamplingTelemetryItemTypes Metric;
    public static SamplingTelemetryItemTypes PageView;
    public static SamplingTelemetryItemTypes PageViewPerformance;
    public static SamplingTelemetryItemTypes PerformanceCounter;
    public static SamplingTelemetryItemTypes RemoteDependency;
    public static SamplingTelemetryItemTypes Request;
    public static SamplingTelemetryItemTypes SessionState;
    public static SamplingTelemetryItemTypes Availability;
}
[ObsoleteAttribute("Session state events are no longer used.")]
public enum Microsoft.ApplicationInsights.DataContracts.SessionState : Enum {
    public int value__;
    public static SessionState Start;
    public static SessionState End;
}
[ObsoleteAttribute("Session state events are no longer used. This telemetry item will be sent as EventTelemetry.")]
public class Microsoft.ApplicationInsights.DataContracts.SessionStateTelemetry : object {
    internal EventTelemetry Data;
    private string startEventName;
    private string endEventName;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Sequence { get; public set; }
    public SessionState State { get; public set; }
    public SessionStateTelemetry(SessionState state);
    private SessionStateTelemetry(SessionStateTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual void set_Timestamp(DateTimeOffset value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public sealed virtual string get_Sequence();
    public sealed virtual void set_Sequence(string value);
    public SessionState get_State();
    public void set_State(SessionState value);
    public sealed virtual ITelemetry DeepClone();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
}
public enum Microsoft.ApplicationInsights.DataContracts.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
public class Microsoft.ApplicationInsights.DataContracts.StackFrame : object {
    [CompilerGeneratedAttribute]
private StackFrame <Data>k__BackingField;
    internal StackFrame Data { get; private set; }
    public StackFrame(string assembly, string fileName, int level, int line, string method);
    [CompilerGeneratedAttribute]
internal StackFrame get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(StackFrame value);
}
public class Microsoft.ApplicationInsights.DataContracts.TelemetryContext : object {
    public static long FlagDropIdentifiers;
    internal IDictionary`2<string, string> GlobalPropertiesValue;
    internal IDictionary`2<string, string> PropertiesValue;
    private InternalContext internalContext;
    private string instrumentationKey;
    private IDictionary`2<string, object> rawObjectsTemp;
    private IDictionary`2<string, object> rawObjectsPerm;
    private ComponentContext component;
    private DeviceContext device;
    private CloudContext cloud;
    private SessionContext session;
    private UserContext user;
    private OperationContext operation;
    private LocationContext location;
    [CompilerGeneratedAttribute]
private long <Flags>k__BackingField;
    public string InstrumentationKey { get; public set; }
    public long Flags { get; public set; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public CloudContext Cloud { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
    public OperationContext Operation { get; }
    public LocationContext Location { get; }
    [ObsoleteAttribute("Use GlobalProperties to set global level properties. For properties at item level, use ISupportProperties.Properties.")]
public IDictionary`2<string, string> Properties { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    internal InternalContext Internal { get; }
    internal IDictionary`2<string, string> SanitizedTags { get; }
    internal TelemetryContext(IDictionary`2<string, string> properties);
    internal TelemetryContext(IDictionary`2<string, string> properties, IDictionary`2<string, string> globalProperties);
    public string get_InstrumentationKey();
    public void set_InstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public long get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(long value);
    public ComponentContext get_Component();
    public DeviceContext get_Device();
    public CloudContext get_Cloud();
    public SessionContext get_Session();
    public UserContext get_User();
    public OperationContext get_Operation();
    public LocationContext get_Location();
    public IDictionary`2<string, string> get_Properties();
    public IDictionary`2<string, string> get_GlobalProperties();
    internal InternalContext get_Internal();
    internal IDictionary`2<string, string> get_SanitizedTags();
    public bool TryGetRawObject(string key, Object& rawObject);
    public void StoreRawObject(string key, object rawObject, bool keepForInitializationOnly);
    internal void SanitizeGlobalProperties();
    internal void ClearTempRawObjects();
    internal TelemetryContext DeepClone(IDictionary`2<string, string> properties);
    internal TelemetryContext DeepClone();
    internal void Initialize(TelemetryContext source, string instrumentationKey);
    internal void InitializeInstrumentationkey(string instrumentationKey);
    [CompilerGeneratedAttribute]
private DeviceContext <get_Device>b__27_0();
}
public class Microsoft.ApplicationInsights.DataContracts.TraceTelemetry : object {
    internal static string EtwEnvelopeName;
    internal MessageData Data;
    internal string EnvelopeName;
    private TelemetryContext context;
    private IExtension extension;
    private Nullable`1<double> samplingPercentage;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private SamplingDecision <ProactiveSamplingDecision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricExtractorInfo>k__BackingField;
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.TelemetryName { get; private set; }
    private string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.BaseType { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public string Sequence { get; public set; }
    public TelemetryContext Context { get; }
    public IExtension Extension { get; public set; }
    public string Message { get; public set; }
    public Nullable`1<SeverityLevel> SeverityLevel { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    private Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.SamplingPercentage { get; private set; }
    public SamplingTelemetryItemTypes ItemTypeFlag { get; }
    public SamplingDecision ProactiveSamplingDecision { get; public set; }
    internal string MetricExtractorInfo { get; internal set; }
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    private TraceTelemetry(TraceTelemetry source);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_TelemetryName();
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.set_TelemetryName(string value);
    private sealed virtual override string Microsoft.ApplicationInsights.Channel.IAiSerializableTelemetry.get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(string value);
    public sealed virtual TelemetryContext get_Context();
    public sealed virtual IExtension get_Extension();
    public sealed virtual void set_Extension(IExtension value);
    public string get_Message();
    public void set_Message(string value);
    public Nullable`1<SeverityLevel> get_SeverityLevel();
    public void set_SeverityLevel(Nullable`1<SeverityLevel> value);
    public sealed virtual IDictionary`2<string, string> get_Properties();
    private sealed virtual override Nullable`1<double> Microsoft.ApplicationInsights.DataContracts.ISupportSampling.get_SamplingPercentage();
    private sealed virtual override void Microsoft.ApplicationInsights.DataContracts.ISupportSampling.set_SamplingPercentage(Nullable`1<double> value);
    public sealed virtual SamplingTelemetryItemTypes get_ItemTypeFlag();
    [CompilerGeneratedAttribute]
public sealed virtual SamplingDecision get_ProactiveSamplingDecision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProactiveSamplingDecision(SamplingDecision value);
    [CompilerGeneratedAttribute]
internal string get_MetricExtractorInfo();
    [CompilerGeneratedAttribute]
internal void set_MetricExtractorInfo(string value);
    public sealed virtual ITelemetry DeepClone();
    public sealed virtual void SerializeData(ISerializationWriter serializationWriter);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
}
public class Microsoft.ApplicationInsights.Extensibility.AutocollectedMetricsExtractor : object {
    private RequestMetricsExtractor extractorForRequestMetrics;
    private DependencyMetricsExtractor extractorForDependencyMetrics;
    private ExceptionMetricsExtractor extractorForExceptionMetrics;
    private TraceMetricsExtractor extractorForTraceMetrics;
    private ExtractorWithInfo[] extractors;
    private TelemetryClient metricTelemetryClient;
    private ITelemetryProcessor nextProcessorInPipeline;
    private bool isMetricExtractorAfterSamplingLogged;
    public int MaxDependencyTypesToDiscover { get; public set; }
    public int MaxDependencyResultCodesToDiscover { get; public set; }
    public int MaxDependencyTargetValuesToDiscover { get; public set; }
    public int MaxDependencyCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxDependencyCloudRoleNameValuesToDiscover { get; public set; }
    public int MaxExceptionCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxExceptionCloudRoleNameValuesToDiscover { get; public set; }
    public int MaxTraceCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxTraceCloudRoleNameValuesToDiscover { get; public set; }
    public int MaxRequestCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxRequestCloudRoleNameValuesToDiscover { get; public set; }
    public int MaxRequestResponseCodeValuesToDiscover { get; public set; }
    public AutocollectedMetricsExtractor(ITelemetryProcessor nextProcessorInPipeline);
    public int get_MaxDependencyTypesToDiscover();
    public void set_MaxDependencyTypesToDiscover(int value);
    public int get_MaxDependencyResultCodesToDiscover();
    public void set_MaxDependencyResultCodesToDiscover(int value);
    public int get_MaxDependencyTargetValuesToDiscover();
    public void set_MaxDependencyTargetValuesToDiscover(int value);
    public int get_MaxDependencyCloudRoleInstanceValuesToDiscover();
    public void set_MaxDependencyCloudRoleInstanceValuesToDiscover(int value);
    public int get_MaxDependencyCloudRoleNameValuesToDiscover();
    public void set_MaxDependencyCloudRoleNameValuesToDiscover(int value);
    public int get_MaxExceptionCloudRoleInstanceValuesToDiscover();
    public void set_MaxExceptionCloudRoleInstanceValuesToDiscover(int value);
    public int get_MaxExceptionCloudRoleNameValuesToDiscover();
    public void set_MaxExceptionCloudRoleNameValuesToDiscover(int value);
    public int get_MaxTraceCloudRoleInstanceValuesToDiscover();
    public void set_MaxTraceCloudRoleInstanceValuesToDiscover(int value);
    public int get_MaxTraceCloudRoleNameValuesToDiscover();
    public void set_MaxTraceCloudRoleNameValuesToDiscover(int value);
    public int get_MaxRequestCloudRoleInstanceValuesToDiscover();
    public void set_MaxRequestCloudRoleInstanceValuesToDiscover(int value);
    public int get_MaxRequestCloudRoleNameValuesToDiscover();
    public void set_MaxRequestCloudRoleNameValuesToDiscover(int value);
    public int get_MaxRequestResponseCodeValuesToDiscover();
    public void set_MaxRequestResponseCodeValuesToDiscover(int value);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public sealed virtual void Process(ITelemetry item);
    public sealed virtual void Dispose();
    private static string GetExtractorInfo(ISpecificAutocollectedMetricsExtractor extractor);
    private static void AddExtractorInfo(ITelemetry item, string extractorInfo);
    private static string ExtractionPipelineInfo(string extractionPipelineInfo, string extractorInfo);
    private void InitializeExtractors(TelemetryClient metricsClient);
    private void ExtractMetrics(ITelemetry fromItem);
    private bool EnsureItemNotSampled(ISupportSampling item);
    private void InvokeNextProcessor(ITelemetry item);
}
public interface Microsoft.ApplicationInsights.Extensibility.IApplicationIdProvider {
    public abstract virtual bool TryGetApplicationId(string instrumentationKey, String& applicationId);
}
internal interface Microsoft.ApplicationInsights.Extensibility.IDebugOutput {
    public abstract virtual void WriteLine(string message);
    public abstract virtual bool IsLogging();
    public abstract virtual bool IsAttached();
}
internal interface Microsoft.ApplicationInsights.Extensibility.IDimensionExtractor {
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    public abstract virtual int get_MaxValues();
    public abstract virtual void set_MaxValues(int value);
    public abstract virtual string get_DefaultValue();
    public abstract virtual void set_DefaultValue(string value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string ExtractDimension(ITelemetry item);
}
public interface Microsoft.ApplicationInsights.Extensibility.IExtension {
    public abstract virtual IExtension DeepClone();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.ApplicationIdHelper : object {
    private static string Format;
    private static int ApplicationIdMaxLength;
    internal static string ApplyFormatting(string applicationId);
    internal static string SanitizeString(string input);
    private static string EnforceMaxLength(string input, int maxLength);
    private static bool IsCharHeaderSafe(char ch);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.ApplicationInsightsApplicationIdProvider : object {
    internal ConcurrentDictionary`2<string, bool> FetchTasks;
    private static int MAXSIZE;
    private ProfileServiceWrapper applicationIdProvider;
    private ConcurrentDictionary`2<string, string> knownApplicationIds;
    public string ProfileQueryEndpoint { get; public set; }
    internal ApplicationInsightsApplicationIdProvider(ProfileServiceWrapper profileServiceWrapper);
    public string get_ProfileQueryEndpoint();
    public void set_ProfileQueryEndpoint(string value);
    public sealed virtual void Dispose();
    public sealed virtual bool TryGetApplicationId(string instrumentationKey, String& applicationId);
    internal bool IsFetchAppInProgress(string instrumentationKey);
    private void FetchApplicationId(string instrumentationKey);
    private void FormatAndAddToDictionary(string instrumentationKey, string applicationId);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.DictionaryApplicationIdProvider : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Defined>k__BackingField;
    [CompilerGeneratedAttribute]
private IApplicationIdProvider <Next>k__BackingField;
    public IReadOnlyDictionary`2<string, string> Defined { get; public set; }
    public IApplicationIdProvider Next { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Defined();
    [CompilerGeneratedAttribute]
public void set_Defined(IReadOnlyDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IApplicationIdProvider get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(IApplicationIdProvider value);
    public sealed virtual bool TryGetApplicationId(string instrumentationKey, String& applicationId);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.FailedRequestsManager : object {
    private static int DefaultRetryWaitTimeSeconds;
    private TimeSpan retryWaitTime;
    private ConcurrentDictionary`2<string, FailedResult> failingInstrumentationKeys;
    internal FailedRequestsManager(TimeSpan retryWaitTime);
    public void RegisterFetchFailure(string instrumentationKey, HttpStatusCode httpStatusCode);
    public void RegisterFetchFailure(string instrumentationKey, Exception ex);
    public bool CanRetry(string instrumentationKey);
    private static string GetExceptionDetailString(Exception ex);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.ProfileServiceWrapper : object {
    internal FailedRequestsManager FailedRequestsManager;
    private HttpClient httpClient;
    [CompilerGeneratedAttribute]
private string <ProfileQueryEndpoint>k__BackingField;
    public string ProfileQueryEndpoint { get; public set; }
    internal ProfileServiceWrapper(TimeSpan failedRequestRetryWaitTime);
    [CompilerGeneratedAttribute]
public string get_ProfileQueryEndpoint();
    [CompilerGeneratedAttribute]
public void set_ProfileQueryEndpoint(string value);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.ProfileServiceWrapper/<FetchApplicationIdAsync>d__8")]
public Task`1<string> FetchApplicationIdAsync(string instrumentationKey);
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    internal virtual Task`1<HttpResponseMessage> GetAsync(string instrumentationKey);
    internal Uri GetApplicationIdEndPointUri(string instrumentationKey);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.ApplicationId.ProfileServiceWrapper/<SendRequestAsync>d__13")]
private Task`1<string> SendRequestAsync(string instrumentationKey);
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.AuthConstants : object {
    public static string AuthorizationHeaderName;
    public static string AuthorizationTokenPrefix;
    private static string AzureMonitorScope;
    public static String[] GetScopes();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.AuthToken : ValueType {
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    public string Token { get; public set; }
    public DateTimeOffset ExpiresOn { get; public set; }
    public AuthToken(string token, DateTimeOffset expiresOn);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(DateTimeOffset value);
    public static bool op_Equality(AuthToken left, AuthToken right);
    public static bool op_Inequality(AuthToken left, AuthToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AuthToken other);
}
internal abstract class Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.CredentialEnvelope : object {
    internal object Credential { get; }
    internal abstract virtual object get_Credential();
    public abstract virtual AuthToken GetToken(CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthToken> GetTokenAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope {
    public CredentialEnvelope CredentialEnvelope { get; public set; }
    public abstract virtual CredentialEnvelope get_CredentialEnvelope();
    public abstract virtual void set_CredentialEnvelope(CredentialEnvelope value);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ReflectionCredentialEnvelope : CredentialEnvelope {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) azureCoreAssemblyName;
    private object tokenCredential;
    private object tokenRequestContext;
    internal object Credential { get; }
    public ReflectionCredentialEnvelope(object tokenCredential);
    private static ReflectionCredentialEnvelope();
    internal virtual object get_Credential();
    public virtual AuthToken GetToken(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ReflectionCredentialEnvelope/<GetTokenAsync>d__7")]
public virtual Task`1<AuthToken> GetTokenAsync(CancellationToken cancellationToken);
    private static bool IsValidType(object inputTokenCredential);
    private static Type GetTokenCredentialType();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.CallContextHelpers : object {
    private static string FieldKey;
    private static CallContextHelpers();
    internal static void SaveOperationContext(OperationContextForCallContext operationContext);
    internal static OperationContextForCallContext GetCurrentOperationContext();
    internal static void RestoreOperationContext(OperationContextForCallContext parentContext);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.CloudContext : object {
    private string roleName;
    private string roleInstance;
    public string RoleName { get; public set; }
    public string RoleInstance { get; public set; }
    public string get_RoleName();
    public void set_RoleName(string value);
    public string get_RoleInstance();
    public void set_RoleInstance(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(CloudContext target);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.ComponentContext : object {
    private string version;
    public string Version { get; public set; }
    public string get_Version();
    public void set_Version(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(ComponentContext target);
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.ConfigString.ConfigStringParser : object {
    private static Char[] SplitSemicolon;
    private static ConfigStringParser();
    public static IDictionary`2<string, string> Parse(string configString);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.DeviceContext : object {
    private IDictionary`2<string, string> properties;
    private string type;
    private string id;
    private string operatingSystem;
    private string oemName;
    private string model;
    public string Type { get; public set; }
    public string Id { get; public set; }
    public string OperatingSystem { get; public set; }
    public string OemName { get; public set; }
    public string Model { get; public set; }
    [ObsoleteAttribute("Use custom properties.")]
public string NetworkType { get; public set; }
    [ObsoleteAttribute("Use custom properties.")]
public string ScreenResolution { get; public set; }
    [ObsoleteAttribute("Use custom properties.")]
public string Language { get; public set; }
    internal DeviceContext(IDictionary`2<string, string> properties);
    public string get_Type();
    public void set_Type(string value);
    public string get_Id();
    public void set_Id(string value);
    public string get_OperatingSystem();
    public void set_OperatingSystem(string value);
    public string get_OemName();
    public void set_OemName(string value);
    public string get_Model();
    public void set_Model(string value);
    public string get_NetworkType();
    public void set_NetworkType(string value);
    public string get_ScreenResolution();
    public void set_ScreenResolution(string value);
    public string get_Language();
    public void set_Language(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(DeviceContext target);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.DictionarySerializationWriter : object {
    internal static string DefaultKey;
    internal static string DefaultObjectKey;
    private Stack`1<string> lastPrefix;
    private Stack`1<long> lastIndex;
    private string currentPrefix;
    private long currentIndex;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AccumulatedDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, double> <AccumulatedMeasurements>k__BackingField;
    internal Dictionary`2<string, string> AccumulatedDictionary { get; }
    internal Dictionary`2<string, double> AccumulatedMeasurements { get; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_AccumulatedDictionary();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, double> get_AccumulatedMeasurements();
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteProperty(string name, Nullable`1<double> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<int> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<bool> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public sealed virtual void WriteProperty(string name, ISerializableWithWriter value);
    public sealed virtual void WriteProperty(ISerializableWithWriter value);
    public sealed virtual void WriteProperty(string name, IList`1<string> items);
    public sealed virtual void WriteProperty(string name, IList`1<ISerializableWithWriter> items);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, string> items);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, double> items);
    public sealed virtual void WriteStartObject(string name);
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteEndObject();
    private string GetKey(string fieldName);
    private string GenerateSequencialPrefix();
    private string GenerateSequencialPrefixForObject();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.Constants : object {
    internal static string DefaultIngestionEndpoint;
    internal static string DefaultLiveMetricsEndpoint;
    internal static string DefaultProfilerEndpoint;
    internal static string DefaultSnapshotEndpoint;
    internal static string IngestionPrefix;
    internal static string LiveMetricsPrefix;
    internal static string ProfilerPrefix;
    internal static string SnapshotPrefix;
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.EndpointContainer : object {
    [CompilerGeneratedAttribute]
private Uri <Ingestion>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Live>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Snapshot>k__BackingField;
    public Uri Ingestion { get; private set; }
    public Uri Live { get; private set; }
    public Uri Profiler { get; private set; }
    public Uri Snapshot { get; private set; }
    internal string FormattedIngestionEndpoint { get; }
    internal string FormattedIngestionAADEndpoint { get; }
    internal string FormattedApplicationIdEndpoint { get; }
    internal EndpointContainer(IEndpointProvider endpointProvider);
    [CompilerGeneratedAttribute]
public Uri get_Ingestion();
    [CompilerGeneratedAttribute]
private void set_Ingestion(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Live();
    [CompilerGeneratedAttribute]
private void set_Live(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Profiler();
    [CompilerGeneratedAttribute]
private void set_Profiler(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Snapshot();
    [CompilerGeneratedAttribute]
private void set_Snapshot(Uri value);
    internal string get_FormattedIngestionEndpoint();
    internal string get_FormattedIngestionAADEndpoint();
    internal string get_FormattedApplicationIdEndpoint();
    internal string GetFormattedIngestionEndpoint(bool enableAAD);
}
[AttributeUsageAttribute("256")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.EndpointMetaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ExplicitName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    public string ExplicitName { get; public set; }
    public string EndpointPrefix { get; public set; }
    public string Default { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExplicitName();
    [CompilerGeneratedAttribute]
public void set_ExplicitName(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointPrefix();
    [CompilerGeneratedAttribute]
public void set_EndpointPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    public static EndpointMetaAttribute GetAttribute(EndpointName enumValue);
}
internal enum Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.EndpointName : Enum {
    public int value__;
    [EndpointMetaAttribute]
public static EndpointName Ingestion;
    [EndpointMetaAttribute]
public static EndpointName Live;
    [EndpointMetaAttribute]
public static EndpointName Profiler;
    [EndpointMetaAttribute]
public static EndpointName Snapshot;
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.EndpointProvider : object {
    internal static int ConnectionStringMaxLength;
    private static Char[] TrimPeriod;
    private string connectionString;
    private IDictionary`2<string, string> connectionStringParsed;
    public string ConnectionString { get; public set; }
    private static EndpointProvider();
    public sealed virtual string get_ConnectionString();
    public sealed virtual void set_ConnectionString(string value);
    public sealed virtual Uri GetEndpoint(EndpointName endpointName);
    public sealed virtual string GetInstrumentationKey();
    internal static IDictionary`2<string, string> ParseConnectionString(string connectionString);
    internal static bool TryBuildUri(string prefix, string suffix, Uri& uri, string location);
    private string GetLocation();
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Endpoints.IEndpointProvider {
    public string ConnectionString { get; public set; }
    public abstract virtual string get_ConnectionString();
    public abstract virtual void set_ConnectionString(string value);
    public abstract virtual Uri GetEndpoint(EndpointName endpointName);
    public abstract virtual string GetInstrumentationKey();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.ExceptionConverter : object {
    public static int MaxParsedStackLength;
    public static int MaxExceptionMessageLength;
    internal static ExceptionDetails ConvertToExceptionDetails(Exception exception, ExceptionDetails parentExceptionDetails);
    internal static StackFrame GetStackFrame(StackFrame stackFrame, int frameId);
    internal static int GetStackFrameLength(StackFrame stackFrame);
    private static Tuple`2<List`1<TOutput>, bool> SanitizeStackFrame(IList`1<TInput> inputList, Func`3<TInput, int, TOutput> converter, Func`2<TOutput, int> lengthGetter);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.Experimental.ExperimentalFeaturesExtension : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool EvaluateExperimentalFeature(TelemetryConfiguration telemetryConfiguration, string featureName);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.AvailabilityData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <runLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    private IDictionary`2<string, double> measurementsInternal;
    public int ver { get; public set; }
    public string id { get; public set; }
    public string name { get; public set; }
    public TimeSpan duration { get; public set; }
    public bool success { get; public set; }
    public string runLocation { get; public set; }
    public string message { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected AvailabilityData(string fullName, string name);
    public AvailabilityData DeepClone();
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
    [CompilerGeneratedAttribute]
public string get_runLocation();
    [CompilerGeneratedAttribute]
public void set_runLocation(string value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, double> get_measurements();
    public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.Base : object {
    [CompilerGeneratedAttribute]
private string <baseType>k__BackingField;
    public string baseType { get; public set; }
    protected Base(string fullName, string name);
    [CompilerGeneratedAttribute]
public string get_baseType();
    [CompilerGeneratedAttribute]
public void set_baseType(string value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.ContextTagKeys : object {
    private static ContextTagKeys keys;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceLocale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOEMName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceOSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationCountry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationProvince>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationCity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationSyntheticSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationCorrelationVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionIsFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAuthUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudRole>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudRoleInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalSdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalAgentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalNodeName>k__BackingField;
    internal static ContextTagKeys Keys { get; }
    public string ApplicationVersion { get; public set; }
    public string DeviceId { get; public set; }
    public string DeviceLocale { get; public set; }
    public string DeviceModel { get; public set; }
    public string DeviceOEMName { get; public set; }
    public string DeviceOSVersion { get; public set; }
    public string DeviceType { get; public set; }
    public string LocationIp { get; public set; }
    public string LocationCountry { get; public set; }
    public string LocationProvince { get; public set; }
    public string LocationCity { get; public set; }
    public string OperationId { get; public set; }
    public string OperationName { get; public set; }
    public string OperationParentId { get; public set; }
    public string OperationSyntheticSource { get; public set; }
    public string OperationCorrelationVector { get; public set; }
    public string SessionId { get; public set; }
    public string SessionIsFirst { get; public set; }
    public string UserAccountId { get; public set; }
    public string UserId { get; public set; }
    public string UserAuthUserId { get; public set; }
    public string CloudRole { get; public set; }
    public string CloudRoleInstance { get; public set; }
    public string InternalSdkVersion { get; public set; }
    public string InternalAgentVersion { get; public set; }
    public string InternalNodeName { get; public set; }
    protected ContextTagKeys(string fullName, string name);
    internal static ContextTagKeys get_Keys();
    [CompilerGeneratedAttribute]
public string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public void set_DeviceId(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceLocale();
    [CompilerGeneratedAttribute]
public void set_DeviceLocale(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceModel();
    [CompilerGeneratedAttribute]
public void set_DeviceModel(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOEMName();
    [CompilerGeneratedAttribute]
public void set_DeviceOEMName(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceOSVersion();
    [CompilerGeneratedAttribute]
public void set_DeviceOSVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceType();
    [CompilerGeneratedAttribute]
public void set_DeviceType(string value);
    [CompilerGeneratedAttribute]
public string get_LocationIp();
    [CompilerGeneratedAttribute]
public void set_LocationIp(string value);
    [CompilerGeneratedAttribute]
public string get_LocationCountry();
    [CompilerGeneratedAttribute]
public void set_LocationCountry(string value);
    [CompilerGeneratedAttribute]
public string get_LocationProvince();
    [CompilerGeneratedAttribute]
public void set_LocationProvince(string value);
    [CompilerGeneratedAttribute]
public string get_LocationCity();
    [CompilerGeneratedAttribute]
public void set_LocationCity(string value);
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public void set_OperationName(string value);
    [CompilerGeneratedAttribute]
public string get_OperationParentId();
    [CompilerGeneratedAttribute]
public void set_OperationParentId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationSyntheticSource();
    [CompilerGeneratedAttribute]
public void set_OperationSyntheticSource(string value);
    [CompilerGeneratedAttribute]
public string get_OperationCorrelationVector();
    [CompilerGeneratedAttribute]
public void set_OperationCorrelationVector(string value);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_SessionIsFirst();
    [CompilerGeneratedAttribute]
public void set_SessionIsFirst(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccountId();
    [CompilerGeneratedAttribute]
public void set_UserAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_UserAuthUserId();
    [CompilerGeneratedAttribute]
public void set_UserAuthUserId(string value);
    [CompilerGeneratedAttribute]
public string get_CloudRole();
    [CompilerGeneratedAttribute]
public void set_CloudRole(string value);
    [CompilerGeneratedAttribute]
public string get_CloudRoleInstance();
    [CompilerGeneratedAttribute]
public void set_CloudRoleInstance(string value);
    [CompilerGeneratedAttribute]
public string get_InternalSdkVersion();
    [CompilerGeneratedAttribute]
public void set_InternalSdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_InternalAgentVersion();
    [CompilerGeneratedAttribute]
public void set_InternalAgentVersion(string value);
    [CompilerGeneratedAttribute]
public string get_InternalNodeName();
    [CompilerGeneratedAttribute]
public void set_InternalNodeName(string value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.Data`1 : Base {
    [CompilerGeneratedAttribute]
private TDomain <baseData>k__BackingField;
    public TDomain baseData { get; public set; }
    protected Data`1(string fullName, string name);
    [CompilerGeneratedAttribute]
public TDomain get_baseData();
    [CompilerGeneratedAttribute]
public void set_baseData(TDomain value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.DataPoint : object {
    [CompilerGeneratedAttribute]
private string <ns>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPointType <kind>k__BackingField;
    [CompilerGeneratedAttribute]
private double <value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <stdDev>k__BackingField;
    public string ns { get; public set; }
    public string name { get; public set; }
    public DataPointType kind { get; public set; }
    public double value { get; public set; }
    public Nullable`1<int> count { get; public set; }
    public Nullable`1<double> min { get; public set; }
    public Nullable`1<double> max { get; public set; }
    public Nullable`1<double> stdDev { get; public set; }
    protected DataPoint(string fullName, string name);
    public DataPoint DeepClone();
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public string get_ns();
    [CompilerGeneratedAttribute]
public void set_ns(string value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public DataPointType get_kind();
    [CompilerGeneratedAttribute]
public void set_kind(DataPointType value);
    [CompilerGeneratedAttribute]
public double get_value();
    [CompilerGeneratedAttribute]
public void set_value(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_count();
    [CompilerGeneratedAttribute]
public void set_count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_min();
    [CompilerGeneratedAttribute]
public void set_min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_max();
    [CompilerGeneratedAttribute]
public void set_max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_stdDev();
    [CompilerGeneratedAttribute]
public void set_stdDev(Nullable`1<double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal enum Microsoft.ApplicationInsights.Extensibility.Implementation.External.DataPointType : Enum {
    public int value__;
    public static DataPointType Measurement;
    public static DataPointType Aggregation;
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.Domain : object {
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.Envelope : object {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <time>k__BackingField;
    [CompilerGeneratedAttribute]
private double <sampleRate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <seq>k__BackingField;
    [CompilerGeneratedAttribute]
private string <iKey>k__BackingField;
    [CompilerGeneratedAttribute]
private long <flags>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Base <data>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public string time { get; public set; }
    public double sampleRate { get; public set; }
    public string seq { get; public set; }
    public string iKey { get; public set; }
    public long flags { get; public set; }
    public IDictionary`2<string, string> tags { get; public set; }
    public Base data { get; public set; }
    protected Envelope(string fullName, string name);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_time();
    [CompilerGeneratedAttribute]
public void set_time(string value);
    [CompilerGeneratedAttribute]
public double get_sampleRate();
    [CompilerGeneratedAttribute]
public void set_sampleRate(double value);
    [CompilerGeneratedAttribute]
public string get_seq();
    [CompilerGeneratedAttribute]
public void set_seq(string value);
    [CompilerGeneratedAttribute]
public string get_iKey();
    [CompilerGeneratedAttribute]
public void set_iKey(string value);
    [CompilerGeneratedAttribute]
public long get_flags();
    [CompilerGeneratedAttribute]
public void set_flags(long value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_tags();
    [CompilerGeneratedAttribute]
public void set_tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Base get_data();
    [CompilerGeneratedAttribute]
public void set_data(Base value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.EventData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    private IDictionary`2<string, double> measurementsInternal;
    public int ver { get; public set; }
    public string name { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected EventData(string fullName, string name);
    public EventData DeepClone();
    protected virtual void ApplyProperties(EventData other);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, double> get_measurements();
    public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.ExceptionData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExceptionDetails> <exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <problemId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    private IDictionary`2<string, double> measurementsInternal;
    public int ver { get; public set; }
    public IList`1<ExceptionDetails> exceptions { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public string problemId { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected ExceptionData(string fullName, string name);
    public ExceptionData DeepClone();
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public IList`1<ExceptionDetails> get_exceptions();
    [CompilerGeneratedAttribute]
public void set_exceptions(IList`1<ExceptionDetails> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public string get_problemId();
    [CompilerGeneratedAttribute]
public void set_problemId(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, double> get_measurements();
    public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.ExceptionDetails : object {
    [CompilerGeneratedAttribute]
private int <id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <outerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <typeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <hasFullStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <stack>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<StackFrame> <parsedStack>k__BackingField;
    public int id { get; public set; }
    public int outerId { get; public set; }
    public string typeName { get; public set; }
    public string message { get; public set; }
    public bool hasFullStack { get; public set; }
    public string stack { get; public set; }
    public IList`1<StackFrame> parsedStack { get; public set; }
    protected ExceptionDetails(string fullName, string name);
    internal static ExceptionDetails CreateWithoutStackInfo(Exception exception, ExceptionDetails parentExceptionDetails);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_id();
    [CompilerGeneratedAttribute]
public void set_id(int value);
    [CompilerGeneratedAttribute]
public int get_outerId();
    [CompilerGeneratedAttribute]
public void set_outerId(int value);
    [CompilerGeneratedAttribute]
public string get_typeName();
    [CompilerGeneratedAttribute]
public void set_typeName(string value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public bool get_hasFullStack();
    [CompilerGeneratedAttribute]
public void set_hasFullStack(bool value);
    [CompilerGeneratedAttribute]
public string get_stack();
    [CompilerGeneratedAttribute]
public void set_stack(string value);
    [CompilerGeneratedAttribute]
public IList`1<StackFrame> get_parsedStack();
    [CompilerGeneratedAttribute]
public void set_parsedStack(IList`1<StackFrame> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.MessageData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SeverityLevel> <severityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    private IDictionary`2<string, double> measurementsInternal;
    public int ver { get; public set; }
    public string message { get; public set; }
    public Nullable`1<SeverityLevel> severityLevel { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected MessageData(string fullName, string name);
    public MessageData DeepClone();
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SeverityLevel> get_severityLevel();
    [CompilerGeneratedAttribute]
public void set_severityLevel(Nullable`1<SeverityLevel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    public IDictionary`2<string, double> get_measurements();
    public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.MetricData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DataPoint> <metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    public int ver { get; public set; }
    public IList`1<DataPoint> metrics { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    protected MetricData(string fullName, string name);
    public MetricData DeepClone();
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public IList`1<DataPoint> get_metrics();
    [CompilerGeneratedAttribute]
public void set_metrics(IList`1<DataPoint> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.PageViewData : EventData {
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    public string url { get; public set; }
    public string duration { get; public set; }
    public string id { get; public set; }
    protected PageViewData(string fullName, string name);
    public PageViewData DeepClone();
    protected virtual void ApplyProperties(EventData other);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public string get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(string value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.PageViewPerfData : PageViewData {
    [CompilerGeneratedAttribute]
private string <perfTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <networkConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private string <sentRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <receivedResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <domProcessing>k__BackingField;
    public string perfTotal { get; public set; }
    public string networkConnect { get; public set; }
    public string sentRequest { get; public set; }
    public string receivedResponse { get; public set; }
    public string domProcessing { get; public set; }
    protected PageViewPerfData(string fullName, string name);
    public PageViewPerfData DeepClone();
    protected virtual void ApplyProperties(EventData other);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public string get_perfTotal();
    [CompilerGeneratedAttribute]
public void set_perfTotal(string value);
    [CompilerGeneratedAttribute]
public string get_networkConnect();
    [CompilerGeneratedAttribute]
public void set_networkConnect(string value);
    [CompilerGeneratedAttribute]
public string get_sentRequest();
    [CompilerGeneratedAttribute]
public void set_sentRequest(string value);
    [CompilerGeneratedAttribute]
public string get_receivedResponse();
    [CompilerGeneratedAttribute]
public void set_receivedResponse(string value);
    [CompilerGeneratedAttribute]
public string get_domProcessing();
    [CompilerGeneratedAttribute]
public void set_domProcessing(string value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.RemoteDependencyData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <resultCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <type>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string name { get; public set; }
    public string id { get; public set; }
    public string resultCode { get; public set; }
    public TimeSpan duration { get; public set; }
    public bool success { get; public set; }
    public string data { get; public set; }
    public string target { get; public set; }
    public string type { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected RemoteDependencyData(string fullName, string name);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_resultCode();
    [CompilerGeneratedAttribute]
public void set_resultCode(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
    [CompilerGeneratedAttribute]
public string get_data();
    [CompilerGeneratedAttribute]
public void set_data(string value);
    [CompilerGeneratedAttribute]
public string get_target();
    [CompilerGeneratedAttribute]
public void set_target(string value);
    [CompilerGeneratedAttribute]
public string get_type();
    [CompilerGeneratedAttribute]
public void set_type(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.RequestData : Domain {
    [CompilerGeneratedAttribute]
private int <ver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <responseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <url>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <measurements>k__BackingField;
    public int ver { get; public set; }
    public string id { get; public set; }
    public string source { get; public set; }
    public string name { get; public set; }
    public TimeSpan duration { get; public set; }
    public string responseCode { get; public set; }
    public bool success { get; public set; }
    public string url { get; public set; }
    public IDictionary`2<string, string> properties { get; public set; }
    public IDictionary`2<string, double> measurements { get; public set; }
    protected RequestData(string fullName, string name);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_ver();
    [CompilerGeneratedAttribute]
public void set_ver(int value);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_source();
    [CompilerGeneratedAttribute]
public void set_source(string value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_duration();
    [CompilerGeneratedAttribute]
public void set_duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_responseCode();
    [CompilerGeneratedAttribute]
public void set_responseCode(string value);
    [CompilerGeneratedAttribute]
public bool get_success();
    [CompilerGeneratedAttribute]
public void set_success(bool value);
    [CompilerGeneratedAttribute]
public string get_url();
    [CompilerGeneratedAttribute]
public void set_url(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_properties();
    [CompilerGeneratedAttribute]
public void set_properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_measurements();
    [CompilerGeneratedAttribute]
public void set_measurements(IDictionary`2<string, double> value);
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal enum Microsoft.ApplicationInsights.Extensibility.Implementation.External.SeverityLevel : Enum {
    public int value__;
    public static SeverityLevel Verbose;
    public static SeverityLevel Information;
    public static SeverityLevel Warning;
    public static SeverityLevel Error;
    public static SeverityLevel Critical;
}
[GeneratedCodeAttribute("gbc", "0.4.1.0")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.External.StackFrame : object {
    [CompilerGeneratedAttribute]
private int <level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <fileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <line>k__BackingField;
    public int level { get; public set; }
    public string method { get; public set; }
    public string assembly { get; public set; }
    public string fileName { get; public set; }
    public int line { get; public set; }
    protected StackFrame(string fullName, string name);
    public sealed virtual void Serialize(ISerializationWriter serializationWriter);
    [CompilerGeneratedAttribute]
public int get_level();
    [CompilerGeneratedAttribute]
public void set_level(int value);
    [CompilerGeneratedAttribute]
public string get_method();
    [CompilerGeneratedAttribute]
public void set_method(string value);
    [CompilerGeneratedAttribute]
public string get_assembly();
    [CompilerGeneratedAttribute]
public void set_assembly(string value);
    [CompilerGeneratedAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
public void set_fileName(string value);
    [CompilerGeneratedAttribute]
public int get_line();
    [CompilerGeneratedAttribute]
public void set_line(int value);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.External.Tags : object {
    [ExtensionAttribute]
internal static void SetStringValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
    [ExtensionAttribute]
internal static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, T tagValue);
    internal static void CopyTagValue(Nullable`1<bool> sourceValue, Nullable`1& targetValue);
    [ExtensionAttribute]
internal static string GetTagValueOrNull(IDictionary`2<string, string> tags, string tagKey);
    [ExtensionAttribute]
internal static void UpdateTagValue(IDictionary`2<string, string> tags, string tagKey, string tagValue);
    internal static void CopyTagValue(string sourceValue, String& targetValue);
    [ExtensionAttribute]
internal static void UpdateTagValue(IDictionary`2<string, string> tags, string tagKey, Nullable`1<bool> tagValue);
    [ExtensionAttribute]
private static void SetTagValueOrRemove(IDictionary`2<string, string> tags, string tagKey, string tagValue);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.HttpWebResponseWrapper : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RetryAfterHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    public string Content { get; public set; }
    public int StatusCode { get; public set; }
    public string RetryAfterHeader { get; public set; }
    public string StatusDescription { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_RetryAfterHeader();
    [CompilerGeneratedAttribute]
public void set_RetryAfterHeader(string value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
public void set_StatusDescription(string value);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.InternalContext : object {
    private string sdkVersion;
    private string agentVersion;
    private string nodeName;
    public string SdkVersion { get; public set; }
    public string AgentVersion { get; public set; }
    public string NodeName { get; public set; }
    public string get_SdkVersion();
    public void set_SdkVersion(string value);
    public string get_AgentVersion();
    public void set_AgentVersion(string value);
    public string get_NodeName();
    public void set_NodeName(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(InternalContext target);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.IPlatform {
    public abstract virtual string ReadConfigurationXml();
    public abstract virtual IDebugOutput GetDebugOutput();
    public abstract virtual bool TryGetEnvironmentVariable(string name, String& value);
    public abstract virtual string GetMachineName();
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.IPlatformDispatcher {
    public abstract virtual Task RunAsync(Action action);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.IRandomNumberBatchGenerator {
    public abstract virtual void NextBatch(UInt64[] buffer, int index, int count);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.JsonSerializationWriter : object {
    private TextWriter textWriter;
    private bool currentObjectHasProperties;
    public JsonSerializationWriter(TextWriter textWriter);
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteStartObject(string name);
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteProperty(string name, Nullable`1<int> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<bool> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<double> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public sealed virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public sealed virtual void WriteProperty(string name, IList`1<string> items);
    public sealed virtual void WriteProperty(string name, IList`1<ISerializableWithWriter> items);
    public sealed virtual void WriteProperty(string name, ISerializableWithWriter value);
    public sealed virtual void WriteProperty(ISerializableWithWriter value);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, double> values);
    public sealed virtual void WriteProperty(string name, IDictionary`2<string, string> values);
    public sealed virtual void WriteEndObject();
    internal void WritePropertyName(string name);
    internal void WriteStartArray();
    internal void WriteEndArray();
    internal void WriteComma();
    internal void WriteRawValue(object value);
    internal void WriteString(string value);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.JsonSerializer : object {
    private static UTF8Encoding TransmissionEncoding;
    public static string CompressionType { get; }
    public static string ContentType { get; }
    private static JsonSerializer();
    public static string get_CompressionType();
    public static string get_ContentType();
    public static Byte[] Serialize(IEnumerable`1<ITelemetry> telemetryItems, bool compress);
    public static Byte[] ConvertToByteArray(string telemetryItems, bool compress);
    public static string Deserialize(Byte[] telemetryItemsData, bool compress);
    internal static Byte[] Serialize(ITelemetry telemetryItem, bool compress);
    internal static string SerializeAsString(IEnumerable`1<ITelemetry> telemetryItems);
    internal static string SerializeAsString(ITelemetry telemetry);
    private static Stream CreateCompressedStream(Stream stream);
    private static void SerializeTelemetryItem(ITelemetry telemetryItem, JsonSerializationWriter jsonSerializationWriter);
    private static void SerializeHelper(ITelemetry telemetryItem, JsonSerializationWriter jsonSerializationWriter, string baseType, string telemetryName);
    private static void SerializeUnknownTelemetryHelper(ITelemetry telemetryItem, JsonSerializationWriter jsonSerializationWriter);
    private static void SerializeToStream(IEnumerable`1<ITelemetry> telemetryItems, TextWriter streamWriter);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.LocationContext : object {
    private string ip;
    public string Ip { get; public set; }
    public string get_Ip();
    public void set_Ip(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(LocationContext target);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.CloudRoleInstanceDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.CloudRoleNameDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.CommonHelper : object {
    public static void TrackValueHelper(Metric metricToTrack, double metricValue, String[] dimValues);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DependencyDurationBucketExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DependencyMetricIdDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DependencyMetricsExtractor : object {
    public static int MaxDependencyTypesToDiscoverDefault;
    public static int MaxTargetValuesToDiscoverDefault;
    public static int MaxDependencyResultCodesToDiscoverDefault;
    public static int MaxCloudRoleInstanceValuesToDiscoverDefault;
    public static int MaxCloudRoleNameValuesToDiscoverDefault;
    private object lockObject;
    private List`1<IDimensionExtractor> dimensionExtractors;
    private Metric dependencyCallDurationMetric;
    private bool isInitialized;
    [CompilerGeneratedAttribute]
private string <ExtractorName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtractorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDependencyTypesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDependencyResultCodesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDependencyTargetValuesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleInstanceValuesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleNameValuesToDiscover>k__BackingField;
    public string ExtractorName { get; }
    public string ExtractorVersion { get; }
    public int MaxDependencyTypesToDiscover { get; public set; }
    public int MaxDependencyResultCodesToDiscover { get; public set; }
    public int MaxDependencyTargetValuesToDiscover { get; public set; }
    public int MaxCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxCloudRoleNameValuesToDiscover { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorVersion();
    [CompilerGeneratedAttribute]
public int get_MaxDependencyTypesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxDependencyTypesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDependencyResultCodesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxDependencyResultCodesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDependencyTargetValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxDependencyTargetValuesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleInstanceValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleInstanceValuesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleNameValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleNameValuesToDiscover(int value);
    public sealed virtual void InitializeExtractor(TelemetryClient metricTelemetryClient);
    public sealed virtual void ExtractMetrics(ITelemetry fromItem, Boolean& isItemProcessed);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DependencyResultCodeDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DurationBucketExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.DurationBucketizer : object {
    private static Tuple`2[] perfBuckets;
    private static DurationBucketizer();
    public static string GetPerformanceBucket(TimeSpan duration);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.ExceptionMetricIdDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.ExceptionMetricsExtractor : object {
    public static int MaxCloudRoleInstanceValuesToDiscoverDefault;
    public static int MaxCloudRoleNameValuesToDiscoverDefault;
    private object lockObject;
    private Metric exceptionServerMetric;
    private bool isInitialized;
    private List`1<IDimensionExtractor> dimensionExtractors;
    [CompilerGeneratedAttribute]
private string <ExtractorName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtractorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleInstanceValuesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleNameValuesToDiscover>k__BackingField;
    public string ExtractorName { get; }
    public string ExtractorVersion { get; }
    public int MaxCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxCloudRoleNameValuesToDiscover { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorVersion();
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleInstanceValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleInstanceValuesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleNameValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleNameValuesToDiscover(int value);
    public sealed virtual void InitializeExtractor(TelemetryClient metricTelemetryClient);
    public sealed virtual void ExtractMetrics(ITelemetry fromItem, Boolean& isItemProcessed);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.ISpecificAutocollectedMetricsExtractor {
    public string ExtractorName { get; }
    public string ExtractorVersion { get; }
    public abstract virtual string get_ExtractorName();
    public abstract virtual string get_ExtractorVersion();
    public abstract virtual void InitializeExtractor(TelemetryClient metricTelemetryClient);
    public abstract virtual void ExtractMetrics(ITelemetry fromItem, Boolean& isItemProcessed);
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.MetricTerms : object {
    private static string MetricPropertiesNamePrefix;
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.RequestMetricIdDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.RequestMetricsExtractor : object {
    public static int MaxResponseCodeToDiscoverDefault;
    public static int MaxCloudRoleInstanceValuesToDiscoverDefault;
    public static int MaxCloudRoleNameValuesToDiscoverDefault;
    private object lockObject;
    private Metric requestDurationMetric;
    private bool isInitialized;
    private List`1<IDimensionExtractor> dimensionExtractors;
    [CompilerGeneratedAttribute]
private string <ExtractorName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtractorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResponseCodeToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleInstanceValuesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleNameValuesToDiscover>k__BackingField;
    public string ExtractorName { get; }
    public string ExtractorVersion { get; }
    public int MaxResponseCodeToDiscover { get; public set; }
    public int MaxCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxCloudRoleNameValuesToDiscover { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorVersion();
    [CompilerGeneratedAttribute]
public int get_MaxResponseCodeToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxResponseCodeToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleInstanceValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleInstanceValuesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleNameValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleNameValuesToDiscover(int value);
    public sealed virtual void InitializeExtractor(TelemetryClient metricTelemetryClient);
    public sealed virtual void ExtractMetrics(ITelemetry fromItem, Boolean& isItemProcessed);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.RequestResponseCodeDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.RequestSuccessDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.SuccessDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.SyntheticDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.TargetDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.TraceMetricIdDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.TraceMetricsExtractor : object {
    public static int MaxCloudRoleInstanceValuesToDiscoverDefault;
    public static int MaxCloudRoleNameValuesToDiscoverDefault;
    private object lockObject;
    private Metric traceCountMetric;
    private bool isInitialized;
    private List`1<IDimensionExtractor> dimensionExtractors;
    [CompilerGeneratedAttribute]
private string <ExtractorName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtractorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleInstanceValuesToDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCloudRoleNameValuesToDiscover>k__BackingField;
    public string ExtractorName { get; }
    public string ExtractorVersion { get; }
    public int MaxCloudRoleInstanceValuesToDiscover { get; public set; }
    public int MaxCloudRoleNameValuesToDiscover { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtractorVersion();
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleInstanceValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleInstanceValuesToDiscover(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCloudRoleNameValuesToDiscover();
    [CompilerGeneratedAttribute]
public void set_MaxCloudRoleNameValuesToDiscover(int value);
    public sealed virtual void InitializeExtractor(TelemetryClient metricTelemetryClient);
    public sealed virtual void ExtractMetrics(ITelemetry fromItem, Boolean& isItemProcessed);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.TraceSeverityLevelDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Metrics.TypeDimensionExtractor : object {
    [CompilerGeneratedAttribute]
private int <MaxValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MaxValues { get; public set; }
    public string DefaultValue { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxValues(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual string ExtractDimension(ITelemetry item);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.OperationContext : object {
    private string id;
    private string parentId;
    private string correlationVector;
    private string syntheticSource;
    private string name;
    public string Id { get; public set; }
    public string ParentId { get; public set; }
    [EditorBrowsableAttribute("1")]
public string CorrelationVector { get; public set; }
    public string Name { get; public set; }
    public string SyntheticSource { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public string get_ParentId();
    public void set_ParentId(string value);
    public string get_CorrelationVector();
    public void set_CorrelationVector(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_SyntheticSource();
    public void set_SyntheticSource(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(OperationContext target);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.OperationContextForCallContext : object {
    public string ParentOperationId;
    public string RootOperationId;
    public string RootOperationName;
    public IDictionary`2<string, string> CorrelationContext;
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.OperationHolder`1 : object {
    public OperationContextForCallContext ParentContext;
    private static object LockObj;
    private TelemetryClient telemetryClient;
    private object originalActivity;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private T <Telemetry>k__BackingField;
    public T Telemetry { get; }
    public OperationHolder`1(TelemetryClient telemetryClient, T telemetry, object originalActivity);
    private static OperationHolder`1();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Telemetry();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.ApplicationInsights.Extensibility.Implementation.OperationTelemetry : object {
    internal static string TelemetryName;
    [CompilerGeneratedAttribute]
private long <BeginTimeInTicks>k__BackingField;
    [ObsoleteAttribute("Use Timestamp")]
public DateTimeOffset StartTime { get; public set; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, double> Metrics { get; }
    public IDictionary`2<string, string> Properties { get; }
    public DateTimeOffset Timestamp { get; public set; }
    public TelemetryContext Context { get; }
    public string Sequence { get; public set; }
    public IExtension Extension { get; public set; }
    internal long BeginTimeInTicks { get; internal set; }
    public DateTimeOffset get_StartTime();
    public void set_StartTime(DateTimeOffset value);
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual Nullable`1<bool> get_Success();
    public abstract virtual void set_Success(Nullable`1<bool> value);
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual void set_Duration(TimeSpan value);
    public abstract virtual IDictionary`2<string, double> get_Metrics();
    public abstract virtual IDictionary`2<string, string> get_Properties();
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual void set_Timestamp(DateTimeOffset value);
    public abstract virtual TelemetryContext get_Context();
    public abstract virtual string get_Sequence();
    public abstract virtual void set_Sequence(string value);
    public abstract virtual IExtension get_Extension();
    public abstract virtual void set_Extension(IExtension value);
    [CompilerGeneratedAttribute]
internal long get_BeginTimeInTicks();
    [CompilerGeneratedAttribute]
internal void set_BeginTimeInTicks(long value);
    private sealed virtual override void Microsoft.ApplicationInsights.Channel.ITelemetry.Sanitize();
    public abstract virtual ITelemetry DeepClone();
    public abstract virtual void SerializeData(ISerializationWriter serializationWriter);
    internal void GenerateId();
    protected void Sanitize();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Platform.PlatformImplementation : object {
    private IDictionary environmentVariables;
    private IDebugOutput debugOutput;
    private string hostName;
    public sealed virtual string ReadConfigurationXml();
    public sealed virtual IDebugOutput GetDebugOutput();
    public sealed virtual bool TryGetEnvironmentVariable(string name, String& value);
    public sealed virtual string GetMachineName();
    private static string GetHostName();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Platform.PlatformSingleton : object {
    private static IPlatform current;
    public static IPlatform Current { get; public set; }
    public static IPlatform get_Current();
    public static void set_Current(IPlatform value);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Property : object {
    public static int MaxDictionaryNameLength;
    public static int MaxDependencyTypeLength;
    public static int MaxValueLength;
    public static int MaxResultCodeLength;
    public static int MaxEventNameLength;
    public static int MaxNameLength;
    public static int MaxMessageLength;
    public static int MaxUrlLength;
    public static int MaxDataLength;
    public static int MaxTestNameLength;
    public static int MaxRunLocationLength;
    public static int MaxAvailabilityMessageLength;
    public static int MaxMetricNamespaceLength;
    public static IDictionary`2<string, int> TagSizeLimits;
    private static Property();
    public static void Set(T& property, T value);
    public static void Initialize(Nullable`1& property, Nullable`1<T> value);
    public static void Initialize(String& property, string value);
    [ExtensionAttribute]
public static string SanitizeEventName(string name);
    [ExtensionAttribute]
public static string SanitizeName(string name);
    [ExtensionAttribute]
public static string SanitizeDependencyType(string value);
    [ExtensionAttribute]
public static string SanitizeResultCode(string value);
    [ExtensionAttribute]
public static string SanitizeValue(string value);
    [ExtensionAttribute]
public static string SanitizeMessage(string message);
    [ExtensionAttribute]
public static string SanitizeData(string message);
    [ExtensionAttribute]
public static Uri SanitizeUri(Uri uri);
    [ExtensionAttribute]
public static string SanitizeTestName(string value);
    [ExtensionAttribute]
public static string SanitizeRunLocation(string value);
    [ExtensionAttribute]
public static string SanitizeAvailabilityMessage(string value);
    [ExtensionAttribute]
public static void SanitizeProperties(IDictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static void SanitizeMeasurements(IDictionary`2<string, double> dictionary);
    public static string TrimAndTruncate(string value, int maxLength);
    private static string Truncate(string value, int maxLength);
    private static string SanitizeKey(string key);
    private static string MakeKeyNonEmpty(string key);
    private static string MakeKeyUnique(string key, IDictionary`2<string, TValue> dictionary);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.RichPayloadEventSource : object {
    public static RichPayloadEventSource Log;
    internal EventSource EventSourceInternal;
    private static string EventProviderName;
    private Dictionary`2<Type, Action`1<ITelemetry>> telemetryHandlers;
    private Action`2<OperationTelemetry, EventOpcode> operationStartStopHandler;
    private Action`4<EventData, string, IDictionary`2<string, string>, long> unknownTelemetryHandler;
    private string dummyPartAiKeyValue;
    private long dummyPartAFlagsValue;
    private IDictionary`2<string, string> dummyPartATagsValue;
    internal RichPayloadEventSource(string providerName);
    private static RichPayloadEventSource();
    public void Process(ITelemetry item);
    public void ProcessOperationStart(OperationTelemetry operation);
    public void ProcessOperationStop(OperationTelemetry operation);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private static void CopyGlobalPropertiesIfRequired(ITelemetry telemetry, IDictionary`2<string, string> itemProperties);
    private Dictionary`2<Type, Action`1<ITelemetry>> CreateTelemetryHandlers(EventSource eventSource);
    private Action`2<OperationTelemetry, EventOpcode> CreateOperationStartStopHandler(EventSource eventSource);
    private Action`4<EventData, string, IDictionary`2<string, string>, long> CreateHandlerForUnknownTelemetry(EventSource eventSource);
    private Action`1<ITelemetry> CreateHandlerForRequestTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForTraceTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForEventTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForDependencyTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForMetricTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForExceptionTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForPerformanceCounterTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForPageViewTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForPageViewPerformanceTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
    private Action`1<ITelemetry> CreateHandlerForSessionStateTelemetry(EventSource eventSource, MethodInfo writeGenericMethod, Type eventSourceOptionsType, PropertyInfo eventSourceOptionsKeywordsProperty);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Sampling.SamplingRateStore : object {
    private double requestSampleRate;
    private double dependencySampleRate;
    private double eventSampleRate;
    private double exceptionSampleRate;
    private double pageViewSampleRate;
    private double messageSampleRate;
    internal double GetLastObservedSamplingPercentage(SamplingTelemetryItemTypes samplingItemType);
    internal void SetLastObservedSamplingPercentage(SamplingTelemetryItemTypes samplingItemType, double value);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.SdkVersionUtils : object {
    internal static string GetSdkVersion(string versionPrefix);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.SessionContext : object {
    private string id;
    private Nullable`1<bool> isFirst;
    public string Id { get; public set; }
    public Nullable`1<bool> IsFirst { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public Nullable`1<bool> get_IsFirst();
    public void set_IsFirst(Nullable`1<bool> value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(SessionContext target);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.SeverityLevelExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> sdkSeverityLevel);
    [ExtensionAttribute]
public static Nullable`1<SeverityLevel> TranslateSeverityLevel(Nullable`1<SeverityLevel> dataPlatformSeverityLevel);
}
internal abstract class Microsoft.ApplicationInsights.Extensibility.Implementation.SnapshottingCollection`2 : object {
    protected TCollection Collection;
    protected TCollection snapshot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    protected SnapshottingCollection`2(TCollection collection);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TItem item);
    public virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public virtual bool Remove(TItem item);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected abstract virtual TCollection CreateSnapshot(TCollection collection);
    protected TCollection GetSnapshot();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.SnapshottingList`1 : SnapshottingCollection`2<T, IList`1<T>> {
    public T Item { get; public set; }
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public virtual void Insert(int index, T item);
    public virtual void RemoveAt(int index);
    protected sealed virtual IList`1<T> CreateSnapshot(IList`1<T> collection);
}
[ObsoleteAttribute("This class will be removed in the next major version. Application Insights base library wouldn't provide this functionality any longer.")]
public class Microsoft.ApplicationInsights.Extensibility.Implementation.TaskTimer : object {
    public static TimeSpan InfiniteTimeSpan;
    private TaskTimerInternal internalTimer;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    private static TaskTimer();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Func`1<Task> elapsed);
    public void Cancel();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.TaskTimerInternal : object {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    private static TaskTimerInternal();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Func`1<Task> elapsed);
    public void Cancel();
    public sealed virtual void Dispose();
    private static void LogException(Exception exception);
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
    private void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Telemetry : object {
    [ExtensionAttribute]
public static void WriteEnvelopeProperties(ITelemetry telemetry, ISerializationWriter json);
    public static void WriteTelemetryContext(ISerializationWriter json, TelemetryContext context);
    [ExtensionAttribute]
internal static void CopyGlobalPropertiesIfExist(ITelemetry telemetry);
    [ExtensionAttribute]
internal static void CopyGlobalPropertiesIfExist(ITelemetry telemetry, IDictionary`2<string, string> target);
    [ExtensionAttribute]
internal static void FlattenIExtensionIfExists(ITelemetry telemetry);
    [ExtensionAttribute]
internal static EventData FlattenTelemetryIntoEventData(ITelemetry telemetry);
    [ExtensionAttribute]
private static bool IsDeveloperMode(ITelemetry telemetry);
    private static string NormalizeInstrumentationKey(string instrumentationKey);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static double GetLastObservedSamplingPercentage(TelemetryConfiguration configuration, SamplingTelemetryItemTypes samplingItemType);
    [ExtensionAttribute]
public static void SetLastObservedSamplingPercentage(TelemetryConfiguration configuration, SamplingTelemetryItemTypes samplingItemType, double value);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryConfigurationFactory : object {
    private static string AddElementName;
    private static string TypeAttributeName;
    private static string NameAttributeName;
    private static string InstrumentationKeyEnvironmentVariable;
    private static string ConnectionStringEnvironmentVariable;
    private static MethodInfo LoadInstancesDefinition;
    private static XNamespace XmlNamespace;
    private static TelemetryConfigurationFactory instance;
    public static TelemetryConfigurationFactory Instance { get; public set; }
    private static TelemetryConfigurationFactory();
    public static TelemetryConfigurationFactory get_Instance();
    public static void set_Instance(TelemetryConfigurationFactory value);
    public virtual void Initialize(TelemetryConfiguration configuration, TelemetryModules modules, string serializedConfiguration);
    public virtual void Initialize(TelemetryConfiguration configuration, TelemetryModules modules);
    protected static object CreateInstance(Type interfaceType, string typeName, Object[] constructorArgs);
    protected static void LoadFromXml(TelemetryConfiguration configuration, TelemetryModules modules, XDocument xml);
    protected static object LoadInstance(XElement definition, Type expectedType, object instance, Object[] constructorArgs, TelemetryModules modules);
    protected static void BuildTelemetryProcessorChain(XElement definition, TelemetryProcessorChainBuilder builder);
    protected static void LoadTelemetrySinks(XElement definition, TelemetryConfiguration telemetryConfiguration);
    protected static void LoadInstances(XElement definition, ICollection`1<T> instances, TelemetryModules modules);
    protected static void LoadProperties(XElement instanceDefinition, object instance, TelemetryModules modules);
    private static void InitializeComponents(TelemetryConfiguration configuration, TelemetryModules modules);
    private static void InitializeComponents(IEnumerable components, TelemetryConfiguration configuration);
    private static void InitializeComponent(object component, TelemetryConfiguration configuration);
    private static void LoadInstanceFromValue(XElement definition, Type expectedType, Object& instance);
    private static Type GetType(string typeName);
    private static Type GetManagedType(string typeName);
    private static bool GetCollectionElementType(Type type, Type& elementType);
    private static IEnumerable`1<XElement> GetPropertyDefinitions(XElement instanceDefinition);
    private static void SelectInstrumentationKey(TelemetryConfiguration configuration);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryContextExtensions : object {
    [ExtensionAttribute]
public static InternalContext GetInternalContext(TelemetryContext context);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryDebugWriter : object {
    [CompilerGeneratedAttribute]
private static bool <IsTracingDisabled>k__BackingField;
    public static bool IsTracingDisabled { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_IsTracingDisabled();
    [CompilerGeneratedAttribute]
public static void set_IsTracingDisabled(bool value);
    public static void WriteTelemetry(ITelemetry telemetry, string filteredBy);
    private sealed virtual override void Microsoft.ApplicationInsights.Extensibility.IDebugOutput.WriteLine(string message);
    private sealed virtual override bool Microsoft.ApplicationInsights.Extensibility.IDebugOutput.IsLogging();
    private sealed virtual override bool Microsoft.ApplicationInsights.Extensibility.IDebugOutput.IsAttached();
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryExtensions : object {
    private static string DefaultEnvelopeName;
    [ExtensionAttribute]
public static bool TrySetEnvelopeName(ITelemetry telemetry, string envelopeName);
    [ExtensionAttribute]
public static string GetEnvelopeName(ITelemetry telemetry);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryModules : object {
    private static TelemetryModules instance;
    [CompilerGeneratedAttribute]
private IList`1<ITelemetryModule> <Modules>k__BackingField;
    public static TelemetryModules Instance { get; }
    public IList`1<ITelemetryModule> Modules { get; private set; }
    public static TelemetryModules get_Instance();
    [CompilerGeneratedAttribute]
public IList`1<ITelemetryModule> get_Modules();
    [CompilerGeneratedAttribute]
private void set_Modules(IList`1<ITelemetryModule> value);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryProcessorChain : object {
    private SnapshottingList`1<ITelemetryProcessor> telemetryProcessors;
    internal ITelemetryProcessor FirstTelemetryProcessor { get; }
    internal SnapshottingList`1<ITelemetryProcessor> TelemetryProcessors { get; }
    internal TelemetryProcessorChain(IEnumerable`1<ITelemetryProcessor> telemetryProcessors);
    internal ITelemetryProcessor get_FirstTelemetryProcessor();
    internal SnapshottingList`1<ITelemetryProcessor> get_TelemetryProcessors();
    public void Process(ITelemetry item);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.TelemetryProcessorChainBuilder : object {
    private List`1<Func`2<ITelemetryProcessor, ITelemetryProcessor>> factories;
    private TelemetryConfiguration configuration;
    private TelemetrySink telemetrySink;
    internal TelemetrySink TelemetrySink { get; }
    public TelemetryProcessorChainBuilder(TelemetryConfiguration configuration);
    public TelemetryProcessorChainBuilder(TelemetryConfiguration configuration, TelemetrySink telemetrySink);
    internal TelemetrySink get_TelemetrySink();
    public TelemetryProcessorChainBuilder Use(Func`2<ITelemetryProcessor, ITelemetryProcessor> telemetryProcessorFactory);
    public void Build();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.ApplicationNameProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private static string GetApplicationName();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.BaseDefaultHeartbeatPropertyProvider : object {
    internal List`1<string> DefaultFields;
    private static Nullable`1<Guid> uniqueProcessSessionId;
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual bool IsKeyword(string keyword);
    public sealed virtual Task`1<bool> SetDefaultPayload(IEnumerable`1<string> disabledFields, IHeartbeatProvider provider);
    private static string GetRuntimeFrameworkVer();
    private static string GetBaseSdkTargetFramework();
    private static string GetRuntimeOsType();
    private static string GetProcessSessionId();
}
[EventSourceAttribute]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.CoreEventSource : EventSource {
    public static CoreEventSource Log;
    private ApplicationNameProvider nameProvider;
    public static bool IsVerboseEnabled { get; }
    private static CoreEventSource();
    [NonEventAttribute]
public static bool get_IsVerboseEnabled();
    [EventAttribute("1")]
public void OperationIsNullWarning(string appDomainName);
    [EventAttribute("2")]
public void InvalidOperationToStopError(string appDomainName);
    [EventAttribute("3")]
public void LogVerbose(string msg, string appDomainName);
    [EventAttribute("4")]
public void DiagnosticsEventThrottlingHasBeenStartedForTheEvent(string eventId, string appDomainName);
    [EventAttribute("5")]
public void DiagnosticsEventThrottlingHasBeenResetForTheEvent(int eventId, int executionCount, string appDomainName);
    [EventAttribute("6")]
public void DiagnoisticsEventThrottlingSchedulerDisposeTimerFailure(string exception, string appDomainName);
    [EventAttribute("7")]
public void DiagnoisticsEventThrottlingSchedulerTimerWasCreated(string intervalInMilliseconds, string appDomainName);
    [EventAttribute("8")]
public void DiagnoisticsEventThrottlingSchedulerTimerWasRemoved(string appDomainName);
    [EventAttribute("9")]
public void TelemetryClientConstructorWithNoTelemetryConfiguration(string appDomainName);
    [EventAttribute("10")]
public void PopulateRequiredStringWithValue(string parameterName, string telemetryType, string appDomainName);
    [EventAttribute("11")]
public void TelemetryIncorrectDuration(string appDomainName);
    [EventAttribute("12")]
public void TrackingWasDisabled(string appDomainName);
    [EventAttribute("13")]
public void TrackingWasEnabled(string appDomainName);
    [EventAttribute("14")]
public void LogError(string msg, string appDomainName);
    [EventAttribute("15")]
public void TypeWasNotFoundConfigurationError(string type, string appDomainName);
    [EventAttribute("16")]
public void IncorrectTypeConfigurationError(string type, string expectedType, string appDomainName);
    [EventAttribute("17")]
public void IncorrectPropertyConfigurationError(string type, string property, string appDomainName);
    [EventAttribute("18")]
public void IncorrectInstanceAtributesConfigurationError(string definition, string appDomainName);
    [EventAttribute("19")]
public void LoadInstanceFromValueConfigurationError(string element, string contents, string error, string appDomainName);
    [EventAttribute("20")]
public void ConfigurationFileCouldNotBeParsedError(string error, string appDomainName);
    [EventAttribute("21")]
public void MissingMethodExceptionConfigurationError(string type, string error, string appDomainName);
    [EventAttribute("22")]
public void ComponentInitializationConfigurationError(string type, string error, string appDomainName);
    [EventAttribute("23")]
public void ApplicationInsightsConfigNotFoundWarning(string file, string appDomainName);
    [EventAttribute("24")]
public void FailedToSend(string msg, string appDomainName);
    [EventAttribute("25")]
public void FailedToGetMachineName(string error, string appDomainName);
    [EventAttribute("26")]
public void FailedToFlushMetricAggregators(string ex, string appDomainName);
    [EventAttribute("27")]
public void FailedToSnapshotMetricAggregators(string ex, string appDomainName);
    [EventAttribute("28")]
public void FailedToRunMetricProcessor(string processorName, string ex, string appDomainName);
    [EventAttribute("29")]
public void ItemDroppedAsMaximumUnsentBacklogSizeReached(int maxBacklogSize, string appDomainName);
    [EventAttribute("30")]
public void InMemoryChannelFlushedAfterBeingDisposed(string appDomainName);
    [EventAttribute("31")]
public void InMemoryChannelSendCalledAfterBeingDisposed(string appDomainName);
    [EventAttribute("32")]
public void FailedToLoadEnvironmentVariables(string ex, string appDomainName);
    [EventAttribute("33")]
public void MetricExtractorAfterSamplingError(string appDomainName);
    [EventAttribute("34")]
public void MetricExtractorAfterSamplingVerbose(string appDomainName);
    [EventAttribute("35")]
public void ItemRejectedNoInstrumentationKey(string item, string appDomainName);
    [EventAttribute("36")]
public void FailedToObtainDefaultHeartbeatProperty(string heartbeatProperty, string ex, string appDomainName);
    [EventAttribute("37")]
public void FailedToAddHeartbeatProperty(string heartbeatProperty, string heartbeatPropertyValue, string ex, string appDomainName);
    [EventAttribute("38")]
public void HeartbeatPropertyAddedWithoutAnyName(string heartbeatPropertyValue, bool isHealthy, string appDomainName);
    [EventAttribute("39")]
public void FailedToSetHeartbeatProperty(string heartbeatProperty, string heartbeatPropertyValue, bool isHealthyHasValue, bool isHealthy, string ex, string appDomainName);
    [EventAttribute("40")]
public void CannotSetHeartbeatPropertyWithNoNameOrDefaultName(string heartbeatProperty, string heartbeatPropertyValue, bool isHealthyHasValue, bool isHealthy, string appDomainName);
    [EventAttribute("41")]
public void ApplicationIdProviderFetchApplicationIdFailed(string exception, string appDomainName);
    [EventAttribute("42")]
public void ApplicationIdProviderFetchApplicationIdFailedWithResponseCode(string httpStatusCode, string appDomainName);
    [EventAttribute("43")]
public void TelemetrySinkCalledAfterBeingDisposed(string appDomainName);
    [EventAttribute("44")]
public void InvalidOperationToStopDetails(string details, string appDomainName);
    [EventAttribute("45")]
public void ApplicationInsightsConfigNotAccessibleWarning(string appDomainName);
    [EventAttribute("46")]
public void InitializationIsSkippedForSampledItem(string appDomainName);
    [EventAttribute("47")]
public void ConnectionStringExceedsMaxLength(int maxLength, string appDomainName);
    [EventAttribute("48")]
public void ConnectionStringEmpty(string appDomainName);
    [EventAttribute("49")]
public void ConnectionStringDuplicateKey(string appDomainName);
    [EventAttribute("50")]
public void ConnectionStringInvalidDelimiters(string appDomainName);
    [EventAttribute("51")]
public void ConnectionStringNull(string appDomainName);
    [EventAttribute("52")]
public void ConnectionStringInvalidEndpoint(string exceptionMessage, string appDomainName);
    [EventAttribute("53")]
public void ConnectionStringSetFailed(string exceptionMessage, string appDomainName);
    [EventAttribute("54")]
public void TelemetryConfigurationFactoryFoundConnectionStringEnvironmentVariable(string variableName, string appDomainName);
    [EventAttribute("55")]
public void TelemetryConfigurationFactoryFoundInstrumentationKeyEnvironmentVariable(string variableName, string appDomainName);
    [EventAttribute("56")]
public void TelemetryConfigurationFactoryNoInstrumentationKey(string appDomainName);
    [EventAttribute("57")]
public void TelemetryChannelNoInstrumentationKey(string appDomainName);
    [EventAttribute("58")]
public void TelemetlyClientFlush(string appDomainName);
    [EventAttribute("59")]
public void MetricManagerFlush(string appDomainName);
    [EventAttribute("60")]
public void MetricManagerCreatedTasks(int taskCount, string appDomainName);
    [EventAttribute("61")]
public void LogsFileName(string fileName, string appDomainName);
    [EventAttribute("62")]
public void LogStorageAccessDeniedError(string error, string user, string appDomainName);
    [EventAttribute("66")]
public void LogWindowsIdentityAccessSecurityException(string error, string appDomainName);
    [EventAttribute("67")]
public void IngestionResponseTime(int responseCode, float responseDurationInMs, string appDomainName);
    [EventAttribute("68")]
public void ConfigurationStringParseWarning(string message, string appDomainName);
    [EventAttribute("69")]
public void ConnectionStringParseError(string message, string appDomainName);
    [NonEventAttribute]
public void IngestionResponseTimeEventCounter(float responseDurationInMs);
    [EventAttribute("70")]
public void UpdateDataFailed(string error, string appDomainName);
    [EventAttribute("71")]
public void TransmissionStatusEventError(string error, string appDomainName);
    [EventAttribute("72")]
public void SelfDiagnosticsFileCreateException(string logDirectory, string exception, string appDomainName);
    [EventAttribute("73")]
public void FailedToGetToken(string exception, string appDomainName);
    [EventAttribute("74")]
public void IngestionRedirectInformation(string message, string appDomainName);
    [EventAttribute("75")]
public void IngestionRedirectError(string message, string appDomainName);
    [EventAttribute("76")]
public void MetricValueBufferExceededSpinCount(string appDomainName);
    [NonEventAttribute]
public void TransmissionStatusEventFailed(Exception ex);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnoisticsEventCounters : object {
    private object syncRoot;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) execCount;
    internal int ExecCount { get; }
    internal DiagnoisticsEventCounters(int execCountInitial);
    internal int get_ExecCount();
    internal int Increment();
    [CompilerGeneratedAttribute]
private void <Increment>b__5_0();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnoisticsEventThrottling : object {
    private int throttleAfterCount;
    private object syncRoot;
    private Dictionary`2<int, DiagnoisticsEventCounters> counters;
    internal int ThrottleAfterCount { get; }
    internal DiagnoisticsEventThrottling(int throttleAfterCount);
    internal int get_ThrottleAfterCount();
    public sealed virtual bool ThrottleEvent(int eventId, long keywords, Boolean& justExceededThreshold);
    public sealed virtual IDictionary`2<int, DiagnoisticsEventCounters> CollectSnapshot();
    private static bool IsExcludedFromThrottling(long keywords);
    private DiagnoisticsEventCounters InternalGetEventCounter(int eventId);
    [CompilerGeneratedAttribute]
private void <CollectSnapshot>b__7_0();
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnoisticsEventThrottlingDefaults : object {
    internal static int MinimalThrottleAfterCount;
    internal static int DefaultThrottleAfterCount;
    internal static int MaxThrottleAfterCount;
    internal static UInt32 MinimalThrottlingRecycleIntervalInMinutes;
    internal static UInt32 DefaultThrottlingRecycleIntervalInMinutes;
    internal static UInt32 MaxThrottlingRecycleIntervalInMinutes;
    internal static int KeywordsExcludedFromEventThrottling;
    [ExtensionAttribute]
internal static bool IsInRangeThrottleAfterCount(int throttleAfterCount);
    [ExtensionAttribute]
internal static bool IsInRangeThrottlingRecycleInterval(UInt32 throttlingRecycleIntervalInMinutes);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnoisticsEventThrottlingManager`1 : object {
    private T snapshotContainer;
    internal DiagnoisticsEventThrottlingManager`1(T snapshotContainer, IDiagnoisticsEventThrottlingScheduler scheduler, UInt32 throttlingRecycleIntervalInMinutes);
    public sealed virtual bool ThrottleEvent(int eventId, long keywords);
    private void ResetThrottling();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnoisticsEventThrottlingScheduler : object {
    private IList`1<TaskTimerInternal> timers;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    public ICollection`1<object> Tokens { get; }
    protected virtual override void Finalize();
    public ICollection`1<object> get_Tokens();
    public sealed virtual object ScheduleToRunEveryTimeIntervalInMilliseconds(int interval, Action actionToExecute);
    public sealed virtual void RemoveScheduledRoutine(object token);
    public sealed virtual void Dispose();
    private static void DisposeTimer(IDisposable timer);
    private static TaskTimerInternal InternalCreateAndStartTimer(int intervalInMilliseconds, Action action);
    private void Dispose(bool managed);
    private void DisposeAllTimers();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnosticsEventListener : EventListener {
    private static long AllKeyword;
    private EventLevel logLevel;
    private DiagnosticsListener listener;
    private List`1<EventSource> eventSourcesDuringConstruction;
    public DiagnosticsEventListener(DiagnosticsListener listener, EventLevel logLevel);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventSourceEvent);
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    private static bool ShouldSubscribe(EventSource eventSource);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.DiagnosticsListener : object {
    private IList`1<IDiagnosticsSender> diagnosticsSenders;
    private EventLevel logLevel;
    private DiagnosticsEventListener eventListener;
    public EventLevel LogLevel { get; public set; }
    public DiagnosticsListener(IList`1<IDiagnosticsSender> senders);
    public EventLevel get_LogLevel();
    public void set_LogLevel(EventLevel value);
    public void SetLogLevel(string value);
    public void WriteEvent(TraceEvent eventData);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.IDiagnoisticsEventThrottling {
    public abstract virtual bool ThrottleEvent(int eventId, long keywords, Boolean& justExceededThreshold);
    public abstract virtual IDictionary`2<int, DiagnoisticsEventCounters> CollectSnapshot();
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.IDiagnoisticsEventThrottlingManager {
    public abstract virtual bool ThrottleEvent(int eventId, long keywords);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.IDiagnoisticsEventThrottlingScheduler {
    public abstract virtual object ScheduleToRunEveryTimeIntervalInMilliseconds(int interval, Action actionToExecute);
    public abstract virtual void RemoveScheduledRoutine(object token);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.IDiagnosticsSender {
    public abstract virtual void Send(TraceEvent eventData);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.PortalDiagnosticsQueueSender : object {
    [CompilerGeneratedAttribute]
private IList`1<TraceEvent> <EventData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisabled>k__BackingField;
    public IList`1<TraceEvent> EventData { get; }
    public bool IsDisabled { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<TraceEvent> get_EventData();
    [CompilerGeneratedAttribute]
public bool get_IsDisabled();
    [CompilerGeneratedAttribute]
public void set_IsDisabled(bool value);
    public sealed virtual void Send(TraceEvent eventData);
    public void FlushQueue(IDiagnosticsSender sender);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.PortalDiagnosticsSender : object {
    private static string SdkTelemetrySyntheticSourceName;
    private TelemetryClient telemetryClient;
    private IDiagnoisticsEventThrottlingManager throttlingManager;
    [CompilerGeneratedAttribute]
private string <DiagnosticsInstrumentationKey>k__BackingField;
    public string DiagnosticsInstrumentationKey { get; public set; }
    public PortalDiagnosticsSender(TelemetryConfiguration configuration, IDiagnoisticsEventThrottlingManager throttlingManager);
    [CompilerGeneratedAttribute]
public string get_DiagnosticsInstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_DiagnosticsInstrumentationKey(string value);
    public sealed virtual void Send(TraceEvent eventData);
    private void InternalSendTraceTelemetry(TraceEvent eventData);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.SpinWait : object {
    [ExtensionAttribute]
internal static void ExecuteSpinWaitLock(object syncRoot, Action action);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsModule.ThreadResourceLock : object {
    [ThreadStaticAttribute]
private static object syncObject;
    public static bool IsResourceLocked { get; }
    public static bool get_IsResourceLocked();
    public sealed virtual void Dispose();
    private static void Dispose(bool disponing);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.DiagnosticsTelemetryModule : object {
    internal IList`1<IDiagnosticsSender> Senders;
    internal DiagnosticsListener EventListener;
    internal IHeartbeatProvider HeartbeatProvider;
    private object lockObject;
    private IDiagnoisticsEventThrottlingScheduler throttlingScheduler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private string instrumentationKey;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool IsHeartbeatEnabled { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public IList`1<string> ExcludedHeartbeatPropertyProviders { get; }
    public IList`1<string> ExcludedHeartbeatProperties { get; }
    public string Severity { get; public set; }
    public string DiagnosticsInstrumentationKey { get; public set; }
    internal bool IsInitialized { get; private set; }
    protected virtual override void Finalize();
    public sealed virtual bool get_IsHeartbeatEnabled();
    public sealed virtual void set_IsHeartbeatEnabled(bool value);
    public sealed virtual TimeSpan get_HeartbeatInterval();
    public sealed virtual void set_HeartbeatInterval(TimeSpan value);
    public sealed virtual IList`1<string> get_ExcludedHeartbeatPropertyProviders();
    public sealed virtual IList`1<string> get_ExcludedHeartbeatProperties();
    public string get_Severity();
    public void set_Severity(string value);
    public string get_DiagnosticsInstrumentationKey();
    public void set_DiagnosticsInstrumentationKey(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public sealed virtual bool AddHeartbeatProperty(string propertyName, string propertyValue, bool isHealthy);
    public sealed virtual bool SetHeartbeatProperty(string propertyName, string propertyValue, Nullable`1<bool> isHealthy);
    public sealed virtual void Dispose();
    private void Dispose(bool managed);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.EventMetaData : object {
    [CompilerGeneratedAttribute]
private string <EventSourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    public string EventSourceName { get; public set; }
    public int EventId { get; public set; }
    public string MessageFormat { get; public set; }
    public long Keywords { get; public set; }
    public EventLevel Level { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventSourceName();
    [CompilerGeneratedAttribute]
public void set_EventSourceName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
public void set_EventId(int value);
    [CompilerGeneratedAttribute]
public string get_MessageFormat();
    [CompilerGeneratedAttribute]
public void set_MessageFormat(string value);
    [CompilerGeneratedAttribute]
public long get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(long value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    public bool IsUserActionable();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.EventSourceKeywords : object {
    public static long UserActionable;
    public static long Diagnostics;
    public static long VerboseFailure;
    public static long ErrorFailure;
    public static long ReservedUserKeywordBegin;
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.Extensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(Exception exception);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileDiagnosticsModule.DiagnosticsEventListener : EventListener {
    private static string EventSourceNamePrefix;
    private EventKeywords keywords;
    private EventLevel logLevel;
    private IEventListener sender;
    public EventLevel LogLevel { get; }
    internal DiagnosticsEventListener(EventLevel logLevel, EventKeywords keywords, IEventListener sender);
    public EventLevel get_LogLevel();
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    protected virtual void OnEventSourceCreated(EventSource eventSource);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileDiagnosticsModule.IEventListener {
    public abstract virtual void OnEventWritten(EventWrittenEventArgs eventData);
}
[ComVisibleAttribute("False")]
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileDiagnosticsModule.TraceSourceForEventSource : TraceSource {
    private static long AllKeyword;
    private static string TraceSourceName;
    private DiagnosticsEventListener listener;
    public EventLevel LogLevel { get; public set; }
    public TraceSourceForEventSource(SourceLevels defaultLevel);
    public TraceSourceForEventSource(EventLevel defaultLevel);
    public EventLevel get_LogLevel();
    public void set_LogLevel(EventLevel value);
    private sealed virtual override void Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileDiagnosticsModule.IEventListener.OnEventWritten(EventWrittenEventArgs eventData);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposeManaged);
    protected void TraceEvent(EventWrittenEventArgs eventData);
    private static EventLevel GetEventLevelFromSourceLevels(SourceLevels defaultLevel);
    private static TraceEventType GetTraceEventTypeForEventLevel(EventLevel level);
    private static SourceLevels GetSourceLevelsForEventLevel(EventLevel level);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileDiagnosticsTelemetryModule : object {
    private TraceSourceForEventSource traceSource;
    private DefaultTraceListener listener;
    private string logFileName;
    private string logFilePath;
    public string Severity { get; public set; }
    public string LogFileName { get; public set; }
    public string LogFilePath { get; public set; }
    public string get_Severity();
    public void set_Severity(string value);
    public string get_LogFileName();
    public void set_LogFileName(string value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposeManaged);
    private bool SetAndValidateLogsFolder(string filePath, string fileName);
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.FileHelper : object {
    private static string identityName;
    public static string IdentityName { get; }
    public static string get_IdentityName();
    public static void TestDirectoryPermissions(DirectoryInfo directory);
    public static string GenerateFileName();
    private static string GetCurrentIdentityName();
}
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.HeartbeatDefaultPayload : object {
    internal static IHeartbeatDefaultPayloadProvider[] DefaultPayloadProviders;
    private static HeartbeatDefaultPayload();
    public static bool IsDefaultKeyword(string keyword);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.HeartbeatDefaultPayload/<PopulateDefaultPayload>d__2")]
public static Task`1<bool> PopulateDefaultPayload(IEnumerable`1<string> disabledFields, IEnumerable`1<string> disabledProviders, IHeartbeatProvider provider);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.HeartbeatPropertyPayload : object {
    private string payloadValue;
    private bool isHealthy;
    [CompilerGeneratedAttribute]
private bool <IsUpdated>k__BackingField;
    public string PayloadValue { get; public set; }
    public bool IsHealthy { get; public set; }
    public bool IsUpdated { get; public set; }
    public string get_PayloadValue();
    public void set_PayloadValue(string value);
    public bool get_IsHealthy();
    public void set_IsHealthy(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUpdated();
    [CompilerGeneratedAttribute]
public void set_IsUpdated(bool value);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.HeartbeatProvider : object {
    public static TimeSpan DefaultHeartbeatInterval;
    public static TimeSpan MinimumHeartbeatInterval;
    private static string sdkVersionPropertyValue;
    private static string heartbeatSyntheticMetricName;
    private List`1<string> disabledDefaultFields;
    private List`1<string> disabledHeartbeatPropertyProviders;
    private ulong heartbeatsSent;
    private ConcurrentDictionary`2<string, HeartbeatPropertyPayload> heartbeatProperties;
    private bool disposedValue;
    private TimeSpan interval;
    private TelemetryClient telemetryClient;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isEnabled;
    [CompilerGeneratedAttribute]
private Timer <HeartbeatTimer>k__BackingField;
    public TimeSpan HeartbeatInterval { get; public set; }
    public string InstrumentationKey { get; public set; }
    public bool IsHeartbeatEnabled { get; public set; }
    public IList`1<string> ExcludedHeartbeatPropertyProviders { get; }
    public IList`1<string> ExcludedHeartbeatProperties { get; }
    private Timer HeartbeatTimer { get; private set; }
    private static HeartbeatProvider();
    public sealed virtual TimeSpan get_HeartbeatInterval();
    public sealed virtual void set_HeartbeatInterval(TimeSpan value);
    public sealed virtual string get_InstrumentationKey();
    public sealed virtual void set_InstrumentationKey(string value);
    public sealed virtual bool get_IsHeartbeatEnabled();
    public sealed virtual void set_IsHeartbeatEnabled(bool value);
    public sealed virtual IList`1<string> get_ExcludedHeartbeatPropertyProviders();
    public sealed virtual IList`1<string> get_ExcludedHeartbeatProperties();
    [CompilerGeneratedAttribute]
private Timer get_HeartbeatTimer();
    [CompilerGeneratedAttribute]
private void set_HeartbeatTimer(Timer value);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public sealed virtual bool AddHeartbeatProperty(string heartbeatPropertyName, string heartbeatPropertyValue, bool isHealthy);
    public sealed virtual bool SetHeartbeatProperty(string heartbeatPropertyName, string heartbeatPropertyValue, Nullable`1<bool> isHealthy);
    public sealed virtual void Dispose();
    public sealed virtual bool AddHeartbeatProperty(string propertyName, bool overrideDefaultField, string propertyValue, bool isHealthy);
    public sealed virtual bool SetHeartbeatProperty(string propertyName, bool overrideDefaultField, string propertyValue, Nullable`1<bool> isHealthy);
    internal ITelemetry GatherData();
    internal void InitTimer();
    protected void Dispose(bool disposing);
    private void Send();
    private void HeartbeatPulse(object state);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.HeartbeatProvider/<<Initialize>b__30_0>d")]
[CompilerGeneratedAttribute]
private Task`1<bool> <Initialize>b__30_0();
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.IHeartbeatDefaultPayloadProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool IsKeyword(string keyword);
    public abstract virtual Task`1<bool> SetDefaultPayload(IEnumerable`1<string> disabledFields, IHeartbeatProvider provider);
}
public interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.IHeartbeatPropertyManager {
    public bool IsHeartbeatEnabled { get; public set; }
    public IList`1<string> ExcludedHeartbeatPropertyProviders { get; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public IList`1<string> ExcludedHeartbeatProperties { get; }
    public abstract virtual bool get_IsHeartbeatEnabled();
    public abstract virtual void set_IsHeartbeatEnabled(bool value);
    public abstract virtual IList`1<string> get_ExcludedHeartbeatPropertyProviders();
    public abstract virtual TimeSpan get_HeartbeatInterval();
    public abstract virtual void set_HeartbeatInterval(TimeSpan value);
    public abstract virtual IList`1<string> get_ExcludedHeartbeatProperties();
    public abstract virtual bool AddHeartbeatProperty(string propertyName, string propertyValue, bool isHealthy);
    public abstract virtual bool SetHeartbeatProperty(string propertyName, string propertyValue, Nullable`1<bool> isHealthy);
}
internal interface Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.IHeartbeatProvider {
    public string InstrumentationKey { get; public set; }
    public abstract virtual string get_InstrumentationKey();
    public abstract virtual void set_InstrumentationKey(string value);
    public abstract virtual void Initialize(TelemetryConfiguration configuration);
    public abstract virtual bool AddHeartbeatProperty(string propertyName, bool overrideDefaultField, string propertyValue, bool isHealthy);
    public abstract virtual bool SetHeartbeatProperty(string propertyName, bool overrideDefaultField, string propertyValue, Nullable`1<bool> isHealthy);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.MemoryMappedFileHandler : object {
    public static Byte[] MessageOnNewFile;
    private ThreadLocal`1<MemoryMappedFile> memoryMappedFileCache;
    private ThreadLocal`1<MemoryMappedViewStream> viewStream;
    private FileStream modreq(System.Runtime.CompilerServices.IsVolatile) underlyingFileStreamForMemoryMappedFile;
    private MemoryMappedFile modreq(System.Runtime.CompilerServices.IsVolatile) memoryMappedFile;
    private bool disposedValue;
    private string logDirectory;
    private int logFileSize;
    private long logFilePosition;
    public string LogDirectory { get; public set; }
    public int LogFileSize { get; private set; }
    public string CurrentFilePath { get; }
    private static MemoryMappedFileHandler();
    public string get_LogDirectory();
    public void set_LogDirectory(string value);
    public int get_LogFileSize();
    private void set_LogFileSize(int value);
    public string get_CurrentFilePath();
    public void CreateLogFile(string logDirectory, int fileSize);
    public void CloseLogFile();
    public sealed virtual void Dispose();
    public virtual void Write(Byte[] buffer, int byteCount);
    private static string GenerateFileName();
    private bool TryGetLogStream(int byteCount, Stream& stream, Int32& availableByteCount);
    private MemoryMappedViewStream GetStream();
    private void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.SelfDiagnosticsConfigParser : object {
    public static string ConfigFileName;
    private static int FileSizeLowerLimit;
    private static int FileSizeUpperLimit;
    private static string LogDiagnosticsEnvironmentVariable;
    private static int ConfigBufferSize;
    private static Regex LogDirectoryRegex;
    private static Regex FileSizeRegex;
    private static Regex LogLevelRegex;
    private Byte[] configBuffer;
    private static SelfDiagnosticsConfigParser();
    public bool TryGetConfiguration(String& logDirectory, Int32& fileSizeInKB, EventLevel& logLevel);
    internal static bool TryParseLogDirectory(string configJson, String& logDirectory);
    internal static bool TryParseFileSize(string configJson, Int32& fileSizeInKB);
    internal static bool TryParseLogLevel(string configJson, String& logLevel);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.SelfDiagnosticsConfigRefresher : object {
    private static int ConfigurationUpdatePeriodMilliSeconds;
    private CancellationTokenSource cancellationTokenSource;
    private Task worker;
    private SelfDiagnosticsConfigParser configParser;
    private MemoryMappedFileHandler memoryMappedFileHandler;
    private bool disposedValue;
    private SelfDiagnosticsEventListener eventListener;
    private EventLevel logEventLevel;
    public string CurrentFilePath { get; }
    public string get_CurrentFilePath();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.SelfDiagnosticsConfigRefresher/<Worker>d__12")]
private Task Worker(CancellationToken cancellationToken);
    private void UpdateMemoryMappedFileFromConfiguration();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__8_0();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.SelfDiagnosticsEventListener : EventListener {
    private static string EventSourceNamePrefix;
    private static int BUFFERSIZE;
    private ThreadLocal`1<Byte[]> writeBuffer;
    private object lockObj;
    private EventLevel logLevel;
    private MemoryMappedFileHandler fileHandler;
    private List`1<EventSource> eventSourcesBeforeConstructor;
    private bool disposedValue;
    public SelfDiagnosticsEventListener(EventLevel logLevel, MemoryMappedFileHandler fileHandler);
    public virtual void Dispose();
    internal static int EncodeInBuffer(string str, bool isParameter, Byte[] buffer, int position);
    internal static int DateTimeGetBytes(DateTime datetime, Byte[] bytes, int byteIndex);
    internal void WriteEvent(string eventMessage, ReadOnlyCollection`1<object> payload);
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.SelfDiagnostics.SelfDiagnosticsInitializer : object {
    private static SelfDiagnosticsInitializer Instance;
    private SelfDiagnosticsConfigRefresher configRefresher;
    private static SelfDiagnosticsInitializer();
    public static void EnsureInitialized();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.Tracing.TraceEvent : object {
    private static string AiPrefix;
    private static string AiNonUserActionable;
    [CompilerGeneratedAttribute]
private EventMetaData <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Payload>k__BackingField;
    public EventMetaData MetaData { get; public set; }
    public Object[] Payload { get; public set; }
    [CompilerGeneratedAttribute]
public EventMetaData get_MetaData();
    [CompilerGeneratedAttribute]
public void set_MetaData(EventMetaData value);
    [CompilerGeneratedAttribute]
public Object[] get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(Object[] value);
    public virtual string ToString();
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.TransmissionProcessor : object {
    private TelemetrySink sink;
    internal TransmissionProcessor(TelemetrySink sink);
    public sealed virtual void Process(ITelemetry item);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type otherType);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
}
public class Microsoft.ApplicationInsights.Extensibility.Implementation.UserContext : object {
    private string id;
    private string accountId;
    private string userAgent;
    private string authenticatedUserId;
    public string Id { get; public set; }
    public string AccountId { get; public set; }
    public string UserAgent { get; public set; }
    public string AuthenticatedUserId { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public string get_AuthenticatedUserId();
    public void set_AuthenticatedUserId(string value);
    internal void UpdateTags(IDictionary`2<string, string> tags);
    internal void CopyTo(UserContext target);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Extensibility.Implementation.Utils : object {
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    public static void CopyDictionary(IDictionary`2<string, TValue> source, IDictionary`2<string, TValue> target);
    public static string PopulateRequiredStringValue(string value, string parameterName, string telemetryType);
    public static TimeSpan ValidateDuration(string value);
    public static double SanitizeNanAndInfinity(double value);
    public static double SanitizeNanAndInfinity(double value, Boolean& valueChanged);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.WeakConcurrentRandom : object {
    private static WeakConcurrentRandom random;
    private int index;
    private int segmentCount;
    private int segmentSize;
    private int bitsToStoreRandomIndexWithinSegment;
    private int segmentIndexMask;
    private int randomIndexWithinSegmentMask;
    private int randomArrayIndexMask;
    private IRandomNumberBatchGenerator[] randomGemerators;
    private UInt64[] randomNumbers;
    public static WeakConcurrentRandom Instance { get; }
    public static WeakConcurrentRandom get_Instance();
    public void Initialize();
    public void Initialize(Func`2<ulong, IRandomNumberBatchGenerator> randomGeneratorFactory, int segmentIndexBits, int segmentBits);
    public ulong Next();
    private void RegenerateSegment(int newIndex);
}
internal class Microsoft.ApplicationInsights.Extensibility.Implementation.XorshiftRandomBatchGenerator : object {
    private static ulong Y;
    private static ulong Z;
    private static ulong W;
    private ulong lastX;
    private ulong lastY;
    private ulong lastZ;
    private ulong lastW;
    public XorshiftRandomBatchGenerator(ulong seed);
    public sealed virtual void NextBatch(UInt64[] buffer, int index, int count);
}
public interface Microsoft.ApplicationInsights.Extensibility.IOperationHolder`1 {
    public T Telemetry { get; }
    public abstract virtual T get_Telemetry();
}
public interface Microsoft.ApplicationInsights.Extensibility.ISerializableWithWriter {
    public abstract virtual void Serialize(ISerializationWriter serializationWriter);
}
public interface Microsoft.ApplicationInsights.Extensibility.ISerializationWriter {
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteProperty(string name, Nullable`1<double> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<int> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<bool> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<TimeSpan> value);
    public abstract virtual void WriteProperty(string name, Nullable`1<DateTimeOffset> value);
    public abstract virtual void WriteProperty(string name, ISerializableWithWriter value);
    public abstract virtual void WriteProperty(ISerializableWithWriter value);
    public abstract virtual void WriteProperty(string name, IList`1<string> items);
    public abstract virtual void WriteProperty(string name, IList`1<ISerializableWithWriter> items);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, string> items);
    public abstract virtual void WriteProperty(string name, IDictionary`2<string, double> items);
    public abstract virtual void WriteStartObject(string name);
    public abstract virtual void WriteStartObject();
    public abstract virtual void WriteEndObject();
}
public interface Microsoft.ApplicationInsights.Extensibility.ITelemetryInitializer {
    public abstract virtual void Initialize(ITelemetry telemetry);
}
public interface Microsoft.ApplicationInsights.Extensibility.ITelemetryModule {
    public abstract virtual void Initialize(TelemetryConfiguration configuration);
}
public interface Microsoft.ApplicationInsights.Extensibility.ITelemetryProcessor {
    public abstract virtual void Process(ITelemetry item);
}
public class Microsoft.ApplicationInsights.Extensibility.OperationCorrelationTelemetryInitializer : object {
    private static string TracestatePropertyKey;
    public sealed virtual void Initialize(ITelemetry telemetryItem);
}
public static class Microsoft.ApplicationInsights.Extensibility.SdkInternalOperationsMonitor : object {
    internal static string InternalOperationsMonitorSlotName;
    private static object syncObj;
    private static SdkInternalOperationsMonitor();
    public static bool IsEntered();
    public static void Enter();
    public static void Exit();
}
public class Microsoft.ApplicationInsights.Extensibility.SequencePropertyInitializer : object {
    private string stablePrefix;
    private long currentNumber;
    public sealed virtual void Initialize(ITelemetry telemetry);
}
public class Microsoft.ApplicationInsights.Extensibility.TelemetryConfiguration : object {
    internal SamplingRateStore LastKnownSampleRateStore;
    private static object syncRoot;
    private static TelemetryConfiguration active;
    private SnapshottingList`1<ITelemetryInitializer> telemetryInitializers;
    private TelemetrySinkCollection telemetrySinks;
    private TelemetryProcessorChain telemetryProcessorChain;
    private string instrumentationKey;
    private string connectionString;
    private bool disableTelemetry;
    private TelemetryProcessorChainBuilder builder;
    private MetricManager metricManager;
    private IApplicationIdProvider applicationIdProvider;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private EndpointContainer <EndpointContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExperimentalFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialEnvelope <CredentialEnvelope>k__BackingField;
    public static TelemetryConfiguration Active { get; internal set; }
    public string InstrumentationKey { get; public set; }
    public bool DisableTelemetry { get; public set; }
    public IList`1<ITelemetryInitializer> TelemetryInitializers { get; }
    public ReadOnlyCollection`1<ITelemetryProcessor> TelemetryProcessors { get; }
    public TelemetryProcessorChainBuilder TelemetryProcessorChainBuilder { get; internal set; }
    public ITelemetryChannel TelemetryChannel { get; public set; }
    public IApplicationIdProvider ApplicationIdProvider { get; public set; }
    public EndpointContainer EndpointContainer { get; private set; }
    public string ConnectionString { get; public set; }
    [EditorBrowsableAttribute("1")]
public IList`1<string> ExperimentalFeatures { get; }
    public IList`1<TelemetrySink> TelemetrySinks { get; }
    public TelemetrySink DefaultTelemetrySink { get; }
    internal CredentialEnvelope CredentialEnvelope { get; private set; }
    internal TelemetryProcessorChain TelemetryProcessorChain { get; internal set; }
    private static TelemetryConfiguration();
    [ObsoleteAttribute("InstrumentationKey based global ingestion is being deprecated. Use the default constructor and manually set TelemetryConfiguration.ConnectionString. See https://github.com/microsoft/ApplicationInsights-dotnet/issues/2560 for more details.")]
public TelemetryConfiguration(string instrumentationKey);
    [ObsoleteAttribute("InstrumentationKey based global ingestion is being deprecated. Use the default constructor and manually set TelemetryConfiguration.ConnectionString. See https://github.com/microsoft/ApplicationInsights-dotnet/issues/2560 for more details.")]
public TelemetryConfiguration(string instrumentationKey, ITelemetryChannel channel);
    public static TelemetryConfiguration get_Active();
    internal static void set_Active(TelemetryConfiguration value);
    public string get_InstrumentationKey();
    [ObsoleteAttribute("InstrumentationKey based global ingestion is being deprecated. Use TelemetryConfiguration.ConnectionString. See https://github.com/microsoft/ApplicationInsights-dotnet/issues/2560 for more details.")]
public void set_InstrumentationKey(string value);
    public bool get_DisableTelemetry();
    public void set_DisableTelemetry(bool value);
    public IList`1<ITelemetryInitializer> get_TelemetryInitializers();
    public ReadOnlyCollection`1<ITelemetryProcessor> get_TelemetryProcessors();
    public TelemetryProcessorChainBuilder get_TelemetryProcessorChainBuilder();
    internal void set_TelemetryProcessorChainBuilder(TelemetryProcessorChainBuilder value);
    public ITelemetryChannel get_TelemetryChannel();
    public void set_TelemetryChannel(ITelemetryChannel value);
    public IApplicationIdProvider get_ApplicationIdProvider();
    public void set_ApplicationIdProvider(IApplicationIdProvider value);
    [CompilerGeneratedAttribute]
public EndpointContainer get_EndpointContainer();
    [CompilerGeneratedAttribute]
private void set_EndpointContainer(EndpointContainer value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExperimentalFeatures();
    public IList`1<TelemetrySink> get_TelemetrySinks();
    public TelemetrySink get_DefaultTelemetrySink();
    [CompilerGeneratedAttribute]
internal CredentialEnvelope get_CredentialEnvelope();
    [CompilerGeneratedAttribute]
private void set_CredentialEnvelope(CredentialEnvelope value);
    internal TelemetryProcessorChain get_TelemetryProcessorChain();
    internal void set_TelemetryProcessorChain(TelemetryProcessorChain value);
    public static TelemetryConfiguration CreateDefault();
    public static TelemetryConfiguration CreateFromConfiguration(string config);
    public sealed virtual void Dispose();
    public void SetAzureTokenCredential(object tokenCredential);
    internal MetricManager GetMetricManager(bool createIfNotExists);
    private static void SetApplicationIdEndpoint(IApplicationIdProvider applicationIdProvider, string endpoint, bool force);
    private static void SetTelemetryChannelEndpoint(ITelemetryChannel channel, string endpoint, bool force);
    private static void SetTelemetryChannelCredentialEnvelope(ITelemetryChannel telemetryChannel, CredentialEnvelope credentialEnvelope);
    private void SetTelemetryChannelCredentialEnvelope();
    private void SetTelemetryChannelEndpoint(string ingestionEndpoint);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private TelemetryProcessorChainBuilder <get_TelemetryProcessorChainBuilder>b__31_0();
}
public class Microsoft.ApplicationInsights.Extensibility.TelemetrySink : object {
    public static string DefaultSinkName;
    private TelemetryConfiguration telemetryConfiguration;
    private ITelemetryChannel telemetryChannel;
    private bool shouldDisposeChannel;
    private TelemetryProcessorChain telemetryProcessorChain;
    private TelemetryProcessorChainBuilder telemetryProcessorChainBuilder;
    private string name;
    private bool isDisposed;
    public TelemetryProcessorChainBuilder TelemetryProcessorChainBuilder { get; public set; }
    public ITelemetryChannel TelemetryChannel { get; public set; }
    public string Name { get; public set; }
    public ReadOnlyCollection`1<ITelemetryProcessor> TelemetryProcessors { get; }
    internal TelemetryProcessorChain TelemetryProcessorChain { get; internal set; }
    public TelemetrySink(TelemetryConfiguration telemetryConfiguration, ITelemetryChannel telemetryChannel);
    private static TelemetrySink();
    public TelemetryProcessorChainBuilder get_TelemetryProcessorChainBuilder();
    public void set_TelemetryProcessorChainBuilder(TelemetryProcessorChainBuilder value);
    public ITelemetryChannel get_TelemetryChannel();
    public void set_TelemetryChannel(ITelemetryChannel value);
    public string get_Name();
    public void set_Name(string value);
    public ReadOnlyCollection`1<ITelemetryProcessor> get_TelemetryProcessors();
    internal TelemetryProcessorChain get_TelemetryProcessorChain();
    internal void set_TelemetryProcessorChain(TelemetryProcessorChain value);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    public void Process(ITelemetry item);
    private void EnsureNotDisposed();
    [CompilerGeneratedAttribute]
private TelemetryProcessorChainBuilder <get_TelemetryProcessorChainBuilder>b__11_0();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ApplicationInsights.Extensibility.TelemetrySinkCollection : SnapshottingList`1<TelemetrySink> {
    private static int DefaultSinkIndex;
    private static string DefaultSinkCannotBeChanged;
    public TelemetrySink DefaultSink { get; }
    public TelemetrySink Item { get; public set; }
    public TelemetrySink get_DefaultSink();
    public virtual TelemetrySink get_Item(int index);
    public virtual void set_Item(int index, TelemetrySink value);
    public virtual bool Remove(TelemetrySink item);
    public virtual void Clear();
    public virtual void Insert(int index, TelemetrySink item);
    public virtual void RemoveAt(int index);
    private bool IsDefaultSink(TelemetrySink sink);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C making extension methods in this class no longer required.")]
public static class Microsoft.ApplicationInsights.Extensibility.W3C.W3CActivityExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static Activity GenerateW3CContext(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static bool IsW3CActivity(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static Activity UpdateContextOnActivity(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static string GetTraceparent(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static void SetTraceparent(Activity activity, string value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static string GetTracestate(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
public static void SetTracestate(Activity activity, string value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C. Use Activity.TraceId to get Trace ID")]
public static string GetTraceId(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C. Use Activity.SpanId to get Span ID")]
public static string GetSpanId(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C. Use Activity.ParentSpanId to get ParentSpan ID")]
public static string GetParentSpanId(Activity activity);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C. OperationCorrelationTelemetryInitializer is W3C aware and is recommended to update telemetry from current Activity.")]
public static void UpdateTelemetry(Activity activity, ITelemetry telemetry, bool forceUpdate);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activity from System.Diagnostics.DiagnosticSource 4.6.0 onwards natively support W3C.")]
internal static void SetParentSpanId(Activity activity, string value);
}
internal static class Microsoft.ApplicationInsights.Extensibility.W3C.W3CConstants : object {
    internal static string LegacyRootIdProperty;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Obsolete in favor of OperationCorrelationTelemetryInitializer which is now W3C aware.")]
public class Microsoft.ApplicationInsights.Extensibility.W3C.W3COperationCorrelationTelemetryInitializer : object {
    public sealed virtual void Initialize(ITelemetry telemetry);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.W3C.W3CUtilities : object {
    private static UInt32[] Lookup32;
    private static Regex TraceIdRegex;
    private static W3CUtilities();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ActivityTraceId.CreateRandom().ToHexString() instead.")]
public static string GenerateTraceId();
    internal static bool IsCompatibleW3CTraceId(string traceId);
    [EditorBrowsableAttribute("1")]
internal static string GenerateSpanId();
    private static string GenerateId(Byte[] bytes, int start, int length);
    private static UInt32[] CreateLookup32();
}
public class Microsoft.ApplicationInsights.Metric : object {
    internal MetricConfiguration configuration;
    private MetricSeries zeroDimSeries;
    private IReadOnlyList`1<KeyValuePair`2<String[], MetricSeries>> zeroDimSeriesList;
    private MultidimensionalCube2`1<MetricSeries> metricSeries;
    private MetricManager metricManager;
    [CompilerGeneratedAttribute]
private MetricIdentifier <Identifier>k__BackingField;
    public MetricIdentifier Identifier { get; }
    public int SeriesCount { get; }
    internal Metric(MetricManager metricManager, MetricIdentifier metricIdentifier, MetricConfiguration configuration);
    [CompilerGeneratedAttribute]
public MetricIdentifier get_Identifier();
    public int get_SeriesCount();
    public IReadOnlyCollection`1<string> GetDimensionValues(int dimensionNumber);
    public IReadOnlyList`1<KeyValuePair`2<String[], MetricSeries>> GetAllSeries();
    public bool TryGetDataSeries(MetricSeries& series);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value);
    public bool TryGetDataSeries(MetricSeries& series, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value, string dimension10Value);
    public bool TryGetDataSeries(MetricSeries& series, bool createIfNotExists, String[] dimensionValues);
    public void TrackValue(double metricValue);
    public void TrackValue(object metricValue);
    public bool TrackValue(double metricValue, string dimension1Value);
    public bool TrackValue(object metricValue, string dimension1Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value);
    public bool TrackValue(double metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value, string dimension10Value);
    public bool TrackValue(object metricValue, string dimension1Value, string dimension2Value, string dimension3Value, string dimension4Value, string dimension5Value, string dimension6Value, string dimension7Value, string dimension8Value, string dimension9Value, string dimension10Value);
    private static void EnsureConfigurationValid(int dimensionsCount, MetricConfiguration configuration);
    private MetricSeries CreateNewMetricSeries(String[] dimensionValues);
}
public enum Microsoft.ApplicationInsights.MetricAggregationScope : Enum {
    public int value__;
    public static MetricAggregationScope TelemetryConfiguration;
    public static MetricAggregationScope TelemetryClient;
}
public class Microsoft.ApplicationInsights.MetricConfigurations : object {
    public static MetricConfigurations Common;
    private static MetricConfigurations();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.MetricConfigurationsExtensions : object {
    private static int DefaultSeriesCountLimit;
    private static int DefaultValuesPerDimensionLimit;
    private static MetricConfigurationForMeasurement defaultConfigForMeasurement;
    private static MetricConfigurationsExtensions();
    [ExtensionAttribute]
public static MetricConfigurationForMeasurement Measurement(MetricConfigurations metricConfigPresets);
    [ExtensionAttribute]
public static void SetDefaultForMeasurement(MetricConfigurations metricConfigPresets, MetricConfigurationForMeasurement defaultConfigurationForMeasurement);
    [ExtensionAttribute]
internal static MetricConfiguration Default(MetricConfigurations metricConfigPresets);
}
public static class Microsoft.ApplicationInsights.MetricDimensionNames : object {
}
internal class Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.GrowingCollection`1 : object {
    private static int SegmentSize;
    private Segment<T> dataHead;
    public int Count { get; }
    public int get_Count();
    public void Add(T item);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalCube`2 : object {
    private static int DimensionsCountLimit;
    private static string ExceptionThrownByPointsFactoryKey;
    private Int32[] subdimensionsCountLimits;
    private MultidimensionalCubeDimension`2<TDimensionValue, TPoint> points;
    private Func`2<TDimensionValue[], TPoint> pointsFactory;
    private int totalPointsCountLimit;
    private int totalPointsCount;
    public int DimensionsCount { get; }
    public int TotalPointsCountLimit { get; }
    public int TotalPointsCount { get; }
    public MultidimensionalCube`2(Func`2<TDimensionValue[], TPoint> pointsFactory, IEnumerable`1<int> subdimensionsCountLimits);
    public MultidimensionalCube`2(int totalPointsCountLimit, Func`2<TDimensionValue[], TPoint> pointsFactory, IEnumerable`1<int> subdimensionsCountLimits);
    public MultidimensionalCube`2(Func`2<TDimensionValue[], TPoint> pointsFactory, Int32[] subdimensionsCountLimits);
    public MultidimensionalCube`2(int totalPointsCountLimit, Func`2<TDimensionValue[], TPoint> pointsFactory, Int32[] subdimensionsCountLimits);
    public int get_DimensionsCount();
    public int get_TotalPointsCountLimit();
    public int get_TotalPointsCount();
    public int GetSubdimensionsCountLimit(int dimension);
    public IReadOnlyCollection`1<KeyValuePair`2<TDimensionValue[], TPoint>> GetAllPoints();
    public void GetAllPoints(ICollection`1<KeyValuePair`2<TDimensionValue[], TPoint>> pointContainer);
    public MultidimensionalPointResult`1<TPoint> TryGetOrCreatePoint(TDimensionValue[] coordinates);
    public MultidimensionalPointResult`1<TPoint> TryGetPoint(TDimensionValue[] coordinates);
    public Task`1<MultidimensionalPointResult`1<TPoint>> TryGetOrCreatePointAsync(TDimensionValue[] coordinates);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalCube`2/<TryGetOrCreatePointAsync>d__23")]
public Task`1<MultidimensionalPointResult`1<TPoint>> TryGetOrCreatePointAsync(TimeSpan sleepDuration, TimeSpan timeout, CancellationToken cancelToken, TDimensionValue[] coordinates);
    internal TPoint InvokePointsFactory(TDimensionValue[] coordinates);
    internal bool TryIncTotalPointsCount();
    internal int DecTotalPointsCount();
    private static bool IsThrownByPointsFactoryKey(Exception exception);
}
internal class Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalCube2`1 : object {
    private static int DimensionsCountLimit;
    private static string PointMonikerSeparator;
    private static String[] PointMonikerSeparatorAsArray;
    private SemaphoreSlim pointCreationLock;
    private int totalPointsCountLimit;
    private Int32[] dimensionValuesCountLimits;
    private HashSet`1[] dimensionValues;
    private ConcurrentDictionary`2<string, TPoint> points;
    private Func`2<String[], TPoint> pointsFactory;
    private int totalPointsCount;
    private bool applyDimensionCapping;
    private string dimensionCapValue;
    public int DimensionsCount { get; }
    public int TotalPointsCountLimit { get; }
    public int TotalPointsCount { get; }
    public MultidimensionalCube2`1(Func`2<String[], TPoint> pointsFactory, Int32[] dimensionValuesCountLimits);
    public MultidimensionalCube2`1(int totalPointsCountLimit, Func`2<String[], TPoint> pointsFactory, Int32[] dimensionValuesCountLimits);
    public MultidimensionalCube2`1(int totalPointsCountLimit, Func`2<String[], TPoint> pointsFactory, bool applyDimensionCapping, string dimensionCapValue, Int32[] dimensionValuesCountLimits);
    private static MultidimensionalCube2`1();
    public int get_DimensionsCount();
    public int get_TotalPointsCountLimit();
    public int get_TotalPointsCount();
    public int GetDimensionValuesCountLimit(int dimension);
    public IReadOnlyCollection`1<string> GetDimensionValues(int dimension);
    public IReadOnlyList`1<KeyValuePair`2<String[], TPoint>> GetAllPoints();
    public int GetAllPoints(ICollection`1<KeyValuePair`2<String[], TPoint>> pointContainer);
    public MultidimensionalPointResult`1<TPoint> TryGetOrCreatePoint(String[] coordinates);
    public Task`1<MultidimensionalPointResult`1<TPoint>> TryGetOrCreatePointAsync(String[] coordinates);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalCube2`1/<TryGetOrCreatePointAsync>d__27")]
public Task`1<MultidimensionalPointResult`1<TPoint>> TryGetOrCreatePointAsync(CancellationToken cancelToken, String[] coordinates);
    public MultidimensionalPointResult`1<TPoint> TryGetPoint(String[] coordinates);
    private static String[] ParsePointMoniker(string pointMoniker);
    private static string BuildPointMoniker(String[] coordinates);
    private MultidimensionalPointResult`1<TPoint> TryCreatePoint(String[] coordinates, string pointMoniker);
    private void ValidateDimensionIndex(int dimension);
    private string GetPointMoniker(String[] coordinates);
}
internal class Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalCubeDimension`2 : object {
    private MultidimensionalCube`2<TDimensionValue, TPoint> ownerCube;
    private int subdimensionsCountLimit;
    private bool isLastDimensionLevel;
    private ConcurrentDictionary`2<TDimensionValue, object> elements;
    private int subdimensionsCount;
    public MultidimensionalCubeDimension`2(MultidimensionalCube`2<TDimensionValue, TPoint> ownerCube, int subdimensionsCountLimit, bool isLastDimensionLevel);
    public MultidimensionalPointResult`1<TPoint> TryGetOrAddVector(TDimensionValue[] coordinates);
    public MultidimensionalPointResult`1<TPoint> TryGetVector(TDimensionValue[] coordinates);
    public IReadOnlyCollection`1<KeyValuePair`2<IList`1<TDimensionValue>, TPoint>> GetAllPointsReversed();
    private MultidimensionalPointResult`1<TPoint> TryGetOrAddVectorInternal(TDimensionValue[] coordinates, int currentDim, bool createIfNotExists);
    private MultidimensionalPointResult`1<TPoint> TryAddPoint(TDimensionValue[] coordinates, int currentDim);
    private MultidimensionalPointResult`1<TPoint> TryAddSubvector(TDimensionValue[] coordinates, int currentDim);
    private bool TryIncSubdimensionsCount();
    private int DecSubdimensionsCount();
}
internal class Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalPointResult`1 : ValueType {
    private TPoint point;
    private int failureCoordinateIndex;
    private MultidimensionalPointResultCodes resultCode;
    public TPoint Point { get; }
    public int FailureCoordinateIndex { get; }
    public MultidimensionalPointResultCodes ResultCode { get; }
    public bool IsPointCreatedNew { get; }
    public bool IsSuccess { get; }
    internal MultidimensionalPointResult`1(MultidimensionalPointResultCodes failureCode, int failureCoordinateIndex);
    internal MultidimensionalPointResult`1(MultidimensionalPointResultCodes successCode, TPoint point);
    public TPoint get_Point();
    public int get_FailureCoordinateIndex();
    public MultidimensionalPointResultCodes get_ResultCode();
    public bool get_IsPointCreatedNew();
    public bool get_IsSuccess();
    internal void SetAsyncTimeoutReachedFailure();
}
[FlagsAttribute]
internal enum Microsoft.ApplicationInsights.Metrics.ConcurrentDatastructures.MultidimensionalPointResultCodes : Enum {
    public byte value__;
    public static MultidimensionalPointResultCodes Success_NewPointCreated;
    public static MultidimensionalPointResultCodes Success_ExistingPointRetrieved;
    public static MultidimensionalPointResultCodes Success_NewPointCreatedAboveDimCapLimit;
    public static MultidimensionalPointResultCodes Failure_SubdimensionsCountLimitReached;
    public static MultidimensionalPointResultCodes Failure_TotalPointsCountLimitReached;
    public static MultidimensionalPointResultCodes Failure_PointDoesNotExistCreationNotRequested;
    public static MultidimensionalPointResultCodes Failure_AsyncTimeoutReached;
}
internal class Microsoft.ApplicationInsights.Metrics.DefaultAggregationPeriodCycle : object {
    private static int RunningState_NotStarted;
    private static int RunningState_Running;
    private static int RunningState_Stopped;
    private MetricAggregationManager aggregationManager;
    private MetricManager metricManager;
    private TaskCompletionSource`1<bool> workerTaskCompletionControl;
    private int runningState;
    private Thread aggregationThread;
    public DefaultAggregationPeriodCycle(MetricAggregationManager aggregationManager, MetricManager metricManager);
    protected virtual override void Finalize();
    public bool Start();
    public Task StopAsync();
    public void FetchAndTrackMetrics();
    internal static DateTimeOffset GetNextCycleTargetTime_UnitTestAccessor(DateTimeOffset periodStart);
    private static DateTimeOffset GetNextCycleTargetTime(DateTimeOffset periodStart);
    private void Run();
}
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.AggregationPeriodSummary : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetricAggregate> <PersistentAggregates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetricAggregate> <NonpersistentAggregates>k__BackingField;
    public IReadOnlyList`1<MetricAggregate> PersistentAggregates { get; }
    public IReadOnlyList`1<MetricAggregate> NonpersistentAggregates { get; }
    public AggregationPeriodSummary(IReadOnlyList`1<MetricAggregate> persistentAggregates, IReadOnlyList`1<MetricAggregate> nonpersistentAggregates);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetricAggregate> get_PersistentAggregates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetricAggregate> get_NonpersistentAggregates();
}
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.ApplicationInsightsTelemetryPipeline : object {
    private TelemetryClient trackingClient;
    private Task completedTask;
    public ApplicationInsightsTelemetryPipeline(TelemetryConfiguration telemetryPipeline);
    public ApplicationInsightsTelemetryPipeline(TelemetryClient telemetryClient);
    public sealed virtual Task TrackAsync(MetricAggregate metricAggregate, CancellationToken cancelToken);
    public sealed virtual Task FlushAsync(CancellationToken cancelToken);
}
internal interface Microsoft.ApplicationInsights.Metrics.Extensibility.IMetricAggregateToTelemetryPipelineConverter {
    public abstract virtual object Convert(MetricAggregate aggregate);
}
public interface Microsoft.ApplicationInsights.Metrics.Extensibility.IMetricSeriesAggregator {
    public MetricSeries DataSeries { get; }
    public abstract virtual MetricSeries get_DataSeries();
    public abstract virtual bool TryRecycle();
    public abstract virtual void Reset(DateTimeOffset periodStart, IMetricValueFilter valueFilter);
    public abstract virtual void Reset(DateTimeOffset periodStart);
    public abstract virtual MetricAggregate CompleteAggregation(DateTimeOffset periodEnd);
    public abstract virtual MetricAggregate CreateAggregateUnsafe(DateTimeOffset periodEnd);
    public abstract virtual void TrackValue(double metricValue);
    public abstract virtual void TrackValue(object metricValue);
}
internal interface Microsoft.ApplicationInsights.Metrics.Extensibility.IMetricSeriesFilter {
    public abstract virtual bool WillConsume(MetricSeries dataSeries, IMetricValueFilter& valueFilter);
}
public interface Microsoft.ApplicationInsights.Metrics.Extensibility.IMetricTelemetryPipeline {
    public abstract virtual Task TrackAsync(MetricAggregate metricAggregate, CancellationToken cancelToken);
    public abstract virtual Task FlushAsync(CancellationToken cancelToken);
}
public interface Microsoft.ApplicationInsights.Metrics.Extensibility.IMetricValueFilter {
    public abstract virtual bool WillConsume(MetricSeries dataSeries, double metricValue);
    public abstract virtual bool WillConsume(MetricSeries dataSeries, object metricValue);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.MemoryMetricTelemetryPipeline : object {
    public static int CountLimitDefault;
    private SemaphoreSlim updateLock;
    private IList`1<MetricAggregate> metricAgregates;
    [CompilerGeneratedAttribute]
private int <CountLimit>k__BackingField;
    public int CountLimit { get; }
    public int Count { get; }
    public MetricAggregate Item { get; }
    public MemoryMetricTelemetryPipeline(int countLimit);
    [CompilerGeneratedAttribute]
public int get_CountLimit();
    public sealed virtual int get_Count();
    public sealed virtual MetricAggregate get_Item(int index);
    public void Clear();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.Metrics.Extensibility.MemoryMetricTelemetryPipeline/<TrackAsync>d__13")]
public sealed virtual Task TrackAsync(MetricAggregate metricAggregate, CancellationToken cancelToken);
    public sealed virtual Task FlushAsync(CancellationToken cancelToken);
    private sealed virtual override IEnumerator`1<MetricAggregate> System.Collections.Generic.IEnumerable<Microsoft.ApplicationInsights.Metrics.MetricAggregate>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricAggregateToApplicationInsightsPipelineConverterBase : object {
    public static string AggregationIntervalMonikerPropertyKey;
    public string AggregationKindMoniker { get; }
    public abstract virtual string get_AggregationKindMoniker();
    public sealed virtual object Convert(MetricAggregate aggregate);
    protected abstract virtual void PopulateDataValues(MetricTelemetry telemetryItem, MetricAggregate aggregate);
    private static void PopulateTelemetryContext(IDictionary`2<string, string> dimensions, TelemetryContext telemetryContext, IEnumerable`1& nonContextDimensions);
    private void ValidateAggregate(MetricAggregate metricAggregate);
    private MetricTelemetry ConvertAggregateToTelemetry(MetricAggregate aggregate);
}
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricAggregateToTelemetryPipelineConverters : object {
    public static MetricAggregateToTelemetryPipelineConverters Registry;
    private ConcurrentDictionary`2<Type, ConcurrentDictionary`2<string, IMetricAggregateToTelemetryPipelineConverter>> pipelineTable;
    private static MetricAggregateToTelemetryPipelineConverters();
    public void Add(Type pipelineType, string aggregationKindMoniker, IMetricAggregateToTelemetryPipelineConverter converter);
    public bool TryGet(Type pipelineType, string aggregationKindMoniker, IMetricAggregateToTelemetryPipelineConverter& converter);
    private static void ValidateKeys(Type pipelineType, string aggregationKindMoniker);
}
public enum Microsoft.ApplicationInsights.Metrics.Extensibility.MetricAggregationCycleKind : Enum {
    public int value__;
    public static MetricAggregationCycleKind Default;
    public static MetricAggregationCycleKind QuickPulse;
    public static MetricAggregationCycleKind Custom;
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricConfigurationExtensions : object {
    [ExtensionAttribute]
public static AggregateKindConstants Constants(MetricSeriesConfigurationForMeasurement measurementConfig);
    [ExtensionAttribute]
public static AggregateKindConstants Constants(MetricConfigurationForMeasurement measurementConfig);
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricExtensions : object {
    [ExtensionAttribute]
public static MetricConfiguration GetConfiguration(Metric metric);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricManagerExtensions : object {
    [ExtensionAttribute]
public static AggregationPeriodSummary StopAggregators(MetricManager metricManager, MetricAggregationCycleKind aggregationCycleKind, DateTimeOffset tactTimestamp);
    [ExtensionAttribute]
public static AggregationPeriodSummary StartOrCycleAggregators(MetricManager metricManager, MetricAggregationCycleKind aggregationCycleKind, DateTimeOffset tactTimestamp, IMetricSeriesFilter futureFilter);
    [ExtensionAttribute]
public static Task StopDefaultAggregationCycleAsync(MetricManager metricManager);
}
internal abstract class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricSeriesAggregatorBase`1 : object {
    private MetricSeries dataSeries;
    private MetricAggregationCycleKind aggregationCycleKind;
    private bool isPersistent;
    private Func`1<MetricValuesBufferBase`1<TBufferedValue>> metricValuesBufferFactory;
    private DateTimeOffset periodStart;
    private IMetricValueFilter valueFilter;
    private MetricValuesBufferBase`1 modreq(System.Runtime.CompilerServices.IsVolatile) metricValuesBuffer;
    private MetricValuesBufferBase`1 modreq(System.Runtime.CompilerServices.IsVolatile) metricValuesBufferRecycle;
    public MetricSeries DataSeries { get; }
    protected MetricSeriesAggregatorBase`1(Func`1<MetricValuesBufferBase`1<TBufferedValue>> metricValuesBufferFactory, IMetricSeriesConfiguration configuration, MetricSeries dataSeries, MetricAggregationCycleKind aggregationCycleKind);
    public sealed virtual MetricSeries get_DataSeries();
    public sealed virtual MetricAggregate CompleteAggregation(DateTimeOffset periodEnd);
    public sealed virtual void Reset(DateTimeOffset periodStart);
    public sealed virtual void Reset(DateTimeOffset periodStart, IMetricValueFilter valueFilter);
    public sealed virtual void TrackValue(double metricValue);
    public sealed virtual void TrackValue(object metricValue);
    public sealed virtual bool TryRecycle();
    public sealed virtual MetricAggregate CreateAggregateUnsafe(DateTimeOffset periodEnd);
    protected abstract virtual MetricAggregate CreateAggregate(DateTimeOffset periodEnd);
    protected abstract virtual void ResetAggregate();
    protected abstract virtual TBufferedValue ConvertMetricValue(double metricValue);
    protected abstract virtual TBufferedValue ConvertMetricValue(object metricValue);
    protected abstract virtual object UpdateAggregate_Stage1(MetricValuesBufferBase`1<TBufferedValue> buffer, int minFlushIndex, int maxFlushIndex);
    protected abstract virtual void UpdateAggregate_Stage2(object stage1Result);
    protected void AddInfo_Timing_Dimensions_Context(MetricAggregate aggregate, DateTimeOffset periodEnd);
    private void TrackFilteredConvertedValue(TBufferedValue metricValue);
    private void UpdateAggregate(MetricValuesBufferBase`1<TBufferedValue> buffer);
    private MetricValuesBufferBase`1<TBufferedValue> InvokeMetricValuesBufferFactory();
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricSeriesExtensions : object {
    [ExtensionAttribute]
public static IMetricSeriesConfiguration GetConfiguration(MetricSeries metricSeries);
}
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricValuesBuffer_Double : MetricValuesBufferBase`1<double> {
    public MetricValuesBuffer_Double(int capacity);
    protected virtual bool IsInvalidValue(double value);
    protected virtual void ResetValues(Double[] values);
    protected virtual double GetAndResetValueOnce(Double[] values, int index);
    protected virtual void WriteValueOnce(Double[] values, int index, double value);
}
internal class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricValuesBuffer_Object : MetricValuesBufferBase`1<object> {
    public MetricValuesBuffer_Object(int capacity);
    protected virtual bool IsInvalidValue(object value);
    protected virtual void ResetValues(Object[] values);
    protected virtual object GetAndResetValueOnce(Object[] values, int index);
    protected virtual void WriteValueOnce(Object[] values, int index, object value);
}
internal abstract class Microsoft.ApplicationInsights.Metrics.Extensibility.MetricValuesBufferBase`1 : object {
    private TValue[] values;
    private int lastWriteIndex;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) nextFlushIndex;
    public int Capacity { get; }
    public int NextFlushIndex { get; public set; }
    public MetricValuesBufferBase`1(int capacity);
    public int get_Capacity();
    public int get_NextFlushIndex();
    public void set_NextFlushIndex(int value);
    public int IncWriteIndex();
    public int PeekLastWriteIndex();
    public void WriteValue(int index, TValue value);
    public void ResetIndices();
    public void ResetIndicesAndData();
    public TValue GetAndResetValue(int index);
    protected abstract virtual void ResetValues(TValue[] values);
    protected abstract virtual TValue GetAndResetValueOnce(TValue[] values, int index);
    protected abstract virtual void WriteValueOnce(TValue[] values, int index, TValue value);
    protected abstract virtual bool IsInvalidValue(TValue value);
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Metrics.Extensibility.TelemetryClientExtensions : object {
    private static ConditionalWeakTable`2<TelemetryClient, MetricManager> metricManagersForTelemetryClients;
    [ExtensionAttribute]
public static MetricManager GetMetricManager(TelemetryClient telemetryClient, MetricAggregationScope aggregationScope);
    [ExtensionAttribute]
internal static bool TryGetMetricManager(TelemetryClient telemetryClient, MetricManager& metricManager);
    private static MetricManager GetOrCreateMetricManager(TelemetryClient telemetryClient);
}
public interface Microsoft.ApplicationInsights.Metrics.IMetricSeriesConfiguration {
    public bool RequiresPersistentAggregation { get; }
    public abstract virtual bool get_RequiresPersistentAggregation();
    public abstract virtual IMetricSeriesAggregator CreateNewAggregator(MetricSeries dataSeries, MetricAggregationCycleKind aggregationCycleKind);
}
internal class Microsoft.ApplicationInsights.Metrics.MeasurementAggregateToApplicationInsightsPipelineConverter : MetricAggregateToApplicationInsightsPipelineConverterBase {
    public string AggregationKindMoniker { get; }
    public virtual string get_AggregationKindMoniker();
    protected virtual void PopulateDataValues(MetricTelemetry telemetryItem, MetricAggregate aggregate);
}
internal class Microsoft.ApplicationInsights.Metrics.MeasurementAggregator : MetricSeriesAggregatorBase`1<double> {
    private static Func`1<MetricValuesBufferBase`1<double>> MetricValuesBufferFactory;
    private object updateLock;
    private bool restrictToUInt32Values;
    private Data data;
    public MeasurementAggregator(MetricSeriesConfigurationForMeasurement configuration, MetricSeries dataSeries, MetricAggregationCycleKind aggregationCycleKind);
    private static MeasurementAggregator();
    protected virtual double ConvertMetricValue(double metricValue);
    protected virtual double ConvertMetricValue(object metricValue);
    protected virtual MetricAggregate CreateAggregate(DateTimeOffset periodEnd);
    protected virtual void ResetAggregate();
    protected virtual object UpdateAggregate_Stage1(MetricValuesBufferBase`1<double> buffer, int minFlushIndex, int maxFlushIndex);
    protected virtual void UpdateAggregate_Stage2(object stage1Result);
}
public class Microsoft.ApplicationInsights.Metrics.MetricAggregate : object {
    private object updateLock;
    private DateTimeOffset aggregationPeriodStart;
    private TimeSpan aggregationPeriodDuration;
    [CompilerGeneratedAttribute]
private string <MetricNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AggregationKindMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Dimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Data>k__BackingField;
    public string MetricNamespace { get; }
    public string MetricId { get; }
    public string AggregationKindMoniker { get; }
    public DateTimeOffset AggregationPeriodStart { get; public set; }
    public TimeSpan AggregationPeriodDuration { get; public set; }
    public IDictionary`2<string, string> Dimensions { get; }
    public IDictionary`2<string, object> Data { get; }
    public MetricAggregate(string metricNamespace, string metricId, string aggregationKindMoniker);
    [CompilerGeneratedAttribute]
public string get_MetricNamespace();
    [CompilerGeneratedAttribute]
public string get_MetricId();
    [CompilerGeneratedAttribute]
public string get_AggregationKindMoniker();
    public DateTimeOffset get_AggregationPeriodStart();
    public void set_AggregationPeriodStart(DateTimeOffset value);
    public TimeSpan get_AggregationPeriodDuration();
    public void set_AggregationPeriodDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Dimensions();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Data();
    public T GetDataValue(string dataKey, T defaultValue);
}
internal class Microsoft.ApplicationInsights.Metrics.MetricAggregationManager : object {
    private AggregatorCollection aggregatorsForPersistent;
    private AggregatorCollection aggregatorsForDefault;
    private AggregatorCollection aggregatorsForQuickPulse;
    private AggregatorCollection aggregatorsForCustom;
    public AggregationPeriodSummary StartOrCycleAggregators(MetricAggregationCycleKind aggregationCycleKind, DateTimeOffset tactTimestamp, IMetricSeriesFilter futureFilter);
    public AggregationPeriodSummary StopAggregators(MetricAggregationCycleKind aggregationCycleKind, DateTimeOffset tactTimestamp);
    internal bool IsCycleActive(MetricAggregationCycleKind aggregationCycleKind, IMetricSeriesFilter& filter);
    internal bool AddAggregator(IMetricSeriesAggregator aggregator, MetricAggregationCycleKind aggregationCycleKind);
    private static bool AddAggregator(IMetricSeriesAggregator aggregator, AggregatorCollection aggregatorCollection);
    private static List`1<MetricAggregate> GetNonpersistentAggregations(DateTimeOffset tactTimestamp, AggregatorCollection aggregators);
    private AggregationPeriodSummary CycleAggregators(AggregatorCollection& aggregators, DateTimeOffset tactTimestamp, IMetricSeriesFilter futureFilter, bool stopAggregators);
    private List`1<MetricAggregate> GetPersistentAggregations(DateTimeOffset tactTimestamp, IMetricSeriesFilter previousFilter);
}
public class Microsoft.ApplicationInsights.Metrics.MetricConfiguration : object {
    private int hashCode;
    private Int32[] valuesPerDimensionLimits;
    [CompilerGeneratedAttribute]
private int <SeriesCountLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetricSeriesConfiguration <SeriesConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyDimensionCapping>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DimensionCappedString>k__BackingField;
    public int SeriesCountLimit { get; }
    public IMetricSeriesConfiguration SeriesConfig { get; }
    internal bool ApplyDimensionCapping { get; internal set; }
    internal string DimensionCappedString { get; internal set; }
    public MetricConfiguration(int seriesCountLimit, int valuesPerDimensionLimit, IMetricSeriesConfiguration seriesConfig);
    public MetricConfiguration(int seriesCountLimit, IEnumerable`1<int> valuesPerDimensionLimits, IMetricSeriesConfiguration seriesConfig);
    [CompilerGeneratedAttribute]
public int get_SeriesCountLimit();
    [CompilerGeneratedAttribute]
public IMetricSeriesConfiguration get_SeriesConfig();
    [CompilerGeneratedAttribute]
internal bool get_ApplyDimensionCapping();
    [CompilerGeneratedAttribute]
internal void set_ApplyDimensionCapping(bool value);
    [CompilerGeneratedAttribute]
internal string get_DimensionCappedString();
    [CompilerGeneratedAttribute]
internal void set_DimensionCappedString(string value);
    public int GetValuesPerDimensionLimit(int dimensionNumber);
    public virtual bool Equals(object obj);
    public virtual bool Equals(MetricConfiguration other);
    public virtual int GetHashCode();
    private int ComputeHashCode();
}
public class Microsoft.ApplicationInsights.Metrics.MetricConfigurationForMeasurement : MetricConfiguration {
    public MetricConfigurationForMeasurement(int seriesCountLimit, int valuesPerDimensionLimit, MetricSeriesConfigurationForMeasurement seriesConfig);
    public MetricConfigurationForMeasurement(int seriesCountLimit, IEnumerable`1<int> valuesPerDimensionLimits, MetricSeriesConfigurationForMeasurement seriesConfig);
}
public class Microsoft.ApplicationInsights.Metrics.MetricIdentifier : object {
    public static int MaxDimensionsCount;
    private static string NoNamespaceIdentifierStringComponent;
    private static Char[] InvalidMetricChars;
    private static string defaultMetricNamespace;
    private string dimension1Name;
    private string dimension2Name;
    private string dimension3Name;
    private string dimension4Name;
    private string dimension5Name;
    private string dimension6Name;
    private string dimension7Name;
    private string dimension8Name;
    private string dimension9Name;
    private string dimension10Name;
    private string identifierString;
    private int hashCode;
    [CompilerGeneratedAttribute]
private string <MetricNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DimensionsCount>k__BackingField;
    public static string DefaultMetricNamespace { get; public set; }
    public string MetricNamespace { get; }
    public string MetricId { get; }
    public int DimensionsCount { get; }
    public MetricIdentifier(string metricId);
    public MetricIdentifier(string metricNamespace, string metricId);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name, string dimension6Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name, string dimension6Name, string dimension7Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name, string dimension6Name, string dimension7Name, string dimension8Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name, string dimension6Name, string dimension7Name, string dimension8Name, string dimension9Name);
    public MetricIdentifier(string metricNamespace, string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, string dimension5Name, string dimension6Name, string dimension7Name, string dimension8Name, string dimension9Name, string dimension10Name);
    public MetricIdentifier(string metricNamespace, string metricId, IList`1<string> dimensionNames);
    private static MetricIdentifier();
    public static string get_DefaultMetricNamespace();
    public static void set_DefaultMetricNamespace(string value);
    private static void ValidateLiteral(string partValue, string partName, bool allowEmpty);
    [CompilerGeneratedAttribute]
public string get_MetricNamespace();
    [CompilerGeneratedAttribute]
public string get_MetricId();
    [CompilerGeneratedAttribute]
public int get_DimensionsCount();
    [IteratorStateMachineAttribute("Microsoft.ApplicationInsights.Metrics.MetricIdentifier/<GetDimensionNames>d__42")]
public IEnumerable`1<string> GetDimensionNames();
    public string GetDimensionName(int dimensionNumber);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object otherObj);
    public sealed virtual bool Equals(MetricIdentifier otherMetricIdentifier);
    internal static void ValidateDimensionNumberForGetter(int dimensionNumber, int thisDimensionsCount);
    internal void ValidateDimensionNumberForGetter(int dimensionNumber);
    private static void EnsureDimensionNamesValid(Int32& dimensionCount, String& dimension1Name, String& dimension2Name, String& dimension3Name, String& dimension4Name, String& dimension5Name, String& dimension6Name, String& dimension7Name, String& dimension8Name, String& dimension9Name, String& dimension10Name);
    private static void EnsureDimensionNameValid(Int32& dimensionCount, String& dimensionName, int thisDimensionNumber);
    private string GetIdentifierString();
}
public class Microsoft.ApplicationInsights.Metrics.MetricManager : object {
    private MetricAggregationManager aggregationManager;
    private DefaultAggregationPeriodCycle aggregationCycle;
    private IMetricTelemetryPipeline telemetryPipeline;
    private MetricsCollection metrics;
    public MetricsCollection Metrics { get; }
    internal MetricAggregationManager AggregationManager { get; }
    internal DefaultAggregationPeriodCycle AggregationCycle { get; }
    public MetricManager(IMetricTelemetryPipeline telemetryPipeline);
    protected virtual override void Finalize();
    public MetricsCollection get_Metrics();
    internal MetricAggregationManager get_AggregationManager();
    internal DefaultAggregationPeriodCycle get_AggregationCycle();
    public MetricSeries CreateNewSeries(string metricNamespace, string metricId, IMetricSeriesConfiguration config);
    public MetricSeries CreateNewSeries(string metricNamespace, string metricId, IEnumerable`1<KeyValuePair`2<string, string>> dimensionNamesAndValues, IMetricSeriesConfiguration config);
    public MetricSeries CreateNewSeries(MetricIdentifier metricIdentifier, IEnumerable`1<KeyValuePair`2<string, string>> dimensionNamesAndValues, IMetricSeriesConfiguration config);
    public void Flush();
    internal void Flush(bool flushDownstreamPipeline);
    internal void TrackMetricAggregates(AggregationPeriodSummary aggregates, bool flush);
}
public class Microsoft.ApplicationInsights.Metrics.MetricsCollection : object {
    private MetricManager metricManager;
    private ConcurrentDictionary`2<MetricIdentifier, Metric> metrics;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal MetricsCollection(MetricManager metricManager);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Metric GetOrCreate(MetricIdentifier metricIdentifier, MetricConfiguration metricConfiguration);
    public bool TryGet(MetricIdentifier metricIdentifier, Metric& metric);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Metric metric);
    public bool Contains(MetricIdentifier metricIdentifier);
    public sealed virtual void CopyTo(Metric[] array, int arrayIndex);
    public sealed virtual bool Remove(Metric metric);
    public bool Remove(MetricIdentifier metricIdentifier);
    public bool Remove(MetricIdentifier metricIdentifier, Metric& removedMetric);
    public sealed virtual IEnumerator`1<Metric> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.ApplicationInsights.Metric>.Add(Metric unsupported);
}
public class Microsoft.ApplicationInsights.Metrics.MetricSeries : object {
    internal IMetricSeriesConfiguration configuration;
    private MetricAggregationManager aggregationManager;
    private bool requiresPersistentAggregator;
    private IReadOnlyDictionary`2<string, string> dimensionNamesAndValues;
    private IMetricSeriesAggregator aggregatorPersistent;
    private WeakReference`1<IMetricSeriesAggregator> aggregatorDefault;
    private WeakReference`1<IMetricSeriesAggregator> aggregatorQuickPulse;
    private WeakReference`1<IMetricSeriesAggregator> aggregatorCustom;
    private IMetricSeriesAggregator aggregatorRecycleCacheDefault;
    private IMetricSeriesAggregator aggregatorRecycleCacheQuickPulse;
    private IMetricSeriesAggregator aggregatorRecycleCacheCustom;
    [CompilerGeneratedAttribute]
private MetricIdentifier <MetricIdentifier>k__BackingField;
    public IReadOnlyDictionary`2<string, string> DimensionNamesAndValues { get; }
    public MetricIdentifier MetricIdentifier { get; }
    internal MetricSeries(MetricAggregationManager aggregationManager, MetricIdentifier metricIdentifier, IEnumerable`1<KeyValuePair`2<string, string>> dimensionNamesAndValues, IMetricSeriesConfiguration configuration);
    public IReadOnlyDictionary`2<string, string> get_DimensionNamesAndValues();
    [CompilerGeneratedAttribute]
public MetricIdentifier get_MetricIdentifier();
    public void TrackValue(double metricValue);
    public void TrackValue(object metricValue);
    internal void ResetAggregation();
    internal void ResetAggregation(DateTimeOffset periodStart);
    internal MetricAggregate GetCurrentAggregateUnsafe();
    internal MetricAggregate GetCurrentAggregateUnsafe(MetricAggregationCycleKind aggregationCycleKind, DateTimeOffset dateTime);
    internal void ClearAggregator(MetricAggregationCycleKind aggregationCycleKind);
    private static void TrackValue(IMetricSeriesAggregator aggregator, double metricValue, List`1& errors);
    private static void TrackValue(IMetricSeriesAggregator aggregator, object metricValue, List`1& errors);
    private static IMetricSeriesAggregator UnwrapAggregator(WeakReference`1<IMetricSeriesAggregator> aggregatorWeakRef);
    private IMetricSeriesAggregator GetOrCreatePersistentAggregator();
    private IMetricSeriesAggregator GetOrCreateAggregator(MetricAggregationCycleKind aggregationCycleKind, WeakReference`1& aggregatorWeakRef);
    private IMetricSeriesAggregator GetNewOrRecycledAggregatorInstance(MetricAggregationCycleKind aggregationCycleKind);
    private IMetricSeriesAggregator GetRecycledAggregatorInstance(MetricAggregationCycleKind aggregationCycleKind);
}
public class Microsoft.ApplicationInsights.Metrics.MetricSeriesConfigurationForMeasurement : object {
    private bool restrictToUInt32Values;
    private int hashCode;
    public bool RequiresPersistentAggregation { get; }
    public bool RestrictToUInt32Values { get; }
    private static MetricSeriesConfigurationForMeasurement();
    public MetricSeriesConfigurationForMeasurement(bool restrictToUInt32Values);
    public sealed virtual bool get_RequiresPersistentAggregation();
    public bool get_RestrictToUInt32Values();
    public sealed virtual IMetricSeriesAggregator CreateNewAggregator(MetricSeries dataSeries, MetricAggregationCycleKind aggregationCycleKind);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IMetricSeriesConfiguration other);
    public bool Equals(MetricSeriesConfigurationForMeasurement other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Microsoft.ApplicationInsights.Metrics.TelemetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static MetricManager GetMetricManager(TelemetryConfiguration telemetryPipeline);
}
internal static class Microsoft.ApplicationInsights.Metrics.Util : object {
    public static string NullString;
    private static double MicroOne;
    private static string FallbackParameterName;
    private static string sdkVersionMoniker;
    private static Util();
    public static void ValidateNotNull(object value, string name);
    public static void ValidateNotNullOrEmpty(string value, string name);
    public static void ValidateNotNullOrWhitespace(string value, string name);
    public static double EnsureConcreteValue(double x);
    public static double RoundAndValidateValue(double value);
    public static double ConvertToDoubleValue(object metricValue);
    public static DateTimeOffset RoundDownToMinute(DateTimeOffset dto);
    public static DateTimeOffset RoundDownToSecond(DateTimeOffset dto);
    public static bool FilterWillConsume(IMetricSeriesFilter seriesFilter, MetricSeries series, IMetricValueFilter& valueFilter);
    public static bool FilterWillConsume(IMetricValueFilter valueFilter, MetricSeries series, double metricValue);
    public static bool FilterWillConsume(IMetricValueFilter valueFilter, MetricSeries series, object metricValue);
    public static int CombineHashCodes(int hash1);
    public static int CombineHashCodes(int hash1, int hash2);
    public static int CombineHashCodes(int hash1, int hash2, int hash3, int hash4);
    public static int CombineHashCodes(Int32[] arr);
    public static void CopyTelemetryContext(TelemetryContext source, TelemetryContext target);
    public static void StampSdkVersionToContext(ITelemetry aggregate);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.OperationTelemetryExtensions : object {
    [ExtensionAttribute]
public static void Start(OperationTelemetry telemetry);
    [ExtensionAttribute]
public static void Start(OperationTelemetry telemetry, long timestamp);
    [ExtensionAttribute]
public static void Stop(OperationTelemetry telemetry);
    [ExtensionAttribute]
public static void Stop(OperationTelemetry telemetry, long timestamp);
    [ExtensionAttribute]
public static void GenerateOperationId(OperationTelemetry telemetry);
    private static void StopImpl(OperationTelemetry telemetry, long timestamp);
    private static void StopImpl(OperationTelemetry telemetry, TimeSpan duration);
}
internal class Microsoft.ApplicationInsights.PreciseTimestamp : object {
    internal static double StopwatchTicksToTimeSpanTicks;
    private static Timer SyncTimeUpdater;
    private static TimeSync timeSync;
    private static PreciseTimestamp();
    public static DateTimeOffset GetUtcNow();
    private static void Sync();
    private static Timer InitializeSyncTimer();
}
internal class Microsoft.ApplicationInsights.Shared.Extensibility.Implementation.BroadcastProcessor : object {
    private TelemetryDispatcher[] childrenDispatchers;
    public BroadcastProcessor(IEnumerable`1<TelemetrySink> children);
    public sealed virtual void Process(ITelemetry item);
}
internal class Microsoft.ApplicationInsights.Shared.Extensibility.Implementation.PassThroughProcessor : object {
    [CompilerGeneratedAttribute]
private TelemetrySink <Sink>k__BackingField;
    internal TelemetrySink Sink { get; }
    public PassThroughProcessor(TelemetrySink sink);
    [CompilerGeneratedAttribute]
internal TelemetrySink get_Sink();
    public sealed virtual void Process(ITelemetry item);
}
public class Microsoft.ApplicationInsights.TelemetryClient : object {
    private static string VersionPrefix;
    private TelemetryConfiguration configuration;
    private string sdkVersion;
    [CompilerGeneratedAttribute]
private TelemetryContext <Context>k__BackingField;
    public TelemetryContext Context { get; internal set; }
    public string InstrumentationKey { get; public set; }
    [EditorBrowsableAttribute("1")]
public TelemetryConfiguration TelemetryConfiguration { get; }
    public TelemetryClient(TelemetryConfiguration configuration);
    [CompilerGeneratedAttribute]
public TelemetryContext get_Context();
    [CompilerGeneratedAttribute]
internal void set_Context(TelemetryContext value);
    public string get_InstrumentationKey();
    [ObsoleteAttribute("InstrumentationKey based global ingestion is being deprecated. Recommended to set TelemetryConfiguration.ConnectionString. See https://github.com/microsoft/ApplicationInsights-dotnet/issues/2560 for more details.")]
public void set_InstrumentationKey(string value);
    public TelemetryConfiguration get_TelemetryConfiguration();
    public bool IsEnabled();
    public void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, IDictionary`2<string, string> properties);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary`2<string, string> properties);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary`2<string, string> properties);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackException(ExceptionTelemetry telemetry);
    [ObsoleteAttribute("Please use a different overload of TrackDependency")]
public void TrackDependency(string dependencyName, string data, DateTimeOffset startTime, TimeSpan duration, bool success);
    public void TrackDependency(string dependencyTypeName, string dependencyName, string data, DateTimeOffset startTime, TimeSpan duration, bool success);
    public void TrackDependency(string dependencyTypeName, string target, string dependencyName, string data, DateTimeOffset startTime, TimeSpan duration, string resultCode, bool success);
    public void TrackDependency(DependencyTelemetry telemetry);
    public void TrackAvailability(string name, DateTimeOffset timeStamp, TimeSpan duration, string runLocation, bool success, string message, IDictionary`2<string, string> properties, IDictionary`2<string, double> metrics);
    public void TrackAvailability(AvailabilityTelemetry telemetry);
    [EditorBrowsableAttribute("1")]
public void Track(ITelemetry telemetry);
    [EditorBrowsableAttribute("1")]
public void InitializeInstrumentationKey(ITelemetry telemetry);
    [EditorBrowsableAttribute("1")]
public void Initialize(ITelemetry telemetry);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(string name, DateTimeOffset startTime, TimeSpan duration, string responseCode, bool success);
    public void TrackRequest(RequestTelemetry request);
    public void Flush();
    public Task`1<bool> FlushAsync(CancellationToken cancellationToken);
    public Metric GetMetric(string metricId);
    public Metric GetMetric(string metricId, MetricConfiguration metricConfiguration);
    public Metric GetMetric(string metricId, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    public Metric GetMetric(string metricId, string dimension1Name);
    public Metric GetMetric(string metricId, string dimension1Name, MetricConfiguration metricConfiguration);
    public Metric GetMetric(string metricId, string dimension1Name, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, MetricConfiguration metricConfiguration);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name, MetricConfiguration metricConfiguration);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, MetricConfiguration metricConfiguration);
    public Metric GetMetric(string metricId, string dimension1Name, string dimension2Name, string dimension3Name, string dimension4Name, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    public Metric GetMetric(MetricIdentifier metricIdentifier);
    public Metric GetMetric(MetricIdentifier metricIdentifier, MetricConfiguration metricConfiguration);
    public Metric GetMetric(MetricIdentifier metricIdentifier, MetricConfiguration metricConfiguration, MetricAggregationScope aggregationScope);
    private Metric GetOrCreateMetric(MetricAggregationScope aggregationScope, MetricIdentifier metricIdentifier, MetricConfiguration metricConfiguration);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.TelemetryClientExtensions : object {
    private static string ChildActivityName;
    [ExtensionAttribute]
public static IOperationHolder`1<T> StartOperation(TelemetryClient telemetryClient, string operationName);
    [ExtensionAttribute]
public static IOperationHolder`1<T> StartOperation(TelemetryClient telemetryClient, string operationName, string operationId, string parentOperationId);
    [ExtensionAttribute]
public static IOperationHolder`1<T> StartOperation(TelemetryClient telemetryClient, T operationTelemetry);
    [ExtensionAttribute]
public static void StopOperation(TelemetryClient telemetryClient, IOperationHolder`1<T> operation);
    [ExtensionAttribute]
public static IOperationHolder`1<T> StartOperation(TelemetryClient telemetryClient, Activity activity);
    private static T ActivityToTelemetry(Activity activity);
    private static Activity CopyFromCompatibleRoot(Activity from);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.FormattableString : object {
    private string format;
    private Object[] args;
    public FormattableString(string format, Object[] args);
    public static string Invariant(FormattableString formattableString);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
}
internal class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] args);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
