[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.Authorization.AddAuthorizationBuilderAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool IsCompatibleWithAuthorizationBuilder(IInvocationOperation invocation, AuthorizationOptionsTypes authorizationOptionsTypes);
    private static bool TryGetConfigureArgumentOperation(IInvocationOperation invocation, IArgumentOperation& configureArgumentOperation);
    private static bool TryGetConfigureDelegateCreationOperation(IArgumentOperation configureArgumentOperation, IDelegateCreationOperation& configureDelegateCreationOperation);
    private static bool TryGetConfigureAnonymousFunctionOperation(IDelegateCreationOperation configureDelegateCreationOperation, IAnonymousFunctionOperation& configureAnonymousFunctionOperation);
    private static bool TryGetConfigureBlockOperation(IAnonymousFunctionOperation configureAnonymousFunctionOperation, IBlockOperation& configureBlockOperation);
    private static bool DoesOperationInvolveAuthorizationOptions(IOperation operation, AuthorizationOptionsTypes authorizationOptionsTypes);
    private static bool IsConfigureActionCompatibleWithAuthorizationBuilder(IBlockOperation configureAction, AuthorizationOptionsTypes authorizationOptionsTypes);
    private static bool UsesAuthorizationOptionsSpecificGetters(IOperation operation, AuthorizationOptionsTypes authorizationOptionsTypes);
    private static bool UsesAuthorizationOptionsGetPolicy(IOperation operation, AuthorizationOptionsTypes authorizationOptionsTypes);
    private static bool IsLastCallInChain(IInvocationOperation invocation);
    private static void AddDiagnosticInformation(OperationAnalysisContext context, Location location);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.Authorization.AuthorizationOptionsTypes : object {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <AuthorizationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <DefaultPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <FallbackPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <InvokeHandlersAfterFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetPolicy>k__BackingField;
    public INamedTypeSymbol AuthorizationOptions { get; }
    public IPropertySymbol DefaultPolicy { get; }
    public IPropertySymbol FallbackPolicy { get; }
    public IPropertySymbol InvokeHandlersAfterFailure { get; }
    public IMethodSymbol GetPolicy { get; }
    public bool HasRequiredTypes { get; }
    [NullableContextAttribute("1")]
public AuthorizationOptionsTypes(WellKnownTypes wellKnownTypes);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_AuthorizationOptions();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_DefaultPolicy();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_FallbackPolicy();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_InvokeHandlersAfterFailure();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_GetPolicy();
    public bool get_HasRequiredTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.DiagnosticDescriptors : object {
    internal static DiagnosticDescriptor DoNotUseModelBindingAttributesOnRouteHandlerParameters;
    internal static DiagnosticDescriptor DoNotReturnActionResultsFromRouteHandlers;
    internal static DiagnosticDescriptor DetectMisplacedLambdaAttribute;
    internal static DiagnosticDescriptor DoNotUseNonLiteralSequenceNumbers;
    internal static DiagnosticDescriptor DetectMismatchedParameterOptionality;
    internal static DiagnosticDescriptor DoNotUseConfigureWebHostWithConfigureHostBuilder;
    internal static DiagnosticDescriptor DoNotUseConfigureWithConfigureWebHostBuilder;
    internal static DiagnosticDescriptor DoNotUseUseStartupWithConfigureWebHostBuilder;
    internal static DiagnosticDescriptor DoNotUseHostConfigureLogging;
    internal static DiagnosticDescriptor DoNotUseHostConfigureServices;
    internal static DiagnosticDescriptor DisallowConfigureAppConfigureHostBuilder;
    internal static DiagnosticDescriptor UseTopLevelRouteRegistrationsInsteadOfUseEndpoints;
    internal static DiagnosticDescriptor UseHeaderDictionaryPropertiesInsteadOfIndexer;
    internal static DiagnosticDescriptor DoNotReturnValueFromRequestDelegate;
    internal static DiagnosticDescriptor RoutePatternIssue;
    internal static DiagnosticDescriptor RoutePatternUnusedParameter;
    internal static DiagnosticDescriptor DoNotUseIHeaderDictionaryAdd;
    internal static DiagnosticDescriptor RouteParameterComplexTypeIsNotParsable;
    internal static DiagnosticDescriptor BindAsyncSignatureMustReturnValueTaskOfT;
    internal static DiagnosticDescriptor AmbiguousRouteHandlerRoute;
    internal static DiagnosticDescriptor AmbiguousActionRoute;
    internal static DiagnosticDescriptor AtMostOneFromBodyAttribute;
    internal static DiagnosticDescriptor UseAddAuthorizationBuilder;
    private static DiagnosticDescriptors();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.Http.HeaderDictionaryAddAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool IsAddMethod(IMethodSymbol method);
    private static void AddDiagnosticWarning(OperationAnalysisContext context, Location location);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.Http.HeaderDictionaryIndexerAnalyzer : DiagnosticAnalyzer {
    internal static Dictionary`2<string, string> PropertyMapping;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static HeaderDictionaryIndexerAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsIHeadersDictionaryType(INamedTypeSymbol type);
    private static void AddDiagnosticWarning(OperationAnalysisContext context, Location location, string headerName, string propertyName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.Http.RequestDelegateReturnTypeAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void AddDiagnosticWarning(OperationAnalysisContext context, Location location, ITypeSymbol returnType);
    private static IOperation WalkDownConversion(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.AmbiguousRoutePatternComparer : object {
    [CompilerGeneratedAttribute]
private static AmbiguousRoutePatternComparer <Instance>k__BackingField;
    public static AmbiguousRoutePatternComparer Instance { get; }
    private static AmbiguousRoutePatternComparer();
    [CompilerGeneratedAttribute]
public static AmbiguousRoutePatternComparer get_Instance();
    public sealed virtual bool Equals(RoutePatternTree x, RoutePatternTree y);
    private static bool Equals(RoutePatternSegmentNode x, RoutePatternSegmentNode y);
    private static bool IgnoreCaseEquals(object value1, object value2);
    private static bool Equals(RoutePatternParameterNode x, RoutePatternParameterNode y);
    private static bool Equals(RoutePatternPolicyParameterPartNode x, RoutePatternPolicyParameterPartNode y);
    public sealed virtual int GetHashCode(RoutePatternTree obj);
}
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.AnalyzerDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
}
internal enum Microsoft.AspNetCore.Analyzers.Infrastructure.Bindability : Enum {
    public int value__;
    public static Bindability Bindable;
    public static Bindability NotBindable;
    public static Bindability InvalidReturnType;
}
internal enum Microsoft.AspNetCore.Analyzers.Infrastructure.BindabilityMethod : Enum {
    public int value__;
    public static BindabilityMethod IBindableFromHttpContext;
    public static BindabilityMethod BindAsync;
    public static BindabilityMethod BindAsyncWithParameter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.BoundedCacheWithFactory`2 : object {
    private List`1<WeakReference`1<Entry<TKey, TValue>>> _weakReferencedEntries;
    public TValue GetOrCreateValue(TKey key, Func`2<TKey, TValue> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedDiagnostic : ValueType {
    public string Message;
    public TextSpan Span;
    public EmbeddedDiagnostic(string message, TextSpan span);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmbeddedDiagnostic other);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static bool op_Equality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
    public static bool op_Inequality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSeparatedSyntaxNodeList`3 : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> <NodesAndTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeparatorLength>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static EmbeddedSeparatedSyntaxNodeList`3<TSyntaxKind, TSyntaxNode, TDerivedNode> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> NodesAndTokens { get; }
    public int Length { get; }
    public int SeparatorLength { get; }
    [NullableAttribute("1")]
public TDerivedNode Item { get; }
    public EmbeddedSeparatedSyntaxNodeList`3(ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> nodesAndTokens);
    private static EmbeddedSeparatedSyntaxNodeList`3();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> get_NodesAndTokens();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public int get_SeparatorLength();
    [ConditionalAttribute("DEBUG")]
private void Verify();
    [NullableContextAttribute("1")]
public TDerivedNode get_Item(int index);
    public Enumerator<TSyntaxKind, TSyntaxNode, TDerivedNode> GetEnumerator();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxHelpers : object {
    public static TextSpan GetSpan(EmbeddedSyntaxToken`1<TSyntaxKind> token1, EmbeddedSyntaxToken`1<TSyntaxKind> token2);
    public static TextSpan GetSpan(VirtualCharSequence virtualChars);
    public static TextSpan GetSpan(VirtualChar firstChar, VirtualChar lastChar);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RoutePatternNode GetChildNode(RoutePatternNode node, RoutePatternKind kind);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxNode`2 : object {
    public TSyntaxKind Kind;
    private Nullable`1<TextSpan> _fullSpan;
    internal int ChildCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> Item { get; }
    protected EmbeddedSyntaxNode`2(TSyntaxKind kind);
    internal abstract virtual int get_ChildCount();
    internal abstract virtual EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> ChildAt(int index);
    public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> get_Item(int index);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    private Nullable`1<TextSpan> ComputeFullSpan();
    private void GetSpan(Int32& start, Int32& end);
    public bool Contains(VirtualChar virtualChar);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToFullString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb);
    public Enumerator<TSyntaxKind, TSyntaxNode> GetEnumerator();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeStart|10_0();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeEnd|10_1();
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxNodeOrToken`2 : ValueType {
    private EmbeddedSyntaxToken`1<TSyntaxKind> _token;
    [NullableAttribute("2")]
public TSyntaxNode Node;
    public EmbeddedSyntaxToken`1<TSyntaxKind> Token { get; }
    public TSyntaxKind Kind { get; }
    [MemberNotNullWhenAttribute("True", "Node")]
public bool IsNode { get; }
    private EmbeddedSyntaxNodeOrToken`2(TSyntaxNode node);
    private EmbeddedSyntaxNodeOrToken`2(EmbeddedSyntaxToken`1<TSyntaxKind> token);
    [IsReadOnlyAttribute]
public EmbeddedSyntaxToken`1<TSyntaxKind> get_Token();
    public TSyntaxKind get_Kind();
    [MemberNotNullWhenAttribute("True", "Node")]
public bool get_IsNode();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("2")]
public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(TSyntaxNode node);
    public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(EmbeddedSyntaxToken`1<TSyntaxKind> token);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxToken`1 : ValueType {
    public TSyntaxKind Kind;
    public VirtualCharSequence VirtualChars;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    [NullableAttribute("2")]
public object Value;
    public bool IsMissing { get; }
    public EmbeddedSyntaxToken`1(TSyntaxKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, object value);
    public bool get_IsMissing();
    public EmbeddedSyntaxToken`1<TSyntaxKind> AddDiagnosticIfNone(EmbeddedDiagnostic diagnostic);
    public EmbeddedSyntaxToken`1<TSyntaxKind> WithDiagnostics(ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public EmbeddedSyntaxToken`1<TSyntaxKind> With(Optional`1<TSyntaxKind> kind, Optional`1<VirtualCharSequence> virtualChars, Optional`1<ImmutableArray`1<EmbeddedDiagnostic>> diagnostics, Optional`1<object> value);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb);
}
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxTree`3 : object {
    public VirtualCharSequence Text;
    [NullableAttribute("1")]
public TCompilationUnitSyntax Root;
    public ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    protected EmbeddedSyntaxTree`3(VirtualCharSequence text, TCompilationUnitSyntax root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.EmbeddedSyntax.EmbeddedSyntaxTrivia`1 : ValueType {
    public TSyntaxKind Kind;
    public VirtualCharSequence VirtualChars;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    public EmbeddedSyntaxTrivia`1(TSyntaxKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public TextSpan GetSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal enum Microsoft.AspNetCore.Analyzers.Infrastructure.Parsability : Enum {
    public int value__;
    public static Parsability Parsable;
    public static Parsability NotParsable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.ParsabilityHelper : object {
    private static BoundedCacheWithFactory`2<ITypeSymbol, ValueTuple`2<Nullable`1<BindabilityMethod>, IMethodSymbol>> BindabilityCache;
    private static BoundedCacheWithFactory`2<ITypeSymbol, ValueTuple`2<Parsability, Nullable`1<ParsabilityMethod>>> ParsabilityCache;
    private static ParsabilityHelper();
    private static bool IsTypeAlwaysParsable(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes, Nullable`1& parsabilityMethod);
    internal static Parsability GetParsability(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    internal static Parsability GetParsability(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes, Nullable`1& parsabilityMethod);
    private static bool IsTryParse(IMethodSymbol methodSymbol);
    private static bool IsTryParseWithFormat(IMethodSymbol methodSymbol, WellKnownTypes wellKnownTypes);
    internal static bool IsParsableViaIParsable(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    private static bool IsBindableViaIBindableFromHttpContext(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    private static bool IsBindAsync(IMethodSymbol methodSymbol, ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    private static bool IsBindAsyncWithParameter(IMethodSymbol methodSymbol, ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    private static bool IsReturningValueTaskOfTOrNullableT(INamedTypeSymbol returnType, ITypeSymbol containingType, WellKnownTypes wellKnownTypes);
    internal static Bindability GetBindability(ITypeSymbol typeSymbol, WellKnownTypes wellKnownTypes, Nullable`1& bindabilityMethod, IMethodSymbol& bindMethodSymbol);
}
internal enum Microsoft.AspNetCore.Analyzers.Infrastructure.ParsabilityMethod : Enum {
    public int value__;
    public static ParsabilityMethod String;
    public static ParsabilityMethod IParsable;
    public static ParsabilityMethod Enum;
    public static ParsabilityMethod TryParse;
    public static ParsabilityMethod TryParseWithFormatProvider;
    public static ParsabilityMethod Uri;
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.IRoutePatternNodeVisitor {
    public abstract virtual void Visit(RoutePatternCompilationUnit node);
    public abstract virtual void Visit(RoutePatternSegmentNode node);
    public abstract virtual void Visit(RoutePatternReplacementNode node);
    public abstract virtual void Visit(RoutePatternParameterNode node);
    public abstract virtual void Visit(RoutePatternLiteralNode node);
    public abstract virtual void Visit(RoutePatternSegmentSeparatorNode node);
    public abstract virtual void Visit(RoutePatternOptionalSeparatorNode node);
    public abstract virtual void Visit(RoutePatternCatchAllParameterPartNode node);
    public abstract virtual void Visit(RoutePatternNameParameterPartNode node);
    public abstract virtual void Visit(RoutePatternPolicyParameterPartNode node);
    public abstract virtual void Visit(RoutePatternPolicyFragmentEscapedNode node);
    public abstract virtual void Visit(RoutePatternPolicyFragment node);
    public abstract virtual void Visit(RoutePatternOptionalParameterPartNode node);
    public abstract virtual void Visit(RoutePatternDefaultValueParameterPartNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RouteParameter : ValueType {
    public string Name;
    public bool EncodeSlashes;
    [NullableAttribute("2")]
public string DefaultValue;
    public bool IsOptional;
    public bool IsCatchAll;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Policies;
    public TextSpan Span;
    public RouteParameter(string name, bool encodeSlashes, string defaultValue, bool isOptional, bool isCatchAll, ImmutableArray`1<string> policies, TextSpan span);
    public virtual string ToString();
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternCatchAllParameterPartNode : RoutePatternParameterPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <AsteriskToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> AsteriskToken { get; }
    internal int ChildCount { get; }
    public RoutePatternCatchAllParameterPartNode(EmbeddedSyntaxToken`1<RoutePatternKind> asteriskToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_AsteriskToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternCompilationUnit : RoutePatternNode {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RoutePatternRootPartNode> <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <EndOfFileToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<RoutePatternRootPartNode> Parts { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> EndOfFileToken { get; }
    internal int ChildCount { get; }
    public RoutePatternCompilationUnit(ImmutableArray`1<RoutePatternRootPartNode> parts, EmbeddedSyntaxToken`1<RoutePatternKind> endOfFileToken);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RoutePatternRootPartNode> get_Parts();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_EndOfFileToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternDefaultValueParameterPartNode : RoutePatternParameterPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <EqualsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <DefaultValueToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> EqualsToken { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> DefaultValueToken { get; }
    internal int ChildCount { get; }
    public RoutePatternDefaultValueParameterPartNode(EmbeddedSyntaxToken`1<RoutePatternKind> equalsToken, EmbeddedSyntaxToken`1<RoutePatternKind> defaultValueToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_EqualsToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_DefaultValueToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternHelpers : object {
    public static EmbeddedSyntaxToken`1<RoutePatternKind> CreateToken(RoutePatternKind kind, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxToken`1<RoutePatternKind> CreateMissingToken(RoutePatternKind kind);
    [ExtensionAttribute]
public static bool TryGetNode(EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> nodeOrToken, TSyntaxKind kind, TSyntaxNode& node);
}
internal enum Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternKind : Enum {
    public int value__;
    public static RoutePatternKind None;
    public static RoutePatternKind EndOfFile;
    public static RoutePatternKind Segment;
    public static RoutePatternKind CompilationUnit;
    public static RoutePatternKind Separator;
    public static RoutePatternKind Literal;
    public static RoutePatternKind Replacement;
    public static RoutePatternKind Parameter;
    public static RoutePatternKind CatchAll;
    public static RoutePatternKind ParameterName;
    public static RoutePatternKind Optional;
    public static RoutePatternKind DefaultValue;
    public static RoutePatternKind PolicyFragment;
    public static RoutePatternKind PolicyFragmentEscaped;
    public static RoutePatternKind ParameterPolicy;
    public static RoutePatternKind TextToken;
    public static RoutePatternKind SlashToken;
    public static RoutePatternKind TildeToken;
    public static RoutePatternKind OpenBraceToken;
    public static RoutePatternKind CloseBraceToken;
    public static RoutePatternKind OpenBracketToken;
    public static RoutePatternKind CloseBracketToken;
    public static RoutePatternKind DotToken;
    public static RoutePatternKind EqualsToken;
    public static RoutePatternKind ColonToken;
    public static RoutePatternKind ReplacementToken;
    public static RoutePatternKind AsteriskToken;
    public static RoutePatternKind OpenParenToken;
    public static RoutePatternKind CloseParenToken;
    public static RoutePatternKind QuestionMarkToken;
    public static RoutePatternKind CommaToken;
    public static RoutePatternKind ParameterNameToken;
    public static RoutePatternKind DefaultValueToken;
    public static RoutePatternKind PolicyNameToken;
    public static RoutePatternKind PolicyFragmentToken;
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternLexer : ValueType {
    public VirtualCharSequence Text;
    [NullableAttribute("1")]
public RoutePatternOptions RoutePatternOptions;
    public int Position;
    private static char Separator;
    private static char OpenBrace;
    private static char CloseBrace;
    private static char QuestionMark;
    private static char Asterisk;
    public VirtualChar CurrentChar { get; }
    [NullableContextAttribute("1")]
public RoutePatternLexer(VirtualCharSequence text, RoutePatternOptions routePatternOptions);
    public VirtualChar get_CurrentChar();
    public VirtualCharSequence GetSubPatternToCurrentPos(int start);
    public VirtualCharSequence GetSubPattern(int start, int end);
    public EmbeddedSyntaxToken`1<RoutePatternKind> ScanNextToken();
    private static RoutePatternKind GetKind(VirtualChar ch);
    public TextSpan GetTextSpan(int startInclusive, int endExclusive);
    [NullableContextAttribute("1")]
public bool IsAt(string val);
    private bool TextAt(int position, string val);
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanLiteral();
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanParameterName();
    private bool IsTrailingQuestionMark(VirtualChar ch);
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanUnescapedPolicyFragment();
    internal bool IsUnescapedChar(Int32& position, char c);
    internal bool IsUnescapedCharLookahead(Int32& position, char c);
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanEscapedPolicyFragment();
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanReplacementToken();
    internal Nullable`1<EmbeddedSyntaxToken`1<RoutePatternKind>> TryScanDefaultValue();
    internal bool HasPolicyParenClose();
    [CompilerGeneratedAttribute]
internal static bool <TryScanParameterName>g__IsInvalidNameChar|19_0(VirtualChar ch);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternLiteralNode : RoutePatternSegmentPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <LiteralToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> LiteralToken { get; }
    internal int ChildCount { get; }
    public RoutePatternLiteralNode(EmbeddedSyntaxToken`1<RoutePatternKind> literalToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_LiteralToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternNameParameterPartNode : RoutePatternParameterPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <ParameterNameToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> ParameterNameToken { get; }
    internal int ChildCount { get; }
    public RoutePatternNameParameterPartNode(EmbeddedSyntaxToken`1<RoutePatternKind> parameterNameToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_ParameterNameToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternNode : EmbeddedSyntaxNode`2<RoutePatternKind, RoutePatternNode> {
    protected RoutePatternNode(RoutePatternKind kind);
    public abstract virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternOptionalParameterPartNode : RoutePatternParameterPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <QuestionMarkToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> QuestionMarkToken { get; }
    internal int ChildCount { get; }
    public RoutePatternOptionalParameterPartNode(EmbeddedSyntaxToken`1<RoutePatternKind> questionMarkToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_QuestionMarkToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternOptionalSeparatorNode : RoutePatternSegmentPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <SeparatorToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> SeparatorToken { get; }
    internal int ChildCount { get; }
    public RoutePatternOptionalSeparatorNode(EmbeddedSyntaxToken`1<RoutePatternKind> separatorToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_SeparatorToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternOptions : object {
    [CompilerGeneratedAttribute]
private bool <SupportTokenReplacement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportComplexSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportDefaultValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTwoAsteriskCatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <AdditionalInvalidParameterCharacters>k__BackingField;
    public static RoutePatternOptions DefaultRoute;
    public static RoutePatternOptions MvcAttributeRoute;
    public static RoutePatternOptions ComponentsRoute;
    public bool SupportTokenReplacement { get; private set; }
    public bool SupportComplexSegments { get; private set; }
    public bool SupportDefaultValues { get; private set; }
    public bool SupportTwoAsteriskCatchAll { get; private set; }
    [NullableAttribute("2")]
public Char[] AdditionalInvalidParameterCharacters { get; private set; }
    private static RoutePatternOptions();
    [CompilerGeneratedAttribute]
public bool get_SupportTokenReplacement();
    [CompilerGeneratedAttribute]
private void set_SupportTokenReplacement(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportComplexSegments();
    [CompilerGeneratedAttribute]
private void set_SupportComplexSegments(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportDefaultValues();
    [CompilerGeneratedAttribute]
private void set_SupportDefaultValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTwoAsteriskCatchAll();
    [CompilerGeneratedAttribute]
private void set_SupportTwoAsteriskCatchAll(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Char[] get_AdditionalInvalidParameterCharacters();
    [CompilerGeneratedAttribute]
private void set_AdditionalInvalidParameterCharacters(Char[] value);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternParameterNode : RoutePatternSegmentPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <OpenBraceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RoutePatternParameterPartNode> <ParameterParts>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <CloseBraceToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> OpenBraceToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<RoutePatternParameterPartNode> ParameterParts { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> CloseBraceToken { get; }
    internal int ChildCount { get; }
    public RoutePatternParameterNode(EmbeddedSyntaxToken`1<RoutePatternKind> openBraceToken, ImmutableArray`1<RoutePatternParameterPartNode> parameterPartNodes, EmbeddedSyntaxToken`1<RoutePatternKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RoutePatternParameterPartNode> get_ParameterParts();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_CloseBraceToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternParameterPartNode : RoutePatternNode {
    protected RoutePatternParameterPartNode(RoutePatternKind kind);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternParser : ValueType {
    private RoutePatternLexer _lexer;
    private EmbeddedSyntaxToken`1<RoutePatternKind> _currentToken;
    private RoutePatternOptions _routePatternOptions;
    private RoutePatternParser(VirtualCharSequence text, RoutePatternOptions routePatternOptions);
    private EmbeddedSyntaxToken`1<RoutePatternKind> ConsumeCurrentToken();
    [NullableContextAttribute("1")]
public static RoutePatternTree TryParse(VirtualCharSequence text, RoutePatternOptions routePatternOptions);
    private RoutePatternTree ParseTree();
    private static void ValidateComplexSegments(RoutePatternCompilationUnit root, Builder<EmbeddedDiagnostic> diagnostics, RoutePatternOptions routePatternOptions);
    private static void ValidateAdditionalInvalidParameterCharacters(RoutePatternCompilationUnit root, Builder<EmbeddedDiagnostic> diagnostics, RoutePatternOptions routePatternOptions);
    private static void ValidateStart(RoutePatternCompilationUnit root, IList`1<EmbeddedDiagnostic> diagnostics);
    private static void ValidateCatchAllParameters(RoutePatternCompilationUnit root, IList`1<EmbeddedDiagnostic> diagnostics);
    private static void ValidateNoConsecutiveParameters(RoutePatternCompilationUnit root, IList`1<EmbeddedDiagnostic> diagnostics);
    private static void ValidateParameterParts(RoutePatternCompilationUnit root, IList`1<EmbeddedDiagnostic> diagnostics, IList`1<RouteParameter> routeParameters);
    private static void ValidateNoConsecutiveSeparators(RoutePatternCompilationUnit root, IList`1<EmbeddedDiagnostic> diagnostics);
    private static void CollectDiagnostics(RoutePatternNode node, HashSet`1<EmbeddedDiagnostic> seenDiagnostics, IList`1<EmbeddedDiagnostic> diagnostics);
    private static void AddUniqueDiagnostics(HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ImmutableArray`1<EmbeddedDiagnostic> from, IList`1<EmbeddedDiagnostic> to);
    private ImmutableArray`1<RoutePatternRootPartNode> ParseRootParts();
    private RoutePatternRootPartNode ParseRootPart();
    private RoutePatternSegmentNode ParseSegment();
    private RoutePatternSegmentPartNode ParsePart();
    private RoutePatternLiteralNode ParseLiteral();
    private void MoveBackBeforePreviousScan();
    private RoutePatternReplacementNode ParseReplacement(EmbeddedSyntaxToken`1<RoutePatternKind> openBracketToken);
    private RoutePatternParameterNode ParseParameter(EmbeddedSyntaxToken`1<RoutePatternKind> openBraceToken);
    private EmbeddedSyntaxToken`1<RoutePatternKind> ConsumeToken(RoutePatternKind kind, string error);
    private ImmutableArray`1<RoutePatternParameterPartNode> ParseParameterParts();
    private RoutePatternDefaultValueParameterPartNode ParseDefaultValue();
    private RoutePatternPolicyParameterPartNode ParsePolicy();
    private RoutePatternSegmentSeparatorNode ParseSegmentSeparator();
    private TextSpan GetTokenStartPositionSpan(EmbeddedSyntaxToken`1<RoutePatternKind> token);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternPolicyFragment : RoutePatternNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <ArgumentToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> ArgumentToken { get; }
    internal int ChildCount { get; }
    public RoutePatternPolicyFragment(EmbeddedSyntaxToken`1<RoutePatternKind> argumentToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_ArgumentToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternPolicyFragmentEscapedNode : RoutePatternNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <OpenParenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <ArgumentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <CloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> OpenParenToken { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> ArgumentToken { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> CloseParenToken { get; }
    internal int ChildCount { get; }
    public RoutePatternPolicyFragmentEscapedNode(EmbeddedSyntaxToken`1<RoutePatternKind> openParenToken, EmbeddedSyntaxToken`1<RoutePatternKind> argumentToken, EmbeddedSyntaxToken`1<RoutePatternKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_OpenParenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_ArgumentToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_CloseParenToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternPolicyParameterPartNode : RoutePatternParameterPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <ColonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RoutePatternNode> <PolicyFragments>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> ColonToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<RoutePatternNode> PolicyFragments { get; }
    internal int ChildCount { get; }
    public RoutePatternPolicyParameterPartNode(EmbeddedSyntaxToken`1<RoutePatternKind> colonToken, ImmutableArray`1<RoutePatternNode> policyFragments);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_ColonToken();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RoutePatternNode> get_PolicyFragments();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternReplacementNode : RoutePatternSegmentPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <OpenBracketToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <TextToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <CloseBracketToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> OpenBracketToken { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> TextToken { get; }
    public EmbeddedSyntaxToken`1<RoutePatternKind> CloseBracketToken { get; }
    internal int ChildCount { get; }
    public RoutePatternReplacementNode(EmbeddedSyntaxToken`1<RoutePatternKind> openBracketToken, EmbeddedSyntaxToken`1<RoutePatternKind> textToken, EmbeddedSyntaxToken`1<RoutePatternKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_OpenBracketToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_TextToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_CloseBracketToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternRootPartNode : RoutePatternNode {
    protected RoutePatternRootPartNode(RoutePatternKind kind);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternSegmentNode : RoutePatternRootPartNode {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RoutePatternSegmentPartNode> <Children>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<RoutePatternSegmentPartNode> Children { get; }
    internal int ChildCount { get; }
    public RoutePatternSegmentNode(ImmutableArray`1<RoutePatternSegmentPartNode> children);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RoutePatternSegmentPartNode> get_Children();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternSegmentPartNode : RoutePatternNode {
    protected RoutePatternSegmentPartNode(RoutePatternKind kind);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternSegmentSeparatorNode : RoutePatternRootPartNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RoutePatternKind> <SeparatorToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RoutePatternKind> SeparatorToken { get; }
    internal int ChildCount { get; }
    public RoutePatternSegmentSeparatorNode(EmbeddedSyntaxToken`1<RoutePatternKind> separatorToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RoutePatternKind> get_SeparatorToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RoutePatternKind, RoutePatternNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IRoutePatternNodeVisitor visitor);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.RoutePattern.RoutePatternTree : EmbeddedSyntaxTree`3<RoutePatternKind, RoutePatternNode, RoutePatternCompilationUnit> {
    public ImmutableArray`1<RouteParameter> RouteParameters;
    public RoutePatternTree(VirtualCharSequence text, RoutePatternCompilationUnit root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, ImmutableArray`1<RouteParameter> routeParameters);
    [NullableContextAttribute("1")]
public RouteParameter GetRouteParameter(string name);
    [NullableContextAttribute("1")]
public bool TryGetRouteParameter(string name, RouteParameter& routeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.AbstractVirtualCharService : object {
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    protected abstract virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    protected abstract virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected static bool IsLegalBraceEscape(string tokenText, int index, int offset, TextSpan& span);
    public sealed virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    [ConditionalAttribute("DEBUG")]
private void CheckInvariants(SyntaxToken token, VirtualCharSequence result);
    protected static VirtualCharSequence TryConvertSimpleDoubleQuoteString(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    protected static int ConvertTextAtIndexToRune(string tokenText, int index, Builder<VirtualChar> result, int offset);
    protected static int ConvertTextAtIndexToRune(SourceText tokenText, int index, Builder<VirtualChar> result, int offset);
    private static int ConvertTextAtIndexToRune(T tokenText, int index, TTextInfo info, Builder<VirtualChar> result, int offset);
    protected static bool IsOpenOrCloseBrace(char ch);
    protected static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, Builder<VirtualChar> result);
}
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.CSharpVirtualCharService : AbstractVirtualCharService {
    [NullableAttribute("1")]
public static IVirtualCharService Instance;
    private static CSharpVirtualCharService();
    protected virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    private static bool IsInDirective(SyntaxNode node);
    private static VirtualCharSequence TryConvertVerbatimStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence TryConvertSingleLineRawStringToVirtualChars(SyntaxToken token);
    private static VirtualCharSequence TryConvertMultiLineRawStringToVirtualChars(SyntaxToken token, ExpressionSyntax parentExpression, bool tokenIncludeDelimiters);
    private static VirtualCharSequence TryConvertStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, List`1<ValueTuple`2<char, TextSpan>> charResults);
    private static void ConvertCharactersToRunes(List`1<ValueTuple`2<char, TextSpan>> charResults, Builder<VirtualChar> runeResults);
    private static bool TryAddEscape(List`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    public virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    private static bool TryAddSingleCharacterEscape(List`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(List`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(List`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index, char character);
    private static int HexValue(char c);
    private static bool IsHexDigit(char c);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.Extensions : object {
    [ExtensionAttribute]
public static bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    public static bool TryGetEscapeCharacter(Rune rune, Char& escapedChar);
    private static bool TryGetEscapeCharacter(int value, Char& escapedChar);
}
internal interface Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.IVirtualCharService {
    public abstract virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapeChar);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.TextLineExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(TextLine line);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.VirtualChar : ValueType {
    public Rune Rune;
    public char SurrogateChar;
    public TextSpan Span;
    public int Value { get; }
    public bool IsDigit { get; }
    public bool IsLetterOrDigit { get; }
    public bool IsWhiteSpace { get; }
    private VirtualChar(Rune rune, char surrogateChar, TextSpan span);
    public static VirtualChar Create(Rune rune, TextSpan span);
    public static VirtualChar Create(char surrogateChar, TextSpan span);
    public int get_Value();
    public bool get_IsDigit();
    public bool get_IsLetterOrDigit();
    public bool get_IsWhiteSpace();
    public static bool op_Equality(VirtualChar char1, VirtualChar char2);
    public static bool op_Inequality(VirtualChar char1, VirtualChar char2);
    public static bool op_Equality(VirtualChar ch1, char ch2);
    public static bool op_Inequality(VirtualChar ch1, char ch2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VirtualChar other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public void AppendTo(StringBuilder builder);
    public sealed virtual int CompareTo(VirtualChar other);
    public static bool op_LessThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public sealed virtual int CompareTo(char other);
    public static bool op_LessThan(VirtualChar ch1, char ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, char ch2);
    public static bool op_GreaterThan(VirtualChar ch1, char ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, char ch2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Analyzers.Infrastructure.VirtualChars.VirtualCharSequence : ValueType {
    public static VirtualCharSequence Empty;
    private Chunk _leafCharacters;
    private TextSpan _span;
    public int Length { get; }
    public VirtualChar Item { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    public bool IsDefaultOrEmpty { get; }
    private VirtualCharSequence(Chunk sequence);
    private VirtualCharSequence(Chunk sequence, TextSpan span);
    private static VirtualCharSequence();
    internal static int BinarySearch(ImmutableList`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    public static VirtualCharSequence Create(ImmutableList`1<VirtualChar> virtualChars);
    public static VirtualCharSequence Create(int firstVirtualCharPosition, string underlyingData);
    public int get_Length();
    public VirtualChar get_Item(int index);
    public bool get_IsDefault();
    public bool get_IsEmpty();
    public bool get_IsDefaultOrEmpty();
    public VirtualCharSequence GetSubSequence(TextSpan span);
    public Enumerator GetEnumerator();
    public VirtualChar First();
    public VirtualChar Last();
    public Nullable`1<VirtualChar> Find(int position);
    public bool Contains(VirtualChar char);
    public int IndexOf(VirtualChar char);
    public Nullable`1<VirtualChar> FirstOrNull(Func`2<VirtualChar, bool> predicate);
    public Nullable`1<VirtualChar> LastOrNull(Func`2<VirtualChar, bool> predicate);
    public bool Any(Func`2<VirtualChar, bool> predicate);
    public bool All(Func`2<VirtualChar, bool> predicate);
    public VirtualCharSequence Skip(int count);
    public VirtualCharSequence SkipWhile(Func`2<VirtualChar, bool> predicate);
    public string CreateString();
    [ConditionalAttribute("DEBUG")]
public void AssertAdjacentTo(VirtualCharSequence virtualChars);
    public static VirtualCharSequence FromBounds(VirtualCharSequence chars1, VirtualCharSequence chars2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.Mvc.MvcAnalyzer : DiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static WellKnownType[] RouteAttributeTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MvcAnalyzer();
    private static void DetectAmbiguousActionRoutes(SymbolAnalysisContext context, WellKnownTypes wellKnownTypes, RoutePatternTree controllerRoutePattern, List`1<ActionRoute> actionRoutes);
    private static bool HasActionToken(RoutePatternTree routePattern);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void PopulateActionRoutes(SymbolAnalysisContext context, WellKnownTypes wellKnownTypes, RouteUsageCache routeUsageCache, INamedTypeSymbol namedTypeSymbol, List`1<ActionRoute> actionRoutes);
    private static ImmutableArray`1<string> GetUnroutedMethodHttpMethods(WellKnownTypes wellKnownTypes, IMethodSymbol methodSymbol);
    private static string GetHttpMethod(WellKnownType match);
    private static RouteUsageModel GetRouteUsageModel(AttributeData attribute, RouteUsageCache routeUsageCache, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.RenderTreeBuilder.RenderTreeBuilderAnalyzer : DiagnosticAnalyzer {
    private static int SequenceParameterOrdinal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static bool IsRenderTreeBuilderMethodWithSequenceParameter(WellKnownTypes wellKnownTypes, IMethodSymbol targetMethod);
}
internal static class Microsoft.AspNetCore.Analyzers.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string TemplateRoute_CannotHaveCatchAllInMultiSegment { get; }
    internal static string TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveParameters { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveSeparators { get; }
    internal static string TemplateRoute_CatchAllCannotBeOptional { get; }
    internal static string TemplateRoute_OptionalCannotHaveDefaultValue { get; }
    internal static string TemplateRoute_CatchAllMustBeLast { get; }
    internal static string TemplateRoute_InvalidLiteral { get; }
    internal static string TemplateRoute_InvalidParameterName { get; }
    internal static string TemplateRoute_InvalidRouteTemplate { get; }
    internal static string TemplateRoute_MismatchedParameter { get; }
    internal static string TemplateRoute_RepeatedParameter { get; }
    internal static string TemplateRoute_UnescapedBrace { get; }
    internal static string TemplateRoute_OptionalParameterCanbBePrecededByPeriod { get; }
    internal static string TemplateRoute_OptionalParameterHasTobeTheLast { get; }
    internal static string TemplateRoute_Exception { get; }
    internal static string AttributeRoute_TokenReplacement_EmptyTokenNotAllowed { get; }
    internal static string AttributeRoute_TokenReplacement_ImbalancedSquareBrackets { get; }
    internal static string AttributeRoute_TokenReplacement_UnclosedToken { get; }
    internal static string AttributeRoute_TokenReplacement_UnescapedBraceInToken { get; }
    internal static string Analyzer_HeaderDictionaryIndexer_Message { get; }
    internal static string Analyzer_HeaderDictionaryIndexer_Title { get; }
    internal static string Analyzer_RequestDelegateReturnValue_Message { get; }
    internal static string Analyzer_RequestDelegateReturnValue_Title { get; }
    internal static string Analyzer_RouteIssue_Message { get; }
    internal static string Analyzer_RouteIssue_Title { get; }
    internal static string Analyzer_UnusedParameter_Message { get; }
    internal static string Analyzer_UnusedParameter_Title { get; }
    internal static string Analyzer_HeaderDictionaryAdd_Message { get; }
    internal static string Analyzer_HeaderDictionaryAdd_Title { get; }
    internal static string Analyzer_MultipleFromBody_Message { get; }
    internal static string Analyzer_MultipleFromBody_Title { get; }
    internal static string Analyzer_DoNotUseModelBindingAttributesOnRouteHandlerParameters_Title { get; }
    internal static string Analyzer_DoNotUseModelBindingAttributesOnRouteHandlerParameters_Message { get; }
    internal static string Analyzer_DoNotReturnActionResultsFromRouteHandlers_Title { get; }
    internal static string Analyzer_DoNotReturnActionResultsFromRouteHandlers_Message { get; }
    internal static string Analyzer_DetectMisplacedLambdaAttribute_Title { get; }
    internal static string Analyzer_DetectMisplacedLambdaAttribute_Message { get; }
    internal static string Analyzer_DoNotUseNonLiteralSequenceNumbers_Title { get; }
    internal static string Analyzer_DoNotUseNonLiteralSequenceNumbers_Message { get; }
    internal static string Analyzer_DetectMismatchedParameterOptionality_Title { get; }
    internal static string Analyzer_DetectMismatchedParameterOptionality_Message { get; }
    internal static string Analyzer_DoNotUseConfigureWebHostWithConfigureHostBuilder_Title { get; }
    internal static string Analyzer_DoNotUseConfigureWebHostWithConfigureHostBuilder_Message { get; }
    internal static string Analyzer_DoNotUseConfigureWithConfigureWebHostBuilder_Title { get; }
    internal static string Analyzer_DoNotUseConfigureWithConfigureWebHostBuilder_Message { get; }
    internal static string Analyzer_DoNotUseUseStartupWithConfigureWebHostBuilder_Title { get; }
    internal static string Analyzer_DoNotUseUseStartupWithConfigureWebHostBuilder_Message { get; }
    internal static string Analyzer_DoNotUseHostConfigureLogging_Title { get; }
    internal static string Analyzer_DoNotUseHostConfigureLogging_Message { get; }
    internal static string Analyzer_DoNotUseHostConfigureServices_Title { get; }
    internal static string Analyzer_DoNotUseHostConfigureServices_Message { get; }
    internal static string Analyzer_DisallowConfigureAppConfigureHostBuilder_Title { get; }
    internal static string Analyzer_DisallowConfigureAppConfigureHostBuilder_Message { get; }
    internal static string Analyzer_UseTopLevelRouteRegistrationsInsteadOfUseEndpoints_Title { get; }
    internal static string Analyzer_UseTopLevelRouteRegistrationsInsteadOfUseEndpoints_Message { get; }
    internal static string Analyzer_RouteParameterComplexTypeIsNotParsable_Title { get; }
    internal static string Analyzer_RouteParameterComplexTypeIsNotParsable_Message { get; }
    internal static string Analyzer_BindAsyncSignatureMustReturnValueTaskOfT_Title { get; }
    internal static string Analyzer_BindAsyncSignatureMustReturnValueTaskOfT_Message { get; }
    internal static string Analyzer_AmbiguousRouteHandlerRoute_Title { get; }
    internal static string Analyzer_AmbiguousRouteHandlerRoute_Message { get; }
    internal static string Analyzer_AmbiguousActionRoute_Title { get; }
    internal static string Analyzer_AmbiguousActionRoute_Message { get; }
    internal static string Analyzer_UseAddAuthorizationBuilder_Message { get; }
    internal static string Analyzer_UseAddAuthorizationBuilder_Title { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_TemplateRoute_CannotHaveCatchAllInMultiSegment();
    internal static string get_TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly();
    internal static string FormatTemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly(object p0);
    internal static string get_TemplateRoute_CannotHaveConsecutiveParameters();
    internal static string get_TemplateRoute_CannotHaveConsecutiveSeparators();
    internal static string get_TemplateRoute_CatchAllCannotBeOptional();
    internal static string get_TemplateRoute_OptionalCannotHaveDefaultValue();
    internal static string get_TemplateRoute_CatchAllMustBeLast();
    internal static string get_TemplateRoute_InvalidLiteral();
    internal static string FormatTemplateRoute_InvalidLiteral(object p0);
    internal static string get_TemplateRoute_InvalidParameterName();
    internal static string FormatTemplateRoute_InvalidParameterName(object p0);
    internal static string get_TemplateRoute_InvalidRouteTemplate();
    internal static string get_TemplateRoute_MismatchedParameter();
    internal static string get_TemplateRoute_RepeatedParameter();
    internal static string FormatTemplateRoute_RepeatedParameter(object p0);
    internal static string get_TemplateRoute_UnescapedBrace();
    internal static string get_TemplateRoute_OptionalParameterCanbBePrecededByPeriod();
    internal static string FormatTemplateRoute_OptionalParameterCanbBePrecededByPeriod(object p0, object p1, object p2);
    internal static string get_TemplateRoute_OptionalParameterHasTobeTheLast();
    internal static string FormatTemplateRoute_OptionalParameterHasTobeTheLast(object p0, object p1, object p2);
    internal static string get_TemplateRoute_Exception();
    internal static string FormatTemplateRoute_Exception(object p0, object p1);
    internal static string get_AttributeRoute_TokenReplacement_EmptyTokenNotAllowed();
    internal static string get_AttributeRoute_TokenReplacement_ImbalancedSquareBrackets();
    internal static string get_AttributeRoute_TokenReplacement_UnclosedToken();
    internal static string get_AttributeRoute_TokenReplacement_UnescapedBraceInToken();
    internal static string get_Analyzer_HeaderDictionaryIndexer_Message();
    internal static string FormatAnalyzer_HeaderDictionaryIndexer_Message(object p0, object p1);
    internal static string get_Analyzer_HeaderDictionaryIndexer_Title();
    internal static string get_Analyzer_RequestDelegateReturnValue_Message();
    internal static string FormatAnalyzer_RequestDelegateReturnValue_Message(object p0);
    internal static string get_Analyzer_RequestDelegateReturnValue_Title();
    internal static string get_Analyzer_RouteIssue_Message();
    internal static string FormatAnalyzer_RouteIssue_Message(object p0);
    internal static string get_Analyzer_RouteIssue_Title();
    internal static string get_Analyzer_UnusedParameter_Message();
    internal static string FormatAnalyzer_UnusedParameter_Message(object p0);
    internal static string get_Analyzer_UnusedParameter_Title();
    internal static string get_Analyzer_HeaderDictionaryAdd_Message();
    internal static string get_Analyzer_HeaderDictionaryAdd_Title();
    internal static string get_Analyzer_MultipleFromBody_Message();
    internal static string get_Analyzer_MultipleFromBody_Title();
    internal static string get_Analyzer_DoNotUseModelBindingAttributesOnRouteHandlerParameters_Title();
    internal static string get_Analyzer_DoNotUseModelBindingAttributesOnRouteHandlerParameters_Message();
    internal static string FormatAnalyzer_DoNotUseModelBindingAttributesOnRouteHandlerParameters_Message(object p0, object p1);
    internal static string get_Analyzer_DoNotReturnActionResultsFromRouteHandlers_Title();
    internal static string get_Analyzer_DoNotReturnActionResultsFromRouteHandlers_Message();
    internal static string FormatAnalyzer_DoNotReturnActionResultsFromRouteHandlers_Message(object p0);
    internal static string get_Analyzer_DetectMisplacedLambdaAttribute_Title();
    internal static string get_Analyzer_DetectMisplacedLambdaAttribute_Message();
    internal static string FormatAnalyzer_DetectMisplacedLambdaAttribute_Message(object p0);
    internal static string get_Analyzer_DoNotUseNonLiteralSequenceNumbers_Title();
    internal static string get_Analyzer_DoNotUseNonLiteralSequenceNumbers_Message();
    internal static string FormatAnalyzer_DoNotUseNonLiteralSequenceNumbers_Message(object p0);
    internal static string get_Analyzer_DetectMismatchedParameterOptionality_Title();
    internal static string get_Analyzer_DetectMismatchedParameterOptionality_Message();
    internal static string FormatAnalyzer_DetectMismatchedParameterOptionality_Message(object p0);
    internal static string get_Analyzer_DoNotUseConfigureWebHostWithConfigureHostBuilder_Title();
    internal static string get_Analyzer_DoNotUseConfigureWebHostWithConfigureHostBuilder_Message();
    internal static string get_Analyzer_DoNotUseConfigureWithConfigureWebHostBuilder_Title();
    internal static string get_Analyzer_DoNotUseConfigureWithConfigureWebHostBuilder_Message();
    internal static string get_Analyzer_DoNotUseUseStartupWithConfigureWebHostBuilder_Title();
    internal static string get_Analyzer_DoNotUseUseStartupWithConfigureWebHostBuilder_Message();
    internal static string get_Analyzer_DoNotUseHostConfigureLogging_Title();
    internal static string get_Analyzer_DoNotUseHostConfigureLogging_Message();
    internal static string FormatAnalyzer_DoNotUseHostConfigureLogging_Message(object p0);
    internal static string get_Analyzer_DoNotUseHostConfigureServices_Title();
    internal static string get_Analyzer_DoNotUseHostConfigureServices_Message();
    internal static string FormatAnalyzer_DoNotUseHostConfigureServices_Message(object p0);
    internal static string get_Analyzer_DisallowConfigureAppConfigureHostBuilder_Title();
    internal static string get_Analyzer_DisallowConfigureAppConfigureHostBuilder_Message();
    internal static string FormatAnalyzer_DisallowConfigureAppConfigureHostBuilder_Message(object p0);
    internal static string get_Analyzer_UseTopLevelRouteRegistrationsInsteadOfUseEndpoints_Title();
    internal static string get_Analyzer_UseTopLevelRouteRegistrationsInsteadOfUseEndpoints_Message();
    internal static string FormatAnalyzer_UseTopLevelRouteRegistrationsInsteadOfUseEndpoints_Message(object p0);
    internal static string get_Analyzer_RouteParameterComplexTypeIsNotParsable_Title();
    internal static string get_Analyzer_RouteParameterComplexTypeIsNotParsable_Message();
    internal static string FormatAnalyzer_RouteParameterComplexTypeIsNotParsable_Message(object p0, object p1);
    internal static string get_Analyzer_BindAsyncSignatureMustReturnValueTaskOfT_Title();
    internal static string get_Analyzer_BindAsyncSignatureMustReturnValueTaskOfT_Message();
    internal static string FormatAnalyzer_BindAsyncSignatureMustReturnValueTaskOfT_Message(object p0, object p1);
    internal static string get_Analyzer_AmbiguousRouteHandlerRoute_Title();
    internal static string get_Analyzer_AmbiguousRouteHandlerRoute_Message();
    internal static string FormatAnalyzer_AmbiguousRouteHandlerRoute_Message(object p0);
    internal static string get_Analyzer_AmbiguousActionRoute_Title();
    internal static string get_Analyzer_AmbiguousActionRoute_Message();
    internal static string FormatAnalyzer_AmbiguousActionRoute_Message(object p0);
    internal static string get_Analyzer_UseAddAuthorizationBuilder_Message();
    internal static string get_Analyzer_UseAddAuthorizationBuilder_Title();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("RoutePatternCompletionProvider", "C#")]
[SharedAttribute]
public class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.FrameworkParametersCompletionProvider : CompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string NewPositionKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static FrameworkParametersCompletionProvider();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.FrameworkParametersCompletionProvider/<ProvideCompletionsAsync>d__12")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static bool IsArgumentTypeToken(SyntaxToken token);
    private static Nullable`1<SyntaxToken> TryGetMvcActionRouteToken(CompletionContext context, SemanticModel semanticModel, MethodDeclarationSyntax method);
    private static SyntaxNode TryFindMvcActionParameter(SyntaxNode node);
    private static SyntaxNode TryFindMinimalApiArgument(SyntaxNode node);
    private static bool HasNonRouteAttribute(SyntaxToken token, SemanticModel semanticModel, WellKnownTypes wellKnownTypes, CancellationToken cancellationToken);
    private static bool IsCurrentParameterBindable(SyntaxToken token, SemanticModel semanticModel, WellKnownTypes wellKnownTypes, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetExistingParameterNames(SyntaxNode node);
    private static void ProvideCompletions(EmbeddedCompletionContext context, Nullable`1<SyntaxToken> parentOpt);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.EmbeddedLanguageCommentDetector : ValueType {
    private Regex _regex;
    public EmbeddedLanguageCommentDetector(ImmutableArray`1<string> identifiers);
    [NullableContextAttribute("1")]
public bool TryMatch(string text, String& identifier, IEnumerable`1& options);
}
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.EmbeddedLanguageCommentOptions`1 : object {
    private static Dictionary`2<string, TOptions> s_nameToOption;
    private static EmbeddedLanguageCommentOptions`1();
    public static bool TryGetOptions(IEnumerable`1<string> captures, TOptions& options);
    private static TOptions CombineOptions(TOptions options, TOptions specificOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.MapMethodParts : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private LiteralExpressionSyntax <RouteStringExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <DelegateExpression>k__BackingField;
    public IMethodSymbol Method { get; public set; }
    public LiteralExpressionSyntax RouteStringExpression { get; public set; }
    public ExpressionSyntax DelegateExpression { get; public set; }
    public MapMethodParts(IMethodSymbol Method, LiteralExpressionSyntax RouteStringExpression, ExpressionSyntax DelegateExpression);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Method(IMethodSymbol value);
    [CompilerGeneratedAttribute]
public LiteralExpressionSyntax get_RouteStringExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RouteStringExpression(LiteralExpressionSyntax value);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_DelegateExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DelegateExpression(ExpressionSyntax value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MapMethodParts left, MapMethodParts right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MapMethodParts left, MapMethodParts right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MapMethodParts other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IMethodSymbol& Method, LiteralExpressionSyntax& RouteStringExpression, ExpressionSyntax& DelegateExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.MvcDetector : object {
    public static bool IsController(INamedTypeSymbol typeSymbol, WellKnownTypes wellKnownTypes);
    public static bool IsAction(IMethodSymbol methodSymbol, WellKnownTypes wellKnownTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.ParameterSymbol : ValueType {
    [CompilerGeneratedAttribute]
private string <RouteParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <TopLevelSymbol>k__BackingField;
    public string RouteParameterName { get; public set; }
    public ISymbol Symbol { get; public set; }
    [NullableAttribute("2")]
public ISymbol TopLevelSymbol { get; public set; }
    public bool IsNested { get; }
    public ParameterSymbol(string RouteParameterName, ISymbol Symbol, ISymbol TopLevelSymbol);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RouteParameterName();
    [CompilerGeneratedAttribute]
public void set_RouteParameterName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public void set_Symbol(ISymbol value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISymbol get_TopLevelSymbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TopLevelSymbol(ISymbol value);
    public bool get_IsNested();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ParameterSymbol left, ParameterSymbol right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ParameterSymbol left, ParameterSymbol right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParameterSymbol other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& RouteParameterName, ISymbol& Symbol, ISymbol& TopLevelSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RoutePatternParametersDetector : object {
    public static ImmutableArray`1<ParameterSymbol> ResolvedParameters(ISymbol symbol, WellKnownTypes wellKnownTypes);
    public static ImmutableArray`1<ISymbol> GetParameterSymbols(ISymbol symbol);
    private static bool HasSpecialType(ISymbol child, WellKnownTypes wellKnownTypes, WellKnownType[] specialTypes);
    private static bool HasExplicitNonRouteAttribute(ISymbol child, WellKnownTypes wellKnownTypes, WellKnownType[] allNoneRouteMetadataTypes);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ParameterSymbol> <ResolvedParameters>g__ResolvedParametersCore|0_0(ISymbol symbol, ISymbol topLevelSymbol, WellKnownTypes wellKnownTypes);
    [CompilerGeneratedAttribute]
internal static string <ResolvedParameters>g__ResolveRouteParameterName|0_1(ISymbol parameterSymbol, WellKnownTypes wellKnownTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RouteStringSyntaxDetector : object {
    private static EmbeddedLanguageCommentDetector _commentDetector;
    private static RouteStringSyntaxDetector();
    public static bool IsRouteStringSyntaxToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, RouteOptions& options);
    private static bool IsAnyStringLiteral(int rawKind);
    private static bool TryGetStringFormat(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, String& identifier, IEnumerable`1& options);
    private static bool HasLanguageComment(SyntaxToken token, String& identifier, IEnumerable`1& options);
    private static bool HasLanguageComment(SyntaxTriviaList list, String& identifier, IEnumerable`1& options);
    private static bool HasLanguageComment(SyntaxTrivia trivia, String& identifier, IEnumerable`1& options);
    [NullableContextAttribute("2")]
public static bool IsStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRegularComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirective(SyntaxTrivia trivia);
    [NullableContextAttribute("2")]
public static bool IsEqualsValueOfPropertyDeclaration(SyntaxNode node);
    private static SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    private static bool IsFieldOrPropertyWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode left, CancellationToken cancellationToken, String& identifier);
    public static void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxNode& right);
    public static void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    private static bool IsArgumentWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken, String& identifier);
    public static bool IsArgumentToAttributeParameterWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken, String& identifier);
    [NullableContextAttribute("2")]
public static bool IsFieldOrPropertyWithMatchingStringSyntaxAttribute(ISymbol symbol, String& identifier);
    [NullableContextAttribute("2")]
public static bool HasMatchingStringSyntaxAttribute(ISymbol symbol, String& identifier);
    private static bool IsMatchingStringSyntaxAttribute(AttributeData attribute, String& identifier);
    private static ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    private static IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, CancellationToken cancellationToken);
    private static IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(AttributeArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public static ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RouteUsageContext : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <RouteToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <MethodSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteUsageType <UsageType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ISymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ParameterSymbol> <ResolvedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <HttpMethods>k__BackingField;
    public SyntaxToken RouteToken { get; public set; }
    public IMethodSymbol MethodSymbol { get; public set; }
    public SyntaxNode MethodSyntax { get; public set; }
    public RouteUsageType UsageType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> Parameters { get; public set; }
    [NullableAttribute("0")]
public ImmutableArray`1<ParameterSymbol> ResolvedParameters { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> HttpMethods { get; public set; }
    [NullableAttribute("1")]
public RoutePatternOptions RoutePatternOptions { get; }
    public RouteUsageContext(SyntaxToken RouteToken, IMethodSymbol MethodSymbol, SyntaxNode MethodSyntax, RouteUsageType UsageType, ImmutableArray`1<ISymbol> Parameters, ImmutableArray`1<ParameterSymbol> ResolvedParameters, ImmutableArray`1<string> HttpMethods);
    [CompilerGeneratedAttribute]
public SyntaxToken get_RouteToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RouteToken(SyntaxToken value);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodSymbol();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MethodSymbol(IMethodSymbol value);
    [CompilerGeneratedAttribute]
public SyntaxNode get_MethodSyntax();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MethodSyntax(SyntaxNode value);
    [CompilerGeneratedAttribute]
public RouteUsageType get_UsageType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UsageType(RouteUsageType value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ISymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Parameters(ImmutableArray`1<ISymbol> value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<ParameterSymbol> get_ResolvedParameters();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResolvedParameters(ImmutableArray`1<ParameterSymbol> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_HttpMethods();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HttpMethods(ImmutableArray`1<string> value);
    [NullableContextAttribute("1")]
public RoutePatternOptions get_RoutePatternOptions();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RouteUsageContext left, RouteUsageContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RouteUsageContext left, RouteUsageContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RouteUsageContext other);
    [CompilerGeneratedAttribute]
public void Deconstruct(SyntaxToken& RouteToken, IMethodSymbol& MethodSymbol, SyntaxNode& MethodSyntax, RouteUsageType& UsageType, ImmutableArray`1& Parameters, ImmutableArray`1& ResolvedParameters, ImmutableArray`1& HttpMethods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RouteUsageDetector : object {
    public static RouteUsageContext BuildContext(RouteOptions routeOptions, SyntaxToken token, SemanticModel semanticModel, WellKnownTypes wellKnownTypes, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> CalculateHttpMethods(WellKnownTypes wellKnownTypes, IMethodSymbol mapMethodSymbol);
    private static SyntaxNode FindAttributeParent(SyntaxNode container);
    private static IMethodSymbol FindMvcMethod(WellKnownTypes wellKnownTypes, IMethodSymbol methodSymbol);
    public static Nullable`1<MapMethodParts> FindMapMethodParts(SemanticModel semanticModel, WellKnownTypes wellKnownTypes, SyntaxNode container, CancellationToken cancellationToken);
    private static Nullable`1<MapMethodParts> FindValidMapMethodParts(SemanticModel semanticModel, WellKnownTypes wellKnownTypes, BaseArgumentListSyntax argumentList, IMethodSymbol method);
    private static ArgumentSyntax GetArgumentSyntax(BaseArgumentListSyntax argumentList, IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
    private static IMethodSymbol GetMethodInfo(SemanticModel semanticModel, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
internal enum Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RouteUsageType : Enum {
    public int value__;
    public static RouteUsageType Other;
    public static RouteUsageType MinimalApi;
    public static RouteUsageType MvcAction;
    public static RouteUsageType MvcController;
    public static RouteUsageType Component;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.RouteWellKnownTypes : object {
    public static WellKnownType[] ParameterSpecialTypes;
    public static WellKnownType[] NonRouteMetadataTypes;
    private static RouteWellKnownTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.SymbolExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol UnwrapTypeSymbol(ITypeSymbol typeSymbol, bool unwrapArray, bool unwrapNullable);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.SymbolExtensions/<GetThisAndBaseTypes>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetThisAndBaseTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static bool HasAttribute(ImmutableArray`1<AttributeData> attributes, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static bool TryGetAttribute(ImmutableArray`1<AttributeData> attributes, INamedTypeSymbol attributeType, AttributeData& matchedAttribute);
    [ExtensionAttribute]
public static bool HasAttributeImplementingInterface(ISymbol symbol, INamedTypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool TryGetAttributeImplementingInterface(ISymbol symbol, INamedTypeSymbol interfaceType, AttributeData& matchedAttribute);
    [ExtensionAttribute]
public static bool HasAttributeImplementingInterface(ImmutableArray`1<AttributeData> attributes, INamedTypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool TryGetAttributeImplementingInterface(ImmutableArray`1<AttributeData> attributes, INamedTypeSymbol interfaceType, AttributeData& matchedAttribute);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool IsType(INamedTypeSymbol type, string typeName, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsType(INamedTypeSymbol type, INamedTypeSymbol otherType);
    [ExtensionAttribute]
public static ITypeSymbol GetParameterType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static bool IsOptional(IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
public static bool IsOptional(IPropertySymbol propertySymbol);
    [ExtensionAttribute]
public static string GetDefaultValueString(IParameterSymbol parameterSymbol);
    private static string InnerGetDefaultValueString(object defaultValue);
    [ExtensionAttribute]
public static bool TryGetNamedArgumentValue(AttributeData attribute, string argumentName, T& argumentValue);
    [ExtensionAttribute]
public static string GetParameterInfoFromConstructorCode(IParameterSymbol parameterSymbol);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.SyntaxNodeExtensions : object {
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> FindSkippedTokenBackwardFunc;
    private static SyntaxNodeExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxNode node);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static bool IsLiteralExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsBinaryExpression(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode WalkUpParentheses(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnyInitializerExpression(SyntaxNode node, SyntaxNode& creationExpression);
    [ExtensionAttribute]
public static bool IsSimpleAssignmentStatement(SyntaxNode statement);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    private static SyntaxToken GetInitialToken(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    private static SyntaxToken FindSkippedTokenBackward(SyntaxTriviaList triviaList, int position);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.Infrastructure.SyntaxTokenExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode TryFindContainer(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxToken token);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RouteOptions : Enum {
    public int value__;
    public static RouteOptions Http;
    public static RouteOptions Component;
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternAnalyzer : DiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    private static void AnalyzeToken(SemanticModelAnalysisContext context, RouteUsageCache routeUsageCache, SyntaxToken token, CancellationToken cancellationToken);
    private static Nullable`1<InsertPoint> CalculateInsertPoint(string routeParameterName, ImmutableArray`1<RouteParameter> routeParameters, ImmutableArray`1<ParameterSymbol> resolvedParameterSymbols);
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
}
[ExportAspNetCoreEmbeddedLanguageBraceMatcherAttribute("Route", "C#")]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternBraceMatcher : object {
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<AspNetCoreBraceMatchingResult> FindBraces(SemanticModel semanticModel, SyntaxToken token, int position, CancellationToken cancellationToken);
    private static Nullable`1<AspNetCoreBraceMatchingResult> GetMatchingBraces(RoutePatternTree tree, int position);
    private static Nullable`1<AspNetCoreBraceMatchingResult> FindParameterBraces(RoutePatternTree tree, VirtualChar ch);
    private static Nullable`1<AspNetCoreBraceMatchingResult> FindPolicyParens(RoutePatternTree tree, VirtualChar ch);
    private static Nullable`1<AspNetCoreBraceMatchingResult> FindReplacementTokenBrackets(RoutePatternTree tree, VirtualChar ch);
    private static RoutePatternParameterNode FindParameterNode(RoutePatternNode node, VirtualChar ch);
    private static RoutePatternPolicyFragmentEscapedNode FindPolicyFragmentEscapedNode(RoutePatternNode node, VirtualChar ch);
    private static RoutePatternReplacementNode FindReplacementNode(RoutePatternNode node, VirtualChar ch);
    private static TNode FindNode(RoutePatternNode node, VirtualChar ch, Func`3<TNode, VirtualChar, bool> predicate);
    private static Nullable`1<AspNetCoreBraceMatchingResult> CreateResult(EmbeddedSyntaxToken`1<RoutePatternKind> open, EmbeddedSyntaxToken`1<RoutePatternKind> close);
}
[ExportAspNetCoreEmbeddedLanguageClassifierAttribute("Route", "C#")]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternClassifier : object {
    public sealed virtual void RegisterClassifications(AspNetCoreEmbeddedLanguageClassificationContext context);
    private static void AddClassifications(RoutePatternNode node, Visitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("RoutePatternCompletionProvider", "C#")]
[SharedAttribute]
public class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternCompletionProvider : CompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string NewPositionKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static RoutePatternCompletionProvider();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternCompletionProvider/<ProvideCompletionsAsync>d__12")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void ProvideCompletions(EmbeddedCompletionContext context);
    private static Nullable`1<ValueTuple`2<RoutePatternNode, EmbeddedSyntaxToken`1<RoutePatternKind>>> GetCurrentToken(EmbeddedCompletionContext context);
    private static void ProvideParameterCompletions(EmbeddedCompletionContext context, RoutePatternNode parentOpt);
    private static void ProvidePolicyNameCompletions(EmbeddedCompletionContext context, RoutePatternNode parentOpt);
    private static Nullable`1<ValueTuple`2<RoutePatternNode, EmbeddedSyntaxToken`1<RoutePatternKind>>> FindToken(RoutePatternNode parent, VirtualChar ch);
}
[ExportAspNetCoreEmbeddedLanguageDocumentHighlighterAttribute("Route", "C#")]
internal class Microsoft.AspNetCore.Analyzers.RouteEmbeddedLanguage.RoutePatternHighlighter : object {
    public sealed virtual ImmutableArray`1<AspNetCoreDocumentHighlights> GetDocumentHighlights(SemanticModel semanticModel, SyntaxToken token, int position, CancellationToken cancellationToken);
    private static ImmutableArray`1<AspNetCoreDocumentHighlights> GetHighlights(RouteUsageModel routeUsage, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static void HighlightSymbol(SemanticModel semanticModel, IMethodSymbol methodSymbol, IList`1<AspNetCoreHighlightSpan> highlightSpans, ISymbol matchingParameter, CancellationToken cancellationToken);
    private static RoutePatternNameParameterPartNode FindParameterNode(RoutePatternNode node, VirtualChar ch);
    private static TNode FindNode(RoutePatternNode node, VirtualChar ch, Func`3<TNode, VirtualChar, bool> predicate);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.RouteHandlers.RouteHandlerAnalyzer : DiagnosticAnalyzer {
    private static int DelegateParameterOrdinal;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static void AtMostOneFromBodyAttribute(OperationAnalysisContext& context, WellKnownTypes wellKnownTypes, IMethodSymbol methodSymbol);
    private static void DetectAmbiguousRoutes(OperationBlockAnalysisContext& context, WellKnownTypes wellKnownTypes, ConcurrentDictionary`2<MapOperation, byte> mapOperations);
    private static IOperation ResolveOperation(IOperation operation, WellKnownTypes wellKnownTypes);
    private static bool IsAllowedEndpointBuilderMethod(IInvocationOperation invocationOperation, WellKnownTypes wellKnownTypes);
    private static void DetectMismatchedParameterOptionality(OperationAnalysisContext& context, RouteUsageModel routeUsage, IMethodSymbol methodSymbol);
    private static void DetectMisplacedLambdaAttribute(OperationAnalysisContext& context, IAnonymousFunctionOperation lambda);
    private static void DisallowMvcBindArgumentsOnParameters(OperationAnalysisContext& context, WellKnownTypes wellKnownTypes, IInvocationOperation invocation, IMethodSymbol methodSymbol);
    private static void DisallowNonParsableComplexTypesOnParameters(OperationAnalysisContext& context, WellKnownTypes wellKnownTypes, RouteUsageModel routeUsage, IMethodSymbol methodSymbol);
    private static void DisallowReturningActionResultFromMapMethods(OperationAnalysisContext& context, WellKnownTypes wellKnownTypes, IInvocationOperation invocationOperation, IAnonymousFunctionOperation anonymousFunction, SyntaxNode nodeForError);
    private static void DisallowReturningActionResultFromMapMethods(OperationAnalysisContext& context, WellKnownTypes wellKnownTypes, IInvocationOperation invocationOperation, IMethodSymbol methodSymbol, IBlockOperation methodBody, SyntaxNode nodeForError);
    private static ITypeSymbol UnwrapPossibleAsyncReturnType(ITypeSymbol returnType);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static bool TryGetStringToken(IInvocationOperation invocation, SyntaxToken& token);
    private static bool IsRouteHandlerInvocation(WellKnownTypes wellKnownTypes, IInvocationOperation invocation, IMethodSymbol targetMethod);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <AtMostOneFromBodyAttribute>g__ReportDiagnostics|0_2(OperationAnalysisContext context, IEnumerable`1<ISymbol> symbols);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <DetectMisplacedLambdaAttribute>g__IsInValidNamespace|6_0(INamespaceSymbol namespace);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IMethodSymbol <DetectMisplacedLambdaAttribute>g__GetReturnedInvocation|6_1(IBlockOperation blockOperation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <DisallowNonParsableComplexTypesOnParameters>g__IsRouteParameter|8_0(RouteUsageModel routeUsage, IParameterSymbol handlerDelegateParameter);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <DisallowNonParsableComplexTypesOnParameters>g__ReportFromAttributeDiagnostic|8_1(OperationAnalysisContext context, WellKnownType fromMetadataInterfaceType, WellKnownTypes wellKnownTypes, IParameterSymbol parameter, INamedTypeSymbol parameterTypeSymbol, Location location);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static INamedTypeSymbol <DisallowNonParsableComplexTypesOnParameters>g__ResovleParameterTypeSymbol|8_2(IParameterSymbol parameterSymbol);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsRouteHandlerInvocation>g__IsCompatibleDelegateType|18_0(WellKnownTypes wellKnownTypes, IMethodSymbol targetMethod);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.AspNetCore.Analyzers.WebApplicationBuilder.WebApplicationBuilderAnalyzer : DiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static bool IsDisallowedMethod(OperationAnalysisContext& context, IInvocationOperation invocation, IMethodSymbol methodSymbol, INamedTypeSymbol disallowedReceiverType, string disallowedMethodName, INamedTypeSymbol[] disallowedMethodTypes);
    private static bool HasInvocationInBody(string disallowedMethodName, IInvocationOperation invocation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static Diagnostic <Initialize>g__CreateDiagnostic|3_2(DiagnosticDescriptor descriptor, IInvocationOperation operation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsDisallowedMethod>g__IsDisallowedMethod|4_0(IMethodSymbol methodSymbol, string disallowedMethodName, INamedTypeSymbol[] disallowedMethodTypes);
}
internal class Microsoft.AspNetCore.App.Analyzers.Infrastructure.RouteUsageCache : object {
    private static BoundedCacheWithFactory`2<Compilation, RouteUsageCache> LazyRouteUsageCache;
    private ConcurrentDictionary`2<SyntaxToken, RouteUsageModel> _lazyRoutePatterns;
    private Compilation _compilation;
    private RouteUsageCache(Compilation compilation);
    private static RouteUsageCache();
    [NullableContextAttribute("1")]
public static RouteUsageCache GetOrCreate(Compilation compilation);
    [NullableContextAttribute("2")]
public RouteUsageModel Get(SyntaxToken syntaxToken, CancellationToken cancellationToken);
    private RouteUsageModel GetAndCache(SyntaxToken syntaxToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.App.Analyzers.Infrastructure.RouteUsageModel : object {
    [CompilerGeneratedAttribute]
private RoutePatternTree <RoutePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteUsageContext <UsageContext>k__BackingField;
    public RoutePatternTree RoutePattern { get; public set; }
    public RouteUsageContext UsageContext { get; public set; }
    [CompilerGeneratedAttribute]
public RoutePatternTree get_RoutePattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RoutePattern(RoutePatternTree value);
    [CompilerGeneratedAttribute]
public RouteUsageContext get_UsageContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UsageContext(RouteUsageContext value);
}
internal static class Microsoft.AspNetCore.App.Analyzers.Infrastructure.WellKnownTypeData : object {
    [NullableAttribute("1")]
public static String[] WellKnownTypeNames;
    private static WellKnownTypeData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.App.Analyzers.Infrastructure.WellKnownTypes : object {
    private static BoundedCacheWithFactory`2<Compilation, WellKnownTypes> LazyWellKnownTypesCache;
    private INamedTypeSymbol[] _lazyWellKnownTypes;
    private Compilation _compilation;
    private static WellKnownTypes();
    private WellKnownTypes(Compilation compilation);
    public static WellKnownTypes GetOrCreate(Compilation compilation);
    [ConditionalAttribute("DEBUG")]
private static void AssertEnumAndTableInSync();
    public INamedTypeSymbol Get(SpecialType type);
    public INamedTypeSymbol Get(WellKnownType type);
    private INamedTypeSymbol GetAndCache(int index);
    private INamedTypeSymbol GetTypeByMetadataNameInTargetAssembly(string metadataName);
    public bool IsType(ITypeSymbol type, WellKnownType[] wellKnownTypes);
    public bool IsType(ITypeSymbol type, WellKnownType[] wellKnownTypes, Nullable`1& match);
    public bool Implements(ITypeSymbol type, WellKnownType[] interfaceWellKnownTypes);
    public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Shared.MvcFacts : object {
    public static bool IsController(INamedTypeSymbol type, INamedTypeSymbol controllerAttribute, INamedTypeSymbol nonControllerAttribute);
    public static bool IsControllerAction(IMethodSymbol method, INamedTypeSymbol nonActionAttribute, IMethodSymbol disposableDispose);
    private static INamedTypeSymbol GetDeclaringType(IMethodSymbol method);
    private static bool IsIDisposableDispose(IMethodSymbol method, IMethodSymbol disposableDispose);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeAnalysisExtensions : object {
    [ExtensionAttribute]
public static bool HasAttribute(ITypeSymbol typeSymbol, ITypeSymbol attribute, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(IMethodSymbol methodSymbol, ITypeSymbol attribute, bool inherit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeAnalysisExtensions/<GetAttributes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, ITypeSymbol attribute);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeAnalysisExtensions/<GetAttributes>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(IMethodSymbol methodSymbol, ITypeSymbol attribute, bool inherit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeAnalysisExtensions/<GetAttributes>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ITypeSymbol typeSymbol, ITypeSymbol attribute, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(IPropertySymbol propertySymbol, ITypeSymbol attribute, bool inherit);
    [ExtensionAttribute]
public static bool IsAssignableFrom(ITypeSymbol source, ITypeSymbol target);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, ITypeSymbol attribute);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeAnalysisExtensions/<GetTypeHierarchy>d__8")]
[ExtensionAttribute]
private static IEnumerable`1<ITypeSymbol> GetTypeHierarchy(ITypeSymbol typeSymbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeAnalysisExtensions/<GetAllMethodSymbolsOfPartialParts>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetAllMethodSymbolsOfPartialParts(IMethodSymbol method);
    [ExtensionAttribute]
public static INamedTypeSymbol GetReceiverType(IInvocationOperation invocation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static INamedTypeSymbol <GetReceiverType>g__GetReceiverType|10_0(SyntaxNode receiverSyntax, SemanticModel model, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Rune : ValueType {
    private static char HighSurrogateStart;
    private static char LowSurrogateStart;
    private static int HighSurrogateRange;
    private static byte IsWhiteSpaceFlag;
    private static byte IsLetterOrDigitFlag;
    private static byte UnicodeCategoryMask;
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool unused);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    private static Rune ChangeCaseCultureAware(Rune rune, CultureInfo culture, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    private static int ReadRuneFromString(string input, int index);
    public virtual string ToString();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
}
internal static class System.Text.UnicodeDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsHighSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsLowSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidScalar(UInt32 scalarValue);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidSupplementaryPlaneScalar(UInt32 scalarValue);
    private static string ToHexString(UInt32 codePoint);
}
internal static class System.Text.UnicodeUtility : object {
    public static UInt32 ReplacementChar;
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
