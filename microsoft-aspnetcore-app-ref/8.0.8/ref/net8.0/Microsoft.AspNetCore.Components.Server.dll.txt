[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.BufferWriter : ValueType {
    private IBufferWriter`1<byte> _output;
    private Span`1<byte> _span;
    private ArraySegment`1<byte> _segment;
    private int _buffered;
    private long _bytesCommitted;
    private SequencePool _sequencePool;
    private Rental _rental;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    internal IBufferWriter`1<byte> UnderlyingWriter { get; }
    internal Rental SequenceRental { get; }
    public BufferWriter(IBufferWriter`1<byte> output);
    internal BufferWriter(SequencePool sequencePool, Byte[] array);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    internal IBufferWriter`1<byte> get_UnderlyingWriter();
    internal Rental get_SequenceRental();
    public Span`1<byte> GetSpan(int sizeHint);
    public Byte& GetPointer(int sizeHint);
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    internal bool TryGetUncommittedSpan(ReadOnlySpan`1& span);
}
internal class MessagePack.ExtensionHeader : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public sbyte TypeCode { get; }
    public UInt32 Length { get; }
    public ExtensionHeader(sbyte typeCode, UInt32 length);
    public ExtensionHeader(sbyte typeCode, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    public sealed virtual bool Equals(ExtensionHeader other);
}
internal class MessagePack.ExtensionResult : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <Data>k__BackingField;
    public sbyte TypeCode { get; }
    public ReadOnlySequence`1<byte> Data { get; }
    public ExtensionHeader Header { get; }
    public ExtensionResult(sbyte typeCode, Memory`1<byte> data);
    public ExtensionResult(sbyte typeCode, ReadOnlySequence`1<byte> data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_Data();
    public ExtensionHeader get_Header();
}
internal static class MessagePack.Internal.DateTimeConstants : object {
    internal static long BclSecondsAtUnixEpoch;
    internal static int NanosecondsPerTick;
    internal static DateTime UnixEpoch;
}
internal static class MessagePack.MessagePackCode : object {
    public static byte MinFixInt;
    public static byte MaxFixInt;
    public static byte MinFixMap;
    public static byte MaxFixMap;
    public static byte MinFixArray;
    public static byte MaxFixArray;
    public static byte MinFixStr;
    public static byte MaxFixStr;
    public static byte Nil;
    public static byte NeverUsed;
    public static byte False;
    public static byte True;
    public static byte Bin8;
    public static byte Bin16;
    public static byte Bin32;
    public static byte Ext8;
    public static byte Ext16;
    public static byte Ext32;
    public static byte Float32;
    public static byte Float64;
    public static byte UInt8;
    public static byte UInt16;
    public static byte UInt32;
    public static byte UInt64;
    public static byte Int8;
    public static byte Int16;
    public static byte Int32;
    public static byte Int64;
    public static byte FixExt1;
    public static byte FixExt2;
    public static byte FixExt4;
    public static byte FixExt8;
    public static byte FixExt16;
    public static byte Str8;
    public static byte Str16;
    public static byte Str32;
    public static byte Array16;
    public static byte Array32;
    public static byte Map16;
    public static byte Map32;
    public static byte MinNegativeFixInt;
    public static byte MaxNegativeFixInt;
    public static MessagePackType ToMessagePackType(byte code);
    [NullableContextAttribute("1")]
public static string ToFormatName(byte code);
    internal static bool IsSignedInteger(byte code);
}
internal static class MessagePack.MessagePackRange : object {
    public static int MinFixNegativeInt;
    public static int MaxFixNegativeInt;
    public static int MaxFixPositiveInt;
    public static int MinFixStringLength;
    public static int MaxFixStringLength;
    public static int MaxFixMapCount;
    public static int MaxFixArrayCount;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.MessagePackReader : ValueType {
    private SequenceReader`1<byte> reader;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public int Depth { get; public set; }
    public ReadOnlySequence`1<byte> Sequence { get; }
    public SequencePosition Position { get; }
    public long Consumed { get; }
    public bool End { get; }
    public bool IsNil { get; }
    public MessagePackType NextMessagePackType { get; }
    public byte NextCode { get; }
    public MessagePackReader(ReadOnlyMemory`1<byte> memory);
    public MessagePackReader(ReadOnlySequence`1& readOnlySequence);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    public ReadOnlySequence`1<byte> get_Sequence();
    public SequencePosition get_Position();
    public long get_Consumed();
    public bool get_End();
    public bool get_IsNil();
    public MessagePackType get_NextMessagePackType();
    public byte get_NextCode();
    public MessagePackReader Clone(ReadOnlySequence`1& readOnlySequence);
    public MessagePackReader CreatePeekReader();
    public void Skip();
    internal bool TrySkip();
    public Nil ReadNil();
    public bool TryReadNil();
    public ReadOnlySequence`1<byte> ReadRaw(long length);
    public ReadOnlySequence`1<byte> ReadRaw();
    public int ReadArrayHeader();
    public bool TryReadArrayHeader(Int32& count);
    public int ReadMapHeader();
    public bool TryReadMapHeader(Int32& count);
    public bool ReadBoolean();
    public char ReadChar();
    public float ReadSingle();
    public double ReadDouble();
    public DateTime ReadDateTime();
    public DateTime ReadDateTime(ExtensionHeader header);
    public Nullable`1<ReadOnlySequence`1<byte>> ReadBytes();
    public Nullable`1<ReadOnlySequence`1<byte>> ReadStringSequence();
    public bool TryReadStringSpan(ReadOnlySpan`1& span);
    [NullableContextAttribute("1")]
public string ReadString();
    public ExtensionHeader ReadExtensionFormatHeader();
    public bool TryReadExtensionFormatHeader(ExtensionHeader& extensionHeader);
    public ExtensionResult ReadExtensionFormat();
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.MessagePackSerializationException : Exception {
    public MessagePackSerializationException(string message);
    public MessagePackSerializationException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
protected MessagePackSerializationException(SerializationInfo info, StreamingContext context);
}
internal enum MessagePack.MessagePackType : Enum {
    public byte value__;
    public static MessagePackType Unknown;
    public static MessagePackType Integer;
    public static MessagePackType Nil;
    public static MessagePackType Boolean;
    public static MessagePackType Float;
    public static MessagePackType String;
    public static MessagePackType Binary;
    public static MessagePackType Array;
    public static MessagePackType Map;
    public static MessagePackType Extension;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.MessagePackWriter : ValueType {
    private BufferWriter writer;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldSpec>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public bool OldSpec { get; public set; }
    [NullableContextAttribute("1")]
public MessagePackWriter(IBufferWriter`1<byte> writer);
    [NullableContextAttribute("1")]
internal MessagePackWriter(SequencePool sequencePool, Byte[] array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_OldSpec();
    [CompilerGeneratedAttribute]
public void set_OldSpec(bool value);
    [NullableContextAttribute("1")]
public MessagePackWriter Clone(IBufferWriter`1<byte> writer);
    public void Flush();
    public void WriteNil();
    public void WriteRaw(ReadOnlySpan`1<byte> rawMessagePackBlock);
    public void WriteRaw(ReadOnlySequence`1& rawMessagePackBlock);
    public void WriteArrayHeader(int count);
    public void WriteArrayHeader(UInt32 count);
    public void WriteMapHeader(int count);
    public void WriteMapHeader(UInt32 count);
    public void Write(byte value);
    public void WriteUInt8(byte value);
    public void Write(sbyte value);
    public void WriteInt8(sbyte value);
    public void Write(ushort value);
    public void WriteUInt16(ushort value);
    public void Write(short value);
    public void WriteInt16(short value);
    public void Write(UInt32 value);
    public void WriteUInt32(UInt32 value);
    public void Write(int value);
    public void WriteInt32(int value);
    public void Write(ulong value);
    public void WriteUInt64(ulong value);
    public void Write(long value);
    public void WriteInt64(long value);
    public void Write(bool value);
    public void Write(char value);
    public void Write(float value);
    public void Write(double value);
    public void Write(DateTime dateTime);
    [NullableContextAttribute("1")]
public void Write(Byte[] src);
    public void Write(ReadOnlySpan`1<byte> src);
    public void Write(ReadOnlySequence`1& src);
    public void WriteBinHeader(int length);
    public void WriteString(ReadOnlySequence`1& utf8stringBytes);
    public void WriteString(ReadOnlySpan`1<byte> utf8stringBytes);
    public void WriteStringHeader(int byteCount);
    [NullableContextAttribute("1")]
public void Write(string value);
    public void Write(ReadOnlySpan`1<char> value);
    public void WriteExtensionFormatHeader(ExtensionHeader extensionHeader);
    public void WriteExtensionFormat(ExtensionResult extensionData);
    public Span`1<byte> GetSpan(int length);
    public void Advance(int length);
    internal void WriteBigEndian(ushort value);
    internal void WriteBigEndian(UInt32 value);
    internal void WriteBigEndian(ulong value);
    [NullableContextAttribute("1")]
internal Byte[] FlushAndGetArray();
}
internal class MessagePack.Nil : ValueType {
    public static Nil Default;
    public static bool op_Equality(Nil left, Nil right);
    public static bool op_Inequality(Nil left, Nil right);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Nil other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal static class MessagePack.ReservedMessagePackExtensionTypeCode : object {
    public static sbyte DateTime;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.SequencePool : object {
    internal static SequencePool Shared;
    public SequencePool(int maxSize);
    public SequencePool(int maxSize, ArrayPool`1<byte> arrayPool);
    internal Rental Rent();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.SequenceReader`1 : ValueType {
    private bool usingSequence;
    private ReadOnlySequence`1<T> sequence;
    private SequencePosition currentPosition;
    private SequencePosition nextPosition;
    private ReadOnlyMemory`1<T> memory;
    private bool moreData;
    private long length;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; }
    public int CurrentSpanIndex { get; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1& sequence);
    public SequenceReader`1(ReadOnlyMemory`1<T> memory);
    public bool get_End();
    public ReadOnlySequence`1<T> get_Sequence();
    public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    public long get_Remaining();
    public long get_Length();
    public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    internal bool TryAdvance(long count);
    public bool TryCopyTo(Span`1<T> destination);
    internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
internal static class MessagePack.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryRead(SequenceReader`1& reader, SByte& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Single& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Double& value);
}
internal static class MessagePack.StringEncoding : object {
    [NullableAttribute("1")]
internal static Encoding UTF8;
}
[ExtensionAttribute]
internal static class MessagePack.Utilities : object {
    internal static bool IsMono;
    [NullableContextAttribute("1")]
internal static Byte[] GetWriterBytes(TArg arg, GetWriterBytesAction`1<TArg> action, SequencePool pool);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static Memory`1<T> GetMemoryCheckResult(IBufferWriter`1<T> bufferWriter, int size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Builder.CircuitJavaScriptInitializationMiddleware : object {
    public CircuitJavaScriptInitializationMiddleware(IOptions`1<CircuitOptions> options, RequestDelegate _);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Builder.CircuitJavaScriptInitializationMiddleware/<InvokeAsync>d__2")]
public Task InvokeAsync(HttpContext context);
}
public class Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder : object {
    [NullableContextAttribute("1")]
internal ComponentEndpointConventionBuilder(IEndpointConventionBuilder hubEndpoint, IEndpointConventionBuilder disconnectEndpoint, IEndpointConventionBuilder jsInitializersEndpoint, IEndpointConventionBuilder blazorEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void Add(Action`1<EndpointBuilder> convention);
    [NullableContextAttribute("1")]
public sealed virtual void Finally(Action`1<EndpointBuilder> finalConvention);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions : object {
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, string path);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, Action`1<HttpConnectionDispatcherOptions> configureOptions);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, string path, Action`1<HttpConnectionDispatcherOptions> configureOptions);
}
internal class Microsoft.AspNetCore.Builder.InternalServerRenderMode : InteractiveServerRenderMode {
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.ServerRazorComponentsEndpointConventionBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RazorComponentsEndpointConventionBuilder AddInteractiveServerRenderMode(RazorComponentsEndpointConventionBuilder builder);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentEndMarker : ValueType {
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    public string PrerenderId { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarker : ValueType {
    [NullableAttribute("1")]
public static string ServerMarkerType;
    [NullableAttribute("1")]
public static string WebAssemblyMarkerType;
    [NullableAttribute("1")]
public static string AutoMarkerType;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterValues>k__BackingField;
    public string Type { get; public set; }
    public string PrerenderId { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public Nullable`1<int> Sequence { get; public set; }
    public string Descriptor { get; public set; }
    public string Assembly { get; public set; }
    public string TypeName { get; public set; }
    public string ParameterDefinitions { get; public set; }
    public string ParameterValues { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(string value);
    [NullableContextAttribute("1")]
public static ComponentMarker Create(string type, bool prerendered, Nullable`1<ComponentMarkerKey> key);
    [NullableContextAttribute("1")]
public void WriteServerData(int sequence, string descriptor);
    [NullableContextAttribute("1")]
public void WriteWebAssemblyData(string assembly, string typeName, string parameterDefinitions, string parameterValues);
    public Nullable`1<ComponentEndMarker> ToEndMarker();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarkerKey : ValueType {
    [CompilerGeneratedAttribute]
private string <LocationHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedComponentKey>k__BackingField;
    public string LocationHash { get; public set; }
    [NullableAttribute("2")]
public string FormattedComponentKey { get; public set; }
    public ComponentMarkerKey(string locationHash, string formattedComponentKey);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocationHash();
    [CompilerGeneratedAttribute]
public void set_LocationHash(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FormattedComponentKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FormattedComponentKey(string value);
    public static bool op_Equality(ComponentMarkerKey left, ComponentMarkerKey right);
    public static bool op_Inequality(ComponentMarkerKey left, ComponentMarkerKey right);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(ComponentMarkerKey other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string Assembly { get; public set; }
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    public static ValueTuple`2<IList`1<ComponentParameter>, IList`1<object>> FromParameterView(ParameterView parameters);
}
internal class Microsoft.AspNetCore.Components.ComponentParametersTypeCache : object {
    [NullableContextAttribute("1")]
public Type GetParameterType(string assembly, string type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ElementReferenceJsonConverter : JsonConverter`1<ElementReference> {
    public ElementReferenceJsonConverter(ElementReferenceContext elementReferenceContext);
    public virtual ElementReference Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ElementReference value, JsonSerializerOptions options);
}
internal class Microsoft.AspNetCore.Components.Forms.DefaultAntiforgeryStateProvider : AntiforgeryStateProvider {
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
public DefaultAntiforgeryStateProvider(PersistentComponentState state);
    [NullableContextAttribute("2")]
public virtual AntiforgeryRequestToken GetAntiforgeryToken();
    public sealed virtual void Dispose();
}
internal static class Microsoft.AspNetCore.Components.JsonSerializerOptionsProvider : object {
    [NullableAttribute("1")]
public static JsonSerializerOptions Options;
}
internal class Microsoft.AspNetCore.Components.PrerenderComponentApplicationStore : object {
    [NullableAttribute("2")]
public string PersistedState { get; }
    public Dictionary`2<string, Byte[]> ExistingState { get; protected set; }
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public PrerenderComponentApplicationStore(string existingState);
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected void DeserializeState(Byte[] existingState);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PersistedState();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Byte[]> get_ExistingState();
    [CompilerGeneratedAttribute]
protected void set_ExistingState(Dictionary`2<string, Byte[]> value);
    public sealed virtual Task`1<IDictionary`2<string, Byte[]>> GetPersistedStateAsync();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    public sealed virtual Task PersistStateAsync(IReadOnlyDictionary`2<string, Byte[]> state);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ProtectedPrerenderComponentApplicationStore : PrerenderComponentApplicationStore {
    public ProtectedPrerenderComponentApplicationStore(IDataProtectionProvider dataProtectionProvider);
    public ProtectedPrerenderComponentApplicationStore(string existingState, IDataProtectionProvider dataProtectionProvider);
    protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.RootComponentOperation : object {
    public RootComponentOperationType Type { get; public set; }
    public int SsrComponentId { get; public set; }
    public Nullable`1<ComponentMarker> Marker { get; public set; }
    [JsonIgnoreAttribute]
public WebRootComponentDescriptor Descriptor { get; public set; }
    [CompilerGeneratedAttribute]
public RootComponentOperationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RootComponentOperationType value);
    [CompilerGeneratedAttribute]
public int get_SsrComponentId();
    [CompilerGeneratedAttribute]
public void set_SsrComponentId(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<ComponentMarker> get_Marker();
    [CompilerGeneratedAttribute]
public void set_Marker(Nullable`1<ComponentMarker> value);
    [CompilerGeneratedAttribute]
public WebRootComponentDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(WebRootComponentDescriptor value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.AspNetCore.Components.RootComponentOperationBatch : object {
    public long BatchId { get; public set; }
    [RequiredMemberAttribute]
public RootComponentOperation[] Operations { get; public set; }
    [CompilerGeneratedAttribute]
public long get_BatchId();
    [CompilerGeneratedAttribute]
public void set_BatchId(long value);
    [CompilerGeneratedAttribute]
public RootComponentOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(RootComponentOperation[] value);
}
[JsonConverterAttribute("System.Text.Json.Serialization.JsonStringEnumConverter`1<Microsoft.AspNetCore.Components.RootComponentOperationType>")]
internal enum Microsoft.AspNetCore.Components.RootComponentOperationType : Enum {
    public int value__;
    public static RootComponentOperationType Add;
    public static RootComponentOperationType Update;
    public static RootComponentOperationType Remove;
}
internal class Microsoft.AspNetCore.Components.RootComponentTypeCache : object {
    [NullableContextAttribute("1")]
public Type GetRootComponent(string assembly, string type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NonDefaultHubProtocolAttribute]
internal class Microsoft.AspNetCore.Components.Server.BlazorPack.BlazorPackHubProtocol : object {
    internal static string ProtocolName;
    public string Name { get; }
    public int Version { get; }
    public TransferFormat TransferFormat { get; }
    public sealed virtual string get_Name();
    public sealed virtual int get_Version();
    public sealed virtual TransferFormat get_TransferFormat();
    public sealed virtual bool IsVersionSupported(int version);
    public sealed virtual bool TryParseMessage(ReadOnlySequence`1& input, IInvocationBinder binder, HubMessage& message);
    public sealed virtual void WriteMessage(HubMessage message, IBufferWriter`1<byte> output);
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<byte> GetMessageBytes(HubMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.BlazorPack.BlazorPackHubProtocolWorker : MessagePackHubProtocolWorker {
    protected virtual object DeserializeObject(MessagePackReader& reader, Type type, string field);
    protected virtual void Serialize(MessagePackWriter& writer, Type type, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware : object {
    public ILogger`1<CircuitDisconnectMiddleware> Logger { get; }
    public CircuitRegistry Registry { get; }
    public CircuitIdFactory CircuitIdFactory { get; }
    public RequestDelegate Next { get; }
    public CircuitDisconnectMiddleware(ILogger`1<CircuitDisconnectMiddleware> logger, CircuitRegistry registry, CircuitIdFactory circuitIdFactory, RequestDelegate next);
    [CompilerGeneratedAttribute]
public ILogger`1<CircuitDisconnectMiddleware> get_Logger();
    [CompilerGeneratedAttribute]
public CircuitRegistry get_Registry();
    [CompilerGeneratedAttribute]
public CircuitIdFactory get_CircuitIdFactory();
    [CompilerGeneratedAttribute]
public RequestDelegate get_Next();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware/<Invoke>d__14")]
public Task Invoke(HttpContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.CircuitOptions : object {
    public int DisconnectedCircuitMaxRetained { get; public set; }
    public TimeSpan DisconnectedCircuitRetentionPeriod { get; public set; }
    public bool DetailedErrors { get; public set; }
    public TimeSpan JSInteropDefaultCallTimeout { get; public set; }
    public int MaxBufferedUnacknowledgedRenderBatches { get; public set; }
    public CircuitRootComponentOptions RootComponents { get; }
    internal IList`1<string> JavaScriptInitializers { get; }
    [CompilerGeneratedAttribute]
public int get_DisconnectedCircuitMaxRetained();
    [CompilerGeneratedAttribute]
public void set_DisconnectedCircuitMaxRetained(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisconnectedCircuitRetentionPeriod();
    [CompilerGeneratedAttribute]
public void set_DisconnectedCircuitRetentionPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_DetailedErrors();
    [CompilerGeneratedAttribute]
public void set_DetailedErrors(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_JSInteropDefaultCallTimeout();
    [CompilerGeneratedAttribute]
public void set_JSInteropDefaultCallTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxBufferedUnacknowledgedRenderBatches();
    [CompilerGeneratedAttribute]
public void set_MaxBufferedUnacknowledgedRenderBatches(int value);
    [CompilerGeneratedAttribute]
public CircuitRootComponentOptions get_RootComponents();
    [CompilerGeneratedAttribute]
internal IList`1<string> get_JavaScriptInitializers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.CircuitOptionsJSInteropDetailedErrorsConfiguration : object {
    public IConfiguration Configuration { get; }
    public CircuitOptionsJSInteropDetailedErrorsConfiguration(IConfiguration configuration);
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    public sealed virtual void Configure(CircuitOptions options);
}
public class Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions : object {
    [NullableAttribute("1")]
public JSComponentConfigurationStore JSComponents { get; }
    public int MaxJSRootComponents { get; public set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual JSComponentConfigurationStore get_JSComponents();
    [CompilerGeneratedAttribute]
public int get_MaxJSRootComponents();
    [CompilerGeneratedAttribute]
public void set_MaxJSRootComponents(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.ArrayBuilder`1 : object {
    protected T[] _items;
    protected int _itemsInUse;
    public int Count { get; }
    public T[] Buffer { get; }
    public ArrayBuilder`1(int minCapacity, ArrayPool`1<T> arrayPool);
    public int get_Count();
    public T[] get_Buffer();
    public int Append(T& item);
    internal int Append(T[] source, int startIndex, int length);
    internal int Append(ReadOnlySpan`1<T> source);
    public void Overwrite(int index, T& value);
    public void RemoveLast();
    public void InsertExpensive(int index, T value);
    public void Clear();
    protected void GrowBuffer(int desiredCapacity);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.ArrayBuilderMemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ArrayBuilder`1<byte> ArrayBuilder { get; }
    public ArrayBuilderMemoryStream(ArrayBuilder`1<byte> arrayBuilder);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<byte> get_ArrayBuilder();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> memory, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.Circuits.Circuit : object {
    public string Id { get; }
    internal Circuit(CircuitHost circuitHost);
    public string get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitClientProxy : object {
    public bool Connected { get; }
    public string ConnectionId { get; }
    public IClientProxy Client { get; }
    public CircuitClientProxy(IClientProxy clientProxy, string connectionId);
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [CompilerGeneratedAttribute]
public IClientProxy get_Client();
    public void Transfer(IClientProxy clientProxy, string connectionId);
    public void SetDisconnected();
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitFactory : object {
    [NullableContextAttribute("1")]
public CircuitFactory(IServiceScopeFactory scopeFactory, ILoggerFactory loggerFactory, CircuitIdFactory circuitIdFactory, IOptions`1<CircuitOptions> options);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitFactory/<CreateCircuitHostAsync>d__6")]
public sealed virtual ValueTask`1<CircuitHost> CreateCircuitHostAsync(IReadOnlyList`1<ComponentDescriptor> components, CircuitClientProxy client, string baseUri, string uri, ClaimsPrincipal user, IPersistentComponentStateStore store);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandle : object {
    public CircuitHost CircuitHost { get; public set; }
    [CompilerGeneratedAttribute]
public CircuitHost get_CircuitHost();
    [CompilerGeneratedAttribute]
public void set_CircuitHost(CircuitHost value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler : object {
    public int Order { get; }
    public virtual int get_Order();
    public virtual Task OnCircuitOpenedAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnConnectionUpAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnConnectionDownAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnCircuitClosedAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Func`2<CircuitInboundActivityContext, Task> CreateInboundActivityHandler(Func`2<CircuitInboundActivityContext, Task> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandleRegistry : object {
    public sealed virtual CircuitHandle GetCircuitHandle(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public sealed virtual CircuitHost GetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public sealed virtual void SetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey, CircuitHost circuitHost);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost : object {
    public CircuitHandle Handle { get; }
    public CircuitId CircuitId { get; }
    public Circuit Circuit { get; }
    public CircuitClientProxy Client { get; public set; }
    public RemoteJSRuntime JSRuntime { get; }
    public RemoteRenderer Renderer { get; }
    public IReadOnlyList`1<ComponentDescriptor> Descriptors { get; }
    public IServiceProvider Services { get; }
    public CircuitHost(CircuitId circuitId, AsyncServiceScope scope, CircuitOptions options, CircuitClientProxy client, RemoteRenderer renderer, IReadOnlyList`1<ComponentDescriptor> descriptors, RemoteJSRuntime jsRuntime, RemoteNavigationManager navigationManager, CircuitHandler[] circuitHandlers, ILogger logger);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public CircuitHandle get_Handle();
    [CompilerGeneratedAttribute]
public CircuitId get_CircuitId();
    [CompilerGeneratedAttribute]
public Circuit get_Circuit();
    [CompilerGeneratedAttribute]
public CircuitClientProxy get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(CircuitClientProxy value);
    [CompilerGeneratedAttribute]
public RemoteJSRuntime get_JSRuntime();
    [CompilerGeneratedAttribute]
public RemoteRenderer get_Renderer();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ComponentDescriptor> get_Descriptors();
    [CompilerGeneratedAttribute]
public IServiceProvider get_Services();
    public Task InitializeAsync(ProtectedPrerenderComponentApplicationStore store, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<DisposeAsync>d__39")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnConnectionUpAsync>d__41")]
public Task OnConnectionUpAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnConnectionDownAsync>d__42")]
public Task OnConnectionDownAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnRenderCompletedAsync>d__44")]
public Task OnRenderCompletedAsync(long renderId, string errorMessageOrNull);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<BeginInvokeDotNetFromJS>d__45")]
public Task BeginInvokeDotNetFromJS(string callId, string assemblyName, string methodIdentifier, long dotNetObjectId, string argsJson);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<EndInvokeJSFromDotNet>d__46")]
public Task EndInvokeJSFromDotNet(long asyncCall, bool succeeded, string arguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReceiveByteArray>d__47")]
internal Task ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReceiveJSDataChunk>d__48")]
internal Task`1<bool> ReceiveJSDataChunk(long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<SendDotNetStreamAsync>d__49")]
public Task`1<int> SendDotNetStreamAsync(DotNetStreamReference dotNetStreamReference, long streamId, Byte[] buffer);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<TryClaimPendingStream>d__50")]
public Task`1<DotNetStreamReference> TryClaimPendingStream(long streamId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnLocationChangedAsync>d__51")]
public Task OnLocationChangedAsync(string uri, string state, bool intercepted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnLocationChangingAsync>d__52")]
public Task OnLocationChangingAsync(int callId, string uri, string state, bool intercepted);
    public void SetCircuitUser(ClaimsPrincipal user);
    public void SendPendingBatches();
    internal Task HandleInboundActivityAsync(Func`1<Task> handler);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<HandleInboundActivityAsync>d__56`1")]
internal Task`1<TResult> HandleInboundActivityAsync(Func`1<Task`1<TResult>> handler);
    internal Task UpdateRootComponents(RootComponentOperationBatch operationBatch, ProtectedPrerenderComponentApplicationStore store, IServerComponentDeserializer serverComponentDeserializer, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitId : ValueType {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    public string Id { get; }
    public string Secret { get; }
    public CircuitId(string secret, string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Secret();
    public sealed virtual bool Equals(CircuitId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitIdFactory : object {
    [NullableContextAttribute("1")]
public CircuitIdFactory(IDataProtectionProvider provider);
    public CircuitId CreateCircuitId();
    [NullableContextAttribute("2")]
public bool TryParseCircuitId(string text, CircuitId& circuitId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.Circuits.CircuitInboundActivityContext : object {
    internal Func`1<Task> Handler { get; }
    public Circuit Circuit { get; }
    internal CircuitInboundActivityContext(Func`1<Task> handler, Circuit circuit);
    [CompilerGeneratedAttribute]
internal Func`1<Task> get_Handler();
    [CompilerGeneratedAttribute]
public Circuit get_Circuit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitJSComponentInterop : JSComponentInterop {
    internal CircuitJSComponentInterop(CircuitOptions circuitOptions);
    protected virtual int AddRootComponent(string identifier, string domElementSelector);
    protected virtual void RemoveRootComponent(int componentId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitOptionsJavaScriptInitializersConfiguration : object {
    public CircuitOptionsJavaScriptInitializersConfiguration(IWebHostEnvironment environment);
    public sealed virtual void Configure(CircuitOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry : object {
    internal ConcurrentDictionary`2<CircuitId, CircuitHost> ConnectedCircuits { get; }
    internal MemoryCache DisconnectedCircuits { get; }
    public CircuitRegistry(IOptions`1<CircuitOptions> options, ILogger`1<CircuitRegistry> logger, CircuitIdFactory CircuitHostFactory);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<CircuitId, CircuitHost> get_ConnectedCircuits();
    [CompilerGeneratedAttribute]
internal MemoryCache get_DisconnectedCircuits();
    public void Register(CircuitHost circuitHost);
    public virtual Task DisconnectAsync(CircuitHost circuitHost, string connectionId);
    protected virtual bool DisconnectCore(CircuitHost circuitHost, string connectionId);
    public void RegisterDisconnectedCircuit(CircuitHost circuitHost);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry/<ConnectAsync>d__16")]
public virtual Task`1<CircuitHost> ConnectAsync(CircuitId circuitId, IClientProxy clientProxy, string connectionId, CancellationToken cancellationToken);
    protected virtual ValueTuple`2<CircuitHost, bool> ConnectCore(CircuitId circuitId, IClientProxy clientProxy, string connectionId);
    protected virtual void OnEntryEvicted(object key, object value, EvictionReason reason, object state);
    public ValueTask TerminateAsync(CircuitId circuitId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.DefaultCircuitAccessor : object {
    public Circuit Circuit { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Circuit get_Circuit();
    [CompilerGeneratedAttribute]
public void set_Circuit(Circuit value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitAccessor {
    public Circuit Circuit { get; }
    public abstract virtual Circuit get_Circuit();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitFactory {
    public abstract virtual ValueTask`1<CircuitHost> CreateCircuitHostAsync(IReadOnlyList`1<ComponentDescriptor> components, CircuitClientProxy client, string baseUri, string uri, ClaimsPrincipal user, IPersistentComponentStateStore store);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitHandleRegistry {
    public abstract virtual CircuitHandle GetCircuitHandle(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public abstract virtual CircuitHost GetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public abstract virtual void SetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey, CircuitHost circuitHost);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Server.Circuits.PendingRender : ValueType {
    [CompilerGeneratedAttribute]
private int <ComponentId>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderFragment <RenderFragment>k__BackingField;
    public int ComponentId { get; }
    public RenderFragment RenderFragment { get; }
    public PendingRender(int componentId, RenderFragment renderFragment);
    [CompilerGeneratedAttribute]
public int get_ComponentId();
    [CompilerGeneratedAttribute]
public RenderFragment get_RenderFragment();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteErrorBoundaryLogger : object {
    [NullableContextAttribute("1")]
public RemoteErrorBoundaryLogger(ILogger`1<ErrorBoundary> logger, IJSRuntime jsRuntime, IOptions`1<CircuitOptions> options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask LogErrorAsync(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream : Stream {
    public PipeReader PipeReader { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReceiveData>d__12")]
public static Task`1<bool> ReceiveData(RemoteJSRuntime runtime, long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<CreateRemoteJSDataStreamAsync>d__13")]
public static ValueTask`1<RemoteJSDataStream> CreateRemoteJSDataStreamAsync(RemoteJSRuntime runtime, IJSStreamReference jsStreamReference, long totalLength, long signalRMaximumIncomingBytes, TimeSpan jsInteropDefaultCallTimeout, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public PipeReader get_PipeReader();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReadAsync>d__35")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReadAsync>d__36")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    internal void InvalidateLastDataReceivedTimeForTimeout();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime : JSRuntime {
    internal int RemoteJSDataStreamNextInstanceId;
    internal Dictionary`2<long, RemoteJSDataStream> RemoteJSDataStreamInstances;
    public ElementReferenceContext ElementReferenceContext { get; }
    public bool IsInitialized { get; }
    internal bool IsPermanentlyDisconnected { get; }
    public RemoteJSRuntime(IOptions`1<CircuitOptions> circuitOptions, IOptions`1<HubOptions`1<ComponentHub>> componentHubOptions, ILogger`1<RemoteJSRuntime> logger);
    [CompilerGeneratedAttribute]
public ElementReferenceContext get_ElementReferenceContext();
    public bool get_IsInitialized();
    internal bool get_IsPermanentlyDisconnected();
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    public JsonSerializerOptions ReadJsonSerializerOptions();
    internal void Initialize(CircuitClientProxy clientProxy);
    internal void RaiseUnhandledException(Exception ex);
    protected virtual void EndInvokeDotNet(DotNetInvocationInfo invocationInfo, DotNetInvocationResult& modreq(System.Runtime.InteropServices.InAttribute) invocationResult);
    protected virtual void SendByteArray(int id, Byte[] data);
    protected virtual void BeginInvokeJS(long asyncHandle, string identifier, string argsJson, JSCallResultType resultType, long targetInstanceId);
    protected virtual void ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime/<TransmitStreamAsync>d__27")]
protected virtual Task TransmitStreamAsync(long streamId, DotNetStreamReference dotNetStreamReference);
    public bool TryClaimPendingStreamForSending(long streamId, DotNetStreamReference& pendingStream);
    public void MarkPermanentlyDisconnected();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime/<ReadJSDataAsStreamAsync>d__30")]
protected virtual Task`1<Stream> ReadJSDataAsStreamAsync(IJSStreamReference jsStreamReference, long totalLength, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationInterception : object {
    public bool HasAttachedJSRuntime { get; }
    [NullableContextAttribute("1")]
public void AttachJSRuntime(IJSRuntime jsRuntime);
    public bool get_HasAttachedJSRuntime();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationInterception/<EnableNavigationInterceptionAsync>d__4")]
public sealed virtual Task EnableNavigationInterceptionAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager : NavigationManager {
    public bool HasAttachedJSRuntime { get; }
    public RemoteNavigationManager(ILogger`1<RemoteNavigationManager> logger);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    public bool get_HasAttachedJSRuntime();
    public sealed virtual void Initialize(string baseUri, string uri);
    public void AttachJsRuntime(IJSRuntime jsRuntime);
    public void NotifyLocationChanged(string uri, string state, bool intercepted);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager/<HandleLocationChangingAsync>d__12")]
public ValueTask`1<bool> HandleLocationChangingAsync(string uri, string state, bool intercepted);
    [DynamicDependencyAttribute("512", "Microsoft.AspNetCore.Components.NavigationOptions")]
protected virtual void NavigateToCore(string uri, NavigationOptions options);
    public virtual void Refresh(bool forceReload);
    protected virtual void HandleLocationChangingHandlerException(Exception ex, LocationChangingContext context);
    protected virtual void SetNavigationLockState(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteRenderer : WebRenderer {
    internal ConcurrentQueue`1<UnacknowledgedRenderBatch> _unacknowledgedRenderBatches;
    public Dispatcher Dispatcher { get; }
    public RemoteRenderer(IServiceProvider serviceProvider, ILoggerFactory loggerFactory, CircuitOptions options, CircuitClientProxy client, IServerComponentDeserializer serverComponentDeserializer, ILogger logger, RemoteJSRuntime jsRuntime, CircuitJSComponentInterop jsComponentInterop);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public virtual Dispatcher get_Dispatcher();
    public Task AddComponentAsync(Type componentType, ParameterView parameters, string domElementSelector);
    protected virtual int GetWebRendererId();
    protected virtual void AttachRootComponentToBrowser(int componentId, string domElementSelector);
    internal Type GetExistingComponentType(int componentId);
    protected virtual void ProcessPendingRender();
    protected virtual void HandleException(Exception exception);
    protected virtual void Dispose(bool disposing);
    protected virtual Task UpdateDisplayAsync(RenderBatch& modreq(System.Runtime.InteropServices.InAttribute) batch);
    public Task ProcessBufferedRenderBatches();
    public Task OnRenderCompletedAsync(long incomingBatchId, string errorMessageOrNull);
    protected virtual IComponent ResolveComponentForRenderMode(Type componentType, Nullable`1<int> parentComponentId, IComponentActivator componentActivator, IComponentRenderMode renderMode);
    public WebRootComponentManager GetOrCreateWebRootComponentManager();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteScrollToLocationHash : object {
    public bool HasAttachedJSRuntime { get; }
    [NullableContextAttribute("1")]
public void AttachJSRuntime(IJSRuntime jsRuntime);
    public bool get_HasAttachedJSRuntime();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteScrollToLocationHash/<RefreshScrollPositionForHash>d__4")]
public sealed virtual Task RefreshScrollPositionForHash(string locationAbsolute);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RenderBatchWriter : object {
    [NullableContextAttribute("1")]
public RenderBatchWriter(Stream output, bool leaveOpen);
    public void Write(RenderBatch& renderBatch);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentDescriptor : object {
    public Type ComponentType { get; public set; }
    public ParameterView Parameters { get; public set; }
    public int Sequence { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(Type value);
    [CompilerGeneratedAttribute]
public ParameterView get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ParameterView value);
    [CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
    public void Deconstruct(Type& componentType, ParameterView& parameters, Int32& sequence);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentHub : Hub {
    public static PathString DefaultPath { get; }
    public ComponentHub(IServerComponentDeserializer serializer, IDataProtectionProvider dataProtectionProvider, ICircuitFactory circuitFactory, CircuitIdFactory circuitIdFactory, CircuitRegistry circuitRegistry, ICircuitHandleRegistry circuitHandleRegistry, ILogger`1<ComponentHub> logger);
    [CompilerGeneratedAttribute]
public static PathString get_DefaultPath();
    public virtual Task OnDisconnectedAsync(Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<StartCircuit>d__13")]
public ValueTask`1<string> StartCircuit(string baseUri, string uri, string serializedComponentRecords, string applicationState);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<UpdateRootComponents>d__14")]
public Task UpdateRootComponents(string serializedComponentOperations, string applicationState);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ConnectCircuit>d__15")]
public ValueTask`1<bool> ConnectCircuit(string circuitIdSecret);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<BeginInvokeDotNetFromJS>d__16")]
public ValueTask BeginInvokeDotNetFromJS(string callId, string assemblyName, string methodIdentifier, long dotNetObjectId, string argsJson);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<EndInvokeJSFromDotNet>d__17")]
public ValueTask EndInvokeJSFromDotNet(long asyncHandle, bool succeeded, string arguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ReceiveByteArray>d__18")]
public ValueTask ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ReceiveJSDataChunk>d__19")]
public ValueTask`1<bool> ReceiveJSDataChunk(long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncIteratorStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<SendDotNetStreamToJS>d__20")]
public IAsyncEnumerable`1<ArraySegment`1<byte>> SendDotNetStreamToJS(long streamId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnRenderCompleted>d__21")]
public ValueTask OnRenderCompleted(long renderId, string errorMessageOrNull);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnLocationChanged>d__22")]
public ValueTask OnLocationChanged(string uri, string state, bool intercepted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnLocationChanging>d__23")]
public ValueTask OnLocationChanging(int callId, string uri, string state, bool intercepted);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentParameterDeserializer : object {
    public ComponentParameterDeserializer(ILogger`1<ComponentParameterDeserializer> logger, ComponentParametersTypeCache parametersCache);
    public bool TryDeserializeParameters(IList`1<ComponentParameter> parametersDefinitions, IList`1<object> parameterValues, ParameterView& parameters);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.IServerComponentDeserializer {
    public abstract virtual bool TryDeserializeComponentDescriptorCollection(string serializedComponentRecords, List`1& descriptors);
    public abstract virtual bool TryDeserializeRootComponentOperations(string serializedComponentOperations, RootComponentOperationBatch& operationBatch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage : object {
    private protected ProtectedBrowserStorage(string storeName, IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
    public ValueTask SetAsync(string key, object value);
    public ValueTask SetAsync(string purpose, string key, object value);
    public ValueTask`1<ProtectedBrowserStorageResult`1<TValue>> GetAsync(string key);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage/<GetAsync>d__8`1")]
public ValueTask`1<ProtectedBrowserStorageResult`1<TValue>> GetAsync(string purpose, string key);
    public ValueTask DeleteAsync(string key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult`1 : ValueType {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public bool Success { get; }
    public TValue Value { get; }
    internal ProtectedBrowserStorageResult`1(bool success, TValue value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TValue get_Value();
}
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage : ProtectedBrowserStorage {
    [NullableContextAttribute("1")]
public ProtectedLocalStorage(IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
}
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedSessionStorage : ProtectedBrowserStorage {
    [NullableContextAttribute("1")]
public ProtectedSessionStorage(IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
}
public abstract class Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider : ServerAuthenticationStateProvider {
    protected TimeSpan RevalidationInterval { get; }
    [NullableContextAttribute("1")]
public RevalidatingServerAuthenticationStateProvider(ILoggerFactory loggerFactory);
    protected abstract virtual TimeSpan get_RevalidationInterval();
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<bool> ValidateAuthenticationStateAsync(AuthenticationState authenticationState, CancellationToken cancellationToken);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider : AuthenticationStateProvider {
    [NullableContextAttribute("1")]
public virtual Task`1<AuthenticationState> GetAuthenticationStateAsync();
    [NullableContextAttribute("1")]
public sealed virtual void SetAuthenticationState(Task`1<AuthenticationState> authenticationStateTask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ServerComponentDeserializer : object {
    public ServerComponentDeserializer(IDataProtectionProvider dataProtectionProvider, ILogger`1<ServerComponentDeserializer> logger, RootComponentTypeCache rootComponentTypeCache, ComponentParameterDeserializer parametersDeserializer);
    public sealed virtual bool TryDeserializeComponentDescriptorCollection(string serializedComponentRecords, List`1& descriptors);
    [NullableContextAttribute("2")]
public bool TryDeserializeWebRootComponentDescriptor(ComponentMarker record, WebRootComponentDescriptor& result);
    public sealed virtual bool TryDeserializeRootComponentOperations(string serializedComponentOperations, RootComponentOperationBatch& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ServerComponent : ValueType {
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ComponentParameter> <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<object> <ParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InvocationId>k__BackingField;
    public int Sequence { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public string AssemblyName { get; public set; }
    public string TypeName { get; public set; }
    public IList`1<ComponentParameter> ParameterDefinitions { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<object> ParameterValues { get; public set; }
    public Guid InvocationId { get; public set; }
    public ServerComponent(int sequence, Nullable`1<ComponentMarkerKey> key, string assemblyName, string typeName, IList`1<ComponentParameter> parametersDefinitions, IList`1<object> parameterValues, Guid invocationId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<ComponentParameter> get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(IList`1<ComponentParameter> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<object> get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(IList`1<object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_InvocationId();
    [CompilerGeneratedAttribute]
public void set_InvocationId(Guid value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.ServerComponentSerializationSettings : object {
    public static string DataProtectionProviderPurpose;
    public static JsonSerializerOptions JsonSerializationOptions;
    public static TimeSpan DataExpiration;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.Web.BrowserNavigationManagerInterop : object {
    public static string EnableNavigationInterception;
    public static string GetLocationHref;
    public static string GetBaseUri;
    public static string NavigateTo;
    public static string Refresh;
    public static string SetHasLocationChangingListeners;
    public static string ScrollToElement;
}
internal enum Microsoft.AspNetCore.Components.WebRendererId : Enum {
    public int value__;
    public static WebRendererId Default;
    public static WebRendererId Server;
    public static WebRendererId WebAssembly;
    public static WebRendererId WebView;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.WebRootComponentDescriptor : object {
    public Type ComponentType { get; }
    public WebRootComponentParameters Parameters { get; }
    public WebRootComponentDescriptor(Type componentType, WebRootComponentParameters parameters);
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public WebRootComponentParameters get_Parameters();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.WebRootComponentParameters : ValueType {
    [CompilerGeneratedAttribute]
private ParameterView <parameterView>P;
    public static WebRootComponentParameters Empty;
    private IReadOnlyList`1<ComponentParameter> _parameterDefinitions;
    private IReadOnlyList`1<object> _serializedParameterValues;
    public ParameterView Parameters { get; }
    [NullableContextAttribute("1")]
public WebRootComponentParameters(ParameterView parameterView, IReadOnlyList`1<ComponentParameter> parameterDefinitions, IReadOnlyList`1<object> serializedParameterValues);
    public ParameterView get_Parameters();
    public bool DefinitelyEquals(WebRootComponentParameters& other);
}
internal static class Microsoft.AspNetCore.Internal.BinaryMessageFormatter : object {
    [NullableContextAttribute("1")]
public static void WriteLengthPrefix(long length, IBufferWriter`1<byte> output);
    public static int WriteLengthPrefix(long length, Span`1<byte> output);
    public static int LengthPrefixLength(long length);
}
internal static class Microsoft.AspNetCore.Internal.BinaryMessageParser : object {
    public static bool TryParseMessage(ReadOnlySequence`1& buffer, ReadOnlySequence`1& payload);
}
internal static class Microsoft.AspNetCore.Internal.LinkerFlags : object {
    public static DynamicallyAccessedMemberTypes JsonSerialized;
    public static DynamicallyAccessedMemberTypes Component;
    public static DynamicallyAccessedMemberTypes JSInvokable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Internal.MemoryBufferWriter : Stream {
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public MemoryBufferWriter(int minimumSegmentSize);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static MemoryBufferWriter Get();
    public static void Return(MemoryBufferWriter writer);
    public void Reset();
    public sealed virtual void Advance(int count);
    [NullableContextAttribute("0")]
public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public void CopyTo(IBufferWriter`1<byte> destination);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public Byte[] ToArray();
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<byte> span);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> span);
    public WrittenBuffers DetachAndReset();
    protected virtual void Dispose(bool disposing);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.AspNetCore.SignalR.Internal.NonDefaultHubProtocolAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.SignalR.Protocol.MessagePackHubProtocolWorker : object {
    [NullableContextAttribute("0")]
public bool TryParseMessage(ReadOnlySequence`1& input, IInvocationBinder binder, HubMessage& message);
    protected abstract virtual object DeserializeObject(MessagePackReader& reader, Type type, string field);
    public void WriteMessage(HubMessage message, IBufferWriter`1<byte> output);
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> GetMessageBytes(HubMessage message);
    protected abstract virtual void Serialize(MessagePackWriter& writer, Type type, object value);
    protected static string ReadString(MessagePackReader& reader, IInvocationBinder binder, string field);
    protected static string ReadString(MessagePackReader& reader, string field);
}
internal static class Microsoft.AspNetCore.SignalR.Protocol.ProtocolHelper : object {
    [NullableContextAttribute("1")]
internal static Type TryGetReturnType(IInvocationBinder binder, string invocationId);
}
internal static class Microsoft.AspNetCore.StaticFiles.CacheHeaderSettings : object {
    [NullableContextAttribute("1")]
internal static void SetCacheHeaders(StaticFileResponseContext ctx);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Server-side Blazor does not currently support trimming or native AOT.")]
public static IServerSideBlazorBuilder AddServerSideBlazor(IServiceCollection services, Action`1<CircuitOptions> configure);
}
[NullableContextAttribute("1")]
public interface Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
    public IServiceCollection Services { get; }
    private IServiceCollection Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder.Services { get; }
    public abstract virtual IServiceCollection get_Services();
    private sealed virtual override IServiceCollection Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder.get_Services();
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServerRazorComponentsBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Server-side Blazor does not currently support native AOT.")]
public static IServerSideBlazorBuilder AddInteractiveServerComponents(IRazorComponentsBuilder builder, Action`1<CircuitOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions : object {
    [ExtensionAttribute]
public static IServerSideBlazorBuilder AddCircuitOptions(IServerSideBlazorBuilder builder, Action`1<CircuitOptions> configure);
    [ExtensionAttribute]
public static IServerSideBlazorBuilder AddHubOptions(IServerSideBlazorBuilder builder, Action`1<HubOptions> configure);
}
internal class Microsoft.Extensions.Internal.ValueStopwatch : ValueType {
    private long _startTimestamp;
    public bool IsActive { get; }
    public bool get_IsActive();
    public static ValueStopwatch StartNew();
    public TimeSpan GetElapsedTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Nerdbank.Streams.Requires : object {
    internal static void NotNull(object arg, string paramName);
    internal static void Argument(bool condition, string paramName, string message);
    internal static void Range(bool condition, string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Nerdbank.Streams.Sequence`1 : object {
    public int MinimumSpanLength { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySequence`1<T> AsReadOnlySequence { get; }
    public long Length { get; }
    public Sequence`1(MemoryPool`1<T> memoryPool);
    public Sequence`1(ArrayPool`1<T> arrayPool);
    [CompilerGeneratedAttribute]
public int get_MinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_MinimumSpanLength(int value);
    public ReadOnlySequence`1<T> get_AsReadOnlySequence();
    public long get_Length();
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1<T> sequence);
    public void AdvanceTo(SequencePosition position);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    public void Reset();
}
internal class System.Buffers.PooledArrayBufferWriter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Dispose();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
}
