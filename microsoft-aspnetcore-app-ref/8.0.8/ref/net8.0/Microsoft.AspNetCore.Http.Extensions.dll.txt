internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ArrayCollectionFactory`1 : object {
    [NullableContextAttribute("1")]
public static override TElement[] ToResultCore(TElement[] buffer, int size);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ArrayPoolBufferAdapter`3 : object {
    public static override PooledBuffer<TCollection, TCollectionFactory, TElement> CreateBuffer();
    public static override PooledBuffer<TCollection, TCollectionFactory, TElement> Add(PooledBuffer& buffer, TElement element);
    public static override TCollection ToResult(PooledBuffer<TCollection, TCollectionFactory, TElement> buffer);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverter`1 : FormDataConverter`1<TCollection> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverter`4 : CollectionConverter`1<TCollection> {
    public CollectionConverter`4(FormDataConverter`1<TElement> elementConverter);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, TCollection& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverterFactory : object {
    public static CollectionConverterFactory Instance;
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public static Type ResolveElementType(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CompiledComplexTypeConverter`1 : FormDataConverter`1<T> {
    public CompiledComplexTypeConverter`1(ConverterDelegate<T> body);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeConverterFactory : object {
    internal FormDataMetadataFactory MetadataFactory { get; }
    public ComplexTypeConverterFactory(FormDataMapperOptions options, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
internal FormDataMetadataFactory get_MetadataFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory`1 : ComplexTypeExpressionConverterFactory {
    public ComplexTypeExpressionConverterFactory`1(FormDataMetadataFactory factory);
    [PreserveBaseOverridesAttribute]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual override CompiledComplexTypeConverter`1<T> CreateConverter(Type type, FormDataMapperOptions options);
    [CompilerGeneratedAttribute]
internal static BinaryExpression <CreateInstanceAndAssignProperties>g__HasHandler|4_0(ParameterExpression context);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__PushPrefix|5_0(Expression readerParam, string prefix);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__AddMappingError|5_1(Expression readerParam, string message, string parameter);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__PopPrefix|5_2(Expression readerParam, string prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcreteTypeCollectionConverterFactory`2 : object {
    public static ConcreteTypeCollectionConverterFactory`2<TCollection, TElement> Instance;
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2046")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3051")]
public sealed virtual bool CanConvert(Type _, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type _, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcreteTypeDictionaryConverterFactory`3 : object {
    public static ConcreteTypeDictionaryConverterFactory`3<TDictionary, TKey, TValue> Instance;
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2046")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3051")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentBagBufferAdapter`1 : object {
    public static override ConcurrentBag`1<TElement> CreateBuffer();
    public static override ConcurrentBag`1<TElement> Add(ConcurrentBag`1& buffer, TElement element);
    public static override ConcurrentBag`1<TElement> ToResult(ConcurrentBag`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentQueueBufferAdapter`1 : object {
    public static override ConcurrentQueue`1<TElement> CreateBuffer();
    public static override ConcurrentQueue`1<TElement> Add(ConcurrentQueue`1& buffer, TElement element);
    public static override ConcurrentQueue`1<TElement> ToResult(ConcurrentQueue`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentStackBufferAdapter`1 : object {
    public static override ConcurrentStack`1<TElement> CreateBuffer();
    public static override ConcurrentStack`1<TElement> Add(ConcurrentStack`1& buffer, TElement element);
    public static override ConcurrentStack`1<TElement> ToResult(ConcurrentStack`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryBufferAdapter`3 : object {
    public static override TDictionaryType Add(TDictionaryType& buffer, TKey key, TValue value);
    public static override TDictionaryType CreateBuffer();
    public static override TDictionaryType ToResult(TDictionaryType buffer);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverter`1 : FormDataConverter`1<TDictionary> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverter`5 : DictionaryConverter`1<TDictionary> {
    public DictionaryConverter`5(FormDataConverter`1<TValue> elementConverter);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, TDictionary& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverterFactory : object {
    internal static DictionaryConverterFactory Instance;
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal static ValueTuple`2<Type, Type> ResolveDictionaryTypes(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryStaticCastAdapter`6 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TKey key, TValue element);
    public static override TDictionaryInterface ToResult(TBuffer buffer);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.EnumConverter`1 : FormDataConverter`1<TEnum> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, TEnum& result);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, TEnum& result, Boolean& found);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.EnumConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FileConverter`1 : FormDataConverter`1<T> {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FileConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataConverter : object {
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataConverter`1 : FormDataConverter {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal abstract virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMapper : object {
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public static T Map(FormDataReader reader, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMapperOptions : object {
    internal List`1<IFormDataConverterFactory> Factories { get; }
    internal ILogger Logger { get; }
    internal int MaxCollectionSize { get; internal set; }
    internal int MaxRecursionDepth { get; internal set; }
    internal int MaxErrorCount { get; internal set; }
    internal int MaxKeyBufferSize { get; internal set; }
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public FormDataMapperOptions(ILoggerFactory loggerFactory);
    internal List`1<IFormDataConverterFactory> get_Factories();
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
internal int get_MaxCollectionSize();
    [CompilerGeneratedAttribute]
internal void set_MaxCollectionSize(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxRecursionDepth();
    [CompilerGeneratedAttribute]
internal void set_MaxRecursionDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxErrorCount();
    [CompilerGeneratedAttribute]
internal void set_MaxErrorCount(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxKeyBufferSize();
    [CompilerGeneratedAttribute]
internal void set_MaxKeyBufferSize(int value);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal FormDataConverter`1<T> ResolveConverter();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal FormDataConverter ResolveConverter(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal void AddConverter(FormDataConverter`1<T> converter);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal bool CanConvert(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMappingError : object {
    public string Key { get; }
    public FormattableString Message { get; }
    [NullableAttribute("2")]
public string Value { get; }
    internal FormDataMappingError(string key, FormattableString message, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public FormattableString get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMappingException : Exception {
    public FormDataMappingError Error { get; }
    public FormDataMappingException(FormDataMappingError error);
    public FormDataMappingException(FormDataMappingError error, Exception innerException);
    [CompilerGeneratedAttribute]
public FormDataMappingError get_Error();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataReader : ValueType {
    private IReadOnlyDictionary`2<FormKey, StringValues> _readOnlyMemoryKeys;
    private Memory`1<char> _prefixBuffer;
    private Memory`1<char> _currentPrefixBuffer;
    private int _currentDepth;
    private int _errorCount;
    private IReadOnlyDictionary`2<FormKey, HashSet`1<FormKey>> _formDictionaryKeysByPrefix;
    private PrefixResolver _prefixResolver;
    [CompilerGeneratedAttribute]
private IFormatProvider <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormFileCollection <FormFileCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, FormattableString, string> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, object> <AttachInstanceToErrorsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxErrorCount>k__BackingField;
    [NullableAttribute("0")]
internal ReadOnlyMemory`1<char> CurrentPrefix { get; }
    public IFormatProvider Culture { get; }
    [NullableAttribute("2")]
public IFormFileCollection FormFileCollection { get; internal set; }
    public int MaxRecursionDepth { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`3<string, FormattableString, string> ErrorHandler { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<string, object> AttachInstanceToErrorsHandler { get; public set; }
    public int MaxErrorCount { get; public set; }
    public FormDataReader(IReadOnlyDictionary`2<FormKey, StringValues> formCollection, CultureInfo culture, Memory`1<char> buffer);
    public FormDataReader(IReadOnlyDictionary`2<FormKey, StringValues> formCollection, CultureInfo culture, Memory`1<char> buffer, IFormFileCollection formFileCollection);
    [NullableContextAttribute("0")]
internal ReadOnlyMemory`1<char> get_CurrentPrefix();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IFormatProvider get_Culture();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormFileCollection get_FormFileCollection();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_FormFileCollection(IFormFileCollection value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxRecursionDepth();
    [CompilerGeneratedAttribute]
public void set_MaxRecursionDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Action`3<string, FormattableString, string> get_ErrorHandler();
    [CompilerGeneratedAttribute]
public void set_ErrorHandler(Action`3<string, FormattableString, string> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Action`2<string, object> get_AttachInstanceToErrorsHandler();
    [CompilerGeneratedAttribute]
public void set_AttachInstanceToErrorsHandler(Action`2<string, object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxErrorCount();
    [CompilerGeneratedAttribute]
public void set_MaxErrorCount(int value);
    public void AddMappingError(FormattableString errorMessage, string attemptedValue);
    public void AddMappingError(Exception exception, string attemptedValue);
    public void AttachInstanceToErrors(object value);
    internal FormKeyCollection GetKeys();
    internal IReadOnlyDictionary`2<FormKey, HashSet`1<FormKey>> ProcessFormKeys();
    internal bool CurrentPrefixExists();
    internal void PopPrefix(string key);
    [NullableContextAttribute("0")]
internal void PopPrefix(ReadOnlySpan`1<char> key);
    internal void PushPrefix(string key);
    [NullableContextAttribute("0")]
internal void PushPrefix(ReadOnlySpan`1<char> key);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
internal bool TryGetValue(String& value);
    [IsReadOnlyAttribute]
internal bool TryGetValues(StringValues& values);
    internal string GetPrefix();
    internal string GetLastPrefixSegment();
    public sealed virtual void Dispose();
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataResources : object {
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string DictionaryUnparsableKey { get; }
    internal static string EnumMappingError { get; }
    internal static string MappingExceptionMessage { get; }
    internal static string MaxCollectionSizeReached { get; }
    internal static string ParsableMappingError { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_DictionaryUnparsableKey();
    internal static string FormatDictionaryUnparsableKey(object p0, object p1);
    internal static string get_EnumMappingError();
    internal static string FormatEnumMappingError(object p0, object p1);
    internal static string get_MappingExceptionMessage();
    internal static string get_MaxCollectionSizeReached();
    internal static string FormatMaxCollectionSizeReached(object p0, object p1);
    internal static string get_ParsableMappingError();
    internal static string FormatParsableMappingError(object p0, object p1);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormKey : ValueType {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Value>k__BackingField;
    public ReadOnlyMemory`1<char> Value { get; }
    public FormKey(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FormKey other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormMappingHelpers : object {
    public static string RequiresUnreferencedCodeMessage;
    public static string RequiresDynamicCodeMessage;
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ICollectionBufferAdapter`3 {
    public static abstract virtual TBuffer CreateBuffer();
    public static abstract virtual TBuffer Add(TBuffer& buffer, TElement element);
    public static abstract virtual TCollection ToResult(TBuffer buffer);
}
[NullableContextAttribute("2")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ICollectionFactory`2 {
    [NullableContextAttribute("1")]
public static abstract virtual TCollection ToResultCore(TElement[] buffer, int size);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.IDictionaryBufferAdapter`4 {
    public static abstract virtual TBuffer CreateBuffer();
    public static abstract virtual TBuffer Add(TBuffer& buffer, TKey key, TValue value);
    public static abstract virtual TDictionary ToResult(TBuffer buffer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.IFormDataConverterFactory {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableArrayBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableArray`1<TElement> ToResult(Builder<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableDictionaryBufferAdapter`2 : object {
    public static override Builder<TKey, TValue> Add(Builder& buffer, TKey key, TValue value);
    public static override Builder<TKey, TValue> CreateBuffer();
    public static override ImmutableDictionary`2<TKey, TValue> ToResult(Builder<TKey, TValue> buffer);
    internal static DictionaryConverter`1<IImmutableDictionary`2<TKey, TValue>> CreateInterfaceConverter(FormDataConverter`1<TValue> valueTypeConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableHashSetBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableHashSet`1<TElement> ToResult(Builder<TElement> buffer);
    public static CollectionConverter`1<IImmutableSet`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableListBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableList`1<TElement> ToResult(Builder<TElement> buffer);
    public static CollectionConverter`1<IImmutableList`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableQueueBufferAdapter`1 : ArrayPoolBufferAdapter`3<ImmutableQueue`1<TElement>, ImmutableQueueFactory<TElement>, TElement> {
    [NullableContextAttribute("1")]
public static CollectionConverter`1<IImmutableQueue`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableSortedDictionaryBufferAdapter`2 : object {
    public static override Builder<TKey, TValue> Add(Builder& buffer, TKey key, TValue value);
    public static override Builder<TKey, TValue> CreateBuffer();
    public static override ImmutableSortedDictionary`2<TKey, TValue> ToResult(Builder<TKey, TValue> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableSortedSetBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableSortedSet`1<TElement> ToResult(Builder<TElement> buffer);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableStackBufferAdapter`1 : ArrayPoolBufferAdapter`3<ImmutableStack`1<TElement>, ImmutableStackFactory<TElement>, TElement> {
    [NullableContextAttribute("1")]
public static CollectionConverter`1<IImmutableStack`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImplementingCollectionBufferAdapter`3 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TElement element);
    public static override TCollection ToResult(TBuffer buffer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ISingleValueConverter`1 {
    public abstract virtual bool CanConvertSingleValue();
    public abstract virtual bool TryConvertValue(FormDataReader& reader, string value, T& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataMetadataFactory : object {
    public FormDataMetadataFactory(List`1<IFormDataConverterFactory> factories, ILoggerFactory loggerFactory);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public FormDataTypeMetadata GetOrCreateMetadataFor(Type type, FormDataMapperOptions options);
    internal bool HasMetadataFor(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataParameterMetadata : object {
    public ParameterInfo Parameter { get; }
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public bool Required { get; }
    internal FormDataTypeMetadata ParameterMetadata { get; }
    public FormDataParameterMetadata(ParameterInfo parameter, FormDataTypeMetadata parameterTypeInfo);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    public sealed virtual bool get_Required();
    [CompilerGeneratedAttribute]
internal FormDataTypeMetadata get_ParameterMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataPropertyMetadata : object {
    public PropertyInfo Property { get; }
    public FormDataTypeMetadata PropertyMetadata { get; }
    public string Name { get; public set; }
    public Type Type { get; }
    public bool Required { get; public set; }
    public FormDataPropertyMetadata(PropertyInfo property, FormDataTypeMetadata propertyTypeInfo);
    public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_PropertyMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
internal enum Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataTypeKind : Enum {
    public int value__;
    public static FormDataTypeKind Primitive;
    public static FormDataTypeKind File;
    public static FormDataTypeKind Collection;
    public static FormDataTypeKind Dictionary;
    public static FormDataTypeKind Object;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataTypeMetadata : object {
    public FormDataTypeKind Kind { get; public set; }
    [NullableAttribute("1")]
public Type Type { get; public set; }
    public FormDataTypeMetadata ElementType { get; public set; }
    public FormDataTypeMetadata KeyType { get; public set; }
    public FormDataTypeMetadata ValueType { get; public set; }
    public ConstructorInfo Constructor { get; public set; }
    [NullableAttribute("1")]
public IList`1<FormDataParameterMetadata> ConstructorParameters { get; public set; }
    [NullableAttribute("1")]
public IList`1<FormDataPropertyMetadata> Properties { get; public set; }
    public bool IsRecursive { get; internal set; }
    [NullableContextAttribute("1")]
public FormDataTypeMetadata(Type type);
    [CompilerGeneratedAttribute]
public FormDataTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(FormDataTypeKind value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_Type();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_ValueType();
    [CompilerGeneratedAttribute]
public void set_ValueType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public void set_Constructor(ConstructorInfo value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<FormDataParameterMetadata> get_ConstructorParameters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ConstructorParameters(IList`1<FormDataParameterMetadata> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<FormDataPropertyMetadata> get_Properties();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Properties(IList`1<FormDataPropertyMetadata> value);
    [CompilerGeneratedAttribute]
public bool get_IsRecursive();
    [CompilerGeneratedAttribute]
internal void set_IsRecursive(bool value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.IFormDataValue {
    public string Name { get; }
    public Type Type { get; }
    public bool Required { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_Required();
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.NullableConverter`1 : FormDataConverter`1<Nullable`1<T>> {
    public NullableConverter`1(FormDataConverter`1<T> nonNullableConverter);
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, Nullable`1& result);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, Nullable`1& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.NullableConverterFactory : object {
    public static NullableConverterFactory Instance;
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ParsableConverter`1 : FormDataConverter`1<T> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, T& result);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ParsableConverterFactory : object {
    public static ParsableConverterFactory Instance;
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.PrefixResolver : ValueType {
    private FormKey[] _sortedKeys;
    private int _length;
    public bool HasValues { get; }
    [NullableContextAttribute("1")]
public PrefixResolver(IEnumerable`1<FormKey> readOnlyMemoryKeys, int count);
    public bool get_HasValues();
    internal bool HasPrefix(ReadOnlyMemory`1<char> currentPrefixBuffer);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.QueueBufferAdapter`1 : object {
    public static override Queue`1<TElement> CreateBuffer();
    public static override Queue`1<TElement> Add(Queue`1& buffer, TElement element);
    public static override Queue`1<TElement> ToResult(Queue`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ReadOnlyCollectionBufferAdapter`1 : object {
    public static override IList`1<TElement> CreateBuffer();
    public static override IList`1<TElement> Add(IList`1& buffer, TElement element);
    public static override ReadOnlyCollection`1<TElement> ToResult(IList`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ReadOnlyDictionaryBufferAdapter`2 : object {
    public static override Dictionary`2<TKey, TValue> Add(Dictionary`2& buffer, TKey key, TValue value);
    public static override Dictionary`2<TKey, TValue> CreateBuffer();
    public static override ReadOnlyDictionary`2<TKey, TValue> ToResult(Dictionary`2<TKey, TValue> buffer);
    internal static DictionaryConverter`1<IReadOnlyDictionary`2<TKey, TValue>> CreateInterfaceConverter(FormDataConverter`1<TValue> valueTypeConverter);
    internal static DictionaryConverter`1<ReadOnlyDictionary`2<TKey, TValue>> CreateConverter(FormDataConverter`1<TValue> valueTypeConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.StackBufferAdapter`1 : object {
    public static override Stack`1<TElement> CreateBuffer();
    public static override Stack`1<TElement> Add(Stack`1& buffer, TElement element);
    public static override Stack`1<TElement> ToResult(Stack`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.StaticCastAdapter`5 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TElement element);
    public static override TCollectionInterface ToResult(TBuffer buffer);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedCollectionConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedCollectionConverterFactory`2 : TypedCollectionConverterFactory {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public virtual bool CanConvert(Type _, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public virtual FormDataConverter CreateConverter(Type _, FormDataMapperOptions options);
    [CompilerGeneratedAttribute]
internal static FormDataConverter <CreateConverter>g__CreateConverter|1_0(FormDataConverter`1<TElement> elementTypeConverter);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedDictionaryConverterFactory`3 : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.UriFormDataConverter : FormDataConverter`1<Uri> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, Uri& result);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, Uri& result, Boolean& found);
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.WellKnownConverters : object {
    [NullableAttribute("1")]
public static IReadOnlyDictionary`2<Type, FormDataConverter> Converters;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Http.DefaultProblemDetailsWriter : object {
    public DefaultProblemDetailsWriter(IOptions`1<ProblemDetailsOptions> options, IOptions`1<JsonOptions> jsonOptions);
    public sealed virtual bool CanWrite(ProblemDetailsContext context);
    public sealed virtual ValueTask WriteAsync(ProblemDetailsContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Http.EndpointDescriptionAttribute : Attribute {
    public string Description { get; }
    public EndpointDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    public virtual string ToString();
}
[RequiresUnreferencedCodeAttribute("This API performs reflection on types that can't be statically analyzed.")]
[RequiresDynamicCodeAttribute("This API performs reflection on types that can't be statically analyzed.")]
internal static class Microsoft.AspNetCore.Http.EndpointMetadataPopulator : object {
    [NullableContextAttribute("1")]
public static void PopulateMetadata(MethodInfo methodInfo, EndpointBuilder builder, IEnumerable`1<ParameterInfo> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Http.EndpointSummaryAttribute : Attribute {
    public string Summary { get; }
    public EndpointSummaryAttribute(string summary);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.Extensions.HttpRequestMultipartExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetMultipartBoundary(HttpRequest request);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.Extensions.QueryBuilder : object {
    public QueryBuilder(IEnumerable`1<KeyValuePair`2<string, string>> parameters);
    public QueryBuilder(IEnumerable`1<KeyValuePair`2<string, StringValues>> parameters);
    public void Add(string key, IEnumerable`1<string> values);
    public void Add(string key, string value);
    public virtual string ToString();
    public QueryString ToQueryString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class Microsoft.AspNetCore.Http.Extensions.SharedFormMapping.FormDataResources : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.AspNetCore.Http.Extensions.StreamCopyOperation : object {
    public static Task CopyToAsync(Stream source, Stream destination, Nullable`1<long> count, CancellationToken cancel);
    public static Task CopyToAsync(Stream source, Stream destination, Nullable`1<long> count, int bufferSize, CancellationToken cancel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.Extensions.UriHelper : object {
    public static string BuildRelative(PathString pathBase, PathString path, QueryString query, FragmentString fragment);
    public static string BuildAbsolute(string scheme, HostString host, PathString pathBase, PathString path, QueryString query, FragmentString fragment);
    public static void FromAbsolute(string uri, String& scheme, HostString& host, PathString& path, QueryString& query, FragmentString& fragment);
    public static string Encode(Uri uri);
    [ExtensionAttribute]
public static string GetEncodedUrl(HttpRequest request);
    [ExtensionAttribute]
public static string GetEncodedPathAndQuery(HttpRequest request);
    [ExtensionAttribute]
public static string GetDisplayUrl(HttpRequest request);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.HeaderDictionaryTypeExtensions : object {
    [ExtensionAttribute]
public static RequestHeaders GetTypedHeaders(HttpRequest request);
    [ExtensionAttribute]
public static ResponseHeaders GetTypedHeaders(HttpResponse response);
    [ExtensionAttribute]
internal static Nullable`1<DateTimeOffset> GetDate(IHeaderDictionary headers, string name);
    [ExtensionAttribute]
internal static void Set(IHeaderDictionary headers, string name, object value);
    [ExtensionAttribute]
internal static void SetList(IHeaderDictionary headers, string name, IList`1<T> values);
    [ExtensionAttribute]
public static void AppendList(IHeaderDictionary Headers, string name, IList`1<T> values);
    [ExtensionAttribute]
internal static void SetDate(IHeaderDictionary headers, string name, Nullable`1<DateTimeOffset> value);
    [ExtensionAttribute]
internal static T Get(IHeaderDictionary headers, string name);
    [ExtensionAttribute]
internal static IList`1<T> GetList(IHeaderDictionary headers, string name);
    [ExtensionAttribute]
internal static IList`1<T> GetList(StringValues values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.Headers.RequestHeaders : object {
    public IHeaderDictionary Headers { get; }
    public IList`1<MediaTypeHeaderValue> Accept { get; public set; }
    public IList`1<StringWithQualityHeaderValue> AcceptCharset { get; public set; }
    public IList`1<StringWithQualityHeaderValue> AcceptEncoding { get; public set; }
    public IList`1<StringWithQualityHeaderValue> AcceptLanguage { get; public set; }
    [NullableAttribute("2")]
public CacheControlHeaderValue CacheControl { get; public set; }
    [NullableAttribute("2")]
public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    public Nullable`1<long> ContentLength { get; public set; }
    [NullableAttribute("2")]
public ContentRangeHeaderValue ContentRange { get; public set; }
    [NullableAttribute("2")]
public MediaTypeHeaderValue ContentType { get; public set; }
    public IList`1<CookieHeaderValue> Cookie { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public HostString Host { get; public set; }
    public IList`1<EntityTagHeaderValue> IfMatch { get; public set; }
    public Nullable`1<DateTimeOffset> IfModifiedSince { get; public set; }
    public IList`1<EntityTagHeaderValue> IfNoneMatch { get; public set; }
    [NullableAttribute("2")]
public RangeConditionHeaderValue IfRange { get; public set; }
    public Nullable`1<DateTimeOffset> IfUnmodifiedSince { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    [NullableAttribute("2")]
public RangeHeaderValue Range { get; public set; }
    [NullableAttribute("2")]
public Uri Referer { get; public set; }
    public RequestHeaders(IHeaderDictionary headers);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_Headers();
    public IList`1<MediaTypeHeaderValue> get_Accept();
    public void set_Accept(IList`1<MediaTypeHeaderValue> value);
    public IList`1<StringWithQualityHeaderValue> get_AcceptCharset();
    public void set_AcceptCharset(IList`1<StringWithQualityHeaderValue> value);
    public IList`1<StringWithQualityHeaderValue> get_AcceptEncoding();
    public void set_AcceptEncoding(IList`1<StringWithQualityHeaderValue> value);
    public IList`1<StringWithQualityHeaderValue> get_AcceptLanguage();
    public void set_AcceptLanguage(IList`1<StringWithQualityHeaderValue> value);
    [NullableContextAttribute("2")]
public CacheControlHeaderValue get_CacheControl();
    [NullableContextAttribute("2")]
public void set_CacheControl(CacheControlHeaderValue value);
    [NullableContextAttribute("2")]
public ContentDispositionHeaderValue get_ContentDisposition();
    [NullableContextAttribute("2")]
public void set_ContentDisposition(ContentDispositionHeaderValue value);
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    [NullableContextAttribute("2")]
public ContentRangeHeaderValue get_ContentRange();
    [NullableContextAttribute("2")]
public void set_ContentRange(ContentRangeHeaderValue value);
    [NullableContextAttribute("2")]
public MediaTypeHeaderValue get_ContentType();
    [NullableContextAttribute("2")]
public void set_ContentType(MediaTypeHeaderValue value);
    public IList`1<CookieHeaderValue> get_Cookie();
    public void set_Cookie(IList`1<CookieHeaderValue> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public HostString get_Host();
    public void set_Host(HostString value);
    public IList`1<EntityTagHeaderValue> get_IfMatch();
    public void set_IfMatch(IList`1<EntityTagHeaderValue> value);
    public Nullable`1<DateTimeOffset> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value);
    public IList`1<EntityTagHeaderValue> get_IfNoneMatch();
    public void set_IfNoneMatch(IList`1<EntityTagHeaderValue> value);
    [NullableContextAttribute("2")]
public RangeConditionHeaderValue get_IfRange();
    [NullableContextAttribute("2")]
public void set_IfRange(RangeConditionHeaderValue value);
    public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
    [NullableContextAttribute("2")]
public RangeHeaderValue get_Range();
    [NullableContextAttribute("2")]
public void set_Range(RangeHeaderValue value);
    [NullableContextAttribute("2")]
public Uri get_Referer();
    [NullableContextAttribute("2")]
public void set_Referer(Uri value);
    [NullableContextAttribute("2")]
public T Get(string name);
    public IList`1<T> GetList(string name);
    public void Set(string name, object value);
    public void SetList(string name, IList`1<T> values);
    public void Append(string name, object value);
    public void AppendList(string name, IList`1<T> values);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.Headers.ResponseHeaders : object {
    [NullableAttribute("1")]
public IHeaderDictionary Headers { get; }
    public CacheControlHeaderValue CacheControl { get; public set; }
    public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    public Nullable`1<long> ContentLength { get; public set; }
    public ContentRangeHeaderValue ContentRange { get; public set; }
    public MediaTypeHeaderValue ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public EntityTagHeaderValue ETag { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    public Uri Location { get; public set; }
    [NullableAttribute("1")]
public IList`1<SetCookieHeaderValue> SetCookie { get; public set; }
    [NullableContextAttribute("1")]
public ResponseHeaders(IHeaderDictionary headers);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IHeaderDictionary get_Headers();
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public ContentDispositionHeaderValue get_ContentDisposition();
    public void set_ContentDisposition(ContentDispositionHeaderValue value);
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public ContentRangeHeaderValue get_ContentRange();
    public void set_ContentRange(ContentRangeHeaderValue value);
    public MediaTypeHeaderValue get_ContentType();
    public void set_ContentType(MediaTypeHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public EntityTagHeaderValue get_ETag();
    public void set_ETag(EntityTagHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
    public Uri get_Location();
    public void set_Location(Uri value);
    [NullableContextAttribute("1")]
public IList`1<SetCookieHeaderValue> get_SetCookie();
    [NullableContextAttribute("1")]
public void set_SetCookie(IList`1<SetCookieHeaderValue> value);
    public T Get(string name);
    [NullableContextAttribute("1")]
public IList`1<T> GetList(string name);
    [NullableContextAttribute("1")]
public void Set(string name, object value);
    [NullableContextAttribute("1")]
public void SetList(string name, IList`1<T> values);
    [NullableContextAttribute("1")]
public void Append(string name, object value);
    [NullableContextAttribute("1")]
public void AppendList(string name, IList`1<T> values);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.HttpContextServerVariableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetServerVariable(HttpContext context, string variableName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.HttpRequestJsonExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<TValue> ReadFromJsonAsync(HttpRequest request, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpRequestJsonExtensions/<ReadFromJsonAsync>d__3`1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static ValueTask`1<TValue> ReadFromJsonAsync(HttpRequest request, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpRequestJsonExtensions/<ReadFromJsonAsync>d__4`1")]
[ExtensionAttribute]
public static ValueTask`1<TValue> ReadFromJsonAsync(HttpRequest request, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpRequestJsonExtensions/<ReadFromJsonAsync>d__5")]
[ExtensionAttribute]
public static ValueTask`1<object> ReadFromJsonAsync(HttpRequest request, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<object> ReadFromJsonAsync(HttpRequest request, Type type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpRequestJsonExtensions/<ReadFromJsonAsync>d__7")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static ValueTask`1<object> ReadFromJsonAsync(HttpRequest request, Type type, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpRequestJsonExtensions/<ReadFromJsonAsync>d__8")]
[ExtensionAttribute]
public static ValueTask`1<object> ReadFromJsonAsync(HttpRequest request, Type type, JsonSerializerContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasJsonContentType(HttpRequest request);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.HttpResponseJsonExtensions : object {
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, TValue value, CancellationToken cancellationToken);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, TValue value, JsonSerializerOptions options, string contentType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsJsonAsync(HttpResponse response, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, string contentType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsJsonAsync(HttpResponse response, object value, JsonTypeInfo jsonTypeInfo, string contentType, CancellationToken cancellationToken);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, object value, Type type, CancellationToken cancellationToken);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, object value, Type type, JsonSerializerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and need runtime code generation. Use the overload that takes a JsonTypeInfo or JsonSerializerContext for native AOT applications.")]
public static Task WriteAsJsonAsync(HttpResponse response, object value, Type type, JsonSerializerOptions options, string contentType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsJsonAsync(HttpResponse response, object value, Type type, JsonSerializerContext context, string contentType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpResponseJsonExtensions/<<WriteAsJsonAsync>g__WriteAsJsonAsyncSlow|5_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <WriteAsJsonAsync>g__WriteAsJsonAsyncSlow|5_0(HttpResponse response, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.HttpResponseJsonExtensions/<<WriteAsJsonAsync>g__WriteAsJsonAsyncSlow|6_0>d")]
[CompilerGeneratedAttribute]
internal static Task <WriteAsJsonAsync>g__WriteAsJsonAsyncSlow|6_0(HttpResponse response, object value, JsonTypeInfo jsonTypeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.Json.JsonOptions : object {
    internal static JsonSerializerOptions DefaultSerializerOptions;
    public JsonSerializerOptions SerializerOptions { get; }
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_SerializerOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Http.JsonConstants : object {
    public static string JsonContentType;
    public static string JsonContentTypeWithCharset;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Http.JsonSerializerExtensions : object {
    [ExtensionAttribute]
public static bool HasKnownPolymorphism(JsonTypeInfo jsonTypeInfo);
    [ExtensionAttribute]
public static bool ShouldUseWith(JsonTypeInfo jsonTypeInfo, Type runtimeType);
    [ExtensionAttribute]
public static JsonTypeInfo GetReadOnlyTypeInfo(JsonSerializerOptions options, Type type);
    [ExtensionAttribute]
public static JsonTypeInfo GetRequiredTypeInfo(JsonSerializerContext context, Type type);
}
internal class Microsoft.AspNetCore.Http.Metadata.AntiforgeryMetadata : object {
    [NullableAttribute("1")]
public static IAntiforgeryMetadata ValidationRequired;
    [NullableAttribute("1")]
public static IAntiforgeryMetadata ValidationNotRequired;
    public bool RequiresValidation { get; }
    public AntiforgeryMetadata(bool required);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresValidation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("Uses unbounded Reflection to inspect property types.")]
internal class Microsoft.AspNetCore.Http.ParameterBindingMethodCache : object {
    public ParameterBindingMethodCache(bool throwOnInvalidMethod);
    public ParameterBindingMethodCache(bool preferNonGenericEnumParseOverload, bool throwOnInvalidMethod);
    [RequiresUnreferencedCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
[RequiresDynamicCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
public bool HasTryParseMethod(Type type);
    [RequiresUnreferencedCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
[RequiresDynamicCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
public bool HasBindAsyncMethod(ParameterInfo parameter);
    [RequiresUnreferencedCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
[RequiresDynamicCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
public Func`3<ParameterExpression, Expression, Expression> FindTryParseMethod(Type type);
    [RequiresUnreferencedCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
[RequiresDynamicCodeAttribute("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
public ValueTuple`2<Expression, int> FindBindAsyncMethod(ParameterInfo parameter);
    public ValueTuple`2<ConstructorInfo, ConstructorParameter[]> FindConstructor(Type type);
    [CompilerGeneratedAttribute]
internal static bool <FindTryParseMethod>g__ValidateReturnType|14_8(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
internal static bool <FindBindAsyncMethod>g__ValidateReturnType|15_1(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<ConstructorInfo, ConstructorParameter[]> <FindConstructor>g__Finder|16_0(Type type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetStaticMethodFromHierarchy>g__IsMatch|21_0(MethodInfo method, <>c__DisplayClass21_0& );
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.ParameterBindingMethodCache/<<ConvertValueTask>g__ConvertAwaited|26_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <ConvertValueTask>g__ConvertAwaited|26_0(ValueTask`1<T> typedValueTask);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.ParameterBindingMethodCache/<<ConvertValueTaskOfNullableResult>g__ConvertAwaited|27_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <ConvertValueTaskOfNullableResult>g__ConvertAwaited|27_0(ValueTask`1<Nullable`1<T>> typedValueTask);
}
internal static class Microsoft.AspNetCore.Http.ProblemDetailsDefaults : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dictionary`2<int, ValueTuple`2<string, string>> Defaults;
    [NullableContextAttribute("1")]
public static void Apply(ProblemDetails problemDetails, Nullable`1<int> statusCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Microsoft.AspNetCore.Mvc.ProblemDetails")]
[JsonSerializableAttribute("Microsoft.AspNetCore.Http.HttpValidationProblemDetails")]
[JsonSerializableAttribute("System.Text.Json.JsonElement")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.36612")]
internal class Microsoft.AspNetCore.Http.ProblemDetailsJsonContext : JsonSerializerContext {
    public JsonTypeInfo`1<HttpValidationProblemDetails> HttpValidationProblemDetails { get; }
    public JsonTypeInfo`1<ProblemDetails> ProblemDetails { get; }
    public JsonTypeInfo`1<IDictionary`2<string, object>> IDictionaryStringObject { get; }
    public JsonTypeInfo`1<IDictionary`2<string, String[]>> IDictionaryStringStringArray { get; }
    public JsonTypeInfo`1<JsonElement> JsonElement { get; }
    public JsonTypeInfo`1<int> Int32 { get; }
    public JsonTypeInfo`1<Nullable`1<int>> NullableInt32 { get; }
    public JsonTypeInfo`1<object> Object { get; }
    public JsonTypeInfo`1<string> String { get; }
    public JsonTypeInfo`1<String[]> StringArray { get; }
    public static ProblemDetailsJsonContext Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public ProblemDetailsJsonContext(JsonSerializerOptions options);
    public JsonTypeInfo`1<HttpValidationProblemDetails> get_HttpValidationProblemDetails();
    public JsonTypeInfo`1<ProblemDetails> get_ProblemDetails();
    public JsonTypeInfo`1<IDictionary`2<string, object>> get_IDictionaryStringObject();
    public JsonTypeInfo`1<IDictionary`2<string, String[]>> get_IDictionaryStringStringArray();
    public JsonTypeInfo`1<JsonElement> get_JsonElement();
    public JsonTypeInfo`1<int> get_Int32();
    public JsonTypeInfo`1<Nullable`1<int>> get_NullableInt32();
    public JsonTypeInfo`1<object> get_Object();
    public JsonTypeInfo`1<string> get_String();
    public JsonTypeInfo`1<String[]> get_StringArray();
    [CompilerGeneratedAttribute]
public static ProblemDetailsJsonContext get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
internal class Microsoft.AspNetCore.Http.ProblemDetailsJsonOptionsSetup : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(JsonOptions options);
}
public class Microsoft.AspNetCore.Http.ProblemDetailsOptions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<ProblemDetailsContext> CustomizeProblemDetails { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<ProblemDetailsContext> get_CustomizeProblemDetails();
    [CompilerGeneratedAttribute]
public void set_CustomizeProblemDetails(Action`1<ProblemDetailsContext> value);
}
internal class Microsoft.AspNetCore.Http.ProblemDetailsService : object {
    [NullableContextAttribute("1")]
public ProblemDetailsService(IEnumerable`1<IProblemDetailsWriter> writers);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.ProblemDetailsService/<WriteAsync>d__2")]
public sealed virtual ValueTask WriteAsync(ProblemDetailsContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.ProblemDetailsService/<TryWriteAsync>d__3")]
public sealed virtual ValueTask`1<bool> TryWriteAsync(ProblemDetailsContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Http.PropertyAsParameterInfo : ParameterInfo {
    public bool HasDefaultValue { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    public int MetadataToken { get; }
    [NullableAttribute("2")]
public object RawDefaultValue { get; }
    public bool IsOptional { get; }
    public NullabilityInfo NullabilityInfo { get; }
    public PropertyAsParameterInfo(PropertyInfo propertyInfo, NullabilityInfoContext nullabilityContext);
    public PropertyAsParameterInfo(PropertyInfo property, ParameterInfo parameterInfo, NullabilityInfoContext nullabilityContext);
    public virtual bool get_HasDefaultValue();
    [NullableContextAttribute("2")]
public virtual object get_DefaultValue();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public virtual object get_RawDefaultValue();
    [RequiresUnreferencedCodeAttribute("Uses unbounded Reflection to access parameter type constructors.")]
public static ReadOnlySpan`1<ParameterInfo> Flatten(ParameterInfo[] parameters, ParameterBindingMethodCache cache);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public bool get_IsOptional();
    public NullabilityInfo get_NullabilityInfo();
    [CompilerGeneratedAttribute]
internal static List`1<ParameterInfo> <Flatten>g__InitializeList|14_1(ParameterInfo[] parameters, int i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Http.RequestDelegateCreationLogging : object {
    public static int RequestBodyIOExceptionEventId;
    public static string RequestBodyIOExceptionEventName;
    public static string RequestBodyIOExceptionMessage;
    public static int InvalidJsonRequestBodyEventId;
    public static string InvalidJsonRequestBodyEventName;
    public static string InvalidJsonRequestBodyLogMessage;
    public static string InvalidJsonRequestBodyExceptionMessage;
    public static int ParameterBindingFailedEventId;
    public static string ParameterBindingFailedEventName;
    public static string ParameterBindingFailedLogMessage;
    public static string ParameterBindingFailedExceptionMessage;
    public static int RequiredParameterNotProvidedEventId;
    public static string RequiredParameterNotProvidedEventName;
    public static string RequiredParameterNotProvidedLogMessage;
    public static string RequiredParameterNotProvidedExceptionMessage;
    public static int ImplicitBodyNotProvidedEventId;
    public static string ImplicitBodyNotProvidedEventName;
    public static string ImplicitBodyNotProvidedLogMessage;
    public static string ImplicitBodyNotProvidedExceptionMessage;
    public static int UnexpectedJsonContentTypeEventId;
    public static string UnexpectedJsonContentTypeEventName;
    public static string UnexpectedJsonContentTypeLogMessage;
    public static string UnexpectedJsonContentTypeExceptionMessage;
    public static int UnexpectedFormContentTypeEventId;
    public static string UnexpectedFormContentTypeLogEventName;
    public static string UnexpectedFormContentTypeLogMessage;
    public static string UnexpectedFormContentTypeExceptionMessage;
    public static int InvalidFormRequestBodyEventId;
    public static string InvalidFormRequestBodyEventName;
    public static string InvalidFormRequestBodyLogMessage;
    public static string InvalidFormRequestBodyExceptionMessage;
    public static int InvalidAntiforgeryTokenEventId;
    public static string InvalidAntiforgeryTokenEventName;
    public static string InvalidAntiforgeryTokenLogMessage;
    public static string InvalidAntiforgeryTokenExceptionMessage;
    public static int FormDataMappingFailedEventId;
    public static string FormDataMappingFailedEventName;
    public static string FormDataMappingFailedLogMessage;
    public static string FormDataMappingFailedExceptionMessage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("RequestDelegateFactory performs object creation, serialization and deserialization on the delegates and its parameters. This cannot be statically analyzed.")]
[RequiresDynamicCodeAttribute("RequestDelegateFactory performs object creation, serialization and deserialization on the delegates and its parameters. This cannot be statically analyzed.")]
public static class Microsoft.AspNetCore.Http.RequestDelegateFactory : object {
    public static RequestDelegateMetadataResult InferMetadata(MethodInfo methodInfo, RequestDelegateFactoryOptions options);
    public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions options);
    public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions options, RequestDelegateMetadataResult metadataResult);
    public static RequestDelegateResult Create(MethodInfo methodInfo, Func`2<HttpContext, object> targetFactory, RequestDelegateFactoryOptions options);
    public static RequestDelegateResult Create(MethodInfo methodInfo, Func`2<HttpContext, object> targetFactory, RequestDelegateFactoryOptions options, RequestDelegateMetadataResult metadataResult);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ValueTaskOfTToValueTaskOfObject>g__ExecuteAwaited|91_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <ValueTaskOfTToValueTaskOfObject>g__ExecuteAwaited|91_0(ValueTask`1<T> valueTask);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<TaskOfTToValueTaskOfObject>g__ExecuteAwaited|92_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <TaskOfTToValueTaskOfObject>g__ExecuteAwaited|92_0(Task`1<T> task);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<HandleRequestBodyAndCompileRequestDelegateForJson>g__TryReadBodyAsync|102_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ValueTuple`2<object, bool>> <HandleRequestBodyAndCompileRequestDelegateForJson>g__TryReadBodyAsync|102_0(HttpContext httpContext, Type bodyType, string parameterTypeName, string parameterName, bool allowEmptyRequestBody, bool throwOnBadRequest, JsonTypeInfo jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<HandleRequestBodyAndCompileRequestDelegateForForm>g__TryReadFormAsync|104_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ValueTuple`2<object, bool>> <HandleRequestBodyAndCompileRequestDelegateForForm>g__TryReadFormAsync|104_0(HttpContext httpContext, string parameterTypeName, string parameterName, bool throwOnBadRequest);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskOfObject>g__ExecuteAwaited|129_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTaskOfObject>g__ExecuteAwaited|129_0(ValueTask`1<object> valueTask, HttpContext httpContext, JsonTypeInfo`1<object> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteTaskOfObject>g__ExecuteAwaited|130_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteTaskOfObject>g__ExecuteAwaited|130_0(Task`1<object> task, HttpContext httpContext, JsonTypeInfo`1<object> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteTaskOfTFast>g__ExecuteAwaited|132_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteTaskOfTFast>g__ExecuteAwaited|132_0(Task`1<T> task, HttpContext httpContext, JsonTypeInfo`1<T> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteTaskOfT>g__ExecuteAwaited|133_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteTaskOfT>g__ExecuteAwaited|133_0(Task`1<T> task, HttpContext httpContext, JsonTypeInfo`1<T> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteTaskOfString>g__ExecuteAwaited|134_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteTaskOfString>g__ExecuteAwaited|134_0(Task`1<string> task, HttpContext httpContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTask>g__ExecuteAwaited|136_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTask>g__ExecuteAwaited|136_0(ValueTask task);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteTaskWithEmptyResult>g__ExecuteAwaited|137_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <ExecuteTaskWithEmptyResult>g__ExecuteAwaited|137_0(Task task);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskWithEmptyResult>g__ExecuteAwaited|138_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<object> <ExecuteValueTaskWithEmptyResult>g__ExecuteAwaited|138_0(ValueTask task);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskOfTFast>g__ExecuteAwaited|139_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTaskOfTFast>g__ExecuteAwaited|139_0(ValueTask`1<T> task, HttpContext httpContext, JsonTypeInfo`1<T> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskOfT>g__ExecuteAwaited|140_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTaskOfT>g__ExecuteAwaited|140_0(ValueTask`1<T> task, HttpContext httpContext, JsonTypeInfo`1<T> jsonTypeInfo);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskOfString>g__ExecuteAwaited|141_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTaskOfString>g__ExecuteAwaited|141_0(ValueTask`1<string> task, HttpContext httpContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.RequestDelegateFactory/<<ExecuteValueTaskResult>g__ExecuteAwaited|142_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteValueTaskResult>g__ExecuteAwaited|142_0(ValueTask`1<T> task, HttpContext httpContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.AspNetCore.Http.RequestDelegateFactoryContext : object {
    [RequiredMemberAttribute]
public IServiceProvider ServiceProvider { get; public set; }
    [NullableAttribute("2")]
[RequiredMemberAttribute]
public IServiceProviderIsService ServiceProviderIsService { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[RequiredMemberAttribute]
public IEnumerable`1<string> RouteParameters { get; public set; }
    [RequiredMemberAttribute]
public bool ThrowOnBadRequest { get; public set; }
    [RequiredMemberAttribute]
public bool DisableInferredFromBody { get; public set; }
    [RequiredMemberAttribute]
public EndpointBuilder EndpointBuilder { get; public set; }
    [NullableAttribute("2")]
public Delegate Handler { get; public set; }
    [RequiredMemberAttribute]
public bool MetadataAlreadyInferred { get; public set; }
    [NullableAttribute("2")]
public ParameterInfo JsonRequestBodyParameter { get; public set; }
    public bool AllowEmptyRequestBody { get; public set; }
    public bool UsingTempSourceString { get; public set; }
    public List`1<ParameterExpression> ExtraLocals { get; }
    public List`1<Expression> ParamCheckExpressions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<Func`2<HttpContext, ValueTask`1<object>>> ParameterBinders { get; }
    public Dictionary`2<string, string> TrackedParameters { get; }
    public bool HasMultipleBodyParameters { get; public set; }
    public bool HasInferredBody { get; public set; }
    public NullabilityInfoContext NullabilityContext { get; }
    public bool ReadForm { get; public set; }
    public bool ReadFormFile { get; public set; }
    [NullableAttribute("2")]
public ParameterInfo FirstFormRequestBodyParameter { get; public set; }
    [NullableAttribute("2")]
public Expression MethodCall { get; public set; }
    public Type[] ArgumentTypes { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Expression[] ArgumentExpressions { get; public set; }
    public Expression[] BoxedArgs { get; public set; }
    public bool FilterFactoriesHaveRunWithoutModifyingPerRequestBehavior { get; public set; }
    public List`1<ParameterInfo> Parameters { get; public set; }
    [RequiredMemberAttribute]
public JsonSerializerOptions JsonSerializerOptions { get; public set; }
    [RequiredMemberAttribute]
public FormDataMapperOptions FormDataMapperOptions { get; public set; }
    [CompilerGeneratedAttribute]
public IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ServiceProvider(IServiceProvider value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IServiceProviderIsService get_ServiceProviderIsService();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ServiceProviderIsService(IServiceProviderIsService value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RouteParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RouteParameters(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnBadRequest();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ThrowOnBadRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableInferredFromBody();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableInferredFromBody(bool value);
    [CompilerGeneratedAttribute]
public EndpointBuilder get_EndpointBuilder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndpointBuilder(EndpointBuilder value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Delegate get_Handler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Handler(Delegate value);
    [CompilerGeneratedAttribute]
public bool get_MetadataAlreadyInferred();
    [CompilerGeneratedAttribute]
public void set_MetadataAlreadyInferred(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParameterInfo get_JsonRequestBodyParameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_JsonRequestBodyParameter(ParameterInfo value);
    [CompilerGeneratedAttribute]
public bool get_AllowEmptyRequestBody();
    [CompilerGeneratedAttribute]
public void set_AllowEmptyRequestBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsingTempSourceString();
    [CompilerGeneratedAttribute]
public void set_UsingTempSourceString(bool value);
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_ExtraLocals();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_ParamCheckExpressions();
    [CompilerGeneratedAttribute]
public List`1<Func`2<HttpContext, ValueTask`1<object>>> get_ParameterBinders();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_TrackedParameters();
    [CompilerGeneratedAttribute]
public bool get_HasMultipleBodyParameters();
    [CompilerGeneratedAttribute]
public void set_HasMultipleBodyParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasInferredBody();
    [CompilerGeneratedAttribute]
public void set_HasInferredBody(bool value);
    [CompilerGeneratedAttribute]
public NullabilityInfoContext get_NullabilityContext();
    [CompilerGeneratedAttribute]
public bool get_ReadForm();
    [CompilerGeneratedAttribute]
public void set_ReadForm(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadFormFile();
    [CompilerGeneratedAttribute]
public void set_ReadFormFile(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParameterInfo get_FirstFormRequestBodyParameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FirstFormRequestBodyParameter(ParameterInfo value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_MethodCall();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_MethodCall(Expression value);
    [CompilerGeneratedAttribute]
public Type[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
public void set_ArgumentTypes(Type[] value);
    [CompilerGeneratedAttribute]
public Expression[] get_ArgumentExpressions();
    [CompilerGeneratedAttribute]
public void set_ArgumentExpressions(Expression[] value);
    [CompilerGeneratedAttribute]
public Expression[] get_BoxedArgs();
    [CompilerGeneratedAttribute]
public void set_BoxedArgs(Expression[] value);
    [CompilerGeneratedAttribute]
public bool get_FilterFactoriesHaveRunWithoutModifyingPerRequestBehavior();
    [CompilerGeneratedAttribute]
public void set_FilterFactoriesHaveRunWithoutModifyingPerRequestBehavior(bool value);
    [CompilerGeneratedAttribute]
public List`1<ParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(List`1<ParameterInfo> value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_JsonSerializerOptions();
    [CompilerGeneratedAttribute]
public void set_JsonSerializerOptions(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public FormDataMapperOptions get_FormDataMapperOptions();
    [CompilerGeneratedAttribute]
public void set_FormDataMapperOptions(FormDataMapperOptions value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions : object {
    public IServiceProvider ServiceProvider { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> RouteParameterNames { get; public set; }
    public bool ThrowOnBadRequest { get; public set; }
    public bool DisableInferBodyFromParameters { get; public set; }
    public EndpointBuilder EndpointBuilder { get; public set; }
    [CompilerGeneratedAttribute]
public IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ServiceProvider(IServiceProvider value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RouteParameterNames();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RouteParameterNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnBadRequest();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ThrowOnBadRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableInferBodyFromParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableInferBodyFromParameters(bool value);
    [CompilerGeneratedAttribute]
public EndpointBuilder get_EndpointBuilder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndpointBuilder(EndpointBuilder value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
public class Microsoft.AspNetCore.Http.RequestDelegateMetadataResult : object {
    [RequiredMemberAttribute]
public IReadOnlyList`1<object> EndpointMetadata { get; public set; }
    [NullableAttribute("2")]
internal object CachedFactoryContext { get; internal set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<object> get_EndpointMetadata();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndpointMetadata(IReadOnlyList`1<object> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal object get_CachedFactoryContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_CachedFactoryContext(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.ResponseExtensions : object {
    [ExtensionAttribute]
public static void Clear(HttpResponse response);
    [ExtensionAttribute]
public static void Redirect(HttpResponse response, string location, bool permanent, bool preserveMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.SendFileResponseExtensions : object {
    [ExtensionAttribute]
public static Task SendFileAsync(HttpResponse response, IFileInfo file, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendFileAsync(HttpResponse response, IFileInfo file, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendFileAsync(HttpResponse response, string fileName, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendFileAsync(HttpResponse response, string fileName, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.SessionExtensions : object {
    [ExtensionAttribute]
public static void SetInt32(ISession session, string key, int value);
    [ExtensionAttribute]
public static Nullable`1<int> GetInt32(ISession session, string key);
    [ExtensionAttribute]
public static void SetString(ISession session, string key, string value);
    [ExtensionAttribute]
public static string GetString(ISession session, string key);
    [ExtensionAttribute]
public static Byte[] Get(ISession session, string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Http.StreamCopyOperationInternal : object {
    public static Task CopyToAsync(Stream source, Stream destination, Nullable`1<long> count, CancellationToken cancel);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Http.StreamCopyOperationInternal/<CopyToAsync>d__2")]
public static Task CopyToAsync(Stream source, Stream destination, Nullable`1<long> count, int bufferSize, CancellationToken cancel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4164")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Http.TagsAttribute : Attribute {
    public IReadOnlyList`1<string> Tags { get; }
    public TagsAttribute(String[] tags);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_Tags();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Internal.ExecuteHandlerHelper : object {
    public static Task ExecuteReturnAsync(object obj, HttpContext httpContext, JsonTypeInfo`1<object> jsonTypeInfo);
    public static void SetPlaintextContentType(HttpContext httpContext);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:RequiresDynamicCode")]
public static Task WriteJsonResponseAsync(HttpResponse response, T value, JsonTypeInfo`1<T> jsonTypeInfo);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.HttpJsonServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IServiceCollection ConfigureHttpJsonOptions(IServiceCollection services, Action`1<JsonOptions> configureOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ProblemDetailsServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddProblemDetails(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddProblemDetails(IServiceCollection services, Action`1<ProblemDetailsOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.AwaitableInfo : ValueType {
    private static BindingFlags Everything;
    private static MethodInfo INotifyCompletion_OnCompleted;
    private static MethodInfo ICriticalNotifyCompletion_UnsafeOnCompleted;
    [CompilerGeneratedAttribute]
private Type <AwaiterType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <AwaiterIsCompletedProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterGetResultMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterOnCompletedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <AwaiterUnsafeOnCompletedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <GetAwaiterMethod>k__BackingField;
    public Type AwaiterType { get; }
    public PropertyInfo AwaiterIsCompletedProperty { get; }
    public MethodInfo AwaiterGetResultMethod { get; }
    public MethodInfo AwaiterOnCompletedMethod { get; }
    [NullableAttribute("2")]
public MethodInfo AwaiterUnsafeOnCompletedMethod { get; }
    public Type ResultType { get; }
    public MethodInfo GetAwaiterMethod { get; }
    public AwaitableInfo(Type awaiterType, PropertyInfo awaiterIsCompletedProperty, MethodInfo awaiterGetResultMethod, MethodInfo awaiterOnCompletedMethod, MethodInfo awaiterUnsafeOnCompletedMethod, Type resultType, MethodInfo getAwaiterMethod);
    [CompilerGeneratedAttribute]
public Type get_AwaiterType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_AwaiterIsCompletedProperty();
    [CompilerGeneratedAttribute]
public MethodInfo get_AwaiterGetResultMethod();
    [CompilerGeneratedAttribute]
public MethodInfo get_AwaiterOnCompletedMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodInfo get_AwaiterUnsafeOnCompletedMethod();
    [CompilerGeneratedAttribute]
public Type get_ResultType();
    [CompilerGeneratedAttribute]
public MethodInfo get_GetAwaiterMethod();
    [UnconditionalSuppressMessageAttribute("Trimmer", "IL2070")]
[UnconditionalSuppressMessageAttribute("Trimmer", "IL2075")]
public static bool IsTypeAwaitable(Type type, AwaitableInfo& awaitableInfo);
}
internal static class Microsoft.Extensions.Internal.ClosedGenericMatcher : object {
    [NullableContextAttribute("1")]
public static Type ExtractGenericInterface(Type queryType, Type interfaceType);
}
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.CoercedAwaitableInfo : ValueType {
    [CompilerGeneratedAttribute]
private AwaitableInfo <AwaitableInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <CoercerExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CoercerResultType>k__BackingField;
    public AwaitableInfo AwaitableInfo { get; }
    public Expression CoercerExpression { get; }
    public Type CoercerResultType { get; }
    public bool RequiresCoercion { get; }
    public CoercedAwaitableInfo(AwaitableInfo awaitableInfo);
    public CoercedAwaitableInfo(Expression coercerExpression, Type coercerResultType, AwaitableInfo coercedAwaitableInfo);
    [CompilerGeneratedAttribute]
public AwaitableInfo get_AwaitableInfo();
    [CompilerGeneratedAttribute]
public Expression get_CoercerExpression();
    [CompilerGeneratedAttribute]
public Type get_CoercerResultType();
    public bool get_RequiresCoercion();
    [RequiresDynamicCodeAttribute("Dynamically generates calls to FSharpAsync.")]
public static bool IsTypeAwaitable(Type type, CoercedAwaitableInfo& info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("ObjectMethodExecutor performs reflection on arbitrary types.")]
[RequiresDynamicCodeAttribute("ObjectMethodExecutor performs reflection on arbitrary types.")]
internal class Microsoft.Extensions.Internal.ObjectMethodExecutor : object {
    public MethodInfo MethodInfo { get; }
    public ParameterInfo[] MethodParameters { get; }
    public TypeInfo TargetTypeInfo { get; }
    [NullableAttribute("2")]
public Type AsyncResultType { get; }
    public Type MethodReturnType { get; internal set; }
    public bool IsMethodAsync { get; }
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodInfo();
    [CompilerGeneratedAttribute]
public ParameterInfo[] get_MethodParameters();
    [CompilerGeneratedAttribute]
public TypeInfo get_TargetTypeInfo();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_AsyncResultType();
    [CompilerGeneratedAttribute]
public Type get_MethodReturnType();
    [CompilerGeneratedAttribute]
internal void set_MethodReturnType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMethodAsync();
    public static ObjectMethodExecutor Create(MethodInfo methodInfo, TypeInfo targetTypeInfo);
    public static ObjectMethodExecutor Create(MethodInfo methodInfo, TypeInfo targetTypeInfo, Object[] parameterDefaultValues);
    [NullableContextAttribute("2")]
public object Execute(object target, Object[] parameters);
    public ObjectMethodExecutorAwaitable ExecuteAsync(object target, Object[] parameters);
    [NullableContextAttribute("2")]
public object GetDefaultValueForParameter(int index);
}
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Internal.ObjectMethodExecutorAwaitable : ValueType {
    private object _customAwaitable;
    private Func`2<object, object> _getAwaiterMethod;
    private Func`2<object, bool> _isCompletedMethod;
    private Func`2<object, object> _getResultMethod;
    private Action`2<object, Action> _onCompletedMethod;
    private Action`2<object, Action> _unsafeOnCompletedMethod;
    public ObjectMethodExecutorAwaitable(object customAwaitable, Func`2<object, object> getAwaiterMethod, Func`2<object, bool> isCompletedMethod, Func`2<object, object> getResultMethod, Action`2<object, Action> onCompletedMethod, Action`2<object, Action> unsafeOnCompletedMethod);
    public Awaiter GetAwaiter();
}
[RequiresDynamicCodeAttribute("Dynamically generates calls to FSharpAsync.")]
internal static class Microsoft.Extensions.Internal.ObjectMethodExecutorFSharpSupport : object {
    [UnconditionalSuppressMessageAttribute("Trimmer", "IL2060")]
public static bool TryBuildCoercerFromFSharpAsyncToAwaitable(Type possibleFSharpAsyncType, Expression& coerceToAwaitableExpression, Type& awaitableType);
}
internal static class Microsoft.Extensions.Internal.TypeNameHelper : object {
    [NullableContextAttribute("2")]
public static string GetTypeDisplayName(object item, bool fullName);
    [NullableContextAttribute("1")]
public static string GetTypeDisplayName(Type type, bool fullName, bool includeGenericParameterNames, bool includeGenericParameters, char nestedTypeDelimiter);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    [NullableContextAttribute("2")]
public void Insert(int index, string s);
    public void Append(char c);
    [NullableContextAttribute("2")]
public void Append(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    public void Dispose();
}
