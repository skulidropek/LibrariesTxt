[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.BufferWriter : ValueType {
    private IBufferWriter`1<byte> _output;
    private Span`1<byte> _span;
    private ArraySegment`1<byte> _segment;
    private int _buffered;
    private long _bytesCommitted;
    private SequencePool _sequencePool;
    private Rental _rental;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    internal IBufferWriter`1<byte> UnderlyingWriter { get; }
    internal Rental SequenceRental { get; }
    public BufferWriter(IBufferWriter`1<byte> output);
    internal BufferWriter(SequencePool sequencePool, Byte[] array);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    internal IBufferWriter`1<byte> get_UnderlyingWriter();
    internal Rental get_SequenceRental();
    public Span`1<byte> GetSpan(int sizeHint);
    public Byte& GetPointer(int sizeHint);
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    internal bool TryGetUncommittedSpan(ReadOnlySpan`1& span);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
    private void MigrateToSequence();
}
internal class MessagePack.ExtensionHeader : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public UInt32 Length { get; private set; }
    public ExtensionHeader(sbyte typeCode, UInt32 length);
    public ExtensionHeader(sbyte typeCode, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(UInt32 value);
    public sealed virtual bool Equals(ExtensionHeader other);
}
internal class MessagePack.ExtensionResult : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <Data>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public ReadOnlySequence`1<byte> Data { get; private set; }
    public ExtensionHeader Header { get; }
    public ExtensionResult(sbyte typeCode, Memory`1<byte> data);
    public ExtensionResult(sbyte typeCode, ReadOnlySequence`1<byte> data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ReadOnlySequence`1<byte> value);
    public ExtensionHeader get_Header();
}
internal static class MessagePack.Internal.DateTimeConstants : object {
    internal static long BclSecondsAtUnixEpoch;
    internal static int NanosecondsPerTick;
    internal static DateTime UnixEpoch;
    private static DateTimeConstants();
}
internal static class MessagePack.MessagePackCode : object {
    public static byte MinFixInt;
    public static byte MaxFixInt;
    public static byte MinFixMap;
    public static byte MaxFixMap;
    public static byte MinFixArray;
    public static byte MaxFixArray;
    public static byte MinFixStr;
    public static byte MaxFixStr;
    public static byte Nil;
    public static byte NeverUsed;
    public static byte False;
    public static byte True;
    public static byte Bin8;
    public static byte Bin16;
    public static byte Bin32;
    public static byte Ext8;
    public static byte Ext16;
    public static byte Ext32;
    public static byte Float32;
    public static byte Float64;
    public static byte UInt8;
    public static byte UInt16;
    public static byte UInt32;
    public static byte UInt64;
    public static byte Int8;
    public static byte Int16;
    public static byte Int32;
    public static byte Int64;
    public static byte FixExt1;
    public static byte FixExt2;
    public static byte FixExt4;
    public static byte FixExt8;
    public static byte FixExt16;
    public static byte Str8;
    public static byte Str16;
    public static byte Str32;
    public static byte Array16;
    public static byte Array32;
    public static byte Map16;
    public static byte Map32;
    public static byte MinNegativeFixInt;
    public static byte MaxNegativeFixInt;
    private static MessagePackType[] TypeLookupTable;
    private static String[] FormatNameTable;
    private static MessagePackCode();
    public static MessagePackType ToMessagePackType(byte code);
    [NullableContextAttribute("1")]
public static string ToFormatName(byte code);
    internal static bool IsSignedInteger(byte code);
}
internal static class MessagePack.MessagePackRange : object {
    public static int MinFixNegativeInt;
    public static int MaxFixNegativeInt;
    public static int MaxFixPositiveInt;
    public static int MinFixStringLength;
    public static int MaxFixStringLength;
    public static int MaxFixMapCount;
    public static int MaxFixArrayCount;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.MessagePackReader : ValueType {
    private SequenceReader`1<byte> reader;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public int Depth { get; public set; }
    public ReadOnlySequence`1<byte> Sequence { get; }
    public SequencePosition Position { get; }
    public long Consumed { get; }
    public bool End { get; }
    public bool IsNil { get; }
    public MessagePackType NextMessagePackType { get; }
    public byte NextCode { get; }
    public MessagePackReader(ReadOnlyMemory`1<byte> memory);
    public MessagePackReader(ReadOnlySequence`1& readOnlySequence);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    public ReadOnlySequence`1<byte> get_Sequence();
    public SequencePosition get_Position();
    public long get_Consumed();
    public bool get_End();
    public bool get_IsNil();
    public MessagePackType get_NextMessagePackType();
    public byte get_NextCode();
    public MessagePackReader Clone(ReadOnlySequence`1& readOnlySequence);
    public MessagePackReader CreatePeekReader();
    public void Skip();
    internal bool TrySkip();
    public Nil ReadNil();
    public bool TryReadNil();
    public ReadOnlySequence`1<byte> ReadRaw(long length);
    public ReadOnlySequence`1<byte> ReadRaw();
    public int ReadArrayHeader();
    public bool TryReadArrayHeader(Int32& count);
    public int ReadMapHeader();
    public bool TryReadMapHeader(Int32& count);
    public bool ReadBoolean();
    public char ReadChar();
    public float ReadSingle();
    public double ReadDouble();
    public DateTime ReadDateTime();
    public DateTime ReadDateTime(ExtensionHeader header);
    public Nullable`1<ReadOnlySequence`1<byte>> ReadBytes();
    public Nullable`1<ReadOnlySequence`1<byte>> ReadStringSequence();
    public bool TryReadStringSpan(ReadOnlySpan`1& span);
    [NullableContextAttribute("1")]
public string ReadString();
    public ExtensionHeader ReadExtensionFormatHeader();
    public bool TryReadExtensionFormatHeader(ExtensionHeader& extensionHeader);
    public ExtensionResult ReadExtensionFormat();
    private static EndOfStreamException ThrowNotEnoughBytesException();
    private static EndOfStreamException ThrowNotEnoughBytesException(Exception innerException);
    private static Exception ThrowInvalidCode(byte code);
    private static void ThrowInsufficientBufferUnless(bool condition);
    private int GetBytesLength();
    private bool TryGetBytesLength(Int32& length);
    private bool TryGetStringLengthInBytes(Int32& length);
    private int GetStringLengthInBytes();
    private bool TryGetStringLengthInBytesSlow(byte code, Int32& length);
    private string ReadStringSlow(int byteLength);
    private bool TrySkipNextArray();
    private bool TrySkipNextMap();
    private bool TrySkip(int count);
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.MessagePackSerializationException : Exception {
    public MessagePackSerializationException(string message);
    public MessagePackSerializationException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
protected MessagePackSerializationException(SerializationInfo info, StreamingContext context);
}
internal enum MessagePack.MessagePackType : Enum {
    public byte value__;
    public static MessagePackType Unknown;
    public static MessagePackType Integer;
    public static MessagePackType Nil;
    public static MessagePackType Boolean;
    public static MessagePackType Float;
    public static MessagePackType String;
    public static MessagePackType Binary;
    public static MessagePackType Array;
    public static MessagePackType Map;
    public static MessagePackType Extension;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.MessagePackWriter : ValueType {
    private BufferWriter writer;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldSpec>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public bool OldSpec { get; public set; }
    [NullableContextAttribute("1")]
public MessagePackWriter(IBufferWriter`1<byte> writer);
    [NullableContextAttribute("1")]
internal MessagePackWriter(SequencePool sequencePool, Byte[] array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_OldSpec();
    [CompilerGeneratedAttribute]
public void set_OldSpec(bool value);
    [NullableContextAttribute("1")]
public MessagePackWriter Clone(IBufferWriter`1<byte> writer);
    public void Flush();
    public void WriteNil();
    public void WriteRaw(ReadOnlySpan`1<byte> rawMessagePackBlock);
    public void WriteRaw(ReadOnlySequence`1& rawMessagePackBlock);
    public void WriteArrayHeader(int count);
    public void WriteArrayHeader(UInt32 count);
    public void WriteMapHeader(int count);
    public void WriteMapHeader(UInt32 count);
    public void Write(byte value);
    public void WriteUInt8(byte value);
    public void Write(sbyte value);
    public void WriteInt8(sbyte value);
    public void Write(ushort value);
    public void WriteUInt16(ushort value);
    public void Write(short value);
    public void WriteInt16(short value);
    public void Write(UInt32 value);
    public void WriteUInt32(UInt32 value);
    public void Write(int value);
    public void WriteInt32(int value);
    public void Write(ulong value);
    public void WriteUInt64(ulong value);
    public void Write(long value);
    public void WriteInt64(long value);
    public void Write(bool value);
    public void Write(char value);
    public void Write(float value);
    public void Write(double value);
    public void Write(DateTime dateTime);
    [NullableContextAttribute("1")]
public void Write(Byte[] src);
    public void Write(ReadOnlySpan`1<byte> src);
    public void Write(ReadOnlySequence`1& src);
    public void WriteBinHeader(int length);
    public void WriteString(ReadOnlySequence`1& utf8stringBytes);
    public void WriteString(ReadOnlySpan`1<byte> utf8stringBytes);
    public void WriteStringHeader(int byteCount);
    [NullableContextAttribute("1")]
public void Write(string value);
    public void Write(ReadOnlySpan`1<char> value);
    public void WriteExtensionFormatHeader(ExtensionHeader extensionHeader);
    public void WriteExtensionFormat(ExtensionResult extensionData);
    public Span`1<byte> GetSpan(int length);
    public void Advance(int length);
    internal void WriteBigEndian(ushort value);
    internal void WriteBigEndian(UInt32 value);
    internal void WriteBigEndian(ulong value);
    [NullableContextAttribute("1")]
internal Byte[] FlushAndGetArray();
    private static void WriteBigEndian(short value, Span`1<byte> span);
    private static void WriteBigEndian(int value, Span`1<byte> span);
    private static void WriteBigEndian(long value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Byte* span);
    private static void WriteBigEndian(UInt32 value, Span`1<byte> span);
    private static void WriteBigEndian(UInt32 value, Byte* span);
    private static void WriteBigEndian(ulong value, Span`1<byte> span);
    private static void WriteBigEndian(float value, Span`1<byte> span);
    private static void WriteBigEndian(double value, Span`1<byte> span);
    private Byte& WriteString_PrepareSpan(int characterLength, Int32& bufferSize, Int32& encodedBytesOffset);
    private void WriteString_PostEncoding(Byte* pBuffer, int estimatedOffset, int byteCount);
    private static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
}
internal class MessagePack.Nil : ValueType {
    public static Nil Default;
    public static bool op_Equality(Nil left, Nil right);
    public static bool op_Inequality(Nil left, Nil right);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Nil other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal static class MessagePack.ReservedMessagePackExtensionTypeCode : object {
    public static sbyte DateTime;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MessagePack.SequencePool : object {
    internal static SequencePool Shared;
    private static int MinimumSpanLength;
    private int maxSize;
    private Stack`1<Sequence`1<byte>> pool;
    private ArrayPool`1<byte> arrayPool;
    public SequencePool(int maxSize);
    public SequencePool(int maxSize, ArrayPool`1<byte> arrayPool);
    private static SequencePool();
    internal Rental Rent();
    private void Return(Sequence`1<byte> value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MessagePack.SequenceReader`1 : ValueType {
    private bool usingSequence;
    private ReadOnlySequence`1<T> sequence;
    private SequencePosition currentPosition;
    private SequencePosition nextPosition;
    private ReadOnlyMemory`1<T> memory;
    private bool moreData;
    private long length;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1& sequence);
    public SequenceReader`1(ReadOnlyMemory`1<T> memory);
    public bool get_End();
    public ReadOnlySequence`1<T> get_Sequence();
    public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    public long get_Remaining();
    public long get_Length();
    public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    internal bool TryAdvance(long count);
    private void AdvanceToNextSpan(long count);
    public bool TryCopyTo(Span`1<T> destination);
    internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
internal static class MessagePack.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryRead(SequenceReader`1& reader, SByte& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Single& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Double& value);
}
internal static class MessagePack.StringEncoding : object {
    [NullableAttribute("1")]
internal static Encoding UTF8;
    private static StringEncoding();
}
[ExtensionAttribute]
internal static class MessagePack.Utilities : object {
    internal static bool IsMono;
    private static Utilities();
    [NullableContextAttribute("1")]
internal static Byte[] GetWriterBytes(TArg arg, GetWriterBytesAction`1<TArg> action, SequencePool pool);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static Memory`1<T> GetMemoryCheckResult(IBufferWriter`1<T> bufferWriter, int size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Builder.CircuitJavaScriptInitializationMiddleware : object {
    private IList`1<string> _initializers;
    public CircuitJavaScriptInitializationMiddleware(IOptions`1<CircuitOptions> options, RequestDelegate _);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Builder.CircuitJavaScriptInitializationMiddleware/<InvokeAsync>d__2")]
public Task InvokeAsync(HttpContext context);
}
public class Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder : object {
    private IEndpointConventionBuilder _hubEndpoint;
    private IEndpointConventionBuilder _disconnectEndpoint;
    private IEndpointConventionBuilder _jsInitializersEndpoint;
    private IEndpointConventionBuilder _blazorEndpoint;
    [NullableContextAttribute("1")]
internal ComponentEndpointConventionBuilder(IEndpointConventionBuilder hubEndpoint, IEndpointConventionBuilder disconnectEndpoint, IEndpointConventionBuilder jsInitializersEndpoint, IEndpointConventionBuilder blazorEndpoint);
    [NullableContextAttribute("1")]
public sealed virtual void Add(Action`1<EndpointBuilder> convention);
    [NullableContextAttribute("1")]
public sealed virtual void Finally(Action`1<EndpointBuilder> finalConvention);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions : object {
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, string path);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, Action`1<HttpConnectionDispatcherOptions> configureOptions);
    [ExtensionAttribute]
public static ComponentEndpointConventionBuilder MapBlazorHub(IEndpointRouteBuilder endpoints, string path, Action`1<HttpConnectionDispatcherOptions> configureOptions);
    private static IEndpointConventionBuilder GetBlazorEndpoint(IEndpointRouteBuilder endpoints);
}
internal class Microsoft.AspNetCore.Builder.InternalServerRenderMode : InteractiveServerRenderMode {
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.ServerRazorComponentsEndpointConventionBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RazorComponentsEndpointConventionBuilder AddInteractiveServerRenderMode(RazorComponentsEndpointConventionBuilder builder);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentEndMarker : ValueType {
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    public string PrerenderId { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarker : ValueType {
    [NullableAttribute("1")]
public static string ServerMarkerType;
    [NullableAttribute("1")]
public static string WebAssemblyMarkerType;
    [NullableAttribute("1")]
public static string AutoMarkerType;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterValues>k__BackingField;
    public string Type { get; public set; }
    public string PrerenderId { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public Nullable`1<int> Sequence { get; public set; }
    public string Descriptor { get; public set; }
    public string Assembly { get; public set; }
    public string TypeName { get; public set; }
    public string ParameterDefinitions { get; public set; }
    public string ParameterValues { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(string value);
    [NullableContextAttribute("1")]
public static ComponentMarker Create(string type, bool prerendered, Nullable`1<ComponentMarkerKey> key);
    [NullableContextAttribute("1")]
public void WriteServerData(int sequence, string descriptor);
    [NullableContextAttribute("1")]
public void WriteWebAssemblyData(string assembly, string typeName, string parameterDefinitions, string parameterValues);
    public Nullable`1<ComponentEndMarker> ToEndMarker();
    private static string GeneratePrerenderId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarkerKey : ValueType {
    [CompilerGeneratedAttribute]
private string <LocationHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedComponentKey>k__BackingField;
    public string LocationHash { get; public set; }
    [NullableAttribute("2")]
public string FormattedComponentKey { get; public set; }
    public ComponentMarkerKey(string locationHash, string formattedComponentKey);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocationHash();
    [CompilerGeneratedAttribute]
public void set_LocationHash(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FormattedComponentKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FormattedComponentKey(string value);
    public static bool op_Equality(ComponentMarkerKey left, ComponentMarkerKey right);
    public static bool op_Inequality(ComponentMarkerKey left, ComponentMarkerKey right);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(ComponentMarkerKey other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string Assembly { get; public set; }
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    public static ValueTuple`2<IList`1<ComponentParameter>, IList`1<object>> FromParameterView(ParameterView parameters);
}
internal class Microsoft.AspNetCore.Components.ComponentParametersTypeCache : object {
    private ConcurrentDictionary`2<Key, Type> _typeToKeyLookUp;
    [NullableContextAttribute("1")]
public Type GetParameterType(string assembly, string type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private static Type ResolveType(Key key, Assembly[] assemblies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ElementReferenceJsonConverter : JsonConverter`1<ElementReference> {
    private static JsonEncodedText IdProperty;
    private ElementReferenceContext _elementReferenceContext;
    public ElementReferenceJsonConverter(ElementReferenceContext elementReferenceContext);
    private static ElementReferenceJsonConverter();
    public virtual ElementReference Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ElementReference value, JsonSerializerOptions options);
}
internal class Microsoft.AspNetCore.Components.Forms.DefaultAntiforgeryStateProvider : AntiforgeryStateProvider {
    private static string PersistenceKey;
    private PersistingComponentStateSubscription _subscription;
    private AntiforgeryRequestToken _currentToken;
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
public DefaultAntiforgeryStateProvider(PersistentComponentState state);
    [NullableContextAttribute("2")]
public virtual AntiforgeryRequestToken GetAntiforgeryToken();
    public sealed virtual void Dispose();
}
internal static class Microsoft.AspNetCore.Components.JsonSerializerOptionsProvider : object {
    [NullableAttribute("1")]
public static JsonSerializerOptions Options;
    private static JsonSerializerOptionsProvider();
}
internal class Microsoft.AspNetCore.Components.PrerenderComponentApplicationStore : object {
    private bool _stateIsPersisted;
    [CompilerGeneratedAttribute]
private string <PersistedState>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Byte[]> <ExistingState>k__BackingField;
    [NullableAttribute("2")]
public string PersistedState { get; private set; }
    public Dictionary`2<string, Byte[]> ExistingState { get; protected set; }
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public PrerenderComponentApplicationStore(string existingState);
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected void DeserializeState(Byte[] existingState);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PersistedState();
    [CompilerGeneratedAttribute]
private void set_PersistedState(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Byte[]> get_ExistingState();
    [CompilerGeneratedAttribute]
protected void set_ExistingState(Dictionary`2<string, Byte[]> value);
    public sealed virtual Task`1<IDictionary`2<string, Byte[]>> GetPersistedStateAsync();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    public sealed virtual Task PersistStateAsync(IReadOnlyDictionary`2<string, Byte[]> state);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ProtectedPrerenderComponentApplicationStore : PrerenderComponentApplicationStore {
    private IDataProtector _protector;
    public ProtectedPrerenderComponentApplicationStore(IDataProtectionProvider dataProtectionProvider);
    public ProtectedPrerenderComponentApplicationStore(string existingState, IDataProtectionProvider dataProtectionProvider);
    protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    private void CreateProtector(IDataProtectionProvider dataProtectionProvider);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.RootComponentOperation : object {
    [CompilerGeneratedAttribute]
private RootComponentOperationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SsrComponentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarker> <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRootComponentDescriptor <Descriptor>k__BackingField;
    public RootComponentOperationType Type { get; public set; }
    public int SsrComponentId { get; public set; }
    public Nullable`1<ComponentMarker> Marker { get; public set; }
    [JsonIgnoreAttribute]
public WebRootComponentDescriptor Descriptor { get; public set; }
    [CompilerGeneratedAttribute]
public RootComponentOperationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RootComponentOperationType value);
    [CompilerGeneratedAttribute]
public int get_SsrComponentId();
    [CompilerGeneratedAttribute]
public void set_SsrComponentId(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<ComponentMarker> get_Marker();
    [CompilerGeneratedAttribute]
public void set_Marker(Nullable`1<ComponentMarker> value);
    [CompilerGeneratedAttribute]
public WebRootComponentDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(WebRootComponentDescriptor value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.AspNetCore.Components.RootComponentOperationBatch : object {
    [CompilerGeneratedAttribute]
private long <BatchId>k__BackingField;
    [CompilerGeneratedAttribute]
private RootComponentOperation[] <Operations>k__BackingField;
    public long BatchId { get; public set; }
    [RequiredMemberAttribute]
public RootComponentOperation[] Operations { get; public set; }
    [CompilerGeneratedAttribute]
public long get_BatchId();
    [CompilerGeneratedAttribute]
public void set_BatchId(long value);
    [CompilerGeneratedAttribute]
public RootComponentOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(RootComponentOperation[] value);
}
[JsonConverterAttribute("System.Text.Json.Serialization.JsonStringEnumConverter`1<Microsoft.AspNetCore.Components.RootComponentOperationType>")]
internal enum Microsoft.AspNetCore.Components.RootComponentOperationType : Enum {
    public int value__;
    public static RootComponentOperationType Add;
    public static RootComponentOperationType Update;
    public static RootComponentOperationType Remove;
}
internal class Microsoft.AspNetCore.Components.RootComponentTypeCache : object {
    private ConcurrentDictionary`2<Key, Type> _typeToKeyLookUp;
    [NullableContextAttribute("1")]
public Type GetRootComponent(string assembly, string type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private static Type ResolveType(Key key, Assembly[] assemblies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NonDefaultHubProtocolAttribute]
internal class Microsoft.AspNetCore.Components.Server.BlazorPack.BlazorPackHubProtocol : object {
    internal static string ProtocolName;
    private static int ProtocolVersion;
    private BlazorPackHubProtocolWorker _worker;
    public string Name { get; }
    public int Version { get; }
    public TransferFormat TransferFormat { get; }
    public sealed virtual string get_Name();
    public sealed virtual int get_Version();
    public sealed virtual TransferFormat get_TransferFormat();
    public sealed virtual bool IsVersionSupported(int version);
    public sealed virtual bool TryParseMessage(ReadOnlySequence`1& input, IInvocationBinder binder, HubMessage& message);
    public sealed virtual void WriteMessage(HubMessage message, IBufferWriter`1<byte> output);
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<byte> GetMessageBytes(HubMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.BlazorPack.BlazorPackHubProtocolWorker : MessagePackHubProtocolWorker {
    protected virtual object DeserializeObject(MessagePackReader& reader, Type type, string field);
    protected virtual void Serialize(MessagePackWriter& writer, Type type, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware : object {
    private static string CircuitIdKey;
    [CompilerGeneratedAttribute]
private ILogger`1<CircuitDisconnectMiddleware> <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private CircuitRegistry <Registry>k__BackingField;
    [CompilerGeneratedAttribute]
private CircuitIdFactory <CircuitIdFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestDelegate <Next>k__BackingField;
    public ILogger`1<CircuitDisconnectMiddleware> Logger { get; }
    public CircuitRegistry Registry { get; }
    public CircuitIdFactory CircuitIdFactory { get; }
    public RequestDelegate Next { get; }
    public CircuitDisconnectMiddleware(ILogger`1<CircuitDisconnectMiddleware> logger, CircuitRegistry registry, CircuitIdFactory circuitIdFactory, RequestDelegate next);
    [CompilerGeneratedAttribute]
public ILogger`1<CircuitDisconnectMiddleware> get_Logger();
    [CompilerGeneratedAttribute]
public CircuitRegistry get_Registry();
    [CompilerGeneratedAttribute]
public CircuitIdFactory get_CircuitIdFactory();
    [CompilerGeneratedAttribute]
public RequestDelegate get_Next();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware/<Invoke>d__14")]
public Task Invoke(HttpContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware/<GetCircuitIdAsync>d__15")]
private Task`1<Nullable`1<CircuitId>> GetCircuitIdAsync(HttpContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.CircuitDisconnectMiddleware/<TerminateCircuitGracefully>d__16")]
private Task TerminateCircuitGracefully(CircuitId circuitId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.CircuitOptions : object {
    [CompilerGeneratedAttribute]
private int <DisconnectedCircuitMaxRetained>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DisconnectedCircuitRetentionPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetailedErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <JSInteropDefaultCallTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBufferedUnacknowledgedRenderBatches>k__BackingField;
    [CompilerGeneratedAttribute]
private CircuitRootComponentOptions <RootComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <JavaScriptInitializers>k__BackingField;
    public int DisconnectedCircuitMaxRetained { get; public set; }
    public TimeSpan DisconnectedCircuitRetentionPeriod { get; public set; }
    public bool DetailedErrors { get; public set; }
    public TimeSpan JSInteropDefaultCallTimeout { get; public set; }
    public int MaxBufferedUnacknowledgedRenderBatches { get; public set; }
    public CircuitRootComponentOptions RootComponents { get; }
    internal IList`1<string> JavaScriptInitializers { get; }
    [CompilerGeneratedAttribute]
public int get_DisconnectedCircuitMaxRetained();
    [CompilerGeneratedAttribute]
public void set_DisconnectedCircuitMaxRetained(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisconnectedCircuitRetentionPeriod();
    [CompilerGeneratedAttribute]
public void set_DisconnectedCircuitRetentionPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_DetailedErrors();
    [CompilerGeneratedAttribute]
public void set_DetailedErrors(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_JSInteropDefaultCallTimeout();
    [CompilerGeneratedAttribute]
public void set_JSInteropDefaultCallTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxBufferedUnacknowledgedRenderBatches();
    [CompilerGeneratedAttribute]
public void set_MaxBufferedUnacknowledgedRenderBatches(int value);
    [CompilerGeneratedAttribute]
public CircuitRootComponentOptions get_RootComponents();
    [CompilerGeneratedAttribute]
internal IList`1<string> get_JavaScriptInitializers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.CircuitOptionsJSInteropDetailedErrorsConfiguration : object {
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    public IConfiguration Configuration { get; }
    public CircuitOptionsJSInteropDetailedErrorsConfiguration(IConfiguration configuration);
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    public sealed virtual void Configure(CircuitOptions options);
}
public class Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions : object {
    [CompilerGeneratedAttribute]
private JSComponentConfigurationStore <JSComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxJSRootComponents>k__BackingField;
    [NullableAttribute("1")]
public JSComponentConfigurationStore JSComponents { get; }
    public int MaxJSRootComponents { get; public set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual JSComponentConfigurationStore get_JSComponents();
    [CompilerGeneratedAttribute]
public int get_MaxJSRootComponents();
    [CompilerGeneratedAttribute]
public void set_MaxJSRootComponents(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.ArrayBuilder`1 : object {
    protected T[] _items;
    protected int _itemsInUse;
    private static T[] Empty;
    private ArrayPool`1<T> _arrayPool;
    private int _minCapacity;
    private bool _disposed;
    public int Count { get; }
    public T[] Buffer { get; }
    public ArrayBuilder`1(int minCapacity, ArrayPool`1<T> arrayPool);
    private static ArrayBuilder`1();
    public int get_Count();
    public T[] get_Buffer();
    public int Append(T& item);
    internal int Append(T[] source, int startIndex, int length);
    internal int Append(ReadOnlySpan`1<T> source);
    public void Overwrite(int index, T& value);
    public void RemoveLast();
    public void InsertExpensive(int index, T value);
    public void Clear();
    protected void GrowBuffer(int desiredCapacity);
    private void ReturnBuffer();
    public sealed virtual void Dispose();
    private static void ThrowIndexOutOfBoundsException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.ArrayBuilderMemoryStream : Stream {
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<byte> <ArrayBuilder>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ArrayBuilder`1<byte> ArrayBuilder { get; }
    public ArrayBuilderMemoryStream(ArrayBuilder`1<byte> arrayBuilder);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public ArrayBuilder`1<byte> get_ArrayBuilder();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> memory, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.Circuits.Circuit : object {
    private CircuitHost _circuitHost;
    public string Id { get; }
    internal Circuit(CircuitHost circuitHost);
    public string get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitClientProxy : object {
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientProxy <Client>k__BackingField;
    public bool Connected { get; private set; }
    public string ConnectionId { get; private set; }
    public IClientProxy Client { get; private set; }
    public CircuitClientProxy(IClientProxy clientProxy, string connectionId);
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
private void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [CompilerGeneratedAttribute]
private void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public IClientProxy get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(IClientProxy value);
    public void Transfer(IClientProxy clientProxy, string connectionId);
    public void SetDisconnected();
    public sealed virtual Task SendCoreAsync(string method, Object[] args, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitFactory : object {
    private IServiceScopeFactory _scopeFactory;
    private ILoggerFactory _loggerFactory;
    private CircuitIdFactory _circuitIdFactory;
    private CircuitOptions _options;
    private ILogger _logger;
    [NullableContextAttribute("1")]
public CircuitFactory(IServiceScopeFactory scopeFactory, ILoggerFactory loggerFactory, CircuitIdFactory circuitIdFactory, IOptions`1<CircuitOptions> options);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitFactory/<CreateCircuitHostAsync>d__6")]
public sealed virtual ValueTask`1<CircuitHost> CreateCircuitHostAsync(IReadOnlyList`1<ComponentDescriptor> components, CircuitClientProxy client, string baseUri, string uri, ClaimsPrincipal user, IPersistentComponentStateStore store);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandle : object {
    [CompilerGeneratedAttribute]
private CircuitHost <CircuitHost>k__BackingField;
    public CircuitHost CircuitHost { get; public set; }
    [CompilerGeneratedAttribute]
public CircuitHost get_CircuitHost();
    [CompilerGeneratedAttribute]
public void set_CircuitHost(CircuitHost value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler : object {
    public int Order { get; }
    public virtual int get_Order();
    public virtual Task OnCircuitOpenedAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnConnectionUpAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnConnectionDownAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Task OnCircuitClosedAsync(Circuit circuit, CancellationToken cancellationToken);
    public virtual Func`2<CircuitInboundActivityContext, Task> CreateInboundActivityHandler(Func`2<CircuitInboundActivityContext, Task> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandleRegistry : object {
    public sealed virtual CircuitHandle GetCircuitHandle(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public sealed virtual CircuitHost GetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public sealed virtual void SetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey, CircuitHost circuitHost);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost : object {
    private AsyncServiceScope _scope;
    private CircuitOptions _options;
    private RemoteNavigationManager _navigationManager;
    private ILogger _logger;
    private Func`2<Func`1<Task>, Task> _dispatchInboundActivity;
    private CircuitHandler[] _circuitHandlers;
    private bool _initialized;
    private bool _isFirstUpdate;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private CircuitHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private CircuitId <CircuitId>k__BackingField;
    [CompilerGeneratedAttribute]
private Circuit <Circuit>k__BackingField;
    [CompilerGeneratedAttribute]
private CircuitClientProxy <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteJSRuntime <JSRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteRenderer <Renderer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ComponentDescriptor> <Descriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    public CircuitHandle Handle { get; }
    public CircuitId CircuitId { get; }
    public Circuit Circuit { get; }
    public CircuitClientProxy Client { get; public set; }
    public RemoteJSRuntime JSRuntime { get; }
    public RemoteRenderer Renderer { get; }
    public IReadOnlyList`1<ComponentDescriptor> Descriptors { get; }
    public IServiceProvider Services { get; }
    public CircuitHost(CircuitId circuitId, AsyncServiceScope scope, CircuitOptions options, CircuitClientProxy client, RemoteRenderer renderer, IReadOnlyList`1<ComponentDescriptor> descriptors, RemoteJSRuntime jsRuntime, RemoteNavigationManager navigationManager, CircuitHandler[] circuitHandlers, ILogger logger);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public CircuitHandle get_Handle();
    [CompilerGeneratedAttribute]
public CircuitId get_CircuitId();
    [CompilerGeneratedAttribute]
public Circuit get_Circuit();
    [CompilerGeneratedAttribute]
public CircuitClientProxy get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(CircuitClientProxy value);
    [CompilerGeneratedAttribute]
public RemoteJSRuntime get_JSRuntime();
    [CompilerGeneratedAttribute]
public RemoteRenderer get_Renderer();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ComponentDescriptor> get_Descriptors();
    [CompilerGeneratedAttribute]
public IServiceProvider get_Services();
    public Task InitializeAsync(ProtectedPrerenderComponentApplicationStore store, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<DisposeAsync>d__39")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnCircuitOpenedAsync>d__40")]
private Task OnCircuitOpenedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnConnectionUpAsync>d__41")]
public Task OnConnectionUpAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnConnectionDownAsync>d__42")]
public Task OnConnectionDownAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnCircuitDownAsync>d__43")]
private Task OnCircuitDownAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnRenderCompletedAsync>d__44")]
public Task OnRenderCompletedAsync(long renderId, string errorMessageOrNull);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<BeginInvokeDotNetFromJS>d__45")]
public Task BeginInvokeDotNetFromJS(string callId, string assemblyName, string methodIdentifier, long dotNetObjectId, string argsJson);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<EndInvokeJSFromDotNet>d__46")]
public Task EndInvokeJSFromDotNet(long asyncCall, bool succeeded, string arguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReceiveByteArray>d__47")]
internal Task ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReceiveJSDataChunk>d__48")]
internal Task`1<bool> ReceiveJSDataChunk(long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<SendDotNetStreamAsync>d__49")]
public Task`1<int> SendDotNetStreamAsync(DotNetStreamReference dotNetStreamReference, long streamId, Byte[] buffer);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<TryClaimPendingStream>d__50")]
public Task`1<DotNetStreamReference> TryClaimPendingStream(long streamId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnLocationChangedAsync>d__51")]
public Task OnLocationChangedAsync(string uri, string state, bool intercepted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<OnLocationChangingAsync>d__52")]
public Task OnLocationChangingAsync(int callId, string uri, string state, bool intercepted);
    public void SetCircuitUser(ClaimsPrincipal user);
    public void SendPendingBatches();
    internal Task HandleInboundActivityAsync(Func`1<Task> handler);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<HandleInboundActivityAsync>d__56`1")]
internal Task`1<TResult> HandleInboundActivityAsync(Func`1<Task`1<TResult>> handler);
    private static Func`2<Func`1<Task>, Task> BuildInboundActivityDispatcher(IReadOnlyList`1<CircuitHandler> circuitHandlers, Circuit circuit);
    private void AssertInitialized();
    private void AssertNotDisposed();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReportAndInvoke_UnhandledException>d__60")]
private void ReportAndInvoke_UnhandledException(object sender, Exception e);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<SynchronizationContext_UnhandledException>d__61")]
private void SynchronizationContext_UnhandledException(object sender, UnhandledExceptionEventArgs e);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<ReportUnhandledException>d__62")]
private Task ReportUnhandledException(Exception exception);
    private string GetClientErrorMessage(Exception exception, string additionalInformation);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<TryNotifyClientErrorAsync>d__64")]
private Task TryNotifyClientErrorAsync(IClientProxy client, string error, Exception exception);
    internal Task UpdateRootComponents(RootComponentOperationBatch operationBatch, ProtectedPrerenderComponentApplicationStore store, IServerComponentDeserializer serverComponentDeserializer, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<PerformRootComponentOperations>d__66")]
private ValueTask PerformRootComponentOperations(RootComponentOperation[] operations, bool shouldWaitForQuiescence);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitHost/<<DisposeAsync>b__39_0>d")]
[CompilerGeneratedAttribute]
private Task <DisposeAsync>b__39_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitId : ValueType {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    public string Id { get; }
    public string Secret { get; }
    public CircuitId(string secret, string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Secret();
    public sealed virtual bool Equals(CircuitId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitIdFactory : object {
    private static string CircuitIdProtectorPurpose;
    private static int SecretLength;
    private static int IdLength;
    private IDataProtector _protector;
    [NullableContextAttribute("1")]
public CircuitIdFactory(IDataProtectionProvider provider);
    public CircuitId CreateCircuitId();
    [NullableContextAttribute("2")]
public bool TryParseCircuitId(string text, CircuitId& circuitId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Server.Circuits.CircuitInboundActivityContext : object {
    [CompilerGeneratedAttribute]
private Func`1<Task> <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private Circuit <Circuit>k__BackingField;
    internal Func`1<Task> Handler { get; }
    public Circuit Circuit { get; }
    internal CircuitInboundActivityContext(Func`1<Task> handler, Circuit circuit);
    [CompilerGeneratedAttribute]
internal Func`1<Task> get_Handler();
    [CompilerGeneratedAttribute]
public Circuit get_Circuit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitJSComponentInterop : JSComponentInterop {
    private CircuitOptions _circuitOptions;
    private int _jsRootComponentCount;
    internal CircuitJSComponentInterop(CircuitOptions circuitOptions);
    protected virtual int AddRootComponent(string identifier, string domElementSelector);
    protected virtual void RemoveRootComponent(int componentId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitOptionsJavaScriptInitializersConfiguration : object {
    private IWebHostEnvironment _environment;
    public CircuitOptionsJavaScriptInitializersConfiguration(IWebHostEnvironment environment);
    public sealed virtual void Configure(CircuitOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry : object {
    private object CircuitRegistryLock;
    private CircuitOptions _options;
    private ILogger _logger;
    private CircuitIdFactory _circuitIdFactory;
    private PostEvictionCallbackRegistration _postEvictionCallback;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<CircuitId, CircuitHost> <ConnectedCircuits>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryCache <DisconnectedCircuits>k__BackingField;
    internal ConcurrentDictionary`2<CircuitId, CircuitHost> ConnectedCircuits { get; }
    internal MemoryCache DisconnectedCircuits { get; }
    public CircuitRegistry(IOptions`1<CircuitOptions> options, ILogger`1<CircuitRegistry> logger, CircuitIdFactory CircuitHostFactory);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<CircuitId, CircuitHost> get_ConnectedCircuits();
    [CompilerGeneratedAttribute]
internal MemoryCache get_DisconnectedCircuits();
    public void Register(CircuitHost circuitHost);
    public virtual Task DisconnectAsync(CircuitHost circuitHost, string connectionId);
    protected virtual bool DisconnectCore(CircuitHost circuitHost, string connectionId);
    public void RegisterDisconnectedCircuit(CircuitHost circuitHost);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry/<ConnectAsync>d__16")]
public virtual Task`1<CircuitHost> ConnectAsync(CircuitId circuitId, IClientProxy clientProxy, string connectionId, CancellationToken cancellationToken);
    protected virtual ValueTuple`2<CircuitHost, bool> ConnectCore(CircuitId circuitId, IClientProxy clientProxy, string connectionId);
    protected virtual void OnEntryEvicted(object key, object value, EvictionReason reason, object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry/<DisposeCircuitEntry>d__19")]
private Task DisposeCircuitEntry(DisconnectedCircuitEntry entry);
    private void DisposeTokenSource(DisconnectedCircuitEntry entry);
    public ValueTask TerminateAsync(CircuitId circuitId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.CircuitRegistry/<CircuitHost_UnhandledException>d__22")]
private void CircuitHost_UnhandledException(object sender, UnhandledExceptionEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.DefaultCircuitAccessor : object {
    [CompilerGeneratedAttribute]
private Circuit <Circuit>k__BackingField;
    public Circuit Circuit { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Circuit get_Circuit();
    [CompilerGeneratedAttribute]
public void set_Circuit(Circuit value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitAccessor {
    public Circuit Circuit { get; }
    public abstract virtual Circuit get_Circuit();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitFactory {
    public abstract virtual ValueTask`1<CircuitHost> CreateCircuitHostAsync(IReadOnlyList`1<ComponentDescriptor> components, CircuitClientProxy client, string baseUri, string uri, ClaimsPrincipal user, IPersistentComponentStateStore store);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.Circuits.ICircuitHandleRegistry {
    public abstract virtual CircuitHandle GetCircuitHandle(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public abstract virtual CircuitHost GetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey);
    public abstract virtual void SetCircuit(IDictionary`2<object, object> circuitHandles, object circuitKey, CircuitHost circuitHost);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Server.Circuits.PendingRender : ValueType {
    [CompilerGeneratedAttribute]
private int <ComponentId>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderFragment <RenderFragment>k__BackingField;
    public int ComponentId { get; }
    public RenderFragment RenderFragment { get; }
    public PendingRender(int componentId, RenderFragment renderFragment);
    [CompilerGeneratedAttribute]
public int get_ComponentId();
    [CompilerGeneratedAttribute]
public RenderFragment get_RenderFragment();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteErrorBoundaryLogger : object {
    private ILogger _logger;
    private IJSRuntime _jsRuntime;
    private CircuitOptions _options;
    [NullableContextAttribute("1")]
public RemoteErrorBoundaryLogger(ILogger`1<ErrorBoundary> logger, IJSRuntime jsRuntime, IOptions`1<CircuitOptions> options);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask LogErrorAsync(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream : Stream {
    private RemoteJSRuntime _runtime;
    private long _streamId;
    private long _totalLength;
    private int _chunkSize;
    private TimeSpan _jsInteropDefaultCallTimeout;
    private CancellationToken _streamCancellationToken;
    private Stream _pipeReaderStream;
    private Pipe _pipe;
    private long _bytesRead;
    private long _expectedChunkId;
    private DateTimeOffset _lastDataReceivedTime;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private PipeReader <PipeReader>k__BackingField;
    public PipeReader PipeReader { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private RemoteJSDataStream(RemoteJSRuntime runtime, long streamId, long totalLength, int chunkSize, TimeSpan jsInteropDefaultCallTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReceiveData>d__12")]
public static Task`1<bool> ReceiveData(RemoteJSRuntime runtime, long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<CreateRemoteJSDataStreamAsync>d__13")]
public static ValueTask`1<RemoteJSDataStream> CreateRemoteJSDataStreamAsync(RemoteJSRuntime runtime, IJSStreamReference jsStreamReference, long totalLength, long signalRMaximumIncomingBytes, TimeSpan jsInteropDefaultCallTimeout, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public PipeReader get_PipeReader();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReceiveData>d__18")]
private Task`1<bool> ReceiveData(long chunkId, Byte[] chunk, string error);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReadAsync>d__35")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ReadAsync>d__36")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private static CancellationToken GetLinkedCancellationToken(CancellationToken a, CancellationToken b);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<ThrowOnTimeout>d__38")]
private Task ThrowOnTimeout();
    internal void InvalidateLastDataReceivedTimeForTimeout();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSDataStream/<CompletePipeAndDisposeStream>d__40")]
private Task CompletePipeAndDisposeStream(Exception ex);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime : JSRuntime {
    private CircuitOptions _options;
    private ILogger`1<RemoteJSRuntime> _logger;
    private CircuitClientProxy _clientProxy;
    private ConcurrentDictionary`2<long, DotNetStreamReference> _pendingDotNetToJSStreams;
    private bool _permanentlyDisconnected;
    private long _maximumIncomingBytes;
    private int _byteArraysToBeRevivedTotalBytes;
    internal int RemoteJSDataStreamNextInstanceId;
    internal Dictionary`2<long, RemoteJSDataStream> RemoteJSDataStreamInstances;
    [CompilerGeneratedAttribute]
private ElementReferenceContext <ElementReferenceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> UnhandledException;
    public ElementReferenceContext ElementReferenceContext { get; }
    public bool IsInitialized { get; }
    internal bool IsPermanentlyDisconnected { get; }
    public RemoteJSRuntime(IOptions`1<CircuitOptions> circuitOptions, IOptions`1<HubOptions`1<ComponentHub>> componentHubOptions, ILogger`1<RemoteJSRuntime> logger);
    [CompilerGeneratedAttribute]
public ElementReferenceContext get_ElementReferenceContext();
    public bool get_IsInitialized();
    internal bool get_IsPermanentlyDisconnected();
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    public JsonSerializerOptions ReadJsonSerializerOptions();
    internal void Initialize(CircuitClientProxy clientProxy);
    internal void RaiseUnhandledException(Exception ex);
    protected virtual void EndInvokeDotNet(DotNetInvocationInfo invocationInfo, DotNetInvocationResult& modreq(System.Runtime.InteropServices.InAttribute) invocationResult);
    protected virtual void SendByteArray(int id, Byte[] data);
    protected virtual void BeginInvokeJS(long asyncHandle, string identifier, string argsJson, JSCallResultType resultType, long targetInstanceId);
    protected virtual void ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime/<TransmitStreamAsync>d__27")]
protected virtual Task TransmitStreamAsync(long streamId, DotNetStreamReference dotNetStreamReference);
    public bool TryClaimPendingStreamForSending(long streamId, DotNetStreamReference& pendingStream);
    public void MarkPermanentlyDisconnected();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteJSRuntime/<ReadJSDataAsStreamAsync>d__30")]
protected virtual Task`1<Stream> ReadJSDataAsStreamAsync(IJSStreamReference jsStreamReference, long totalLength, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationInterception : object {
    private IJSRuntime _jsRuntime;
    public bool HasAttachedJSRuntime { get; }
    [NullableContextAttribute("1")]
public void AttachJSRuntime(IJSRuntime jsRuntime);
    public bool get_HasAttachedJSRuntime();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationInterception/<EnableNavigationInterceptionAsync>d__4")]
public sealed virtual Task EnableNavigationInterceptionAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager : NavigationManager {
    private ILogger`1<RemoteNavigationManager> _logger;
    private IJSRuntime _jsRuntime;
    private Nullable`1<bool> _navigationLockStateBeforeJsRuntimeAttached;
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> UnhandledException;
    public bool HasAttachedJSRuntime { get; }
    public RemoteNavigationManager(ILogger`1<RemoteNavigationManager> logger);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    public bool get_HasAttachedJSRuntime();
    public sealed virtual void Initialize(string baseUri, string uri);
    public void AttachJsRuntime(IJSRuntime jsRuntime);
    public void NotifyLocationChanged(string uri, string state, bool intercepted);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager/<HandleLocationChangingAsync>d__12")]
public ValueTask`1<bool> HandleLocationChangingAsync(string uri, string state, bool intercepted);
    [DynamicDependencyAttribute("512", "Microsoft.AspNetCore.Components.NavigationOptions")]
protected virtual void NavigateToCore(string uri, NavigationOptions options);
    public virtual void Refresh(bool forceReload);
    protected virtual void HandleLocationChangingHandlerException(Exception ex, LocationChangingContext context);
    protected virtual void SetNavigationLockState(bool value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager/<SetHasLocationChangingListenersAsync>d__17")]
private Task SetHasLocationChangingListenersAsync(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteRenderer : WebRenderer {
    private static Task CanceledTask;
    private CircuitClientProxy _client;
    private CircuitOptions _options;
    private IServerComponentDeserializer _serverComponentDeserializer;
    private ILogger _logger;
    internal ConcurrentQueue`1<UnacknowledgedRenderBatch> _unacknowledgedRenderBatches;
    private long _nextRenderId;
    private bool _disposing;
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> UnhandledException;
    [CompilerGeneratedAttribute]
private Dispatcher <Dispatcher>k__BackingField;
    private WebRootComponentManager _webRootComponentManager;
    public Dispatcher Dispatcher { get; }
    public RemoteRenderer(IServiceProvider serviceProvider, ILoggerFactory loggerFactory, CircuitOptions options, CircuitClientProxy client, IServerComponentDeserializer serverComponentDeserializer, ILogger logger, RemoteJSRuntime jsRuntime, CircuitJSComponentInterop jsComponentInterop);
    private static RemoteRenderer();
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public virtual Dispatcher get_Dispatcher();
    public Task AddComponentAsync(Type componentType, ParameterView parameters, string domElementSelector);
    protected virtual int GetWebRendererId();
    protected virtual void AttachRootComponentToBrowser(int componentId, string domElementSelector);
    internal Type GetExistingComponentType(int componentId);
    protected virtual void ProcessPendingRender();
    protected virtual void HandleException(Exception exception);
    protected virtual void Dispose(bool disposing);
    protected virtual Task UpdateDisplayAsync(RenderBatch& modreq(System.Runtime.InteropServices.InAttribute) batch);
    public Task ProcessBufferedRenderBatches();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteRenderer/<WriteBatchBytesAsync>d__24")]
private Task WriteBatchBytesAsync(UnacknowledgedRenderBatch pending);
    public Task OnRenderCompletedAsync(long incomingBatchId, string errorMessageOrNull);
    protected virtual IComponent ResolveComponentForRenderMode(Type componentType, Nullable`1<int> parentComponentId, IComponentActivator componentActivator, IComponentRenderMode renderMode);
    private void ProcessPendingBatch(string errorMessageOrNull, UnacknowledgedRenderBatch entry);
    private static void CompleteRender(TaskCompletionSource pendingRenderInfo, string errorMessageOrNull);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteRenderer/<CaptureAsyncExceptions>d__30")]
private Task CaptureAsyncExceptions(Task task);
    public WebRootComponentManager GetOrCreateWebRootComponentManager();
    [CompilerGeneratedAttribute]
private void <OnRenderCompletedAsync>b__25_0();
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RemoteScrollToLocationHash : object {
    private IJSRuntime _jsRuntime;
    public bool HasAttachedJSRuntime { get; }
    [NullableContextAttribute("1")]
public void AttachJSRuntime(IJSRuntime jsRuntime);
    public bool get_HasAttachedJSRuntime();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.Circuits.RemoteScrollToLocationHash/<RefreshScrollPositionForHash>d__4")]
public sealed virtual Task RefreshScrollPositionForHash(string locationAbsolute);
}
internal class Microsoft.AspNetCore.Components.Server.Circuits.RenderBatchWriter : object {
    private ArrayBuilder`1<string> _strings;
    private Dictionary`2<string, int> _deduplicatedStringIndices;
    private BinaryWriter _binaryWriter;
    [NullableContextAttribute("1")]
public RenderBatchWriter(Stream output, bool leaveOpen);
    public void Write(RenderBatch& renderBatch);
    private int Write(ArrayRange`1& diffs);
    private void Write(RenderTreeDiff& diff);
    private void Write(RenderTreeEdit& edit);
    private int Write(ArrayRange`1& frames);
    private void Write(RenderTreeFrame& frame);
    private int Write(ArrayRange`1& numbers);
    private int Write(ArrayRange`1& numbers);
    private void WriteString(string value, bool allowDeduplication);
    private int WriteStringTable();
    private static void WritePadding(BinaryWriter writer, int numBytes);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentDescriptor : object {
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterView <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    public Type ComponentType { get; public set; }
    public ParameterView Parameters { get; public set; }
    public int Sequence { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(Type value);
    [CompilerGeneratedAttribute]
public ParameterView get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ParameterView value);
    [CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
    public void Deconstruct(Type& componentType, ParameterView& parameters, Int32& sequence);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentHub : Hub {
    private static object CircuitKey;
    private IServerComponentDeserializer _serverComponentSerializer;
    private IDataProtectionProvider _dataProtectionProvider;
    private ICircuitFactory _circuitFactory;
    private CircuitIdFactory _circuitIdFactory;
    private CircuitRegistry _circuitRegistry;
    private ICircuitHandleRegistry _circuitHandleRegistry;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private static PathString <DefaultPath>k__BackingField;
    public static PathString DefaultPath { get; }
    public ComponentHub(IServerComponentDeserializer serializer, IDataProtectionProvider dataProtectionProvider, ICircuitFactory circuitFactory, CircuitIdFactory circuitIdFactory, CircuitRegistry circuitRegistry, ICircuitHandleRegistry circuitHandleRegistry, ILogger`1<ComponentHub> logger);
    private static ComponentHub();
    [CompilerGeneratedAttribute]
public static PathString get_DefaultPath();
    public virtual Task OnDisconnectedAsync(Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<StartCircuit>d__13")]
public ValueTask`1<string> StartCircuit(string baseUri, string uri, string serializedComponentRecords, string applicationState);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<UpdateRootComponents>d__14")]
public Task UpdateRootComponents(string serializedComponentOperations, string applicationState);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ConnectCircuit>d__15")]
public ValueTask`1<bool> ConnectCircuit(string circuitIdSecret);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<BeginInvokeDotNetFromJS>d__16")]
public ValueTask BeginInvokeDotNetFromJS(string callId, string assemblyName, string methodIdentifier, long dotNetObjectId, string argsJson);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<EndInvokeJSFromDotNet>d__17")]
public ValueTask EndInvokeJSFromDotNet(long asyncHandle, bool succeeded, string arguments);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ReceiveByteArray>d__18")]
public ValueTask ReceiveByteArray(int id, Byte[] data);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<ReceiveJSDataChunk>d__19")]
public ValueTask`1<bool> ReceiveJSDataChunk(long streamId, long chunkId, Byte[] chunk, string error);
    [AsyncIteratorStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<SendDotNetStreamToJS>d__20")]
public IAsyncEnumerable`1<ArraySegment`1<byte>> SendDotNetStreamToJS(long streamId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnRenderCompleted>d__21")]
public ValueTask OnRenderCompleted(long renderId, string errorMessageOrNull);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnLocationChanged>d__22")]
public ValueTask OnLocationChanged(string uri, string state, bool intercepted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<OnLocationChanging>d__23")]
public ValueTask OnLocationChanging(int callId, string uri, string state, bool intercepted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ComponentHub/<GetActiveCircuitAsync>d__24")]
private ValueTask`1<CircuitHost> GetActiveCircuitAsync(string callSite);
    private static Task NotifyClientError(IClientProxy client, string error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ComponentParameterDeserializer : object {
    private ILogger`1<ComponentParameterDeserializer> _logger;
    private ComponentParametersTypeCache _parametersCache;
    public ComponentParameterDeserializer(ILogger`1<ComponentParameterDeserializer> logger, ComponentParametersTypeCache parametersCache);
    public bool TryDeserializeParameters(IList`1<ComponentParameter> parametersDefinitions, IList`1<object> parameterValues, ParameterView& parameters);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Server.IServerComponentDeserializer {
    public abstract virtual bool TryDeserializeComponentDescriptorCollection(string serializedComponentRecords, List`1& descriptors);
    public abstract virtual bool TryDeserializeRootComponentOperations(string serializedComponentOperations, RootComponentOperationBatch& operationBatch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage : object {
    private string _storeName;
    private IJSRuntime _jsRuntime;
    private IDataProtectionProvider _dataProtectionProvider;
    private ConcurrentDictionary`2<string, IDataProtector> _cachedDataProtectorsByPurpose;
    private protected ProtectedBrowserStorage(string storeName, IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
    public ValueTask SetAsync(string key, object value);
    public ValueTask SetAsync(string purpose, string key, object value);
    public ValueTask`1<ProtectedBrowserStorageResult`1<TValue>> GetAsync(string key);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage/<GetAsync>d__8`1")]
public ValueTask`1<ProtectedBrowserStorageResult`1<TValue>> GetAsync(string purpose, string key);
    public ValueTask DeleteAsync(string key);
    private string Protect(string purpose, object value);
    private TValue Unprotect(string purpose, string protectedJson);
    private ValueTask SetProtectedJsonAsync(string key, string protectedJson);
    private ValueTask`1<string> GetProtectedJsonAsync(string key);
    private IDataProtector GetOrCreateCachedProtector(string purpose);
    private string CreatePurposeFromKey(string key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult`1 : ValueType {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public bool Success { get; }
    public TValue Value { get; }
    internal ProtectedBrowserStorageResult`1(bool success, TValue value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TValue get_Value();
}
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage : ProtectedBrowserStorage {
    [NullableContextAttribute("1")]
public ProtectedLocalStorage(IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
}
public class Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedSessionStorage : ProtectedBrowserStorage {
    [NullableContextAttribute("1")]
public ProtectedSessionStorage(IJSRuntime jsRuntime, IDataProtectionProvider dataProtectionProvider);
}
public abstract class Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider : ServerAuthenticationStateProvider {
    private ILogger _logger;
    private CancellationTokenSource _loopCancellationTokenSource;
    protected TimeSpan RevalidationInterval { get; }
    [NullableContextAttribute("1")]
public RevalidatingServerAuthenticationStateProvider(ILoggerFactory loggerFactory);
    protected abstract virtual TimeSpan get_RevalidationInterval();
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<bool> ValidateAuthenticationStateAsync(AuthenticationState authenticationState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider/<RevalidationLoop>d__6")]
private Task RevalidationLoop(Task`1<AuthenticationState> authenticationStateTask, CancellationToken cancellationToken);
    private void ForceSignOut();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(Task`1<AuthenticationState> authenticationStateTask);
}
public class Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider : AuthenticationStateProvider {
    private Task`1<AuthenticationState> _authenticationStateTask;
    [NullableContextAttribute("1")]
public virtual Task`1<AuthenticationState> GetAuthenticationStateAsync();
    [NullableContextAttribute("1")]
public sealed virtual void SetAuthenticationState(Task`1<AuthenticationState> authenticationStateTask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Server.ServerComponentDeserializer : object {
    private IDataProtector _dataProtector;
    private ILogger`1<ServerComponentDeserializer> _logger;
    private RootComponentTypeCache _rootComponentTypeCache;
    private ComponentParameterDeserializer _parametersDeserializer;
    private HashSet`1<Guid> _expiredInvocationIds;
    private HashSet`1<int> _seenSequenceNumbersForCurrentInvocation;
    private Nullable`1<Guid> _currentInvocationId;
    public ServerComponentDeserializer(IDataProtectionProvider dataProtectionProvider, ILogger`1<ServerComponentDeserializer> logger, RootComponentTypeCache rootComponentTypeCache, ComponentParameterDeserializer parametersDeserializer);
    public sealed virtual bool TryDeserializeComponentDescriptorCollection(string serializedComponentRecords, List`1& descriptors);
    [NullableContextAttribute("2")]
public bool TryDeserializeWebRootComponentDescriptor(ComponentMarker record, WebRootComponentDescriptor& result);
    private bool TryDeserializeComponentTypeAndParameters(ServerComponent serverComponent, Type& componentType, ParameterView& parameters);
    private bool TryDeserializeServerComponent(ComponentMarker record, ServerComponent& result);
    private ValueTuple`2<ComponentDescriptor, ServerComponent> DeserializeComponentDescriptor(ComponentMarker record);
    public sealed virtual bool TryDeserializeRootComponentOperations(string serializedComponentOperations, RootComponentOperationBatch& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ServerComponent : ValueType {
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ComponentParameter> <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<object> <ParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InvocationId>k__BackingField;
    public int Sequence { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public string AssemblyName { get; public set; }
    public string TypeName { get; public set; }
    public IList`1<ComponentParameter> ParameterDefinitions { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<object> ParameterValues { get; public set; }
    public Guid InvocationId { get; public set; }
    public ServerComponent(int sequence, Nullable`1<ComponentMarkerKey> key, string assemblyName, string typeName, IList`1<ComponentParameter> parametersDefinitions, IList`1<object> parameterValues, Guid invocationId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<ComponentParameter> get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(IList`1<ComponentParameter> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<object> get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(IList`1<object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_InvocationId();
    [CompilerGeneratedAttribute]
public void set_InvocationId(Guid value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.ServerComponentSerializationSettings : object {
    public static string DataProtectionProviderPurpose;
    public static JsonSerializerOptions JsonSerializationOptions;
    public static TimeSpan DataExpiration;
    private static ServerComponentSerializationSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.Web.BrowserNavigationManagerInterop : object {
    private static string Prefix;
    public static string EnableNavigationInterception;
    public static string GetLocationHref;
    public static string GetBaseUri;
    public static string NavigateTo;
    public static string Refresh;
    public static string SetHasLocationChangingListeners;
    public static string ScrollToElement;
}
internal enum Microsoft.AspNetCore.Components.WebRendererId : Enum {
    public int value__;
    public static WebRendererId Default;
    public static WebRendererId Server;
    public static WebRendererId WebAssembly;
    public static WebRendererId WebView;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.WebRootComponentDescriptor : object {
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRootComponentParameters <Parameters>k__BackingField;
    public Type ComponentType { get; }
    public WebRootComponentParameters Parameters { get; }
    public WebRootComponentDescriptor(Type componentType, WebRootComponentParameters parameters);
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public WebRootComponentParameters get_Parameters();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.WebRootComponentParameters : ValueType {
    [CompilerGeneratedAttribute]
private ParameterView <parameterView>P;
    public static WebRootComponentParameters Empty;
    private IReadOnlyList`1<ComponentParameter> _parameterDefinitions;
    private IReadOnlyList`1<object> _serializedParameterValues;
    public ParameterView Parameters { get; }
    [NullableContextAttribute("1")]
public WebRootComponentParameters(ParameterView parameterView, IReadOnlyList`1<ComponentParameter> parameterDefinitions, IReadOnlyList`1<object> serializedParameterValues);
    private static WebRootComponentParameters();
    public ParameterView get_Parameters();
    public bool DefinitelyEquals(WebRootComponentParameters& other);
}
internal static class Microsoft.AspNetCore.Internal.BinaryMessageFormatter : object {
    [NullableContextAttribute("1")]
public static void WriteLengthPrefix(long length, IBufferWriter`1<byte> output);
    public static int WriteLengthPrefix(long length, Span`1<byte> output);
    public static int LengthPrefixLength(long length);
}
internal static class Microsoft.AspNetCore.Internal.BinaryMessageParser : object {
    private static int MaxLengthPrefixSize;
    public static bool TryParseMessage(ReadOnlySequence`1& buffer, ReadOnlySequence`1& payload);
    private static ReadOnlySpan`1<byte> GetSpan(ReadOnlySequence`1& lengthPrefixBuffer);
}
internal static class Microsoft.AspNetCore.Internal.LinkerFlags : object {
    public static DynamicallyAccessedMemberTypes JsonSerialized;
    public static DynamicallyAccessedMemberTypes Component;
    public static DynamicallyAccessedMemberTypes JSInvokable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Internal.MemoryBufferWriter : Stream {
    [ThreadStaticAttribute]
private static MemoryBufferWriter _cachedInstance;
    private int _minimumSegmentSize;
    private int _bytesWritten;
    private List`1<CompletedBuffer> _completedSegments;
    private Byte[] _currentSegment;
    private int _position;
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public MemoryBufferWriter(int minimumSegmentSize);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static MemoryBufferWriter Get();
    public static void Return(MemoryBufferWriter writer);
    public void Reset();
    public sealed virtual void Advance(int count);
    [NullableContextAttribute("0")]
public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public void CopyTo(IBufferWriter`1<byte> destination);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [MemberNotNullAttribute("_currentSegment")]
private void EnsureCapacity(int sizeHint);
    [MemberNotNullAttribute("_currentSegment")]
private void AddSegment(int sizeHint);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Internal.MemoryBufferWriter/<CopyToSlowAsync>d__28")]
private Task CopyToSlowAsync(Stream destination, CancellationToken cancellationToken);
    public Byte[] ToArray();
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<byte> span);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> span);
    public WrittenBuffers DetachAndReset();
    protected virtual void Dispose(bool disposing);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.AspNetCore.SignalR.Internal.NonDefaultHubProtocolAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.SignalR.Protocol.MessagePackHubProtocolWorker : object {
    private static int ErrorResult;
    private static int VoidResult;
    private static int NonVoidResult;
    [NullableContextAttribute("0")]
public bool TryParseMessage(ReadOnlySequence`1& input, IInvocationBinder binder, HubMessage& message);
    private HubMessage ParseMessage(MessagePackReader& reader, IInvocationBinder binder);
    private HubMessage CreateInvocationMessage(MessagePackReader& reader, IInvocationBinder binder, int itemCount);
    private HubMessage CreateStreamInvocationMessage(MessagePackReader& reader, IInvocationBinder binder, int itemCount);
    private HubMessage CreateStreamItemMessage(MessagePackReader& reader, IInvocationBinder binder);
    private CompletionMessage CreateCompletionMessage(MessagePackReader& reader, IInvocationBinder binder);
    private static CancelInvocationMessage CreateCancelInvocationMessage(MessagePackReader& reader);
    private static CloseMessage CreateCloseMessage(MessagePackReader& reader, int itemCount);
    private static Dictionary`2<string, string> ReadHeaders(MessagePackReader& reader);
    private static String[] ReadStreamIds(MessagePackReader& reader);
    private static AckMessage CreateAckMessage(MessagePackReader& reader);
    private static SequenceMessage CreateSequenceMessage(MessagePackReader& reader);
    private Object[] BindArguments(MessagePackReader& reader, IReadOnlyList`1<Type> parameterTypes);
    protected abstract virtual object DeserializeObject(MessagePackReader& reader, Type type, string field);
    private static T ApplyHeaders(IDictionary`2<string, string> source, T destination);
    public void WriteMessage(HubMessage message, IBufferWriter`1<byte> output);
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> GetMessageBytes(HubMessage message);
    private void WriteMessageCore(HubMessage message, MessagePackWriter& writer);
    private void WriteInvocationMessage(InvocationMessage message, MessagePackWriter& writer);
    private void WriteStreamInvocationMessage(StreamInvocationMessage message, MessagePackWriter& writer);
    private void WriteStreamingItemMessage(StreamItemMessage message, MessagePackWriter& writer);
    private void WriteArgument(object argument, MessagePackWriter& writer);
    protected abstract virtual void Serialize(MessagePackWriter& writer, Type type, object value);
    private static void WriteStreamIds(String[] streamIds, MessagePackWriter& writer);
    private void WriteCompletionMessage(CompletionMessage message, MessagePackWriter& writer);
    private static void WriteCancelInvocationMessage(CancelInvocationMessage message, MessagePackWriter& writer);
    private static void WriteCloseMessage(CloseMessage message, MessagePackWriter& writer);
    private static void WritePingMessage(MessagePackWriter& writer);
    private static void WriteAckMessage(AckMessage message, MessagePackWriter& writer);
    private static void WriteSequenceMessage(SequenceMessage message, MessagePackWriter& writer);
    private static void PackHeaders(IDictionary`2<string, string> headers, MessagePackWriter& writer);
    private static string ReadInvocationId(MessagePackReader& reader);
    private static bool ReadBoolean(MessagePackReader& reader, string field);
    private static int ReadInt32(MessagePackReader& reader, string field);
    private static long ReadInt64(MessagePackReader& reader, string field);
    protected static string ReadString(MessagePackReader& reader, IInvocationBinder binder, string field);
    protected static string ReadString(MessagePackReader& reader, string field);
    private static long ReadMapLength(MessagePackReader& reader, string field);
    private static long ReadArrayLength(MessagePackReader& reader, string field);
    private static void ThrowIfNullOrEmpty(string target, string message);
}
internal static class Microsoft.AspNetCore.SignalR.Protocol.ProtocolHelper : object {
    [NullableContextAttribute("1")]
internal static Type TryGetReturnType(IInvocationBinder binder, string invocationId);
}
internal static class Microsoft.AspNetCore.StaticFiles.CacheHeaderSettings : object {
    [NullableContextAttribute("1")]
internal static void SetCacheHeaders(StaticFileResponseContext ctx);
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Server-side Blazor does not currently support trimming or native AOT.")]
public static IServerSideBlazorBuilder AddServerSideBlazor(IServiceCollection services, Action`1<CircuitOptions> configure);
}
[NullableContextAttribute("1")]
public interface Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
    public IServiceCollection Services { get; }
    private IServiceCollection Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder.Services { get; }
    public abstract virtual IServiceCollection get_Services();
    private sealed virtual override IServiceCollection Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder.get_Services();
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServerRazorComponentsBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Server-side Blazor does not currently support native AOT.")]
public static IServerSideBlazorBuilder AddInteractiveServerComponents(IRazorComponentsBuilder builder, Action`1<CircuitOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions : object {
    [ExtensionAttribute]
public static IServerSideBlazorBuilder AddCircuitOptions(IServerSideBlazorBuilder builder, Action`1<CircuitOptions> configure);
    [ExtensionAttribute]
public static IServerSideBlazorBuilder AddHubOptions(IServerSideBlazorBuilder builder, Action`1<HubOptions> configure);
}
internal class Microsoft.Extensions.Internal.ValueStopwatch : ValueType {
    private long _startTimestamp;
    public bool IsActive { get; }
    private ValueStopwatch(long startTimestamp);
    public bool get_IsActive();
    public static ValueStopwatch StartNew();
    public TimeSpan GetElapsedTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Nerdbank.Streams.Requires : object {
    internal static void NotNull(object arg, string paramName);
    internal static void Argument(bool condition, string paramName, string message);
    internal static void Range(bool condition, string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Nerdbank.Streams.Sequence`1 : object {
    private static int DefaultLengthFromArrayPool;
    private Stack`1<SequenceSegment<T>> segmentPool;
    private MemoryPool`1<T> memoryPool;
    private ArrayPool`1<T> arrayPool;
    private SequenceSegment<T> first;
    private SequenceSegment<T> last;
    [CompilerGeneratedAttribute]
private int <MinimumSpanLength>k__BackingField;
    public int MinimumSpanLength { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySequence`1<T> AsReadOnlySequence { get; }
    public long Length { get; }
    private string DebuggerDisplay { get; }
    public Sequence`1(MemoryPool`1<T> memoryPool);
    public Sequence`1(ArrayPool`1<T> arrayPool);
    private static Sequence`1();
    [CompilerGeneratedAttribute]
public int get_MinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_MinimumSpanLength(int value);
    public ReadOnlySequence`1<T> get_AsReadOnlySequence();
    public long get_Length();
    private string get_DebuggerDisplay();
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1<T> sequence);
    public void AdvanceTo(SequencePosition position);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    public void Reset();
    private SequenceSegment<T> GetSegment(int sizeHint);
    private void Append(SequenceSegment<T> segment);
    private SequenceSegment<T> RecycleAndGetNext(SequenceSegment<T> segment);
}
internal class System.Buffers.PooledArrayBufferWriter`1 : object {
    private T[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    private void ClearHelper();
    public sealed virtual void Dispose();
    private void CheckIfDisposed();
    private static void ThrowObjectDisposedException();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException(int capacity);
}
