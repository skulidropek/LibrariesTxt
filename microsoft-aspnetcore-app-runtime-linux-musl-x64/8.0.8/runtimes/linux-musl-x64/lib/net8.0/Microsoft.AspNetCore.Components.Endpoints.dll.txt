[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilder : object {
    private object _lock;
    private ComponentApplicationBuilder _builder;
    private RazorComponentDataSourceOptions _options;
    private List`1<Action`1<EndpointBuilder>> _conventions;
    private List`1<Action`1<EndpointBuilder>> _finallyConventions;
    internal ComponentApplicationBuilder ApplicationBuilder { get; }
    internal RazorComponentsEndpointConventionBuilder(object lock, ComponentApplicationBuilder builder, RazorComponentDataSourceOptions options, List`1<Action`1<EndpointBuilder>> conventions, List`1<Action`1<EndpointBuilder>> finallyConventions);
    internal ComponentApplicationBuilder get_ApplicationBuilder();
    public sealed virtual void Add(Action`1<EndpointBuilder> convention);
    public sealed virtual void Finally(Action`1<EndpointBuilder> finallyConvention);
    internal void AddRenderMode(IComponentRenderMode renderMode);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RazorComponentsEndpointConventionBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RazorComponentsEndpointConventionBuilder AddAdditionalAssemblies(RazorComponentsEndpointConventionBuilder builder, Assembly[] assemblies);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RazorComponentsEndpointRouteBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RazorComponentsEndpointConventionBuilder MapRazorComponents(IEndpointRouteBuilder endpoints);
    private static void AddBlazorWebJsEndpoint(IEndpointRouteBuilder endpoints);
    private static RazorComponentEndpointDataSource`1<TRootComponent> GetOrCreateDataSource(IEndpointRouteBuilder endpoints);
    private static void EnsureRazorComponentServices(IEndpointRouteBuilder endpoints);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentEndMarker : ValueType {
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    public string PrerenderId { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarker : ValueType {
    [NullableAttribute("1")]
public static string ServerMarkerType;
    [NullableAttribute("1")]
public static string WebAssemblyMarkerType;
    [NullableAttribute("1")]
public static string AutoMarkerType;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrerenderId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterValues>k__BackingField;
    public string Type { get; public set; }
    public string PrerenderId { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public Nullable`1<int> Sequence { get; public set; }
    public string Descriptor { get; public set; }
    public string Assembly { get; public set; }
    public string TypeName { get; public set; }
    public string ParameterDefinitions { get; public set; }
    public string ParameterValues { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PrerenderId();
    [CompilerGeneratedAttribute]
public void set_PrerenderId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(string value);
    [NullableContextAttribute("1")]
public static ComponentMarker Create(string type, bool prerendered, Nullable`1<ComponentMarkerKey> key);
    [NullableContextAttribute("1")]
public void WriteServerData(int sequence, string descriptor);
    [NullableContextAttribute("1")]
public void WriteWebAssemblyData(string assembly, string typeName, string parameterDefinitions, string parameterValues);
    public Nullable`1<ComponentEndMarker> ToEndMarker();
    private static string GeneratePrerenderId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentMarkerKey : ValueType {
    [CompilerGeneratedAttribute]
private string <LocationHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedComponentKey>k__BackingField;
    public string LocationHash { get; public set; }
    [NullableAttribute("2")]
public string FormattedComponentKey { get; public set; }
    public ComponentMarkerKey(string locationHash, string formattedComponentKey);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocationHash();
    [CompilerGeneratedAttribute]
public void set_LocationHash(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FormattedComponentKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FormattedComponentKey(string value);
    public static bool op_Equality(ComponentMarkerKey left, ComponentMarkerKey right);
    public static bool op_Inequality(ComponentMarkerKey left, ComponentMarkerKey right);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(ComponentMarkerKey other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ComponentParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string Assembly { get; public set; }
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
    public static ValueTuple`2<IList`1<ComponentParameter>, IList`1<object>> FromParameterView(ParameterView parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Discovery.AssemblyComponentLibraryDescriptor : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PageComponentBuilder> <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ComponentBuilder> <Components>k__BackingField;
    public string AssemblyName { get; }
    public IReadOnlyList`1<PageComponentBuilder> Pages { get; }
    public IReadOnlyList`1<ComponentBuilder> Components { get; }
    public AssemblyComponentLibraryDescriptor(string name, IReadOnlyList`1<PageComponentBuilder> pages, IReadOnlyList`1<ComponentBuilder> components);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PageComponentBuilder> get_Pages();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ComponentBuilder> get_Components();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Discovery.ComponentApplicationBuilder : object {
    private HashSet`1<string> _assemblies;
    [CompilerGeneratedAttribute]
private PageCollectionBuilder <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private ComponentCollectionBuilder <Components>k__BackingField;
    internal PageCollectionBuilder Pages { get; }
    internal ComponentCollectionBuilder Components { get; }
    [CompilerGeneratedAttribute]
internal PageCollectionBuilder get_Pages();
    [CompilerGeneratedAttribute]
internal ComponentCollectionBuilder get_Components();
    internal RazorComponentApplication Build();
    public bool HasAssembly(string assemblyName);
    public ComponentApplicationBuilder AddAssembly(Assembly assembly);
    public ComponentApplicationBuilder RemoveAssembly(Assembly assembly);
    internal void AddLibrary(AssemblyComponentLibraryDescriptor libraryBuilder);
    internal void Combine(ComponentApplicationBuilder other);
    internal void Exclude(ComponentApplicationBuilder builder);
    internal void RemoveLibrary(string assembly);
    [NullableContextAttribute("2")]
internal static ComponentApplicationBuilder GetBuilder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.AspNetCore.Components.Discovery.ComponentBuilder : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderModeAttribute <RenderMode>k__BackingField;
    [RequiredMemberAttribute]
public string AssemblyName { get; public set; }
    [RequiredMemberAttribute]
public Type ComponentType { get; public set; }
    [NullableAttribute("2")]
public RenderModeAttribute RenderMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(Type value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RenderModeAttribute get_RenderMode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RenderMode(RenderModeAttribute value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ComponentBuilder other);
    public virtual int GetHashCode();
    internal bool HasSource(string name);
    internal ComponentInfo Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Discovery.ComponentCollectionBuilder : object {
    private Dictionary`2<string, IReadOnlyList`1<ComponentBuilder>> _components;
    internal void Combine(ComponentCollectionBuilder components);
    internal void Exclude(ComponentCollectionBuilder components);
    internal void Remove(string name);
    internal void AddFromLibraryInfo(string assemblyName, IReadOnlyList`1<ComponentBuilder> components);
    internal ComponentInfo[] ToComponentCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Discovery.ComponentInfo : object {
    private IComponentRenderMode _renderMode;
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    public Type ComponentType { get; }
    [NullableAttribute("2")]
public IComponentRenderMode RenderMode { get; public set; }
    public ComponentInfo(Type componentType);
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [NullableContextAttribute("2")]
public IComponentRenderMode get_RenderMode();
    [NullableContextAttribute("2")]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenderMode(IComponentRenderMode value);
    private string GetDebuggerDisplay();
    private string GetRenderMode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Discovery.DefaultRazorComponentApplication`1 : object {
    [CompilerGeneratedAttribute]
private static IRazorComponentApplication <Instance>k__BackingField;
    public static IRazorComponentApplication Instance { get; }
    private static DefaultRazorComponentApplication`1();
    [CompilerGeneratedAttribute]
public static IRazorComponentApplication get_Instance();
    public sealed virtual ComponentApplicationBuilder GetBuilder();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Discovery.IRazorComponentApplication {
    public abstract virtual ComponentApplicationBuilder GetBuilder();
    public static ComponentApplicationBuilder GetBuilderForAssembly(ComponentApplicationBuilder builder, Assembly assembly);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IReadOnlyList`1<PageComponentBuilder>, IReadOnlyList`1<ComponentBuilder>> <GetBuilderForAssembly>g__CreatePageRouteCollection|1_0(string name, Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Discovery.PageCollectionBuilder : object {
    private Dictionary`2<string, IReadOnlyList`1<PageComponentBuilder>> _pages;
    internal void Combine(PageCollectionBuilder pages);
    internal void Exclude(PageCollectionBuilder pages);
    internal void RemoveFromAssembly(string name);
    internal void AddFromLibraryInfo(string assemblyName, IReadOnlyList`1<PageComponentBuilder> pages);
    internal PageComponentInfo[] ToPageCollection();
    private static void ResolveMetadata(Type componentType, List`1<object> result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Discovery.PageComponentBuilder : object {
    private IReadOnlyList`1<string> _routeTemplates;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PageType>k__BackingField;
    [RequiredMemberAttribute]
public string AssemblyName { get; public set; }
    [RequiredMemberAttribute]
public IReadOnlyList`1<string> RouteTemplates { get; public set; }
    [RequiredMemberAttribute]
[DynamicallyAccessedMembersAttribute("-1")]
public Type PageType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    public IReadOnlyList`1<string> get_RouteTemplates();
    public void set_RouteTemplates(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public Type get_PageType();
    [CompilerGeneratedAttribute]
public void set_PageType(Type value);
    public bool HasSource(string source);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PageComponentBuilder other);
    public virtual int GetHashCode();
    internal PageComponentInfo Build(string route, Object[] pageMetadata);
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Discovery.PageComponentInfo : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Route>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<object> <Metadata>k__BackingField;
    public string DisplayName { get; }
    [DynamicallyAccessedMembersAttribute("-1")]
public Type Type { get; }
    public string Route { get; }
    public IReadOnlyList`1<object> Metadata { get; }
    internal PageComponentInfo(string displayName, Type type, string route, IReadOnlyList`1<object> metadata);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_Route();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<object> get_Metadata();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Discovery.RazorComponentApplication : object {
    private PageComponentInfo[] _pages;
    private ComponentInfo[] _components;
    public IReadOnlyList`1<PageComponentInfo> Pages { get; }
    public IReadOnlyList`1<ComponentInfo> Components { get; }
    internal RazorComponentApplication(PageComponentInfo[] pageCollection, ComponentInfo[] componentCollection);
    public IReadOnlyList`1<PageComponentInfo> get_Pages();
    public IReadOnlyList`1<ComponentInfo> get_Components();
    public ISet`1<IComponentRenderMode> GetDeclaredRenderModesByDiscoveredComponents();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Endpoints.ComponentTypeMetadata : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [DynamicallyAccessedMembersAttribute("-1")]
public Type Type { get; }
    public ComponentTypeMetadata(Type componentType);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.ConfiguredRenderModesMetadata : object {
    [CompilerGeneratedAttribute]
private IComponentRenderMode[] <configuredRenderModes>P;
    public IComponentRenderMode[] ConfiguredRenderModes { get; }
    public ConfiguredRenderModesMetadata(IComponentRenderMode[] configuredRenderModes);
    public IComponentRenderMode[] get_ConfiguredRenderModes();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.DependencyInjection.EndpointRoutingStateProvider : object {
    [CompilerGeneratedAttribute]
private RouteData <RouteData>k__BackingField;
    public RouteData RouteData { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual RouteData get_RouteData();
    [CompilerGeneratedAttribute]
internal void set_RouteData(RouteData value);
}
internal class Microsoft.AspNetCore.Components.Endpoints.EndpointComponentState : ComponentState {
    private static ConcurrentDictionary`2<Type, StreamRenderingAttribute> _streamRenderingAttributeByComponentType;
    [CompilerGeneratedAttribute]
private bool <StreamRendering>k__BackingField;
    public bool StreamRendering { get; }
    [NullableContextAttribute("1")]
public EndpointComponentState(Renderer renderer, int componentId, IComponent component, ComponentState parentComponentState);
    private static EndpointComponentState();
    [CompilerGeneratedAttribute]
public bool get_StreamRendering();
    public static void UpdateApplication(Type[] _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer : StaticHtmlRenderer {
    private IServiceProvider _services;
    private RazorComponentsServiceOptions _options;
    private Task _servicesInitializedTask;
    private HttpContext _httpContext;
    private List`1<Task> _nonStreamingPendingTasks;
    [NullableAttribute("2")]
internal Task NonStreamingPendingTasksCompletion;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<int, int>, string> _namedSubmitEventsByLocation;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, HashSet`1<ValueTuple`2<int, int>>> _namedSubmitEventsByScopeQualifiedName;
    private static object ComponentSequenceKey;
    private static object InvokedRenderModesKey;
    private static string _streamingRenderingFramingHeaderName;
    private TextWriter _streamingUpdatesWriter;
    private HashSet`1<int> _visitedComponentIdsInCurrentStreamingBatch;
    private string _ssrFramingCommentMarkup;
    private bool _isHandlingErrors;
    [NullableAttribute("2")]
internal HttpContext HttpContext { get; }
    public EndpointHtmlRenderer(IServiceProvider serviceProvider, ILoggerFactory loggerFactory);
    private static EndpointHtmlRenderer();
    [NullableContextAttribute("2")]
internal HttpContext get_HttpContext();
    private void SetHttpContext(HttpContext httpContext);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<InitializeStandardComponentServicesAsync>d__9")]
internal static Task InitializeStandardComponentServicesAsync(HttpContext httpContext, Type componentType, string handler, IFormCollection form);
    protected virtual ComponentState CreateComponentState(int componentId, IComponent component, ComponentState parentComponentState);
    protected virtual void AddPendingTask(ComponentState componentState, Task task);
    protected virtual Task UpdateDisplayAsync(RenderBatch& modreq(System.Runtime.InteropServices.InAttribute) renderBatch);
    private static string GetFullUri(HttpRequest request);
    private static string GetContextBaseUri(HttpRequest request);
    internal Task DispatchSubmitEventAsync(string handlerName, Boolean& isBadRequest);
    private string CreateMessageForAmbiguousNamedSubmitEvent(string scopeQualifiedName, IEnumerable`1<ValueTuple`2<int, int>> locations);
    private Task ReturnErrorResponse(string detailedMessage);
    private void UpdateNamedSubmitEvents(RenderBatch& renderBatch);
    private void ProcessNamedSubmitEventRemovals(ArrayRange`1<NamedEventChange> changes);
    private void ProcessNamedSubmitEventAdditions(ArrayRange`1<NamedEventChange> changes);
    private static TVal GetOrAddNewToDictionary(Dictionary`2<TKey, TVal> dictionary, TKey key);
    private Nullable`1<ulong> FindEventHandlerIdForNamedEvent(string eventType, int componentId, int frameIndex);
    private string GenerateComponentPath(int componentId);
    protected virtual IComponent ResolveComponentForRenderMode(Type componentType, Nullable`1<int> parentComponentId, IComponentActivator componentActivator, IComponentRenderMode renderMode);
    protected virtual IComponentRenderMode GetComponentRenderMode(IComponent component);
    private SSRRenderModeBoundary GetClosestRenderModeBoundary(int componentId);
    private static SSRRenderModeBoundary GetClosestRenderModeBoundary(ComponentState componentState);
    public static void MarkAsAllowingEnhancedNavigation(HttpContext context);
    public sealed virtual ValueTask`1<IHtmlAsyncContent> PrerenderComponentAsync(HttpContext httpContext, Type componentType, IComponentRenderMode prerenderMode, ParameterView parameters);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<PrerenderComponentAsync>d__35")]
public ValueTask`1<IHtmlAsyncContent> PrerenderComponentAsync(HttpContext httpContext, Type componentType, IComponentRenderMode prerenderMode, ParameterView parameters, bool waitForQuiescence);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<RenderEndpointComponent>d__36")]
internal ValueTask`1<PrerenderedComponentHtmlContent> RenderEndpointComponent(HttpContext httpContext, Type rootComponentType, ParameterView parameters, bool waitForQuiescence);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<WaitForResultReady>d__37")]
private Task WaitForResultReady(bool waitForQuiescence, PrerenderedComponentHtmlContent result);
    public Task WaitForNonStreamingPendingTasks();
    public static ValueTask`1<PrerenderedComponentHtmlContent> HandleNavigationException(HttpContext httpContext, NavigationException navigationException);
    private static bool IsPossibleExternalDestination(HttpRequest request, string destinationUrl);
    internal static ServerComponentInvocationSequence GetOrCreateInvocationId(HttpContext httpContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<PrerenderPersistedStateAsync>d__44")]
public ValueTask`1<IHtmlContent> PrerenderPersistedStateAsync(HttpContext httpContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<PrerenderPersistedStateAsync>d__45")]
public sealed virtual ValueTask`1<IHtmlContent> PrerenderPersistedStateAsync(HttpContext httpContext, PersistedStateSerializationMode serializationMode);
    internal static void UpdateSaveStateRenderMode(HttpContext httpContext, IComponentRenderMode mode);
    private static bool ModeEnablesPrerendering(IComponentRenderMode mode);
    internal static Mode GetPersistStateRenderMode(HttpContext httpContext);
    public void InitializeStreamingRenderingFraming(HttpContext httpContext, bool isErrorHandler);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<SendStreamingUpdatesAsync>d__58")]
public Task SendStreamingUpdatesAsync(HttpContext httpContext, Task untilTaskCompleted, TextWriter writer);
    internal void EmitInitializersIfNecessary(HttpContext httpContext, TextWriter writer);
    private void SendBatchAsStreamingUpdate(RenderBatch& renderBatch, TextWriter writer);
    private int GetComponentDepth(int componentId);
    private static void HandleExceptionAfterResponseStarted(HttpContext httpContext, TextWriter writer, Exception exception);
    private static void HandleNavigationAfterResponseStarted(TextWriter writer, HttpContext httpContext, string destinationUrl);
    protected virtual void WriteComponentHtml(int componentId, TextWriter output);
    protected virtual void RenderChildComponent(TextWriter output, RenderTreeFrame& componentFrame);
    private void WriteComponentHtml(int componentId, TextWriter output, bool allowBoundaryMarkers, SequenceAndKey sequenceAndKey);
    private static bool IsProgressivelyEnhancedNavigation(HttpRequest request);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<<UpdateDisplayAsync>g__FlushThenComplete|13_0>d")]
[CompilerGeneratedAttribute]
internal static Task <UpdateDisplayAsync>g__FlushThenComplete|13_0(TextWriter writerToFlush, Task completion);
    [CompilerGeneratedAttribute]
internal static string <GenerateComponentPath>g__GetName|27_0(ComponentState current);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.EndpointHtmlRenderer/<<WaitForNonStreamingPendingTasks>g__Execute|38_0>d")]
[CompilerGeneratedAttribute]
private Task <WaitForNonStreamingPendingTasks>g__Execute|38_0();
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ArrayCollectionFactory`1 : object {
    [NullableContextAttribute("1")]
public static override TElement[] ToResultCore(TElement[] buffer, int size);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ArrayPoolBufferAdapter`3 : object {
    public static override PooledBuffer<TCollection, TCollectionFactory, TElement> CreateBuffer();
    public static override PooledBuffer<TCollection, TCollectionFactory, TElement> Add(PooledBuffer& buffer, TElement element);
    public static override TCollection ToResult(PooledBuffer<TCollection, TCollectionFactory, TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.BrowserFileFromFormFile : object {
    [CompilerGeneratedAttribute]
private IFormFile <formFile>P;
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public long Size { get; }
    public string ContentType { get; }
    public BrowserFileFromFormFile(IFormFile formFile);
    public sealed virtual string get_Name();
    public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual long get_Size();
    public sealed virtual string get_ContentType();
    public sealed virtual Stream OpenReadStream(long maxAllowedSize, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverter`1 : FormDataConverter`1<TCollection> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverter`4 : CollectionConverter`1<TCollection> {
    private static Type _elementType;
    private static String[] Indexes;
    private FormDataConverter`1<TElement> _elementConverter;
    public CollectionConverter`4(FormDataConverter`1<TElement> elementConverter);
    private static CollectionConverter`4();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, TCollection& result, Boolean& found);
    private bool TryReadSingleValueCollection(FormDataReader& context, TCollection& result, Boolean& found, TBuffer& buffer, Boolean& succeded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CollectionConverterFactory : object {
    public static CollectionConverterFactory Instance;
    private static CollectionConverterFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public static Type ResolveElementType(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.CompiledComplexTypeConverter`1 : FormDataConverter`1<T> {
    [CompilerGeneratedAttribute]
private ConverterDelegate<T> <body>P;
    public CompiledComplexTypeConverter`1(ConverterDelegate<T> body);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeConverterFactory : object {
    [CompilerGeneratedAttribute]
private FormDataMetadataFactory <MetadataFactory>k__BackingField;
    internal FormDataMetadataFactory MetadataFactory { get; }
    public ComplexTypeConverterFactory(FormDataMapperOptions options, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
internal FormDataMetadataFactory get_MetadataFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory`1 : ComplexTypeExpressionConverterFactory {
    [CompilerGeneratedAttribute]
private FormDataMetadataFactory <factory>P;
    public ComplexTypeExpressionConverterFactory`1(FormDataMetadataFactory factory);
    [PreserveBaseOverridesAttribute]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual override CompiledComplexTypeConverter`1<T> CreateConverter(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private ConverterDelegate<T> CreateConverterBody(Type type, FormDataMapperOptions options);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory`1/<CreateInstanceAndAssignProperties>d__4")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static IEnumerable`1<Expression> CreateInstanceAndAssignProperties(FormDataTypeMetadata model, ParameterExpression resultParam, IList`1<FormDataParameterMetadata> constructorParameters, List`1<ParameterExpression> constructorParameterValueLocals, IList`1<FormDataPropertyMetadata> props, List`1<ParameterExpression> propsLocals, List`1<ParameterExpression> variables, ParameterExpression succeeded, ParameterExpression context);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.FormMapping.ComplexTypeExpressionConverterFactory`1/<ReportMissingValues>d__5")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static IEnumerable`1<Expression> ReportMissingValues(Expression readerParam, List`1<ParameterExpression> constructorParameters, IList`1<FormDataParameterMetadata> constructorParameterMetadata, List`1<ParameterExpression> properties, IList`1<FormDataPropertyMetadata> propertyMetadata, ParameterExpression succeeded);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static void MapPropertyValues(IList`1<FormDataPropertyMetadata> properties, ParameterExpression readerParam, ParameterExpression optionsParam, ParameterExpression propertyFoundValue, ParameterExpression succeeded, ParameterExpression localFoundValueVar, ParameterExpression exceptionVar, List`1<ParameterExpression> variables, List`1<ParameterExpression> propertyValueLocals, List`1<Expression> body);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static void MapConstructorParameters(IList`1<FormDataParameterMetadata> constructorParameters, ParameterExpression readerParam, ParameterExpression optionsParam, ParameterExpression propertyFoundValue, ParameterExpression succeeded, ParameterExpression localFoundValueVar, ParameterExpression exceptionVar, List`1<ParameterExpression> variables, List`1<ParameterExpression> constructorParameterValueLocals, List`1<Expression> body);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static Expression GetValueLocalVariableFoundExpression(ParameterExpression constructorParameterVar);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static Expression GetValueLocalVariableValueExpression(ParameterExpression constructorParameterVar);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static ParameterExpression CreateValueLocalVariable(IFormDataValue constructorParameter);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static ConditionalExpression CreatePrefixCheckForRecursiveTypes(ParameterExpression readerParam, ParameterExpression foundValueParam, ParameterExpression succeeded, LabelTarget end);
    private static ConverterDelegate<T> CreateConverterFunction(List`1<ParameterExpression> parameters, List`1<ParameterExpression> variables, List`1<Expression> body);
    private static FormDataConverterReadParameters<T> CreateFormDataConverterParameters();
    [CompilerGeneratedAttribute]
internal static BinaryExpression <CreateInstanceAndAssignProperties>g__HasHandler|4_0(ParameterExpression context);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__PushPrefix|5_0(Expression readerParam, string prefix);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__AddMappingError|5_1(Expression readerParam, string message, string parameter);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <ReportMissingValues>g__PopPrefix|5_2(Expression readerParam, string prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcreteTypeCollectionConverterFactory`2 : object {
    public static ConcreteTypeCollectionConverterFactory`2<TCollection, TElement> Instance;
    private static ConcreteTypeCollectionConverterFactory`2();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2046")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3051")]
public sealed virtual bool CanConvert(Type _, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type _, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcreteTypeDictionaryConverterFactory`3 : object {
    public static ConcreteTypeDictionaryConverterFactory`3<TDictionary, TKey, TValue> Instance;
    private static ConcreteTypeDictionaryConverterFactory`3();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2046")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3051")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentBagBufferAdapter`1 : object {
    public static override ConcurrentBag`1<TElement> CreateBuffer();
    public static override ConcurrentBag`1<TElement> Add(ConcurrentBag`1& buffer, TElement element);
    public static override ConcurrentBag`1<TElement> ToResult(ConcurrentBag`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentQueueBufferAdapter`1 : object {
    public static override ConcurrentQueue`1<TElement> CreateBuffer();
    public static override ConcurrentQueue`1<TElement> Add(ConcurrentQueue`1& buffer, TElement element);
    public static override ConcurrentQueue`1<TElement> ToResult(ConcurrentQueue`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ConcurrentStackBufferAdapter`1 : object {
    public static override ConcurrentStack`1<TElement> CreateBuffer();
    public static override ConcurrentStack`1<TElement> Add(ConcurrentStack`1& buffer, TElement element);
    public static override ConcurrentStack`1<TElement> ToResult(ConcurrentStack`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryBufferAdapter`3 : object {
    public static override TDictionaryType Add(TDictionaryType& buffer, TKey key, TValue value);
    public static override TDictionaryType CreateBuffer();
    public static override TDictionaryType ToResult(TDictionaryType buffer);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverter`1 : FormDataConverter`1<TDictionary> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverter`5 : DictionaryConverter`1<TDictionary> {
    private FormDataConverter`1<TValue> _valueConverter;
    private static Type _elementType;
    public DictionaryConverter`5(FormDataConverter`1<TValue> elementConverter);
    private static DictionaryConverter`5();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, TDictionary& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryConverterFactory : object {
    internal static DictionaryConverterFactory Instance;
    private static DictionaryConverterFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal static ValueTuple`2<Type, Type> ResolveDictionaryTypes(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.DictionaryStaticCastAdapter`6 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TKey key, TValue element);
    public static override TDictionaryInterface ToResult(TBuffer buffer);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.EnumConverter`1 : FormDataConverter`1<TEnum> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, TEnum& result);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, TEnum& result, Boolean& found);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.EnumConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FileConverter`1 : FormDataConverter`1<T> {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FileConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    private static bool CanConvertCommon(Type type);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataConverter : object {
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataConverter`1 : FormDataConverter {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal abstract virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMapper : object {
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public static T Map(FormDataReader reader, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMapperOptions : object {
    private ConcurrentDictionary`2<Type, FormDataConverter> _converters;
    private List`1<IFormDataConverterFactory> _factories;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCollectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxKeyBufferSize>k__BackingField;
    internal List`1<IFormDataConverterFactory> Factories { get; }
    internal ILogger Logger { get; }
    internal int MaxCollectionSize { get; internal set; }
    internal int MaxRecursionDepth { get; internal set; }
    internal int MaxErrorCount { get; internal set; }
    internal int MaxKeyBufferSize { get; internal set; }
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public FormDataMapperOptions(ILoggerFactory loggerFactory);
    internal List`1<IFormDataConverterFactory> get_Factories();
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
internal int get_MaxCollectionSize();
    [CompilerGeneratedAttribute]
internal void set_MaxCollectionSize(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxRecursionDepth();
    [CompilerGeneratedAttribute]
internal void set_MaxRecursionDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxErrorCount();
    [CompilerGeneratedAttribute]
internal void set_MaxErrorCount(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxKeyBufferSize();
    [CompilerGeneratedAttribute]
internal void set_MaxKeyBufferSize(int value);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal FormDataConverter`1<T> ResolveConverter();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
private static FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal FormDataConverter ResolveConverter(Type type);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal void AddConverter(FormDataConverter`1<T> converter);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal bool CanConvert(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMappingError : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattableString <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public FormattableString Message { get; }
    [NullableAttribute("2")]
public string Value { get; }
    internal FormDataMappingError(string key, FormattableString message, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public FormattableString get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataMappingException : Exception {
    [CompilerGeneratedAttribute]
private FormDataMappingError <Error>k__BackingField;
    public FormDataMappingError Error { get; }
    public FormDataMappingException(FormDataMappingError error);
    public FormDataMappingException(FormDataMappingError error, Exception innerException);
    [CompilerGeneratedAttribute]
public FormDataMappingError get_Error();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataReader : ValueType {
    private IReadOnlyDictionary`2<FormKey, StringValues> _readOnlyMemoryKeys;
    private Memory`1<char> _prefixBuffer;
    private Memory`1<char> _currentPrefixBuffer;
    private int _currentDepth;
    private int _errorCount;
    private IReadOnlyDictionary`2<FormKey, HashSet`1<FormKey>> _formDictionaryKeysByPrefix;
    private PrefixResolver _prefixResolver;
    [CompilerGeneratedAttribute]
private IFormatProvider <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormFileCollection <FormFileCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, FormattableString, string> <ErrorHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, object> <AttachInstanceToErrorsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxErrorCount>k__BackingField;
    [NullableAttribute("0")]
internal ReadOnlyMemory`1<char> CurrentPrefix { get; }
    public IFormatProvider Culture { get; }
    [NullableAttribute("2")]
public IFormFileCollection FormFileCollection { get; internal set; }
    public int MaxRecursionDepth { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`3<string, FormattableString, string> ErrorHandler { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<string, object> AttachInstanceToErrorsHandler { get; public set; }
    public int MaxErrorCount { get; public set; }
    private string DebuggerDisplay { get; }
    public FormDataReader(IReadOnlyDictionary`2<FormKey, StringValues> formCollection, CultureInfo culture, Memory`1<char> buffer);
    public FormDataReader(IReadOnlyDictionary`2<FormKey, StringValues> formCollection, CultureInfo culture, Memory`1<char> buffer, IFormFileCollection formFileCollection);
    [NullableContextAttribute("0")]
internal ReadOnlyMemory`1<char> get_CurrentPrefix();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IFormatProvider get_Culture();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormFileCollection get_FormFileCollection();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_FormFileCollection(IFormFileCollection value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxRecursionDepth();
    [CompilerGeneratedAttribute]
public void set_MaxRecursionDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Action`3<string, FormattableString, string> get_ErrorHandler();
    [CompilerGeneratedAttribute]
public void set_ErrorHandler(Action`3<string, FormattableString, string> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Action`2<string, object> get_AttachInstanceToErrorsHandler();
    [CompilerGeneratedAttribute]
public void set_AttachInstanceToErrorsHandler(Action`2<string, object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxErrorCount();
    [CompilerGeneratedAttribute]
public void set_MaxErrorCount(int value);
    public void AddMappingError(FormattableString errorMessage, string attemptedValue);
    public void AddMappingError(Exception exception, string attemptedValue);
    public void AttachInstanceToErrors(object value);
    internal FormKeyCollection GetKeys();
    internal IReadOnlyDictionary`2<FormKey, HashSet`1<FormKey>> ProcessFormKeys();
    internal bool CurrentPrefixExists();
    internal void PopPrefix(string key);
    [NullableContextAttribute("0")]
internal void PopPrefix(ReadOnlySpan`1<char> key);
    internal void PushPrefix(string key);
    [NullableContextAttribute("0")]
internal void PushPrefix(ReadOnlySpan`1<char> key);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
internal bool TryGetValue(String& value);
    [IsReadOnlyAttribute]
internal bool TryGetValues(StringValues& values);
    internal string GetPrefix();
    internal string GetLastPrefixSegment();
    public sealed virtual void Dispose();
    [IsReadOnlyAttribute]
private string get_DebuggerDisplay();
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormDataResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string DictionaryUnparsableKey { get; }
    internal static string EnumMappingError { get; }
    internal static string MappingExceptionMessage { get; }
    internal static string MaxCollectionSizeReached { get; }
    internal static string ParsableMappingError { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_DictionaryUnparsableKey();
    internal static string FormatDictionaryUnparsableKey(object p0, object p1);
    internal static string get_EnumMappingError();
    internal static string FormatEnumMappingError(object p0, object p1);
    internal static string get_MappingExceptionMessage();
    internal static string get_MaxCollectionSizeReached();
    internal static string FormatMaxCollectionSizeReached(object p0, object p1);
    internal static string get_ParsableMappingError();
    internal static string FormatParsableMappingError(object p0, object p1);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormKey : ValueType {
    private int _hashCode;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Value>k__BackingField;
    public ReadOnlyMemory`1<char> Value { get; }
    public FormKey(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FormKey other);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.FormMappingHelpers : object {
    public static string RequiresUnreferencedCodeMessage;
    public static string RequiresDynamicCodeMessage;
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ICollectionBufferAdapter`3 {
    public static abstract virtual TBuffer CreateBuffer();
    public static abstract virtual TBuffer Add(TBuffer& buffer, TElement element);
    public static abstract virtual TCollection ToResult(TBuffer buffer);
}
[NullableContextAttribute("2")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ICollectionFactory`2 {
    [NullableContextAttribute("1")]
public static abstract virtual TCollection ToResultCore(TElement[] buffer, int size);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.IDictionaryBufferAdapter`4 {
    public static abstract virtual TBuffer CreateBuffer();
    public static abstract virtual TBuffer Add(TBuffer& buffer, TKey key, TValue value);
    public static abstract virtual TDictionary ToResult(TBuffer buffer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.IFormDataConverterFactory {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableArrayBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableArray`1<TElement> ToResult(Builder<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableDictionaryBufferAdapter`2 : object {
    public static override Builder<TKey, TValue> Add(Builder& buffer, TKey key, TValue value);
    public static override Builder<TKey, TValue> CreateBuffer();
    public static override ImmutableDictionary`2<TKey, TValue> ToResult(Builder<TKey, TValue> buffer);
    internal static DictionaryConverter`1<IImmutableDictionary`2<TKey, TValue>> CreateInterfaceConverter(FormDataConverter`1<TValue> valueTypeConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableHashSetBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableHashSet`1<TElement> ToResult(Builder<TElement> buffer);
    public static CollectionConverter`1<IImmutableSet`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableListBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableList`1<TElement> ToResult(Builder<TElement> buffer);
    public static CollectionConverter`1<IImmutableList`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableQueueBufferAdapter`1 : ArrayPoolBufferAdapter`3<ImmutableQueue`1<TElement>, ImmutableQueueFactory<TElement>, TElement> {
    [NullableContextAttribute("1")]
public static CollectionConverter`1<IImmutableQueue`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableSortedDictionaryBufferAdapter`2 : object {
    public static override Builder<TKey, TValue> Add(Builder& buffer, TKey key, TValue value);
    public static override Builder<TKey, TValue> CreateBuffer();
    public static override ImmutableSortedDictionary`2<TKey, TValue> ToResult(Builder<TKey, TValue> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableSortedSetBufferAdapter`1 : object {
    public static override Builder<TElement> CreateBuffer();
    public static override Builder<TElement> Add(Builder& buffer, TElement element);
    public static override ImmutableSortedSet`1<TElement> ToResult(Builder<TElement> buffer);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImmutableStackBufferAdapter`1 : ArrayPoolBufferAdapter`3<ImmutableStack`1<TElement>, ImmutableStackFactory<TElement>, TElement> {
    [NullableContextAttribute("1")]
public static CollectionConverter`1<IImmutableStack`1<TElement>> CreateInterfaceConverter(FormDataConverter`1<TElement> elementConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ImplementingCollectionBufferAdapter`3 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TElement element);
    public static override TCollection ToResult(TBuffer buffer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.ISingleValueConverter`1 {
    public abstract virtual bool CanConvertSingleValue();
    public abstract virtual bool TryConvertValue(FormDataReader& reader, string value, T& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataMetadataFactory : object {
    private object _lock;
    private FormMetadataContext _context;
    private ParsableConverterFactory _parsableFactory;
    private DictionaryConverterFactory _dictionaryFactory;
    private FileConverterFactory _fileConverterFactory;
    private CollectionConverterFactory _collectionFactory;
    private ILogger`1<FormDataMetadataFactory> _logger;
    public FormDataMetadataFactory(List`1<IFormDataConverterFactory> factories, ILoggerFactory loggerFactory);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public FormDataTypeMetadata GetOrCreateMetadataFor(Type type, FormDataMapperOptions options);
    internal bool HasMetadataFor(Type type);
    private void DetectCyclesAndMarkMetadataTypesAsRecursive(Type type, FormDataTypeMetadata result);
    [CompilerGeneratedAttribute]
private void <DetectCyclesAndMarkMetadataTypesAsRecursive>g__ReportRecursiveChain|10_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataParameterMetadata : object {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private FormDataTypeMetadata <ParameterMetadata>k__BackingField;
    public ParameterInfo Parameter { get; }
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public bool Required { get; }
    internal FormDataTypeMetadata ParameterMetadata { get; }
    public FormDataParameterMetadata(ParameterInfo parameter, FormDataTypeMetadata parameterTypeInfo);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    public sealed virtual bool get_Required();
    [CompilerGeneratedAttribute]
internal FormDataTypeMetadata get_ParameterMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataPropertyMetadata : object {
    [CompilerGeneratedAttribute]
private PropertyInfo <property>P;
    [CompilerGeneratedAttribute]
private FormDataTypeMetadata <PropertyMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public PropertyInfo Property { get; }
    public FormDataTypeMetadata PropertyMetadata { get; }
    public string Name { get; public set; }
    public Type Type { get; }
    public bool Required { get; public set; }
    public FormDataPropertyMetadata(PropertyInfo property, FormDataTypeMetadata propertyTypeInfo);
    public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_PropertyMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
internal enum Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataTypeKind : Enum {
    public int value__;
    public static FormDataTypeKind Primitive;
    public static FormDataTypeKind File;
    public static FormDataTypeKind Collection;
    public static FormDataTypeKind Dictionary;
    public static FormDataTypeKind Object;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.FormDataTypeMetadata : object {
    [CompilerGeneratedAttribute]
private FormDataTypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private FormDataTypeMetadata <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private FormDataTypeMetadata <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private FormDataTypeMetadata <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FormDataParameterMetadata> <ConstructorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FormDataPropertyMetadata> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecursive>k__BackingField;
    public FormDataTypeKind Kind { get; public set; }
    [NullableAttribute("1")]
public Type Type { get; public set; }
    public FormDataTypeMetadata ElementType { get; public set; }
    public FormDataTypeMetadata KeyType { get; public set; }
    public FormDataTypeMetadata ValueType { get; public set; }
    public ConstructorInfo Constructor { get; public set; }
    [NullableAttribute("1")]
public IList`1<FormDataParameterMetadata> ConstructorParameters { get; public set; }
    [NullableAttribute("1")]
public IList`1<FormDataPropertyMetadata> Properties { get; public set; }
    public bool IsRecursive { get; internal set; }
    [NullableContextAttribute("1")]
public FormDataTypeMetadata(Type type);
    [CompilerGeneratedAttribute]
public FormDataTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(FormDataTypeKind value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_Type();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public FormDataTypeMetadata get_ValueType();
    [CompilerGeneratedAttribute]
public void set_ValueType(FormDataTypeMetadata value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public void set_Constructor(ConstructorInfo value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<FormDataParameterMetadata> get_ConstructorParameters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ConstructorParameters(IList`1<FormDataParameterMetadata> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<FormDataPropertyMetadata> get_Properties();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Properties(IList`1<FormDataPropertyMetadata> value);
    [CompilerGeneratedAttribute]
public bool get_IsRecursive();
    [CompilerGeneratedAttribute]
internal void set_IsRecursive(bool value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Components.Endpoints.FormMapping.Metadata.IFormDataValue {
    public string Name { get; }
    public Type Type { get; }
    public bool Required { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_Required();
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.NullableConverter`1 : FormDataConverter`1<Nullable`1<T>> {
    private FormDataConverter`1<T> _nonNullableConverter;
    public NullableConverter`1(FormDataConverter`1<T> nonNullableConverter);
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, Nullable`1& result);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, Nullable`1& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.NullableConverterFactory : object {
    public static NullableConverterFactory Instance;
    private static NullableConverterFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ParsableConverter`1 : FormDataConverter`1<T> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, T& result);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& reader, Type type, FormDataMapperOptions options, T& result, Boolean& found);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ParsableConverterFactory : object {
    public static ParsableConverterFactory Instance;
    private static ParsableConverterFactory();
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.PrefixResolver : ValueType {
    private FormKey[] _sortedKeys;
    private int _length;
    public bool HasValues { get; }
    [NullableContextAttribute("1")]
public PrefixResolver(IEnumerable`1<FormKey> readOnlyMemoryKeys, int count);
    public bool get_HasValues();
    internal bool HasPrefix(ReadOnlyMemory`1<char> currentPrefixBuffer);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.QueueBufferAdapter`1 : object {
    public static override Queue`1<TElement> CreateBuffer();
    public static override Queue`1<TElement> Add(Queue`1& buffer, TElement element);
    public static override Queue`1<TElement> ToResult(Queue`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ReadOnlyCollectionBufferAdapter`1 : object {
    public static override IList`1<TElement> CreateBuffer();
    public static override IList`1<TElement> Add(IList`1& buffer, TElement element);
    public static override ReadOnlyCollection`1<TElement> ToResult(IList`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.ReadOnlyDictionaryBufferAdapter`2 : object {
    public static override Dictionary`2<TKey, TValue> Add(Dictionary`2& buffer, TKey key, TValue value);
    public static override Dictionary`2<TKey, TValue> CreateBuffer();
    public static override ReadOnlyDictionary`2<TKey, TValue> ToResult(Dictionary`2<TKey, TValue> buffer);
    internal static DictionaryConverter`1<IReadOnlyDictionary`2<TKey, TValue>> CreateInterfaceConverter(FormDataConverter`1<TValue> valueTypeConverter);
    internal static DictionaryConverter`1<ReadOnlyDictionary`2<TKey, TValue>> CreateConverter(FormDataConverter`1<TValue> valueTypeConverter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.StackBufferAdapter`1 : object {
    public static override Stack`1<TElement> CreateBuffer();
    public static override Stack`1<TElement> Add(Stack`1& buffer, TElement element);
    public static override Stack`1<TElement> ToResult(Stack`1<TElement> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.StaticCastAdapter`5 : object {
    public static override TBuffer CreateBuffer();
    public static override TBuffer Add(TBuffer& buffer, TElement element);
    public static override TCollectionInterface ToResult(TBuffer buffer);
}
internal abstract class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedCollectionConverterFactory : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public abstract virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedCollectionConverterFactory`2 : TypedCollectionConverterFactory {
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public virtual bool CanConvert(Type _, FormDataMapperOptions options);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public virtual FormDataConverter CreateConverter(Type _, FormDataMapperOptions options);
    [CompilerGeneratedAttribute]
internal static FormDataConverter <CreateConverter>g__CreateConverter|1_0(FormDataConverter`1<TElement> elementTypeConverter);
}
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.TypedDictionaryConverterFactory`3 : object {
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual bool CanConvert(Type type, FormDataMapperOptions options);
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
public sealed virtual FormDataConverter CreateConverter(Type type, FormDataMapperOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Components.Endpoints.FormMapping.UriFormDataConverter : FormDataConverter`1<Uri> {
    public sealed virtual bool CanConvertSingleValue();
    public sealed virtual bool TryConvertValue(FormDataReader& reader, string value, Uri& result);
    [RequiresDynamicCodeAttribute("Form mapping may require dynamic code generation.")]
[RequiresUnreferencedCodeAttribute("Form mapping is not compatible with trimming, as it requires dynamic access to code that is not referenced statically.")]
internal virtual bool TryRead(FormDataReader& context, Type type, FormDataMapperOptions options, Uri& result, Boolean& found);
}
internal static class Microsoft.AspNetCore.Components.Endpoints.FormMapping.WellKnownConverters : object {
    [NullableAttribute("1")]
public static IReadOnlyDictionary`2<Type, FormDataConverter> Converters;
    private static WellKnownConverters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.Forms.EndpointAntiforgeryStateProvider : DefaultAntiforgeryStateProvider {
    [CompilerGeneratedAttribute]
private IAntiforgery <antiforgery>P;
    private HttpContext _context;
    public EndpointAntiforgeryStateProvider(IAntiforgery antiforgery, PersistentComponentState state);
    internal void SetRequestContext(HttpContext context);
    [NullableContextAttribute("2")]
public virtual AntiforgeryRequestToken GetAntiforgeryToken();
}
internal class Microsoft.AspNetCore.Components.Endpoints.HotReloadService : object {
    private CancellationTokenSource _tokenSource;
    [CompilerGeneratedAttribute]
private static Action`1<Type[]> UpdateApplicationEvent;
    [CompilerGeneratedAttribute]
private static Action`1<Type[]> ClearCacheEvent;
    [CompilerGeneratedAttribute]
private bool <MetadataUpdateSupported>k__BackingField;
    public bool MetadataUpdateSupported { get; internal set; }
    [CompilerGeneratedAttribute]
private static void add_UpdateApplicationEvent(Action`1<Type[]> value);
    [CompilerGeneratedAttribute]
private static void remove_UpdateApplicationEvent(Action`1<Type[]> value);
    [CompilerGeneratedAttribute]
internal static void add_ClearCacheEvent(Action`1<Type[]> value);
    [CompilerGeneratedAttribute]
internal static void remove_ClearCacheEvent(Action`1<Type[]> value);
    [CompilerGeneratedAttribute]
public bool get_MetadataUpdateSupported();
    [CompilerGeneratedAttribute]
internal void set_MetadataUpdateSupported(bool value);
    [NullableContextAttribute("1")]
public IChangeToken GetChangeToken();
    public static void UpdateApplication(Type[] changedTypes);
    public static void ClearCache(Type[] types);
    private void NotifyUpdateApplication(Type[] changedTypes);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.HttpContextFormDataProvider : object {
    private string _incomingHandlerName;
    private IReadOnlyDictionary`2<string, StringValues> _entries;
    private IFormFileCollection _formFiles;
    [NullableAttribute("2")]
public string IncomingHandlerName { get; }
    public IReadOnlyDictionary`2<string, StringValues> Entries { get; }
    public IFormFileCollection FormFiles { get; }
    [NullableContextAttribute("2")]
public string get_IncomingHandlerName();
    public IReadOnlyDictionary`2<string, StringValues> get_Entries();
    public IFormFileCollection get_FormFiles();
    public void SetFormData(string incomingHandlerName, IReadOnlyDictionary`2<string, StringValues> form, IFormFileCollection formFiles);
    [NullableContextAttribute("2")]
public bool TryGetIncomingHandlerName(String& incomingHandlerName);
}
internal class Microsoft.AspNetCore.Components.Endpoints.HttpContextFormValueMapper : object {
    private HttpContextFormDataProvider _formData;
    private FormDataMapperOptions _options;
    private static ConcurrentDictionary`2<Type, FormValueSupplier> _cache;
    [NullableContextAttribute("1")]
public HttpContextFormValueMapper(HttpContextFormDataProvider formData, IOptions`1<RazorComponentsServiceOptions> options);
    private static HttpContextFormValueMapper();
    [NullableContextAttribute("1")]
public sealed virtual bool CanMap(Type valueType, string scopeName, string formName);
    private static bool MatchesScope(string incomingScopeQualifiedFormName, string currentMappingScopeName, ReadOnlySpan`1& incomingFormName);
    [NullableContextAttribute("1")]
public sealed virtual void Map(FormValueMappingContext context);
    private FormValueSupplier CreateDeserializer(Type type);
}
internal class Microsoft.AspNetCore.Components.Endpoints.HttpNavigationManager : NavigationManager {
    private sealed virtual override void Microsoft.AspNetCore.Components.Routing.IHostEnvironmentNavigationManager.Initialize(string baseUri, string uri);
    [NullableContextAttribute("1")]
protected virtual void NavigateToCore(string uri, NavigationOptions options);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Components.Endpoints.IComponentPrerenderer {
    public Dispatcher Dispatcher { get; }
    public abstract virtual ValueTask`1<IHtmlAsyncContent> PrerenderComponentAsync(HttpContext httpContext, Type componentType, IComponentRenderMode renderMode, ParameterView parameters);
    public abstract virtual ValueTask`1<IHtmlContent> PrerenderPersistedStateAsync(HttpContext httpContext, PersistedStateSerializationMode serializationMode);
    public abstract virtual Dispatcher get_Dispatcher();
}
public static class Microsoft.AspNetCore.Components.Endpoints.Infrastructure.ComponentEndpointConventionBuilderHelper : object {
    [NullableContextAttribute("1")]
public static void AddRenderMode(RazorComponentsEndpointConventionBuilder builder, IComponentRenderMode renderMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Components.Endpoints.Infrastructure.RenderModeEndpointProvider : object {
    public abstract virtual bool Supports(IComponentRenderMode renderMode);
    public abstract virtual IEnumerable`1<RouteEndpointBuilder> GetEndpointBuilders(IComponentRenderMode renderMode, IApplicationBuilder applicationBuilder);
    internal static void AddEndpoints(List`1<Endpoint> endpoints, Type rootComponent, IEnumerable`1<RouteEndpointBuilder> renderModeEndpoints, IComponentRenderMode renderMode, List`1<Action`1<EndpointBuilder>> conventions, List`1<Action`1<EndpointBuilder>> finallyConventions);
}
internal class Microsoft.AspNetCore.Components.Endpoints.InvokedRenderModes : object {
    [CompilerGeneratedAttribute]
private Mode <Value>k__BackingField;
    public Mode Value { get; public set; }
    public InvokedRenderModes(Mode mode);
    [CompilerGeneratedAttribute]
public Mode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Mode value);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Components.Endpoints.IRazorComponentEndpointInvoker {
    public abstract virtual Task Render(HttpContext context);
}
internal class Microsoft.AspNetCore.Components.Endpoints.OpaqueRedirection : object {
    private static string RedirectionDataProtectionProviderPurpose;
    private static string RedirectionEndpointBaseRelativeUrl;
    [NullableContextAttribute("1")]
public static string CreateProtectedRedirectionUrl(HttpContext httpContext, string destinationUrl);
    [NullableContextAttribute("1")]
public static void AddBlazorOpaqueRedirectionEndpoint(IEndpointRouteBuilder endpoints);
    private static ITimeLimitedDataProtector CreateProtector(HttpContext httpContext);
}
internal class Microsoft.AspNetCore.Components.Endpoints.PrerenderingErrorBoundaryLogger : object {
    private static Action`3<ILogger, string, Exception> _exceptionCaughtByErrorBoundary;
    private ILogger _logger;
    [NullableContextAttribute("1")]
public PrerenderingErrorBoundaryLogger(ILogger`1<ErrorBoundary> logger);
    private static PrerenderingErrorBoundaryLogger();
    [NullableContextAttribute("1")]
public sealed virtual ValueTask LogErrorAsync(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentDataSourceOptions : object {
    internal static EqualityComparer`1<IComponentRenderMode> RenderModeComparer;
    [CompilerGeneratedAttribute]
private ISet`1<IComponentRenderMode> <ConfiguredRenderModes>k__BackingField;
    internal ISet`1<IComponentRenderMode> ConfiguredRenderModes { get; }
    private static RazorComponentDataSourceOptions();
    [CompilerGeneratedAttribute]
internal ISet`1<IComponentRenderMode> get_ConfiguredRenderModes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointDataSource`1 : EndpointDataSource {
    private object _lock;
    private List`1<Action`1<EndpointBuilder>> _conventions;
    private List`1<Action`1<EndpointBuilder>> _finallyConventions;
    private RazorComponentDataSourceOptions _options;
    private ComponentApplicationBuilder _builder;
    private IApplicationBuilder _applicationBuilder;
    private RenderModeEndpointProvider[] _renderModeEndpointProviders;
    private RazorComponentEndpointFactory _factory;
    private HotReloadService _hotReloadService;
    private List`1<Endpoint> _endpoints;
    private CancellationTokenSource _cancellationTokenSource;
    private IChangeToken _changeToken;
    private IDisposable _disposableChangeToken;
    public Func`2<IDisposable, IDisposable> SetDisposableChangeTokenAction;
    [CompilerGeneratedAttribute]
private RazorComponentsEndpointConventionBuilder <DefaultBuilder>k__BackingField;
    internal ComponentApplicationBuilder Builder { get; }
    internal List`1<Action`1<EndpointBuilder>> Conventions { get; }
    internal RazorComponentsEndpointConventionBuilder DefaultBuilder { get; }
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    internal RazorComponentDataSourceOptions Options { get; }
    public RazorComponentEndpointDataSource`1(ComponentApplicationBuilder builder, IEnumerable`1<RenderModeEndpointProvider> renderModeEndpointProviders, IApplicationBuilder applicationBuilder, RazorComponentEndpointFactory factory, HotReloadService hotReloadService);
    internal ComponentApplicationBuilder get_Builder();
    internal List`1<Action`1<EndpointBuilder>> get_Conventions();
    [CompilerGeneratedAttribute]
internal RazorComponentsEndpointConventionBuilder get_DefaultBuilder();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    internal RazorComponentDataSourceOptions get_Options();
    private void Initialize();
    private void UpdateEndpoints();
    public void OnHotReloadClearCache(Type[] types);
    public virtual IChangeToken GetChangeToken();
}
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointFactory : object {
    private static HttpMethodMetadata HttpMethodsMetadata;
    private static RazorComponentEndpointFactory();
    [NullableContextAttribute("1")]
internal void AddEndpoints(List`1<Endpoint> endpoints, Type rootComponent, PageComponentInfo pageDefinition, IReadOnlyList`1<Action`1<EndpointBuilder>> conventions, IReadOnlyList`1<Action`1<EndpointBuilder>> finallyConventions, ConfiguredRenderModesMetadata configuredRenderModesMetadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointHost : object {
    private RenderHandle _renderHandle;
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <ComponentParameters>k__BackingField;
    [ParameterAttribute]
[DynamicallyAccessedMembersAttribute("-1")]
public Type ComponentType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ParameterAttribute]
public IReadOnlyDictionary`2<string, object> ComponentParameters { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(Type value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_ComponentParameters();
    [CompilerGeneratedAttribute]
public void set_ComponentParameters(IReadOnlyDictionary`2<string, object> value);
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    private void BuildRenderTree(RenderTreeBuilder builder);
    private void RenderPageWithParameters(RenderTreeBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointInvoker : object {
    private EndpointHtmlRenderer _renderer;
    private ILogger`1<RazorComponentEndpointInvoker> _logger;
    public RazorComponentEndpointInvoker(EndpointHtmlRenderer renderer, ILogger`1<RazorComponentEndpointInvoker> logger);
    public sealed virtual Task Render(HttpContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointInvoker/<RenderComponentCore>d__4")]
private Task RenderComponentCore(HttpContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.RazorComponentEndpointInvoker/<ValidateRequestAsync>d__5")]
private Task`1<RequestValidationState> ValidateRequestAsync(HttpContext context, IAntiforgery antiforgery);
    private static string GetFormHandler(HttpContext context, Boolean& isBadRequest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.Endpoints.RazorComponentResultExecutor : object {
    public static string DefaultContentType;
    public static Task ExecuteAsync(HttpContext httpContext, RazorComponentResult result);
    private static Task RenderComponentToResponse(HttpContext httpContext, Type componentType, IReadOnlyDictionary`2<string, object> componentParameters, bool preventStreamingRendering);
}
internal class Microsoft.AspNetCore.Components.Endpoints.RazorComponentsMarkerService : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Endpoints.RazorComponentsServiceOptions : object {
    private TimeSpan _temporaryRedirectionUrlValidityDuration;
    [NullableAttribute("1")]
internal FormDataMapperOptions _formMappingOptions;
    [CompilerGeneratedAttribute]
private bool <DetailedErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JavaScriptInitializers>k__BackingField;
    public bool DetailedErrors { get; public set; }
    public int MaxFormMappingCollectionSize { get; public set; }
    public int MaxFormMappingRecursionDepth { get; public set; }
    public int MaxFormMappingErrorCount { get; public set; }
    public int MaxFormMappingKeySize { get; public set; }
    public TimeSpan TemporaryRedirectionUrlValidityDuration { get; public set; }
    internal string JavaScriptInitializers { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_DetailedErrors();
    [CompilerGeneratedAttribute]
public void set_DetailedErrors(bool value);
    public int get_MaxFormMappingCollectionSize();
    public void set_MaxFormMappingCollectionSize(int value);
    public int get_MaxFormMappingRecursionDepth();
    public void set_MaxFormMappingRecursionDepth(int value);
    public int get_MaxFormMappingErrorCount();
    public void set_MaxFormMappingErrorCount(int value);
    public int get_MaxFormMappingKeySize();
    public void set_MaxFormMappingKeySize(int value);
    public TimeSpan get_TemporaryRedirectionUrlValidityDuration();
    public void set_TemporaryRedirectionUrlValidityDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_JavaScriptInitializers();
    [CompilerGeneratedAttribute]
internal void set_JavaScriptInitializers(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.Rendering.BufferedTextWriter : TextWriter {
    private static int PageSize;
    private TextWriter _underlying;
    private StringBuilder _charArraySegmentBuilder;
    private TextChunkListBuilder _currentOutput;
    private TextChunkListBuilder _previousOutput;
    private Task _currentFlushAsyncTask;
    public Encoding Encoding { get; }
    public BufferedTextWriter(TextWriter underlying);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    public virtual void Write(int value);
    public virtual void Flush();
    public virtual Task FlushAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.Rendering.BufferedTextWriter/<FlushAsyncCore>d__15")]
private Task FlushAsyncCore(Task priorTask);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Components.Endpoints.Rendering.TextChunk : ValueType {
    private TextChunkType _type;
    private string _stringValue;
    private char _charValue;
    private int _charArraySegmentStart;
    private int _charArraySegmentLength;
    private int _intValue;
    [NullableContextAttribute("1")]
public TextChunk(string value);
    public TextChunk(char value);
    public TextChunk(ArraySegment`1<char> value, StringBuilder charArraySegmentScope);
    public TextChunk(int value);
    [NullableContextAttribute("1")]
public Task WriteToAsync(TextWriter writer, string charArraySegments, StringBuilder& tempBuffer);
}
internal class Microsoft.AspNetCore.Components.Endpoints.Rendering.TextChunkListBuilder : object {
    [CompilerGeneratedAttribute]
private int <pageLength>P;
    private TextChunkPage _currentPage;
    private List`1<TextChunkPage> _priorPages;
    public TextChunkListBuilder(int pageLength);
    public void Add(TextChunk value);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Components.Endpoints.Rendering.TextChunkListBuilder/<WriteToAsync>d__5")]
public Task WriteToAsync(TextWriter writer, string charArraySegments);
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.Rendering.TextChunkPage : object {
    private TextChunk[] _buffer;
    private int _count;
    public TextChunk[] Buffer { get; }
    public int Count { get; }
    public TextChunkPage(int capacity);
    public TextChunk[] get_Buffer();
    public int get_Count();
    public bool TryAdd(TextChunk value);
    public void Clear();
}
internal static class Microsoft.AspNetCore.Components.Endpoints.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string FailedToInferComponentPersistenceMode { get; }
    internal static string TypeMustDeriveFromType { get; }
    internal static string UnableToFindServices { get; }
    internal static string UnsupportedRenderMode { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_FailedToInferComponentPersistenceMode();
    internal static string get_TypeMustDeriveFromType();
    internal static string FormatTypeMustDeriveFromType(object p0, object p1);
    internal static string get_UnableToFindServices();
    internal static string FormatUnableToFindServices(object p0, object p1);
    internal static string get_UnsupportedRenderMode();
    internal static string FormatUnsupportedRenderMode(object p0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Components.Endpoints.RootComponentMetadata : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [DynamicallyAccessedMembersAttribute("-1")]
public Type Type { get; }
    public RootComponentMetadata(Type rootComponentType);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
internal class Microsoft.AspNetCore.Components.Endpoints.ServerComponentInvocationSequence : object {
    private int _sequence;
    [CompilerGeneratedAttribute]
private Guid <Value>k__BackingField;
    public Guid Value { get; }
    [CompilerGeneratedAttribute]
public Guid get_Value();
    public int Next();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.ServerComponentSerializer : object {
    private ITimeLimitedDataProtector _dataProtector;
    public ServerComponentSerializer(IDataProtectionProvider dataProtectionProvider);
    public void SerializeInvocation(ComponentMarker& marker, ServerComponentInvocationSequence invocationId, Type type, ParameterView parameters);
    private ValueTuple`2<int, string> CreateSerializedServerComponent(ServerComponentInvocationSequence invocationId, Type rootComponent, ParameterView parameters, Nullable`1<ComponentMarkerKey> key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Endpoints.SSRRenderModeBoundary : object {
    private static ConcurrentDictionary`2<Type, string> _componentTypeNameHashCache;
    [DynamicallyAccessedMembersAttribute("-1")]
private Type _componentType;
    private bool _prerender;
    private RenderHandle _renderHandle;
    private IReadOnlyDictionary`2<string, object> _latestParameters;
    private Nullable`1<ComponentMarkerKey> _markerKey;
    [CompilerGeneratedAttribute]
private IComponentRenderMode <RenderMode>k__BackingField;
    public IComponentRenderMode RenderMode { get; }
    public SSRRenderModeBoundary(HttpContext httpContext, Type componentType, IComponentRenderMode renderMode);
    private static SSRRenderModeBoundary();
    [CompilerGeneratedAttribute]
public IComponentRenderMode get_RenderMode();
    private static void AssertRenderModeIsConfigured(HttpContext httpContext, Type componentType, IComponentRenderMode renderMode);
    private static void AssertRenderModeIsConfigured(Type componentType, IComponentRenderMode specifiedMode, IComponentRenderMode[] configuredModes, string expectedCall);
    public sealed virtual void Attach(RenderHandle renderHandle);
    public sealed virtual Task SetParametersAsync(ParameterView parameters);
    private void ValidateParameters(IReadOnlyDictionary`2<string, object> latestParameters);
    private void Prerender(RenderTreeBuilder builder);
    public ComponentMarker ToMarker(HttpContext httpContext, int sequence, object componentKey);
    private ComponentMarkerKey GenerateMarkerKey(int sequence, object componentKey);
}
internal class Microsoft.AspNetCore.Components.Endpoints.TypeNameHash : object {
    public static int MaxStackBufferSize;
    [NullableContextAttribute("1")]
public static string Compute(Type type);
}
internal class Microsoft.AspNetCore.Components.Endpoints.UnsupportedJavaScriptRuntime : object {
    private static string Message;
    [NullableContextAttribute("2")]
public sealed virtual ValueTask`1<TValue> InvokeAsync(string identifier, CancellationToken cancellationToken, Object[] args);
    private sealed virtual override ValueTask`1<TValue> Microsoft.JSInterop.IJSRuntime.InvokeAsync(string identifier, Object[] args);
}
internal class Microsoft.AspNetCore.Components.Endpoints.UnsupportedNavigationInterception : object {
    [NullableContextAttribute("1")]
public sealed virtual Task EnableNavigationInterceptionAsync();
}
internal class Microsoft.AspNetCore.Components.Endpoints.UnsupportedScrollToLocationHash : object {
    [NullableContextAttribute("1")]
public sealed virtual Task RefreshScrollPositionForHash(string locationAbsolute);
}
internal class Microsoft.AspNetCore.Components.Endpoints.WebAssemblyComponentSerializer : object {
    [NullableContextAttribute("1")]
public static void SerializeInvocation(ComponentMarker& marker, Type type, ParameterView parameters);
}
internal class Microsoft.AspNetCore.Components.Forms.DefaultAntiforgeryStateProvider : AntiforgeryStateProvider {
    private static string PersistenceKey;
    private PersistingComponentStateSubscription _subscription;
    private AntiforgeryRequestToken _currentToken;
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
public DefaultAntiforgeryStateProvider(PersistentComponentState state);
    [NullableContextAttribute("2")]
public virtual AntiforgeryRequestToken GetAntiforgeryToken();
    public sealed virtual void Dispose();
}
[AttributeUsageAttribute("1")]
internal abstract class Microsoft.AspNetCore.Components.Infrastructure.RazorComponentApplicationAttribute : Attribute {
    [NullableContextAttribute("1")]
public abstract virtual ComponentApplicationBuilder GetBuilder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.Infrastructure.RazorComponentEndpointDataSourceFactory : object {
    private RazorComponentEndpointFactory _factory;
    private IEnumerable`1<RenderModeEndpointProvider> _providers;
    private HotReloadService _hotReloadService;
    public RazorComponentEndpointDataSourceFactory(RazorComponentEndpointFactory factory, IEnumerable`1<RenderModeEndpointProvider> providers, HotReloadService hotReloadService);
    public RazorComponentEndpointDataSource`1<TRootComponent> CreateDataSource(IEndpointRouteBuilder endpoints);
}
public enum Microsoft.AspNetCore.Components.PersistedStateSerializationMode : Enum {
    public int value__;
    public static PersistedStateSerializationMode Infer;
    public static PersistedStateSerializationMode Server;
    public static PersistedStateSerializationMode WebAssembly;
}
internal class Microsoft.AspNetCore.Components.PrerenderComponentApplicationStore : object {
    private bool _stateIsPersisted;
    [CompilerGeneratedAttribute]
private string <PersistedState>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Byte[]> <ExistingState>k__BackingField;
    [NullableAttribute("2")]
public string PersistedState { get; private set; }
    public Dictionary`2<string, Byte[]> ExistingState { get; protected set; }
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public PrerenderComponentApplicationStore(string existingState);
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected void DeserializeState(Byte[] existingState);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PersistedState();
    [CompilerGeneratedAttribute]
private void set_PersistedState(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Byte[]> get_ExistingState();
    [CompilerGeneratedAttribute]
protected void set_ExistingState(Dictionary`2<string, Byte[]> value);
    public sealed virtual Task`1<IDictionary`2<string, Byte[]>> GetPersistedStateAsync();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    public sealed virtual Task PersistStateAsync(IReadOnlyDictionary`2<string, Byte[]> state);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ProtectedPrerenderComponentApplicationStore : PrerenderComponentApplicationStore {
    private IDataProtector _protector;
    public ProtectedPrerenderComponentApplicationStore(IDataProtectionProvider dataProtectionProvider);
    public ProtectedPrerenderComponentApplicationStore(string existingState, IDataProtectionProvider dataProtectionProvider);
    protected virtual Byte[] SerializeState(IReadOnlyDictionary`2<string, Byte[]> state);
    private void CreateProtector(IDataProtectionProvider dataProtectionProvider);
    public virtual bool SupportsRenderMode(IComponentRenderMode renderMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Components.ServerComponent : ValueType {
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ComponentMarkerKey> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ComponentParameter> <ParameterDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<object> <ParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InvocationId>k__BackingField;
    public int Sequence { get; public set; }
    public Nullable`1<ComponentMarkerKey> Key { get; public set; }
    public string AssemblyName { get; public set; }
    public string TypeName { get; public set; }
    public IList`1<ComponentParameter> ParameterDefinitions { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<object> ParameterValues { get; public set; }
    public Guid InvocationId { get; public set; }
    public ServerComponent(int sequence, Nullable`1<ComponentMarkerKey> key, string assemblyName, string typeName, IList`1<ComponentParameter> parametersDefinitions, IList`1<object> parameterValues, Guid invocationId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<ComponentMarkerKey> get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Nullable`1<ComponentMarkerKey> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<ComponentParameter> get_ParameterDefinitions();
    [CompilerGeneratedAttribute]
public void set_ParameterDefinitions(IList`1<ComponentParameter> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<object> get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(IList`1<object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_InvocationId();
    [CompilerGeneratedAttribute]
public void set_InvocationId(Guid value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Components.ServerComponentSerializationSettings : object {
    public static string DataProtectionProviderPurpose;
    public static JsonSerializerOptions JsonSerializationOptions;
    public static TimeSpan DataExpiration;
    private static ServerComponentSerializationSettings();
}
internal static class Microsoft.AspNetCore.Components.WebAssemblyComponentSerializationSettings : object {
    [NullableAttribute("1")]
public static JsonSerializerOptions JsonSerializationOptions;
    private static WebAssemblyComponentSerializationSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Http.HttpResults.RazorComponentResult : object {
    private static IReadOnlyDictionary`2<string, object> EmptyParameters;
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventStreamingRendering>k__BackingField;
    public Type ComponentType { get; }
    [NullableAttribute("2")]
public string ContentType { get; public set; }
    public Nullable`1<int> StatusCode { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Parameters { get; }
    public bool PreventStreamingRendering { get; public set; }
    public RazorComponentResult(Type componentType);
    public RazorComponentResult(Type componentType, object parameters);
    public RazorComponentResult(Type componentType, IReadOnlyDictionary`2<string, object> parameters);
    private static RazorComponentResult();
    private static IReadOnlyDictionary`2<string, object> CoerceParametersObjectToDictionary(object parameters);
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public bool get_PreventStreamingRendering();
    [CompilerGeneratedAttribute]
public void set_PreventStreamingRendering(bool value);
    public sealed virtual Task ExecuteAsync(HttpContext httpContext);
}
public class Microsoft.AspNetCore.Http.HttpResults.RazorComponentResult`1 : RazorComponentResult {
    [NullableContextAttribute("1")]
public RazorComponentResult`1(object parameters);
    public RazorComponentResult`1(IReadOnlyDictionary`2<string, object> parameters);
}
internal static class Microsoft.AspNetCore.Internal.LinkerFlags : object {
    public static DynamicallyAccessedMemberTypes JsonSerialized;
    public static DynamicallyAccessedMemberTypes Component;
    public static DynamicallyAccessedMemberTypes JSInvokable;
}
internal static class Microsoft.AspNetCore.StaticFiles.CacheHeaderSettings : object {
    [NullableContextAttribute("1")]
internal static void SetCacheHeaders(StaticFileResponseContext ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.DependencyInjection.DefaultRazorComponentsServiceOptionsConfiguration : object {
    [CompilerGeneratedAttribute]
private ILoggerFactory <loggerFactory>P;
    [CompilerGeneratedAttribute]
private IWebHostEnvironment <environment>P;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    public IConfiguration Configuration { get; }
    public DefaultRazorComponentsServiceOptionsConfiguration(IConfiguration configuration, ILoggerFactory loggerFactory, IWebHostEnvironment environment);
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    public sealed virtual void PostConfigure(string name, RazorComponentsServiceOptions options);
}
[NullableContextAttribute("1")]
public interface Microsoft.Extensions.DependencyInjection.IRazorComponentsBuilder {
    public IServiceCollection Services { get; }
    public abstract virtual IServiceCollection get_Services();
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.RazorComponentsServiceCollectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Razor Components does not currently support trimming or native AOT.")]
public static IRazorComponentsBuilder AddRazorComponents(IServiceCollection services, Action`1<RazorComponentsServiceOptions> configure);
}
internal static class Microsoft.Extensions.Internal.ClosedGenericMatcher : object {
    [NullableContextAttribute("1")]
public static Type ExtractGenericInterface(Type queryType, Type interfaceType);
    private static bool IsGenericInstantiation(Type candidate, Type interfaceType);
    private static Type GetGenericInstantiation(Type queryType, Type interfaceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Internal.PropertyHelper : object {
    private static BindingFlags DeclaredOnlyLookup;
    private static BindingFlags Everything;
    private static MethodInfo CallPropertyGetterOpenGenericMethod;
    private static MethodInfo CallPropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallPropertySetterOpenGenericMethod;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> PropertiesCache;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> VisiblePropertiesCache;
    private Action`2<object, object> _valueSetter;
    private Func`2<object, object> _valueGetter;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PropertyInfo Property { get; }
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> ValueGetter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> ValueSetter { get; }
    public PropertyHelper(PropertyInfo property);
    private static PropertyHelper();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public string get_Name();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public Func`2<object, object> get_ValueGetter();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public Action`2<object, object> get_ValueSetter();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public object GetValue(object instance);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public void SetValue(object instance, object value);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetProperties(Type type);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetVisibleProperties(Type type);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Func`2<object, object> MakeNullSafeFastPropertyGetter(PropertyInfo propertyInfo);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
private static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo, MethodInfo propertyGetterWrapperMethod, MethodInfo propertyGetterByRefWrapperMethod);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
[RequiresDynamicCodeAttribute("This API requires dynamic code because it makes generic types which may be filled with ValueTypes.")]
private static Func`2<object, object> MakeFastPropertyGetter(Type openGenericDelegateType, MethodInfo propertyGetMethod, MethodInfo openGenericWrapperMethod);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Action`2<object, object> MakeFastPropertySetter(PropertyInfo propertyInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Method uses reflection to generate the dictionary.")]
public static IDictionary`2<string, object> ObjectToDictionary(object value);
    private static object CallPropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallPropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static void CallPropertySetter(Action`2<TDeclaringType, TValue> setter, object target, object value);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetVisibleProperties(Type type, ConcurrentDictionary`2<Type, PropertyHelper[]> allPropertiesCache, ConcurrentDictionary`2<Type, PropertyHelper[]> visiblePropertiesCache);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetProperties(Type type, ConcurrentDictionary`2<Type, PropertyHelper[]> cache);
    private static bool IsInterestingProperty(PropertyInfo property);
    [CompilerGeneratedAttribute]
internal static void <GetProperties>g__AddInterestingProperties|39_0(List`1<PropertyHelper> propertyHelpers, Type type);
}
