internal static class Interop : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Connections.CompletionPipeReader : PipeReader {
    private PipeReader _inner;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <CompleteException>k__BackingField;
    public bool IsCompleted { get; private set; }
    public Exception CompleteException { get; private set; }
    public bool IsCompletedSuccessfully { get; }
    [NullableContextAttribute("1")]
public CompletionPipeReader(PipeReader inner);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public Exception get_CompleteException();
    [CompilerGeneratedAttribute]
private void set_CompleteException(Exception value);
    public bool get_IsCompletedSuccessfully();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual ValueTask CompleteAsync(Exception exception);
    public virtual void Complete(Exception exception);
    public virtual void CancelPendingRead();
    [NullableContextAttribute("0")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    public void Reset();
}
internal class Microsoft.AspNetCore.Connections.CompletionPipeWriter : PipeWriter {
    private PipeWriter _inner;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <CompleteException>k__BackingField;
    public bool IsCompleted { get; private set; }
    [NullableAttribute("2")]
public Exception CompleteException { get; private set; }
    public bool IsCompletedSuccessfully { get; }
    [NullableContextAttribute("1")]
public CompletionPipeWriter(PipeWriter inner);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_CompleteException();
    [CompilerGeneratedAttribute]
private void set_CompleteException(Exception value);
    public bool get_IsCompletedSuccessfully();
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    public void Reset();
}
internal static class Microsoft.AspNetCore.Connections.ConnectionCompletion : object {
    [NullableContextAttribute("1")]
public static Task FireOnCompletedAsync(ILogger logger, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    private static Task CompleteAsyncMayAwait(ILogger logger, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Connections.ConnectionCompletion/<CompleteAsyncAwaited>d__2")]
private static Task CompleteAsyncAwaited(Task currentTask, ILogger logger, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
}
internal static class Microsoft.AspNetCore.Connections.CorrelationIdGenerator : object {
    private static Char[] s_encode32Chars;
    private static long _lastId;
    private static CorrelationIdGenerator();
    [NullableContextAttribute("1")]
public static string GetNextId();
    private static string GenerateId(long id);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Connections.TransportConnection : ConnectionContext {
    private IDictionary`2<object, object> _items;
    private string _connectionId;
    [CompilerGeneratedAttribute]
private IFeatureCollection <MultiplexedConnectionFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <LocalEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectionClosed>k__BackingField;
    protected internal IConnectionIdFeature _currentIConnectionIdFeature;
    protected internal IConnectionTransportFeature _currentIConnectionTransportFeature;
    protected internal IConnectionItemsFeature _currentIConnectionItemsFeature;
    protected internal IMemoryPoolFeature _currentIMemoryPoolFeature;
    protected internal IConnectionLifetimeFeature _currentIConnectionLifetimeFeature;
    protected internal IPersistentStateFeature _currentIPersistentStateFeature;
    protected internal IConnectionSocketFeature _currentIConnectionSocketFeature;
    protected internal IProtocolErrorCodeFeature _currentIProtocolErrorCodeFeature;
    protected internal IStreamDirectionFeature _currentIStreamDirectionFeature;
    protected internal IStreamIdFeature _currentIStreamIdFeature;
    protected internal IStreamAbortFeature _currentIStreamAbortFeature;
    protected internal IStreamClosedFeature _currentIStreamClosedFeature;
    protected internal IConnectionMetricsTagsFeature _currentIConnectionMetricsTagsFeature;
    private int _featureRevision;
    private List`1<KeyValuePair`2<Type, object>> MaybeExtra;
    public IFeatureCollection MultiplexedConnectionFeatures { get; protected set; }
    public EndPoint LocalEndPoint { get; public set; }
    public EndPoint RemoteEndPoint { get; public set; }
    [NullableAttribute("1")]
public string ConnectionId { get; public set; }
    [NullableAttribute("1")]
public IFeatureCollection Features { get; }
    [NullableAttribute("1")]
public MemoryPool`1<byte> MemoryPool { get; }
    [NullableAttribute("1")]
public IDuplexPipe Transport { get; public set; }
    [NullableAttribute("1")]
public IDuplexPipe Application { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<object, object> Items { get; public set; }
    public CancellationToken ConnectionClosed { get; public set; }
    private bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.IsReadOnly { get; }
    private int Microsoft.AspNetCore.Http.Features.IFeatureCollection.Revision { get; }
    private object Microsoft.AspNetCore.Http.Features.IFeatureCollection.Item { get; private set; }
    [NullableAttribute("1")]
private MemoryPool`1<byte> Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature.MemoryPool { get; }
    [NullableAttribute("1")]
private IDuplexPipe Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature.Transport { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.Items { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.ConnectionClosed { get; private set; }
    [CompilerGeneratedAttribute]
public IFeatureCollection get_MultiplexedConnectionFeatures();
    [CompilerGeneratedAttribute]
protected void set_MultiplexedConnectionFeatures(IFeatureCollection value);
    [CompilerGeneratedAttribute]
public virtual EndPoint get_LocalEndPoint();
    [CompilerGeneratedAttribute]
public virtual void set_LocalEndPoint(EndPoint value);
    [CompilerGeneratedAttribute]
public virtual EndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public virtual void set_RemoteEndPoint(EndPoint value);
    [NullableContextAttribute("1")]
public virtual string get_ConnectionId();
    [NullableContextAttribute("1")]
public virtual void set_ConnectionId(string value);
    [NullableContextAttribute("1")]
public virtual IFeatureCollection get_Features();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual MemoryPool`1<byte> get_MemoryPool();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual IDuplexPipe get_Transport();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual void set_Transport(IDuplexPipe value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDuplexPipe get_Application();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Application(IDuplexPipe value);
    public virtual IDictionary`2<object, object> get_Items();
    public virtual void set_Items(IDictionary`2<object, object> value);
    internal void ResetItems();
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_ConnectionClosed();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionClosed(CancellationToken value);
    [NullableContextAttribute("1")]
public virtual void Abort(ConnectionAbortedException abortReason);
    private void FastReset();
    internal void ResetFeatureCollection();
    private object ExtraFeatureGet(Type key);
    private void ExtraFeatureSet(Type key, object value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_IsReadOnly();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Revision();
    private sealed virtual override object Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Item(Type key);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.set_Item(Type key, object value);
    private sealed virtual override TFeature Microsoft.AspNetCore.Http.Features.IFeatureCollection.Get();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.Set(TFeature feature);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Connections.TransportConnection/<FastEnumerable>d__68")]
private IEnumerable`1<KeyValuePair`2<Type, object>> FastEnumerable();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override MemoryPool`1<byte> Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature.get_MemoryPool();
    private sealed virtual override IDuplexPipe Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature.get_Transport();
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature.set_Transport(IDuplexPipe value);
    private sealed virtual override IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.get_Items();
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.set_Items(IDictionary`2<object, object> value);
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.get_ConnectionClosed();
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.set_ConnectionClosed(CancellationToken value);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.Abort();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Connections.TransportMultiplexedConnection : MultiplexedConnectionContext {
    private IDictionary`2<object, object> _items;
    private string _connectionId;
    [CompilerGeneratedAttribute]
private EndPoint <LocalEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectionClosed>k__BackingField;
    protected internal IConnectionIdFeature _currentIConnectionIdFeature;
    protected internal IConnectionItemsFeature _currentIConnectionItemsFeature;
    protected internal IMemoryPoolFeature _currentIMemoryPoolFeature;
    protected internal IConnectionLifetimeFeature _currentIConnectionLifetimeFeature;
    protected internal IConnectionTransportFeature _currentIConnectionTransportFeature;
    protected internal IProtocolErrorCodeFeature _currentIProtocolErrorCodeFeature;
    protected internal ITlsConnectionFeature _currentITlsConnectionFeature;
    private int _featureRevision;
    private List`1<KeyValuePair`2<Type, object>> MaybeExtra;
    public EndPoint LocalEndPoint { get; public set; }
    public EndPoint RemoteEndPoint { get; public set; }
    [NullableAttribute("1")]
public string ConnectionId { get; public set; }
    [NullableAttribute("1")]
public IFeatureCollection Features { get; }
    [NullableAttribute("1")]
public MemoryPool`1<byte> MemoryPool { get; }
    [NullableAttribute("1")]
public IDuplexPipe Application { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<object, object> Items { get; public set; }
    public CancellationToken ConnectionClosed { get; public set; }
    private bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.IsReadOnly { get; }
    private int Microsoft.AspNetCore.Http.Features.IFeatureCollection.Revision { get; }
    private object Microsoft.AspNetCore.Http.Features.IFeatureCollection.Item { get; private set; }
    [NullableAttribute("1")]
private MemoryPool`1<byte> Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature.MemoryPool { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.Items { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.ConnectionClosed { get; private set; }
    [CompilerGeneratedAttribute]
public virtual EndPoint get_LocalEndPoint();
    [CompilerGeneratedAttribute]
public virtual void set_LocalEndPoint(EndPoint value);
    [CompilerGeneratedAttribute]
public virtual EndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public virtual void set_RemoteEndPoint(EndPoint value);
    [NullableContextAttribute("1")]
public virtual string get_ConnectionId();
    [NullableContextAttribute("1")]
public virtual void set_ConnectionId(string value);
    [NullableContextAttribute("1")]
public virtual IFeatureCollection get_Features();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual MemoryPool`1<byte> get_MemoryPool();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDuplexPipe get_Application();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Application(IDuplexPipe value);
    public virtual IDictionary`2<object, object> get_Items();
    public virtual void set_Items(IDictionary`2<object, object> value);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_ConnectionClosed();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionClosed(CancellationToken value);
    [NullableContextAttribute("1")]
public virtual void Abort(ConnectionAbortedException abortReason);
    private void FastReset();
    internal void ResetFeatureCollection();
    private object ExtraFeatureGet(Type key);
    private void ExtraFeatureSet(Type key, object value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_IsReadOnly();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Revision();
    private sealed virtual override object Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Item(Type key);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.set_Item(Type key, object value);
    private sealed virtual override TFeature Microsoft.AspNetCore.Http.Features.IFeatureCollection.Get();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.Set(TFeature feature);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Connections.TransportMultiplexedConnection/<FastEnumerable>d__53")]
private IEnumerable`1<KeyValuePair`2<Type, object>> FastEnumerable();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override MemoryPool`1<byte> Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature.get_MemoryPool();
    private sealed virtual override IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.get_Items();
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.set_Items(IDictionary`2<object, object> value);
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.get_ConnectionClosed();
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.set_ConnectionClosed(CancellationToken value);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.Abort();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.WebHostBuilderQuicExtensions : object {
    [ExtensionAttribute]
public static IWebHostBuilder UseQuic(IWebHostBuilder hostBuilder);
    [ExtensionAttribute]
public static IWebHostBuilder UseQuic(IWebHostBuilder hostBuilder, Action`1<QuicTransportOptions> configureOptions);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities : object {
    private static SpanAction`2<char, IntPtr> s_getAsciiOrUTF8StringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getAsciiStringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getLatin1StringNonNullCharacters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SpanAction`2<char, ValueTuple`3<string, char, UInt32>> s_populateSpanWithHexSuffix;
    private static StringUtilities();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(ReadOnlySpan`1<byte> span, Encoding defaultEncoding);
    [ExtensionAttribute]
public static string GetAsciiStringNonNullCharacters(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static string GetLatin1StringNonNullCharacters(ReadOnlySpan`1<byte> span);
    public static bool TryGetAsciiString(Byte* input, Char* output, int count);
    public static bool TryGetLatin1String(Byte* input, Char* output, int count);
    public static bool BytesOrdinalEqualsStringAndAscii(string previousValue, ReadOnlySpan`1<byte> newValue);
    private static void WidenFourAsciiBytesToUtf16AndWriteToBuffer(Char* output, Byte* input, int value, Vector128`1<sbyte> zero);
    private static bool IsValidHeaderString(string value);
    [NullableContextAttribute("1")]
public static string ConcatAsHexSuffix(string str, char separator, UInt32 number);
    private static bool CheckBytesInAsciiRange(Vector`1<sbyte> check);
    private static bool CheckBytesInAsciiRange(Vector256`1<sbyte> check, Vector256`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(Vector128`1<sbyte> check, Vector128`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(long check);
    private static bool CheckBytesInAsciiRange(int check);
    private static bool CheckBytesInAsciiRange(short check);
    private static bool CheckBytesInAsciiRange(sbyte check);
    private static bool CheckBytesNotNull(Vector`1<byte> check);
    private static bool CheckBytesNotNull(long check);
    private static bool CheckBytesNotNull(int check);
    private static bool CheckBytesNotNull(short check);
    private static bool CheckBytesNotNull(sbyte check);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.IPooledStream {
    public long PoolExpirationTimestamp { get; }
    public abstract virtual long get_PoolExpirationTimestamp();
    public abstract virtual void DisposeCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.PooledStreamStack`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal StreamAsValueType[] _array;
    private int _size;
    public int Count { get; }
    public PooledStreamStack`1(int size);
    [IsReadOnlyAttribute]
public int get_Count();
    [NullableContextAttribute("2")]
public bool TryPop(TValue& result);
    [NullableContextAttribute("2")]
public bool TryPeek(TValue& result);
    public void Push(TValue item);
    private void PushWithResize(TValue item);
    public void RemoveExpired(long timestamp);
    private static int CalculateRemoveCount(long timestamp, int size, StreamAsValueType[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionContext : TransportMultiplexedConnection {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PooledStreamStack`1<QuicStreamContext> StreamPool;
    private bool _streamPoolHeartbeatInitialized;
    private long _heartbeatTimestamp;
    private object _poolLock;
    private object _shutdownLock;
    private QuicConnection _connection;
    private QuicTransportContext _context;
    private ILogger _log;
    private CancellationTokenSource _connectionClosedTokenSource;
    private Task _closeTask;
    private ExceptionDispatchInfo _abortReason;
    internal static int InitialStreamPoolSize;
    internal static int MaxStreamPoolSize;
    internal static long StreamPoolExpirySeconds;
    private X509Certificate2 _clientCert;
    private Task`1<X509Certificate2> _clientCertTask;
    private Nullable`1<long> _error;
    public long Error { get; public set; }
    [NullableAttribute("2")]
public X509Certificate2 ClientCertificate { get; public set; }
    public QuicConnectionContext(QuicConnection connection, QuicTransportContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionContext/<DisposeAsync>d__15")]
public virtual ValueTask DisposeAsync();
    public virtual void Abort();
    public virtual void Abort(ConnectionAbortedException abortReason);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionContext/<AcceptAsync>d__18")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
public virtual ValueTask`1<ConnectionContext> AcceptAsync(CancellationToken cancellationToken);
    private void CancelConnectionClosedToken();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionContext/<ConnectAsync>d__20")]
public virtual ValueTask`1<ConnectionContext> ConnectAsync(IFeatureCollection features, CancellationToken cancellationToken);
    internal bool TryReturnStream(QuicStreamContext stream);
    internal QuicConnection GetInnerConnection();
    private void RemoveExpiredStreams();
    public sealed virtual long get_Error();
    public sealed virtual void set_Error(long value);
    [NullableContextAttribute("2")]
public sealed virtual X509Certificate2 get_ClientCertificate();
    [NullableContextAttribute("2")]
public sealed virtual void set_ClientCertificate(X509Certificate2 value);
    public sealed virtual Task`1<X509Certificate2> GetClientCertificateAsync(CancellationToken cancellationToken);
    private void InitializeFeatures();
    private static X509Certificate2 ConvertToX509Certificate2(X509Certificate certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionListener : object {
    private ILogger _log;
    private TlsConnectionCallbackOptions _tlsConnectionCallbackOptions;
    private QuicTransportContext _context;
    private QuicListenerOptions _quicListenerOptions;
    internal ConditionalWeakTable`2<QuicConnection, QuicConnectionContext> _pendingConnections;
    private bool _disposed;
    private QuicListener _listener;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    public EndPoint EndPoint { get; public set; }
    public QuicConnectionListener(QuicTransportOptions options, ILogger log, EndPoint endpoint, TlsConnectionCallbackOptions tlsConnectionCallbackOptions);
    private void ValidateServerAuthenticationOptions(SslServerAuthenticationOptions serverAuthenticationOptions);
    [CompilerGeneratedAttribute]
public sealed virtual EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public void set_EndPoint(EndPoint value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionListener/<CreateListenerAsync>d__13")]
public ValueTask CreateListenerAsync();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionListener/<AcceptAsync>d__14")]
public sealed virtual ValueTask`1<MultiplexedConnectionContext> AcceptAsync(IFeatureCollection features, CancellationToken cancellationToken);
    public sealed virtual ValueTask UnbindAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicConnectionListener/<DisposeAsync>d__16")]
public sealed virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicLog : object {
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __AcceptedConnectionCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, StreamType, Exception> __AcceptedStreamCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, StreamType, Exception> __ConnectedStreamCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __ConnectionErrorCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, long, Exception> __ConnectionAbortedCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`5<ILogger, string, long, string, Exception> __ConnectionAbortCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamErrorCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamPauseCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamResumeCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __StreamShutdownWriteCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, long, Exception> __StreamAbortedReadCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, long, Exception> __StreamAbortedWriteCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`5<ILogger, string, long, string, Exception> __StreamAbortCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`5<ILogger, string, long, string, Exception> __StreamAbortReadCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`5<ILogger, string, long, string, Exception> __StreamAbortWriteCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamPooledCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamReusedCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ConnectionListenerCertificateNotSpecifiedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ConnectionListenerApplicationProtocolsNotSpecifiedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, IPEndPoint, Exception> __ConnectionListenerStartingCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ConnectionListenerAbortedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamTimeoutReadCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __StreamTimeoutWriteCoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ConnectionListenerAcceptConnectionFailedCallback;
    private static QuicLog();
    [LoggerMessageAttribute("1", "1", "Connection id "{ConnectionId}" accepted.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void AcceptedConnectionCore(ILogger logger, string connectionId);
    public static void AcceptedConnection(ILogger logger, BaseConnectionContext connection);
    [LoggerMessageAttribute("2", "1", "Stream id "{ConnectionId}" type {StreamType} accepted.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void AcceptedStreamCore(ILogger logger, string connectionId, StreamType streamType);
    public static void AcceptedStream(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("3", "1", "Stream id "{ConnectionId}" type {StreamType} connected.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void ConnectedStreamCore(ILogger logger, string connectionId, StreamType streamType);
    public static void ConnectedStream(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("4", "1", "Connection id "{ConnectionId}" unexpected error.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void ConnectionErrorCore(ILogger logger, string connectionId, Exception ex);
    public static void ConnectionError(ILogger logger, BaseConnectionContext connection, Exception ex);
    [LoggerMessageAttribute("5", "1", "Connection id "{ConnectionId}" aborted by peer with error code {ErrorCode}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void ConnectionAbortedCore(ILogger logger, string connectionId, long errorCode, Exception ex);
    public static void ConnectionAborted(ILogger logger, BaseConnectionContext connection, long errorCode, Exception ex);
    [LoggerMessageAttribute("6", "1", "Connection id "{ConnectionId}" aborted by application with error code {ErrorCode} because: "{Reason}".")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void ConnectionAbortCore(ILogger logger, string connectionId, long errorCode, string reason);
    public static void ConnectionAbort(ILogger logger, BaseConnectionContext connection, long errorCode, string reason);
    [LoggerMessageAttribute("7", "1", "Stream id "{ConnectionId}" unexpected error.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamErrorCore(ILogger logger, string connectionId, Exception ex);
    public static void StreamError(ILogger logger, QuicStreamContext streamContext, Exception ex);
    [LoggerMessageAttribute("8", "1", "Stream id "{ConnectionId}" paused.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamPauseCore(ILogger logger, string connectionId);
    public static void StreamPause(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("9", "1", "Stream id "{ConnectionId}" resumed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamResumeCore(ILogger logger, string connectionId);
    public static void StreamResume(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("10", "1", "Stream id "{ConnectionId}" shutting down writes because: "{Reason}".")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamShutdownWriteCore(ILogger logger, string connectionId, string reason);
    public static void StreamShutdownWrite(ILogger logger, QuicStreamContext streamContext, string reason);
    [LoggerMessageAttribute("11", "1", "Stream id "{ConnectionId}" read aborted by peer with error code {ErrorCode}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamAbortedReadCore(ILogger logger, string connectionId, long errorCode);
    public static void StreamAbortedRead(ILogger logger, QuicStreamContext streamContext, long errorCode);
    [LoggerMessageAttribute("12", "1", "Stream id "{ConnectionId}" write aborted by peer with error code {ErrorCode}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamAbortedWriteCore(ILogger logger, string connectionId, long errorCode);
    public static void StreamAbortedWrite(ILogger logger, QuicStreamContext streamContext, long errorCode);
    [LoggerMessageAttribute("13", "1", "Stream id "{ConnectionId}" aborted by application with error code {ErrorCode} because: "{Reason}".")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamAbortCore(ILogger logger, string connectionId, long errorCode, string reason);
    public static void StreamAbort(ILogger logger, QuicStreamContext streamContext, long errorCode, string reason);
    [LoggerMessageAttribute("14", "1", "Stream id "{ConnectionId}" read side aborted by application with error code {ErrorCode} because: "{Reason}".")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamAbortReadCore(ILogger logger, string connectionId, long errorCode, string reason);
    public static void StreamAbortRead(ILogger logger, QuicStreamContext streamContext, long errorCode, string reason);
    [LoggerMessageAttribute("15", "1", "Stream id "{ConnectionId}" write side aborted by application with error code {ErrorCode} because: "{Reason}".")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamAbortWriteCore(ILogger logger, string connectionId, long errorCode, string reason);
    public static void StreamAbortWrite(ILogger logger, QuicStreamContext streamContext, long errorCode, string reason);
    [LoggerMessageAttribute("16", "0", "Stream id "{ConnectionId}" pooled for reuse.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamPooledCore(ILogger logger, string connectionId);
    public static void StreamPooled(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("17", "0", "Stream id "{ConnectionId}" reused from pool.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamReusedCore(ILogger logger, string connectionId);
    public static void StreamReused(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("18", "3", "SslServerAuthenticationOptions must provide a server certificate using ServerCertificate, ServerCertificateContext, or ServerCertificateSelectionCallback.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConnectionListenerCertificateNotSpecified(ILogger logger);
    [LoggerMessageAttribute("19", "3", "SslServerAuthenticationOptions must provide at least one application protocol using ApplicationProtocols.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConnectionListenerApplicationProtocolsNotSpecified(ILogger logger);
    [LoggerMessageAttribute("20", "1", "QUIC listener starting with configured endpoint {listenEndPoint}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConnectionListenerStarting(ILogger logger, IPEndPoint listenEndPoint);
    [LoggerMessageAttribute("21", "1", "QUIC listener aborted.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConnectionListenerAborted(ILogger logger, Exception exception);
    [LoggerMessageAttribute("22", "1", "Stream id "{ConnectionId}" read timed out.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamTimeoutReadCore(ILogger logger, string connectionId);
    public static void StreamTimeoutRead(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("23", "1", "Stream id "{ConnectionId}" write timed out.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void StreamTimeoutWriteCore(ILogger logger, string connectionId);
    public static void StreamTimeoutWrite(ILogger logger, QuicStreamContext streamContext);
    [LoggerMessageAttribute("24", "1", "QUIC listener connection failed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConnectionListenerAcceptConnectionFailed(ILogger logger, Exception exception);
    private static StreamType GetStreamType(QuicStreamContext streamContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext : TransportConnection {
    private static ConnectionAbortedException SendGracefullyCompletedException;
    internal Task _processingTask;
    private QuicStream _stream;
    private QuicConnectionContext _connection;
    private QuicTransportContext _context;
    private Pipe _inputPipe;
    private Pipe _outputPipe;
    private IDuplexPipe _originalTransport;
    private IDuplexPipe _originalApplication;
    private CompletionPipeReader _transportPipeReader;
    private CompletionPipeWriter _transportPipeWriter;
    private ILogger _log;
    private CancellationTokenSource _streamClosedTokenSource;
    private string _connectionId;
    private static int MinAllocBufferSize;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _shutdownReadReason;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _shutdownWriteReason;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _shutdownReason;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _writeAbortException;
    private bool _streamClosed;
    private bool _serverAborted;
    private bool _clientAbort;
    private object _shutdownLock;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PoolExpirationTimestamp>k__BackingField;
    private IDictionary`2<object, object> _persistentState;
    private Nullable`1<long> _error;
    private List`1<OnCloseRegistration> _onClosedRegistrations;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StreamId>k__BackingField;
    public MemoryPool`1<byte> MemoryPool { get; }
    private PipeWriter Input { get; }
    private PipeReader Output { get; }
    public bool CanReuse { get; private set; }
    public CancellationToken ConnectionClosed { get; public set; }
    public string ConnectionId { get; public set; }
    public long PoolExpirationTimestamp { get; public set; }
    public bool CanRead { get; private set; }
    public bool CanWrite { get; private set; }
    public long Error { get; public set; }
    public long StreamId { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.State { get; }
    public QuicStreamContext(QuicConnectionContext connection, QuicTransportContext context);
    private static QuicStreamContext();
    [CompilerGeneratedAttribute]
public virtual MemoryPool`1<byte> get_MemoryPool();
    private PipeWriter get_Input();
    private PipeReader get_Output();
    [CompilerGeneratedAttribute]
public bool get_CanReuse();
    [CompilerGeneratedAttribute]
private void set_CanReuse(bool value);
    public void Initialize(QuicStream stream);
    public virtual CancellationToken get_ConnectionClosed();
    public virtual void set_ConnectionClosed(CancellationToken value);
    public virtual string get_ConnectionId();
    public virtual void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_PoolExpirationTimestamp();
    [CompilerGeneratedAttribute]
public void set_PoolExpirationTimestamp(long value);
    public void Start();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<StartAsync>d__47")]
private Task StartAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<WaitForWritesClosedAsync>d__48")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder")]
private ValueTask WaitForWritesClosedAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<DoReceiveAsync>d__49")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder")]
private ValueTask DoReceiveAsync();
    private Exception ResolveCompleteReceiveException(Exception error);
    private void FireStreamClosed();
    private void CancelConnectionClosedToken();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<DoSendAsync>d__53")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder")]
private ValueTask DoSendAsync();
    public virtual void Abort(ConnectionAbortedException abortReason);
    private void ShutdownWrite(Exception shutdownReason);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<DisposeAsync>d__56")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder")]
public virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    public sealed virtual void DisposeCore();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
private void set_CanRead(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
private void set_CanWrite(bool value);
    public sealed virtual long get_Error();
    public sealed virtual void set_Error(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_StreamId();
    [CompilerGeneratedAttribute]
private void set_StreamId(long value);
    private sealed virtual override IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.get_State();
    public sealed virtual void AbortRead(long errorCode, ConnectionAbortedException abortReason);
    public sealed virtual void AbortWrite(long errorCode, ConnectionAbortedException abortReason);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IStreamClosedFeature.OnClosed(Action`1<object> callback, object state);
    private void InitializeFeatures();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicStreamContext/<<DoReceiveAsync>g__AwaitCompleteTaskAsync|49_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<FlushResult> <DoReceiveAsync>g__AwaitCompleteTaskAsync|49_0(ValueTask completeTask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.Internal.QuicTransportContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private QuicTransportOptions <Options>k__BackingField;
    public ILogger Log { get; }
    public QuicTransportOptions Options { get; }
    public QuicTransportContext(ILogger log, QuicTransportOptions options);
    [CompilerGeneratedAttribute]
public ILogger get_Log();
    [CompilerGeneratedAttribute]
public QuicTransportOptions get_Options();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.QuicTransportFactory : object {
    private ILogger _log;
    private QuicTransportOptions _options;
    [NullableContextAttribute("1")]
public QuicTransportFactory(ILoggerFactory loggerFactory, IOptions`1<QuicTransportOptions> options);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.QuicTransportFactory/<BindAsync>d__3")]
public sealed virtual ValueTask`1<IMultiplexedConnectionListener> BindAsync(EndPoint endpoint, IFeatureCollection features, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual bool CanBind(EndPoint endpoint);
}
public class Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.QuicTransportOptions : object {
    private long _defaultStreamErrorCode;
    private long _defaultCloseErrorCode;
    [CompilerGeneratedAttribute]
private int <MaxBidirectionalStreamCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxUnidirectionalStreamCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxReadBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxWriteBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Backlog>k__BackingField;
    [NullableAttribute("1")]
internal TimeProvider TimeProvider;
    [RequiresPreviewFeaturesAttribute]
public int MaxBidirectionalStreamCount { get; public set; }
    [RequiresPreviewFeaturesAttribute]
public int MaxUnidirectionalStreamCount { get; public set; }
    [RequiresPreviewFeaturesAttribute]
public Nullable`1<long> MaxReadBufferSize { get; public set; }
    [RequiresPreviewFeaturesAttribute]
public Nullable`1<long> MaxWriteBufferSize { get; public set; }
    public int Backlog { get; public set; }
    public long DefaultStreamErrorCode { get; public set; }
    public long DefaultCloseErrorCode { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxBidirectionalStreamCount();
    [CompilerGeneratedAttribute]
public void set_MaxBidirectionalStreamCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaxUnidirectionalStreamCount();
    [CompilerGeneratedAttribute]
public void set_MaxUnidirectionalStreamCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxReadBufferSize();
    [CompilerGeneratedAttribute]
public void set_MaxReadBufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxWriteBufferSize();
    [CompilerGeneratedAttribute]
public void set_MaxWriteBufferSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public int get_Backlog();
    [CompilerGeneratedAttribute]
public void set_Backlog(int value);
    public long get_DefaultStreamErrorCode();
    public void set_DefaultStreamErrorCode(long value);
    public long get_DefaultCloseErrorCode();
    public void set_DefaultCloseErrorCode(long value);
    private static void ValidateErrorCode(long errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.DiagnosticMemoryPool : MemoryPool`1<byte> {
    private MemoryPool`1<byte> _pool;
    private bool _allowLateReturn;
    private bool _rentTracking;
    private object _syncObj;
    private HashSet`1<DiagnosticPoolBlock> _blocks;
    private List`1<Exception> _blockAccessExceptions;
    private TaskCompletionSource _allBlocksReturned;
    private int _totalBlocks;
    private static int AnySize;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public int MaxBufferSize { get; }
    public DiagnosticMemoryPool(MemoryPool`1<byte> pool, bool allowLateReturn, bool rentTracking);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual IMemoryOwner`1<byte> Rent(int size);
    public virtual int get_MaxBufferSize();
    internal void Return(DiagnosticPoolBlock block);
    internal void ReportException(Exception exception);
    protected virtual void Dispose(bool disposing);
    private void SetAllBlocksReturned();
    private AggregateException CreateAccessExceptions();
    [AsyncStateMachineAttribute("System.Buffers.DiagnosticMemoryPool/<WhenAllBlocksReturnedAsync>d__22")]
public Task WhenAllBlocksReturnedAsync(TimeSpan timeout);
}
internal class System.Buffers.DiagnosticPoolBlock : MemoryManager`1<byte> {
    private DiagnosticMemoryPool _pool;
    private IMemoryOwner`1<byte> _memoryOwner;
    private Nullable`1<MemoryHandle> _memoryHandle;
    private Memory`1<byte> _memory;
    private object _syncObj;
    private bool _isDisposed;
    private int _pinCount;
    [CompilerGeneratedAttribute]
private StackTrace <Leaser>k__BackingField;
    public Memory`1<byte> Memory { get; }
    [NullableAttribute("2")]
public StackTrace Leaser { get; public set; }
    [NullableContextAttribute("1")]
internal DiagnosticPoolBlock(DiagnosticMemoryPool pool, IMemoryOwner`1<byte> memoryOwner);
    public virtual Memory`1<byte> get_Memory();
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<byte> GetSpan();
    public virtual MemoryHandle Pin(int byteOffset);
    protected virtual bool TryGetArray(ArraySegment`1& segment);
    public virtual void Unpin();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public StackTrace get_Leaser();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Leaser(StackTrace value);
    public void Track();
}
internal class System.Buffers.MemoryPoolBlock : object {
    [CompilerGeneratedAttribute]
private PinnedBlockMemoryPool <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <Memory>k__BackingField;
    [NullableAttribute("1")]
public PinnedBlockMemoryPool Pool { get; }
    public Memory`1<byte> Memory { get; }
    [NullableContextAttribute("1")]
internal MemoryPoolBlock(PinnedBlockMemoryPool pool, int length);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public PinnedBlockMemoryPool get_Pool();
    [CompilerGeneratedAttribute]
public sealed virtual Memory`1<byte> get_Memory();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.MemoryPoolThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(int sourceLength, int offset);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(int sourceLength, int offset);
    public static void ThrowInvalidOperationException_PinCountZero(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_ReturningPinnedBlock(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DoubleDispose();
    public static void ThrowInvalidOperationException_BlockDoubleDispose(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockReturnedToDisposedPool(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockIsBackedByDisposedSlab(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DisposingPoolWithActiveBlocks(int returned, int total, DiagnosticPoolBlock[] blocks);
    public static void ThrowInvalidOperationException_BlocksWereNotReturnedInTime(int returned, int total, DiagnosticPoolBlock[] blocks);
    private static string GenerateMessage(string message, DiagnosticPoolBlock[] blocks);
    public static void ThrowArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    public static void ThrowObjectDisposedException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    private static ObjectDisposedException GetObjectDisposedException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.PinnedBlockMemoryPool : MemoryPool`1<byte> {
    private static int _blockSize;
    [CompilerGeneratedAttribute]
private int <MaxBufferSize>k__BackingField;
    private ConcurrentQueue`1<MemoryPoolBlock> _blocks;
    private bool _isDisposed;
    private object _disposeSync;
    private static int AnySize;
    public int MaxBufferSize { get; }
    public static int BlockSize { get; }
    [CompilerGeneratedAttribute]
public virtual int get_MaxBufferSize();
    public static int get_BlockSize();
    public virtual IMemoryOwner`1<byte> Rent(int size);
    internal void Return(MemoryPoolBlock block);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Buffers.PinnedBlockMemoryPoolFactory : object {
    public static MemoryPool`1<byte> Create();
    public static MemoryPool`1<byte> CreatePinnedBlockMemoryPool();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.DuplexPipe : object {
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public DuplexPipe(PipeReader reader, PipeWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    public static DuplexPipePair CreateConnectionPair(PipeOptions inputOptions, PipeOptions outputOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
}
internal class UnmanagedBufferAllocator : ValueType {
    private int _blockSize;
    private int _currentBlockCount;
    private Void** _currentAlloc;
    private Byte* _currentBlock;
    public static int DefaultBlockSize { get; }
    public UnmanagedBufferAllocator(int blockSize);
    public static int get_DefaultBlockSize();
    public T* AllocAsPointer(int count);
    public Span`1<T> AllocAsSpan(int count);
    public Byte* GetHeaderEncodedBytes(string myString, Int32& length);
    public sealed virtual void Dispose();
    private Span`1<byte> GetSpan(int sizeHint, Boolean& mustCommit);
    private void Commit(int count);
    private Byte* Alloc(int size);
    private void NewBlock();
}
