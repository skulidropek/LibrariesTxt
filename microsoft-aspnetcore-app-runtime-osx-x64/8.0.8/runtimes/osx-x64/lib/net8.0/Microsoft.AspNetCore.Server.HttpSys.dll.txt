[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions : object {
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IWebHostBuilder UseHttpSys(IWebHostBuilder hostBuilder);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IWebHostBuilder UseHttpSys(IWebHostBuilder hostBuilder, Action`1<HttpSysOptions> options);
}
internal static class Microsoft.AspNetCore.Http.HttpCharacters : object {
    private static string AlphaNumeric;
    private static SearchValues`1<byte> _allowedAuthorityBytes;
    private static SearchValues`1<char> _allowedHostChars;
    private static SearchValues`1<char> _allowedTokenChars;
    private static SearchValues`1<byte> _allowedTokenBytes;
    private static SearchValues`1<char> _allowedFieldChars;
    private static SearchValues`1<char> _invalidFieldChars;
    private static HttpCharacters();
    public static bool ContainsInvalidAuthorityChar(ReadOnlySpan`1<byte> span);
    public static int IndexOfInvalidHostChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidTokenChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidTokenChar(ReadOnlySpan`1<byte> span);
    public static int IndexOfInvalidFieldValueChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidFieldValueCharExtended(ReadOnlySpan`1<char> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.HttpSys.Internal.Constants : object {
    internal static string HttpScheme;
    internal static string HttpsScheme;
    internal static string Chunked;
    internal static string Close;
    internal static string Zero;
    internal static string SchemeDelimiter;
    internal static string DefaultServerAddress;
    internal static Version V1_0;
    internal static Version V1_1;
    internal static Version V2;
    private static Constants();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.HttpSys.Internal.CookedUrl : ValueType {
    private HTTP_COOKED_URL _nativeCookedUrl;
    internal CookedUrl(HTTP_COOKED_URL nativeCookedUrl);
    internal string GetFullUrl();
    internal string GetHost();
    internal string GetAbsPath();
    internal string GetQueryString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.HttpSys.Internal.HeaderCollection/HeaderCollectionDebugView")]
internal class Microsoft.AspNetCore.HttpSys.Internal.HeaderCollection : object {
    internal static HashSet`1<string> DisallowedTrailers;
    private bool _checkTrailers;
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private IDictionary`2<string, StringValues> Store { get; private set; }
    public bool IsReadOnly { get; internal set; }
    public StringValues Item { get; public set; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<StringValues> Values { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public HeaderCollection(bool checkTrailers);
    public HeaderCollection(IDictionary`2<string, StringValues> store);
    private static HeaderCollection();
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, StringValues> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    public sealed virtual StringValues get_Item(string key);
    public sealed virtual void set_Item(string key, StringValues value);
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<StringValues> get_Values();
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual void set_ContentLength(Nullable`1<long> value);
    public sealed virtual void Add(KeyValuePair`2<string, StringValues> item);
    public sealed virtual void Add(string key, StringValues value);
    public void Append(string key, string value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumerator();
    public IEnumerable`1<string> GetValues(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    public static void ValidateHeaderCharacters(StringValues headerValues);
    public static void ValidateHeaderCharacters(string headerCharacters);
    private void ValidateRestrictedTrailers(string key);
    [CompilerGeneratedAttribute]
internal static void <ValidateHeaderCharacters>g__Throw|44_0(string headerCharacters, int invalidIndex);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderEncoding : object {
    internal static string GetString(Byte* pBytes, int byteCount, bool useLatin1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderParser : object {
    internal static IEnumerable`1<string> Empty;
    private static HeaderParser();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.HeaderParser/<SplitValues>d__1")]
internal static IEnumerable`1<string> SplitValues(StringValues values);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.HeapAllocHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static IntPtr ProcessHeap;
    private static HeapAllocHandle();
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HttpApiTypes : object {
    private static int HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH;
    internal static int SniPropertySizeInBytes;
    internal static int MaxTimeout;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] HttpVerbs;
    private static HttpApiTypes();
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysRequestHeader : Enum {
    public int value__;
    public static HttpSysRequestHeader CacheControl;
    public static HttpSysRequestHeader Connection;
    public static HttpSysRequestHeader Date;
    public static HttpSysRequestHeader KeepAlive;
    public static HttpSysRequestHeader Pragma;
    public static HttpSysRequestHeader Trailer;
    public static HttpSysRequestHeader TransferEncoding;
    public static HttpSysRequestHeader Upgrade;
    public static HttpSysRequestHeader Via;
    public static HttpSysRequestHeader Warning;
    public static HttpSysRequestHeader Allow;
    public static HttpSysRequestHeader ContentLength;
    public static HttpSysRequestHeader ContentType;
    public static HttpSysRequestHeader ContentEncoding;
    public static HttpSysRequestHeader ContentLanguage;
    public static HttpSysRequestHeader ContentLocation;
    public static HttpSysRequestHeader ContentMd5;
    public static HttpSysRequestHeader ContentRange;
    public static HttpSysRequestHeader Expires;
    public static HttpSysRequestHeader LastModified;
    public static HttpSysRequestHeader Accept;
    public static HttpSysRequestHeader AcceptCharset;
    public static HttpSysRequestHeader AcceptEncoding;
    public static HttpSysRequestHeader AcceptLanguage;
    public static HttpSysRequestHeader Authorization;
    public static HttpSysRequestHeader Cookie;
    public static HttpSysRequestHeader Expect;
    public static HttpSysRequestHeader From;
    public static HttpSysRequestHeader Host;
    public static HttpSysRequestHeader IfMatch;
    public static HttpSysRequestHeader IfModifiedSince;
    public static HttpSysRequestHeader IfNoneMatch;
    public static HttpSysRequestHeader IfRange;
    public static HttpSysRequestHeader IfUnmodifiedSince;
    public static HttpSysRequestHeader MaxForwards;
    public static HttpSysRequestHeader ProxyAuthorization;
    public static HttpSysRequestHeader Referer;
    public static HttpSysRequestHeader Range;
    public static HttpSysRequestHeader Te;
    public static HttpSysRequestHeader Translate;
    public static HttpSysRequestHeader UserAgent;
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysResponseHeader : Enum {
    public int value__;
    public static HttpSysResponseHeader CacheControl;
    public static HttpSysResponseHeader Connection;
    public static HttpSysResponseHeader Date;
    public static HttpSysResponseHeader KeepAlive;
    public static HttpSysResponseHeader Pragma;
    public static HttpSysResponseHeader Trailer;
    public static HttpSysResponseHeader TransferEncoding;
    public static HttpSysResponseHeader Upgrade;
    public static HttpSysResponseHeader Via;
    public static HttpSysResponseHeader Warning;
    public static HttpSysResponseHeader Allow;
    public static HttpSysResponseHeader ContentLength;
    public static HttpSysResponseHeader ContentType;
    public static HttpSysResponseHeader ContentEncoding;
    public static HttpSysResponseHeader ContentLanguage;
    public static HttpSysResponseHeader ContentLocation;
    public static HttpSysResponseHeader ContentMd5;
    public static HttpSysResponseHeader ContentRange;
    public static HttpSysResponseHeader Expires;
    public static HttpSysResponseHeader LastModified;
    public static HttpSysResponseHeader AcceptRanges;
    public static HttpSysResponseHeader Age;
    public static HttpSysResponseHeader ETag;
    public static HttpSysResponseHeader Location;
    public static HttpSysResponseHeader ProxyAuthenticate;
    public static HttpSysResponseHeader RetryAfter;
    public static HttpSysResponseHeader Server;
    public static HttpSysResponseHeader SetCookie;
    public static HttpSysResponseHeader Vary;
    public static HttpSysResponseHeader WwwAuthenticate;
}
internal class Microsoft.AspNetCore.HttpSys.Internal.NativeRequestContext : object {
    private static int AlignmentPadding;
    private static int DefaultBufferSize;
    private IntPtr _originalBufferAddress;
    private bool _useLatin1;
    private HTTP_REQUEST* _nativeRequest;
    private IMemoryOwner`1<byte> _backingBuffer;
    private MemoryHandle _memoryHandle;
    private int _bufferAlignment;
    private bool _permanentlyPinned;
    private bool _disposed;
    private IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> _requestInfo;
    [MemberNotNullWhenAttribute("False", "_backingBuffer")]
private bool PermanentlyPinned { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> RequestInfo { get; }
    public ReadOnlySpan`1<long> Timestamps { get; }
    internal HTTP_REQUEST* NativeRequest { get; }
    internal HTTP_REQUEST_V2* NativeRequestV2 { get; }
    internal ulong RequestId { get; internal set; }
    internal ulong ConnectionId { get; }
    internal ulong RawConnectionId { get; }
    internal HTTP_VERB VerbId { get; }
    internal ulong UrlContext { get; }
    internal ushort UnknownHeaderCount { get; }
    internal SslStatus SslStatus { get; }
    internal bool IsHttp2 { get; }
    internal bool IsHttp3 { get; }
    internal UInt32 Size { get; }
    [NullableContextAttribute("1")]
internal NativeRequestContext(MemoryPool`1<byte> memoryPool, Nullable`1<UInt32> bufferSize, ulong requestId, bool useLatin1);
    internal NativeRequestContext(HTTP_REQUEST* request, bool useLatin1);
    [MemberNotNullWhenAttribute("False", "_backingBuffer")]
private bool get_PermanentlyPinned();
    public sealed virtual IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> get_RequestInfo();
    public sealed virtual ReadOnlySpan`1<long> get_Timestamps();
    internal HTTP_REQUEST* get_NativeRequest();
    internal HTTP_REQUEST_V2* get_NativeRequestV2();
    internal ulong get_RequestId();
    internal void set_RequestId(ulong value);
    internal ulong get_ConnectionId();
    internal ulong get_RawConnectionId();
    internal HTTP_VERB get_VerbId();
    internal ulong get_UrlContext();
    internal ushort get_UnknownHeaderCount();
    internal SslStatus get_SslStatus();
    internal bool get_IsHttp2();
    internal bool get_IsHttp3();
    internal UInt32 get_Size();
    internal void ReleasePins();
    public sealed virtual bool TryGetTimestamp(HttpSysRequestTimingType timestampType, Int64& timestamp);
    public sealed virtual bool TryGetElapsedTime(HttpSysRequestTimingType startingTimestampType, HttpSysRequestTimingType endingTimestampType, TimeSpan& elapsed);
    public virtual void Dispose();
    [NullableContextAttribute("2")]
internal string GetVerb();
    [NullableContextAttribute("2")]
internal string GetRawUrl();
    internal Span`1<byte> GetRawUrlInBytes();
    internal CookedUrl GetCookedUrl();
    [NullableContextAttribute("1")]
internal Version GetVersion();
    internal bool CheckAuthenticated();
    [NullableContextAttribute("1")]
internal WindowsPrincipal GetUser();
    internal HTTP_SSL_PROTOCOL_INFO GetTlsHandshake();
    private static void SetSslProtocol(HTTP_SSL_PROTOCOL_INFO* protocolInfo);
    private static string GetAuthTypeFromRequest(HTTP_REQUEST_AUTH_TYPE input);
    internal bool HasKnownHeader(HttpSysRequestHeader header);
    private bool HasKnowHeaderHelper(HttpSysRequestHeader header, long fixup, HTTP_REQUEST* request);
    [NullableContextAttribute("2")]
internal string GetKnownHeader(HttpSysRequestHeader header);
    private string GetKnowHeaderHelper(HttpSysRequestHeader header, long fixup, HTTP_REQUEST* request);
    internal void GetUnknownKeys(Span`1<string> destination);
    private void PopulateUnknownKeys(HTTP_REQUEST* request, long fixup, Span`1<string> destination);
    internal int CountUnknownHeaders();
    private int CountUnknownHeaders(HTTP_REQUEST* request, long fixup);
    [NullableContextAttribute("1")]
internal void GetUnknownHeaders(IDictionary`2<string, StringValues> unknownHeaders);
    private void GetUnknownHeadersHelper(IDictionary`2<string, StringValues> unknownHeaders, long fixup, HTTP_REQUEST* request);
    [NullableContextAttribute("2")]
internal SocketAddress GetRemoteEndPoint();
    [NullableContextAttribute("2")]
internal SocketAddress GetLocalEndPoint();
    private SocketAddress GetEndPoint(bool localEndpoint);
    private SocketAddress GetEndPointHelper(bool localEndpoint, HTTP_REQUEST* request, Byte* pMemoryBlob);
    private static SocketAddress CopyOutAddress(IntPtr address);
    [NullableContextAttribute("1")]
internal UInt32 GetChunks(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size);
    private UInt32 GetChunksHelper(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size, long fixup, HTTP_REQUEST* request);
    internal IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> GetRequestInfo();
    private IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> GetRequestInfo(IntPtr baseAddress, HTTP_REQUEST_V2* nativeRequest);
    [NullableContextAttribute("2")]
internal X509Certificate2 GetClientCertificate();
    private X509Certificate2 GetClientCertificate(IntPtr baseAddress, HTTP_REQUEST_V2* nativeRequest);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.NclUtilities : object {
    internal static bool HasShutdownStarted { get; }
    internal static bool get_HasShutdownStarted();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.PathNormalizer : object {
    private static byte ByteSlash;
    private static byte ByteDot;
    public static int RemoveDotSegments(Span`1<byte> input);
    public static int RemoveDotSegments(Byte* start, Byte* end);
    public static bool ContainsDotSegments(Byte* start, Byte* end);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RawUrlHelper : object {
    public static Span`1<byte> GetPath(Span`1<byte> raw);
    private static int FindHttpOrHttps(Span`1<byte> raw);
    private static int Find(Span`1<byte> raw, int begin, byte target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/RequestHeadersDebugView")]
[GeneratedCodeAttribute("TextTemplatingFileGenerator", "")]
internal class Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders : object {
    private IDictionary`2<string, StringValues> _extra;
    private NativeRequestContext _requestMemoryBlob;
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private UInt32 _flag0;
    private UInt32 _flag1;
    private StringValues _Accept;
    private StringValues _AcceptCharset;
    private StringValues _AcceptEncoding;
    private StringValues _AcceptLanguage;
    private StringValues _Allow;
    private StringValues _Authorization;
    private StringValues _CacheControl;
    private StringValues _Connection;
    private StringValues _ContentEncoding;
    private StringValues _ContentLanguage;
    private StringValues _ContentLength;
    private StringValues _ContentLocation;
    private StringValues _ContentMD5;
    private StringValues _ContentRange;
    private StringValues _ContentType;
    private StringValues _Cookie;
    private StringValues _Date;
    private StringValues _Expect;
    private StringValues _Expires;
    private StringValues _From;
    private StringValues _Host;
    private StringValues _IfMatch;
    private StringValues _IfModifiedSince;
    private StringValues _IfNoneMatch;
    private StringValues _IfRange;
    private StringValues _IfUnmodifiedSince;
    private StringValues _KeepAlive;
    private StringValues _LastModified;
    private StringValues _MaxForwards;
    private StringValues _Pragma;
    private StringValues _ProxyAuthorization;
    private StringValues _Range;
    private StringValues _Referer;
    private StringValues _TE;
    private StringValues _Trailer;
    private StringValues _TransferEncoding;
    private StringValues _Translate;
    private StringValues _Upgrade;
    private StringValues _UserAgent;
    private StringValues _Via;
    private StringValues _Warning;
    public bool IsReadOnly { get; internal set; }
    private IDictionary`2<string, StringValues> Extra { get; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public ICollection`1<string> Keys { get; }
    private ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLength { get; private set; }
    public StringValues Item { get; public set; }
    public StringValues Accept { get; public set; }
    public StringValues AcceptCharset { get; public set; }
    public StringValues AcceptEncoding { get; public set; }
    public StringValues AcceptLanguage { get; public set; }
    public StringValues Allow { get; public set; }
    public StringValues Authorization { get; public set; }
    public StringValues CacheControl { get; public set; }
    public StringValues Connection { get; public set; }
    public StringValues ContentEncoding { get; public set; }
    public StringValues ContentLanguage { get; public set; }
    public StringValues ContentLength { get; public set; }
    public StringValues ContentLocation { get; public set; }
    public StringValues ContentMD5 { get; public set; }
    public StringValues ContentRange { get; public set; }
    public StringValues ContentType { get; public set; }
    public StringValues Cookie { get; public set; }
    public StringValues Date { get; public set; }
    public StringValues Expect { get; public set; }
    public StringValues Expires { get; public set; }
    public StringValues From { get; public set; }
    public StringValues Host { get; public set; }
    public StringValues IfMatch { get; public set; }
    public StringValues IfModifiedSince { get; public set; }
    public StringValues IfNoneMatch { get; public set; }
    public StringValues IfRange { get; public set; }
    public StringValues IfUnmodifiedSince { get; public set; }
    public StringValues KeepAlive { get; public set; }
    public StringValues LastModified { get; public set; }
    public StringValues MaxForwards { get; public set; }
    public StringValues Pragma { get; public set; }
    public StringValues ProxyAuthorization { get; public set; }
    public StringValues Range { get; public set; }
    public StringValues Referer { get; public set; }
    public StringValues TE { get; public set; }
    public StringValues Trailer { get; public set; }
    public StringValues TransferEncoding { get; public set; }
    public StringValues Translate { get; public set; }
    public StringValues Upgrade { get; public set; }
    public StringValues UserAgent { get; public set; }
    public StringValues Via { get; public set; }
    public StringValues Warning { get; public set; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> HeaderKeys { get; }
    internal RequestHeaders(NativeRequestContext requestMemoryBlob);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    private IDictionary`2<string, StringValues> get_Extra();
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    private string GetKnownHeader(HttpSysRequestHeader header);
    private void GetUnknownHeaders(IDictionary`2<string, StringValues> extra);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Add(string key, StringValues value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    internal void ResetFlags();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Add(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Contains(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLength();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLength(Nullable`1<long> value);
    public sealed virtual StringValues get_Item(string key);
    public sealed virtual void set_Item(string key, StringValues value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Remove(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, StringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    private static void ThrowDuplicateKeyException();
    public IEnumerable`1<string> GetValues(string key);
    private int GetKnownHeadersKeys(Span`1<string> observedHeaders);
    private int GetKnownHeadersCount();
    public sealed virtual StringValues get_Accept();
    public sealed virtual void set_Accept(StringValues value);
    public sealed virtual StringValues get_AcceptCharset();
    public sealed virtual void set_AcceptCharset(StringValues value);
    public sealed virtual StringValues get_AcceptEncoding();
    public sealed virtual void set_AcceptEncoding(StringValues value);
    public sealed virtual StringValues get_AcceptLanguage();
    public sealed virtual void set_AcceptLanguage(StringValues value);
    public sealed virtual StringValues get_Allow();
    public sealed virtual void set_Allow(StringValues value);
    public sealed virtual StringValues get_Authorization();
    public sealed virtual void set_Authorization(StringValues value);
    public sealed virtual StringValues get_CacheControl();
    public sealed virtual void set_CacheControl(StringValues value);
    public sealed virtual StringValues get_Connection();
    public sealed virtual void set_Connection(StringValues value);
    public sealed virtual StringValues get_ContentEncoding();
    public sealed virtual void set_ContentEncoding(StringValues value);
    public sealed virtual StringValues get_ContentLanguage();
    public sealed virtual void set_ContentLanguage(StringValues value);
    public StringValues get_ContentLength();
    public void set_ContentLength(StringValues value);
    public sealed virtual StringValues get_ContentLocation();
    public sealed virtual void set_ContentLocation(StringValues value);
    public sealed virtual StringValues get_ContentMD5();
    public sealed virtual void set_ContentMD5(StringValues value);
    public sealed virtual StringValues get_ContentRange();
    public sealed virtual void set_ContentRange(StringValues value);
    public sealed virtual StringValues get_ContentType();
    public sealed virtual void set_ContentType(StringValues value);
    public sealed virtual StringValues get_Cookie();
    public sealed virtual void set_Cookie(StringValues value);
    public sealed virtual StringValues get_Date();
    public sealed virtual void set_Date(StringValues value);
    public sealed virtual StringValues get_Expect();
    public sealed virtual void set_Expect(StringValues value);
    public sealed virtual StringValues get_Expires();
    public sealed virtual void set_Expires(StringValues value);
    public sealed virtual StringValues get_From();
    public sealed virtual void set_From(StringValues value);
    public sealed virtual StringValues get_Host();
    public sealed virtual void set_Host(StringValues value);
    public sealed virtual StringValues get_IfMatch();
    public sealed virtual void set_IfMatch(StringValues value);
    public sealed virtual StringValues get_IfModifiedSince();
    public sealed virtual void set_IfModifiedSince(StringValues value);
    public sealed virtual StringValues get_IfNoneMatch();
    public sealed virtual void set_IfNoneMatch(StringValues value);
    public sealed virtual StringValues get_IfRange();
    public sealed virtual void set_IfRange(StringValues value);
    public sealed virtual StringValues get_IfUnmodifiedSince();
    public sealed virtual void set_IfUnmodifiedSince(StringValues value);
    public sealed virtual StringValues get_KeepAlive();
    public sealed virtual void set_KeepAlive(StringValues value);
    public sealed virtual StringValues get_LastModified();
    public sealed virtual void set_LastModified(StringValues value);
    public sealed virtual StringValues get_MaxForwards();
    public sealed virtual void set_MaxForwards(StringValues value);
    public sealed virtual StringValues get_Pragma();
    public sealed virtual void set_Pragma(StringValues value);
    public sealed virtual StringValues get_ProxyAuthorization();
    public sealed virtual void set_ProxyAuthorization(StringValues value);
    public sealed virtual StringValues get_Range();
    public sealed virtual void set_Range(StringValues value);
    public sealed virtual StringValues get_Referer();
    public sealed virtual void set_Referer(StringValues value);
    public sealed virtual StringValues get_TE();
    public sealed virtual void set_TE(StringValues value);
    public sealed virtual StringValues get_Trailer();
    public sealed virtual void set_Trailer(StringValues value);
    public sealed virtual StringValues get_TransferEncoding();
    public sealed virtual void set_TransferEncoding(StringValues value);
    public sealed virtual StringValues get_Translate();
    public sealed virtual void set_Translate(StringValues value);
    public sealed virtual StringValues get_Upgrade();
    public sealed virtual void set_Upgrade(StringValues value);
    public sealed virtual StringValues get_UserAgent();
    public sealed virtual void set_UserAgent(StringValues value);
    public sealed virtual StringValues get_Via();
    public sealed virtual void set_Via(StringValues value);
    public sealed virtual StringValues get_Warning();
    public sealed virtual void set_Warning(StringValues value);
    private bool PropertiesContainsKey(string key);
    private bool PropertiesTryGetValue(string key, StringValues& value);
    private bool PropertiesTrySetValue(string key, StringValues value);
    private bool PropertiesTryRemove(string key);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesKeys>d__218")]
private IEnumerable`1<string> PropertiesKeys();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesValues>d__219")]
private IEnumerable`1<StringValues> PropertiesValues();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesEnumerable>d__220")]
private IEnumerable`1<KeyValuePair`2<string, StringValues>> PropertiesEnumerable();
    private static ReadOnlySpan`1<byte> get_HeaderKeys();
    private string GetHeaderKeyName(HttpSysRequestHeader header);
    private bool HasKnownHeader(HttpSysRequestHeader header);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RequestUriBuilder : object {
    private static Encoding UTF8;
    private static RequestUriBuilder();
    public static string DecodeAndUnescapePath(Span`1<byte> rawUrlBytes);
    private static Span`1<byte> Unescape(Span`1<byte> rawPath);
    private static bool DecodeCore(Int32& reader, Int32& writer, int end, Span`1<byte> buffer);
    private static void Copy(int begin, int end, Int32& writer, Span`1<byte> buffer);
    private static Nullable`1<int> UnescapePercentEncoding(Int32& scan, int end, ReadOnlySpan`1<byte> buffer);
    private static Nullable`1<int> ReadHex(Int32& scan, int end, ReadOnlySpan`1<byte> buffer);
    private static bool SkipUnescape(int value1, int value2);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalFreeChannelBinding : ChannelBinding {
    private static int LMEM_FIXED;
    private int size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    [NullableContextAttribute("1")]
public static SafeLocalFreeChannelBinding LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalMemHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLocalMemHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeNativeOverlapped : SafeHandle {
    [NullableAttribute("1")]
internal static SafeNativeOverlapped Zero;
    private ThreadPoolBoundHandle _boundHandle;
    public bool IsInvalid { get; }
    internal SafeNativeOverlapped(ThreadPoolBoundHandle boundHandle, NativeOverlapped* handle);
    private static SafeNativeOverlapped();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.HttpSys.Internal.SocketAddress : object {
    private static int NumberOfIPv6Labels;
    private static string IPv6NumberFormat;
    private static char IPv6StringSeparator;
    private static string IPv4StringFormat;
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    private static int WriteableOffset;
    private int _size;
    private Byte[] _buffer;
    private int _hash;
    internal Byte[] Buffer { get; }
    internal AddressFamily Family { get; }
    internal int Size { get; }
    private byte Item { get; }
    public SocketAddress(AddressFamily family, int size);
    internal Byte[] get_Buffer();
    internal AddressFamily get_Family();
    internal int get_Size();
    private byte get_Item(int offset);
    internal int GetPort();
    [NullableContextAttribute("2")]
public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
internal IPAddress GetIPAddress();
    private IPAddress GetIpv6Address();
    private IPAddress GetIPv4Address();
    public virtual string ToString();
    [NullableContextAttribute("2")]
internal string GetIPAddressString();
    private string GetIPv4AddressString();
    private string GetIpv6AddressString();
    private static string GetIPv6AddressString(UInt16* numbers);
    private static KeyValuePair`2<int, int> FindCompressionRange(UInt16* numbers);
    private static bool ShouldHaveIpv4Embedded(UInt16* numbers);
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.SslStatus : Enum {
    public byte value__;
    public static SslStatus Insecure;
    public static SslStatus NoClientCert;
    public static SslStatus ClientCert;
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.UnsafeNclNativeMethods : object {
    private static string sspicli_LIB;
    private static string api_ms_win_core_io_LIB;
    private static string api_ms_win_core_handle_LIB;
    private static string api_ms_win_core_heap_LIB;
    private static string api_ms_win_core_heap_obsolete_LIB;
    private static string api_ms_win_core_kernel32_legacy_LIB;
    private static string TOKENBINDING;
    [NullableContextAttribute("1")]
[LibraryImportAttribute("api-ms-win-core-io-l1-1-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 CancelIoEx(SafeHandle handle, SafeNativeOverlapped overlapped);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("api-ms-win-core-kernel32-legacy-l1-1-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static bool SetFileCompletionNotificationModes(SafeHandle handle, FileCompletionNotificationModes modes);
    [LibraryImportAttribute("tokenbinding.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
public static int TokenBindingVerifyMessage(Byte* tokenBindingMessage, UInt32 tokenBindingMessageSize, Char* keyType, Byte* tlsUnique, UInt32 tlsUniqueSize, HeapAllocHandle& resultList);
    [LibraryImportAttribute("api-ms-win-core-heap-L1-2-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static IntPtr GetProcessHeap();
    [LibraryImportAttribute("api-ms-win-core-heap-L1-2-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
    [CompilerGeneratedAttribute]
internal static UInt32 <CancelIoEx>g____PInvoke|8_0(IntPtr __handle_native, IntPtr __overlapped_native);
    [CompilerGeneratedAttribute]
internal static int <SetFileCompletionNotificationModes>g____PInvoke|9_0(IntPtr __handle_native, FileCompletionNotificationModes __modes_native);
    [CompilerGeneratedAttribute]
internal static int <TokenBindingVerifyMessage>g____PInvoke|11_0(Byte* __tokenBindingMessage_native, UInt32 __tokenBindingMessageSize_native, Char* __keyType_native, Byte* __tlsUnique_native, UInt32 __tlsUniqueSize_native, IntPtr* __resultList_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <GetProcessHeap>g____PInvoke|12_0();
    [CompilerGeneratedAttribute]
internal static int <HeapFree>g____PInvoke|13_0(IntPtr __hHeap_native, UInt32 __dwFlags_native, IntPtr __lpMem_native);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.ApplicationRequestContextFactory`1 : object {
    private IHttpApplication`1<TContext> _application;
    private MessagePump _messagePump;
    public ApplicationRequestContextFactory`1(IHttpApplication`1<TContext> application, MessagePump messagePump);
    public sealed virtual RequestContext CreateRequestContext(Nullable`1<UInt32> bufferSize, ulong requestId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.AsyncAcceptContext : object {
    private static IOCompletionCallback IOCallback;
    private PreAllocatedOverlapped _preallocatedOverlapped;
    private IRequestContextFactory _requestContextFactory;
    private ILogger _logger;
    private int _expectedCompletionCount;
    private NativeOverlapped* _overlapped;
    private bool _logExpectationFailures;
    private ManualResetValueTaskSourceCore`1<RequestContext> _mrvts;
    private RequestContext _requestContext;
    [CompilerGeneratedAttribute]
private HttpSysListener <Server>k__BackingField;
    internal HttpSysListener Server { get; }
    internal AsyncAcceptContext(HttpSysListener server, IRequestContextFactory requestContextFactory, ILogger logger);
    private static AsyncAcceptContext();
    [CompilerGeneratedAttribute]
internal HttpSysListener get_Server();
    internal ValueTask`1<RequestContext> AcceptAsync();
    private void IOCompleted(UInt32 errorCode, UInt32 numBytes, bool managed);
    private static void IOWaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    private void SetExpectCompletion();
    private void CancelExpectCompletion();
    private void ObserveCompletion(bool managed);
    private UInt32 QueueBeginGetContext();
    private void AllocateNativeRequest(Nullable`1<UInt32> size, ulong requestId);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual RequestContext GetResult(short token);
    public sealed virtual ValueTaskSourceStatus GetStatus(short token);
    [NullableContextAttribute("2")]
public sealed virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.AuthenticationHandler : object {
    private RequestContext _requestContext;
    private AuthenticationScheme _scheme;
    public sealed virtual Task`1<AuthenticateResult> AuthenticateAsync();
    public sealed virtual Task ChallengeAsync(AuthenticationProperties properties);
    public sealed virtual Task ForbidAsync(AuthenticationProperties properties);
    public sealed virtual Task InitializeAsync(AuthenticationScheme scheme, HttpContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager : object {
    private static int AuthInfoSize;
    private UrlGroup _urlGroup;
    private AuthenticationSchemes _authSchemes;
    private bool _allowAnonymous;
    [CompilerGeneratedAttribute]
private bool <AutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationDisplayName>k__BackingField;
    public AuthenticationSchemes Schemes { get; public set; }
    public bool AllowAnonymous { get; public set; }
    public bool AutomaticAuthentication { get; public set; }
    [NullableAttribute("2")]
public string AuthenticationDisplayName { get; public set; }
    private static AuthenticationManager();
    public AuthenticationSchemes get_Schemes();
    public void set_Schemes(AuthenticationSchemes value);
    public bool get_AllowAnonymous();
    public void set_AllowAnonymous(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutomaticAuthentication();
    [CompilerGeneratedAttribute]
public void set_AutomaticAuthentication(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_AuthenticationDisplayName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_AuthenticationDisplayName(string value);
    internal void SetUrlGroupSecurity(UrlGroup urlGroup);
    private void SetUrlGroupSecurity();
    internal static IList`1<string> GenerateChallenges(AuthenticationSchemes authSchemes);
    internal static void SetAuthenticationChallenge(RequestContext context);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes NTLM;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes Kerberos;
}
internal enum Microsoft.AspNetCore.Server.HttpSys.BoundaryType : Enum {
    public int value__;
    public static BoundaryType None;
    public static BoundaryType Chunked;
    public static BoundaryType ContentLength;
    public static BoundaryType Close;
    public static BoundaryType PassThrough;
    public static BoundaryType Invalid;
}
public enum Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod : Enum {
    public int value__;
    public static ClientCertificateMethod NoCertificate;
    public static ClientCertificateMethod AllowCertificate;
    public static ClientCertificateMethod AllowRenegotation;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.ClientCertLoader : object {
    private static UInt32 CertBoblSize;
    private static IOCompletionCallback IOCallback;
    private static int RequestChannelBindStatusSize;
    private SafeNativeOverlapped _overlapped;
    private Byte[] _backingBuffer;
    private HTTP_SSL_CLIENT_CERT_INFO* _memoryBlob;
    private UInt32 _size;
    private TaskCompletionSource`1<object> _tcs;
    private RequestContext _requestContext;
    private int _clientCertError;
    private X509Certificate2 _clientCert;
    private Exception _clientCertException;
    private CancellationTokenRegistration _cancellationRegistration;
    internal SafeHandle RequestQueueHandle { get; }
    [NullableAttribute("2")]
internal X509Certificate2 ClientCert { get; }
    internal int ClientCertError { get; }
    [NullableAttribute("2")]
internal Exception ClientCertException { get; }
    private RequestContext RequestContext { get; }
    private Task Task { get; }
    [NullableAttribute("2")]
private SafeNativeOverlapped NativeOverlapped { get; }
    [NullableAttribute("0")]
private HTTP_SSL_CLIENT_CERT_INFO* RequestBlob { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal ClientCertLoader(RequestContext requestContext, CancellationToken cancellationToken);
    private static ClientCertLoader();
    internal SafeHandle get_RequestQueueHandle();
    [NullableContextAttribute("2")]
internal X509Certificate2 get_ClientCert();
    internal int get_ClientCertError();
    [NullableContextAttribute("2")]
internal Exception get_ClientCertException();
    private RequestContext get_RequestContext();
    private Task get_Task();
    private SafeNativeOverlapped get_NativeOverlapped();
    private HTTP_SSL_CLIENT_CERT_INFO* get_RequestBlob();
    private void Reset(UInt32 size);
    internal Task LoadClientCertificateAsync();
    private void Complete(int certErrors, X509Certificate2 cert);
    private void Fail(Exception ex);
    private void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(ClientCertLoader asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal static ChannelBinding GetChannelBindingFromTls(RequestQueue requestQueue, ulong connectionId, ILogger logger);
    private static int GetTokenOffsetFromBlob(IntPtr blob);
    private static int GetTokenSizeFromBlob(IntPtr blob);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.ComNetOS : object {
    internal static bool IsWin8orLater;
    private static ComNetOS();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.HttpSys.DelegationRule : object {
    private ILogger _logger;
    private UrlGroup _sourceQueueUrlGroup;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestQueue <Queue>k__BackingField;
    public string QueueName { get; }
    public string UrlPrefix { get; }
    internal RequestQueue Queue { get; }
    internal DelegationRule(UrlGroup sourceQueueUrlGroup, string queueName, string urlPrefix, ILogger logger);
    [CompilerGeneratedAttribute]
public string get_QueueName();
    [CompilerGeneratedAttribute]
public string get_UrlPrefix();
    [CompilerGeneratedAttribute]
internal RequestQueue get_Queue();
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.HttpSys.DisconnectListener : object {
    private ConcurrentDictionary`2<ulong, ConnectionCancellation> _connectionCancellationTokens;
    private RequestQueue _requestQueue;
    private ILogger _logger;
    [NullableContextAttribute("1")]
internal DisconnectListener(RequestQueue requestQueue, ILogger logger);
    internal CancellationToken GetTokenForConnection(ulong connectionId);
    private CancellationToken GetOrCreateDisconnectToken(ulong connectionId);
    private ConnectionCancellation GetCreatedConnectionCancellation(ulong connectionId);
    private CancellationToken CreateDisconnectToken(ulong connectionId);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.Helpers : object {
    public static ReadOnlySpan`1<byte> ChunkTerminator { get; }
    public static ReadOnlySpan`1<byte> CRLF { get; }
    public static ReadOnlySpan`1<byte> get_ChunkTerminator();
    public static ReadOnlySpan`1<byte> get_CRLF();
    internal static ArraySegment`1<byte> GetChunkHeader(long size);
    internal static ArraySegment`1<byte> GetChunkHeader(int size);
}
public enum Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel : Enum {
    public long value__;
    public static Http503VerbosityLevel Basic;
    public static Http503VerbosityLevel Limited;
    public static Http503VerbosityLevel Full;
}
internal static class Microsoft.AspNetCore.Server.HttpSys.HttpApi : object {
    private static string HTTPAPI;
    private static HTTPAPI_VERSION version;
    [CompilerGeneratedAttribute]
private static SafeLibraryHandle <HttpApiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private static HttpGetRequestPropertyInvoker <HttpGetRequestProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private static HttpSetRequestPropertyInvoker <HttpSetRequestProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsTrailers>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsReset>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsDelegation>k__BackingField;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) supported;
    internal static HTTPAPI_VERSION Version { get; }
    internal static HTTP_API_VERSION ApiVersion { get; }
    [NullableAttribute("2")]
internal static SafeLibraryHandle HttpApiModule { get; private set; }
    [NullableAttribute("2")]
internal static HttpGetRequestPropertyInvoker HttpGetRequestProperty { get; private set; }
    [NullableAttribute("2")]
internal static HttpSetRequestPropertyInvoker HttpSetRequestProperty { get; private set; }
    [MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
internal static bool SupportsTrailers { get; private set; }
    [MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
internal static bool SupportsReset { get; private set; }
    internal static bool SupportsDelegation { get; private set; }
    internal static bool Supported { get; }
    private static HttpApi();
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpInitialize(HTTPAPI_VERSION version, UInt32 flags, Void* pReserved);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpReceiveRequestEntityBody(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, IntPtr pEntityBuffer, UInt32 entityBufferLength, UInt32& bytesReturned, SafeNativeOverlapped pOverlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpReceiveClientCertificate(SafeHandle requestQueueHandle, ulong connectionId, UInt32 flags, HTTP_SSL_CLIENT_CERT_INFO* pSslClientCertInfo, UInt32 sslClientCertInfoSize, UInt32* pBytesReceived, SafeNativeOverlapped pOverlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpReceiveClientCertificate(SafeHandle requestQueueHandle, ulong connectionId, UInt32 flags, Byte* pSslClientCertInfo, UInt32 sslClientCertInfoSize, UInt32* pBytesReceived, SafeNativeOverlapped pOverlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpReceiveHttpRequest(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, HTTP_REQUEST* pRequestBuffer, UInt32 requestBufferLength, UInt32* pBytesReturned, NativeOverlapped* pOverlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpSendHttpResponse(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, HTTP_RESPONSE_V2* pHttpResponse, HTTP_CACHE_POLICY* pCachePolicy, UInt32* pBytesSent, IntPtr pReserved1, UInt32 Reserved2, SafeNativeOverlapped pOverlapped, IntPtr pLogData);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpSendResponseEntityBody(SafeHandle requestQueueHandle, ulong requestId, UInt32 flags, ushort entityChunkCount, HTTP_DATA_CHUNK* pEntityChunks, UInt32* pBytesSent, IntPtr pReserved1, UInt32 Reserved2, SafeNativeOverlapped pOverlapped, IntPtr pLogData);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCancelHttpRequest(SafeHandle requestQueueHandle, ulong requestId, IntPtr pOverlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpWaitForDisconnectEx(SafeHandle requestQueueHandle, ulong connectionId, UInt32 reserved, NativeOverlapped* overlapped);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCreateServerSession(HTTPAPI_VERSION version, UInt64* serverSessionId, UInt32 reserved);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCreateUrlGroup(ulong serverSessionId, UInt64* urlGroupId, UInt32 reserved);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpFindUrlGroupId(string pFullyQualifiedUrl, SafeHandle requestQueueHandle, UInt64* urlGroupId);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpAddUrlToUrlGroup(ulong urlGroupId, string pFullyQualifiedUrl, ulong context, UInt32 pReserved);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpSetUrlGroupProperty(ulong urlGroupId, HTTP_SERVER_PROPERTY serverProperty, IntPtr pPropertyInfo, UInt32 propertyInfoLength);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpRemoveUrlFromUrlGroup(ulong urlGroupId, string pFullyQualifiedUrl, UInt32 flags);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCloseServerSession(ulong serverSessionId);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCloseUrlGroup(ulong urlGroupId);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpSetRequestQueueProperty(SafeHandle requestQueueHandle, HTTP_SERVER_PROPERTY serverProperty, IntPtr pPropertyInfo, UInt32 propertyInfoLength, UInt32 reserved, IntPtr pReserved);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCreateRequestQueue(HTTPAPI_VERSION version, string pName, IntPtr pSecurityAttributes, HTTP_CREATE_REQUEST_QUEUE_FLAG flags, HttpRequestQueueV2Handle& pReqQueueHandle);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpCloseRequestQueue(IntPtr pReqQueueHandle);
    [LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static bool HttpIsFeatureSupported(HTTP_FEATURE_ID feature);
    [NullableContextAttribute("1")]
[LibraryImportAttribute("httpapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal static UInt32 HttpDelegateRequestEx(SafeHandle pReqQueueHandle, SafeHandle pDelegateQueueHandle, ulong requestId, ulong delegateUrlGroupId, UInt32 propertyInfoSetSize, HTTP_DELEGATE_REQUEST_PROPERTY_INFO* pRequestPropertyBuffer);
    internal static HTTPAPI_VERSION get_Version();
    internal static HTTP_API_VERSION get_ApiVersion();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SafeLibraryHandle get_HttpApiModule();
    [CompilerGeneratedAttribute]
private static void set_HttpApiModule(SafeLibraryHandle value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static HttpGetRequestPropertyInvoker get_HttpGetRequestProperty();
    [CompilerGeneratedAttribute]
private static void set_HttpGetRequestProperty(HttpGetRequestPropertyInvoker value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static HttpSetRequestPropertyInvoker get_HttpSetRequestProperty();
    [CompilerGeneratedAttribute]
private static void set_HttpSetRequestProperty(HttpSetRequestPropertyInvoker value);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
internal static bool get_SupportsTrailers();
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
private static void set_SupportsTrailers(bool value);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
internal static bool get_SupportsReset();
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "HttpSetRequestProperty")]
private static void set_SupportsReset(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_SupportsDelegation();
    [CompilerGeneratedAttribute]
private static void set_SupportsDelegation(bool value);
    private static void InitHttpApi(ushort majorVersion, ushort minorVersion);
    internal static bool get_Supported();
    private static bool IsFeatureSupported(HTTP_FEATURE_ID feature);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpInitialize>g____PInvoke|1_0(HTTPAPI_VERSION __version_native, UInt32 __flags_native, Void* __pReserved_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpReceiveRequestEntityBody>g____PInvoke|2_0(IntPtr __requestQueueHandle_native, ulong __requestId_native, UInt32 __flags_native, IntPtr __pEntityBuffer_native, UInt32 __entityBufferLength_native, UInt32* __bytesReturned_native, IntPtr __pOverlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpReceiveClientCertificate>g____PInvoke|3_0(IntPtr __requestQueueHandle_native, ulong __connectionId_native, UInt32 __flags_native, HTTP_SSL_CLIENT_CERT_INFO* __pSslClientCertInfo_native, UInt32 __sslClientCertInfoSize_native, UInt32* __pBytesReceived_native, IntPtr __pOverlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpReceiveClientCertificate>g____PInvoke|4_0(IntPtr __requestQueueHandle_native, ulong __connectionId_native, UInt32 __flags_native, Byte* __pSslClientCertInfo_native, UInt32 __sslClientCertInfoSize_native, UInt32* __pBytesReceived_native, IntPtr __pOverlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpReceiveHttpRequest>g____PInvoke|5_0(IntPtr __requestQueueHandle_native, ulong __requestId_native, UInt32 __flags_native, HTTP_REQUEST* __pRequestBuffer_native, UInt32 __requestBufferLength_native, UInt32* __pBytesReturned_native, NativeOverlapped* __pOverlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpSendHttpResponse>g____PInvoke|6_0(IntPtr __requestQueueHandle_native, ulong __requestId_native, UInt32 __flags_native, HTTP_RESPONSE_V2* __pHttpResponse_native, HTTP_CACHE_POLICY* __pCachePolicy_native, UInt32* __pBytesSent_native, IntPtr __pReserved1_native, UInt32 __Reserved2_native, IntPtr __pOverlapped_native, IntPtr __pLogData_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpSendResponseEntityBody>g____PInvoke|7_0(IntPtr __requestQueueHandle_native, ulong __requestId_native, UInt32 __flags_native, ushort __entityChunkCount_native, HTTP_DATA_CHUNK* __pEntityChunks_native, UInt32* __pBytesSent_native, IntPtr __pReserved1_native, UInt32 __Reserved2_native, IntPtr __pOverlapped_native, IntPtr __pLogData_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCancelHttpRequest>g____PInvoke|8_0(IntPtr __requestQueueHandle_native, ulong __requestId_native, IntPtr __pOverlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpWaitForDisconnectEx>g____PInvoke|9_0(IntPtr __requestQueueHandle_native, ulong __connectionId_native, UInt32 __reserved_native, NativeOverlapped* __overlapped_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCreateServerSession>g____PInvoke|10_0(HTTPAPI_VERSION __version_native, UInt64* __serverSessionId_native, UInt32 __reserved_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCreateUrlGroup>g____PInvoke|11_0(ulong __serverSessionId_native, UInt64* __urlGroupId_native, UInt32 __reserved_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpFindUrlGroupId>g____PInvoke|12_0(UInt16* __pFullyQualifiedUrl_native, IntPtr __requestQueueHandle_native, UInt64* __urlGroupId_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpAddUrlToUrlGroup>g____PInvoke|13_0(ulong __urlGroupId_native, UInt16* __pFullyQualifiedUrl_native, ulong __context_native, UInt32 __pReserved_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpSetUrlGroupProperty>g____PInvoke|14_0(ulong __urlGroupId_native, HTTP_SERVER_PROPERTY __serverProperty_native, IntPtr __pPropertyInfo_native, UInt32 __propertyInfoLength_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpRemoveUrlFromUrlGroup>g____PInvoke|15_0(ulong __urlGroupId_native, UInt16* __pFullyQualifiedUrl_native, UInt32 __flags_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCloseServerSession>g____PInvoke|16_0(ulong __serverSessionId_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCloseUrlGroup>g____PInvoke|17_0(ulong __urlGroupId_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpSetRequestQueueProperty>g____PInvoke|18_0(IntPtr __requestQueueHandle_native, HTTP_SERVER_PROPERTY __serverProperty_native, IntPtr __pPropertyInfo_native, UInt32 __propertyInfoLength_native, UInt32 __reserved_native, IntPtr __pReserved_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCreateRequestQueue>g____PInvoke|19_0(HTTPAPI_VERSION __version_native, UInt16* __pName_native, IntPtr __pSecurityAttributes_native, HTTP_CREATE_REQUEST_QUEUE_FLAG __flags_native, IntPtr* __pReqQueueHandle_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpCloseRequestQueue>g____PInvoke|20_0(IntPtr __pReqQueueHandle_native);
    [CompilerGeneratedAttribute]
internal static int <HttpIsFeatureSupported>g____PInvoke|21_0(HTTP_FEATURE_ID __feature_native);
    [CompilerGeneratedAttribute]
internal static UInt32 <HttpDelegateRequestEx>g____PInvoke|22_0(IntPtr __pReqQueueHandle_native, IntPtr __pDelegateQueueHandle_native, ulong __requestId_native, ulong __delegateUrlGroupId_native, UInt32 __propertyInfoSetSize_native, HTTP_DELEGATE_REQUEST_PROPERTY_INFO* __pRequestPropertyBuffer_native);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.HttpReasonPhrase : object {
    private static String[][] HttpReasonPhrases;
    private static HttpReasonPhrase();
    [NullableContextAttribute("2")]
internal static string Get(int code);
}
internal class Microsoft.AspNetCore.Server.HttpSys.HttpRequestQueueV2Handle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.Server.HttpSys.HttpServerSessionHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    private int disposed;
    private ulong serverSessionId;
    internal HttpServerSessionHandle(ulong id);
    internal ulong DangerousGetServerSessionId();
    protected virtual bool ReleaseHandle();
}
public static class Microsoft.AspNetCore.Server.HttpSys.HttpSysDefaults : object {
    [NullableAttribute("1")]
public static string AuthenticationScheme;
}
public class Microsoft.AspNetCore.Server.HttpSys.HttpSysException : Win32Exception {
    public int ErrorCode { get; }
    internal HttpSysException(int errorCode);
    [NullableContextAttribute("1")]
internal HttpSysException(int errorCode, string message);
    public virtual int get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.HttpSysListener : object {
    internal static bool SkipIOCPCallbackOnSuccess;
    private static int UnknownHeaderLimit;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private ServerSession _serverSession;
    private UrlGroup _urlGroup;
    private RequestQueue _requestQueue;
    private DisconnectListener _disconnectListener;
    private object _internalLock;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSysOptions <Options>k__BackingField;
    internal MemoryPool`1<byte> MemoryPool { get; }
    internal ILogger Logger { get; private set; }
    internal UrlGroup UrlGroup { get; }
    internal RequestQueue RequestQueue { get; }
    internal DisconnectListener DisconnectListener { get; }
    public HttpSysOptions Options { get; }
    public bool IsListening { get; }
    public HttpSysListener(HttpSysOptions options, ILoggerFactory loggerFactory);
    private static HttpSysListener();
    [CompilerGeneratedAttribute]
internal MemoryPool`1<byte> get_MemoryPool();
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    internal UrlGroup get_UrlGroup();
    internal RequestQueue get_RequestQueue();
    internal DisconnectListener get_DisconnectListener();
    [CompilerGeneratedAttribute]
public HttpSysOptions get_Options();
    public bool get_IsListening();
    public void Start();
    private void Stop();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void DisposeInternal();
    internal ValueTask`1<RequestContext> AcceptAsync(AsyncAcceptContext acceptContext);
    internal bool ValidateRequest(NativeRequestContext requestMemory);
    internal void SendError(ulong requestId, int httpStatusCode, IList`1<string> authChallenges);
    private void CheckDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions : object {
    private static UInt32 MaximumRequestQueueNameLength;
    private static Http503VerbosityLevel DefaultRejectionVerbosityLevel;
    private static long DefaultRequestQueueLength;
    internal static int DefaultMaxAccepts;
    private static long DefaultMaxRequestBodySize;
    private Http503VerbosityLevel _rejectionVebosityLevel;
    private long _requestQueueLength;
    private Nullable`1<long> _maxConnections;
    private RequestQueue _requestQueue;
    private UrlGroup _urlGroup;
    private Nullable`1<long> _maxRequestBodySize;
    private string _requestQueueName;
    [CompilerGeneratedAttribute]
private RequestQueueMode <RequestQueueMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientCertificateMethod <ClientCertificateMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAccepts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableResponseCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlPrefixCollection <UrlPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationManager <Authentication>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeoutManager <Timeouts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowWriteExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableKernelResponseBuffering>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnsafePreferInlineScheduling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLatin1RequestHeaders>k__BackingField;
    [NullableAttribute("2")]
public string RequestQueueName { get; public set; }
    public RequestQueueMode RequestQueueMode { get; public set; }
    public ClientCertificateMethod ClientCertificateMethod { get; public set; }
    public int MaxAccepts { get; public set; }
    public bool EnableResponseCaching { get; public set; }
    public UrlPrefixCollection UrlPrefixes { get; }
    public AuthenticationManager Authentication { get; }
    public TimeoutManager Timeouts { get; }
    public bool ThrowWriteExceptions { get; public set; }
    public bool EnableKernelResponseBuffering { get; public set; }
    public Nullable`1<long> MaxConnections { get; public set; }
    public long RequestQueueLimit { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    public Http503VerbosityLevel Http503Verbosity { get; public set; }
    public bool UnsafePreferInlineScheduling { get; public set; }
    public bool UseLatin1RequestHeaders { get; public set; }
    private static HttpSysOptions();
    [NullableContextAttribute("2")]
public string get_RequestQueueName();
    [NullableContextAttribute("2")]
public void set_RequestQueueName(string value);
    [CompilerGeneratedAttribute]
public RequestQueueMode get_RequestQueueMode();
    [CompilerGeneratedAttribute]
public void set_RequestQueueMode(RequestQueueMode value);
    [CompilerGeneratedAttribute]
public ClientCertificateMethod get_ClientCertificateMethod();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMethod(ClientCertificateMethod value);
    [CompilerGeneratedAttribute]
public int get_MaxAccepts();
    [CompilerGeneratedAttribute]
public void set_MaxAccepts(int value);
    [CompilerGeneratedAttribute]
public bool get_EnableResponseCaching();
    [CompilerGeneratedAttribute]
public void set_EnableResponseCaching(bool value);
    [CompilerGeneratedAttribute]
public UrlPrefixCollection get_UrlPrefixes();
    [CompilerGeneratedAttribute]
public AuthenticationManager get_Authentication();
    [CompilerGeneratedAttribute]
public TimeoutManager get_Timeouts();
    [CompilerGeneratedAttribute]
public bool get_ThrowWriteExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowWriteExceptions(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableKernelResponseBuffering();
    [CompilerGeneratedAttribute]
public void set_EnableKernelResponseBuffering(bool value);
    public Nullable`1<long> get_MaxConnections();
    public void set_MaxConnections(Nullable`1<long> value);
    public long get_RequestQueueLimit();
    public void set_RequestQueueLimit(long value);
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    public Http503VerbosityLevel get_Http503Verbosity();
    public void set_Http503Verbosity(Http503VerbosityLevel value);
    [CompilerGeneratedAttribute]
public bool get_UnsafePreferInlineScheduling();
    [CompilerGeneratedAttribute]
public void set_UnsafePreferInlineScheduling(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseLatin1RequestHeaders();
    [CompilerGeneratedAttribute]
public void set_UseLatin1RequestHeaders(bool value);
    internal void Apply(UrlGroup urlGroup, RequestQueue requestQueue);
}
public enum Microsoft.AspNetCore.Server.HttpSys.HttpSysRequestTimingType : Enum {
    public int value__;
    public static HttpSysRequestTimingType ConnectionStart;
    public static HttpSysRequestTimingType DataStart;
    public static HttpSysRequestTimingType TlsCertificateLoadStart;
    public static HttpSysRequestTimingType TlsCertificateLoadEnd;
    public static HttpSysRequestTimingType TlsHandshakeLeg1Start;
    public static HttpSysRequestTimingType TlsHandshakeLeg1End;
    public static HttpSysRequestTimingType TlsHandshakeLeg2Start;
    public static HttpSysRequestTimingType TlsHandshakeLeg2End;
    public static HttpSysRequestTimingType TlsAttributesQueryStart;
    public static HttpSysRequestTimingType TlsAttributesQueryEnd;
    public static HttpSysRequestTimingType TlsClientCertQueryStart;
    public static HttpSysRequestTimingType TlsClientCertQueryEnd;
    public static HttpSysRequestTimingType Http2StreamStart;
    public static HttpSysRequestTimingType Http2HeaderDecodeStart;
    public static HttpSysRequestTimingType Http2HeaderDecodeEnd;
    public static HttpSysRequestTimingType RequestHeaderParseStart;
    public static HttpSysRequestTimingType RequestHeaderParseEnd;
    public static HttpSysRequestTimingType RequestRoutingStart;
    public static HttpSysRequestTimingType RequestRoutingEnd;
    public static HttpSysRequestTimingType RequestQueuedForInspection;
    public static HttpSysRequestTimingType RequestDeliveredForInspection;
    public static HttpSysRequestTimingType RequestReturnedAfterInspection;
    public static HttpSysRequestTimingType RequestQueuedForDelegation;
    public static HttpSysRequestTimingType RequestDeliveredForDelegation;
    public static HttpSysRequestTimingType RequestReturnedAfterDelegation;
    public static HttpSysRequestTimingType RequestQueuedForIO;
    public static HttpSysRequestTimingType RequestDeliveredForIO;
    public static HttpSysRequestTimingType Http3StreamStart;
    public static HttpSysRequestTimingType Http3HeaderDecodeStart;
    public static HttpSysRequestTimingType Http3HeaderDecodeEnd;
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestDelegationFeature {
    public bool CanDelegate { get; }
    public abstract virtual bool get_CanDelegate();
    public abstract virtual void DelegateRequest(DelegationRule destination);
}
public interface Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> RequestInfo { get; }
    public abstract virtual IReadOnlyDictionary`2<int, ReadOnlyMemory`1<byte>> get_RequestInfo();
}
public interface Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestTimingFeature {
    public ReadOnlySpan`1<long> Timestamps { get; }
    public abstract virtual ReadOnlySpan`1<long> get_Timestamps();
    public abstract virtual bool TryGetTimestamp(HttpSysRequestTimingType timestampType, Int64& timestamp);
    public abstract virtual bool TryGetElapsedTime(HttpSysRequestTimingType startingTimestampType, HttpSysRequestTimingType endingTimestampType, TimeSpan& elapsed);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
    internal static long Subtract(IntPtr a, IntPtr b);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.HttpSys.IRequestContextFactory {
    public abstract virtual RequestContext CreateRequestContext(Nullable`1<UInt32> bufferSize, ulong requestId);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Server.HttpSys.IServerDelegationFeature {
    public abstract virtual DelegationRule CreateDelegationRule(string queueName, string urlPrefix);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.LoggerEventIds : object {
    public static int HttpSysListenerCtorError;
    public static int BindingToDefault;
    public static int ClearedPrefixes;
    public static int AcceptErrorStopping;
    public static int AcceptError;
    public static int RequestProcessError;
    public static int RequestsDrained;
    public static int StopCancelled;
    public static int WaitingForRequestsToDrain;
    public static int DisconnectRegistrationError;
    public static int RegisterDisconnectListener;
    public static int UnknownDisconnectError;
    public static int DisconnectHandlerError;
    public static int ListenerStarting;
    public static int ListenerDisposeError;
    public static int RequestListenerProcessError;
    public static int AttachedToQueue;
    public static int SetUrlPropertyError;
    public static int RegisteringPrefix;
    public static int UnregisteringPrefix;
    public static int CloseUrlGroupError;
    public static int ChannelBindingUnsupported;
    public static int ChannelBindingMissing;
    public static int RequestError;
    public static int ErrorInReadingCertificate;
    public static int ChannelBindingNeedsHttps;
    public static int ChannelBindingRetrieved;
    public static int AbortError;
    public static int ErrorWhileRead;
    public static int ErrorWhenReadBegun;
    public static int ErrorWhenReadAsync;
    public static int ErrorWhenFlushAsync;
    public static int FewerBytesThanExpected;
    public static int WriteError;
    public static int WriteErrorIgnored;
    public static int WriteFlushCancelled;
    public static int ClearedAddresses;
    public static int FileSendAsyncError;
    public static int FileSendAsyncCancelled;
    public static int FileSendAsyncErrorIgnored;
    public static int WriteCancelled;
    public static int ListenerStopping;
    public static int ListenerStartError;
    public static int DisconnectTriggered;
    public static int ListenerStopError;
    public static int ListenerDisposing;
    public static int RequestValidationFailed;
    public static int CreateDisconnectTokenError;
    public static int RequestAborted;
    public static int AcceptSetResultFailed;
    public static int AcceptSetExpectationMismatch;
    public static int AcceptCancelExpectationMismatch;
    public static int AcceptObserveExpectationMismatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.MessagePump : object {
    private ILogger _logger;
    private HttpSysOptions _options;
    private int _maxAccepts;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _stopping;
    private int _outstandingRequests;
    private TaskCompletionSource _shutdownSignal;
    private int _shutdownSignalCompleted;
    private ServerAddressesFeature _serverAddresses;
    [CompilerGeneratedAttribute]
private HttpSysListener <Listener>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestContextFactory <RequestContextFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    internal HttpSysListener Listener { get; }
    [NullableAttribute("2")]
internal IRequestContextFactory RequestContextFactory { get; internal set; }
    public IFeatureCollection Features { get; }
    internal bool Stopping { get; }
    public MessagePump(IOptions`1<HttpSysOptions> options, ILoggerFactory loggerFactory, IAuthenticationSchemeProvider authentication);
    [CompilerGeneratedAttribute]
internal HttpSysListener get_Listener();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IRequestContextFactory get_RequestContextFactory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_RequestContextFactory(IRequestContextFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual IFeatureCollection get_Features();
    internal bool get_Stopping();
    public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    private void ActivateRequestProcessingLimits();
    private void UpdateUrlPrefixes(IList`1<string> serverAddressCopy);
    internal int IncrementOutstandingRequest();
    internal int DecrementOutstandingRequest();
    internal void SetShutdownSignal();
    private void ProcessRequestsWorker();
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual DelegationRule CreateDelegationRule(string queueName, string uri);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.OpaqueStream : Stream {
    private Stream _requestStream;
    private Stream _responseStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal OpaqueStream(Stream requestStream, Stream responseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.Request : object {
    private X509Certificate2 _clientCert;
    private BoundaryType _contentBoundaryType;
    private Nullable`1<long> _contentLength;
    private RequestStream _nativeStream;
    private SocketAddress _localEndPoint;
    private SocketAddress _remoteEndPoint;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private ulong <UConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RawConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private SslStatus <SslStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HTTP_VERB <KnownMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SniHostName>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithmType <CipherAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CipherStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmType <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private ExchangeAlgorithmType <KeyExchangeAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeStrength>k__BackingField;
    internal ulong UConnectionId { get; }
    internal ulong RawConnectionId { get; }
    public long ConnectionId { get; }
    internal ulong RequestId { get; }
    private SslStatus SslStatus { get; }
    private RequestContext RequestContext { get; }
    public string QueryString { get; }
    public Nullable`1<long> ContentLength { get; }
    public RequestHeaders Headers { get; }
    internal HTTP_VERB KnownMethod { get; }
    internal bool IsHeadMethod { get; }
    public string Method { get; }
    public Stream Body { get; }
    public bool HasRequestBodyStarted { get; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public string PathBase { get; }
    public string Path { get; }
    public bool IsHttps { get; }
    public string RawUrl { get; }
    public Version ProtocolVersion { get; }
    public bool HasEntityBody { get; }
    private SocketAddress RemoteEndPoint { get; }
    private SocketAddress LocalEndPoint { get; }
    [NullableAttribute("2")]
public IPAddress RemoteIpAddress { get; }
    [NullableAttribute("2")]
public IPAddress LocalIpAddress { get; }
    public int RemotePort { get; }
    public int LocalPort { get; }
    public string Scheme { get; }
    internal bool IsUpgradable { get; }
    internal WindowsPrincipal User { get; }
    public string SniHostName { get; private set; }
    public SslProtocols Protocol { get; private set; }
    public CipherAlgorithmType CipherAlgorithm { get; private set; }
    public int CipherStrength { get; private set; }
    public HashAlgorithmType HashAlgorithm { get; private set; }
    public int HashStrength { get; private set; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; private set; }
    public int KeyExchangeStrength { get; private set; }
    [NullableAttribute("2")]
public X509Certificate2 ClientCertificate { get; }
    public bool CanDelegate { get; }
    internal Request(RequestContext requestContext);
    [CompilerGeneratedAttribute]
internal ulong get_UConnectionId();
    [CompilerGeneratedAttribute]
internal ulong get_RawConnectionId();
    public long get_ConnectionId();
    [CompilerGeneratedAttribute]
internal ulong get_RequestId();
    [CompilerGeneratedAttribute]
private SslStatus get_SslStatus();
    [CompilerGeneratedAttribute]
private RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public string get_QueryString();
    public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public RequestHeaders get_Headers();
    [CompilerGeneratedAttribute]
internal HTTP_VERB get_KnownMethod();
    internal bool get_IsHeadMethod();
    [CompilerGeneratedAttribute]
public string get_Method();
    public Stream get_Body();
    private RequestStream EnsureRequestStream();
    public bool get_HasRequestBodyStarted();
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
public string get_Path();
    public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public string get_RawUrl();
    [CompilerGeneratedAttribute]
public Version get_ProtocolVersion();
    public bool get_HasEntityBody();
    private SocketAddress get_RemoteEndPoint();
    private SocketAddress get_LocalEndPoint();
    [NullableContextAttribute("2")]
public IPAddress get_RemoteIpAddress();
    [NullableContextAttribute("2")]
public IPAddress get_LocalIpAddress();
    public int get_RemotePort();
    public int get_LocalPort();
    public string get_Scheme();
    internal bool get_IsUpgradable();
    [CompilerGeneratedAttribute]
internal WindowsPrincipal get_User();
    [CompilerGeneratedAttribute]
public string get_SniHostName();
    [CompilerGeneratedAttribute]
private void set_SniHostName(string value);
    [CompilerGeneratedAttribute]
public SslProtocols get_Protocol();
    [CompilerGeneratedAttribute]
private void set_Protocol(SslProtocols value);
    [CompilerGeneratedAttribute]
public CipherAlgorithmType get_CipherAlgorithm();
    [CompilerGeneratedAttribute]
private void set_CipherAlgorithm(CipherAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_CipherStrength();
    [CompilerGeneratedAttribute]
private void set_CipherStrength(int value);
    [CompilerGeneratedAttribute]
public HashAlgorithmType get_HashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithm(HashAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_HashStrength();
    [CompilerGeneratedAttribute]
private void set_HashStrength(int value);
    [CompilerGeneratedAttribute]
public ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeAlgorithm(ExchangeAlgorithmType value);
    [CompilerGeneratedAttribute]
public int get_KeyExchangeStrength();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeStrength(int value);
    private void GetTlsHandshakeResults();
    [NullableContextAttribute("2")]
public X509Certificate2 get_ClientCertificate();
    public bool get_CanDelegate();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.Request/<GetClientCertificateAsync>d__121")]
public Task`1<X509Certificate2> GetClientCertificateAsync(CancellationToken cancellationToken);
    internal UInt32 GetChunks(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size);
    internal void Dispose();
    internal void SwitchToOpaqueMode();
    private void RemoveContentLengthIfTransferEncodingContainsChunked();
    private static bool IsChunked(string transferEncoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.RequestContext : NativeRequestContext {
    private static Action`1<object> AbortDelegate;
    private CancellationTokenSource _requestAbortSource;
    private Nullable`1<CancellationToken> _disconnectToken;
    private bool _disposed;
    private bool _initialized;
    [CompilerGeneratedAttribute]
private HttpSysListener <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private Request <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Response <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    private IFeatureCollection _features;
    private bool _enableResponseCaching;
    private Stream _requestBody;
    private IHeaderDictionary _requestHeaders;
    private string _scheme;
    private string _httpMethod;
    private string _httpProtocolVersion;
    private string _query;
    private string _pathBase;
    private string _path;
    private string _rawTarget;
    private IPAddress _remoteIpAddress;
    private IPAddress _localIpAddress;
    private int _remotePort;
    private int _localPort;
    private string _connectionId;
    private string _traceIdentitfier;
    private X509Certificate2 _clientCert;
    private Task`1<X509Certificate2> _clientCertTask;
    private ClaimsPrincipal _user;
    private Stream _responseStream;
    private PipeWriter _pipeWriter;
    private bool _bodyCompleted;
    private IHeaderDictionary _responseHeaders;
    private IHeaderDictionary _responseTrailers;
    private Fields _initializedFields;
    private List`1<Tuple`2<Func`2<object, Task>, object>> _onStartingActions;
    private List`1<Tuple`2<Func`2<object, Task>, object>> _onCompletedActions;
    private bool _responseStarted;
    private bool _completed;
    [CompilerGeneratedAttribute]
private CancellationToken <Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.ConnectionClosedRequested>k__BackingField;
    internal HttpSysListener Server { get; }
    internal ILogger Logger { get; }
    public Request Request { get; private set; }
    public Response Response { get; private set; }
    public WindowsPrincipal User { get; }
    public CancellationToken DisconnectToken { get; }
    public Guid TraceIdentifier { get; }
    public bool IsUpgradableRequest { get; }
    internal bool AllowSynchronousIO { get; internal set; }
    internal IFeatureCollection Features { get; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Body { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Headers { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Method { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Path { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.PathBase { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Protocol { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.QueryString { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.RawTarget { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Scheme { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature.CanHaveBody { get; }
    [NullableAttribute("2")]
private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress { get; private set; }
    [NullableAttribute("2")]
private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId { get; private set; }
    [NullableAttribute("2")]
private X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.ClientCertificate { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Body { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Stream { get; }
    private PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Writer { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Headers { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.HasStarted { get; }
    [NullableAttribute("2")]
private string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.ReasonPhrase { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.StatusCode { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.RequestAborted { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.IsUpgradableRequest { get; }
    [NullableAttribute("2")]
private ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.User { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.TraceIdentifier { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.MaxRequestBodySize { get; private set; }
    private SslProtocols Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.Protocol { get; }
    private CipherAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.CipherStrength { get; }
    private HashAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HashStrength { get; }
    private ExchangeAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeAlgorithm { get; }
    private int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.KeyExchangeStrength { get; }
    private string Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.HostName { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.Trailers { get; private set; }
    public bool CanDelegate { get; }
    private CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.ConnectionClosedRequested { get; private set; }
    public RequestContext(HttpSysListener server, Nullable`1<UInt32> bufferSize, ulong requestId);
    private static RequestContext();
    [CompilerGeneratedAttribute]
internal HttpSysListener get_Server();
    internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Request get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(Request value);
    [CompilerGeneratedAttribute]
public Response get_Response();
    [CompilerGeneratedAttribute]
private void set_Response(Response value);
    public WindowsPrincipal get_User();
    public CancellationToken get_DisconnectToken();
    public Guid get_TraceIdentifier();
    public bool get_IsUpgradableRequest();
    [CompilerGeneratedAttribute]
internal bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
internal void set_AllowSynchronousIO(bool value);
    public Task`1<Stream> UpgradeAsync();
    [NullableContextAttribute("2")]
internal bool TryGetChannelBinding(ChannelBinding& value);
    public virtual void Dispose();
    public void Abort();
    private static void Abort(object state);
    internal CancellationTokenRegistration RegisterForCancellation(CancellationToken cancellationToken);
    internal void ForceCancelRequest();
    internal HTTP_REQUEST_PROPERTY_SNI GetClientSni();
    internal void SetResetCode(int errorCode);
    public virtual Task ExecuteAsync();
    public sealed virtual void Execute();
    protected void SetFatalResponse(int status);
    internal void Delegate(DelegationRule destination);
    internal IFeatureCollection get_Features();
    protected internal void InitializeFeatures();
    private bool IsNotInitialized(Fields field);
    private void SetInitialized(Fields field);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Body(Stream value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Method();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Method(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Path();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Path(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_PathBase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_PathBase(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Protocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Protocol(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_QueryString();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_QueryString(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_RawTarget();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_RawTarget(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Scheme();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Scheme(string value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature.get_CanHaveBody();
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalIpAddress(IPAddress value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemoteIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemoteIpAddress(IPAddress value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalPort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalPort(int value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemotePort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemotePort(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_ConnectionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_ConnectionId(string value);
    private sealed virtual override X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.get_ClientCertificate();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.set_ClientCertificate(X509Certificate2 value);
    private sealed virtual override Task`1<X509Certificate2> Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.GetClientCertificateAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal ITlsConnectionFeature GetTlsConnectionFeature();
    [NullableContextAttribute("2")]
internal ITlsHandshakeFeature GetTlsHandshakeFeature();
    [NullableContextAttribute("2")]
internal IHttpResponseTrailersFeature GetResponseTrailersFeature();
    [NullableContextAttribute("2")]
internal IHttpResetFeature GetResetFeature();
    [NullableContextAttribute("2")]
internal IConnectionLifetimeNotificationFeature GetConnectionLifetimeNotificationFeature();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.DisableBuffering();
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Body(Stream value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Stream();
    private sealed virtual override PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Writer();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_HasStarted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnStarting(Func`2<object, Task> callback, object state);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnCompleted(Func`2<object, Task> callback, object state);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_ReasonPhrase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_ReasonPhrase(string value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_StatusCode();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_StatusCode(int value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<Microsoft-AspNetCore-Http-Features-IHttpResponseBodyFeature-SendFileAsync>d__154")]
private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.SendFileAsync(string path, long offset, Nullable`1<long> length, CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.StartAsync(CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.CompleteAsync();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResetFeature.Reset(int errorCode);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<CompleteAsync>d__158")]
internal Task CompleteAsync();
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.get_RequestAborted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.set_RequestAborted(CancellationToken value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.Abort();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.get_IsUpgradableRequest();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<Microsoft-AspNetCore-Http-Features-IHttpUpgradeFeature-UpgradeAsync>d__165")]
private sealed virtual override Task`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.UpgradeAsync();
    private sealed virtual override ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.get_User();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.set_User(ClaimsPrincipal value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.get_TraceIdentifier();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.set_TraceIdentifier(string value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.get_AllowSynchronousIO();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.set_AllowSynchronousIO(bool value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_MaxRequestBodySize();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.set_MaxRequestBodySize(Nullable`1<long> value);
    private sealed virtual override SslProtocols Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_Protocol();
    private sealed virtual override CipherAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherStrength();
    private sealed virtual override HashAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashStrength();
    private sealed virtual override ExchangeAlgorithmType Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeAlgorithm();
    private sealed virtual override int Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeStrength();
    private sealed virtual override string Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HostName();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.get_Trailers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.set_Trailers(IHeaderDictionary value);
    public sealed virtual bool get_CanDelegate();
    [CompilerGeneratedAttribute]
private sealed virtual override CancellationToken Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.get_ConnectionClosedRequested();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.set_ConnectionClosedRequested(CancellationToken value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<OnResponseStart>d__205")]
internal Task OnResponseStart();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<NotifiyOnStartingAsync>d__206")]
private Task NotifiyOnStartingAsync();
    private void ConsiderEnablingResponseCache();
    private Nullable`1<TimeSpan> GetCacheTtl();
    internal Task OnCompleted();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<NotifyOnCompletedAsync>d__210")]
private Task NotifyOnCompletedAsync();
    public sealed virtual void DelegateRequest(DelegationRule destination);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.RequestClose();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext/<<Microsoft-AspNetCore-Http-Features-ITlsConnectionFeature-GetClientCertificateAsync>g__GetCertificateAsync|127_0>d")]
[CompilerGeneratedAttribute]
private Task`1<X509Certificate2> <Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.GetClientCertificateAsync>g__GetCertificateAsync|127_0(CancellationToken cancellation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.RequestContext`1 : RequestContext {
    private IHttpApplication`1<TContext> _application;
    private MessagePump _messagePump;
    public RequestContext`1(IHttpApplication`1<TContext> application, MessagePump messagePump, HttpSysListener server, Nullable`1<UInt32> bufferSize, ulong requestId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.RequestContext`1/<ExecuteAsync>d__3")]
public virtual Task ExecuteAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.HttpSys.RequestContextLog : object {
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __RequestErrorCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __RequestProcessErrorCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __RequestsDrainedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __RequestAbortedCallback;
    private static RequestContextLog();
    [LoggerMessageAttribute("24", "4", "ProcessRequestAsync")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RequestError(ILogger logger, Exception exception);
    [LoggerMessageAttribute("6", "4", "ProcessRequestAsync")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RequestProcessError(ILogger logger, Exception exception);
    [LoggerMessageAttribute("7", "2", "All requests drained.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RequestsDrained(ILogger logger);
    [LoggerMessageAttribute("49", "1", "The request was aborted by the client.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RequestAborted(ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.RequestQueue : object {
    private RequestQueueMode _mode;
    private ILogger _logger;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <BoundHandle>k__BackingField;
    internal bool Created { get; }
    internal SafeHandle Handle { get; }
    internal ThreadPoolBoundHandle BoundHandle { get; }
    internal RequestQueue(string requestQueueName, ILogger logger);
    internal RequestQueue(string requestQueueName, RequestQueueMode mode, ILogger logger);
    private RequestQueue(string requestQueueName, RequestQueueMode mode, ILogger logger, bool receiver);
    [CompilerGeneratedAttribute]
internal bool get_Created();
    [CompilerGeneratedAttribute]
internal SafeHandle get_Handle();
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_BoundHandle();
    internal void SetLengthLimit(long length);
    internal void SetRejectionVerbosity(Http503VerbosityLevel verbosity);
    public void Dispose();
    private void CheckDisposed();
}
public enum Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode : Enum {
    public int value__;
    public static RequestQueueMode Create;
    public static RequestQueueMode Attach;
    public static RequestQueueMode CreateOrAttach;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.RequestStream : Stream {
    private static int MaxReadSize;
    private RequestContext _requestContext;
    private UInt32 _dataChunkOffset;
    private int _dataChunkIndex;
    private Nullable`1<long> _maxSize;
    private long _totalRead;
    private bool _closed;
    [CompilerGeneratedAttribute]
private bool <HasStarted>k__BackingField;
    internal RequestContext RequestContext { get; }
    private SafeHandle RequestQueueHandle { get; }
    private ulong RequestId { get; }
    private ILogger Logger { get; }
    public bool HasStarted { get; private set; }
    public Nullable`1<long> MaxSize { get; public set; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RequestStream(RequestContext httpContext);
    internal RequestContext get_RequestContext();
    private SafeHandle get_RequestQueueHandle();
    private ulong get_RequestId();
    private ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_HasStarted();
    [CompilerGeneratedAttribute]
private void set_HasStarted(bool value);
    public Nullable`1<long> get_MaxSize();
    public void set_MaxSize(Nullable`1<long> value);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal void SwitchToOpaqueMode();
    internal void Abort();
    public virtual int Read(Byte[] buffer, int offset, int size);
    internal void UpdateAfterRead(UInt32 statusCode, UInt32 dataRead);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void CheckSizeLimit();
    [NullableContextAttribute("2")]
internal bool TryCheckSizeLimit(int bytesRead, Exception& exception);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.RequestStreamAsyncResult : object {
    private static IOCompletionCallback IOCallback;
    private SafeNativeOverlapped _overlapped;
    private IntPtr _pinnedBuffer;
    private int _size;
    private UInt32 _dataAlreadyRead;
    private TaskCompletionSource`1<int> _tcs;
    private RequestStream _requestStream;
    private AsyncCallback _callback;
    private CancellationTokenRegistration _cancellationRegistration;
    internal RequestStream RequestStream { get; }
    [NullableAttribute("2")]
internal SafeNativeOverlapped NativeOverlapped { get; }
    internal IntPtr PinnedBuffer { get; }
    internal UInt32 DataAlreadyRead { get; }
    internal Task`1<int> Task { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal RequestStreamAsyncResult(RequestStream requestStream, object userState, AsyncCallback callback, Byte[] buffer, int offset, int size, UInt32 dataAlreadyRead, CancellationTokenRegistration cancellationRegistration);
    private static RequestStreamAsyncResult();
    internal RequestStream get_RequestStream();
    [NullableContextAttribute("2")]
internal SafeNativeOverlapped get_NativeOverlapped();
    internal IntPtr get_PinnedBuffer();
    internal UInt32 get_DataAlreadyRead();
    internal Task`1<int> get_Task();
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(RequestStreamAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void Callback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal void Complete(int read, UInt32 errorCode);
    internal void Fail(Exception ex);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal static class Microsoft.AspNetCore.Server.HttpSys.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Exception_AccessDenied { get; }
    internal static string Exception_ArrayTooSmall { get; }
    internal static string Exception_EndCalledMultipleTimes { get; }
    internal static string Exception_InvalidStatusCode { get; }
    internal static string Exception_NoSeek { get; }
    internal static string Exception_PrefixAlreadyRegistered { get; }
    internal static string Exception_ReadOnlyStream { get; }
    internal static string Exception_TooMuchWritten { get; }
    internal static string Exception_UnsupportedScheme { get; }
    internal static string Exception_WriteOnlyStream { get; }
    internal static string Exception_WrongIAsyncResult { get; }
    internal static string Warning_ExceptionInOnResponseCompletedAction { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_Exception_AccessDenied();
    internal static string FormatException_AccessDenied(object p0, object p1);
    internal static string get_Exception_ArrayTooSmall();
    internal static string get_Exception_EndCalledMultipleTimes();
    internal static string get_Exception_InvalidStatusCode();
    internal static string FormatException_InvalidStatusCode(object p0);
    internal static string get_Exception_NoSeek();
    internal static string get_Exception_PrefixAlreadyRegistered();
    internal static string FormatException_PrefixAlreadyRegistered(object p0);
    internal static string get_Exception_ReadOnlyStream();
    internal static string get_Exception_TooMuchWritten();
    internal static string get_Exception_UnsupportedScheme();
    internal static string get_Exception_WriteOnlyStream();
    internal static string get_Exception_WrongIAsyncResult();
    internal static string get_Warning_ExceptionInOnResponseCompletedAction();
    internal static string FormatWarning_ExceptionInOnResponseCompletedAction(object p0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.Response : object {
    private static bool SupportsGoAway;
    private ResponseState _responseState;
    private bool _aborted;
    private string _reasonPhrase;
    private ResponseBody _nativeStream;
    private AuthenticationSchemes _authChallenges;
    private Nullable`1<TimeSpan> _cacheTtl;
    private long _expectedBodyLength;
    private BoundaryType _boundaryType;
    private HTTP_RESPONSE_V2 _nativeResponse;
    private HeaderCollection _trailers;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    private static Int32[] StatusWithNoResponseBody;
    [CompilerGeneratedAttribute]
private HeaderCollection <Headers>k__BackingField;
    private RequestContext RequestContext { get; }
    private Request Request { get; }
    public int StatusCode { get; public set; }
    [NullableAttribute("2")]
public string ReasonPhrase { get; public set; }
    public Stream Body { get; }
    internal bool BodyIsFinished { get; }
    public AuthenticationSchemes AuthenticationChallenges { get; public set; }
    public HeaderCollection Headers { get; }
    public HeaderCollection Trailers { get; }
    internal bool HasTrailers { get; }
    internal bool TrailersExpected { get; }
    internal long ExpectedBodyLength { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public Nullable`1<TimeSpan> CacheTtl { get; public set; }
    internal BoundaryType BoundaryType { get; }
    internal bool HasComputedHeaders { get; }
    public bool HasStarted { get; }
    internal Response(RequestContext requestContext);
    private static Response();
    [CompilerGeneratedAttribute]
private RequestContext get_RequestContext();
    private Request get_Request();
    public int get_StatusCode();
    public void set_StatusCode(int value);
    [NullableContextAttribute("2")]
public string get_ReasonPhrase();
    [NullableContextAttribute("2")]
public void set_ReasonPhrase(string value);
    public Stream get_Body();
    internal bool get_BodyIsFinished();
    public AuthenticationSchemes get_AuthenticationChallenges();
    public void set_AuthenticationChallenges(AuthenticationSchemes value);
    private string GetReasonPhrase(int statusCode);
    private static bool CanSendResponseBody(int responseCode);
    [CompilerGeneratedAttribute]
public HeaderCollection get_Headers();
    public HeaderCollection get_Trailers();
    internal bool get_HasTrailers();
    internal bool get_TrailersExpected();
    internal long get_ExpectedBodyLength();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Nullable`1<TimeSpan> get_CacheTtl();
    public void set_CacheTtl(Nullable`1<TimeSpan> value);
    internal void MakeTrailersReadOnly();
    internal void Abort();
    internal void Dispose();
    internal BoundaryType get_BoundaryType();
    internal bool get_HasComputedHeaders();
    public bool get_HasStarted();
    private void CheckResponseStarted();
    [MemberNotNullAttribute("_nativeStream")]
private void EnsureResponseStream();
    [NullableContextAttribute("0")]
internal UInt32 SendHeaders(UnmanagedBufferAllocator& allocator, Span`1<HTTP_DATA_CHUNK> dataChunks, ResponseStreamAsyncResult asyncResult, HTTP_FLAGS flags, bool isOpaqueUpgrade);
    internal HTTP_FLAGS ComputeHeaders(long writeCount, bool endOfRequest);
    private static bool Matches(string knownValue, StringValues input);
    private void SerializeHeaders(UnmanagedBufferAllocator& allocator, bool isOpaqueUpgrade);
    internal void SerializeTrailers(UnmanagedBufferAllocator& allocator, HTTP_DATA_CHUNK& dataChunk);
    internal void SendOpaqueUpgrade();
    internal void MarkDelegated();
    internal void CancelLastWrite();
    public Task SendFileAsync(string path, long offset, Nullable`1<long> count, CancellationToken cancel);
    internal void SwitchToOpaqueMode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseBody : Stream {
    private RequestContext _requestContext;
    private long _leftToWrite;
    private bool _skipWrites;
    private bool _disposed;
    private ResponseStreamAsyncResult _lastWrite;
    internal RequestContext RequestContext { get; }
    private SafeHandle RequestQueueHandle { get; }
    private ulong RequestId { get; }
    private ILogger Logger { get; }
    internal bool ThrowWriteExceptions { get; }
    internal bool EnableKernelResponseBuffering { get; }
    internal bool IsDisposed { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseBody(RequestContext requestContext);
    internal RequestContext get_RequestContext();
    private SafeHandle get_RequestQueueHandle();
    private ulong get_RequestId();
    private ILogger get_Logger();
    internal bool get_ThrowWriteExceptions();
    internal bool get_EnableKernelResponseBuffering();
    internal bool get_IsDisposed();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public void MarkDelegated();
    private void FlushInternal(bool endOfRequest, ArraySegment`1<byte> data);
    private void BuildDataChunks(UnmanagedBufferAllocator& allocator, bool endOfRequest, ArraySegment`1<byte> data, Span`1& dataChunks, Span`1& pins);
    private static void SetDataChunk(Span`1<HTTP_DATA_CHUNK> chunks, Int32& chunkIndex, ArraySegment`1<byte> buffer, GCHandle& handle);
    private static void SetDataChunkWithPinnedData(Span`1<HTTP_DATA_CHUNK> chunks, Int32& chunkIndex, ReadOnlySpan`1<byte> bytes);
    private static void FreeDataBuffers(Span`1<GCHandle> pinnedBuffers);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private Task FlushInternalAsync(ArraySegment`1<byte> data, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    internal void Abort(bool dispose);
    private HTTP_FLAGS ComputeLeftToWrite(long writeCount, bool endOfRequest);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void CheckWriteCount(Nullable`1<long> count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseBody/<SendFileAsync>d__52")]
internal Task SendFileAsync(string fileName, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
    internal Task SendFileAsyncCore(string fileName, long offset, Nullable`1<long> count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    internal void SwitchToOpaqueMode();
    internal void CancelLastWrite();
    private void CheckDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseStream : Stream {
    private Stream _innerStream;
    private Func`1<Task> _onStart;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseStream(Stream innerStream, Func`1<Task> onStart);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseStream/<FlushAsync>d__20")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseStream/<WriteAsync>d__22")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.ResponseStream/<WriteAsync>d__23")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.ResponseStreamAsyncResult : object {
    private static IOCompletionCallback IOCallback;
    private SafeNativeOverlapped _overlapped;
    private HTTP_DATA_CHUNK[] _dataChunks;
    private FileStream _fileStream;
    private ResponseBody _responseStream;
    private TaskCompletionSource`1<object> _tcs;
    private UInt32 _bytesSent;
    private CancellationToken _cancellationToken;
    private CancellationTokenRegistration _cancellationRegistration;
    [CompilerGeneratedAttribute]
private bool <EndCalled>k__BackingField;
    [NullableAttribute("2")]
internal SafeNativeOverlapped NativeOverlapped { get; }
    internal Task Task { get; }
    internal UInt32 BytesSent { get; internal set; }
    internal ushort DataChunkCount { get; }
    [NullableAttribute("0")]
internal HTTP_DATA_CHUNK* DataChunks { get; }
    internal bool EndCalled { get; internal set; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal ResponseStreamAsyncResult(ResponseBody responseStream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
internal ResponseStreamAsyncResult(ResponseBody responseStream, ArraySegment`1<byte> data, bool chunked, CancellationToken cancellationToken);
    internal ResponseStreamAsyncResult(ResponseBody responseStream, FileStream fileStream, long offset, long count, bool chunked, CancellationToken cancellationToken);
    private static ResponseStreamAsyncResult();
    private static void SetDataChunk(HTTP_DATA_CHUNK[] chunks, Int32& chunkIndex, Object[] objectsToPin, Int32& pinIndex, ArraySegment`1<byte> segment);
    private static void SetDataChunkWithPinnedData(HTTP_DATA_CHUNK[] chunks, Int32& chunkIndex, ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("2")]
internal SafeNativeOverlapped get_NativeOverlapped();
    internal Task get_Task();
    internal UInt32 get_BytesSent();
    internal void set_BytesSent(UInt32 value);
    internal ushort get_DataChunkCount();
    [NullableContextAttribute("0")]
internal HTTP_DATA_CHUNK* get_DataChunks();
    [CompilerGeneratedAttribute]
internal bool get_EndCalled();
    [CompilerGeneratedAttribute]
internal void set_EndCalled(bool value);
    internal void IOCompleted(UInt32 errorCode);
    private static void IOCompleted(ResponseStreamAsyncResult asyncResult, UInt32 errorCode);
    private static void Callback(UInt32 errorCode, UInt32 _, NativeOverlapped* nativeOverlapped);
    internal void Complete();
    internal void FailSilently();
    internal void Cancel(bool dispose);
    internal void Fail(Exception ex);
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool DoesProcExist(string lpProcName);
    public TDelegate GetProcAddress(string lpProcName, bool throwIfNotFound);
    public static SafeLibraryHandle Open(string filename);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.Server.HttpSys.ServerSession : object {
    [CompilerGeneratedAttribute]
private HttpServerSessionHandle <Id>k__BackingField;
    [NullableAttribute("1")]
public HttpServerSessionHandle Id { get; private set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public HttpServerSessionHandle get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(HttpServerSessionHandle value);
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.HttpSys.StandardFeatureCollection : object {
    private static Func`2<RequestContext, object> _identityFunc;
    private static Dictionary`2<Type, Func`2<RequestContext, object>> _featureFuncLookup;
    private RequestContext _featureContext;
    public bool IsReadOnly { get; }
    public int Revision { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    private static StandardFeatureCollection();
    [NullableContextAttribute("1")]
public StandardFeatureCollection(RequestContext featureContext);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Revision();
    [NullableContextAttribute("1")]
public sealed virtual object get_Item(Type key);
    [NullableContextAttribute("1")]
public sealed virtual void set_Item(Type key, object value);
    private static object ReturnIdentity(RequestContext featureContext);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.HttpSys.StandardFeatureCollection/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-Type,System-Object>>-GetEnumerator>d__14")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual TFeature Get();
    [NullableContextAttribute("2")]
public sealed virtual void Set(TFeature instance);
}
public class Microsoft.AspNetCore.Server.HttpSys.TimeoutManager : object {
    private static int TimeoutLimitSize;
    private UrlGroup _urlGroup;
    private Int32[] _timeouts;
    private UInt32 _minSendBytesPerSecond;
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    private static TimeoutManager();
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
    private TimeSpan GetTimeSpanTimeout(HTTP_TIMEOUT_TYPE type);
    private void SetTimeSpanTimeout(HTTP_TIMEOUT_TYPE type, TimeSpan value);
    [NullableContextAttribute("1")]
internal void SetUrlGroupTimeouts(UrlGroup urlGroup);
    private void SetUrlGroupTimeouts(Int32[] timeouts, UInt32 minSendBytesPerSecond);
}
internal static class Microsoft.AspNetCore.Server.HttpSys.TokenBindingUtil : object {
    private static Byte[] ExtractIdentifierBlob(TOKENBINDING_RESULT_DATA* pTokenBindingResultData);
    [NullableContextAttribute("2")]
public static Byte[] GetProvidedTokenIdFromBindingInfo(HTTP_REQUEST_TOKEN_BINDING_INFO* pTokenBindingInfo, Byte[]& referredId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.HttpSys.UrlGroup : object {
    private static int BindingInfoSize;
    private static int QosInfoSize;
    private static int RequestPropertyInfoSize;
    private ILogger _logger;
    private ServerSession _serverSession;
    private RequestQueue _requestQueue;
    private bool _disposed;
    private bool _created;
    [CompilerGeneratedAttribute]
private ulong <Id>k__BackingField;
    internal ulong Id { get; private set; }
    internal UrlGroup(ServerSession serverSession, RequestQueue requestQueue, ILogger logger);
    private static UrlGroup();
    [CompilerGeneratedAttribute]
internal ulong get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ulong value);
    internal void SetMaxConnections(long maxConnections);
    internal void SetDelegationProperty(RequestQueue destination);
    internal void UnSetDelegationProperty(RequestQueue destination, bool throwOnError);
    internal void SetProperty(HTTP_SERVER_PROPERTY property, IntPtr info, UInt32 infosize, bool throwOnError);
    internal void AttachToQueue();
    internal void DetachFromQueue();
    internal void RegisterPrefix(string uriPrefix, int contextId);
    internal void UnregisterPrefix(string uriPrefix);
    public sealed virtual void Dispose();
    private void CheckDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.HttpSys.UrlPrefix : object {
    [CompilerGeneratedAttribute]
private bool <IsHttps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostAndPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PortValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathWithoutTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPrefix>k__BackingField;
    public bool IsHttps { get; }
    public string Scheme { get; }
    public string Host { get; }
    public string Port { get; }
    internal string HostAndPort { get; }
    public int PortValue { get; }
    public string Path { get; }
    internal string PathWithoutTrailingSlash { get; }
    public string FullPrefix { get; }
    private UrlPrefix(bool isHttps, string scheme, string host, string port, int portValue, string path);
    public static UrlPrefix Create(string scheme, string host, string port, string path);
    public static UrlPrefix Create(string scheme, string host, Nullable`1<int> portValue, string path);
    public static UrlPrefix Create(string prefix);
    [CompilerGeneratedAttribute]
public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public string get_Port();
    [CompilerGeneratedAttribute]
internal string get_HostAndPort();
    [CompilerGeneratedAttribute]
public int get_PortValue();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal string get_PathWithoutTrailingSlash();
    [CompilerGeneratedAttribute]
public string get_FullPrefix();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection : object {
    private IDictionary`2<int, UrlPrefix> _prefixes;
    private UrlGroup _urlGroup;
    private int _nextId;
    private static int BasePort;
    private static int MaxPortIndex;
    private static int MaxRetries;
    private static int NextPortIndex;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public void Add(string prefix);
    public sealed virtual void Add(UrlPrefix item);
    [NullableContextAttribute("2")]
internal UrlPrefix GetPrefix(int id);
    internal bool TryMatchLongestPrefix(bool isHttps, string host, string originalPath, String& pathBase, String& remainingPath);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(UrlPrefix item);
    public sealed virtual void CopyTo(UrlPrefix[] array, int arrayIndex);
    public bool Remove(string prefix);
    public sealed virtual bool Remove(UrlPrefix item);
    public sealed virtual IEnumerator`1<UrlPrefix> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void RegisterAllPrefixes(UrlGroup urlGroup);
    private void FindHttpPortUnsynchronized(int key, UrlPrefix urlPrefix);
    internal void UnregisterAllPrefixes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.HttpSys.ValidationHelper : object {
    public static string ExceptionMessage(Exception exception);
    public static string ToString(object objectValue);
    public static string HashString(object objectValue);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities : object {
    private static SpanAction`2<char, IntPtr> s_getAsciiOrUTF8StringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getAsciiStringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getLatin1StringNonNullCharacters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SpanAction`2<char, ValueTuple`3<string, char, UInt32>> s_populateSpanWithHexSuffix;
    private static StringUtilities();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(ReadOnlySpan`1<byte> span, Encoding defaultEncoding);
    [ExtensionAttribute]
public static string GetAsciiStringNonNullCharacters(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static string GetLatin1StringNonNullCharacters(ReadOnlySpan`1<byte> span);
    public static bool TryGetAsciiString(Byte* input, Char* output, int count);
    public static bool TryGetLatin1String(Byte* input, Char* output, int count);
    public static bool BytesOrdinalEqualsStringAndAscii(string previousValue, ReadOnlySpan`1<byte> newValue);
    private static void WidenFourAsciiBytesToUtf16AndWriteToBuffer(Char* output, Byte* input, int value, Vector128`1<sbyte> zero);
    private static bool IsValidHeaderString(string value);
    [NullableContextAttribute("1")]
public static string ConcatAsHexSuffix(string str, char separator, UInt32 number);
    private static bool CheckBytesInAsciiRange(Vector`1<sbyte> check);
    private static bool CheckBytesInAsciiRange(Vector256`1<sbyte> check, Vector256`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(Vector128`1<sbyte> check, Vector128`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(long check);
    private static bool CheckBytesInAsciiRange(int check);
    private static bool CheckBytesInAsciiRange(short check);
    private static bool CheckBytesInAsciiRange(sbyte check);
    private static bool CheckBytesNotNull(Vector`1<byte> check);
    private static bool CheckBytesNotNull(long check);
    private static bool CheckBytesNotNull(int check);
    private static bool CheckBytesNotNull(short check);
    private static bool CheckBytesNotNull(sbyte check);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.DiagnosticMemoryPool : MemoryPool`1<byte> {
    private MemoryPool`1<byte> _pool;
    private bool _allowLateReturn;
    private bool _rentTracking;
    private object _syncObj;
    private HashSet`1<DiagnosticPoolBlock> _blocks;
    private List`1<Exception> _blockAccessExceptions;
    private TaskCompletionSource _allBlocksReturned;
    private int _totalBlocks;
    private static int AnySize;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public int MaxBufferSize { get; }
    public DiagnosticMemoryPool(MemoryPool`1<byte> pool, bool allowLateReturn, bool rentTracking);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual IMemoryOwner`1<byte> Rent(int size);
    public virtual int get_MaxBufferSize();
    internal void Return(DiagnosticPoolBlock block);
    internal void ReportException(Exception exception);
    protected virtual void Dispose(bool disposing);
    private void SetAllBlocksReturned();
    private AggregateException CreateAccessExceptions();
    [AsyncStateMachineAttribute("System.Buffers.DiagnosticMemoryPool/<WhenAllBlocksReturnedAsync>d__22")]
public Task WhenAllBlocksReturnedAsync(TimeSpan timeout);
}
internal class System.Buffers.DiagnosticPoolBlock : MemoryManager`1<byte> {
    private DiagnosticMemoryPool _pool;
    private IMemoryOwner`1<byte> _memoryOwner;
    private Nullable`1<MemoryHandle> _memoryHandle;
    private Memory`1<byte> _memory;
    private object _syncObj;
    private bool _isDisposed;
    private int _pinCount;
    [CompilerGeneratedAttribute]
private StackTrace <Leaser>k__BackingField;
    public Memory`1<byte> Memory { get; }
    [NullableAttribute("2")]
public StackTrace Leaser { get; public set; }
    [NullableContextAttribute("1")]
internal DiagnosticPoolBlock(DiagnosticMemoryPool pool, IMemoryOwner`1<byte> memoryOwner);
    public virtual Memory`1<byte> get_Memory();
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<byte> GetSpan();
    public virtual MemoryHandle Pin(int byteOffset);
    protected virtual bool TryGetArray(ArraySegment`1& segment);
    public virtual void Unpin();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public StackTrace get_Leaser();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Leaser(StackTrace value);
    public void Track();
}
internal class System.Buffers.MemoryPoolBlock : object {
    [CompilerGeneratedAttribute]
private PinnedBlockMemoryPool <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <Memory>k__BackingField;
    [NullableAttribute("1")]
public PinnedBlockMemoryPool Pool { get; }
    public Memory`1<byte> Memory { get; }
    [NullableContextAttribute("1")]
internal MemoryPoolBlock(PinnedBlockMemoryPool pool, int length);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public PinnedBlockMemoryPool get_Pool();
    [CompilerGeneratedAttribute]
public sealed virtual Memory`1<byte> get_Memory();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.MemoryPoolThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(int sourceLength, int offset);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(int sourceLength, int offset);
    public static void ThrowInvalidOperationException_PinCountZero(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_ReturningPinnedBlock(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DoubleDispose();
    public static void ThrowInvalidOperationException_BlockDoubleDispose(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockReturnedToDisposedPool(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockIsBackedByDisposedSlab(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DisposingPoolWithActiveBlocks(int returned, int total, DiagnosticPoolBlock[] blocks);
    public static void ThrowInvalidOperationException_BlocksWereNotReturnedInTime(int returned, int total, DiagnosticPoolBlock[] blocks);
    private static string GenerateMessage(string message, DiagnosticPoolBlock[] blocks);
    public static void ThrowArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    public static void ThrowObjectDisposedException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    private static ObjectDisposedException GetObjectDisposedException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Buffers.PinnedBlockMemoryPool : MemoryPool`1<byte> {
    private static int _blockSize;
    [CompilerGeneratedAttribute]
private int <MaxBufferSize>k__BackingField;
    private ConcurrentQueue`1<MemoryPoolBlock> _blocks;
    private bool _isDisposed;
    private object _disposeSync;
    private static int AnySize;
    public int MaxBufferSize { get; }
    public static int BlockSize { get; }
    [CompilerGeneratedAttribute]
public virtual int get_MaxBufferSize();
    public static int get_BlockSize();
    public virtual IMemoryOwner`1<byte> Rent(int size);
    internal void Return(MemoryPoolBlock block);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Buffers.PinnedBlockMemoryPoolFactory : object {
    public static MemoryPool`1<byte> Create();
    public static MemoryPool`1<byte> CreatePinnedBlockMemoryPool();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
}
internal class UnmanagedBufferAllocator : ValueType {
    private int _blockSize;
    private int _currentBlockCount;
    private Void** _currentAlloc;
    private Byte* _currentBlock;
    public static int DefaultBlockSize { get; }
    public UnmanagedBufferAllocator(int blockSize);
    public static int get_DefaultBlockSize();
    public T* AllocAsPointer(int count);
    public Span`1<T> AllocAsSpan(int count);
    public Byte* GetHeaderEncodedBytes(string myString, Int32& length);
    public sealed virtual void Dispose();
    private Span`1<byte> GetSpan(int sizeHint, Boolean& mustCommit);
    private void Commit(int count);
    private Byte* Alloc(int size);
    private void NewBlock();
}
