[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HttpExtensions : object {
    internal static string UrlEncodedFormContentType;
    internal static string MultipartFormContentType;
    internal static string OriginalEndpointKey;
    internal static bool IsValidHttpMethodForForm(string method);
    [NullableContextAttribute("2")]
internal static bool IsValidContentTypeForForm(string contentType);
    internal static Endpoint GetOriginalEndpoint(HttpContext context);
    internal static void ClearEndpoint(HttpContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions : object {
    private static string MapEndpointUnreferencedCodeWarning;
    private static string MapEndpointDynamicCodeWarning;
    private static String[] GetVerb;
    private static String[] PostVerb;
    private static String[] PutVerb;
    private static String[] DeleteVerb;
    private static String[] PatchVerb;
    private static EndpointRouteBuilderExtensions();
    [ExtensionAttribute]
public static RouteGroupBuilder MapGroup(IEndpointRouteBuilder endpoints, string prefix);
    [ExtensionAttribute]
public static RouteGroupBuilder MapGroup(IEndpointRouteBuilder endpoints, RoutePattern prefix);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapGet(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapPost(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapPut(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapDelete(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapPatch(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapMethods(IEndpointRouteBuilder endpoints, string pattern, IEnumerable`1<string> httpMethods, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints, RoutePattern pattern, RequestDelegate requestDelegate);
    [ExtensionAttribute]
private static IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints, RoutePattern pattern, RequestDelegate requestDelegate, IEnumerable`1<string> httpMethods);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapGet(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapPost(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapPut(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapDelete(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapPatch(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapMethods(IEndpointRouteBuilder endpoints, string pattern, IEnumerable`1<string> httpMethods, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder Map(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder Map(IEndpointRouteBuilder endpoints, RoutePattern pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapFallback(IEndpointRouteBuilder endpoints, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
public static RouteHandlerBuilder MapFallback(IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may be trimmed if not directly referenced.")]
[RequiresDynamicCodeAttribute("This API may perform reflection on the supplied delegate and its parameters. These types may require generated code and aren't compatible with native AOT applications.")]
private static RouteHandlerBuilder Map(IEndpointRouteBuilder endpoints, RoutePattern pattern, Delegate handler, IEnumerable`1<string> httpMethods, bool isFallback);
    [ExtensionAttribute]
internal static RouteEndpointDataSource GetOrAddRouteEndpointDataSource(IEndpointRouteBuilder endpoints);
    [CompilerGeneratedAttribute]
internal static RequestDelegateResult <Map>g__CreateHandlerRequestDelegate|17_0(Delegate handler, RequestDelegateFactoryOptions options, RequestDelegateMetadataResult metadataResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions : object {
    private static string EndpointRouteBuilder;
    private static string GlobalEndpointRouteBuilderKey;
    private static string UseRoutingKey;
    [ExtensionAttribute]
public static IApplicationBuilder UseRouting(IApplicationBuilder builder);
    [ExtensionAttribute]
public static IApplicationBuilder UseEndpoints(IApplicationBuilder builder, Action`1<IEndpointRouteBuilder> configure);
    private static void VerifyRoutingServicesAreRegistered(IApplicationBuilder app);
    private static void VerifyEndpointRoutingMiddlewareIsRegistered(IApplicationBuilder app, IEndpointRouteBuilder& endpointRouteBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.FallbackEndpointRouteBuilderExtensions : object {
    public static string DefaultPattern;
    private static FallbackEndpointRouteBuilderExtensions();
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapFallback(IEndpointRouteBuilder endpoints, RequestDelegate requestDelegate);
    [ExtensionAttribute]
public static IEndpointConventionBuilder MapFallback(IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.")]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.")]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.")]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.")]
public static IRouteBuilder MapRoute(IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints, object dataTokens);
    private static IInlineConstraintResolver CreateInlineConstraintResolver(IServiceProvider serviceProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Builder.RouteHandlerBuilder : object {
    private IEnumerable`1<IEndpointConventionBuilder> _endpointConventionBuilders;
    private ICollection`1<Action`1<EndpointBuilder>> _conventions;
    private ICollection`1<Action`1<EndpointBuilder>> _finallyConventions;
    internal RouteHandlerBuilder(ICollection`1<Action`1<EndpointBuilder>> conventions, ICollection`1<Action`1<EndpointBuilder>> finallyConventions);
    public RouteHandlerBuilder(IEnumerable`1<IEndpointConventionBuilder> endpointConventionBuilders);
    public sealed virtual void Add(Action`1<EndpointBuilder> convention);
    public sealed virtual void Finally(Action`1<EndpointBuilder> finalConvention);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Builder.RouterMiddleware : object {
    private ILogger _logger;
    private RequestDelegate _next;
    private IRouter _router;
    public RouterMiddleware(RequestDelegate next, ILoggerFactory loggerFactory, IRouter router);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Builder.RouterMiddleware/<Invoke>d__4")]
public Task Invoke(HttpContext httpContext);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RouteShortCircuitEndpointConventionBuilderExtensions : object {
    private static ShortCircuitMetadata _200ShortCircuitMetadata;
    private static ShortCircuitMetadata _401ShortCircuitMetadata;
    private static ShortCircuitMetadata _404ShortCircuitMetadata;
    private static ShortCircuitMetadata _nullShortCircuitMetadata;
    private static RouteShortCircuitEndpointConventionBuilderExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEndpointConventionBuilder ShortCircuit(IEndpointConventionBuilder builder, Nullable`1<int> statusCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RoutingBuilderExtensions : object {
    [ExtensionAttribute]
public static IApplicationBuilder UseRouter(IApplicationBuilder builder, IRouter router);
    [ExtensionAttribute]
public static IApplicationBuilder UseRouter(IApplicationBuilder builder, Action`1<IRouteBuilder> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions : object {
    [ExtensionAttribute]
public static TBuilder RequireHost(TBuilder builder, String[] hosts);
    [ExtensionAttribute]
public static TBuilder WithDisplayName(TBuilder builder, string displayName);
    [ExtensionAttribute]
public static TBuilder WithDisplayName(TBuilder builder, Func`2<EndpointBuilder, string> func);
    [ExtensionAttribute]
public static TBuilder WithMetadata(TBuilder builder, Object[] items);
    [ExtensionAttribute]
public static TBuilder WithName(TBuilder builder, string endpointName);
    [ExtensionAttribute]
public static TBuilder WithGroupName(TBuilder builder, string endpointGroupName);
    [ExtensionAttribute]
public static TBuilder WithOrder(TBuilder builder, int order);
    [ExtensionAttribute]
public static TBuilder DisableAntiforgery(TBuilder builder);
    [ExtensionAttribute]
public static TBuilder WithFormMappingOptions(TBuilder builder, Nullable`1<int> maxCollectionSize, Nullable`1<int> maxRecursionDepth, Nullable`1<int> maxKeySize);
    [ExtensionAttribute]
public static TBuilder WithFormOptions(TBuilder builder, Nullable`1<bool> bufferBody, Nullable`1<int> memoryBufferThreshold, Nullable`1<long> bufferBodyLengthLimit, Nullable`1<int> valueCountLimit, Nullable`1<int> keyLengthLimit, Nullable`1<int> valueLengthLimit, Nullable`1<int> multipartBoundaryLengthLimit, Nullable`1<int> multipartHeadersCountLimit, Nullable`1<int> multipartHeadersLengthLimit, Nullable`1<long> multipartBodyLengthLimit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.EndpointFilterExtensions : object {
    [ExtensionAttribute]
public static TBuilder AddEndpointFilter(TBuilder builder, IEndpointFilter filter);
    [ExtensionAttribute]
public static TBuilder AddEndpointFilter(TBuilder builder);
    [ExtensionAttribute]
public static RouteHandlerBuilder AddEndpointFilter(RouteHandlerBuilder builder);
    [ExtensionAttribute]
public static RouteGroupBuilder AddEndpointFilter(RouteGroupBuilder builder);
    [ExtensionAttribute]
public static TBuilder AddEndpointFilter(TBuilder builder, Func`3<EndpointFilterInvocationContext, EndpointFilterDelegate, ValueTask`1<object>> routeHandlerFilter);
    [ExtensionAttribute]
public static TBuilder AddEndpointFilterFactory(TBuilder builder, Func`3<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate> filterFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Http.Headers.ReadOnlyMediaTypeHeaderValue : ValueType {
    [CompilerGeneratedAttribute]
private StringSegment <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSegment <SubType>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSegment <SubTypeWithoutSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSegment <SubTypeSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaTypeParameterParser <ParameterParser>k__BackingField;
    public StringSegment Type { get; }
    public bool MatchesAllTypes { get; }
    public StringSegment SubType { get; }
    public StringSegment SubTypeWithoutSuffix { get; }
    public StringSegment SubTypeSuffix { get; }
    public bool MatchesAllSubTypes { get; }
    public bool MatchesAllSubTypesWithoutSuffix { get; }
    [NullableAttribute("2")]
public Encoding Encoding { get; }
    public StringSegment Charset { get; }
    public bool HasWildcard { get; }
    public MediaTypeParameterParser ParameterParser { get; }
    public ReadOnlyMediaTypeHeaderValue(string mediaType);
    public ReadOnlyMediaTypeHeaderValue(StringSegment mediaType);
    public ReadOnlyMediaTypeHeaderValue(string mediaType, int offset, Nullable`1<int> length);
    private static int GetTypeLength(string input, int offset, StringSegment& type);
    private static int GetSubtypeLength(string input, int offset, StringSegment& subType);
    private static bool TryGetSuffixLength(StringSegment subType, Int32& suffixLength);
    [CompilerGeneratedAttribute]
public StringSegment get_Type();
    public bool get_MatchesAllTypes();
    [CompilerGeneratedAttribute]
public StringSegment get_SubType();
    [CompilerGeneratedAttribute]
public StringSegment get_SubTypeWithoutSuffix();
    [CompilerGeneratedAttribute]
public StringSegment get_SubTypeSuffix();
    public bool get_MatchesAllSubTypes();
    public bool get_MatchesAllSubTypesWithoutSuffix();
    [NullableContextAttribute("2")]
public Encoding get_Encoding();
    public StringSegment get_Charset();
    public bool get_HasWildcard();
    [CompilerGeneratedAttribute]
public MediaTypeParameterParser get_ParameterParser();
    public bool IsSubsetOf(ReadOnlyMediaTypeHeaderValue set);
    public StringSegment GetParameter(string parameterName);
    public StringSegment GetParameter(StringSegment parameterName);
    public bool TryGetLastParameter(StringSegment parameterName, StringSegment& parameterValue);
    public static Encoding GetEncoding(string mediaType);
    [NullableContextAttribute("2")]
public static Encoding GetEncoding(StringSegment mediaType);
    private static Encoding GetEncodingFromCharset(StringSegment charset);
    private bool MatchesType(ReadOnlyMediaTypeHeaderValue set);
    private bool MatchesSubtype(ReadOnlyMediaTypeHeaderValue set);
    private bool MatchesSubtypeWithoutSuffix(ReadOnlyMediaTypeHeaderValue set);
    private bool MatchesSubtypeSuffix(ReadOnlyMediaTypeHeaderValue set);
    private bool MatchesEitherSubtypeOrSuffix(ReadOnlyMediaTypeHeaderValue set);
    private bool ContainsAllParameters(MediaTypeParameterParser setParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Http.JsonSerializerExtensions : object {
    [ExtensionAttribute]
public static bool HasKnownPolymorphism(JsonTypeInfo jsonTypeInfo);
    [ExtensionAttribute]
public static bool ShouldUseWith(JsonTypeInfo jsonTypeInfo, Type runtimeType);
    [ExtensionAttribute]
public static JsonTypeInfo GetReadOnlyTypeInfo(JsonSerializerOptions options, Type type);
    [ExtensionAttribute]
public static JsonTypeInfo GetRequiredTypeInfo(JsonSerializerContext context, Type type);
}
internal class Microsoft.AspNetCore.Http.Metadata.AntiforgeryMetadata : object {
    [NullableAttribute("1")]
public static IAntiforgeryMetadata ValidationRequired;
    [NullableAttribute("1")]
public static IAntiforgeryMetadata ValidationNotRequired;
    [CompilerGeneratedAttribute]
private bool <RequiresValidation>k__BackingField;
    public bool RequiresValidation { get; }
    public AntiforgeryMetadata(bool required);
    private static AntiforgeryMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresValidation();
}
internal class Microsoft.AspNetCore.Http.Metadata.FormOptionsMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BufferBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MemoryBufferThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BufferBodyLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ValueCountLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <KeyLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ValueLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultipartBoundaryLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultipartHeadersCountLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultipartHeadersLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MultipartBodyLengthLimit>k__BackingField;
    public Nullable`1<bool> BufferBody { get; }
    public Nullable`1<int> MemoryBufferThreshold { get; }
    public Nullable`1<long> BufferBodyLengthLimit { get; }
    public Nullable`1<int> ValueCountLimit { get; }
    public Nullable`1<int> KeyLengthLimit { get; }
    public Nullable`1<int> ValueLengthLimit { get; }
    public Nullable`1<int> MultipartBoundaryLengthLimit { get; }
    public Nullable`1<int> MultipartHeadersCountLimit { get; }
    public Nullable`1<int> MultipartHeadersLengthLimit { get; }
    public Nullable`1<long> MultipartBodyLengthLimit { get; }
    public FormOptionsMetadata(Nullable`1<bool> bufferBody, Nullable`1<int> memoryBufferThreshold, Nullable`1<long> bufferBodyLengthLimit, Nullable`1<int> valueCountLimit, Nullable`1<int> keyLengthLimit, Nullable`1<int> valueLengthLimit, Nullable`1<int> multipartBoundaryLengthLimit, Nullable`1<int> multipartHeadersCountLimit, Nullable`1<int> multipartHeadersLengthLimit, Nullable`1<long> multipartBodyLengthLimit);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_BufferBody();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MemoryBufferThreshold();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_BufferBodyLengthLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ValueCountLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_KeyLengthLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ValueLengthLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MultipartBoundaryLengthLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MultipartHeadersCountLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MultipartHeadersLengthLimit();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_MultipartBodyLengthLimit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Http.OpenApiRouteHandlerBuilderExtensions : object {
    private static ExcludeFromDescriptionAttribute _excludeFromDescriptionMetadataAttribute;
    private static OpenApiRouteHandlerBuilderExtensions();
    [ExtensionAttribute]
public static TBuilder ExcludeFromDescription(TBuilder builder);
    [ExtensionAttribute]
public static RouteHandlerBuilder ExcludeFromDescription(RouteHandlerBuilder builder);
    [ExtensionAttribute]
public static RouteHandlerBuilder Produces(RouteHandlerBuilder builder, int statusCode, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static RouteHandlerBuilder Produces(RouteHandlerBuilder builder, int statusCode, Type responseType, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static RouteHandlerBuilder ProducesProblem(RouteHandlerBuilder builder, int statusCode, string contentType);
    [ExtensionAttribute]
public static RouteHandlerBuilder ProducesValidationProblem(RouteHandlerBuilder builder, int statusCode, string contentType);
    [ExtensionAttribute]
public static TBuilder WithTags(TBuilder builder, String[] tags);
    [ExtensionAttribute]
public static RouteHandlerBuilder WithTags(RouteHandlerBuilder builder, String[] tags);
    [ExtensionAttribute]
public static RouteHandlerBuilder Accepts(RouteHandlerBuilder builder, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static RouteHandlerBuilder Accepts(RouteHandlerBuilder builder, bool isOptional, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static RouteHandlerBuilder Accepts(RouteHandlerBuilder builder, Type requestType, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static RouteHandlerBuilder Accepts(RouteHandlerBuilder builder, Type requestType, bool isOptional, string contentType, String[] additionalContentTypes);
    [ExtensionAttribute]
public static TBuilder WithDescription(TBuilder builder, string description);
    [ExtensionAttribute]
public static TBuilder WithSummary(TBuilder builder, string summary);
    private static String[] GetAllContentTypes(string contentType, String[] additionalContentTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Internal.ExecuteHandlerHelper : object {
    public static Task ExecuteReturnAsync(object obj, HttpContext httpContext, JsonTypeInfo`1<object> jsonTypeInfo);
    public static void SetPlaintextContentType(HttpContext httpContext);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:RequiresDynamicCode")]
public static Task WriteJsonResponseAsync(HttpResponse response, T value, JsonTypeInfo`1<T> jsonTypeInfo);
}
internal static class Microsoft.AspNetCore.Internal.RouteValueDictionaryTrimmerWarning : object {
    [NullableAttribute("1")]
public static string Warning;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Routing.ArrayBuilder`1 : ValueType {
    private static int DefaultCapacity;
    private static int MaxCoreClrArrayLength;
    private T[] _array;
    private int _count;
    public int Capacity { get; }
    public T[] Buffer { get; }
    public int Count { get; }
    public T Item { get; }
    public ArrayBuilder`1(int capacity);
    public int get_Capacity();
    public T[] get_Buffer();
    public int get_Count();
    public T get_Item(int index);
    public void Add(T item);
    public T First();
    public T Last();
    public T[] ToArray();
    public void UncheckedAdd(T item);
    private void EnsureCapacity(int minimum);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayString,nq}")]
public class Microsoft.AspNetCore.Routing.CompositeEndpointDataSource : EndpointDataSource {
    private object _lock;
    private ICollection`1<EndpointDataSource> _dataSources;
    private List`1<Endpoint> _endpoints;
    private IChangeToken _consumerChangeToken;
    private CancellationTokenSource _cts;
    private List`1<IDisposable> _changeTokenRegistrations;
    private bool _disposed;
    public IEnumerable`1<EndpointDataSource> DataSources { get; }
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    private string DebuggerDisplayString { get; }
    internal CompositeEndpointDataSource(ObservableCollection`1<EndpointDataSource> dataSources);
    public CompositeEndpointDataSource(IEnumerable`1<EndpointDataSource> endpointDataSources);
    private void OnDataSourcesChanged(object sender, NotifyCollectionChangedEventArgs e);
    public IEnumerable`1<EndpointDataSource> get_DataSources();
    public virtual IChangeToken GetChangeToken();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    public virtual IReadOnlyList`1<Endpoint> GetGroupedEndpoints(RouteGroupContext context);
    public sealed virtual void Dispose();
    [MemberNotNullAttribute("_endpoints")]
private void EnsureEndpointsInitialized();
    [MemberNotNullAttribute("_consumerChangeToken")]
private void EnsureChangeTokenInitialized();
    private void HandleChange(bool collectionChanged);
    [MemberNotNullAttribute("_consumerChangeToken")]
private void CreateChangeTokenUnsynchronized(bool collectionChanged);
    [MemberNotNullAttribute("_endpoints")]
private void CreateEndpointsUnsynchronized();
    private string get_DebuggerDisplayString();
    [CompilerGeneratedAttribute]
private void <CreateChangeTokenUnsynchronized>b__20_0();
}
internal class Microsoft.AspNetCore.Routing.ConfigureRouteHandlerOptions : object {
    private IHostEnvironment _environment;
    [NullableContextAttribute("2")]
public ConfigureRouteHandlerOptions(IHostEnvironment environment);
    [NullableContextAttribute("1")]
public sealed virtual void Configure(RouteHandlerOptions options);
}
public class Microsoft.AspNetCore.Routing.Constraints.AlphaRouteConstraint : RegexRouteConstraint {
    [GeneratedRegexAttribute("^[A-Za-z]*$")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex GetAlphaRouteRegex();
}
public class Microsoft.AspNetCore.Routing.Constraints.BoolRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.CompositeRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRouteConstraint> <Constraints>k__BackingField;
    [NullableAttribute("1")]
public IEnumerable`1<IRouteConstraint> Constraints { get; private set; }
    [NullableContextAttribute("1")]
public CompositeRouteConstraint(IEnumerable`1<IRouteConstraint> constraints);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
private void set_Constraints(IEnumerable`1<IRouteConstraint> value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.DateTimeRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.DecimalRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.DoubleRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.FileNameRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    internal static bool IsFileName(ReadOnlySpan`1<char> value);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.FloatRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.GuidRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <AllowedMethods>k__BackingField;
    public IList`1<string> AllowedMethods { get; }
    public HttpMethodRouteConstraint(String[] allowedMethods);
    [CompilerGeneratedAttribute]
public IList`1<string> get_AllowedMethods();
    public virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.IntRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.LengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; }
    public int MaxLength { get; }
    public LengthRouteConstraint(int length);
    public LengthRouteConstraint(int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.LongRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private static bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.MaxLengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MaxLength { get; }
    public MaxLengthRouteConstraint(int maxLength);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.MaxRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    public long Max { get; private set; }
    public MaxRouteConstraint(long max);
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(long value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.MinLengthRouteConstraint : object {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    public int MinLength { get; private set; }
    public MinLengthRouteConstraint(int minLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(int value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.MinRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Min>k__BackingField;
    public long Min { get; }
    public MinRouteConstraint(long min);
    [CompilerGeneratedAttribute]
public long get_Min();
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.NonFileNameRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
internal class Microsoft.AspNetCore.Routing.Constraints.NullRouteConstraint : object {
    [NullableAttribute("1")]
public static NullRouteConstraint Instance;
    private static NullRouteConstraint();
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Constraints.OptionalRouteConstraint : object {
    [CompilerGeneratedAttribute]
private IRouteConstraint <InnerConstraint>k__BackingField;
    public IRouteConstraint InnerConstraint { get; }
    public OptionalRouteConstraint(IRouteConstraint innerConstraint);
    [CompilerGeneratedAttribute]
public IRouteConstraint get_InnerConstraint();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.RangeRouteConstraint : object {
    [CompilerGeneratedAttribute]
private long <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    public long Min { get; private set; }
    public long Max { get; private set; }
    public RangeRouteConstraint(long min, long max);
    [CompilerGeneratedAttribute]
public long get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(long value);
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(long value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string valueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
internal class Microsoft.AspNetCore.Routing.Constraints.RegexErrorStubRouteConstraint : object {
    [NullableContextAttribute("1")]
public RegexErrorStubRouteConstraint(string _);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.IRouteConstraint.Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.RegexInlineRouteConstraint : RegexRouteConstraint {
    [NullableContextAttribute("1")]
public RegexInlineRouteConstraint(string regexPattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Constraints.RegexRouteConstraint : object {
    private static TimeSpan RegexMatchTimeout;
    private Func`1<Regex> _regexFactory;
    private Regex _constraint;
    public Regex Constraint { get; }
    public RegexRouteConstraint(Regex regex);
    public RegexRouteConstraint(string regexPattern);
    private static RegexRouteConstraint();
    public Regex get_Constraint();
    public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
public class Microsoft.AspNetCore.Routing.Constraints.RequiredRouteConstraint : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
}
public class Microsoft.AspNetCore.Routing.Constraints.StringRouteConstraint : object {
    private string _value;
    [NullableContextAttribute("1")]
public StringRouteConstraint(string value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(HttpContext httpContext, IRouter route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection);
    private bool CheckConstraintCore(string parameterValueString);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy.MatchesLiteral(string parameterName, string literal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.DataSourceDependentCache`1 : object {
    private EndpointDataSource _dataSource;
    private Func`2<IReadOnlyList`1<Endpoint>, T> _initializeCore;
    private Func`1<T> _initializer;
    private Action`1<object> _initializerWithState;
    private object _lock;
    private bool _initialized;
    private T _value;
    private IDisposable _disposable;
    private bool _disposed;
    [NullableAttribute("2")]
[NotNullIfNotNullAttribute("_value")]
public T Value { get; }
    public DataSourceDependentCache`1(EndpointDataSource dataSource, Func`2<IReadOnlyList`1<Endpoint>, T> initialize);
    [NullableContextAttribute("2")]
public T get_Value();
    [MemberNotNullAttribute("_value")]
public T EnsureInitialized();
    private T Initialize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(object state);
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.DataTokensMetadata : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <DataTokens>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> DataTokens { get; }
    public DataTokensMetadata(IReadOnlyDictionary`2<string, object> dataTokens);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, object> get_DataTokens();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterion`1 : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, DecisionTreeNode`1<TItem>> <Branches>k__BackingField;
    public string Key { get; public set; }
    public Dictionary`2<object, DecisionTreeNode`1<TItem>> Branches { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, DecisionTreeNode`1<TItem>> get_Branches();
    [CompilerGeneratedAttribute]
public void set_Branches(Dictionary`2<object, DecisionTreeNode`1<TItem>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterionValue : ValueType {
    private object _value;
    public object Value { get; }
    public DecisionCriterionValue(object value);
    public object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionCriterionValueEqualityComparer : object {
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<object> <InnerComparer>k__BackingField;
    public IEqualityComparer`1<object> InnerComparer { get; private set; }
    public DecisionCriterionValueEqualityComparer(IEqualityComparer`1<object> innerComparer);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<object> get_InnerComparer();
    [CompilerGeneratedAttribute]
private void set_InnerComparer(IEqualityComparer`1<object> value);
    public sealed virtual bool Equals(DecisionCriterionValue x, DecisionCriterionValue y);
    public sealed virtual int GetHashCode(DecisionCriterionValue obj);
}
internal static class Microsoft.AspNetCore.Routing.DecisionTree.DecisionTreeBuilder`1 : object {
    [NullableContextAttribute("1")]
public static DecisionTreeNode`1<TItem> GenerateTree(IReadOnlyList`1<TItem> items, IClassifier`1<TItem> classifier);
    private static DecisionTreeNode`1<TItem> GenerateNode(TreeBuilderContext<TItem> context, DecisionCriterionValueEqualityComparer comparer, List`1<ItemDescriptor`1<TItem>> items);
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.DecisionTreeNode`1 : object {
    [CompilerGeneratedAttribute]
private IList`1<TItem> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DecisionCriterion`1<TItem>> <Criteria>k__BackingField;
    public IList`1<TItem> Matches { get; public set; }
    public IList`1<DecisionCriterion`1<TItem>> Criteria { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<TItem> get_Matches();
    [CompilerGeneratedAttribute]
public void set_Matches(IList`1<TItem> value);
    [CompilerGeneratedAttribute]
public IList`1<DecisionCriterion`1<TItem>> get_Criteria();
    [CompilerGeneratedAttribute]
public void set_Criteria(IList`1<DecisionCriterion`1<TItem>> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Routing.DecisionTree.IClassifier`1 {
    public IEqualityComparer`1<object> ValueComparer { get; }
    public abstract virtual IDictionary`2<string, DecisionCriterionValue> GetCriteria(TItem item);
    public abstract virtual IEqualityComparer`1<object> get_ValueComparer();
}
internal class Microsoft.AspNetCore.Routing.DecisionTree.ItemDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DecisionCriterionValue> <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TItem <Item>k__BackingField;
    public IDictionary`2<string, DecisionCriterionValue> Criteria { get; public set; }
    public int Index { get; public set; }
    public TItem Item { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, DecisionCriterionValue> get_Criteria();
    [CompilerGeneratedAttribute]
public void set_Criteria(IDictionary`2<string, DecisionCriterionValue> value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public TItem get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(TItem value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayString,nq}")]
public class Microsoft.AspNetCore.Routing.DefaultEndpointDataSource : EndpointDataSource {
    private IReadOnlyList`1<Endpoint> _endpoints;
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    private string DebuggerDisplayString { get; }
    public DefaultEndpointDataSource(Endpoint[] endpoints);
    public DefaultEndpointDataSource(IEnumerable`1<Endpoint> endpoints);
    public virtual IChangeToken GetChangeToken();
    public virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    private string get_DebuggerDisplayString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.DefaultEndpointRouteBuilder : object {
    [CompilerGeneratedAttribute]
private IApplicationBuilder <ApplicationBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EndpointDataSource> <DataSources>k__BackingField;
    public IApplicationBuilder ApplicationBuilder { get; }
    public ICollection`1<EndpointDataSource> DataSources { get; }
    public IServiceProvider ServiceProvider { get; }
    public DefaultEndpointRouteBuilder(IApplicationBuilder applicationBuilder);
    [CompilerGeneratedAttribute]
public IApplicationBuilder get_ApplicationBuilder();
    public sealed virtual IApplicationBuilder CreateApplicationBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<EndpointDataSource> get_DataSources();
    public sealed virtual IServiceProvider get_ServiceProvider();
}
public class Microsoft.AspNetCore.Routing.DefaultInlineConstraintResolver : object {
    private IDictionary`2<string, Type> _inlineConstraintMap;
    private IServiceProvider _serviceProvider;
    [NullableContextAttribute("1")]
public DefaultInlineConstraintResolver(IOptions`1<RouteOptions> routeOptions, IServiceProvider serviceProvider);
    [NullableContextAttribute("1")]
public virtual IRouteConstraint ResolveConstraint(string inlineConstraint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Endpoints = {Endpoints.Count}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.Routing.DefaultLinkGenerator/DefaultLinkGeneratorDebugView")]
internal class Microsoft.AspNetCore.Routing.DefaultLinkGenerator : LinkGenerator {
    private TemplateBinderFactory _binderFactory;
    private ILogger`1<DefaultLinkGenerator> _logger;
    private IServiceProvider _serviceProvider;
    private LinkOptions _globalLinkOptions;
    private DataSourceDependentCache`1<ConcurrentDictionary`2<RouteEndpoint, TemplateBinder>> _cache;
    private Func`2<RouteEndpoint, TemplateBinder> _createTemplateBinder;
    private IReadOnlyList`1<Endpoint> Endpoints { get; }
    public DefaultLinkGenerator(TemplateBinderFactory binderFactory, EndpointDataSource dataSource, IOptions`1<RouteOptions> routeOptions, ILogger`1<DefaultLinkGenerator> logger, IServiceProvider serviceProvider);
    [NullableContextAttribute("2")]
public virtual string GetPathByAddress(HttpContext httpContext, TAddress address, RouteValueDictionary values, RouteValueDictionary ambientValues, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
public virtual string GetPathByAddress(TAddress address, RouteValueDictionary values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
public virtual string GetUriByAddress(HttpContext httpContext, TAddress address, RouteValueDictionary values, RouteValueDictionary ambientValues, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    public virtual string GetUriByAddress(TAddress address, RouteValueDictionary values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private List`1<RouteEndpoint> GetEndpoints(TAddress address);
    private string GetPathByEndpoints(HttpContext httpContext, List`1<RouteEndpoint> endpoints, RouteValueDictionary values, RouteValueDictionary ambientValues, PathString pathBase, FragmentString fragment, LinkOptions options);
    public string GetUriByEndpoints(List`1<RouteEndpoint> endpoints, RouteValueDictionary values, RouteValueDictionary ambientValues, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private TemplateBinder CreateTemplateBinder(RouteEndpoint endpoint);
    internal TemplateBinder GetTemplateBinder(RouteEndpoint endpoint);
    [NullableContextAttribute("2")]
internal bool TryProcessTemplate(HttpContext httpContext, RouteEndpoint endpoint, RouteValueDictionary values, RouteValueDictionary ambientValues, LinkOptions options, ValueTuple`2& result);
    [NullableContextAttribute("2")]
public static RouteValueDictionary GetAmbientValues(HttpContext httpContext);
    public sealed virtual void Dispose();
    private IReadOnlyList`1<Endpoint> get_Endpoints();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.DefaultLinkParser : LinkParser {
    private ParameterPolicyFactory _parameterPolicyFactory;
    private ILogger`1<DefaultLinkParser> _logger;
    private IServiceProvider _serviceProvider;
    private DataSourceDependentCache`1<ConcurrentDictionary`2<RouteEndpoint, MatcherState>> _matcherCache;
    private Func`2<RouteEndpoint, MatcherState> _createMatcher;
    public DefaultLinkParser(ParameterPolicyFactory parameterPolicyFactory, EndpointDataSource dataSource, ILogger`1<DefaultLinkParser> logger, IServiceProvider serviceProvider);
    [NullableContextAttribute("2")]
public virtual RouteValueDictionary ParsePathByAddress(TAddress address, PathString path);
    private List`1<RouteEndpoint> GetEndpoints(TAddress address);
    private MatcherState CreateRoutePatternMatcher(RouteEndpoint endpoint);
    internal MatcherState GetMatcherState(RouteEndpoint endpoint);
    internal bool TryParse(RouteEndpoint endpoint, PathString path, RouteValueDictionary& values);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.DefaultParameterPolicyFactory : ParameterPolicyFactory {
    private RouteOptions _options;
    private IServiceProvider _serviceProvider;
    public DefaultParameterPolicyFactory(IOptions`1<RouteOptions> options, IServiceProvider serviceProvider);
    public virtual IParameterPolicy Create(RoutePatternParameterPart parameter, IParameterPolicy parameterPolicy);
    public virtual IParameterPolicy Create(RoutePatternParameterPart parameter, string inlineText);
    private static IParameterPolicy InitializeRouteConstraint(bool optional, IRouteConstraint routeConstraint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.EndpointDataSource : object {
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    public abstract virtual IChangeToken GetChangeToken();
    public abstract virtual IReadOnlyList`1<Endpoint> get_Endpoints();
    public virtual IReadOnlyList`1<Endpoint> GetGroupedEndpoints(RouteGroupContext context);
    internal static string GetDebuggerDisplayStringForEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    [CompilerGeneratedAttribute]
internal static void <GetDebuggerDisplayStringForEndpoints>g__FormatValues|4_0(StringBuilder sb, IEnumerable`1<KeyValuePair`2<string, object>> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4164")]
public class Microsoft.AspNetCore.Routing.EndpointGroupNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EndpointGroupName>k__BackingField;
    public string EndpointGroupName { get; }
    public EndpointGroupNameAttribute(string endpointGroupName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointGroupName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.EndpointMiddleware : object {
    internal static string AuthorizationMiddlewareInvokedKey;
    internal static string CorsMiddlewareInvokedKey;
    internal static string AntiforgeryMiddlewareWithEndpointInvokedKey;
    private ILogger _logger;
    private RequestDelegate _next;
    private RouteOptions _routeOptions;
    public EndpointMiddleware(ILogger`1<EndpointMiddleware> logger, RequestDelegate next, IOptions`1<RouteOptions> routeOptions);
    public Task Invoke(HttpContext httpContext);
    private static void ThrowMissingAuthMiddlewareException(Endpoint endpoint);
    private static void ThrowMissingCorsMiddlewareException(Endpoint endpoint);
    private static void ThrowMissingAntiforgeryMiddlewareException(Endpoint endpoint);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointMiddleware/<<Invoke>g__AwaitRequestTask|7_0>d")]
[CompilerGeneratedAttribute]
internal static Task <Invoke>g__AwaitRequestTask|7_0(Endpoint endpoint, Task requestTask, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.EndpointNameAddressScheme : object {
    private DataSourceDependentCache`1<Dictionary`2<string, Endpoint[]>> _cache;
    internal Dictionary`2<string, Endpoint[]> Entries { get; }
    public EndpointNameAddressScheme(EndpointDataSource dataSource);
    internal Dictionary`2<string, Endpoint[]> get_Entries();
    public sealed virtual IEnumerable`1<Endpoint> FindEndpoints(string address);
    private static Dictionary`2<string, Endpoint[]> Initialize(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static string <Initialize>g__GetEndpointName|5_0(Endpoint endpoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4160")]
public class Microsoft.AspNetCore.Routing.EndpointNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EndpointName>k__BackingField;
    public string EndpointName { get; }
    public EndpointNameAttribute(string endpointName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.EndpointNameMetadata : object {
    [CompilerGeneratedAttribute]
private string <EndpointName>k__BackingField;
    public string EndpointName { get; }
    public EndpointNameMetadata(string endpointName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EndpointName();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware : object {
    private static string DiagnosticsEndpointMatchedKey;
    private MatcherFactory _matcherFactory;
    private ILogger _logger;
    private EndpointDataSource _endpointDataSource;
    private DiagnosticListener _diagnosticListener;
    private RoutingMetrics _metrics;
    private RequestDelegate _next;
    private RouteOptions _routeOptions;
    private Task`1<Matcher> _initializationTask;
    public EndpointRoutingMiddleware(MatcherFactory matcherFactory, ILogger`1<EndpointRoutingMiddleware> logger, IEndpointRouteBuilder endpointRouteBuilder, EndpointDataSource rootCompositeEndpointDataSource, DiagnosticListener diagnosticListener, IOptions`1<RouteOptions> routeOptions, RoutingMetrics metrics, RequestDelegate next);
    public Task Invoke(HttpContext httpContext);
    private Task SetRoutingAndContinue(HttpContext httpContext);
    private Task ExecuteShortCircuit(ShortCircuitMetadata shortCircuitMetadata, Endpoint endpoint, HttpContext httpContext);
    private Task`1<Matcher> InitializeAsync();
    private Task`1<Matcher> InitializeCoreAsync();
    private static void ThrowCannotShortCircuitAnAuthRouteException(Endpoint endpoint);
    private static void ThrowCannotShortCircuitACorsRouteException(Endpoint endpoint);
    private static void ThrowCannotShortCircuitAnAntiforgeryRouteException(Endpoint endpoint);
    private void SetMaxRequestBodySize(HttpContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware/<<Invoke>g__AwaitMatcher|10_0>d")]
[CompilerGeneratedAttribute]
internal static Task <Invoke>g__AwaitMatcher|10_0(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task`1<Matcher> matcherTask);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware/<<Invoke>g__AwaitMatch|10_1>d")]
[CompilerGeneratedAttribute]
internal static Task <Invoke>g__AwaitMatch|10_1(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task matchTask);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
internal static void <SetRoutingAndContinue>g__Write|11_0(DiagnosticListener diagnosticListener, HttpContext httpContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware/<<ExecuteShortCircuit>g__AwaitRequestTask|12_0>d")]
[CompilerGeneratedAttribute]
internal static Task <ExecuteShortCircuit>g__AwaitRequestTask|12_0(Endpoint endpoint, Task requestTask, ILogger logger);
}
[AttributeUsageAttribute("4164")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.ExcludeFromDescriptionAttribute : Attribute {
    public bool ExcludeFromDescription { get; }
    public sealed virtual bool get_ExcludeFromDescription();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class Microsoft.AspNetCore.Routing.FallbackMetadata : object {
    [NullableAttribute("1")]
public static FallbackMetadata Instance;
    private static FallbackMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
[AttributeUsageAttribute("68")]
public class Microsoft.AspNetCore.Routing.HostAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Hosts>k__BackingField;
    public IReadOnlyList`1<string> Hosts { get; }
    public HostAttribute(string host);
    public HostAttribute(String[] hosts);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_Hosts();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.HttpMethodMetadata : object {
    [CompilerGeneratedAttribute]
private bool <AcceptCorsPreflight>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <HttpMethods>k__BackingField;
    public bool AcceptCorsPreflight { get; public set; }
    public IReadOnlyList`1<string> HttpMethods { get; }
    public HttpMethodMetadata(IEnumerable`1<string> httpMethods);
    public HttpMethodMetadata(IEnumerable`1<string> httpMethods, bool acceptCorsPreflight);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AcceptCorsPreflight();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AcceptCorsPreflight(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_HttpMethods();
    public virtual string ToString();
}
public interface Microsoft.AspNetCore.Routing.IDataTokensMetadata {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> DataTokens { get; }
    public abstract virtual IReadOnlyDictionary`2<string, object> get_DataTokens();
}
public interface Microsoft.AspNetCore.Routing.IDynamicEndpointMetadata {
    public bool IsDynamic { get; }
    public abstract virtual bool get_IsDynamic();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IEndpointAddressScheme`1 {
    public abstract virtual IEnumerable`1<Endpoint> FindEndpoints(TAddress address);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IEndpointGroupNameMetadata {
    public string EndpointGroupName { get; }
    public abstract virtual string get_EndpointGroupName();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IEndpointNameMetadata {
    public string EndpointName { get; }
    public abstract virtual string get_EndpointName();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IEndpointRouteBuilder {
    public IServiceProvider ServiceProvider { get; }
    public ICollection`1<EndpointDataSource> DataSources { get; }
    public abstract virtual IApplicationBuilder CreateApplicationBuilder();
    public abstract virtual IServiceProvider get_ServiceProvider();
    public abstract virtual ICollection`1<EndpointDataSource> get_DataSources();
}
public interface Microsoft.AspNetCore.Routing.IExcludeFromDescriptionMetadata {
    public bool ExcludeFromDescription { get; }
    public abstract virtual bool get_ExcludeFromDescription();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IHostMetadata {
    public IReadOnlyList`1<string> Hosts { get; }
    public abstract virtual IReadOnlyList`1<string> get_Hosts();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IHttpMethodMetadata {
    public bool AcceptCorsPreflight { get; public set; }
    public IReadOnlyList`1<string> HttpMethods { get; }
    public virtual bool get_AcceptCorsPreflight();
    public virtual void set_AcceptCorsPreflight(bool value);
    public abstract virtual IReadOnlyList`1<string> get_HttpMethods();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IInlineConstraintResolver {
    public abstract virtual IRouteConstraint ResolveConstraint(string inlineConstraint);
}
[NullableContextAttribute("2")]
public interface Microsoft.AspNetCore.Routing.INamedRouter {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public static class Microsoft.AspNetCore.Routing.InlineRouteParameterParser : object {
    [NullableContextAttribute("1")]
public static TemplatePart ParseRouteParameter(string routeParameter);
    private static ConstraintParseResults ParseConstraints(string routeParameter, int currentIndex, int endIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Internal.DfaGraphWriter : object {
    private IServiceProvider _services;
    public DfaGraphWriter(IServiceProvider services);
    public void Write(EndpointDataSource dataSource, TextWriter writer);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.IRouteBuilder {
    public IApplicationBuilder ApplicationBuilder { get; }
    [NullableAttribute("2")]
public IRouter DefaultHandler { get; public set; }
    public IServiceProvider ServiceProvider { get; }
    public IList`1<IRouter> Routes { get; }
    public abstract virtual IApplicationBuilder get_ApplicationBuilder();
    [NullableContextAttribute("2")]
public abstract virtual IRouter get_DefaultHandler();
    [NullableContextAttribute("2")]
public abstract virtual void set_DefaultHandler(IRouter value);
    public abstract virtual IServiceProvider get_ServiceProvider();
    public abstract virtual IList`1<IRouter> get_Routes();
    public abstract virtual IRouter Build();
}
public interface Microsoft.AspNetCore.Routing.IRouteCollection {
    [NullableContextAttribute("1")]
public abstract virtual void Add(IRouter router);
}
[NullableContextAttribute("2")]
public interface Microsoft.AspNetCore.Routing.IRouteNameMetadata {
    public string RouteName { get; }
    public abstract virtual string get_RouteName();
}
public interface Microsoft.AspNetCore.Routing.ISuppressLinkGenerationMetadata {
    public bool SuppressLinkGeneration { get; }
    public abstract virtual bool get_SuppressLinkGeneration();
}
public interface Microsoft.AspNetCore.Routing.ISuppressMatchingMetadata {
    public bool SuppressMatching { get; }
    public abstract virtual bool get_SuppressMatching();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkGeneratorEndpointNameAddressExtensions : object {
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetPathByName(LinkGenerator generator, HttpContext httpContext, string endpointName, object values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetPathByName(LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetPathByName(LinkGenerator generator, string endpointName, object values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetPathByName(LinkGenerator generator, string endpointName, RouteValueDictionary values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetUriByName(LinkGenerator generator, HttpContext httpContext, string endpointName, object values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetUriByName(LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetUriByName(LinkGenerator generator, string endpointName, object values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByName(LinkGenerator generator, string endpointName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkGeneratorRouteValuesAddressExtensions : object {
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetPathByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, object values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetPathByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetPathByRouteValues(LinkGenerator generator, string routeName, object values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetPathByRouteValues(LinkGenerator generator, string routeName, RouteValueDictionary values, PathString pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetUriByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, object values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
public static string GetUriByRouteValues(LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values, string scheme, Nullable`1<HostString> host, Nullable`1<PathString> pathBase, FragmentString fragment, LinkOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static string GetUriByRouteValues(LinkGenerator generator, string routeName, object values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetUriByRouteValues(LinkGenerator generator, string routeName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase, FragmentString fragment, LinkOptions options);
    private static RouteValuesAddress CreateAddress(HttpContext httpContext, string routeName, RouteValueDictionary values);
}
public abstract class Microsoft.AspNetCore.Routing.LinkParser : object {
    [NullableContextAttribute("2")]
public abstract virtual RouteValueDictionary ParsePathByAddress(TAddress address, PathString path);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static RouteValueDictionary ParsePathByEndpointName(LinkParser parser, string endpointName, PathString path);
}
public abstract class Microsoft.AspNetCore.Routing.MatcherPolicy : object {
    public int Order { get; }
    public abstract virtual int get_Order();
    [NullableContextAttribute("1")]
protected static bool ContainsDynamicEndpoints(IReadOnlyList`1<Endpoint> endpoints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.AcceptsMatcherPolicy : MatcherPolicy {
    private static Endpoint Http415Endpoint;
    internal static string Http415EndpointDisplayName;
    internal static string AnyContentType;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<Endpoint> <Comparer>k__BackingField;
    public int Order { get; }
    public IComparer`1<Endpoint> Comparer { get; }
    [CompilerGeneratedAttribute]
public virtual int get_Order();
    [CompilerGeneratedAttribute]
public sealed virtual IComparer`1<Endpoint> get_Comparer();
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private static bool AppliesToEndpointsCore(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    public sealed virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    private static Endpoint CreateRejectionEndpoint();
    public sealed virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
    private static int GetNoContentTypeDestination(ValueTuple`2[] destinations);
    private static ReadOnlyMediaTypeHeaderValue CreateEdgeMediaType(PolicyJumpTableEdge& e);
    private static int GetScore(ReadOnlyMediaTypeHeaderValue mediaType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.AmbiguousMatchException : Exception {
    public AmbiguousMatchException(string message);
    [ObsoleteAttribute]
internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Matching.Candidate : ValueType {
    public Endpoint Endpoint;
    public CandidateFlags Flags;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2[] Slots;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3[] Captures;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3<string, int, int> CatchAll;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2[] ComplexSegments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2[] Constraints;
    public int Score;
    public Candidate(Endpoint endpoint);
    public Candidate(Endpoint endpoint, int score, KeyValuePair`2[] slots, ValueTuple`3[] captures, ValueTuple`3& catchAll, ValueTuple`2[] complexSegments, KeyValuePair`2[] constraints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.Routing.Matching.CandidateSet : object {
    internal CandidateState[] Candidates;
    public int Count { get; }
    public CandidateState& Item { get; }
    public CandidateSet(Endpoint[] endpoints, RouteValueDictionary[] values, Int32[] scores);
    internal CandidateSet(Candidate[] candidates);
    internal CandidateSet(CandidateState[] candidates);
    public int get_Count();
    public CandidateState& get_Item(int index);
    public bool IsValidCandidate(int index);
    internal static bool IsValidCandidate(CandidateState& candidate);
    public void SetValidity(int index, bool value);
    internal static void SetValidity(CandidateState& candidate, bool value);
    [NullableContextAttribute("2")]
public void ReplaceEndpoint(int index, Endpoint endpoint, RouteValueDictionary values);
    public void ExpandEndpoint(int index, IReadOnlyList`1<Endpoint> endpoints, IComparer`1<Endpoint> comparer);
    private int GetOriginalScore(int index);
    private void ValidateUniqueScore(int index);
    [DoesNotReturnAttribute]
private static void ThrowIndexArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
private static void ThrowArgumentNullException(string parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Matching.CandidateState : ValueType {
    [CompilerGeneratedAttribute]
private Endpoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Values>k__BackingField;
    public Endpoint Endpoint { get; }
    public int Score { get; }
    [NullableAttribute("2")]
public RouteValueDictionary Values { get; internal set; }
    internal CandidateState(Endpoint endpoint, int score);
    internal CandidateState(Endpoint endpoint, RouteValueDictionary values, int score);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Endpoint get_Endpoint();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Score();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RouteValueDictionary get_Values();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Values(RouteValueDictionary value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.DataSourceDependentMatcher : Matcher {
    private Func`1<MatcherBuilder> _matcherBuilderFactory;
    private DataSourceDependentCache`1<Matcher> _cache;
    internal Matcher CurrentMatcher { get; }
    public DataSourceDependentMatcher(EndpointDataSource dataSource, Lifetime lifetime, Func`1<MatcherBuilder> matcherBuilderFactory);
    internal Matcher get_CurrentMatcher();
    public virtual Task MatchAsync(HttpContext httpContext);
    private Matcher CreateMatcher(IReadOnlyList`1<Endpoint> endpoints);
}
internal class Microsoft.AspNetCore.Routing.Matching.DefaultEndpointSelector : EndpointSelector {
    [NullableContextAttribute("1")]
public virtual Task SelectAsync(HttpContext httpContext, CandidateSet candidateSet);
    internal static void Select(HttpContext httpContext, Span`1<CandidateState> candidateState);
    private static void ProcessFinalCandidates(HttpContext httpContext, Span`1<CandidateState> candidateState);
    private static void ReportAmbiguity(Span`1<CandidateState> candidateState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcher : Matcher {
    private static int CandidateSetStackSize;
    private ILogger _logger;
    private EndpointSelector _selector;
    private DfaState[] _states;
    private int _maxSegmentCount;
    private bool _isDefaultEndpointSelector;
    public DfaMatcher(ILogger`1<DfaMatcher> logger, EndpointSelector selector, DfaState[] states, int maxSegmentCount);
    [SkipLocalsInitAttribute]
public sealed virtual Task MatchAsync(HttpContext httpContext);
    internal ValueTuple`2<Candidate[], IEndpointSelectorPolicy[]> FindCandidateSet(HttpContext httpContext, string path, ReadOnlySpan`1<PathSegment> segments);
    private static void ProcessCaptures(KeyValuePair`2[] slots, ValueTuple`3[] captures, string path, ReadOnlySpan`1<PathSegment> segments);
    private static void ProcessCatchAll(KeyValuePair`2[] slots, ValueTuple`3& catchAll, string path, ReadOnlySpan`1<PathSegment> segments);
    private bool ProcessComplexSegments(Endpoint endpoint, ValueTuple`2[] complexSegments, string path, ReadOnlySpan`1<PathSegment> segments, RouteValueDictionary values);
    private bool ProcessConstraints(Endpoint endpoint, KeyValuePair`2[] constraints, HttpContext httpContext, RouteValueDictionary values);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Matching.DfaMatcher/<SelectEndpointWithPoliciesAsync>d__13")]
private Task SelectEndpointWithPoliciesAsync(HttpContext httpContext, IEndpointSelectorPolicy[] policies, CandidateSet candidateSet);
}
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcherBuilder : MatcherBuilder {
    private List`1<RouteEndpoint> _endpoints;
    private ILoggerFactory _loggerFactory;
    private ParameterPolicyFactory _parameterPolicyFactory;
    private EndpointSelector _selector;
    private IEndpointSelectorPolicy[] _endpointSelectorPolicies;
    private INodeBuilderPolicy[] _nodeBuilders;
    private EndpointComparer _comparer;
    private Dictionary`2<string, int> _assignments;
    private List`1<KeyValuePair`2<string, object>> _slots;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`3<string, int, int>> _captures;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<RoutePatternPathSegment, int>> _complexSegments;
    private List`1<KeyValuePair`2<string, IRouteConstraint>> _constraints;
    private int _stateIndex;
    internal EndpointComparer Comparer { get; }
    public DfaMatcherBuilder(ILoggerFactory loggerFactory, ParameterPolicyFactory parameterPolicyFactory, EndpointSelector selector, IEnumerable`1<MatcherPolicy> policies);
    internal EndpointComparer get_Comparer();
    public virtual void AddEndpoint(RouteEndpoint endpoint);
    public DfaNode BuildDfaTree(bool includeLabel);
    private static void AddLiteralNode(bool includeLabel, List`1<DfaNode> nextParents, DfaNode parent, string literal);
    private static RoutePatternPathSegment GetCurrentSegment(RouteEndpoint endpoint, int depth);
    private static int GetPrecedenceDigitAtDepth(RouteEndpoint endpoint, int depth);
    public virtual Matcher Build();
    private int AddNode(DfaNode node, DfaState[] states, int exitDestination);
    private static PolicyJumpTable BuildPolicy(int exitDestination, INodeBuilderPolicy nodeBuilder, PolicyJumpTableEdge[] policyEntries);
    internal Candidate[] CreateCandidates(IReadOnlyList`1<Endpoint> endpoints);
    internal Candidate CreateCandidate(Endpoint endpoint, int score);
    private static bool HasAdditionalRequiredSegments(RouteEndpoint endpoint, int depth);
    private void ApplyPolicies(DfaNode node);
    private static ValueTuple`3<INodeBuilderPolicy[], IEndpointComparerPolicy[], IEndpointSelectorPolicy[]> ExtractPolicies(IEnumerable`1<MatcherPolicy> policies);
    private static bool TryGetRequiredValue(RoutePattern routePattern, RoutePatternParameterPart parameterPart, Object& value);
    [CompilerGeneratedAttribute]
private int <AddNode>g__Transition|24_0(DfaNode next, <>c__DisplayClass24_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaMatcherFactory : MatcherFactory {
    private IServiceProvider _services;
    public DfaMatcherFactory(IServiceProvider services);
    public virtual Matcher CreateMatcher(EndpointDataSource dataSource);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaNode : object {
    [CompilerGeneratedAttribute]
private int <PathDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Endpoint> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DfaNode> <Literals>k__BackingField;
    [CompilerGeneratedAttribute]
private DfaNode <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DfaNode <CatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeBuilderPolicy <NodeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, DfaNode> <PolicyEdges>k__BackingField;
    public int PathDepth { get; public set; }
    public string Label { get; public set; }
    public List`1<Endpoint> Matches { get; private set; }
    public Dictionary`2<string, DfaNode> Literals { get; private set; }
    public DfaNode Parameters { get; public set; }
    public DfaNode CatchAll { get; public set; }
    public INodeBuilderPolicy NodeBuilder { get; public set; }
    public Dictionary`2<object, DfaNode> PolicyEdges { get; private set; }
    [CompilerGeneratedAttribute]
public int get_PathDepth();
    [CompilerGeneratedAttribute]
public void set_PathDepth(int value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public List`1<Endpoint> get_Matches();
    [CompilerGeneratedAttribute]
private void set_Matches(List`1<Endpoint> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DfaNode> get_Literals();
    [CompilerGeneratedAttribute]
private void set_Literals(Dictionary`2<string, DfaNode> value);
    [CompilerGeneratedAttribute]
public DfaNode get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(DfaNode value);
    [CompilerGeneratedAttribute]
public DfaNode get_CatchAll();
    [CompilerGeneratedAttribute]
public void set_CatchAll(DfaNode value);
    [CompilerGeneratedAttribute]
public INodeBuilderPolicy get_NodeBuilder();
    [CompilerGeneratedAttribute]
public void set_NodeBuilder(INodeBuilderPolicy value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, DfaNode> get_PolicyEdges();
    [CompilerGeneratedAttribute]
private void set_PolicyEdges(Dictionary`2<object, DfaNode> value);
    public void AddPolicyEdge(object state, DfaNode node);
    public void AddLiteral(string literal, DfaNode node);
    public void AddMatch(Endpoint endpoint);
    public void AddMatches(IEnumerable`1<Endpoint> endpoints);
    public void Visit(Action`1<DfaNode> visitor);
    private string DebuggerToString();
    [CompilerGeneratedAttribute]
private string <DebuggerToString>b__37_0(KeyValuePair`2<string, DfaNode> kvp);
    [CompilerGeneratedAttribute]
private string <DebuggerToString>g__FormatNode|37_1(DfaNode other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.Matching.DfaState : ValueType {
    public Candidate[] Candidates;
    public IEndpointSelectorPolicy[] Policies;
    public JumpTable PathTransitions;
    public PolicyJumpTable PolicyTransitions;
    public DfaState(Candidate[] candidates, IEndpointSelectorPolicy[] policies, JumpTable pathTransitions, PolicyJumpTable policyTransitions);
    public string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.DictionaryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private FrozenDictionary`2<string, int> _dictionary;
    public DictionaryJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.EndpointComparer : object {
    private IComparer`1[] _comparers;
    public EndpointComparer(IEndpointComparerPolicy[] policies);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(Endpoint x, Endpoint y);
    private static int ComparePattern(Endpoint x, Endpoint y);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Endpoint x, Endpoint y);
    public sealed virtual int GetHashCode(Endpoint obj);
    private int CompareCore(Endpoint x, Endpoint y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Matching.EndpointMetadataComparer : object {
    private IServiceProvider _services;
    private IComparer`1[] _comparers;
    private IComparer`1[] Comparers { get; }
    internal EndpointMetadataComparer(IServiceProvider services);
    private IComparer`1[] get_Comparers();
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.AspNetCore.Http.Endpoint>.Compare(Endpoint x, Endpoint y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.Matching.EndpointMetadataComparer`1 : object {
    public static EndpointMetadataComparer`1<TMetadata> Default;
    private static EndpointMetadataComparer`1();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(Endpoint x, Endpoint y);
    protected virtual TMetadata GetMetadata(Endpoint endpoint);
    [NullableContextAttribute("2")]
protected virtual int CompareMetadata(TMetadata x, TMetadata y);
}
public abstract class Microsoft.AspNetCore.Routing.Matching.EndpointSelector : object {
    [NullableContextAttribute("1")]
public abstract virtual Task SelectAsync(HttpContext httpContext, CandidateSet candidates);
}
internal static class Microsoft.AspNetCore.Routing.Matching.FastPathTokenizer : object {
    public static int Tokenize(string path, Span`1<PathSegment> segments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Matching.HostMatcherPolicy : MatcherPolicy {
    private static string WildcardHost;
    private static string WildcardPrefix;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<Endpoint> <Comparer>k__BackingField;
    public int Order { get; }
    public IComparer`1<Endpoint> Comparer { get; }
    [CompilerGeneratedAttribute]
public virtual int get_Order();
    [CompilerGeneratedAttribute]
public sealed virtual IComparer`1<Endpoint> get_Comparer();
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private static bool AppliesToEndpointsCore(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    private static EdgeKey CreateEdgeKey(string host);
    public sealed virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    private static EdgeKey[] GetEdgeKeys(Endpoint endpoint);
    public sealed virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
    private static int GetScore(EdgeKey& key);
    private static ValueTuple`2<string, Nullable`1<int>> GetHostAndPort(HttpContext httpContext);
}
internal class Microsoft.AspNetCore.Routing.Matching.HttpMethodDictionaryPolicyJumpTable : PolicyJumpTable {
    private int _exitDestination;
    private Dictionary`2<string, int> _destinations;
    private int _corsPreflightExitDestination;
    private Dictionary`2<string, int> _corsPreflightDestinations;
    private bool _supportsCorsPreflight;
    public HttpMethodDictionaryPolicyJumpTable(int exitDestination, Dictionary`2<string, int> destinations, int corsPreflightExitDestination, Dictionary`2<string, int> corsPreflightDestinations);
    [NullableContextAttribute("1")]
public virtual int GetDestination(HttpContext httpContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Matching.HttpMethodMatcherPolicy : MatcherPolicy {
    internal static string PreflightHttpMethod;
    internal static string Http405EndpointDisplayName;
    internal static string AnyMethod;
    public IComparer`1<Endpoint> Comparer { get; }
    public int Order { get; }
    private static HttpMethodMatcherPolicy();
    public sealed virtual IComparer`1<Endpoint> get_Comparer();
    public virtual int get_Order();
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private sealed virtual override bool Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy.AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    private static bool AppliesToEndpointsCore(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    public sealed virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
    private static Endpoint CreateRejectionEndpoint(IEnumerable`1<string> httpMethods);
    private static bool ContainsHttpMethod(List`1<string> httpMethods, string httpMethod);
    internal static bool IsCorsPreflightRequest(HttpContext httpContext, string httpMethod, StringValues& accessControlRequestMethod);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IReadOnlyList`1<string>, bool> <GetEdges>g__GetHttpMethods|11_0(Endpoint e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.HttpMethodSingleEntryPolicyJumpTable : PolicyJumpTable {
    private int _exitDestination;
    private string _method;
    private int _destination;
    private int _corsPreflightExitDestination;
    private int _corsPreflightDestination;
    private bool _supportsCorsPreflight;
    public HttpMethodSingleEntryPolicyJumpTable(int exitDestination, string method, int destination, bool supportsCorsPreflight, int corsPreflightExitDestination, int corsPreflightDestination);
    public virtual int GetDestination(HttpContext httpContext);
}
internal interface Microsoft.AspNetCore.Routing.Matching.ICachableParameterPolicy {
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.Matching.IEndpointComparerPolicy {
    public IComparer`1<Endpoint> Comparer { get; }
    public abstract virtual IComparer`1<Endpoint> get_Comparer();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.Matching.IEndpointSelectorPolicy {
    public abstract virtual bool AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
}
[RequiresDynamicCodeAttribute("ILEmitTrieFactory uses runtime IL generation.")]
internal static class Microsoft.AspNetCore.Routing.Matching.ILEmitTrieFactory : object {
    public static int NotAscii;
    public static Func`4<string, int, int, int> Create(int defaultDestination, int exitDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize);
    internal static bool ShouldVectorize(ValueTuple`2[] entries);
    private static void GenerateMethodBody(ILGenerator il, int defaultDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize);
    private static void EmitTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    private static void EmitVectorizedTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    private static void EmitSingleCharacterTable(ILGenerator il, ValueTuple`2[] entries, int index, int length, Locals locals, Labels labels, Methods methods);
    public static void EmitReturnDestination(ILGenerator il, ValueTuple`2[] entries);
    private static ulong GetUInt64Key(string text, int index);
    private static ushort GetUInt16Key(string text, int index);
}
[RequiresDynamicCodeAttribute("ILEmitTrieJumpTable uses runtime IL generation.")]
internal class Microsoft.AspNetCore.Routing.Matching.ILEmitTrieJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _entries;
    private Nullable`1<bool> _vectorize;
    private JumpTable _fallback;
    private object _lock;
    private bool _initializing;
    private Task _task;
    internal Func`3<string, PathSegment, int> _getDestination;
    public ILEmitTrieJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries, Nullable`1<bool> vectorize, JumpTable fallback);
    public virtual int GetDestination(string path, PathSegment segment);
    private int FallbackGetDestination(string path, PathSegment segment);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Matching.ILEmitTrieJumpTable/<InitializeILDelegateAsync>d__12")]
internal Task InitializeILDelegateAsync();
    internal void InitializeILDelegate();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Routing.Matching.INodeBuilderPolicy {
    public abstract virtual bool AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual IReadOnlyList`1<PolicyNodeEdge> GetEdges(IReadOnlyList`1<Endpoint> endpoints);
    public abstract virtual PolicyJumpTable BuildJumpTable(int exitDestination, IReadOnlyList`1<PolicyJumpTableEdge> edges);
}
public interface Microsoft.AspNetCore.Routing.Matching.IParameterLiteralNodeMatchingPolicy {
    [NullableContextAttribute("1")]
public abstract virtual bool MatchesLiteral(string parameterName, string literal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal abstract class Microsoft.AspNetCore.Routing.Matching.JumpTable : object {
    public abstract virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal static class Microsoft.AspNetCore.Routing.Matching.JumpTableBuilder : object {
    public static int InvalidDestination;
    [NullableContextAttribute("1")]
public static JumpTable Build(int defaultDestination, int exitDestination, ValueTuple`2[] pathEntries);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050")]
internal static JumpTable <Build>g__MakeILEmitTrieJumpTableIfSupported|1_0(int defaultDestination, int exitDestination, ValueTuple`2[] pathEntries, JumpTable fallback);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.LinearSearchJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _entries;
    public LinearSearchJumpTable(int defaultDestination, int exitDestination, ValueTuple`2[] entries);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
internal abstract class Microsoft.AspNetCore.Routing.Matching.Matcher : object {
    [NullableContextAttribute("1")]
public abstract virtual Task MatchAsync(HttpContext httpContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Routing.Matching.MatcherBuilder : object {
    public abstract virtual void AddEndpoint(RouteEndpoint endpoint);
    public abstract virtual Matcher Build();
}
internal abstract class Microsoft.AspNetCore.Routing.Matching.MatcherFactory : object {
    [NullableContextAttribute("1")]
public abstract virtual Matcher CreateMatcher(EndpointDataSource dataSource);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Matching.PathSegment : ValueType {
    public int Start;
    public int Length;
    public PathSegment(int start, int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PathSegment other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.Matching.PolicyJumpTable : object {
    public abstract virtual int GetDestination(HttpContext httpContext);
    internal virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Routing.Matching.PolicyJumpTableEdge : ValueType {
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Destination>k__BackingField;
    public object State { get; }
    public int Destination { get; }
    public PolicyJumpTableEdge(object state, int destination);
    [CompilerGeneratedAttribute]
public object get_State();
    [CompilerGeneratedAttribute]
public int get_Destination();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Routing.Matching.PolicyNodeEdge : ValueType {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Endpoint> <Endpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public IReadOnlyList`1<Endpoint> Endpoints { get; }
    public object State { get; }
    public PolicyNodeEdge(object state, IReadOnlyList`1<Endpoint> endpoints);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Endpoint> get_Endpoints();
    [CompilerGeneratedAttribute]
public object get_State();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.SingleEntryAsciiJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private string _text;
    private int _destination;
    public SingleEntryAsciiJumpTable(int defaultDestination, int exitDestination, string text, int destination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.SingleEntryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    private string _text;
    private int _destination;
    public SingleEntryJumpTable(int defaultDestination, int exitDestination, string text, int destination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Matching.ZeroEntryJumpTable : JumpTable {
    private int _defaultDestination;
    private int _exitDestination;
    public ZeroEntryJumpTable(int defaultDestination, int exitDestination);
    public virtual int GetDestination(string path, PathSegment segment);
    public virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.NullRouter : object {
    public static NullRouter Instance;
    private static NullRouter();
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    public sealed virtual Task RouteAsync(RouteContext context);
}
internal static class Microsoft.AspNetCore.Routing.ParameterPolicyActivator : object {
    [NullableContextAttribute("1")]
public static T ResolveParameterPolicy(IDictionary`2<string, Type> inlineParameterPolicyMap, IServiceProvider serviceProvider, string inlineParameterPolicy, String& parameterPolicyKey);
    private static bool ResolveParameterPolicyTypeAndArgument(IDictionary`2<string, Type> inlineParameterPolicyMap, string inlineParameterPolicy, String& policyKey, String& argumentString, Type& policyType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2006:UnrecognizedReflectionPattern")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070")]
private static IParameterPolicy CreateParameterPolicy(IServiceProvider serviceProvider, Type parameterPolicyType, string argumentString);
    private static List`1<ConstructorInfo> GetMatchingConstructors(ConstructorInfo[] constructors, IServiceProvider serviceProvider, int argumentsLength);
    private static ConstructorInfo GetLongestConstructor(List`1<ConstructorInfo> constructors, Type parameterPolicyType);
    private static int GetNonConvertableParameterTypeCount(IServiceProvider serviceProvider, ParameterInfo[] parameters);
    private static Object[] ConvertArguments(IServiceProvider serviceProvider, ParameterInfo[] parameterInfos, String[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.ParameterPolicyFactory : object {
    public abstract virtual IParameterPolicy Create(RoutePatternParameterPart parameter, string inlineText);
    public abstract virtual IParameterPolicy Create(RoutePatternParameterPart parameter, IParameterPolicy parameterPolicy);
    public IParameterPolicy Create(RoutePatternParameterPart parameter, RoutePatternParameterPolicyReference reference);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Routing.PathTokenizer : ValueType {
    private string _path;
    private int _count;
    public int Count { get; }
    public StringSegment Item { get; }
    public PathTokenizer(PathString path);
    public sealed virtual int get_Count();
    public sealed virtual StringSegment get_Item(int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<StringSegment> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Primitives.StringSegment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.AspNetCore.Routing.Patterns.DefaultRoutePatternTransformer : RoutePatternTransformer {
    private ParameterPolicyFactory _policyFactory;
    public DefaultRoutePatternTransformer(ParameterPolicyFactory policyFactory);
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.Consider using a different overload to avoid this issue.")]
public virtual RoutePattern SubstituteRequiredValues(RoutePattern original, object requiredValues);
    public virtual RoutePattern SubstituteRequiredValues(RoutePattern original, RouteValueDictionary requiredValues);
    private bool MatchesConstraints(RoutePattern pattern, RoutePatternParameterPart parameter, string key, RouteValueDictionary requiredValues);
    private static void RemoveParameterDefault(List`1<RoutePatternPathSegment> segments, List`1<RoutePatternParameterPart> parameters, RoutePatternParameterPart parameter);
}
internal static class Microsoft.AspNetCore.Routing.Patterns.RouteParameterParser : object {
    [NullableContextAttribute("1")]
public static RoutePatternParameterPart ParseRouteParameter(string parameter);
    private static ParameterPolicyParseResults ParseConstraints(string text, int currentIndex, int endIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePattern : object {
    public static object RequiredValueAny;
    private static string SeparatorString;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> <ParameterPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <RequiredValues>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <InboundPrecedence>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <OutboundPrecedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawText>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternParameterPart> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternPathSegment> <PathSegments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> ParameterPolicies { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> RequiredValues { get; }
    public decimal InboundPrecedence { get; }
    public decimal OutboundPrecedence { get; }
    [NullableAttribute("2")]
public string RawText { get; }
    public IReadOnlyList`1<RoutePatternParameterPart> Parameters { get; }
    public IReadOnlyList`1<RoutePatternPathSegment> PathSegments { get; }
    internal RoutePattern(string rawText, IReadOnlyDictionary`2<string, object> defaults, IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> parameterPolicies, IReadOnlyDictionary`2<string, object> requiredValues, IReadOnlyList`1<RoutePatternParameterPart> parameters, IReadOnlyList`1<RoutePatternPathSegment> pathSegments);
    private static RoutePattern();
    [NullableContextAttribute("2")]
internal static bool IsRequiredValueAny(object value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> get_ParameterPolicies();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_RequiredValues();
    [CompilerGeneratedAttribute]
public decimal get_InboundPrecedence();
    [CompilerGeneratedAttribute]
public decimal get_OutboundPrecedence();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_RawText();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternParameterPart> get_Parameters();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternPathSegment> get_PathSegments();
    public RoutePatternParameterPart GetParameter(string name);
    internal string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternException : Exception {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    [ObsoleteAttribute]
private RoutePatternException(SerializationInfo info, StreamingContext context);
    public RoutePatternException(string pattern, string message);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.AspNetCore.Routing.Patterns.RoutePatternFactory : object {
    private static IReadOnlyDictionary`2<string, object> EmptyDictionary;
    private static IReadOnlyDictionary`2<string, IReadOnlyList`1<RoutePatternParameterPolicyReference>> EmptyPoliciesDictionary;
    private static RoutePatternFactory();
    public static RoutePattern Parse(string pattern);
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Parse(string pattern, object defaults, object parameterPolicies);
    public static RoutePattern Parse(string pattern, RouteValueDictionary defaults, RouteValueDictionary parameterPolicies);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Parse(string pattern, object defaults, object parameterPolicies, object requiredValues);
    [NullableContextAttribute("2")]
public static RoutePattern Parse(string pattern, RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, RouteValueDictionary requiredValues);
    public static RoutePattern Pattern(IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(string rawText, IEnumerable`1<RoutePatternPathSegment> segments);
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Pattern(object defaults, object parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Pattern(string rawText, object defaults, object parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    [NullableContextAttribute("2")]
public static RoutePattern Pattern(string rawText, RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, IEnumerable`1<RoutePatternPathSegment> segments);
    public static RoutePattern Pattern(RoutePatternPathSegment[] segments);
    public static RoutePattern Pattern(string rawText, RoutePatternPathSegment[] segments);
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Pattern(object defaults, object parameterPolicies, RoutePatternPathSegment[] segments);
    public static RoutePattern Pattern(RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, RoutePatternPathSegment[] segments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
public static RoutePattern Pattern(string rawText, object defaults, object parameterPolicies, RoutePatternPathSegment[] segments);
    [NullableContextAttribute("2")]
public static RoutePattern Pattern(string rawText, RouteValueDictionary defaults, RouteValueDictionary parameterPolicies, RoutePatternPathSegment[] segments);
    private static RoutePattern PatternCore(string rawText, RouteValueDictionary defaults, Dictionary`2<string, List`1<RoutePatternParameterPolicyReference>> parameterPolicyReferences, RouteValueDictionary requiredValues, IEnumerable`1<RoutePatternPathSegment> segments);
    private static Dictionary`2<string, List`1<RoutePatternParameterPolicyReference>> CreateRoutePatternPolicyReferences(RouteValueDictionary parameterPolicies);
    public static RoutePatternPathSegment Segment(IEnumerable`1<RoutePatternPart> parts);
    public static RoutePatternPathSegment Segment(RoutePatternPart[] parts);
    private static RoutePatternPathSegment SegmentCore(RoutePatternPart[] parts);
    public static RoutePatternLiteralPart LiteralPart(string content);
    private static RoutePatternLiteralPart LiteralPartCore(string content);
    public static RoutePatternSeparatorPart SeparatorPart(string content);
    private static RoutePatternSeparatorPart SeparatorPartCore(string content);
    public static RoutePatternParameterPart ParameterPart(string parameterName);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, IEnumerable`1<RoutePatternParameterPolicyReference> parameterPolicies);
    public static RoutePatternParameterPart ParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    private static RoutePatternParameterPart ParameterPartCore(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    private static RoutePatternParameterPart ParameterPartCore(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies, bool encodeSlashes);
    public static RoutePatternParameterPolicyReference Constraint(object constraint);
    public static RoutePatternParameterPolicyReference Constraint(IRouteConstraint constraint);
    public static RoutePatternParameterPolicyReference Constraint(string constraint);
    public static RoutePatternParameterPolicyReference ParameterPolicy(IParameterPolicy parameterPolicy);
    public static RoutePatternParameterPolicyReference ParameterPolicy(string parameterPolicy);
    public static RoutePattern Combine(RoutePattern left, RoutePattern right);
    internal static IReadOnlyList`1<T> CombineLists(IReadOnlyList`1<T> leftList, IReadOnlyList`1<T> rightList, Func`3<int, string, Action`1<T>> checkDuplicates, string rawText);
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(string parameterPolicy);
    private static RoutePatternParameterPolicyReference ParameterPolicyCore(IParameterPolicy parameterPolicy);
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameters which may be trimmed if not referenced directly. Initialize a RouteValueDictionary with route values to avoid this issue.")]
private static RouteValueDictionary Wrap(object values);
    [CompilerGeneratedAttribute]
internal static RoutePatternPathSegment <PatternCore>g__VisitSegment|19_2(RoutePatternPathSegment segment, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static RoutePatternPart <PatternCore>g__VisitPart|19_3(RoutePatternPart part, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<string, TValue> <Combine>g__CombineDictionaries|40_0(IReadOnlyDictionary`2<string, TValue> leftDictionary, IReadOnlyDictionary`2<string, TValue> rightDictionary, string rawText, string dictionaryName);
    [CompilerGeneratedAttribute]
internal static Action`1<RoutePatternParameterPart> <Combine>g__CheckDuplicateParameters|40_1(int parameterCount, string rawText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternLiteralPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; }
    internal RoutePatternLiteralPart(string content);
    [CompilerGeneratedAttribute]
public string get_Content();
    internal virtual string DebuggerToString();
}
public enum Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterKind : Enum {
    public int value__;
    public static RoutePatternParameterKind Standard;
    public static RoutePatternParameterKind Optional;
    public static RoutePatternParameterKind CatchAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternParameterPolicyReference> <ParameterPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSlashes>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePatternParameterKind <ParameterKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IReadOnlyList`1<RoutePatternParameterPolicyReference> ParameterPolicies { get; }
    public bool EncodeSlashes { get; }
    [NullableAttribute("2")]
public object Default { get; }
    public bool IsCatchAll { get; }
    public bool IsOptional { get; }
    public RoutePatternParameterKind ParameterKind { get; }
    public string Name { get; }
    internal RoutePatternParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies);
    internal RoutePatternParameterPart(string parameterName, object default, RoutePatternParameterKind parameterKind, RoutePatternParameterPolicyReference[] parameterPolicies, bool encodeSlashes);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternParameterPolicyReference> get_ParameterPolicies();
    [CompilerGeneratedAttribute]
public bool get_EncodeSlashes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Default();
    public bool get_IsCatchAll();
    public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public RoutePatternParameterKind get_ParameterKind();
    [CompilerGeneratedAttribute]
public string get_Name();
    internal virtual string DebuggerToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParameterPolicyReference : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterPolicy <ParameterPolicy>k__BackingField;
    public string Content { get; }
    public IParameterPolicy ParameterPolicy { get; }
    [NullableContextAttribute("1")]
internal RoutePatternParameterPolicyReference(string content);
    [NullableContextAttribute("1")]
internal RoutePatternParameterPolicyReference(IParameterPolicy parameterPolicy);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public IParameterPolicy get_ParameterPolicy();
    private string DebuggerToString();
}
internal static class Microsoft.AspNetCore.Routing.Patterns.RoutePatternParser : object {
    private static char Separator;
    private static char OpenBrace;
    private static char CloseBrace;
    private static char QuestionMark;
    private static string PeriodString;
    internal static SearchValues`1<char> InvalidParameterNameChars;
    private static RoutePatternParser();
    public static RoutePattern Parse(string pattern);
    private static bool ParseSegment(Context context, List`1<RoutePatternPathSegment> segments);
    private static bool ParseParameter(Context context, List`1<RoutePatternPart> parts);
    private static bool ParseLiteral(Context context, List`1<RoutePatternPart> parts);
    private static bool IsAllValid(Context context, List`1<RoutePatternPathSegment> segments);
    private static bool IsSegmentValid(Context context, List`1<RoutePatternPart> parts);
    private static bool IsValidParameterName(Context context, string parameterName);
    private static bool IsValidLiteral(Context context, string literal);
    private static string TrimPrefix(string routePattern);
}
public abstract class Microsoft.AspNetCore.Routing.Patterns.RoutePatternPart : object {
    [CompilerGeneratedAttribute]
private RoutePatternPartKind <PartKind>k__BackingField;
    public RoutePatternPartKind PartKind { get; }
    public bool IsLiteral { get; }
    public bool IsParameter { get; }
    public bool IsSeparator { get; }
    private protected RoutePatternPart(RoutePatternPartKind partKind);
    [CompilerGeneratedAttribute]
public RoutePatternPartKind get_PartKind();
    public bool get_IsLiteral();
    public bool get_IsParameter();
    public bool get_IsSeparator();
    [NullableContextAttribute("1")]
internal abstract virtual string DebuggerToString();
}
public enum Microsoft.AspNetCore.Routing.Patterns.RoutePatternPartKind : Enum {
    public int value__;
    public static RoutePatternPartKind Literal;
    public static RoutePatternPartKind Parameter;
    public static RoutePatternPartKind Separator;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternPathSegment : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RoutePatternPart> <Parts>k__BackingField;
    public bool IsSimple { get; }
    public IReadOnlyList`1<RoutePatternPart> Parts { get; }
    internal RoutePatternPathSegment(IReadOnlyList`1<RoutePatternPart> parts);
    public bool get_IsSimple();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RoutePatternPart> get_Parts();
    internal string DebuggerToString();
    internal static string DebuggerToString(IReadOnlyList`1<RoutePatternPart> parts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Patterns.RoutePatternSeparatorPart : RoutePatternPart {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; }
    internal RoutePatternSeparatorPart(string content);
    [CompilerGeneratedAttribute]
public string get_Content();
    internal virtual string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.Patterns.RoutePatternTransformer : object {
    [RequiresUnreferencedCodeAttribute("This API may perform reflection on supplied parameter which may be trimmed if not referenced directly.Consider using a different overload to avoid this issue.")]
public abstract virtual RoutePattern SubstituteRequiredValues(RoutePattern original, object requiredValues);
    public virtual RoutePattern SubstituteRequiredValues(RoutePattern original, RouteValueDictionary requiredValues);
}
internal static class Microsoft.AspNetCore.Routing.RequestDelegateFilterPipelineBuilder : object {
    [NullableContextAttribute("1")]
public static RequestDelegate Create(RequestDelegate requestDelegate, RequestDelegateFactoryOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions : object {
    [ExtensionAttribute]
public static IRouteBuilder MapRoute(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareRoute(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapDelete(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareDelete(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapDelete(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapGet(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareGet(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapGet(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapPost(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewarePost(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapPost(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapPut(IRouteBuilder builder, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewarePut(IRouteBuilder builder, string template, Action`1<IApplicationBuilder> action);
    [ExtensionAttribute]
public static IRouteBuilder MapPut(IRouteBuilder builder, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapVerb(IRouteBuilder builder, string verb, string template, Func`4<HttpRequest, HttpResponse, RouteData, Task> handler);
    [ExtensionAttribute]
public static IRouteBuilder MapVerb(IRouteBuilder builder, string verb, string template, RequestDelegate handler);
    [ExtensionAttribute]
public static IRouteBuilder MapMiddlewareVerb(IRouteBuilder builder, string verb, string template, Action`1<IApplicationBuilder> action);
    private static IInlineConstraintResolver GetConstraintResolver(IRouteBuilder builder);
}
internal static class Microsoft.AspNetCore.Routing.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentMustBeGreaterThanOrEqualTo { get; }
    internal static string RangeConstraint_MinShouldBeLessThanOrEqualToMax { get; }
    internal static string PropertyOfTypeCannotBeNull { get; }
    internal static string NamedRoutes_AmbiguousRoutesFound { get; }
    internal static string DefaultHandler_MustBeSet { get; }
    internal static string DefaultInlineConstraintResolver_AmbiguousCtors { get; }
    internal static string DefaultInlineConstraintResolver_CouldNotFindCtor { get; }
    internal static string DefaultInlineConstraintResolver_TypeNotConstraint { get; }
    internal static string TemplateRoute_CannotHaveCatchAllInMultiSegment { get; }
    internal static string TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveParameters { get; }
    internal static string TemplateRoute_CannotHaveConsecutiveSeparators { get; }
    internal static string TemplateRoute_CatchAllCannotBeOptional { get; }
    internal static string TemplateRoute_OptionalCannotHaveDefaultValue { get; }
    internal static string TemplateRoute_CatchAllMustBeLast { get; }
    internal static string TemplateRoute_InvalidLiteral { get; }
    internal static string TemplateRoute_InvalidParameterName { get; }
    internal static string TemplateRoute_InvalidRouteTemplate { get; }
    internal static string TemplateRoute_MismatchedParameter { get; }
    internal static string TemplateRoute_RepeatedParameter { get; }
    internal static string RouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint { get; }
    internal static string RouteConstraintBuilder_CouldNotResolveConstraint { get; }
    internal static string TemplateRoute_UnescapedBrace { get; }
    internal static string TemplateRoute_OptionalParameterCanbBePrecededByPeriod { get; }
    internal static string TemplateRoute_OptionalParameterHasTobeTheLast { get; }
    internal static string AttributeRoute_DifferentLinkGenerationEntries_SameName { get; }
    internal static string UnableToFindServices { get; }
    internal static string TemplateRoute_Exception { get; }
    internal static string AmbiguousEndpoints { get; }
    internal static string Argument_NullOrEmpty { get; }
    internal static string RoutePatternBuilder_CollectionCannotBeEmpty { get; }
    internal static string ConstraintMustBeStringOrConstraint { get; }
    internal static string RoutePattern_InvalidConstraintReference { get; }
    internal static string RoutePattern_InvalidParameterConstraintReference { get; }
    internal static string RoutePattern_ConstraintReferenceNotFound { get; }
    internal static string RoutePattern_InvalidStringConstraintReference { get; }
    internal static string DuplicateEndpointNameEntry { get; }
    internal static string DuplicateEndpointNameHeader { get; }
    internal static string FormatterMapping_MediaTypeInvalid { get; }
    internal static string MapGroup_ChangingRoutePatternUnsupported { get; }
    internal static string MapGroup_CustomEndpointUnsupported { get; }
    internal static string MapGroup_RepeatedDictionaryEntry { get; }
    internal static string RouteEndpointDataSource_ConventionsCannotBeModifiedAfterBuild { get; }
    internal static string RouteEndpointDataSource_RequestDelegateCannotBeCalledBeforeBuild { get; }
    internal static string RegexRouteContraint_NotConfigured { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_ArgumentMustBeGreaterThanOrEqualTo();
    internal static string FormatArgumentMustBeGreaterThanOrEqualTo(object p0);
    internal static string get_RangeConstraint_MinShouldBeLessThanOrEqualToMax();
    internal static string FormatRangeConstraint_MinShouldBeLessThanOrEqualToMax(object p0, object p1);
    internal static string get_PropertyOfTypeCannotBeNull();
    internal static string FormatPropertyOfTypeCannotBeNull(object p0, object p1);
    internal static string get_NamedRoutes_AmbiguousRoutesFound();
    internal static string FormatNamedRoutes_AmbiguousRoutesFound(object p0);
    internal static string get_DefaultHandler_MustBeSet();
    internal static string FormatDefaultHandler_MustBeSet(object p0);
    internal static string get_DefaultInlineConstraintResolver_AmbiguousCtors();
    internal static string FormatDefaultInlineConstraintResolver_AmbiguousCtors(object p0, object p1);
    internal static string get_DefaultInlineConstraintResolver_CouldNotFindCtor();
    internal static string FormatDefaultInlineConstraintResolver_CouldNotFindCtor(object p0, object p1);
    internal static string get_DefaultInlineConstraintResolver_TypeNotConstraint();
    internal static string FormatDefaultInlineConstraintResolver_TypeNotConstraint(object p0, object p1, object p2);
    internal static string get_TemplateRoute_CannotHaveCatchAllInMultiSegment();
    internal static string get_TemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly();
    internal static string FormatTemplateRoute_CannotHaveDefaultValueSpecifiedInlineAndExplicitly(object p0);
    internal static string get_TemplateRoute_CannotHaveConsecutiveParameters();
    internal static string get_TemplateRoute_CannotHaveConsecutiveSeparators();
    internal static string get_TemplateRoute_CatchAllCannotBeOptional();
    internal static string get_TemplateRoute_OptionalCannotHaveDefaultValue();
    internal static string get_TemplateRoute_CatchAllMustBeLast();
    internal static string get_TemplateRoute_InvalidLiteral();
    internal static string FormatTemplateRoute_InvalidLiteral(object p0);
    internal static string get_TemplateRoute_InvalidParameterName();
    internal static string FormatTemplateRoute_InvalidParameterName(object p0);
    internal static string get_TemplateRoute_InvalidRouteTemplate();
    internal static string get_TemplateRoute_MismatchedParameter();
    internal static string get_TemplateRoute_RepeatedParameter();
    internal static string FormatTemplateRoute_RepeatedParameter(object p0);
    internal static string get_RouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint();
    internal static string FormatRouteConstraintBuilder_ValidationMustBeStringOrCustomConstraint(object p0, object p1, object p2, object p3);
    internal static string get_RouteConstraintBuilder_CouldNotResolveConstraint();
    internal static string FormatRouteConstraintBuilder_CouldNotResolveConstraint(object p0, object p1, object p2, object p3);
    internal static string get_TemplateRoute_UnescapedBrace();
    internal static string get_TemplateRoute_OptionalParameterCanbBePrecededByPeriod();
    internal static string FormatTemplateRoute_OptionalParameterCanbBePrecededByPeriod(object p0, object p1, object p2);
    internal static string get_TemplateRoute_OptionalParameterHasTobeTheLast();
    internal static string FormatTemplateRoute_OptionalParameterHasTobeTheLast(object p0, object p1, object p2);
    internal static string get_AttributeRoute_DifferentLinkGenerationEntries_SameName();
    internal static string FormatAttributeRoute_DifferentLinkGenerationEntries_SameName(object p0);
    internal static string get_UnableToFindServices();
    internal static string FormatUnableToFindServices(object p0, object p1, object p2);
    internal static string get_TemplateRoute_Exception();
    internal static string FormatTemplateRoute_Exception(object p0, object p1);
    internal static string get_AmbiguousEndpoints();
    internal static string FormatAmbiguousEndpoints(object p0, object p1);
    internal static string get_Argument_NullOrEmpty();
    internal static string get_RoutePatternBuilder_CollectionCannotBeEmpty();
    internal static string get_ConstraintMustBeStringOrConstraint();
    internal static string FormatConstraintMustBeStringOrConstraint(object p0, object p1, object p2);
    internal static string get_RoutePattern_InvalidConstraintReference();
    internal static string FormatRoutePattern_InvalidConstraintReference(object p0, object p1);
    internal static string get_RoutePattern_InvalidParameterConstraintReference();
    internal static string FormatRoutePattern_InvalidParameterConstraintReference(object p0, object p1, object p2, object p3);
    internal static string get_RoutePattern_ConstraintReferenceNotFound();
    internal static string FormatRoutePattern_ConstraintReferenceNotFound(object p0, object p1, object p2);
    internal static string get_RoutePattern_InvalidStringConstraintReference();
    internal static string FormatRoutePattern_InvalidStringConstraintReference(object p0, object p1, object p2, object p3);
    internal static string get_DuplicateEndpointNameEntry();
    internal static string FormatDuplicateEndpointNameEntry(object p0);
    internal static string get_DuplicateEndpointNameHeader();
    internal static string get_FormatterMapping_MediaTypeInvalid();
    internal static string FormatFormatterMapping_MediaTypeInvalid(object p0);
    internal static string get_MapGroup_ChangingRoutePatternUnsupported();
    internal static string FormatMapGroup_ChangingRoutePatternUnsupported(object p0, object p1);
    internal static string get_MapGroup_CustomEndpointUnsupported();
    internal static string FormatMapGroup_CustomEndpointUnsupported(object p0);
    internal static string get_MapGroup_RepeatedDictionaryEntry();
    internal static string FormatMapGroup_RepeatedDictionaryEntry(object p0, object p1, object p2);
    internal static string get_RouteEndpointDataSource_ConventionsCannotBeModifiedAfterBuild();
    internal static string get_RouteEndpointDataSource_RequestDelegateCannotBeCalledBeforeBuild();
    internal static string get_RegexRouteContraint_NotConfigured();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Route : RouteBase {
    private IRouter _target;
    [NullableAttribute("2")]
public string RouteTemplate { get; }
    public Route(IRouter target, string routeTemplate, IInlineConstraintResolver inlineConstraintResolver);
    public Route(IRouter target, string routeTemplate, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens, IInlineConstraintResolver inlineConstraintResolver);
    [NullableContextAttribute("2")]
public Route(IRouter target, string routeName, string routeTemplate, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens, IInlineConstraintResolver inlineConstraintResolver);
    [NullableContextAttribute("2")]
public string get_RouteTemplate();
    protected virtual Task OnRouteMatched(RouteContext context);
    protected virtual VirtualPathData OnVirtualPathGenerated(VirtualPathContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.RouteBase : object {
    private object _loggersLock;
    private TemplateMatcher _matcher;
    private TemplateBinder _binder;
    private ILogger _logger;
    private ILogger _constraintLogger;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private IInlineConstraintResolver <ConstraintResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <DataTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <ParsedTemplate>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; protected set; }
    protected IInlineConstraintResolver ConstraintResolver { get; protected set; }
    public RouteValueDictionary DataTokens { get; protected set; }
    public RouteValueDictionary Defaults { get; protected set; }
    [NullableAttribute("2")]
public string Name { get; protected set; }
    public RouteTemplate ParsedTemplate { get; protected set; }
    [NullableContextAttribute("2")]
public RouteBase(string template, string name, IInlineConstraintResolver constraintResolver, RouteValueDictionary defaults, IDictionary`2<string, object> constraints, RouteValueDictionary dataTokens);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
protected virtual void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
protected virtual IInlineConstraintResolver get_ConstraintResolver();
    [CompilerGeneratedAttribute]
protected virtual void set_ConstraintResolver(IInlineConstraintResolver value);
    [CompilerGeneratedAttribute]
public virtual RouteValueDictionary get_DataTokens();
    [CompilerGeneratedAttribute]
protected virtual void set_DataTokens(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public virtual RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
protected virtual void set_Defaults(RouteValueDictionary value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual RouteTemplate get_ParsedTemplate();
    [CompilerGeneratedAttribute]
protected virtual void set_ParsedTemplate(RouteTemplate value);
    protected abstract virtual Task OnRouteMatched(RouteContext context);
    protected abstract virtual VirtualPathData OnVirtualPathGenerated(VirtualPathContext context);
    public virtual Task RouteAsync(RouteContext context);
    public virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    protected static IDictionary`2<string, IRouteConstraint> GetConstraints(IInlineConstraintResolver inlineConstraintResolver, RouteTemplate parsedTemplate, IDictionary`2<string, object> constraints);
    protected static RouteValueDictionary GetDefaults(RouteTemplate parsedTemplate, RouteValueDictionary defaults);
    private static void MergeValues(RouteValueDictionary destination, RouteValueDictionary values);
    [MemberNotNullAttribute("_binder")]
private void EnsureBinder(HttpContext context);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsureLoggers(HttpContext context);
    [MemberNotNullAttribute("_matcher")]
private void EnsureMatcher();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteBuilder : object {
    [CompilerGeneratedAttribute]
private IApplicationBuilder <ApplicationBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <DefaultHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRouter> <Routes>k__BackingField;
    public IApplicationBuilder ApplicationBuilder { get; }
    [NullableAttribute("2")]
public IRouter DefaultHandler { get; public set; }
    public IServiceProvider ServiceProvider { get; }
    public IList`1<IRouter> Routes { get; }
    public RouteBuilder(IApplicationBuilder applicationBuilder);
    public RouteBuilder(IApplicationBuilder applicationBuilder, IRouter defaultHandler);
    [CompilerGeneratedAttribute]
public sealed virtual IApplicationBuilder get_ApplicationBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IRouter get_DefaultHandler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_DefaultHandler(IRouter value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IRouter> get_Routes();
    public sealed virtual IRouter Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.AspNetCore.Routing.RouteCollection : object {
    private List`1<IRouter> _routes;
    private List`1<IRouter> _unnamedRoutes;
    private Dictionary`2<string, INamedRouter> _namedRoutes;
    private RouteOptions _options;
    public IRouter Item { get; }
    public int Count { get; }
    public IRouter get_Item(int index);
    public int get_Count();
    public sealed virtual void Add(IRouter router);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.RouteCollection/<RouteAsync>d__9")]
public virtual Task RouteAsync(RouteContext context);
    public virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    private static VirtualPathData GetVirtualPath(VirtualPathContext context, List`1<IRouter> routes);
    private VirtualPathData NormalizeVirtualPath(VirtualPathData pathData);
    [MemberNotNullAttribute("_options")]
private void EnsureOptions(HttpContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteConstraintBuilder : object {
    private IInlineConstraintResolver _inlineConstraintResolver;
    private string _displayName;
    private Dictionary`2<string, List`1<IRouteConstraint>> _constraints;
    private HashSet`1<string> _optionalParameters;
    public RouteConstraintBuilder(IInlineConstraintResolver inlineConstraintResolver, string displayName);
    public IDictionary`2<string, IRouteConstraint> Build();
    public void AddConstraint(string key, object value);
    public void AddResolvedConstraint(string key, string constraintText);
    public void SetOptional(string key);
    private void Add(string key, IRouteConstraint constraint);
}
public static class Microsoft.AspNetCore.Routing.RouteConstraintMatcher : object {
    [NullableContextAttribute("1")]
public static bool Match(IDictionary`2<string, IRouteConstraint> constraints, RouteValueDictionary routeValues, HttpContext httpContext, IRouter route, RouteDirection routeDirection, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteCreationException : Exception {
    public RouteCreationException(string message);
    public RouteCreationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteEndpoint : Endpoint {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    public int Order { get; }
    public RoutePattern RoutePattern { get; }
    public RouteEndpoint(RequestDelegate requestDelegate, RoutePattern routePattern, int order, EndpointMetadataCollection metadata, string displayName);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteEndpointBuilder : EndpointBuilder {
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public RoutePattern RoutePattern { get; public set; }
    public int Order { get; public set; }
    public RouteEndpointBuilder(RequestDelegate requestDelegate, RoutePattern routePattern, int order);
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
    [CompilerGeneratedAttribute]
public void set_RoutePattern(RoutePattern value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    public virtual Endpoint Build();
    private static EndpointMetadataCollection CreateMetadataCollection(IList`1<object> metadata, RoutePattern routePattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.RouteEndpointDataSource : EndpointDataSource {
    private List`1<RouteEntry> _routeEntries;
    private IServiceProvider _applicationServices;
    private bool _throwOnBadRequest;
    public IReadOnlyList`1<RouteEndpoint> Endpoints { get; }
    public RouteEndpointDataSource(IServiceProvider applicationServices, bool throwOnBadRequest);
    public RouteHandlerBuilder AddRequestDelegate(RoutePattern pattern, RequestDelegate requestDelegate, IEnumerable`1<string> httpMethods, Func`4<Delegate, RequestDelegateFactoryOptions, RequestDelegateMetadataResult, RequestDelegateResult> createHandlerRequestDelegateFunc);
    public RouteHandlerBuilder AddRouteHandler(RoutePattern pattern, Delegate routeHandler, IEnumerable`1<string> httpMethods, bool isFallback, Func`3<MethodInfo, RequestDelegateFactoryOptions, RequestDelegateMetadataResult> inferMetadataFunc, Func`4<Delegate, RequestDelegateFactoryOptions, RequestDelegateMetadataResult, RequestDelegateResult> createHandlerRequestDelegateFunc);
    [PreserveBaseOverridesAttribute]
public virtual override IReadOnlyList`1<RouteEndpoint> get_Endpoints();
    [PreserveBaseOverridesAttribute]
public virtual override IReadOnlyList`1<RouteEndpoint> GetGroupedEndpoints(RouteGroupContext context);
    public virtual IChangeToken GetChangeToken();
    internal RouteEndpointBuilder GetSingleRouteEndpointBuilder();
    private RouteEndpointBuilder CreateRouteEndpointBuilder(RouteEntry entry, RoutePattern groupPrefix, IReadOnlyList`1<Action`1<EndpointBuilder>> groupConventions, IReadOnlyList`1<Action`1<EndpointBuilder>> groupFinallyConventions);
    private RequestDelegateFactoryOptions CreateRdfOptions(RouteEntry entry, RoutePattern pattern, RouteEndpointBuilder builder);
    private static bool ShouldDisableInferredBodyParameters(IEnumerable`1<string> httpMethods);
    [CompilerGeneratedAttribute]
internal static bool <ShouldDisableInferredBodyParameters>g__ShouldDisableInferredBodyForMethod|13_0(string method);
}
public class Microsoft.AspNetCore.Routing.RouteGroupBuilder : object {
    private IEndpointRouteBuilder _outerEndpointRouteBuilder;
    private RoutePattern _partialPrefix;
    private List`1<EndpointDataSource> _dataSources;
    private List`1<Action`1<EndpointBuilder>> _conventions;
    private List`1<Action`1<EndpointBuilder>> _finallyConventions;
    [NullableAttribute("1")]
private IServiceProvider Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.ServiceProvider { get; }
    [NullableAttribute("1")]
private ICollection`1<EndpointDataSource> Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.DataSources { get; }
    [NullableContextAttribute("1")]
internal RouteGroupBuilder(IEndpointRouteBuilder outerEndpointRouteBuilder, RoutePattern partialPrefix);
    private sealed virtual override IServiceProvider Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.get_ServiceProvider();
    private sealed virtual override IApplicationBuilder Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.CreateApplicationBuilder();
    private sealed virtual override ICollection`1<EndpointDataSource> Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.get_DataSources();
    private sealed virtual override void Microsoft.AspNetCore.Builder.IEndpointConventionBuilder.Add(Action`1<EndpointBuilder> convention);
    private sealed virtual override void Microsoft.AspNetCore.Builder.IEndpointConventionBuilder.Finally(Action`1<EndpointBuilder> finalConvention);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
public class Microsoft.AspNetCore.Routing.RouteGroupContext : object {
    [CompilerGeneratedAttribute]
private RoutePattern <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Action`1<EndpointBuilder>> <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Action`1<EndpointBuilder>> <FinallyConventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ApplicationServices>k__BackingField;
    [RequiredMemberAttribute]
public RoutePattern Prefix { get; public set; }
    public IReadOnlyList`1<Action`1<EndpointBuilder>> Conventions { get; public set; }
    public IReadOnlyList`1<Action`1<EndpointBuilder>> FinallyConventions { get; public set; }
    public IServiceProvider ApplicationServices { get; public set; }
    [CompilerGeneratedAttribute]
public RoutePattern get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(RoutePattern value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Action`1<EndpointBuilder>> get_Conventions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Conventions(IReadOnlyList`1<Action`1<EndpointBuilder>> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Action`1<EndpointBuilder>> get_FinallyConventions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FinallyConventions(IReadOnlyList`1<Action`1<EndpointBuilder>> value);
    [CompilerGeneratedAttribute]
public IServiceProvider get_ApplicationServices();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ApplicationServices(IServiceProvider value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteHandler : object {
    private RequestDelegate _requestDelegate;
    public RouteHandler(RequestDelegate requestDelegate);
    public sealed virtual RequestDelegate GetRequestHandler(HttpContext httpContext, RouteData routeData);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    public sealed virtual Task RouteAsync(RouteContext context);
}
public class Microsoft.AspNetCore.Routing.RouteHandlerOptions : object {
    [CompilerGeneratedAttribute]
private bool <ThrowOnBadRequest>k__BackingField;
    public bool ThrowOnBadRequest { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ThrowOnBadRequest();
    [CompilerGeneratedAttribute]
public void set_ThrowOnBadRequest(bool value);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.AspNetCore.Routing.RouteHandlerServices : object {
    [NullableContextAttribute("1")]
public static RouteHandlerBuilder Map(IEndpointRouteBuilder endpoints, string pattern, Delegate handler, IEnumerable`1<string> httpMethods, Func`3<MethodInfo, RequestDelegateFactoryOptions, RequestDelegateMetadataResult> populateMetadata, Func`4<Delegate, RequestDelegateFactoryOptions, RequestDelegateMetadataResult, RequestDelegateResult> createRequestDelegate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.RouteNameMetadata : object {
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    public string RouteName { get; }
    public RouteNameMetadata(string routeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RouteName();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteOptions : object {
    private IDictionary`2<string, Type> _constraintTypeMap;
    private ICollection`1<EndpointDataSource> _endpointDataSources;
    [CompilerGeneratedAttribute]
private bool <LowercaseUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowercaseQueryStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressCheckForUnhandledSecurityMetadata>k__BackingField;
    internal ICollection`1<EndpointDataSource> EndpointDataSources { get; internal set; }
    public bool LowercaseUrls { get; public set; }
    public bool LowercaseQueryStrings { get; public set; }
    public bool AppendTrailingSlash { get; public set; }
    public bool SuppressCheckForUnhandledSecurityMetadata { get; public set; }
    public IDictionary`2<string, Type> ConstraintMap { get; public set; }
    internal IDictionary`2<string, Type> TrimmerSafeConstraintMap { get; }
    internal ICollection`1<EndpointDataSource> get_EndpointDataSources();
    internal void set_EndpointDataSources(ICollection`1<EndpointDataSource> value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseUrls();
    [CompilerGeneratedAttribute]
public void set_LowercaseUrls(bool value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseQueryStrings();
    [CompilerGeneratedAttribute]
public void set_LowercaseQueryStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppendTrailingSlash();
    [CompilerGeneratedAttribute]
public void set_AppendTrailingSlash(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressCheckForUnhandledSecurityMetadata();
    [CompilerGeneratedAttribute]
public void set_SuppressCheckForUnhandledSecurityMetadata(bool value);
    [RequiresUnreferencedCodeAttribute("The linker cannot determine what constraints are being added via the ConstraintMap property. Prefer RouteOptions.SetParameterPolicy instead for setting constraints. This warning can be suppressed if this property is being used to read or delete constraints.")]
public IDictionary`2<string, Type> get_ConstraintMap();
    public void set_ConstraintMap(IDictionary`2<string, Type> value);
    internal IDictionary`2<string, Type> get_TrimmerSafeConstraintMap();
    private static IDictionary`2<string, Type> GetDefaultConstraintMap();
    public void SetParameterPolicy(string token);
    public void SetParameterPolicy(string token, Type type);
    private static void AddConstraint(Dictionary`2<string, Type> constraintMap, string text);
}
internal class Microsoft.AspNetCore.Routing.RoutePatternMatcher : object {
    private Boolean[] _hasDefaultValue;
    private Object[] _defaultValues;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutePattern <RoutePattern>k__BackingField;
    public RouteValueDictionary Defaults { get; }
    public RoutePattern RoutePattern { get; }
    public RoutePatternMatcher(RoutePattern pattern, RouteValueDictionary defaults);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public RoutePattern get_RoutePattern();
    public bool TryMatch(PathString path, RouteValueDictionary values);
    private bool TryMatchLiterals(int index, StringSegment stringSegment, RoutePatternPathSegment pathSegment);
    private bool SavePathSegmentsAsValues(int index, RouteValueDictionary values, StringSegment requestSegment, RoutePatternPathSegment pathSegment);
    internal static bool MatchComplexSegment(RoutePatternPathSegment routeSegment, ReadOnlySpan`1<char> requestSegment, RouteValueDictionary values);
    private static bool MatchComplexSegmentCore(RoutePatternPathSegment routeSegment, ReadOnlySpan`1<char> requestSegment, RouteValueDictionary values, int indexOfLastSegmentUsed);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Routing.RouteShortCircuitEndpointRouteBuilderExtensions : object {
    private static RequestDelegate _shortCircuitDelegate;
    private static RouteShortCircuitEndpointRouteBuilderExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEndpointConventionBuilder MapShortCircuit(IEndpointRouteBuilder builder, int statusCode, String[] routePrefixes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteValueEqualityComparer : object {
    public static RouteValueEqualityComparer Default;
    private static RouteValueEqualityComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RouteValuesAddress : object {
    private string _toString;
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <ExplicitValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <AmbientValues>k__BackingField;
    public string RouteName { get; public set; }
    [NullableAttribute("1")]
public RouteValueDictionary ExplicitValues { get; public set; }
    public RouteValueDictionary AmbientValues { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public RouteValueDictionary get_ExplicitValues();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ExplicitValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_AmbientValues();
    [CompilerGeneratedAttribute]
public void set_AmbientValues(RouteValueDictionary value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.RouteValuesAddressScheme : object {
    private DataSourceDependentCache`1<StateEntry> _cache;
    internal StateEntry State { get; }
    public RouteValuesAddressScheme(EndpointDataSource dataSource);
    internal StateEntry get_State();
    public sealed virtual IEnumerable`1<Endpoint> FindEndpoints(RouteValuesAddress address);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Routing.RouteValuesAddressScheme/<GetEndpoints>d__5")]
private static IEnumerable`1<Endpoint> GetEndpoints(IList`1<OutboundMatchResult> matchResults, int matchCount);
    private StateEntry Initialize(IReadOnlyList`1<Endpoint> endpoints);
    private static OutboundRouteEntry CreateOutboundRouteEntry(RouteEndpoint endpoint, IReadOnlyDictionary`2<string, object> requiredValues, string routeName);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.RoutingFeature : object {
    [CompilerGeneratedAttribute]
private RouteData <RouteData>k__BackingField;
    public RouteData RouteData { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual RouteData get_RouteData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RouteData(RouteData value);
}
internal class Microsoft.AspNetCore.Routing.RoutingMarkerService : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.RoutingMetrics : object {
    public static string MeterName;
    private static object BoxedTrue;
    private static object BoxedFalse;
    private Meter _meter;
    private Counter`1<long> _matchAttemptsCounter;
    public bool MatchSuccessCounterEnabled { get; }
    public RoutingMetrics(IMeterFactory meterFactory);
    private static RoutingMetrics();
    public bool get_MatchSuccessCounterEnabled();
    public void MatchSuccess(string route, bool isFallback);
    public void MatchFailure();
}
internal enum Microsoft.AspNetCore.Routing.SegmentState : Enum {
    public int value__;
    public static SegmentState Beginning;
    public static SegmentState Inside;
}
internal class Microsoft.AspNetCore.Routing.ShortCircuit.ShortCircuitMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StatusCode>k__BackingField;
    public Nullable`1<int> StatusCode { get; }
    public ShortCircuitMetadata(Nullable`1<int> statusCode);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StatusCode();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.SuppressLinkGenerationMetadata : object {
    public bool SuppressLinkGeneration { get; }
    public sealed virtual bool get_SuppressLinkGeneration();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Microsoft.AspNetCore.Routing.SuppressMatchingMetadata : object {
    public bool SuppressMatching { get; }
    public sealed virtual bool get_SuppressMatching();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.Template.DefaultTemplateBinderFactory : TemplateBinderFactory {
    private ParameterPolicyFactory _policyFactory;
    private ObjectPool`1<UriBuildingContext> _pool;
    public DefaultTemplateBinderFactory(ParameterPolicyFactory policyFactory, ObjectPool`1<UriBuildingContext> pool);
    public virtual TemplateBinder Create(RouteTemplate template, RouteValueDictionary defaults);
    public virtual TemplateBinder Create(RoutePattern pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Template.InlineConstraint : object {
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    public string Constraint { get; }
    public InlineConstraint(string constraint);
    public InlineConstraint(RoutePatternParameterPolicyReference other);
    [CompilerGeneratedAttribute]
public string get_Constraint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.AspNetCore.Routing.Template.RoutePrecedence : object {
    public static decimal ComputeInbound(RouteTemplate template);
    internal static decimal ComputeInbound(RoutePattern routePattern);
    public static decimal ComputeOutbound(RouteTemplate template);
    internal static decimal ComputeOutbound(RoutePattern routePattern);
    private static void ValidateSegementLength(int length);
    private static int ComputeOutboundPrecedenceDigit(TemplateSegment segment);
    private static int ComputeOutboundPrecedenceDigit(RoutePatternPathSegment pathSegment);
    private static int ComputeInboundPrecedenceDigit(TemplateSegment segment);
    internal static int ComputeInboundPrecedenceDigit(RoutePattern routePattern, RoutePatternPathSegment pathSegment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.RouteTemplate : object {
    private static string SeparatorString;
    [CompilerGeneratedAttribute]
private string <TemplateText>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TemplatePart> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TemplateSegment> <Segments>k__BackingField;
    [NullableAttribute("2")]
public string TemplateText { get; }
    public IList`1<TemplatePart> Parameters { get; }
    public IList`1<TemplateSegment> Segments { get; }
    public RouteTemplate(RoutePattern other);
    public RouteTemplate(string template, List`1<TemplateSegment> segments);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TemplateText();
    [CompilerGeneratedAttribute]
public IList`1<TemplatePart> get_Parameters();
    [CompilerGeneratedAttribute]
public IList`1<TemplateSegment> get_Segments();
    [NullableContextAttribute("2")]
public TemplateSegment GetSegment(int index);
    private string DebuggerToString();
    public TemplatePart GetParameter(string name);
    public RoutePattern ToRoutePattern();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Template.TemplateBinder : object {
    private UrlEncoder _urlEncoder;
    private ObjectPool`1<UriBuildingContext> _pool;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _constraints;
    private RouteValueDictionary _defaults;
    private KeyValuePair`2[] _filters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _parameterTransformers;
    private RoutePattern _pattern;
    private String[] _requiredKeys;
    private KeyValuePair`2[] _slots;
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RouteTemplate template, RouteValueDictionary defaults);
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RoutePattern pattern, RouteValueDictionary defaults, IEnumerable`1<string> requiredKeys, IEnumerable`1<ValueTuple`2<string, IParameterPolicy>> parameterPolicies);
    internal TemplateBinder(UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> pool, RoutePattern pattern, IEnumerable`1<ValueTuple`2<string, IParameterPolicy>> parameterPolicies);
    private static void Initialize(IEnumerable`1<ValueTuple`2<string, IParameterPolicy>> parameterPolicies, ValueTuple`2[]& constraints, ValueTuple`2[]& parameterTransformers);
    [NullableContextAttribute("2")]
public TemplateValuesResult GetValues(RouteValueDictionary ambientValues, RouteValueDictionary values);
    [NullableContextAttribute("2")]
public bool TryProcessConstraints(HttpContext httpContext, RouteValueDictionary combinedValues, String& parameterName, IRouteConstraint& constraint);
    public string BindValues(RouteValueDictionary acceptedValues);
    internal bool TryBindValues(RouteValueDictionary acceptedValues, LinkOptions options, LinkOptions globalOptions, ValueTuple`2& result);
    private bool TryBindValuesCore(UriBuildingContext context, RouteValueDictionary acceptedValues);
    private bool AddQueryKeyValueToContext(UriBuildingContext context, string key, object value, bool wroteFirst);
    [NullableContextAttribute("2")]
public static bool RoutePartsEqual(object a, object b);
    private static bool IsRoutePartNonEmpty(object part);
    private void CopyNonParameterAmbientValues(RouteValueDictionary ambientValues, RouteValueDictionary acceptedValues, RouteValueDictionary combinedValues);
    private static KeyValuePair`2[] AssignSlots(RoutePattern pattern, KeyValuePair`2[] filters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.AspNetCore.Routing.Template.TemplateBinderFactory : object {
    public abstract virtual TemplateBinder Create(RouteTemplate template, RouteValueDictionary defaults);
    public abstract virtual TemplateBinder Create(RoutePattern pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Template.TemplateMatcher : object {
    private Boolean[] _hasDefaultValue;
    private Object[] _defaultValues;
    private RoutePatternMatcher _routePatternMatcher;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <Template>k__BackingField;
    public RouteValueDictionary Defaults { get; }
    public RouteTemplate Template { get; }
    public TemplateMatcher(RouteTemplate template, RouteValueDictionary defaults);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public RouteTemplate get_Template();
    public bool TryMatch(PathString path, RouteValueDictionary values);
}
public static class Microsoft.AspNetCore.Routing.Template.TemplateParser : object {
    [NullableContextAttribute("1")]
public static RouteTemplate Parse(string routeTemplate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.TemplatePart : object {
    [CompilerGeneratedAttribute]
private bool <IsCatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptionalSeperator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InlineConstraint> <InlineConstraints>k__BackingField;
    public bool IsCatchAll { get; private set; }
    [MemberNotNullWhenAttribute("True", "Text")]
public bool IsLiteral { get; private set; }
    public bool IsParameter { get; private set; }
    public bool IsOptional { get; private set; }
    public bool IsOptionalSeperator { get; public set; }
    public string Name { get; private set; }
    public string Text { get; private set; }
    public object DefaultValue { get; private set; }
    [NullableAttribute("1")]
public IEnumerable`1<InlineConstraint> InlineConstraints { get; private set; }
    [NullableContextAttribute("1")]
public TemplatePart(RoutePatternPart other);
    [NullableContextAttribute("1")]
public static TemplatePart CreateLiteral(string text);
    [NullableContextAttribute("1")]
public static TemplatePart CreateParameter(string name, bool isCatchAll, bool isOptional, object defaultValue, IEnumerable`1<InlineConstraint> inlineConstraints);
    [CompilerGeneratedAttribute]
public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
private void set_IsCatchAll(bool value);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "Text")]
public bool get_IsLiteral();
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "Text")]
private void set_IsLiteral(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParameter();
    [CompilerGeneratedAttribute]
private void set_IsParameter(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
private void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptionalSeperator();
    [CompilerGeneratedAttribute]
public void set_IsOptionalSeperator(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(object value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<InlineConstraint> get_InlineConstraints();
    [CompilerGeneratedAttribute]
private void set_InlineConstraints(IEnumerable`1<InlineConstraint> value);
    internal string DebuggerToString();
    [NullableContextAttribute("1")]
public RoutePatternPart ToRoutePatternPart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class Microsoft.AspNetCore.Routing.Template.TemplateSegment : object {
    [CompilerGeneratedAttribute]
private List`1<TemplatePart> <Parts>k__BackingField;
    public bool IsSimple { get; }
    public List`1<TemplatePart> Parts { get; }
    public TemplateSegment(RoutePatternPathSegment other);
    public bool get_IsSimple();
    [CompilerGeneratedAttribute]
public List`1<TemplatePart> get_Parts();
    internal string DebuggerToString();
    public RoutePatternPathSegment ToRoutePatternPathSegment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Template.TemplateValuesResult : object {
    [CompilerGeneratedAttribute]
private RouteValueDictionary <AcceptedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <CombinedValues>k__BackingField;
    public RouteValueDictionary AcceptedValues { get; public set; }
    public RouteValueDictionary CombinedValues { get; public set; }
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_AcceptedValues();
    [CompilerGeneratedAttribute]
public void set_AcceptedValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_CombinedValues();
    [CompilerGeneratedAttribute]
public void set_CombinedValues(RouteValueDictionary value);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.Tree.InboundMatch : object {
    [CompilerGeneratedAttribute]
private InboundRouteEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateMatcher <TemplateMatcher>k__BackingField;
    public InboundRouteEntry Entry { get; public set; }
    public TemplateMatcher TemplateMatcher { get; public set; }
    [CompilerGeneratedAttribute]
public InboundRouteEntry get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(InboundRouteEntry value);
    [CompilerGeneratedAttribute]
public TemplateMatcher get_TemplateMatcher();
    [CompilerGeneratedAttribute]
public void set_TemplateMatcher(TemplateMatcher value);
    private string DebuggerToString();
}
public class Microsoft.AspNetCore.Routing.Tree.InboundRouteEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <RouteTemplate>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; public set; }
    public RouteValueDictionary Defaults { get; public set; }
    public IRouter Handler { get; public set; }
    public int Order { get; public set; }
    public decimal Precedence { get; public set; }
    public string RouteName { get; public set; }
    public RouteTemplate RouteTemplate { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
public void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public IRouter get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(IRouter value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public decimal get_Precedence();
    [CompilerGeneratedAttribute]
public void set_Precedence(decimal value);
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [CompilerGeneratedAttribute]
public RouteTemplate get_RouteTemplate();
    [CompilerGeneratedAttribute]
public void set_RouteTemplate(RouteTemplate value);
}
[DebuggerDisplayAttribute("{DebuggerDisplayString,nq}")]
internal class Microsoft.AspNetCore.Routing.Tree.LinkGenerationDecisionTree : object {
    private static RouteValueDictionary EmptyAmbientValues;
    private DecisionTreeNode`1<OutboundMatch> _root;
    private List`1<OutboundMatch> _conventionalEntries;
    internal string DebuggerDisplayString { get; }
    public LinkGenerationDecisionTree(IReadOnlyList`1<OutboundMatch> entries);
    private static LinkGenerationDecisionTree();
    public IList`1<OutboundMatchResult> GetMatches(RouteValueDictionary values, RouteValueDictionary ambientValues);
    private static void Walk(List`1<OutboundMatchResult> results, RouteValueDictionary values, RouteValueDictionary ambientValues, DecisionTreeNode`1<OutboundMatch> node, bool isFallbackPath);
    private void ProcessConventionalEntries(List`1<OutboundMatchResult> results);
    internal string get_DebuggerDisplayString();
    private static void FlattenTree(Stack`1<string> branchStack, StringBuilder sb, DecisionTreeNode`1<OutboundMatch> node);
}
public class Microsoft.AspNetCore.Routing.Tree.OutboundMatch : object {
    [CompilerGeneratedAttribute]
private OutboundRouteEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateBinder <TemplateBinder>k__BackingField;
    public OutboundRouteEntry Entry { get; public set; }
    public TemplateBinder TemplateBinder { get; public set; }
    [CompilerGeneratedAttribute]
public OutboundRouteEntry get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(OutboundRouteEntry value);
    [CompilerGeneratedAttribute]
public TemplateBinder get_TemplateBinder();
    [CompilerGeneratedAttribute]
public void set_TemplateBinder(TemplateBinder value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Routing.Tree.OutboundMatchResult : ValueType {
    [CompilerGeneratedAttribute]
private OutboundMatch <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFallbackMatch>k__BackingField;
    public OutboundMatch Match { get; }
    public bool IsFallbackMatch { get; }
    public OutboundMatchResult(OutboundMatch match, bool isFallbackMatch);
    [CompilerGeneratedAttribute]
public OutboundMatch get_Match();
    [CompilerGeneratedAttribute]
public bool get_IsFallbackMatch();
}
public class Microsoft.AspNetCore.Routing.Tree.OutboundRouteEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IRouteConstraint> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouter <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RouteName>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteValueDictionary <RequiredLinkValues>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteTemplate <RouteTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public IDictionary`2<string, IRouteConstraint> Constraints { get; public set; }
    public RouteValueDictionary Defaults { get; public set; }
    public IRouter Handler { get; public set; }
    public int Order { get; public set; }
    public decimal Precedence { get; public set; }
    public string RouteName { get; public set; }
    public RouteValueDictionary RequiredLinkValues { get; public set; }
    public RouteTemplate RouteTemplate { get; public set; }
    public object Data { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IRouteConstraint> get_Constraints();
    [CompilerGeneratedAttribute]
public void set_Constraints(IDictionary`2<string, IRouteConstraint> value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public IRouter get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(IRouter value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public decimal get_Precedence();
    [CompilerGeneratedAttribute]
public void set_Precedence(decimal value);
    [CompilerGeneratedAttribute]
public string get_RouteName();
    [CompilerGeneratedAttribute]
public void set_RouteName(string value);
    [CompilerGeneratedAttribute]
public RouteValueDictionary get_RequiredLinkValues();
    [CompilerGeneratedAttribute]
public void set_RequiredLinkValues(RouteValueDictionary value);
    [CompilerGeneratedAttribute]
public RouteTemplate get_RouteTemplate();
    [CompilerGeneratedAttribute]
public void set_RouteTemplate(RouteTemplate value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
}
internal class Microsoft.AspNetCore.Routing.Tree.TreeEnumerator : ValueType {
    private Stack`1<UrlMatchingNode> _stack;
    private PathTokenizer _tokenizer;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Current>k__BackingField;
    public UrlMatchingNode Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public TreeEnumerator(UrlMatchingNode root, PathTokenizer tokenizer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UrlMatchingNode get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(UrlMatchingNode value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class Microsoft.AspNetCore.Routing.Tree.TreeRouteBuilder : object {
    private ILogger _logger;
    private ILogger _constraintLogger;
    private UrlEncoder _urlEncoder;
    private ObjectPool`1<UriBuildingContext> _objectPool;
    private IInlineConstraintResolver _constraintResolver;
    [CompilerGeneratedAttribute]
private IList`1<InboundRouteEntry> <InboundEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OutboundRouteEntry> <OutboundEntries>k__BackingField;
    public IList`1<InboundRouteEntry> InboundEntries { get; }
    public IList`1<OutboundRouteEntry> OutboundEntries { get; }
    internal TreeRouteBuilder(ILoggerFactory loggerFactory, ObjectPool`1<UriBuildingContext> objectPool, IInlineConstraintResolver constraintResolver);
    public InboundRouteEntry MapInbound(IRouter handler, RouteTemplate routeTemplate, string routeName, int order);
    public OutboundRouteEntry MapOutbound(IRouter handler, RouteTemplate routeTemplate, RouteValueDictionary requiredLinkValues, string routeName, int order);
    [CompilerGeneratedAttribute]
public IList`1<InboundRouteEntry> get_InboundEntries();
    [CompilerGeneratedAttribute]
public IList`1<OutboundRouteEntry> get_OutboundEntries();
    public TreeRouter Build();
    public TreeRouter Build(int version);
    public void Clear();
}
public class Microsoft.AspNetCore.Routing.Tree.TreeRouter : object {
    public static string RouteGroupKey;
    private LinkGenerationDecisionTree _linkGenerationTree;
    private UrlMatchingTree[] _trees;
    private IDictionary`2<string, OutboundMatch> _namedEntries;
    private ILogger _constraintLogger;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; }
    internal IEnumerable`1<UrlMatchingTree> MatchingTrees { get; }
    internal TreeRouter(UrlMatchingTree[] trees, IEnumerable`1<OutboundRouteEntry> linkGenerationEntries, UrlEncoder urlEncoder, ObjectPool`1<UriBuildingContext> objectPool, ILogger routeLogger, ILogger constraintLogger, int version);
    private static TreeRouter();
    [CompilerGeneratedAttribute]
public int get_Version();
    internal IEnumerable`1<UrlMatchingTree> get_MatchingTrees();
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Routing.Tree.TreeRouter/<RouteAsync>d__13")]
public sealed virtual Task RouteAsync(RouteContext context);
    private VirtualPathData GetVirtualPathForNamedRoute(VirtualPathContext context);
    private VirtualPathData GenerateVirtualPath(VirtualPathContext context, OutboundRouteEntry entry, TemplateBinder binder);
}
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
public class Microsoft.AspNetCore.Routing.Tree.UrlMatchingNode : object {
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCatchAll>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<InboundMatch> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, UrlMatchingNode> <Literals>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <ConstrainedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <ConstrainedCatchAlls>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <CatchAlls>k__BackingField;
    public int Depth { get; }
    public bool IsCatchAll { get; public set; }
    public List`1<InboundMatch> Matches { get; }
    public Dictionary`2<string, UrlMatchingNode> Literals { get; }
    public UrlMatchingNode ConstrainedParameters { get; public set; }
    public UrlMatchingNode Parameters { get; public set; }
    public UrlMatchingNode ConstrainedCatchAlls { get; public set; }
    public UrlMatchingNode CatchAlls { get; public set; }
    public UrlMatchingNode(int length);
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
public void set_IsCatchAll(bool value);
    [CompilerGeneratedAttribute]
public List`1<InboundMatch> get_Matches();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, UrlMatchingNode> get_Literals();
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_ConstrainedParameters();
    [CompilerGeneratedAttribute]
public void set_ConstrainedParameters(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_ConstrainedCatchAlls();
    [CompilerGeneratedAttribute]
public void set_ConstrainedCatchAlls(UrlMatchingNode value);
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_CatchAlls();
    [CompilerGeneratedAttribute]
public void set_CatchAlls(UrlMatchingNode value);
    private string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Routing.Tree.UrlMatchingTree : object {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlMatchingNode <Root>k__BackingField;
    public int Order { get; }
    public UrlMatchingNode Root { get; }
    public UrlMatchingTree(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public UrlMatchingNode get_Root();
    internal void AddEntry(InboundRouteEntry entry);
    private static bool RemainingSegmentsAreOptional(IList`1<TemplateSegment> segments, int currentParameterIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Routing.UriBuilderContextPooledObjectPolicy : object {
    public sealed virtual UriBuildingContext Create();
    public sealed virtual bool Return(UriBuildingContext obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
internal class Microsoft.AspNetCore.Routing.UriBuildingContext : object {
    private StringBuilder _path;
    private StringBuilder _query;
    private List`1<BufferValue> _buffer;
    private UrlEncoder _urlEncoder;
    private bool _hasEmptySegment;
    private int _lastValueOffset;
    [CompilerGeneratedAttribute]
private bool <LowercaseUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowercaseQueryStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendTrailingSlash>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentState <BufferState>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentState <UriState>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <PathWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <QueryWriter>k__BackingField;
    public bool LowercaseUrls { get; public set; }
    public bool LowercaseQueryStrings { get; public set; }
    public bool AppendTrailingSlash { get; public set; }
    public SegmentState BufferState { get; private set; }
    public SegmentState UriState { get; private set; }
    public TextWriter PathWriter { get; }
    public TextWriter QueryWriter { get; }
    public UriBuildingContext(UrlEncoder urlEncoder);
    [CompilerGeneratedAttribute]
public bool get_LowercaseUrls();
    [CompilerGeneratedAttribute]
public void set_LowercaseUrls(bool value);
    [CompilerGeneratedAttribute]
public bool get_LowercaseQueryStrings();
    [CompilerGeneratedAttribute]
public void set_LowercaseQueryStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppendTrailingSlash();
    [CompilerGeneratedAttribute]
public void set_AppendTrailingSlash(bool value);
    [CompilerGeneratedAttribute]
public SegmentState get_BufferState();
    [CompilerGeneratedAttribute]
private void set_BufferState(SegmentState value);
    [CompilerGeneratedAttribute]
public SegmentState get_UriState();
    [CompilerGeneratedAttribute]
private void set_UriState(SegmentState value);
    [CompilerGeneratedAttribute]
public TextWriter get_PathWriter();
    [CompilerGeneratedAttribute]
public TextWriter get_QueryWriter();
    [NullableContextAttribute("2")]
public bool Accept(string value);
    [NullableContextAttribute("2")]
public bool Accept(string value, bool encodeSlashes);
    public void Remove();
    [NullableContextAttribute("2")]
public bool Buffer(string value);
    public void EndSegment();
    public void Clear();
    public virtual string ToString();
    public PathString ToPathString();
    public QueryString ToQueryString();
    private void EncodeValue(string value);
    private void EncodeValue(string value, bool encodeSlashes);
    internal void EncodeValue(string value, int start, int characterCount, bool encodeSlashes);
    private string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Shared.DebuggerHelpers : object {
    public static string GetDebugText(string key1, object value1, bool includeNullValues, string prefix);
    public static string GetDebugText(string key1, object value1, string key2, object value2, bool includeNullValues, string prefix);
    public static string GetDebugText(string key1, object value1, string key2, object value2, string key3, object value3, bool includeNullValues, string prefix);
    public static string GetDebugText(ReadOnlySpan`1<KeyValuePair`2<string, object>> values, bool includeNullValues, string prefix);
    private static bool HasValue(object value);
    private static KeyValuePair`2<string, object> Create(string key, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.DependencyInjection.ConfigureRouteOptions : object {
    private ICollection`1<EndpointDataSource> _dataSources;
    public ConfigureRouteOptions(ICollection`1<EndpointDataSource> dataSources);
    public sealed virtual void Configure(RouteOptions options);
}
internal class Microsoft.Extensions.DependencyInjection.RegexInlineRouteConstraintSetup : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(RouteOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddRouting(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddRoutingCore(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddRouting(IServiceCollection services, Action`1<RouteOptions> configureOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Internal.PropertyHelper : object {
    private static BindingFlags DeclaredOnlyLookup;
    private static BindingFlags Everything;
    private static MethodInfo CallPropertyGetterOpenGenericMethod;
    private static MethodInfo CallPropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallPropertySetterOpenGenericMethod;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> PropertiesCache;
    private static ConcurrentDictionary`2<Type, PropertyHelper[]> VisiblePropertiesCache;
    private Action`2<object, object> _valueSetter;
    private Func`2<object, object> _valueGetter;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PropertyInfo Property { get; }
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> ValueGetter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> ValueSetter { get; }
    public PropertyHelper(PropertyInfo property);
    private static PropertyHelper();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public string get_Name();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public Func`2<object, object> get_ValueGetter();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public Action`2<object, object> get_ValueSetter();
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public object GetValue(object instance);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public void SetValue(object instance, object value);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetProperties(Type type);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetVisibleProperties(Type type);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Func`2<object, object> MakeNullSafeFastPropertyGetter(PropertyInfo propertyInfo);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
private static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo, MethodInfo propertyGetterWrapperMethod, MethodInfo propertyGetterByRefWrapperMethod);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
[RequiresDynamicCodeAttribute("This API requires dynamic code because it makes generic types which may be filled with ValueTypes.")]
private static Func`2<object, object> MakeFastPropertyGetter(Type openGenericDelegateType, MethodInfo propertyGetMethod, MethodInfo openGenericWrapperMethod);
    [RequiresUnreferencedCodeAttribute("This API is not trimmer safe.")]
public static Action`2<object, object> MakeFastPropertySetter(PropertyInfo propertyInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Method uses reflection to generate the dictionary.")]
public static IDictionary`2<string, object> ObjectToDictionary(object value);
    private static object CallPropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallPropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static void CallPropertySetter(Action`2<TDeclaringType, TValue> setter, object target, object value);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetVisibleProperties(Type type, ConcurrentDictionary`2<Type, PropertyHelper[]> allPropertiesCache, ConcurrentDictionary`2<Type, PropertyHelper[]> visiblePropertiesCache);
    [RequiresUnreferencedCodeAttribute("This API is not trim safe.")]
public static PropertyHelper[] GetProperties(Type type, ConcurrentDictionary`2<Type, PropertyHelper[]> cache);
    private static bool IsInterestingProperty(PropertyInfo property);
    [CompilerGeneratedAttribute]
internal static void <GetProperties>g__AddInterestingProperties|39_0(List`1<PropertyHelper> propertyHelpers, Type type);
}
internal enum Microsoft.Net.Http.Headers.HttpParseResult : Enum {
    public int value__;
    public static HttpParseResult Parsed;
    public static HttpParseResult NotParsed;
    public static HttpParseResult InvalidFormat;
}
internal static class Microsoft.Net.Http.Headers.HttpRuleParser : object {
    private static SearchValues`1<char> TokenChars;
    private static int MaxNestedCount;
    private static String[] DateFormats;
    internal static char CR;
    internal static char LF;
    internal static char SP;
    internal static char Tab;
    internal static int MaxInt64Digits;
    internal static int MaxInt32Digits;
    [NullableAttribute("1")]
internal static Encoding DefaultHttpEncoding;
    private static HttpRuleParser();
    internal static int GetTokenLength(StringSegment input, int startIndex);
    internal static int GetWhitespaceLength(StringSegment input, int startIndex);
    internal static int GetNumberLength(StringSegment input, int startIndex, bool allowDecimal);
    internal static HttpParseResult GetQuotedStringLength(StringSegment input, int startIndex, Int32& length);
    internal static HttpParseResult GetQuotedPairLength(StringSegment input, int startIndex, Int32& length);
    internal static bool TryStringToDate(StringSegment input, DateTimeOffset& result);
    private static HttpParseResult GetExpressionLength(StringSegment input, int startIndex, char openChar, char closeChar, bool supportsNesting, Int32& nestedCount, Int32& length);
}
internal static class System.Runtime.CompilerServices.TypeHelper : object {
    [NullableContextAttribute("2")]
internal static bool IsCompilerGeneratedType(Type type);
    private static bool IsCompilerGeneratedMethod(MethodInfo method);
    private static bool TryParseLocalFunctionName(string generatedName, String& originalName);
    [NullableContextAttribute("1")]
internal static bool TryGetNonCompilerGeneratedMethodName(MethodInfo method, String& originalName);
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F74B1AE921BCEFE4BA601AA541C7A23B1CA9711EA81E8FE504B5B6446748E035A__GetAlphaRouteRegex_0 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F74B1AE921BCEFE4BA601AA541C7A23B1CA9711EA81E8FE504B5B6446748E035A__GetAlphaRouteRegex_0 Instance;
    private static <RegexGenerator_g>F74B1AE921BCEFE4BA601AA541C7A23B1CA9711EA81E8FE504B5B6446748E035A__GetAlphaRouteRegex_0();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F74B1AE921BCEFE4BA601AA541C7A23B1CA9711EA81E8FE504B5B6446748E035A__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    [NullableAttribute("1")]
internal static SearchValues`1<char> s_asciiLetters;
    private static <RegexGenerator_g>F74B1AE921BCEFE4BA601AA541C7A23B1CA9711EA81E8FE504B5B6446748E035A__Utilities();
}
