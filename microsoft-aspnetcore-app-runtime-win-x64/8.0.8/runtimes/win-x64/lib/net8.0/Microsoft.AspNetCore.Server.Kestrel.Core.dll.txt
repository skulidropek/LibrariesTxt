internal enum Microsoft.AspNetCore.Certificates.Generation.CertificateKeyExportFormat : Enum {
    public int value__;
    public static CertificateKeyExportFormat Pfx;
    public static CertificateKeyExportFormat Pem;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Certificates.Generation.CertificateManager : object {
    internal static int CurrentAspNetCoreCertificateVersion;
    internal static string AspNetHttpsOid;
    internal static string AspNetHttpsOidFriendlyName;
    private static string ServerAuthenticationEnhancedKeyUsageOid;
    private static string ServerAuthenticationEnhancedKeyUsageOidFriendlyName;
    private static string LocalhostHttpsDnsName;
    private static string LocalhostHttpsDistinguishedName;
    public static int RSAMinimumKeySizeInBits;
    [CompilerGeneratedAttribute]
private static CertificateManager <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateManagerEventSource <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AspNetHttpsCertificateVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    public static CertificateManager Instance { get; }
    public static CertificateManagerEventSource Log { get; public set; }
    public int AspNetHttpsCertificateVersion { get; internal set; }
    public string Subject { get; }
    internal CertificateManager(string subject, int version);
    private static CertificateManager();
    [CompilerGeneratedAttribute]
public static CertificateManager get_Instance();
    [CompilerGeneratedAttribute]
public static CertificateManagerEventSource get_Log();
    [CompilerGeneratedAttribute]
public static void set_Log(CertificateManagerEventSource value);
    [CompilerGeneratedAttribute]
public int get_AspNetHttpsCertificateVersion();
    [CompilerGeneratedAttribute]
internal void set_AspNetHttpsCertificateVersion(int value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    public static bool IsHttpsDevelopmentCertificate(X509Certificate2 certificate);
    public IList`1<X509Certificate2> ListCertificates(StoreName storeName, StoreLocation location, bool isValid, bool requireExportable);
    protected virtual void PopulateCertificatesFromStore(X509Store store, List`1<X509Certificate2> certificates, bool requireExportable);
    public IList`1<X509Certificate2> GetHttpsCertificates();
    [NullableContextAttribute("2")]
public EnsureCertificateResult EnsureAspNetCoreHttpsDevelopmentCertificate(DateTimeOffset notBefore, DateTimeOffset notAfter, string path, bool trust, bool includePrivateKey, string password, CertificateKeyExportFormat keyExportFormat, bool isInteractive);
    internal ImportCertificateResult ImportCertificate(string certificatePath, string password);
    public void CleanupHttpsCertificates();
    public abstract virtual bool IsTrusted(X509Certificate2 certificate);
    protected abstract virtual X509Certificate2 SaveCertificateCore(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation);
    protected abstract virtual void TrustCertificateCore(X509Certificate2 certificate);
    protected abstract virtual bool IsExportable(X509Certificate2 c);
    protected abstract virtual void RemoveCertificateFromTrustedRoots(X509Certificate2 certificate);
    protected abstract virtual IList`1<X509Certificate2> GetCertificatesToRemove(StoreName storeName, StoreLocation storeLocation);
    internal static void ExportCertificate(X509Certificate2 certificate, string path, bool includePrivateKey, string password, CertificateKeyExportFormat format);
    internal X509Certificate2 CreateAspNetCoreHttpsDevelopmentCertificate(DateTimeOffset notBefore, DateTimeOffset notAfter);
    internal X509Certificate2 SaveCertificate(X509Certificate2 certificate);
    internal void TrustCertificate(X509Certificate2 certificate);
    internal void RemoveAllCertificates(StoreName storeName, StoreLocation storeLocation);
    internal void RemoveCertificate(X509Certificate2 certificate, RemoveLocations locations);
    internal abstract virtual CheckCertificateStateResult CheckCertificateState(X509Certificate2 candidate, bool interactive);
    internal abstract virtual void CorrectCertificateState(X509Certificate2 candidate);
    internal static X509Certificate2 CreateSelfSignedCertificate(X500DistinguishedName subject, IEnumerable`1<X509Extension> extensions, DateTimeOffset notBefore, DateTimeOffset notAfter);
    internal static void DisposeCertificates(IEnumerable`1<X509Certificate2> disposables);
    protected virtual void RemoveCertificateFromUserStore(X509Certificate2 certificate);
    protected virtual void RemoveCertificateFromUserStoreCore(X509Certificate2 certificate);
    internal static string ToCertificateDescription(IEnumerable`1<X509Certificate2> certificates);
    internal static string GetDescription(X509Certificate2 c);
    [CompilerGeneratedAttribute]
internal static bool <ListCertificates>g__HasOid|25_0(X509Certificate2 certificate, string oid);
    [CompilerGeneratedAttribute]
internal static byte <ListCertificates>g__GetCertificateVersion|25_1(X509Certificate2 c);
    [CompilerGeneratedAttribute]
private bool <EnsureAspNetCoreHttpsDevelopmentCertificate>b__28_0(X509Certificate2 c);
    [CompilerGeneratedAttribute]
private bool <CleanupHttpsCertificates>b__30_0(X509Certificate2 c);
    [CompilerGeneratedAttribute]
private bool <RemoveAllCertificates>b__41_0(X509Certificate2 c);
    [CompilerGeneratedAttribute]
internal static RSA <CreateSelfSignedCertificate>g__CreateKeyMaterial|45_0(int minimumKeySize);
}
internal enum Microsoft.AspNetCore.Certificates.Generation.CertificatePurpose : Enum {
    public int value__;
    public static CertificatePurpose All;
    public static CertificatePurpose HTTPS;
}
internal enum Microsoft.AspNetCore.Certificates.Generation.EnsureCertificateResult : Enum {
    public int value__;
    public static EnsureCertificateResult Succeeded;
    public static EnsureCertificateResult ValidCertificatePresent;
    public static EnsureCertificateResult ErrorCreatingTheCertificate;
    public static EnsureCertificateResult ErrorSavingTheCertificateIntoTheCurrentUserPersonalStore;
    public static EnsureCertificateResult ErrorExportingTheCertificate;
    public static EnsureCertificateResult FailedToTrustTheCertificate;
    public static EnsureCertificateResult UserCancelledTrustStep;
    public static EnsureCertificateResult FailedToMakeKeyAccessible;
    public static EnsureCertificateResult ExistingHttpsCertificateTrusted;
    public static EnsureCertificateResult NewHttpsCertificateTrusted;
}
internal enum Microsoft.AspNetCore.Certificates.Generation.ImportCertificateResult : Enum {
    public int value__;
    public static ImportCertificateResult Succeeded;
    public static ImportCertificateResult CertificateFileMissing;
    public static ImportCertificateResult InvalidCertificate;
    public static ImportCertificateResult NoDevelopmentHttpsCertificate;
    public static ImportCertificateResult ExistingCertificatesPresent;
    public static ImportCertificateResult ErrorSavingTheCertificateIntoTheCurrentUserPersonalStore;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Certificates.Generation.MacOSCertificateManager : CertificateManager {
    private static string MacOSUserKeychain;
    private static string MacOSSystemKeychain;
    private static string MacOSUserHttpsCertificateLocation;
    private static string MacOSVerifyCertificateCommandLine;
    private static string MacOSVerifyCertificateCommandLineArgumentsFormat;
    private static string MacOSDeleteCertificateCommandLine;
    private static string MacOSDeleteCertificateCommandLineArgumentsFormat;
    private static string MacOSTrustCertificateCommandLine;
    private static string MacOSTrustCertificateCommandLineArguments;
    private static string MacOSAddCertificateToKeyChainCommandLine;
    private static string MacOSAddCertificateToKeyChainCommandLineArgumentsFormat;
    private static string MacOSUntrustLegacyCertificateCommandLine;
    private static string MacOSUntrustLegacyCertificateCommandLineArguments;
    private static string MacOSFindCertificateOnKeychainCommandLine;
    private static string MacOSFindCertificateOnKeychainCommandLineArgumentsFormat;
    private static string MacOSFindCertificateOutputRegex;
    public static string InvalidCertificateState;
    public static string KeyNotAccessibleWithoutUserInteraction;
    internal MacOSCertificateManager(string subject, int version);
    private static MacOSCertificateManager();
    protected virtual void TrustCertificateCore(X509Certificate2 publicCertificate);
    internal virtual CheckCertificateStateResult CheckCertificateState(X509Certificate2 candidate, bool interactive);
    internal virtual void CorrectCertificateState(X509Certificate2 candidate);
    public virtual bool IsTrusted(X509Certificate2 certificate);
    protected virtual void RemoveCertificateFromTrustedRoots(X509Certificate2 certificate);
    private static void RemoveAdminTrustRule(X509Certificate2 certificate);
    private static void RemoveCertificateFromKeychain(string keychain, X509Certificate2 certificate);
    private static bool IsCertOnKeychain(string keychain, X509Certificate2 certificate);
    protected virtual bool IsExportable(X509Certificate2 c);
    protected virtual X509Certificate2 SaveCertificateCore(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation);
    private static void SaveCertificateToUserKeychain(X509Certificate2 certificate);
    private static string GetCertificateFilePath(X509Certificate2 certificate);
    protected virtual IList`1<X509Certificate2> GetCertificatesToRemove(StoreName storeName, StoreLocation storeLocation);
    protected virtual void PopulateCertificatesFromStore(X509Store store, List`1<X509Certificate2> certificates, bool requireExportable);
    private static ICollection`1<X509Certificate2> GetCertsFromDisk();
    protected virtual void RemoveCertificateFromUserStoreCore(X509Certificate2 certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Certificates.Generation.UnixCertificateManager : CertificateManager {
    internal UnixCertificateManager(string subject, int version);
    public virtual bool IsTrusted(X509Certificate2 certificate);
    protected virtual X509Certificate2 SaveCertificateCore(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation);
    internal virtual CheckCertificateStateResult CheckCertificateState(X509Certificate2 candidate, bool interactive);
    internal virtual void CorrectCertificateState(X509Certificate2 candidate);
    protected virtual bool IsExportable(X509Certificate2 c);
    protected virtual void TrustCertificateCore(X509Certificate2 certificate);
    protected virtual void RemoveCertificateFromTrustedRoots(X509Certificate2 certificate);
    protected virtual IList`1<X509Certificate2> GetCertificatesToRemove(StoreName storeName, StoreLocation storeLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
internal class Microsoft.AspNetCore.Certificates.Generation.WindowsCertificateManager : CertificateManager {
    private static int UserCancelledErrorCode;
    internal WindowsCertificateManager(string subject, int version);
    protected virtual bool IsExportable(X509Certificate2 c);
    internal virtual CheckCertificateStateResult CheckCertificateState(X509Certificate2 candidate, bool interactive);
    internal virtual void CorrectCertificateState(X509Certificate2 candidate);
    protected virtual X509Certificate2 SaveCertificateCore(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation);
    protected virtual void TrustCertificateCore(X509Certificate2 certificate);
    protected virtual void RemoveCertificateFromTrustedRoots(X509Certificate2 certificate);
    public virtual bool IsTrusted(X509Certificate2 certificate);
    protected virtual IList`1<X509Certificate2> GetCertificatesToRemove(StoreName storeName, StoreLocation storeLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions : object {
    private static int SdListenFdsStart;
    private static string ListenPidEnvVar;
    private static string ListenFdsEnvVar;
    [ExtensionAttribute]
public static KestrelServerOptions UseSystemd(KestrelServerOptions options);
    [ExtensionAttribute]
public static KestrelServerOptions UseSystemd(KestrelServerOptions options, Action`1<ListenOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions : object {
    [ExtensionAttribute]
public static ListenOptions UseConnectionLogging(ListenOptions listenOptions);
    [ExtensionAttribute]
public static ListenOptions UseConnectionLogging(ListenOptions listenOptions, string loggerName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions : object {
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName, string password);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, string fileName, string password, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid, StoreLocation location);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, StoreName storeName, string subject, bool allowInvalid, StoreLocation location, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, X509Certificate2 serverCertificate);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, X509Certificate2 serverCertificate, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, Action`1<HttpsConnectionAdapterOptions> configureOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, ServerOptionsSelectionCallback serverOptionsSelectionCallback, object state);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, ServerOptionsSelectionCallback serverOptionsSelectionCallback, object state, TimeSpan handshakeTimeout);
    [ExtensionAttribute]
public static ListenOptions UseHttps(ListenOptions listenOptions, TlsHandshakeCallbackOptions callbackOptions);
}
internal static class Microsoft.AspNetCore.Http.HttpCharacters : object {
    private static string AlphaNumeric;
    private static SearchValues`1<byte> _allowedAuthorityBytes;
    private static SearchValues`1<char> _allowedHostChars;
    private static SearchValues`1<char> _allowedTokenChars;
    private static SearchValues`1<byte> _allowedTokenBytes;
    private static SearchValues`1<char> _allowedFieldChars;
    private static SearchValues`1<char> _invalidFieldChars;
    private static HttpCharacters();
    public static bool ContainsInvalidAuthorityChar(ReadOnlySpan`1<byte> span);
    public static int IndexOfInvalidHostChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidTokenChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidTokenChar(ReadOnlySpan`1<byte> span);
    public static int IndexOfInvalidFieldValueChar(ReadOnlySpan`1<char> span);
    public static int IndexOfInvalidFieldValueCharExtended(ReadOnlySpan`1<char> span);
}
internal class Microsoft.AspNetCore.Internal.CancellationTokenSourcePool : object {
    private static int MaxQueueSize;
    private ConcurrentQueue`1<PooledCancellationTokenSource> _queue;
    private int _count;
    [NullableContextAttribute("1")]
public PooledCancellationTokenSource Rent();
    private bool Return(PooledCancellationTokenSource cts);
}
internal class Microsoft.AspNetCore.Internal.UrlDecoder : object {
    private static ReadOnlySpan`1<sbyte> CharToHexLookup { get; }
    public static int DecodeRequestLine(ReadOnlySpan`1<byte> source, Span`1<byte> destination, bool isFormEncoding);
    public static int DecodeInPlace(Span`1<byte> buffer, bool isFormEncoding);
    private static bool DecodeCore(Int32& sourceIndex, Int32& destinationIndex, Span`1<byte> buffer, bool isFormEncoding);
    private static void Copy(int begin, int end, Int32& writer, Span`1<T> buffer);
    private static int UnescapePercentEncoding(Int32& scan, Span`1<byte> buffer, bool isFormEncoding);
    private static int ReadHex(Int32& scan, Span`1<byte> buffer);
    private static bool SkipUnescape(int value1, int value2, bool isFormEncoding);
    public static int DecodeRequestLine(ReadOnlySpan`1<char> source, Span`1<char> destination);
    public static int DecodeInPlace(Span`1<char> buffer);
    private static bool DecodeCore(Int32& sourceIndex, Int32& destinationIndex, Span`1<char> buffer);
    private static int UnescapePercentEncoding(Int32& scan, ReadOnlySpan`1<char> buffer);
    private static int ReadHex(Int32& scan, ReadOnlySpan`1<char> buffer);
    private static int FromChar(int c);
    private static ReadOnlySpan`1<sbyte> get_CharToHexLookup();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Internal.ValueTaskExtensions : object {
    [ExtensionAttribute]
public static Task GetAsTask(ValueTask`1& valueTask);
    [ExtensionAttribute]
public static ValueTask GetAsValueTask(ValueTask`1& valueTask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.InternalHeaderNames : object {
    public static string Authority;
    public static string Method;
    public static string Path;
    public static string Scheme;
    public static string Status;
    public static string Protocol;
    public static string AltUsed;
    private static InternalHeaderNames();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.AnyIPListenOptions : ListenOptions {
    internal AnyIPListenOptions(int port);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.AnyIPListenOptions/<BindAsync>d__1")]
internal virtual Task BindAsync(AddressBindContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(AddressBindContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Moved to Microsoft.AspNetCore.Http.BadHttpRequestException. See https://aka.ms/badhttprequestexception for details.")]
public class Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException : BadHttpRequestException {
    [CompilerGeneratedAttribute]
private StringValues <AllowedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestRejectionReason <Reason>k__BackingField;
    public int StatusCode { get; }
    internal StringValues AllowedHeader { get; }
    internal RequestRejectionReason Reason { get; }
    internal BadHttpRequestException(string message, int statusCode, RequestRejectionReason reason);
    internal BadHttpRequestException(string message, int statusCode, RequestRejectionReason reason, Nullable`1<HttpMethod> requiredMethod);
    public int get_StatusCode();
    [CompilerGeneratedAttribute]
internal StringValues get_AllowedHeader();
    [CompilerGeneratedAttribute]
internal RequestRejectionReason get_Reason();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.CertificateAndConfig : ValueType {
    public X509Certificate2 Certificate;
    public CertificateConfig CertificateConfig;
    public CertificateAndConfig(X509Certificate2 certificate, CertificateConfig certificateConfig);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.CoreStrings : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string BadRequest { get; }
    internal static string BadRequest_BadChunkSizeData { get; }
    internal static string BadRequest_BadChunkSuffix { get; }
    internal static string BadRequest_ChunkedRequestIncomplete { get; }
    internal static string BadRequest_FinalTransferCodingNotChunked { get; }
    internal static string BadRequest_HeadersExceedMaxTotalSize { get; }
    internal static string BadRequest_InvalidCharactersInHeaderName { get; }
    internal static string BadRequest_InvalidContentLength_Detail { get; }
    internal static string BadRequest_InvalidHostHeader { get; }
    internal static string BadRequest_InvalidHostHeader_Detail { get; }
    internal static string BadRequest_InvalidRequestHeadersNoCRLF { get; }
    internal static string BadRequest_InvalidRequestHeader_Detail { get; }
    internal static string BadRequest_InvalidRequestLine { get; }
    internal static string BadRequest_InvalidRequestLine_Detail { get; }
    internal static string BadRequest_InvalidRequestTarget_Detail { get; }
    internal static string BadRequest_LengthRequiredHttp10 { get; }
    internal static string BadRequest_MalformedRequestInvalidHeaders { get; }
    internal static string BadRequest_MethodNotAllowed { get; }
    internal static string BadRequest_MissingHostHeader { get; }
    internal static string BadRequest_MultipleContentLengths { get; }
    internal static string BadRequest_MultipleHostHeaders { get; }
    internal static string BadRequest_RequestLineTooLong { get; }
    internal static string BadRequest_RequestHeadersTimeout { get; }
    internal static string BadRequest_TooManyHeaders { get; }
    internal static string BadRequest_UnexpectedEndOfRequestContent { get; }
    internal static string BadRequest_UnrecognizedHTTPVersion { get; }
    internal static string FallbackToIPv4Any { get; }
    internal static string ResponseStreamWasUpgraded { get; }
    internal static string BigEndianNotSupported { get; }
    internal static string MaxRequestBufferSmallerThanRequestHeaderBuffer { get; }
    internal static string MaxRequestBufferSmallerThanRequestLineBuffer { get; }
    internal static string ServerAlreadyStarted { get; }
    internal static string UnknownTransportMode { get; }
    internal static string InvalidAsciiOrControlChar { get; }
    internal static string InvalidContentLength_InvalidNumber { get; }
    internal static string NonNegativeNumberOrNullRequired { get; }
    internal static string NonNegativeNumberRequired { get; }
    internal static string PositiveNumberRequired { get; }
    internal static string PositiveNumberOrNullRequired { get; }
    internal static string UnixSocketPathMustBeAbsolute { get; }
    internal static string AddressBindingFailed { get; }
    internal static string BindingToDefaultAddress { get; }
    internal static string ConfigurePathBaseFromMethodCall { get; }
    internal static string DynamicPortOnLocalhostNotSupported { get; }
    internal static string EndpointAlreadyInUse { get; }
    internal static string NetworkInterfaceBindingFailed { get; }
    internal static string OverridingWithKestrelOptions { get; }
    internal static string OverridingWithPreferHostingUrls { get; }
    internal static string UnsupportedAddressScheme { get; }
    internal static string HeadersAreReadOnly { get; }
    internal static string KeyAlreadyExists { get; }
    internal static string HeaderNotAllowedOnResponse { get; }
    internal static string ParameterReadOnlyAfterResponseStarted { get; }
    internal static string TooFewBytesWritten { get; }
    internal static string TooManyBytesWritten { get; }
    internal static string UnhandledApplicationException { get; }
    internal static string WritingToResponseBodyNotSupported { get; }
    internal static string ConnectionShutdownError { get; }
    internal static string RequestProcessingEndError { get; }
    internal static string CannotUpgradeNonUpgradableRequest { get; }
    internal static string UpgradedConnectionLimitReached { get; }
    internal static string UpgradeCannotBeCalledMultipleTimes { get; }
    internal static string BadRequest_RequestBodyTooLarge { get; }
    internal static string MaxRequestBodySizeCannotBeModifiedAfterRead { get; }
    internal static string MaxRequestBodySizeCannotBeModifiedForUpgradedRequests { get; }
    internal static string PositiveTimeSpanRequired { get; }
    internal static string MinimumGracePeriodRequired { get; }
    internal static string SynchronousReadsDisallowed { get; }
    internal static string SynchronousWritesDisallowed { get; }
    internal static string PositiveNumberOrNullMinDataRateRequired { get; }
    internal static string ConcurrentTimeoutsNotSupported { get; }
    internal static string PositiveFiniteTimeSpanRequired { get; }
    internal static string EndPointRequiresAtLeastOneProtocol { get; }
    internal static string EndPointHttp2NotNegotiated { get; }
    internal static string Http2ErrorStreamIdEven { get; }
    internal static string Http2ErrorPushPromiseReceived { get; }
    internal static string Http2ErrorHeadersInterleaved { get; }
    internal static string Http2ErrorStreamIdZero { get; }
    internal static string Http2ErrorStreamIdNotZero { get; }
    internal static string Http2ErrorPaddingTooLong { get; }
    internal static string Http2ErrorStreamClosed { get; }
    internal static string Http2ErrorStreamHalfClosedRemote { get; }
    internal static string Http2ErrorStreamSelfDependency { get; }
    internal static string Http2ErrorUnexpectedFrameLength { get; }
    internal static string Http2ErrorSettingsLengthNotMultipleOfSix { get; }
    internal static string Http2ErrorSettingsAckLengthNotZero { get; }
    internal static string Http2ErrorSettingsParameterOutOfRange { get; }
    internal static string Http2ErrorWindowUpdateIncrementZero { get; }
    internal static string Http2ErrorContinuationWithNoHeaders { get; }
    internal static string Http2ErrorStreamIdle { get; }
    internal static string HttpErrorTrailersContainPseudoHeaderField { get; }
    internal static string HttpErrorHeaderNameUppercase { get; }
    internal static string HttpErrorTrailerNameUppercase { get; }
    internal static string Http2ErrorHeadersWithTrailersNoEndStream { get; }
    internal static string HttpErrorMissingMandatoryPseudoHeaderFields { get; }
    internal static string HttpErrorPseudoHeaderFieldAfterRegularHeaders { get; }
    internal static string HttpErrorUnknownPseudoHeaderField { get; }
    internal static string HttpErrorResponsePseudoHeaderField { get; }
    internal static string HttpErrorDuplicatePseudoHeaderField { get; }
    internal static string HttpErrorConnectionSpecificHeaderField { get; }
    internal static string InvalidServerCertificateEku { get; }
    internal static string ServerCertificateRequired { get; }
    internal static string CertNotFoundInStore { get; }
    internal static string EndpointMissingUrl { get; }
    internal static string NoCertSpecifiedNoDevelopmentCertificateFound { get; }
    internal static string MultipleCertificateSources { get; }
    internal static string WritingToResponseBodyAfterResponseCompleted { get; }
    internal static string BadRequest_RequestBodyTimeout { get; }
    internal static string ConnectionAbortedByApplication { get; }
    internal static string ConnectionAbortedDuringServerShutdown { get; }
    internal static string ConnectionTimedBecauseResponseMininumDataRateNotSatisfied { get; }
    internal static string ConnectionTimedOutByServer { get; }
    internal static string Http2ErrorFrameOverLimit { get; }
    internal static string Http2ErrorMinTlsVersion { get; }
    internal static string Http2ErrorInvalidPreface { get; }
    internal static string InvalidEmptyHeaderName { get; }
    internal static string ConnectionOrStreamAbortedByCancellationToken { get; }
    internal static string Http2ErrorInitialWindowSizeInvalid { get; }
    internal static string Http2ErrorWindowUpdateSizeInvalid { get; }
    internal static string Http2ConnectionFaulted { get; }
    internal static string HttpStreamResetByClient { get; }
    internal static string Http2StreamAborted { get; }
    internal static string Http2ErrorFlowControlWindowExceeded { get; }
    internal static string Http2ErrorConnectMustNotSendSchemeOrPath { get; }
    internal static string Http2ErrorMethodInvalid { get; }
    internal static string Http2StreamErrorPathInvalid { get; }
    internal static string Http2StreamErrorSchemeMismatch { get; }
    internal static string Http2StreamErrorLessDataThanLength { get; }
    internal static string Http2StreamErrorMoreDataThanLength { get; }
    internal static string Http2StreamErrorAfterHeaders { get; }
    internal static string Http2ErrorMaxStreams { get; }
    internal static string Http3ErrorConnectMustNotSendSchemeOrPath { get; }
    internal static string Http3StreamErrorSchemeMismatch { get; }
    internal static string Http3ErrorMethodInvalid { get; }
    internal static string Http3StreamErrorPathInvalid { get; }
    internal static string Http3StreamErrorLessDataThanLength { get; }
    internal static string Http3StreamErrorMoreDataThanLength { get; }
    internal static string GreaterThanZeroRequired { get; }
    internal static string ArgumentOutOfRange { get; }
    internal static string ConnectionAbortedByClient { get; }
    internal static string Http2ErrorStreamAborted { get; }
    internal static string HttpMinDataRateNotSupported { get; }
    internal static string RequestTrailersNotAvailable { get; }
    internal static string Http2NoTlsAlpn { get; }
    internal static string Http2StreamResetByApplication { get; }
    internal static string Http2TellClientToCalmDown { get; }
    internal static string HttpParserTlsOverHttpError { get; }
    internal static string BadDeveloperCertificateState { get; }
    internal static string QPackErrorIndexOutOfRange { get; }
    internal static string QPackErrorIntegerTooBig { get; }
    internal static string QPackHuffmanError { get; }
    internal static string QPackStringLengthTooLarge { get; }
    internal static string QuicTransportNotFound { get; }
    internal static string TransportNotFound { get; }
    internal static string GreaterThanOrEqualToZeroRequired { get; }
    internal static string Http2NoTlsWin81 { get; }
    internal static string Http2ErrorKeepAliveTimeout { get; }
    internal static string ArgumentTimeSpanGreaterOrEqual { get; }
    internal static string InvalidPemKey { get; }
    internal static string UnrecognizedCertificateKeyOid { get; }
    internal static string SniNotConfiguredForServerName { get; }
    internal static string SniNotConfiguredToAllowNoServerName { get; }
    internal static string SniNameCannotBeEmpty { get; }
    internal static string EndpointHasUnusedHttpsConfig { get; }
    internal static string Http3ConnectionFaulted { get; }
    internal static string Http3StreamAborted { get; }
    internal static string Http3StreamResetByApplication { get; }
    internal static string Http3StreamErrorAfterHeaders { get; }
    internal static string Http3StreamErrorDataReceivedBeforeHeaders { get; }
    internal static string Http3StreamErrorFrameReceivedAfterTrailers { get; }
    internal static string Http3ErrorUnsupportedFrameOnRequestStream { get; }
    internal static string Http3ErrorUnsupportedFrameOnServer { get; }
    internal static string Http3ErrorUnsupportedFrameOnControlStream { get; }
    internal static string Http3ErrorControlStreamMultipleSettingsFrames { get; }
    internal static string Http3ErrorControlStreamFrameReceivedBeforeSettings { get; }
    internal static string Http3ErrorControlStreamReservedSetting { get; }
    internal static string Http3ControlStreamErrorMultipleInboundStreams { get; }
    internal static string Http3StreamErrorRequestEndedNoHeaders { get; }
    internal static string Http3ControlStreamHeaderTimeout { get; }
    internal static string Http3ErrorControlStreamClientClosedInbound { get; }
    internal static string Http3ControlStreamErrorUnsupportedType { get; }
    internal static string Http3ControlStreamErrorInitializingOutbound { get; }
    internal static string Http3DatagramStatusMismatch { get; }
    internal static string Http3MethodMustBeConnectWhenUsingProtocolPseudoHeader { get; }
    internal static string Http3MissingAuthorityOrPathPseudoHeaders { get; }
    internal static string ConnectRequestsWithProtocolRequireSchemeAndPath { get; }
    internal static string ProtocolRequiresConnect { get; }
    internal static string CannotAcceptNonConnectRequest { get; }
    internal static string AcceptCannotBeCalledMultipleTimes { get; }
    internal static string ConnectStatusMustBe2XX { get; }
    internal static string AttemptedToReadHeaderOnAbortedStream { get; }
    internal static string ReceivedLooseWebTransportStream { get; }
    internal static string UnidentifiedStream { get; }
    internal static string WebTransportFailedToAddStreamToPendingQueue { get; }
    internal static string FailedToNegotiateCommonWebTransportVersion { get; }
    internal static string WebTransportIsDisabled { get; }
    internal static string DynamicPortOnMultipleTransportsNotSupported { get; }
    internal static string NonzeroContentLengthNotAllowedOn205 { get; }
    internal static string Http3ErrorControlStreamClosed { get; }
    internal static string ConnectResponseCanNotHaveBody { get; }
    internal static string FailedToBindToIPv6Any { get; }
    internal static string NeedHttpsConfigurationToApplyHttpsConfiguration { get; }
    internal static string NeedHttpsConfigurationToLoadDefaultCertificate { get; }
    internal static string NeedHttpsConfigurationToUseHttp3 { get; }
    internal static string NeedHttpsConfigurationToBindHttpsAddresses { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_BadRequest();
    internal static string get_BadRequest_BadChunkSizeData();
    internal static string get_BadRequest_BadChunkSuffix();
    internal static string get_BadRequest_ChunkedRequestIncomplete();
    internal static string get_BadRequest_FinalTransferCodingNotChunked();
    internal static string FormatBadRequest_FinalTransferCodingNotChunked(object detail);
    internal static string get_BadRequest_HeadersExceedMaxTotalSize();
    internal static string get_BadRequest_InvalidCharactersInHeaderName();
    internal static string get_BadRequest_InvalidContentLength_Detail();
    internal static string FormatBadRequest_InvalidContentLength_Detail(object detail);
    internal static string get_BadRequest_InvalidHostHeader();
    internal static string get_BadRequest_InvalidHostHeader_Detail();
    internal static string FormatBadRequest_InvalidHostHeader_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestHeadersNoCRLF();
    internal static string get_BadRequest_InvalidRequestHeader_Detail();
    internal static string FormatBadRequest_InvalidRequestHeader_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestLine();
    internal static string get_BadRequest_InvalidRequestLine_Detail();
    internal static string FormatBadRequest_InvalidRequestLine_Detail(object detail);
    internal static string get_BadRequest_InvalidRequestTarget_Detail();
    internal static string FormatBadRequest_InvalidRequestTarget_Detail(object detail);
    internal static string get_BadRequest_LengthRequiredHttp10();
    internal static string FormatBadRequest_LengthRequiredHttp10(object detail);
    internal static string get_BadRequest_MalformedRequestInvalidHeaders();
    internal static string get_BadRequest_MethodNotAllowed();
    internal static string get_BadRequest_MissingHostHeader();
    internal static string get_BadRequest_MultipleContentLengths();
    internal static string get_BadRequest_MultipleHostHeaders();
    internal static string get_BadRequest_RequestLineTooLong();
    internal static string get_BadRequest_RequestHeadersTimeout();
    internal static string get_BadRequest_TooManyHeaders();
    internal static string get_BadRequest_UnexpectedEndOfRequestContent();
    internal static string get_BadRequest_UnrecognizedHTTPVersion();
    internal static string FormatBadRequest_UnrecognizedHTTPVersion(object detail);
    internal static string get_FallbackToIPv4Any();
    internal static string FormatFallbackToIPv4Any(object port);
    internal static string get_ResponseStreamWasUpgraded();
    internal static string get_BigEndianNotSupported();
    internal static string get_MaxRequestBufferSmallerThanRequestHeaderBuffer();
    internal static string FormatMaxRequestBufferSmallerThanRequestHeaderBuffer(object requestBufferSize, object requestHeaderSize);
    internal static string get_MaxRequestBufferSmallerThanRequestLineBuffer();
    internal static string FormatMaxRequestBufferSmallerThanRequestLineBuffer(object requestBufferSize, object requestLineSize);
    internal static string get_ServerAlreadyStarted();
    internal static string get_UnknownTransportMode();
    internal static string FormatUnknownTransportMode(object mode);
    internal static string get_InvalidAsciiOrControlChar();
    internal static string FormatInvalidAsciiOrControlChar(object character);
    internal static string get_InvalidContentLength_InvalidNumber();
    internal static string FormatInvalidContentLength_InvalidNumber(object value);
    internal static string get_NonNegativeNumberOrNullRequired();
    internal static string get_NonNegativeNumberRequired();
    internal static string get_PositiveNumberRequired();
    internal static string get_PositiveNumberOrNullRequired();
    internal static string get_UnixSocketPathMustBeAbsolute();
    internal static string get_AddressBindingFailed();
    internal static string FormatAddressBindingFailed(object address);
    internal static string get_BindingToDefaultAddress();
    internal static string FormatBindingToDefaultAddress(object address);
    internal static string get_ConfigurePathBaseFromMethodCall();
    internal static string FormatConfigurePathBaseFromMethodCall(object methodName);
    internal static string get_DynamicPortOnLocalhostNotSupported();
    internal static string get_EndpointAlreadyInUse();
    internal static string FormatEndpointAlreadyInUse(object endpoint);
    internal static string get_NetworkInterfaceBindingFailed();
    internal static string FormatNetworkInterfaceBindingFailed(object address, object interfaceName, object error);
    internal static string get_OverridingWithKestrelOptions();
    internal static string FormatOverridingWithKestrelOptions(object addresses);
    internal static string get_OverridingWithPreferHostingUrls();
    internal static string FormatOverridingWithPreferHostingUrls(object settingName, object addresses);
    internal static string get_UnsupportedAddressScheme();
    internal static string FormatUnsupportedAddressScheme(object address);
    internal static string get_HeadersAreReadOnly();
    internal static string get_KeyAlreadyExists();
    internal static string get_HeaderNotAllowedOnResponse();
    internal static string FormatHeaderNotAllowedOnResponse(object name, object statusCode);
    internal static string get_ParameterReadOnlyAfterResponseStarted();
    internal static string FormatParameterReadOnlyAfterResponseStarted(object name);
    internal static string get_TooFewBytesWritten();
    internal static string FormatTooFewBytesWritten(object written, object expected);
    internal static string get_TooManyBytesWritten();
    internal static string FormatTooManyBytesWritten(object written, object expected);
    internal static string get_UnhandledApplicationException();
    internal static string get_WritingToResponseBodyNotSupported();
    internal static string FormatWritingToResponseBodyNotSupported(object statusCode);
    internal static string get_ConnectionShutdownError();
    internal static string get_RequestProcessingEndError();
    internal static string get_CannotUpgradeNonUpgradableRequest();
    internal static string get_UpgradedConnectionLimitReached();
    internal static string get_UpgradeCannotBeCalledMultipleTimes();
    internal static string get_BadRequest_RequestBodyTooLarge();
    internal static string FormatBadRequest_RequestBodyTooLarge(object maxRequestBodySize);
    internal static string get_MaxRequestBodySizeCannotBeModifiedAfterRead();
    internal static string get_MaxRequestBodySizeCannotBeModifiedForUpgradedRequests();
    internal static string get_PositiveTimeSpanRequired();
    internal static string get_MinimumGracePeriodRequired();
    internal static string FormatMinimumGracePeriodRequired(object heartbeatInterval);
    internal static string get_SynchronousReadsDisallowed();
    internal static string get_SynchronousWritesDisallowed();
    internal static string get_PositiveNumberOrNullMinDataRateRequired();
    internal static string get_ConcurrentTimeoutsNotSupported();
    internal static string get_PositiveFiniteTimeSpanRequired();
    internal static string get_EndPointRequiresAtLeastOneProtocol();
    internal static string get_EndPointHttp2NotNegotiated();
    internal static string get_Http2ErrorStreamIdEven();
    internal static string FormatHttp2ErrorStreamIdEven(object frameType, object streamId);
    internal static string get_Http2ErrorPushPromiseReceived();
    internal static string get_Http2ErrorHeadersInterleaved();
    internal static string FormatHttp2ErrorHeadersInterleaved(object frameType, object streamId, object headersStreamId);
    internal static string get_Http2ErrorStreamIdZero();
    internal static string FormatHttp2ErrorStreamIdZero(object frameType);
    internal static string get_Http2ErrorStreamIdNotZero();
    internal static string FormatHttp2ErrorStreamIdNotZero(object frameType);
    internal static string get_Http2ErrorPaddingTooLong();
    internal static string FormatHttp2ErrorPaddingTooLong(object frameType);
    internal static string get_Http2ErrorStreamClosed();
    internal static string FormatHttp2ErrorStreamClosed(object frameType, object streamId);
    internal static string get_Http2ErrorStreamHalfClosedRemote();
    internal static string FormatHttp2ErrorStreamHalfClosedRemote(object frameType, object streamId);
    internal static string get_Http2ErrorStreamSelfDependency();
    internal static string FormatHttp2ErrorStreamSelfDependency(object frameType, object streamId);
    internal static string get_Http2ErrorUnexpectedFrameLength();
    internal static string FormatHttp2ErrorUnexpectedFrameLength(object frameType, object expectedLength);
    internal static string get_Http2ErrorSettingsLengthNotMultipleOfSix();
    internal static string get_Http2ErrorSettingsAckLengthNotZero();
    internal static string get_Http2ErrorSettingsParameterOutOfRange();
    internal static string FormatHttp2ErrorSettingsParameterOutOfRange(object parameter);
    internal static string get_Http2ErrorWindowUpdateIncrementZero();
    internal static string get_Http2ErrorContinuationWithNoHeaders();
    internal static string get_Http2ErrorStreamIdle();
    internal static string FormatHttp2ErrorStreamIdle(object frameType, object streamId);
    internal static string get_HttpErrorTrailersContainPseudoHeaderField();
    internal static string get_HttpErrorHeaderNameUppercase();
    internal static string get_HttpErrorTrailerNameUppercase();
    internal static string get_Http2ErrorHeadersWithTrailersNoEndStream();
    internal static string get_HttpErrorMissingMandatoryPseudoHeaderFields();
    internal static string get_HttpErrorPseudoHeaderFieldAfterRegularHeaders();
    internal static string get_HttpErrorUnknownPseudoHeaderField();
    internal static string get_HttpErrorResponsePseudoHeaderField();
    internal static string get_HttpErrorDuplicatePseudoHeaderField();
    internal static string get_HttpErrorConnectionSpecificHeaderField();
    internal static string get_InvalidServerCertificateEku();
    internal static string FormatInvalidServerCertificateEku(object thumbprint);
    internal static string get_ServerCertificateRequired();
    internal static string get_CertNotFoundInStore();
    internal static string FormatCertNotFoundInStore(object subject, object storeLocation, object storeName, object allowInvalid);
    internal static string get_EndpointMissingUrl();
    internal static string FormatEndpointMissingUrl(object endpointName);
    internal static string get_NoCertSpecifiedNoDevelopmentCertificateFound();
    internal static string get_MultipleCertificateSources();
    internal static string FormatMultipleCertificateSources(object endpointName);
    internal static string get_WritingToResponseBodyAfterResponseCompleted();
    internal static string get_BadRequest_RequestBodyTimeout();
    internal static string get_ConnectionAbortedByApplication();
    internal static string get_ConnectionAbortedDuringServerShutdown();
    internal static string get_ConnectionTimedBecauseResponseMininumDataRateNotSatisfied();
    internal static string get_ConnectionTimedOutByServer();
    internal static string get_Http2ErrorFrameOverLimit();
    internal static string FormatHttp2ErrorFrameOverLimit(object size, object limit);
    internal static string get_Http2ErrorMinTlsVersion();
    internal static string FormatHttp2ErrorMinTlsVersion(object protocol);
    internal static string get_Http2ErrorInvalidPreface();
    internal static string get_InvalidEmptyHeaderName();
    internal static string get_ConnectionOrStreamAbortedByCancellationToken();
    internal static string get_Http2ErrorInitialWindowSizeInvalid();
    internal static string get_Http2ErrorWindowUpdateSizeInvalid();
    internal static string get_Http2ConnectionFaulted();
    internal static string get_HttpStreamResetByClient();
    internal static string get_Http2StreamAborted();
    internal static string get_Http2ErrorFlowControlWindowExceeded();
    internal static string get_Http2ErrorConnectMustNotSendSchemeOrPath();
    internal static string get_Http2ErrorMethodInvalid();
    internal static string FormatHttp2ErrorMethodInvalid(object method);
    internal static string get_Http2StreamErrorPathInvalid();
    internal static string FormatHttp2StreamErrorPathInvalid(object path);
    internal static string get_Http2StreamErrorSchemeMismatch();
    internal static string FormatHttp2StreamErrorSchemeMismatch(object requestScheme, object transportScheme);
    internal static string get_Http2StreamErrorLessDataThanLength();
    internal static string get_Http2StreamErrorMoreDataThanLength();
    internal static string get_Http2StreamErrorAfterHeaders();
    internal static string get_Http2ErrorMaxStreams();
    internal static string get_Http3ErrorConnectMustNotSendSchemeOrPath();
    internal static string get_Http3StreamErrorSchemeMismatch();
    internal static string FormatHttp3StreamErrorSchemeMismatch(object requestScheme, object transportScheme);
    internal static string get_Http3ErrorMethodInvalid();
    internal static string FormatHttp3ErrorMethodInvalid(object method);
    internal static string get_Http3StreamErrorPathInvalid();
    internal static string FormatHttp3StreamErrorPathInvalid(object path);
    internal static string get_Http3StreamErrorLessDataThanLength();
    internal static string get_Http3StreamErrorMoreDataThanLength();
    internal static string get_GreaterThanZeroRequired();
    internal static string get_ArgumentOutOfRange();
    internal static string FormatArgumentOutOfRange(object min, object max);
    internal static string get_ConnectionAbortedByClient();
    internal static string get_Http2ErrorStreamAborted();
    internal static string FormatHttp2ErrorStreamAborted(object frameType, object streamId);
    internal static string get_HttpMinDataRateNotSupported();
    internal static string get_RequestTrailersNotAvailable();
    internal static string get_Http2NoTlsAlpn();
    internal static string get_Http2StreamResetByApplication();
    internal static string FormatHttp2StreamResetByApplication(object errorCode);
    internal static string get_Http2TellClientToCalmDown();
    internal static string get_HttpParserTlsOverHttpError();
    internal static string get_BadDeveloperCertificateState();
    internal static string get_QPackErrorIndexOutOfRange();
    internal static string FormatQPackErrorIndexOutOfRange(object index);
    internal static string get_QPackErrorIntegerTooBig();
    internal static string get_QPackHuffmanError();
    internal static string get_QPackStringLengthTooLarge();
    internal static string FormatQPackStringLengthTooLarge(object length, object maxStringLength);
    internal static string get_QuicTransportNotFound();
    internal static string get_TransportNotFound();
    internal static string get_GreaterThanOrEqualToZeroRequired();
    internal static string get_Http2NoTlsWin81();
    internal static string get_Http2ErrorKeepAliveTimeout();
    internal static string get_ArgumentTimeSpanGreaterOrEqual();
    internal static string FormatArgumentTimeSpanGreaterOrEqual(object value);
    internal static string get_InvalidPemKey();
    internal static string get_UnrecognizedCertificateKeyOid();
    internal static string FormatUnrecognizedCertificateKeyOid(object p0);
    internal static string get_SniNotConfiguredForServerName();
    internal static string FormatSniNotConfiguredForServerName(object serverName, object endpointName);
    internal static string get_SniNotConfiguredToAllowNoServerName();
    internal static string FormatSniNotConfiguredToAllowNoServerName(object endpointName);
    internal static string get_SniNameCannotBeEmpty();
    internal static string FormatSniNameCannotBeEmpty(object endpointName);
    internal static string get_EndpointHasUnusedHttpsConfig();
    internal static string FormatEndpointHasUnusedHttpsConfig(object endpointName, object keyName);
    internal static string get_Http3ConnectionFaulted();
    internal static string get_Http3StreamAborted();
    internal static string get_Http3StreamResetByApplication();
    internal static string FormatHttp3StreamResetByApplication(object errorCode);
    internal static string get_Http3StreamErrorAfterHeaders();
    internal static string get_Http3StreamErrorDataReceivedBeforeHeaders();
    internal static string get_Http3StreamErrorFrameReceivedAfterTrailers();
    internal static string FormatHttp3StreamErrorFrameReceivedAfterTrailers(object frameType);
    internal static string get_Http3ErrorUnsupportedFrameOnRequestStream();
    internal static string FormatHttp3ErrorUnsupportedFrameOnRequestStream(object frameType);
    internal static string get_Http3ErrorUnsupportedFrameOnServer();
    internal static string FormatHttp3ErrorUnsupportedFrameOnServer(object frameType);
    internal static string get_Http3ErrorUnsupportedFrameOnControlStream();
    internal static string FormatHttp3ErrorUnsupportedFrameOnControlStream(object frameType);
    internal static string get_Http3ErrorControlStreamMultipleSettingsFrames();
    internal static string get_Http3ErrorControlStreamFrameReceivedBeforeSettings();
    internal static string FormatHttp3ErrorControlStreamFrameReceivedBeforeSettings(object frameType);
    internal static string get_Http3ErrorControlStreamReservedSetting();
    internal static string FormatHttp3ErrorControlStreamReservedSetting(object identifier);
    internal static string get_Http3ControlStreamErrorMultipleInboundStreams();
    internal static string FormatHttp3ControlStreamErrorMultipleInboundStreams(object streamType);
    internal static string get_Http3StreamErrorRequestEndedNoHeaders();
    internal static string get_Http3ControlStreamHeaderTimeout();
    internal static string get_Http3ErrorControlStreamClientClosedInbound();
    internal static string get_Http3ControlStreamErrorUnsupportedType();
    internal static string FormatHttp3ControlStreamErrorUnsupportedType(object type);
    internal static string get_Http3ControlStreamErrorInitializingOutbound();
    internal static string get_Http3DatagramStatusMismatch();
    internal static string FormatHttp3DatagramStatusMismatch(object clientStatus, object serverStatus);
    internal static string get_Http3MethodMustBeConnectWhenUsingProtocolPseudoHeader();
    internal static string get_Http3MissingAuthorityOrPathPseudoHeaders();
    internal static string get_ConnectRequestsWithProtocolRequireSchemeAndPath();
    internal static string get_ProtocolRequiresConnect();
    internal static string get_CannotAcceptNonConnectRequest();
    internal static string get_AcceptCannotBeCalledMultipleTimes();
    internal static string get_ConnectStatusMustBe2XX();
    internal static string get_AttemptedToReadHeaderOnAbortedStream();
    internal static string get_ReceivedLooseWebTransportStream();
    internal static string get_UnidentifiedStream();
    internal static string FormatUnidentifiedStream(object stream);
    internal static string get_WebTransportFailedToAddStreamToPendingQueue();
    internal static string get_FailedToNegotiateCommonWebTransportVersion();
    internal static string FormatFailedToNegotiateCommonWebTransportVersion(object currentSuppportedVersion);
    internal static string get_WebTransportIsDisabled();
    internal static string get_DynamicPortOnMultipleTransportsNotSupported();
    internal static string get_NonzeroContentLengthNotAllowedOn205();
    internal static string get_Http3ErrorControlStreamClosed();
    internal static string get_ConnectResponseCanNotHaveBody();
    internal static string FormatConnectResponseCanNotHaveBody(object StatusCode);
    internal static string get_FailedToBindToIPv6Any();
    internal static string FormatFailedToBindToIPv6Any(object port);
    internal static string get_NeedHttpsConfigurationToApplyHttpsConfiguration();
    internal static string get_NeedHttpsConfigurationToLoadDefaultCertificate();
    internal static string get_NeedHttpsConfigurationToUseHttp3();
    internal static string get_NeedHttpsConfigurationToBindHttpsAddresses();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature {
    public abstract virtual void SetTimeout(TimeSpan timeSpan);
    public abstract virtual void ResetTimeout(TimeSpan timeSpan);
    public abstract virtual void CancelTimeout();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IDecrementConcurrentConnectionCountFeature {
    public abstract virtual void ReleaseConnection();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature {
    public int StreamId { get; }
    public abstract virtual int get_StreamId();
}
[NullableContextAttribute("2")]
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature {
    public MinDataRate MinDataRate { get; public set; }
    public abstract virtual MinDataRate get_MinDataRate();
    public abstract virtual void set_MinDataRate(MinDataRate value);
}
[NullableContextAttribute("2")]
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature {
    public MinDataRate MinDataRate { get; public set; }
    public abstract virtual MinDataRate get_MinDataRate();
    public abstract virtual void set_MinDataRate(MinDataRate value);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.ISslStreamFeature {
    public SslStream SslStream { get; }
    public abstract virtual SslStream get_SslStream();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Features.ITlsApplicationProtocolFeature {
    public ReadOnlyMemory`1<byte> ApplicationProtocol { get; }
    public abstract virtual ReadOnlyMemory`1<byte> get_ApplicationProtocol();
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits : object {
    private int _maxStreamsPerConnection;
    private int _headerTableSize;
    private int _maxFrameSize;
    private int _maxRequestHeaderFieldSize;
    private int _initialConnectionWindowSize;
    private int _initialStreamWindowSize;
    private TimeSpan _keepAlivePingDelay;
    private TimeSpan _keepAlivePingTimeout;
    public int MaxStreamsPerConnection { get; public set; }
    public int HeaderTableSize { get; public set; }
    public int MaxFrameSize { get; public set; }
    public int MaxRequestHeaderFieldSize { get; public set; }
    public int InitialConnectionWindowSize { get; public set; }
    public int InitialStreamWindowSize { get; public set; }
    public TimeSpan KeepAlivePingDelay { get; public set; }
    public TimeSpan KeepAlivePingTimeout { get; public set; }
    public int get_MaxStreamsPerConnection();
    public void set_MaxStreamsPerConnection(int value);
    public int get_HeaderTableSize();
    public void set_HeaderTableSize(int value);
    public int get_MaxFrameSize();
    public void set_MaxFrameSize(int value);
    public int get_MaxRequestHeaderFieldSize();
    public void set_MaxRequestHeaderFieldSize(int value);
    public int get_InitialConnectionWindowSize();
    public void set_InitialConnectionWindowSize(int value);
    public int get_InitialStreamWindowSize();
    public void set_InitialStreamWindowSize(int value);
    public TimeSpan get_KeepAlivePingDelay();
    public void set_KeepAlivePingDelay(TimeSpan value);
    public TimeSpan get_KeepAlivePingTimeout();
    public void set_KeepAlivePingTimeout(TimeSpan value);
    [NullableContextAttribute("1")]
internal void Serialize(Utf8JsonWriter writer);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits : object {
    private int _headerTableSize;
    private int _maxRequestHeaderFieldSize;
    internal int HeaderTableSize { get; internal set; }
    public int MaxRequestHeaderFieldSize { get; public set; }
    internal int get_HeaderTableSize();
    internal void set_HeaderTableSize(int value);
    public int get_MaxRequestHeaderFieldSize();
    public void set_MaxRequestHeaderFieldSize(int value);
    [NullableContextAttribute("1")]
internal void Serialize(Utf8JsonWriter writer);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols : Enum {
    public int value__;
    public static HttpProtocols None;
    public static HttpProtocols Http1;
    public static HttpProtocols Http2;
    public static HttpProtocols Http1AndHttp2;
    public static HttpProtocols Http3;
    public static HttpProtocols Http1AndHttp2AndHttp3;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.HttpsConfigurationService : object {
    private IInitializer _initializer;
    private bool _isInitialized;
    private TlsConfigurationLoader _tlsConfigurationLoader;
    private Action`3<FeatureCollection, ListenOptions, ILogger`1<HttpsConnectionMiddleware>> _populateMultiplexedTransportFeatures;
    private Func`2<ListenOptions, ListenOptions> _useHttpsWithDefaults;
    private ILogger`1<HttpsConnectionMiddleware> _httpsLogger;
    private bool Microsoft.AspNetCore.Server.Kestrel.Core.IHttpsConfigurationService.IsInitialized { get; }
    public HttpsConfigurationService(IInitializer initializer);
    private sealed virtual override bool Microsoft.AspNetCore.Server.Kestrel.Core.IHttpsConfigurationService.get_IsInitialized();
    public sealed virtual void Initialize(IHostEnvironment hostEnvironment, ILogger`1<KestrelServer> serverLogger, ILogger`1<HttpsConnectionMiddleware> httpsLogger);
    public sealed virtual void ApplyHttpsConfiguration(HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint, KestrelServerOptions serverOptions, CertificateConfig defaultCertificateConfig, ConfigurationReader configurationReader);
    public sealed virtual ListenOptions UseHttpsWithSni(ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint);
    public sealed virtual Nullable`1<CertificateAndConfig> LoadDefaultCertificate(ConfigurationReader configurationReader);
    public sealed virtual void PopulateMultiplexedTransportFeatures(FeatureCollection features, ListenOptions listenOptions);
    public sealed virtual ListenOptions UseHttpsWithDefaults(ListenOptions listenOptions);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsureInitialized(string uninitializedError);
    internal static void PopulateMultiplexedTransportFeaturesWorker(FeatureCollection features, ListenOptions listenOptions, ILogger`1<HttpsConnectionMiddleware> logger);
    internal static ListenOptions UseHttpsWithDefaultsWorker(ListenOptions listenOptions);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.IHttpsConfigurationService {
    public bool IsInitialized { get; }
    public abstract virtual bool get_IsInitialized();
    public abstract virtual void Initialize(IHostEnvironment hostEnvironment, ILogger`1<KestrelServer> serverLogger, ILogger`1<HttpsConnectionMiddleware> httpsLogger);
    public abstract virtual void ApplyHttpsConfiguration(HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint, KestrelServerOptions serverOptions, CertificateConfig defaultCertificateConfig, ConfigurationReader configurationReader);
    public abstract virtual ListenOptions UseHttpsWithSni(ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint);
    public abstract virtual Nullable`1<CertificateAndConfig> LoadDefaultCertificate(ConfigurationReader configurationReader);
    public abstract virtual void PopulateMultiplexedTransportFeatures(FeatureCollection features, ListenOptions listenOptions);
    public abstract virtual ListenOptions UseHttpsWithDefaults(ListenOptions listenOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBindContext : object {
    [CompilerGeneratedAttribute]
private ServerAddressesFeature <ServerAddressesFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<ListenOptions, CancellationToken, Task> <CreateBinding>k__BackingField;
    public ServerAddressesFeature ServerAddressesFeature { get; }
    public ICollection`1<string> Addresses { get; }
    public KestrelServerOptions ServerOptions { get; }
    public ILogger Logger { get; }
    public Func`3<ListenOptions, CancellationToken, Task> CreateBinding { get; }
    public AddressBindContext(ServerAddressesFeature serverAddressesFeature, KestrelServerOptions serverOptions, ILogger logger, Func`3<ListenOptions, CancellationToken, Task> createBinding);
    [CompilerGeneratedAttribute]
public ServerAddressesFeature get_ServerAddressesFeature();
    public ICollection`1<string> get_Addresses();
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_ServerOptions();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Func`3<ListenOptions, CancellationToken, Task> get_CreateBinding();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder : object {
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder/<BindAsync>d__0")]
public static Task BindAsync(ListenOptions[] listenOptions, AddressBindContext context, Func`2<ListenOptions, ListenOptions> useHttps, CancellationToken cancellationToken);
    private static IStrategy CreateStrategy(ListenOptions[] listenOptions, String[] addresses, bool preferAddresses, Func`2<ListenOptions, ListenOptions> useHttps);
    internal static bool TryCreateIPEndPoint(BindingAddress address, IPEndPoint& endpoint);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.AddressBinder/<BindEndpointAsync>d__3")]
internal static Task BindEndpointAsync(ListenOptions endpoint, AddressBindContext context, CancellationToken cancellationToken);
    internal static ListenOptions ParseAddress(string address, Boolean& https);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.BaseHttpConnectionContext : object {
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private AltSvcHeader <AltSvcHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseConnectionContext <ConnectionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceContext <ServiceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <ConnectionFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <LocalEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeoutControl <TimeoutControl>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionContext <InitialExecutionContext>k__BackingField;
    public string ConnectionId { get; public set; }
    public HttpProtocols Protocols { get; }
    [NullableAttribute("2")]
public AltSvcHeader AltSvcHeader { get; }
    public BaseConnectionContext ConnectionContext { get; }
    public ServiceContext ServiceContext { get; }
    public IFeatureCollection ConnectionFeatures { get; }
    public MemoryPool`1<byte> MemoryPool { get; }
    [NullableAttribute("2")]
public IPEndPoint LocalEndPoint { get; }
    [NullableAttribute("2")]
public IPEndPoint RemoteEndPoint { get; }
    public ITimeoutControl TimeoutControl { get; public set; }
    [NullableAttribute("2")]
public ExecutionContext InitialExecutionContext { get; public set; }
    public BaseHttpConnectionContext(string connectionId, HttpProtocols protocols, AltSvcHeader altSvcHeader, BaseConnectionContext connectionContext, ServiceContext serviceContext, IFeatureCollection connectionFeatures, MemoryPool`1<byte> memoryPool, IPEndPoint localEndPoint, IPEndPoint remoteEndPoint);
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public HttpProtocols get_Protocols();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AltSvcHeader get_AltSvcHeader();
    [CompilerGeneratedAttribute]
public BaseConnectionContext get_ConnectionContext();
    [CompilerGeneratedAttribute]
public ServiceContext get_ServiceContext();
    [CompilerGeneratedAttribute]
public IFeatureCollection get_ConnectionFeatures();
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_MemoryPool();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPEndPoint get_LocalEndPoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPEndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public ITimeoutControl get_TimeoutControl();
    [CompilerGeneratedAttribute]
public void set_TimeoutControl(ITimeoutControl value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExecutionContext get_InitialExecutionContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_InitialExecutionContext(ExecutionContext value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.CertificateConfig : object {
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileHasChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowInvalid>k__BackingField;
    public IConfigurationSection ConfigSection { get; }
    [MemberNotNullWhenAttribute("True", "Path")]
public bool IsFileCert { get; }
    public string Path { get; public set; }
    public string KeyPath { get; public set; }
    public string Password { get; public set; }
    public bool FileHasChanged { get; internal set; }
    [MemberNotNullWhenAttribute("True", "Subject")]
public bool IsStoreCert { get; }
    public string Subject { get; public set; }
    public string Store { get; public set; }
    public string Location { get; public set; }
    public Nullable`1<bool> AllowInvalid { get; public set; }
    [NullableContextAttribute("1")]
public CertificateConfig(IConfigurationSection configSection);
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
    [MemberNotNullWhenAttribute("True", "Path")]
public bool get_IsFileCert();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_KeyPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyPath(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_FileHasChanged();
    [CompilerGeneratedAttribute]
internal void set_FileHasChanged(bool value);
    [MemberNotNullWhenAttribute("True", "Subject")]
public bool get_IsStoreCert();
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Store();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Store(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Location(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowInvalid();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowInvalid(Nullable`1<bool> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CertificateConfig lhs, CertificateConfig rhs);
    public static bool op_Inequality(CertificateConfig lhs, CertificateConfig rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.CertificatePathWatcher : object {
    private Func`2<string, IFileProvider> _fileProviderFactory;
    private string _contentRootDir;
    private ILogger`1<CertificatePathWatcher> _logger;
    private object _metadataLock;
    private Dictionary`2<string, DirectoryWatchMetadata> _metadataForDirectory;
    private Dictionary`2<string, FileWatchMetadata> _metadataForFile;
    private ConfigurationReloadToken _reloadToken;
    private bool _disposed;
    public CertificatePathWatcher(IHostEnvironment hostEnvironment, ILogger`1<CertificatePathWatcher> logger);
    internal CertificatePathWatcher(string contentRootPath, ILogger`1<CertificatePathWatcher> logger, Func`2<string, IFileProvider> fileProviderFactory);
    public IChangeToken GetChangeToken();
    public void UpdateWatches(List`1<CertificateConfig> certificateConfigsToRemove, List`1<CertificateConfig> certificateConfigsToAdd);
    internal void AddWatchUnsynchronized(CertificateConfig certificateConfig);
    private void OnChange(string path);
    internal void RemoveWatchUnsynchronized(CertificateConfig certificateConfig);
    internal int TestGetDirectoryWatchCountUnsynchronized();
    internal int TestGetFileWatchCountUnsynchronized(string dir);
    internal int TestGetObserverCountUnsynchronized(string path);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.CertificatePathWatcherLoggerExtensions : object {
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __DirectoryDoesNotExistCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UnknownFileCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UnknownObserverCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __CreatedDirectoryWatcherCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __CreatedFileWatcherCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __RemovedDirectoryWatcherCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __RemovedFileWatcherCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __LastModifiedTimeErrorCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UntrackedFileEventCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __ReusedObserverCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __AddedObserverCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __RemovedObserverCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, int, Exception> __ObserverCountCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, int, Exception> __FileCountCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __EventWithoutFileCallback;
    private static CertificatePathWatcherLoggerExtensions();
    [ExtensionAttribute]
[LoggerMessageAttribute("1", "3", "Directory '{Directory}' does not exist so changes to the certificate '{Path}' will not be tracked.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DirectoryDoesNotExist(ILogger`1<CertificatePathWatcher> logger, string directory, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("2", "3", "Attempted to remove watch from unwatched path '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UnknownFile(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("3", "3", "Attempted to remove unknown observer from path '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UnknownObserver(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("4", "1", "Created directory watcher for '{Directory}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void CreatedDirectoryWatcher(ILogger`1<CertificatePathWatcher> logger, string directory);
    [ExtensionAttribute]
[LoggerMessageAttribute("5", "1", "Created file watcher for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void CreatedFileWatcher(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("6", "1", "Removed directory watcher for '{Directory}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RemovedDirectoryWatcher(ILogger`1<CertificatePathWatcher> logger, string directory);
    [ExtensionAttribute]
[LoggerMessageAttribute("7", "1", "Removed file watcher for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RemovedFileWatcher(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("8", "1", "Error retrieving last modified time for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void LastModifiedTimeError(ILogger`1<CertificatePathWatcher> logger, string path, Exception e);
    [ExtensionAttribute]
[LoggerMessageAttribute("9", "1", "Ignored event for presently untracked file '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UntrackedFileEvent(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("10", "0", "Reused existing observer on file watcher for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ReusedObserver(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("11", "0", "Added observer to file watcher for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void AddedObserver(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("12", "0", "Removed observer from file watcher for '{Path}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RemovedObserver(ILogger`1<CertificatePathWatcher> logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("13", "0", "File '{Path}' now has {Count} observers.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ObserverCount(ILogger`1<CertificatePathWatcher> logger, string path, int count);
    [ExtensionAttribute]
[LoggerMessageAttribute("14", "0", "Directory '{Directory}' now has watchers on {Count} files.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FileCount(ILogger`1<CertificatePathWatcher> logger, string directory, int count);
    [ExtensionAttribute]
[LoggerMessageAttribute("15", "0", "Flagged {Count} observers of '{Path}' as changed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FlaggedObservers(ILogger`1<CertificatePathWatcher> logger, string path, int count);
    [ExtensionAttribute]
[LoggerMessageAttribute("16", "0", "Ignored event since '{Path}' was unavailable.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EventWithoutFile(ILogger`1<CertificatePathWatcher> logger, string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Certificates.CertificateConfigLoader : object {
    [CompilerGeneratedAttribute]
private IHostEnvironment <HostEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger`1<KestrelServer> <Logger>k__BackingField;
    public IHostEnvironment HostEnvironment { get; }
    public ILogger`1<KestrelServer> Logger { get; }
    public bool IsTestMock { get; }
    public CertificateConfigLoader(IHostEnvironment hostEnvironment, ILogger`1<KestrelServer> logger);
    [CompilerGeneratedAttribute]
public IHostEnvironment get_HostEnvironment();
    [CompilerGeneratedAttribute]
public ILogger`1<KestrelServer> get_Logger();
    public sealed virtual bool get_IsTestMock();
    public sealed virtual ValueTuple`2<X509Certificate2, X509Certificate2Collection> LoadCertificate(CertificateConfig certInfo, string endpointName);
    private static X509Certificate2 PersistKey(X509Certificate2 fullCertificate);
    private static X509Certificate2 LoadCertificateKey(X509Certificate2 certificate, string keyPath, string password);
    private static InvalidOperationException CreateErrorGettingPrivateKeyException(string keyPath, Exception ex);
    private static X509Certificate2 GetCertificate(string certificatePath);
    private static void ImportKeyFromFile(AsymmetricAlgorithm asymmetricAlgorithm, string keyText, string password);
    private static X509Certificate2 LoadFromStoreCert(CertificateConfig certInfo);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Certificates.ICertificateConfigLoader {
    public bool IsTestMock { get; }
    public abstract virtual bool get_IsTestMock();
    public abstract virtual ValueTuple`2<X509Certificate2, X509Certificate2Collection> LoadCertificate(CertificateConfig certInfo, string endpointName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConfigSectionClone : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigSectionClone> <Children>k__BackingField;
    [NullableAttribute("2")]
public string Value { get; }
    public Dictionary`2<string, ConfigSectionClone> Children { get; }
    public ConfigSectionClone(IConfigurationSection configSection);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigSectionClone> get_Children();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConfigSectionClone lhs, ConfigSectionClone rhs);
    public static bool op_Inequality(ConfigSectionClone lhs, ConfigSectionClone rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConfigurationReader : object {
    private static string ProtocolsKey;
    private static string CertificatesKey;
    private static string CertificateKey;
    private static string SslProtocolsKey;
    private static string EndpointDefaultsKey;
    private static string EndpointsKey;
    private static string UrlKey;
    private static string ClientCertificateModeKey;
    private static string SniKey;
    private IConfiguration _configuration;
    private IDictionary`2<string, CertificateConfig> _certificates;
    private EndpointDefaults _endpointDefaults;
    private IEnumerable`1<EndpointConfig> _endpoints;
    public IDictionary`2<string, CertificateConfig> Certificates { get; }
    public EndpointDefaults EndpointDefaults { get; }
    public IEnumerable`1<EndpointConfig> Endpoints { get; }
    public ConfigurationReader(IConfiguration configuration);
    public IDictionary`2<string, CertificateConfig> get_Certificates();
    public EndpointDefaults get_EndpointDefaults();
    public IEnumerable`1<EndpointConfig> get_Endpoints();
    private IDictionary`2<string, CertificateConfig> ReadCertificates();
    private EndpointDefaults ReadEndpointDefaults();
    private IEnumerable`1<EndpointConfig> ReadEndpoints();
    private static Dictionary`2<string, SniConfig> ReadSni(IConfigurationSection sniConfig, string endpointName);
    private static Nullable`1<ClientCertificateMode> ParseClientCertificateMode(string clientCertificateMode);
    private static Nullable`1<HttpProtocols> ParseProtocols(string protocols);
    private static Nullable`1<SslProtocols> ParseSslProcotols(IConfigurationSection sslProtocols);
    internal static void ThrowIfContainsHttpsOnlyConfiguration(EndpointConfig endpoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionDispatcher`1 : object {
    private ServiceContext _serviceContext;
    private Func`2<T, Task> _connectionDelegate;
    private TransportConnectionManager _transportConnectionManager;
    private TaskCompletionSource _acceptLoopTcs;
    private KestrelTrace Log { get; }
    private KestrelMetrics Metrics { get; }
    public ConnectionDispatcher`1(ServiceContext serviceContext, Func`2<T, Task> connectionDelegate, TransportConnectionManager transportConnectionManager);
    private KestrelTrace get_Log();
    private KestrelMetrics get_Metrics();
    public Task StartAcceptingConnections(IConnectionListener`1<T> listener);
    private void StartAcceptingConnectionsCore(IConnectionListener`1<T> listener);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLimitMiddleware`1 : object {
    private Func`2<T, Task> _next;
    private ResourceCounter _concurrentConnectionCounter;
    private KestrelTrace _trace;
    private KestrelMetrics _metrics;
    public ConnectionLimitMiddleware`1(Func`2<T, Task> next, long connectionLimit, KestrelTrace trace, KestrelMetrics metrics);
    internal ConnectionLimitMiddleware`1(Func`2<T, Task> next, ResourceCounter concurrentConnectionCounter, KestrelTrace trace, KestrelMetrics metrics);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLimitMiddleware`1/<OnConnectionAsync>d__6")]
public Task OnConnectionAsync(T connection);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLogScope : object {
    private string _connectionId;
    private string _cachedToString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, object> Item { get; }
    public int Count { get; }
    [NullableContextAttribute("1")]
public ConnectionLogScope(string connectionId);
    public sealed virtual KeyValuePair`2<string, object> get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ConnectionLogScope/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream : Stream {
    private PipeReader _input;
    private PipeWriter _output;
    private bool _throwOnCancelled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cancelCalled;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DuplexPipeStream(PipeReader input, PipeWriter output, bool throwOnCancelled);
    public void CancelPendingRead();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStream/<ReadAsyncInternal>d__27")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStreamAdapter`1 : DuplexPipeStream {
    private bool _disposed;
    private object _disposeLock;
    [CompilerGeneratedAttribute]
private TStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public TStream Stream { get; }
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public DuplexPipeStreamAdapter`1(IDuplexPipe duplexPipe, Func`2<Stream, TStream> createStream);
    public DuplexPipeStreamAdapter`1(IDuplexPipe duplexPipe, StreamPipeReaderOptions readerOptions, StreamPipeWriterOptions writerOptions, Func`2<Stream, TStream> createStream);
    [CompilerGeneratedAttribute]
public TStream get_Stream();
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.DuplexPipeStreamAdapter`1/<DisposeAsync>d__13")]
public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.EndpointConfig : object {
    private ConfigSectionClone _configSectionClone;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SniConfig> <Sni>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SslProtocols> <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateConfig <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ClientCertificateMode> <ClientCertificateMode>k__BackingField;
    public string Name { get; }
    public string Url { get; }
    public Dictionary`2<string, SniConfig> Sni { get; }
    public IConfigurationSection ConfigSection { get; }
    public Nullable`1<HttpProtocols> Protocols { get; public set; }
    public Nullable`1<SslProtocols> SslProtocols { get; public set; }
    [NullableAttribute("2")]
public CertificateConfig Certificate { get; public set; }
    public Nullable`1<ClientCertificateMode> ClientCertificateMode { get; public set; }
    public EndpointConfig(string name, string url, Dictionary`2<string, SniConfig> sni, IConfigurationSection configSection);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SniConfig> get_Sni();
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
    [CompilerGeneratedAttribute]
public Nullable`1<HttpProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<HttpProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SslProtocols> get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(Nullable`1<SslProtocols> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CertificateConfig get_Certificate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Certificate(CertificateConfig value);
    [CompilerGeneratedAttribute]
public Nullable`1<ClientCertificateMode> get_ClientCertificateMode();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMode(Nullable`1<ClientCertificateMode> value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(EndpointConfig lhs, EndpointConfig rhs);
    [NullableContextAttribute("2")]
public static bool op_Inequality(EndpointConfig lhs, EndpointConfig rhs);
    private static bool CompareSniDictionaries(Dictionary`2<string, SniConfig> lhs, Dictionary`2<string, SniConfig> rhs);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.EndpointDefaults : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SslProtocols> <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ClientCertificateMode> <ClientCertificateMode>k__BackingField;
    public Nullable`1<HttpProtocols> Protocols { get; public set; }
    public Nullable`1<SslProtocols> SslProtocols { get; public set; }
    public Nullable`1<ClientCertificateMode> ClientCertificateMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<HttpProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SslProtocols> get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(Nullable`1<SslProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ClientCertificateMode> get_ClientCertificateMode();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMode(Nullable`1<ClientCertificateMode> value);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ChunkWriter : object {
    public static int BeginChunkBytes(int dataCount, Span`1<byte> span);
    internal static int GetPrefixBytesForChunk(int length, Boolean& sliceOneByte);
    [ExtensionAttribute]
internal static int WriteBeginChunkBytes(BufferWriter`1& start, int dataCount);
    [ExtensionAttribute]
internal static void WriteEndChunkBytes(BufferWriter`1& start);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ConnectionOptions : Enum {
    public int value__;
    public static ConnectionOptions None;
    public static ConnectionOptions Close;
    public static ConnectionOptions KeepAlive;
    public static ConnectionOptions Upgrade;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.DateHeaderValueManager : object {
    public TimeProvider _timeProvider;
    private DateHeaderValues _dateValues;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> DatePreambleBytes { get; }
    public DateHeaderValueManager(TimeProvider timeProvider);
    private static ReadOnlySpan`1<byte> get_DatePreambleBytes();
    public DateHeaderValues GetDateHeaderValues();
    public sealed virtual void OnHeartbeat();
    private void SetDateValues();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody : Http1MessageBody {
    private static byte ByteCR;
    private static int MaxChunkPrefixBytes;
    private long _inputLength;
    private Mode _mode;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canceled;
    private Task _pumpTask;
    private Pipe _requestBodyPipe;
    private ReadResult _readResult;
    [NullableContextAttribute("1")]
public Http1ChunkedEncodingMessageBody(Http1Connection context, bool keepAlive);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryReadInternal(ReadResult& readResult);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<ReadAsyncInternal>d__11")]
public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    public virtual void CancelPendingRead();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<PumpAsync>d__13")]
private Task PumpAsync();
    protected virtual ValueTask OnStopAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ChunkedEncodingMessageBody/<StopAsyncAwaited>d__15")]
private ValueTask StopAsyncAwaited(Task pumpTask);
    [NullableContextAttribute("1")]
protected virtual Task OnReadStartedAsync();
    private bool Read(ReadOnlySequence`1<byte> readableBuffer, PipeWriter writableBuffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedPrefix(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseExtension(ReadOnlySequence`1<byte> buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ReadChunkedData(ReadOnlySequence`1& buffer, PipeWriter writableBuffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedSuffix(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private void ParseChunkedTrailer(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private static int CalculateChunkSize(int extraHexDigit, int currentParsedSize);
    private static Pipe CreateRequestBodyPipe(Http1Connection context);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1Connection : HttpProtocol {
    private static byte ByteCR;
    private static byte ByteLF;
    private static byte ByteAsterisk;
    private static byte ByteForwardSlash;
    private static string Asterisk;
    private static string ForwardSlash;
    private HttpConnectionContext _context;
    private IHttpParser`1<Http1ParsingHandler> _parser;
    private Http1OutputProducer _http1Output;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _requestTimedOut;
    private UInt32 _requestCount;
    private HttpRequestTarget _requestTargetForm;
    private Uri _absoluteRequestTarget;
    private string _parsedPath;
    private string _parsedQueryString;
    private string _parsedRawTarget;
    private Uri _parsedAbsoluteRequestTarget;
    private long _remainingRequestHeadersBytesAllowed;
    private bool _http2PrefaceDetected;
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinResponseDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <MemoryPool>k__BackingField;
    private IDictionary`2<object, object> _persistentState;
    internal static ReadOnlySpan`1<byte> Http2GoAwayHttp11RequiredBytes { get; }
    [NullableAttribute("1")]
public PipeReader Input { get; }
    public bool RequestTimedOut { get; }
    [NullableAttribute("2")]
public MinDataRate MinResponseDataRate { get; public set; }
    [NullableAttribute("1")]
public MemoryPool`1<byte> MemoryPool { get; }
    [NullableAttribute("2")]
private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.MinDataRate { get; private set; }
    [NullableAttribute("2")]
private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.MinDataRate { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.State { get; }
    [NullableContextAttribute("1")]
public Http1Connection(HttpConnectionContext context);
    internal static ReadOnlySpan`1<byte> get_Http2GoAwayHttp11RequiredBytes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public PipeReader get_Input();
    public bool get_RequestTimedOut();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MinDataRate get_MinResponseDataRate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_MinResponseDataRate(MinDataRate value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_MemoryPool();
    protected virtual void OnRequestProcessingEnded();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor.OnInputOrOutputCompleted();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.OnInputOrOutputCompleted();
    [NullableContextAttribute("1")]
public sealed virtual void Abort(ConnectionAbortedException abortReason);
    protected virtual void ApplicationAbort();
    public sealed virtual void StopProcessingNextRequest();
    public void SendTimeoutResponse();
    public sealed virtual void HandleRequestHeadersTimeout();
    public sealed virtual void HandleReadDataRateTimeout();
    public bool ParseRequest(SequenceReader`1& reader);
    public bool TakeStartLine(SequenceReader`1& reader);
    public bool TakeMessageHeaders(SequenceReader`1& reader, bool trailers);
    public void OnStartLine(HttpVersionAndMethod versionAndMethod, TargetOffsetPathLength targetPath, Span`1<byte> startLine);
    private void OnOriginFormTarget(TargetOffsetPathLength targetPath, Span`1<byte> target);
    private void ParseTarget(TargetOffsetPathLength targetPath, Span`1<byte> target);
    private int ParseQuery(TargetOffsetPathLength targetPath, Span`1<byte> target);
    private void OnAuthorityFormTarget(HttpMethod method, Span`1<byte> target);
    private void OnAsteriskFormTarget(HttpMethod method);
    private void OnAbsoluteFormTarget(TargetOffsetPathLength targetPath, Span`1<byte> target);
    internal void EnsureHostHeaderExists();
    private void ValidateNonOriginHostHeader(string hostText);
    protected virtual void OnReset();
    protected virtual void OnRequestProcessingEnding();
    [NullableContextAttribute("1")]
protected virtual string CreateRequestId();
    [NullableContextAttribute("1")]
protected virtual MessageBody CreateMessageBody();
    protected virtual void BeginRequestProcessing();
    protected virtual bool BeginRead(ValueTask`1& awaitable);
    protected virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private void DetectHttp2Preface(ReadOnlySequence`1<byte> requestData, BadHttpRequestException ex);
    [NullableContextAttribute("1")]
protected virtual Task TryProduceInvalidRequestResponse();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor.Tick(long timestamp);
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.get_State();
    [CompilerGeneratedAttribute]
private bool <TakeStartLine>g__TrimAndTakeStartLine|44_0(SequenceReader`1& reader);
    [CompilerGeneratedAttribute]
private bool <TakeMessageHeaders>g__TrimAndTakeMessageHeaders|45_0(SequenceReader`1& reader, bool trailers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1Connection`1 : Http1Connection {
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    [NullableAttribute("2")]
private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http1Connection`1(HttpConnectionContext context);
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody : Http1MessageBody {
    private ReadResult _readResult;
    private long _contentLength;
    private long _unexaminedInputLength;
    private bool _readCompleted;
    private bool _isReading;
    private int _userCanceled;
    private bool _finalAdvanceCalled;
    private bool _cannotResetInputPipe;
    [NullableContextAttribute("1")]
public Http1ContentLengthMessageBody(Http1Connection context, long contentLength, bool keepAlive);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ContentLengthMessageBody/<ReadAsyncInternal>d__9")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    public virtual bool TryReadInternal(ReadResult& readResult);
    private long CreateReadResultFromConnectionReadResult();
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    protected virtual void OnReadStarting();
    public virtual void CancelPendingRead();
    [StackTraceHiddenAttribute]
private void VerifyIsNotReading();
    [CompilerGeneratedAttribute]
private void <ReadAsyncInternal>g__ResetReadingState|9_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1MessageBody : MessageBody {
    protected Http1Connection _context;
    private bool _readerCompleted;
    protected Http1MessageBody(Http1Connection context, bool keepAlive);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& readResult);
    public abstract virtual bool TryReadInternal(ReadResult& readResult);
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    protected virtual Task OnConsumeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1MessageBody/<OnConsumeAsyncAwaited>d__9")]
protected Task OnConsumeAsyncAwaited();
    public static MessageBody For(HttpVersion httpVersion, HttpRequestHeaders headers, Http1Connection context);
    [StackTraceHiddenAttribute]
protected void ThrowIfReaderCompleted();
    [StackTraceHiddenAttribute]
protected void ThrowUnexpectedEndOfRequestContent();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1OutputProducer : object {
    private static int MaxBeginChunkLength;
    private static int EndChunkLength;
    private string _connectionId;
    private BaseConnectionContext _connectionContext;
    private MemoryPool`1<byte> _memoryPool;
    private KestrelTrace _log;
    private IHttpMinResponseDataRateFeature _minResponseDataRateFeature;
    private IHttpOutputAborter _outputAborter;
    private TimingPipeFlusher _flusher;
    private object _contextLock;
    private bool _pipeWriterCompleted;
    private bool _aborted;
    private long _unflushedBytes;
    private int _currentMemoryPrefixBytes;
    private ConcurrentPipeWriter _pipeWriter;
    private IMemoryOwner`1<byte> _fakeMemoryOwner;
    private Byte[] _fakeMemory;
    private bool _autoChunk;
    private bool _writeStreamSuffixCalled;
    private int _advancedBytesForChunk;
    private Memory`1<byte> _currentChunkMemory;
    private bool _currentChunkMemoryUpdated;
    private List`1<CompletedBuffer> _completedSegments;
    private Memory`1<byte> _currentSegment;
    private IMemoryOwner`1<byte> _currentSegmentOwner;
    private int _position;
    private bool _startCalled;
    private static ReadOnlySpan`1<byte> ContinueBytes { get; }
    private static ReadOnlySpan`1<byte> HttpVersion11Bytes { get; }
    private static ReadOnlySpan`1<byte> EndHeadersBytes { get; }
    private static ReadOnlySpan`1<byte> EndChunkedResponseBytes { get; }
    [NullableContextAttribute("1")]
public Http1OutputProducer(PipeWriter pipeWriter, string connectionId, BaseConnectionContext connectionContext, MemoryPool`1<byte> memoryPool, KestrelTrace log, ITimeoutControl timeoutControl, IHttpMinResponseDataRateFeature minResponseDataRateFeature, IHttpOutputAborter outputAborter);
    private static ReadOnlySpan`1<byte> get_ContinueBytes();
    private static ReadOnlySpan`1<byte> get_HttpVersion11Bytes();
    private static ReadOnlySpan`1<byte> get_EndHeadersBytes();
    private static ReadOnlySpan`1<byte> get_EndChunkedResponseBytes();
    public sealed virtual Task WriteDataAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public sealed virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public sealed virtual void Advance(int bytes);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual ValueTask`1<FlushResult> WriteChunkAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private void CommitChunkInternal(BufferWriter`1& writer, ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("1")]
public sealed virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appComplete);
    private void WriteResponseHeadersInternal(BufferWriter`1& writer, int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk);
    private void WriteDataWrittenBeforeHeaders(BufferWriter`1& writer);
    public sealed virtual void Dispose();
    private void DisposeCurrentSegment();
    private void CompletePipe();
    [NullableContextAttribute("1")]
public void Abort(ConnectionAbortedException error);
    public sealed virtual void Stop();
    public sealed virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    public sealed virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    public sealed virtual void Reset();
    private ValueTask`1<FlushResult> WriteAsync(ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> WriteAsyncInternal(BufferWriter`1& writer, ReadOnlySpan`1<byte> buffer, CancellationToken cancellationToken);
    private Memory`1<byte> GetChunkedMemory(int sizeHint);
    private void UpdateCurrentChunkMemory(int sizeHint);
    private void WriteCurrentChunkMemoryToPipeWriter(BufferWriter`1& writer);
    internal Memory`1<byte> GetFakeMemory(int minSize);
    private Memory`1<byte> LeasedMemory(int sizeHint);
    private void EnsureCapacity(int sizeHint);
    private void AddSegment(int sizeHint);
    [StackTraceHiddenAttribute]
private void ThrowIfSuffixSent();
    [StackTraceHiddenAttribute]
private static void ThrowSuffixSent();
    [CompilerGeneratedAttribute]
internal static ValueTask`1<FlushResult> <FlushAsync>g__FlushAsyncChunked|39_0(Http1OutputProducer producer, CancellationToken token);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1ParsingHandler : ValueType {
    [NullableAttribute("1")]
public Http1Connection Connection;
    public bool Trailers;
    [NullableContextAttribute("1")]
public Http1ParsingHandler(Http1Connection connection);
    [NullableContextAttribute("1")]
public Http1ParsingHandler(Http1Connection connection, bool trailers);
    public sealed virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public sealed virtual void OnHeadersComplete(bool endStream);
    public sealed virtual void OnStartLine(HttpVersionAndMethod versionAndMethod, TargetOffsetPathLength targetPath, Span`1<byte> startLine);
    public sealed virtual void OnStaticIndexedHeader(int index);
    public sealed virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1UpgradeMessageBody : Http1MessageBody {
    private int _userCanceled;
    public bool IsEmpty { get; }
    [NullableContextAttribute("1")]
public Http1UpgradeMessageBody(Http1Connection context, bool keepAlive);
    public virtual bool get_IsEmpty();
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    [NullableContextAttribute("1")]
public virtual Task ConsumeAsync();
    public virtual ValueTask StopAsync();
    public virtual bool TryReadInternal(ReadResult& readResult);
    public virtual ValueTask`1<ReadResult> ReadAsyncInternal(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.Http1UpgradeMessageBody/<ReadAsyncInternalAwaited>d__12")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<ReadResult> ReadAsyncInternalAwaited(ValueTask`1<ReadResult> readTask, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpHeaders/HttpHeadersDebugView")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpHeaders : object {
    protected long _bits;
    protected Nullable`1<long> _contentLength;
    protected bool _isReadOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Dictionary`2<string, StringValues> MaybeUnknown;
    private static string KeepAlive;
    private static StringValues ConnectionValueKeepAlive;
    private static StringValues ConnectionValueClose;
    private static StringValues ConnectionValueUpgrade;
    private static HashSet`1<string> _internedHeaderNames;
    protected Dictionary`2<string, StringValues> Unknown { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public StringValues HeaderConnection { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Item { get; private set; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.IsReadOnly { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Keys { get; }
    private ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Values { get; }
    private static HttpHeaders();
    protected Dictionary`2<string, StringValues> get_Unknown();
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual void set_ContentLength(Nullable`1<long> value);
    public abstract virtual StringValues get_HeaderConnection();
    public abstract virtual void set_HeaderConnection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Item(string key);
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Item(string key, StringValues value);
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    protected static void ThrowHeadersReadOnlyException();
    protected static void ThrowArgumentException();
    private static void ThrowKeyNotFoundException();
    protected static void ThrowDuplicateKeyException();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Keys();
    private sealed virtual override ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Values();
    public void SetReadOnly();
    public void Reset();
    protected static string GetInternedHeaderName(string name);
    protected static StringValues AppendValue(StringValues existing, string append);
    protected bool TryGetUnknown(string key, StringValues& value);
    protected bool RemoveUnknown(string key);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Add(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Add(string key, StringValues value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Contains(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, StringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Remove(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.TryGetValue(string key, StringValues& value);
    internal string DebuggerToString();
    public static void ValidateHeaderValueCharacters(string headerName, StringValues headerValues, Func`2<string, Encoding> encodingSelector);
    public static void ValidateHeaderValueCharacters(string headerCharacters, bool requireAscii);
    public static void ValidateHeaderNameCharacters(string headerCharacters);
    public static ConnectionOptions ParseConnection(HttpHeaders headers);
    private static ulong ReadLowerCaseUInt64(ReadOnlySpan`1<byte> value, ulong lowerCaseMask);
    private static UInt32 ReadLowerCaseUInt32(ReadOnlySpan`1<byte> value);
    private static ushort ReadLowerCaseUInt16(ReadOnlySpan`1<byte> value);
    private static char ToLowerCase(char value);
    public static TransferCoding GetFinalTransferCoding(StringValues transferEncoding);
    private static bool TryReadLowerCaseUInt64(ReadOnlySpan`1<byte> byteValue, UInt64& value);
    private static bool TryReadLowerCaseUInt32(ReadOnlySpan`1<byte> byteValue, UInt32& value);
    private static void ThrowInvalidContentLengthException(long value);
    private static void ThrowInvalidHeaderCharacter(char ch);
    private static void ThrowInvalidEmptyHeaderName();
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpHeadersCompression : object {
    internal static ValueTuple`2<int, bool> MatchKnownHeaderQPack(KnownHeaderType knownHeader, string value);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod : Enum {
    public byte value__;
    public static HttpMethod Get;
    public static HttpMethod Put;
    public static HttpMethod Delete;
    public static HttpMethod Post;
    public static HttpMethod Head;
    public static HttpMethod Trace;
    public static HttpMethod Patch;
    public static HttpMethod Connect;
    public static HttpMethod Options;
    public static HttpMethod Custom;
    public static HttpMethod None;
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpParser`1 : object {
    private bool _showErrorDetails;
    private bool _disableHttp1LineFeedTerminators;
    private static byte ByteCR;
    private static byte ByteLF;
    private static byte ByteColon;
    private static byte ByteSpace;
    private static byte ByteTab;
    private static byte ByteQuestionMark;
    private static byte BytePercentage;
    private static int MinTlsRequestSize;
    public HttpParser`1(bool showErrorDetails);
    internal HttpParser`1(bool showErrorDetails, bool disableHttp1LineFeedTerminators);
    public sealed virtual bool ParseRequestLine(TRequestHandler handler, SequenceReader`1& reader);
    private void ParseRequestLine(TRequestHandler handler, ReadOnlySpan`1<byte> requestLine);
    public sealed virtual bool ParseHeaders(TRequestHandler handler, SequenceReader`1& reader);
    private static Byte[] AppendEndOfLine(ReadOnlySpan`1<byte> span, bool lineFeedOnly);
    private int ParseMultiSpanHeader(TRequestHandler handler, SequenceReader`1& reader);
    private static bool TryTakeSingleHeader(TRequestHandler handler, ReadOnlySpan`1<byte> headerLine);
    private int GetUnknownMethodLength(ReadOnlySpan`1<byte> span);
    private static bool IsTlsHandshake(ReadOnlySpan`1<byte> requestLine);
    [StackTraceHiddenAttribute]
private void RejectRequestLine(ReadOnlySpan`1<byte> requestLine);
    [StackTraceHiddenAttribute]
private void RejectRequestHeader(ReadOnlySpan`1<byte> headerLine);
    [StackTraceHiddenAttribute]
private void RejectUnknownVersion(ReadOnlySpan`1<byte> version);
    private BadHttpRequestException GetInvalidRequestException(RequestRejectionReason reason, ReadOnlySpan`1<byte> headerLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol : object {
    private static Byte[] _bytesConnectionClose;
    private static Byte[] _bytesConnectionKeepAlive;
    private static Byte[] _bytesTransferEncodingChunked;
    private static Byte[] _bytesServer;
    internal static string SchemeHttp;
    internal static string SchemeHttps;
    [NullableAttribute("2")]
protected BodyControl _bodyControl;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onStarting;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onCompleted;
    private object _abortLock;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _connectionAborted;
    private bool _preventRequestAbortedCancellation;
    private CancellationTokenSource _abortedCts;
    private Nullable`1<CancellationToken> _manuallySetRequestAbortToken;
    protected RequestProcessingStatus _requestProcessingStatus;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _keepAlive;
    private bool _canWriteResponseBody;
    private bool _hasAdvanced;
    private bool _isLeasedMemoryInvalid;
    private bool _autoChunk;
    [NullableAttribute("2")]
protected Exception _applicationException;
    private BadHttpRequestException _requestRejectedException;
    protected HttpVersion _httpVersion;
    private string _httpProtocol;
    private string _requestId;
    private int _requestHeadersParsed;
    protected int _eagerRequestHeadersParsedLimit;
    private long _responseBytesWritten;
    private HttpConnectionContext _context;
    private RouteValueDictionary _routeValues;
    private Endpoint _endpoint;
    [NullableAttribute("2")]
protected string _methodText;
    private string _scheme;
    private Stream _requestStreamInternal;
    private Stream _responseStreamInternal;
    [CompilerGeneratedAttribute]
private IHttpResponseControl <HttpResponseControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpOutputProducer <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionIdFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStartedConsumingRequestBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxRequestBodySize>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinRequestBodyDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpgradableRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpgraded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedConnectRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedConnectAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <RemoteIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemotePort>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <LocalIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <RequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <RequestTrailers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestTrailersAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <RequestBody>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeReader <RequestBodyPipeReader>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseTrailers <ResponseTrailers>k__BackingField;
    private int _statusCode;
    private string _reasonPhrase;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <ResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <ResponseBodyPipeWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestHeaders <HttpRequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseHeaders <HttpResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWebTransportRequest>k__BackingField;
    [NullableAttribute("2")]
protected internal IHttpRequestFeature _currentIHttpRequestFeature;
    [NullableAttribute("2")]
protected internal IHttpResponseFeature _currentIHttpResponseFeature;
    [NullableAttribute("2")]
protected internal IHttpResponseBodyFeature _currentIHttpResponseBodyFeature;
    [NullableAttribute("2")]
protected internal IRouteValuesFeature _currentIRouteValuesFeature;
    [NullableAttribute("2")]
protected internal IEndpointFeature _currentIEndpointFeature;
    [NullableAttribute("2")]
protected internal IHttpRequestIdentifierFeature _currentIHttpRequestIdentifierFeature;
    [NullableAttribute("2")]
protected internal IHttpRequestTrailersFeature _currentIHttpRequestTrailersFeature;
    [NullableAttribute("2")]
protected internal IHttpExtendedConnectFeature _currentIHttpExtendedConnectFeature;
    [NullableAttribute("2")]
protected internal IHttpUpgradeFeature _currentIHttpUpgradeFeature;
    [NullableAttribute("2")]
protected internal IRequestBodyPipeFeature _currentIRequestBodyPipeFeature;
    [NullableAttribute("2")]
protected internal IHttpConnectionFeature _currentIHttpConnectionFeature;
    [NullableAttribute("2")]
protected internal IHttpRequestLifetimeFeature _currentIHttpRequestLifetimeFeature;
    [NullableAttribute("2")]
protected internal IHttpBodyControlFeature _currentIHttpBodyControlFeature;
    [NullableAttribute("2")]
protected internal IHttpMaxRequestBodySizeFeature _currentIHttpMaxRequestBodySizeFeature;
    [NullableAttribute("2")]
protected internal IHttpRequestBodyDetectionFeature _currentIHttpRequestBodyDetectionFeature;
    [NullableAttribute("2")]
protected internal IHttpWebTransportFeature _currentIHttpWebTransportFeature;
    [NullableAttribute("2")]
protected internal IBadRequestExceptionFeature _currentIBadRequestExceptionFeature;
    [NullableAttribute("2")]
protected internal IServiceProvidersFeature _currentIServiceProvidersFeature;
    [NullableAttribute("2")]
protected internal IHttpActivityFeature _currentIHttpActivityFeature;
    [NullableAttribute("2")]
protected internal IHttpMetricsTagsFeature _currentIHttpMetricsTagsFeature;
    [NullableAttribute("2")]
protected internal IItemsFeature _currentIItemsFeature;
    [NullableAttribute("2")]
protected internal IQueryFeature _currentIQueryFeature;
    [NullableAttribute("2")]
protected internal IFormFeature _currentIFormFeature;
    [NullableAttribute("2")]
protected internal IHttpAuthenticationFeature _currentIHttpAuthenticationFeature;
    [NullableAttribute("2")]
protected internal ISessionFeature _currentISessionFeature;
    [NullableAttribute("2")]
protected internal IResponseCookiesFeature _currentIResponseCookiesFeature;
    [NullableAttribute("2")]
protected internal IHttpResponseTrailersFeature _currentIHttpResponseTrailersFeature;
    [NullableAttribute("2")]
protected internal ITlsConnectionFeature _currentITlsConnectionFeature;
    [NullableAttribute("2")]
protected internal IHttpWebSocketFeature _currentIHttpWebSocketFeature;
    [NullableAttribute("2")]
protected internal IHttpRequestTimeoutFeature _currentIHttpRequestTimeoutFeature;
    [NullableAttribute("2")]
protected internal IHttp2StreamIdFeature _currentIHttp2StreamIdFeature;
    [NullableAttribute("2")]
protected internal IHttpMinRequestBodyDataRateFeature _currentIHttpMinRequestBodyDataRateFeature;
    [NullableAttribute("2")]
protected internal IHttpMinResponseDataRateFeature _currentIHttpMinResponseDataRateFeature;
    [NullableAttribute("2")]
protected internal IHttpResetFeature _currentIHttpResetFeature;
    [NullableAttribute("2")]
protected internal IPersistentStateFeature _currentIPersistentStateFeature;
    private int _featureRevision;
    private List`1<KeyValuePair`2<Type, object>> MaybeExtra;
    public IHttpResponseControl HttpResponseControl { get; public set; }
    public ServiceContext ServiceContext { get; }
    [NullableAttribute("2")]
private IPEndPoint LocalEndPoint { get; }
    [NullableAttribute("2")]
private IPEndPoint RemoteEndPoint { get; }
    public ITimeoutControl TimeoutControl { get; }
    public IFeatureCollection ConnectionFeatures { get; }
    public IHttpOutputProducer Output { get; protected set; }
    protected KestrelTrace Log { get; }
    private DateHeaderValueManager DateHeaderValueManager { get; }
    protected KestrelServerOptions ServerOptions { get; protected set; }
    protected string ConnectionId { get; }
    public string ConnectionIdFeature { get; public set; }
    public bool HasStartedConsumingRequestBody { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    [NullableAttribute("2")]
public MinDataRate MinRequestBodyDataRate { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    protected int RequestHeadersParsed { get; }
    public string TraceIdentifier { get; public set; }
    public bool IsUpgradableRequest { get; private set; }
    public bool IsUpgraded { get; public set; }
    public bool IsExtendedConnectRequest { get; public set; }
    public bool IsExtendedConnectAccepted { get; public set; }
    [NullableAttribute("2")]
public IPAddress RemoteIpAddress { get; public set; }
    public int RemotePort { get; public set; }
    [NullableAttribute("2")]
public IPAddress LocalIpAddress { get; public set; }
    public int LocalPort { get; public set; }
    [NullableAttribute("2")]
public string ConnectProtocol { get; public set; }
    [NullableAttribute("2")]
public string Scheme { get; public set; }
    public HttpMethod Method { get; public set; }
    public string MethodText { get; }
    [NullableAttribute("2")]
public string PathBase { get; public set; }
    [NullableAttribute("2")]
public string Path { get; public set; }
    [NullableAttribute("2")]
public string QueryString { get; public set; }
    [NullableAttribute("2")]
public string RawTarget { get; public set; }
    public string HttpVersion { get; public set; }
    public IHeaderDictionary RequestHeaders { get; public set; }
    public IHeaderDictionary RequestTrailers { get; }
    public bool RequestTrailersAvailable { get; public set; }
    public Stream RequestBody { get; public set; }
    public PipeReader RequestBodyPipeReader { get; public set; }
    [NullableAttribute("2")]
public HttpResponseTrailers ResponseTrailers { get; public set; }
    public int StatusCode { get; public set; }
    [NullableAttribute("2")]
public string ReasonPhrase { get; public set; }
    public IHeaderDictionary ResponseHeaders { get; public set; }
    public Stream ResponseBody { get; public set; }
    public PipeWriter ResponseBodyPipeWriter { get; public set; }
    public CancellationToken RequestAborted { get; public set; }
    public bool HasResponseStarted { get; }
    public bool HasFlushedHeaders { get; }
    public bool HasResponseCompleted { get; }
    protected HttpRequestHeaders HttpRequestHeaders { get; protected set; }
    protected HttpResponseHeaders HttpResponseHeaders { get; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Protocol { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Scheme { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Method { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.PathBase { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Path { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.QueryString { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.RawTarget { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Headers { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Body { get; private set; }
    private PipeReader Microsoft.AspNetCore.Http.Features.IRequestBodyPipeFeature.Reader { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature.CanHaveBody { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.Available { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.Trailers { get; }
    private int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.StatusCode { get; private set; }
    [NullableAttribute("2")]
private string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.ReasonPhrase { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Headers { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.RequestAborted { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.HasStarted { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.IsUpgradableRequest { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.IsExtendedConnect { get; }
    [NullableAttribute("2")]
private string Microsoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.Protocol { get; }
    [NullableAttribute("2")]
private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress { get; private set; }
    [NullableAttribute("2")]
private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.TraceIdentifier { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.MaxRequestBodySize { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Body { get; private set; }
    private PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Writer { get; }
    [NullableAttribute("2")]
private Endpoint Microsoft.AspNetCore.Http.Features.IEndpointFeature.Endpoint { get; private set; }
    private RouteValueDictionary Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.RouteValues { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.Stream { get; }
    [NullableAttribute("2")]
private Exception Microsoft.AspNetCore.Http.Features.IBadRequestExceptionFeature.Error { get; }
    public bool IsWebTransportRequest { get; public set; }
    private bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.IsReadOnly { get; }
    private int Microsoft.AspNetCore.Http.Features.IFeatureCollection.Revision { get; }
    [NullableAttribute("2")]
private object Microsoft.AspNetCore.Http.Features.IFeatureCollection.Item { get; private set; }
    private static HttpProtocol();
    public void Initialize(HttpConnectionContext context);
    [CompilerGeneratedAttribute]
public IHttpResponseControl get_HttpResponseControl();
    [CompilerGeneratedAttribute]
public void set_HttpResponseControl(IHttpResponseControl value);
    public ServiceContext get_ServiceContext();
    private IPEndPoint get_LocalEndPoint();
    private IPEndPoint get_RemoteEndPoint();
    public ITimeoutControl get_TimeoutControl();
    public IFeatureCollection get_ConnectionFeatures();
    [CompilerGeneratedAttribute]
public IHttpOutputProducer get_Output();
    [CompilerGeneratedAttribute]
protected void set_Output(IHttpOutputProducer value);
    protected KestrelTrace get_Log();
    private DateHeaderValueManager get_DateHeaderValueManager();
    [CompilerGeneratedAttribute]
protected KestrelServerOptions get_ServerOptions();
    [CompilerGeneratedAttribute]
protected void set_ServerOptions(KestrelServerOptions value);
    protected string get_ConnectionId();
    [CompilerGeneratedAttribute]
public string get_ConnectionIdFeature();
    [CompilerGeneratedAttribute]
public void set_ConnectionIdFeature(string value);
    [CompilerGeneratedAttribute]
public bool get_HasStartedConsumingRequestBody();
    [CompilerGeneratedAttribute]
public void set_HasStartedConsumingRequestBody(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxRequestBodySize();
    [CompilerGeneratedAttribute]
public void set_MaxRequestBodySize(Nullable`1<long> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MinDataRate get_MinRequestBodyDataRate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_MinRequestBodyDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    protected int get_RequestHeadersParsed();
    public void set_TraceIdentifier(string value);
    public sealed virtual string get_TraceIdentifier();
    [CompilerGeneratedAttribute]
public bool get_IsUpgradableRequest();
    [CompilerGeneratedAttribute]
private void set_IsUpgradableRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUpgraded();
    [CompilerGeneratedAttribute]
public void set_IsUpgraded(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedConnectRequest();
    [CompilerGeneratedAttribute]
public void set_IsExtendedConnectRequest(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedConnectAccepted();
    [CompilerGeneratedAttribute]
public void set_IsExtendedConnectAccepted(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPAddress get_RemoteIpAddress();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RemoteIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_RemotePort();
    [CompilerGeneratedAttribute]
public void set_RemotePort(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPAddress get_LocalIpAddress();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_LocalIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_LocalPort();
    [CompilerGeneratedAttribute]
public void set_LocalPort(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ConnectProtocol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ConnectProtocol(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Scheme();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Scheme(string value);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(HttpMethod value);
    public string get_MethodText();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PathBase();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PathBase(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Path(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_QueryString();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_QueryString(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_RawTarget();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RawTarget(string value);
    public string get_HttpVersion();
    public void set_HttpVersion(string value);
    private void HttpVersionSetSlow(string value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_RequestHeaders();
    [CompilerGeneratedAttribute]
public void set_RequestHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_RequestTrailers();
    [CompilerGeneratedAttribute]
public bool get_RequestTrailersAvailable();
    [CompilerGeneratedAttribute]
public void set_RequestTrailersAvailable(bool value);
    [CompilerGeneratedAttribute]
public Stream get_RequestBody();
    [CompilerGeneratedAttribute]
public void set_RequestBody(Stream value);
    [CompilerGeneratedAttribute]
public PipeReader get_RequestBodyPipeReader();
    [CompilerGeneratedAttribute]
public void set_RequestBodyPipeReader(PipeReader value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public HttpResponseTrailers get_ResponseTrailers();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ResponseTrailers(HttpResponseTrailers value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    [NullableContextAttribute("2")]
public string get_ReasonPhrase();
    [NullableContextAttribute("2")]
public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_ResponseHeaders();
    [CompilerGeneratedAttribute]
public void set_ResponseHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
public Stream get_ResponseBody();
    [CompilerGeneratedAttribute]
public void set_ResponseBody(Stream value);
    [CompilerGeneratedAttribute]
public PipeWriter get_ResponseBodyPipeWriter();
    [CompilerGeneratedAttribute]
public void set_ResponseBodyPipeWriter(PipeWriter value);
    public CancellationToken get_RequestAborted();
    public void set_RequestAborted(CancellationToken value);
    public bool get_HasResponseStarted();
    public bool get_HasFlushedHeaders();
    public bool get_HasResponseCompleted();
    [CompilerGeneratedAttribute]
protected HttpRequestHeaders get_HttpRequestHeaders();
    [CompilerGeneratedAttribute]
protected void set_HttpRequestHeaders(HttpRequestHeaders value);
    [CompilerGeneratedAttribute]
protected HttpResponseHeaders get_HttpResponseHeaders();
    public void InitializeBodyControl(MessageBody messageBody);
    internal void ResetState();
    public void Reset();
    protected abstract virtual void OnReset();
    protected abstract virtual void ApplicationAbort();
    protected virtual void OnRequestProcessingEnding();
    protected virtual void OnRequestProcessingEnded();
    protected virtual void BeginRequestProcessing();
    protected virtual void OnErrorAfterResponseStarted();
    [NullableContextAttribute("0")]
protected virtual bool BeginRead(ValueTask`1& awaitable);
    protected abstract virtual string CreateRequestId();
    protected abstract virtual MessageBody CreateMessageBody();
    protected abstract virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private void CancelRequestAbortedTokenCallback();
    protected void CancelRequestAbortedToken();
    protected void PoisonBody(Exception abortReason);
    private void PreventRequestAbortedCancellation();
    [NullableContextAttribute("0")]
public virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value, bool checkForNewlineChars);
    [NullableContextAttribute("0")]
public virtual void OnHeader(int index, bool indexOnly, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("0")]
public void OnTrailer(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void IncrementRequestHeadersCount();
    public void OnHeadersComplete();
    public void OnTrailersComplete();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<ProcessRequestsAsync>d__237`1")]
public sealed virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<ProcessRequests>d__238`1")]
private Task ProcessRequests(IHttpApplication`1<TContext> application);
    public void OnStarting(Func`2<object, Task> callback, object state);
    public void OnCompleted(Func`2<object, Task> callback, object state);
    protected Task FireOnStarting();
    protected Task FireOnCompleted();
    private void VerifyAndUpdateWrite(int count);
    [StackTraceHiddenAttribute]
private void ThrowTooManyBytesWritten(int count);
    private InvalidOperationException GetTooManyBytesWrittenException(int count);
    private void CheckLastWrite();
    [NullableContextAttribute("2")]
protected bool VerifyResponseContentLength(Exception& ex);
    [NullableContextAttribute("0")]
public sealed virtual ValueTask`1<FlushResult> ProduceContinueAsync();
    public Task InitializeResponseAsync(int firstWriteByteCount);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<InitializeResponseAwaited>d__250")]
public Task InitializeResponseAwaited(Task startingTask, int firstWriteByteCount);
    private HttpResponseHeaders InitializeResponseFirstWrite(int firstWriteByteCount);
    private void ProduceStart(bool appCompleted);
    private void VerifyInitializeState(int firstWriteByteCount);
    protected virtual Task TryProduceInvalidRequestResponse();
    protected Task ProduceEnd();
    private Task WriteSuffix();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<WriteSuffixAwaited>d__257")]
private Task WriteSuffixAwaited(ValueTask`1<FlushResult> writeTask);
    private HttpResponseHeaders CreateResponseHeaders(bool appCompleted);
    private bool CanIncludeResponseContentLengthHeader();
    private bool CanWriteResponseBody();
    private bool CanAutoSetContentLengthZeroResponseHeader();
    private static void ThrowResponseAlreadyStartedException(string value);
    private void RejectInvalidHeaderForNonBodyResponse(bool appCompleted, string headerName);
    private void RejectNonzeroContentLengthOn205Response(bool appCompleted);
    private void RejectInvalidResponse(bool appCompleted, string message);
    private void SetErrorResponseException(BadHttpRequestException ex);
    private void SetErrorResponseHeaders(int statusCode);
    public void HandleNonBodyResponseWrite();
    [StackTraceHiddenAttribute]
private void ThrowWritingToResponseBodyNotSupported();
    [StackTraceHiddenAttribute]
private void ThrowResponseAbortedException();
    [NullableContextAttribute("0")]
[StackTraceHiddenAttribute]
[DoesNotReturnAttribute]
public void ThrowRequestTargetRejected(Span`1<byte> target);
    private BadHttpRequestException GetInvalidRequestTargetException(ReadOnlySpan`1<byte> target);
    public void DisableHttp1KeepAlive();
    public void SetBadRequestState(BadHttpRequestException ex);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
private static void WriteDiagnosticEvent(DiagnosticSource diagnosticSource, string name, HttpProtocol value);
    [NullableContextAttribute("2")]
public void ReportApplicationError(Exception ex);
    public sealed virtual void Advance(int bytes);
    [NullableContextAttribute("0")]
public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    [NullableContextAttribute("0")]
public sealed virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual Task CompleteAsync(Exception exception);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<CompleteAsyncAwaited>d__283")]
private Task CompleteAsyncAwaited(Task onStartingTask);
    [StackTraceHiddenAttribute]
private static void ThrowException(Exception exception);
    [NullableContextAttribute("0")]
public sealed virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> FirstWriteAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FirstWriteAsyncAwaited>d__287")]
private ValueTask`1<FlushResult> FirstWriteAsyncAwaited(Task initializeTask, ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private ValueTask`1<FlushResult> FirstWriteAsyncInternal(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FlushAsyncAwaited>d__290")]
private ValueTask`1<FlushResult> FlushAsyncAwaited(Task initializeTask, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Task WriteAsync(ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<WriteAsyncAwaited>d__292")]
public ValueTask`1<FlushResult> WriteAsyncAwaited(Task initializeTask, ReadOnlyMemory`1<byte> data, CancellationToken cancellationToken);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Protocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Protocol(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Scheme();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Scheme(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Method();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Method(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_PathBase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_PathBase(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Path();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Path(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_QueryString();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_QueryString(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_RawTarget();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_RawTarget(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Body(Stream value);
    private sealed virtual override PipeReader Microsoft.AspNetCore.Http.Features.IRequestBodyPipeFeature.get_Reader();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature.get_CanHaveBody();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.get_Available();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestTrailersFeature.get_Trailers();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_StatusCode();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_StatusCode(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_ReasonPhrase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_ReasonPhrase(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.get_RequestAborted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.set_RequestAborted(CancellationToken value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_HasStarted();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.get_IsUpgradableRequest();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.get_IsExtendedConnect();
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.get_Protocol();
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemoteIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemoteIpAddress(IPAddress value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalIpAddress(IPAddress value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemotePort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemotePort(int value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalPort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalPort(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_ConnectionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_ConnectionId(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.get_TraceIdentifier();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.set_TraceIdentifier(string value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.get_AllowSynchronousIO();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.set_AllowSynchronousIO(bool value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.get_MaxRequestBodySize();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpMaxRequestBodySizeFeature.set_MaxRequestBodySize(Nullable`1<long> value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Body(Stream value);
    private sealed virtual override PipeWriter Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Writer();
    private sealed virtual override Endpoint Microsoft.AspNetCore.Http.Features.IEndpointFeature.get_Endpoint();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IEndpointFeature.set_Endpoint(Endpoint value);
    private sealed virtual override RouteValueDictionary Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.get_RouteValues();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IRouteValuesFeature.set_RouteValues(RouteValueDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.get_Stream();
    private sealed virtual override Exception Microsoft.AspNetCore.Http.Features.IBadRequestExceptionFeature.get_Error();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnStarting(Func`2<object, Task> callback, object state);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnCompleted(Func`2<object, Task> callback, object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<Microsoft-AspNetCore-Http-Features-IHttpUpgradeFeature-UpgradeAsync>d__391")]
private sealed virtual override Task`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.UpgradeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<Microsoft-AspNetCore-Http-Features-IHttpExtendedConnectFeature-AcceptAsync>d__392")]
private sealed virtual override ValueTask`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpExtendedConnectFeature.AcceptAsync();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.Abort();
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.StartAsync(CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.DisableBuffering();
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.SendFileAsync(string path, long offset, Nullable`1<long> count, CancellationToken cancellation);
    private sealed virtual override Task Microsoft.AspNetCore.Http.Features.IHttpResponseBodyFeature.CompleteAsync();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWebTransportRequest();
    [CompilerGeneratedAttribute]
public void set_IsWebTransportRequest(bool value);
    public virtual ValueTask`1<IWebTransportSession> AcceptAsync(CancellationToken token);
    private void FastReset();
    internal void ResetFeatureCollection();
    private object ExtraFeatureGet(Type key);
    private void ExtraFeatureSet(Type key, object value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_IsReadOnly();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Revision();
    private sealed virtual override object Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Item(Type key);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.set_Item(Type key, object value);
    private sealed virtual override TFeature Microsoft.AspNetCore.Http.Features.IFeatureCollection.Get();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.Set(TFeature feature);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<FastEnumerable>d__453")]
private IEnumerable`1<KeyValuePair`2<Type, object>> FastEnumerable();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<<FireOnStarting>g__ProcessEvents|241_0>d")]
[CompilerGeneratedAttribute]
internal static Task <FireOnStarting>g__ProcessEvents|241_0(HttpProtocol protocol, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> events);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol/<<FireOnCompleted>g__ProcessEvents|242_0>d")]
[CompilerGeneratedAttribute]
internal static Task <FireOnCompleted>g__ProcessEvents|242_0(HttpProtocol protocol, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> events);
    [CompilerGeneratedAttribute]
internal static bool <CanIncludeResponseContentLengthHeader>g__Is1xxCode|259_0(int code);
    [CompilerGeneratedAttribute]
internal static bool <CanIncludeResponseContentLengthHeader>g__Is2xxCode|259_1(int code);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestHeaders : HttpHeaders {
    private HeaderReferences _headers;
    private EnumeratorCache _enumeratorCache;
    private long _previousBits;
    private long _pseudoBits;
    [CompilerGeneratedAttribute]
private bool <ReuseHeaderValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, Encoding> <EncodingSelector>k__BackingField;
    public bool HasConnection { get; }
    public bool HasCookie { get; }
    public bool HasTransferEncoding { get; }
    public int HostCount { get; }
    public StringValues HeaderConnection { get; public set; }
    public StringValues HeaderHost { get; public set; }
    public StringValues HeaderAuthority { get; public set; }
    public StringValues HeaderMethod { get; public set; }
    public StringValues HeaderPath { get; public set; }
    public StringValues HeaderProtocol { get; public set; }
    public StringValues HeaderScheme { get; public set; }
    public StringValues HeaderTransferEncoding { get; public set; }
    public StringValues HeaderContentLength { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Accept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Connection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Host { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UserAgent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptCharset { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestMethod { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Authorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Baggage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CacheControl { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentType { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Cookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CorrelationContext { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Date { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expect { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.From { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcAcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcTimeout { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfModifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfNoneMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfUnmodifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.KeepAlive { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.MaxForwards { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Origin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Pragma { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Range { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Referer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RequestId { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TE { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceParent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceState { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TransferEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Translate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Upgrade { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UpgradeInsecureRequests { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Via { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Warning { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptRanges { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowCredentials { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowMethods { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowOrigin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlExposeHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlMaxAge { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Age { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Allow { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AltSvc { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentDisposition { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLocation { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentMD5 { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicyReportOnly { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ETag { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expires { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcMessage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcStatus { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.LastModified { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Link { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Location { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyConnection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RetryAfter { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketAccept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketKey { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketProtocol { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketVersion { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketExtensions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Server { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SetCookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.StrictTransportSecurity { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Trailer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Vary { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WebSocketSubProtocols { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WWWAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XContentTypeOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XFrameOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XPoweredBy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XRequestedWith { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XUACompatible { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XXSSProtection { get; private set; }
    public bool ReuseHeaderValues { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> EncodingSelector { get; public set; }
    public HttpRequestHeaders(bool reuseHeaderValues, Func`2<string, Encoding> encodingSelector);
    public bool get_HasConnection();
    public bool get_HasCookie();
    public bool get_HasTransferEncoding();
    public int get_HostCount();
    public virtual StringValues get_HeaderConnection();
    public virtual void set_HeaderConnection(StringValues value);
    public StringValues get_HeaderHost();
    public void set_HeaderHost(StringValues value);
    public StringValues get_HeaderAuthority();
    public void set_HeaderAuthority(StringValues value);
    public StringValues get_HeaderMethod();
    public void set_HeaderMethod(StringValues value);
    public StringValues get_HeaderPath();
    public void set_HeaderPath(StringValues value);
    public StringValues get_HeaderProtocol();
    public void set_HeaderProtocol(StringValues value);
    public StringValues get_HeaderScheme();
    public void set_HeaderScheme(StringValues value);
    public StringValues get_HeaderTransferEncoding();
    public void set_HeaderTransferEncoding(StringValues value);
    public StringValues get_HeaderContentLength();
    public void set_HeaderContentLength(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Accept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Accept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Connection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Connection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Host();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Host(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UserAgent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UserAgent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptCharset();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptCharset(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestMethod();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestMethod(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Authorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Authorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Baggage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Baggage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CacheControl();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CacheControl(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentType();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentType(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Cookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Cookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CorrelationContext();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CorrelationContext(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Date();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Date(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expect();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expect(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_From();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_From(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcAcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcAcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcTimeout();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcTimeout(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfModifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfModifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfNoneMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfNoneMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfUnmodifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfUnmodifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_KeepAlive();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_KeepAlive(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_MaxForwards();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_MaxForwards(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Origin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Origin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Pragma();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Pragma(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Range();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Range(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Referer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Referer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RequestId();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RequestId(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TE();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TE(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceParent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceParent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceState();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceState(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TransferEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TransferEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Translate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Translate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Upgrade();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Upgrade(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UpgradeInsecureRequests();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UpgradeInsecureRequests(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Via();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Via(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Warning();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Warning(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptRanges();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptRanges(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowCredentials();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowCredentials(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowMethods();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowMethods(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowOrigin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowOrigin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlExposeHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlExposeHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlMaxAge();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlMaxAge(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Age();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Age(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Allow();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Allow(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AltSvc();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AltSvc(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentDisposition();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentDisposition(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLocation();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLocation(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentMD5();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentMD5(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicyReportOnly();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicyReportOnly(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ETag();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ETag(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expires();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expires(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcMessage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcMessage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcStatus();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcStatus(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_LastModified();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_LastModified(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Link();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Link(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Location();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Location(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyConnection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyConnection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RetryAfter();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RetryAfter(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketAccept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketAccept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketKey();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketKey(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketProtocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketProtocol(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketVersion();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketVersion(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketExtensions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketExtensions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Server();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Server(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SetCookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SetCookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_StrictTransportSecurity();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_StrictTransportSecurity(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Trailer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Trailer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Vary();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Vary(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WebSocketSubProtocols();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WebSocketSubProtocols(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WWWAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WWWAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XContentTypeOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XContentTypeOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XFrameOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XFrameOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XPoweredBy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XPoweredBy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XRequestedWith();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XRequestedWith(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XUACompatible();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XUACompatible(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XXSSProtection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XXSSProtection(StringValues value);
    protected virtual int GetCountFast();
    [NullableContextAttribute("1")]
protected virtual bool TryGetValueFast(string key, StringValues& value);
    [NullableContextAttribute("1")]
protected virtual void SetValueFast(string key, StringValues value);
    [NullableContextAttribute("1")]
protected virtual bool AddValueFast(string key, StringValues value);
    [NullableContextAttribute("1")]
protected virtual bool RemoveFast(string key);
    private void Clear(long bitsToClear);
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    internal void ClearPseudoRequestHeaders();
    internal static ushort ReadUnalignedLittleEndian_ushort(Byte& source);
    internal static UInt32 ReadUnalignedLittleEndian_uint(Byte& source);
    internal static ulong ReadUnalignedLittleEndian_ulong(Byte& source);
    public void Append(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value, bool checkForNewlineChars);
    public bool TryHPackAppend(int index, ReadOnlySpan`1<byte> value, bool checkForNewlineChars);
    public bool TryQPackAppend(int index, ReadOnlySpan`1<byte> value, bool checkForNewlineChars);
    [CompilerGeneratedAttribute]
public bool get_ReuseHeaderValues();
    [CompilerGeneratedAttribute]
public void set_ReuseHeaderValues(bool value);
    [CompilerGeneratedAttribute]
public Func`2<string, Encoding> get_EncodingSelector();
    [CompilerGeneratedAttribute]
public void set_EncodingSelector(Func`2<string, Encoding> value);
    public void OnHeadersComplete();
    public void MergeCookies();
    protected virtual void ClearFast();
    private static long ParseContentLength(string value);
    private void AppendContentLength(ReadOnlySpan`1<byte> value);
    [SkipLocalsInitAttribute]
private void AppendContentLengthCustomEncoding(ReadOnlySpan`1<byte> value, Encoding customEncoding);
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
    private void AppendUnknownHeaders(string name, string valueString);
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestPipeReader : PipeReader {
    private MessageBody _body;
    private HttpStreamState _state;
    private ExceptionDispatchInfo _error;
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    public virtual void Complete(Exception exception);
    public virtual ValueTask CompleteAsync(Exception exception);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
    [NullableContextAttribute("1")]
public void StartAcceptingReads(MessageBody body);
    public void StopAcceptingReads();
    public void Abort(Exception error);
    private void ValidateState(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowObjectDisposedException|14_0();
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowTaskCanceledException|14_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream : Stream {
    private HttpRequestPipeReader _pipeReader;
    private IHttpBodyControlFeature _bodyControl;
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int WriteTimeout { get; public set; }
    public HttpRequestStream(IHttpBodyControlFeature bodyControl, HttpRequestPipeReader pipeReader);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    private ValueTask`1<int> ReadAsyncWrapper(Memory`1<byte> destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestStream/<ReadAsyncInternal>d__30")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpRequestTarget : Enum {
    public int value__;
    public static HttpRequestTarget Unknown;
    public static HttpRequestTarget OriginForm;
    public static HttpRequestTarget AbsoluteForm;
    public static HttpRequestTarget AuthorityForm;
    public static HttpRequestTarget AsteriskForm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseHeaders : HttpHeaders {
    private HeaderReferences _headers;
    [CompilerGeneratedAttribute]
private Func`2<string, Encoding> <EncodingSelector>k__BackingField;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> HeaderBytes { get; }
    public bool HasConnection { get; }
    public bool HasDate { get; }
    public bool HasServer { get; }
    public bool HasAltSvc { get; }
    public bool HasTransferEncoding { get; }
    public StringValues HeaderConnection { get; public set; }
    public StringValues HeaderAllow { get; public set; }
    public StringValues HeaderAltSvc { get; public set; }
    public StringValues HeaderTransferEncoding { get; public set; }
    public StringValues HeaderContentLength { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Connection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentType { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Date { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Server { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptRanges { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowCredentials { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowMethods { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowOrigin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlExposeHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlMaxAge { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Age { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Allow { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AltSvc { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CacheControl { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLocation { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentMD5 { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ETag { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expires { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.KeepAlive { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.LastModified { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Location { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Pragma { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyConnection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RetryAfter { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SetCookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Trailer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TransferEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Upgrade { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Vary { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Via { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Warning { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WWWAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Accept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptCharset { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestMethod { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Authorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Baggage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentDisposition { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicyReportOnly { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CorrelationContext { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Cookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expect { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.From { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcAcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcMessage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcStatus { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcTimeout { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Host { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfModifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfNoneMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfUnmodifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Link { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.MaxForwards { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Origin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Range { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Referer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RequestId { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketAccept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketKey { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketProtocol { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketVersion { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketExtensions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.StrictTransportSecurity { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TE { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Translate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceParent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceState { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UpgradeInsecureRequests { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UserAgent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WebSocketSubProtocols { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XContentTypeOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XFrameOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XPoweredBy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XRequestedWith { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XUACompatible { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XXSSProtection { get; private set; }
    internal bool HasInvalidH2H3Headers { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> CrLf { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ColonSpace { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> EncodingSelector { get; public set; }
    public HttpResponseHeaders(Func`2<string, Encoding> encodingSelector);
    private static ReadOnlySpan`1<byte> get_HeaderBytes();
    public bool get_HasConnection();
    public bool get_HasDate();
    public bool get_HasServer();
    public bool get_HasAltSvc();
    public bool get_HasTransferEncoding();
    public virtual StringValues get_HeaderConnection();
    public virtual void set_HeaderConnection(StringValues value);
    public StringValues get_HeaderAllow();
    public void set_HeaderAllow(StringValues value);
    public StringValues get_HeaderAltSvc();
    public void set_HeaderAltSvc(StringValues value);
    public StringValues get_HeaderTransferEncoding();
    public void set_HeaderTransferEncoding(StringValues value);
    public StringValues get_HeaderContentLength();
    public void set_HeaderContentLength(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Connection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Connection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentType();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentType(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Date();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Date(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Server();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Server(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptRanges();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptRanges(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowCredentials();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowCredentials(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowMethods();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowMethods(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowOrigin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowOrigin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlExposeHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlExposeHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlMaxAge();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlMaxAge(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Age();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Age(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Allow();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Allow(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AltSvc();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AltSvc(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CacheControl();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CacheControl(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLocation();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLocation(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentMD5();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentMD5(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ETag();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ETag(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expires();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expires(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_KeepAlive();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_KeepAlive(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_LastModified();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_LastModified(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Location();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Location(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Pragma();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Pragma(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyConnection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyConnection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RetryAfter();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RetryAfter(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SetCookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SetCookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Trailer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Trailer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TransferEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TransferEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Upgrade();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Upgrade(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Vary();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Vary(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Via();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Via(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Warning();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Warning(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WWWAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WWWAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Accept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Accept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptCharset();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptCharset(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestMethod();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestMethod(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Authorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Authorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Baggage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Baggage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentDisposition();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentDisposition(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicyReportOnly();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicyReportOnly(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CorrelationContext();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CorrelationContext(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Cookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Cookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expect();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expect(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_From();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_From(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcAcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcAcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcMessage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcMessage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcStatus();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcStatus(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcTimeout();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcTimeout(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Host();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Host(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfModifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfModifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfNoneMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfNoneMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfUnmodifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfUnmodifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Link();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Link(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_MaxForwards();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_MaxForwards(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Origin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Origin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Range();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Range(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Referer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Referer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RequestId();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RequestId(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketAccept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketAccept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketKey();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketKey(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketProtocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketProtocol(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketVersion();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketVersion(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketExtensions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketExtensions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_StrictTransportSecurity();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_StrictTransportSecurity(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TE();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TE(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Translate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Translate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceParent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceParent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceState();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceState(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UpgradeInsecureRequests();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UpgradeInsecureRequests(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UserAgent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UserAgent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WebSocketSubProtocols();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WebSocketSubProtocols(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XContentTypeOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XContentTypeOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XFrameOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XFrameOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XPoweredBy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XPoweredBy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XRequestedWith();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XRequestedWith(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XUACompatible();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XUACompatible(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XXSSProtection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XXSSProtection(StringValues value);
    public void SetRawConnection(StringValues value, Byte[] raw);
    public void SetRawDate(StringValues value, Byte[] raw);
    public void SetRawServer(StringValues value, Byte[] raw);
    public void SetRawAltSvc(StringValues value, Byte[] raw);
    public void SetRawTransferEncoding(StringValues value, Byte[] raw);
    protected virtual int GetCountFast();
    protected virtual bool TryGetValueFast(string key, StringValues& value);
    protected virtual void SetValueFast(string key, StringValues value);
    protected virtual bool AddValueFast(string key, StringValues value);
    protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    internal bool get_HasInvalidH2H3Headers();
    internal void ClearInvalidH2H3Headers();
    internal void CopyToFast(BufferWriter`1& output);
    private static ReadOnlySpan`1<byte> get_CrLf();
    private static ReadOnlySpan`1<byte> get_ColonSpace();
    [CompilerGeneratedAttribute]
public Func`2<string, Encoding> get_EncodingSelector();
    [CompilerGeneratedAttribute]
public void set_EncodingSelector(Func`2<string, Encoding> value);
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    internal void CopyTo(BufferWriter`1& buffer);
    private static long ParseContentLength(string value);
    [DoesNotReturnAttribute]
private static void ThrowInvalidContentLengthException(string value);
    [DoesNotReturnAttribute]
private static void ThrowInvalidHeaderBits();
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
    [CompilerGeneratedAttribute]
internal static void <CopyTo>g__CopyExtraHeaders|324_0(BufferWriter`1& buffer, Dictionary`2<string, StringValues> headers);
    [CompilerGeneratedAttribute]
internal static void <CopyTo>g__CopyExtraHeadersCustomEncoding|324_1(BufferWriter`1& buffer, Dictionary`2<string, StringValues> headers, Func`2<string, Encoding> encodingSelector);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponsePipeWriter : PipeWriter {
    private IHttpResponseControl _pipeControl;
    private HttpStreamState _state;
    private Task _completeTask;
    [NullableContextAttribute("1")]
public HttpResponsePipeWriter(IHttpResponseControl pipeControl);
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public void StartAcceptingWrites();
    [NullableContextAttribute("1")]
public Task StopAcceptingWritesAsync();
    public void Abort();
    private void ValidateState(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ValidateState>g__ThrowObjectDisposedException|15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseStream : Stream {
    private HttpResponsePipeWriter _pipeWriter;
    private IHttpBodyControlFeature _bodyControl;
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public HttpResponseStream(IHttpBodyControlFeature bodyControl, HttpResponsePipeWriter pipeWriter);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpResponseTrailers : HttpHeaders {
    private HeaderReferences _headers;
    [CompilerGeneratedAttribute]
private Func`2<string, Encoding> <EncodingSelector>k__BackingField;
    private static ReadOnlySpan`1<byte> HeaderBytes { get; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ETag { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcMessage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcStatus { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Accept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptCharset { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AcceptRanges { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowCredentials { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowMethods { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlAllowOrigin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlExposeHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlMaxAge { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestHeaders { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AccessControlRequestMethod { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Age { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Allow { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.AltSvc { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Authorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Baggage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CacheControl { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Connection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentDisposition { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLanguage { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLocation { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentMD5 { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentSecurityPolicyReportOnly { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ContentType { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.CorrelationContext { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Cookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Date { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expires { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Expect { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.From { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcAcceptEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.GrpcTimeout { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Host { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.KeepAlive { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfModifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfNoneMatch { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfRange { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.IfUnmodifiedSince { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.LastModified { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Link { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Location { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.MaxForwards { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Origin { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Pragma { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyAuthorization { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.ProxyConnection { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Range { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Referer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RetryAfter { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.RequestId { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketAccept { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketKey { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketProtocol { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketVersion { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SecWebSocketExtensions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Server { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.SetCookie { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.StrictTransportSecurity { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TE { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Trailer { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TransferEncoding { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Translate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceParent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.TraceState { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Upgrade { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UpgradeInsecureRequests { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.UserAgent { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Vary { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Via { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Warning { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WebSocketSubProtocols { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.WWWAuthenticate { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XContentTypeOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XFrameOptions { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XPoweredBy { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XRequestedWith { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XUACompatible { get; private set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.XXSSProtection { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> EncodingSelector { get; public set; }
    public StringValues HeaderConnection { get; public set; }
    public HttpResponseTrailers(Func`2<string, Encoding> encodingSelector);
    private static ReadOnlySpan`1<byte> get_HeaderBytes();
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ETag();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ETag(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcMessage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcMessage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcStatus();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcStatus(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Accept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Accept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptCharset();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptCharset(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AcceptRanges();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AcceptRanges(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowCredentials();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowCredentials(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowMethods();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowMethods(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlAllowOrigin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlAllowOrigin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlExposeHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlExposeHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlMaxAge();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlMaxAge(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestHeaders();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestHeaders(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AccessControlRequestMethod();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AccessControlRequestMethod(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Age();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Age(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Allow();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Allow(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_AltSvc();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_AltSvc(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Authorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Authorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Baggage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Baggage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CacheControl();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CacheControl(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Connection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Connection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentDisposition();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentDisposition(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLanguage();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLanguage(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLocation();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLocation(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentMD5();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentMD5(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentSecurityPolicyReportOnly();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentSecurityPolicyReportOnly(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentType();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentType(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_CorrelationContext();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_CorrelationContext(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Cookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Cookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Date();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Date(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expires();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expires(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Expect();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Expect(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_From();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_From(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcAcceptEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcAcceptEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_GrpcTimeout();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_GrpcTimeout(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Host();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Host(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_KeepAlive();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_KeepAlive(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfModifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfModifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfNoneMatch();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfNoneMatch(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfRange();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfRange(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_IfUnmodifiedSince();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_IfUnmodifiedSince(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_LastModified();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_LastModified(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Link();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Link(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Location();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Location(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_MaxForwards();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_MaxForwards(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Origin();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Origin(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Pragma();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Pragma(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyAuthorization();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyAuthorization(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_ProxyConnection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ProxyConnection(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Range();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Range(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Referer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Referer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RetryAfter();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RetryAfter(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_RequestId();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_RequestId(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketAccept();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketAccept(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketKey();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketKey(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketProtocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketProtocol(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketVersion();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketVersion(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SecWebSocketExtensions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SecWebSocketExtensions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Server();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Server(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_SetCookie();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_SetCookie(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_StrictTransportSecurity();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_StrictTransportSecurity(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TE();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TE(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Trailer();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Trailer(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TransferEncoding();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TransferEncoding(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Translate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Translate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceParent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceParent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_TraceState();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_TraceState(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Upgrade();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Upgrade(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UpgradeInsecureRequests();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UpgradeInsecureRequests(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_UserAgent();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_UserAgent(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Vary();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Vary(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Via();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Via(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Warning();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Warning(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WebSocketSubProtocols();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WebSocketSubProtocols(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_WWWAuthenticate();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_WWWAuthenticate(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XContentTypeOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XContentTypeOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XFrameOptions();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XFrameOptions(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XPoweredBy();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XPoweredBy(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XRequestedWith();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XRequestedWith(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XUACompatible();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XUACompatible(StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_XXSSProtection();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_XXSSProtection(StringValues value);
    protected virtual int GetCountFast();
    [NullableContextAttribute("1")]
protected virtual bool TryGetValueFast(string key, StringValues& value);
    [NullableContextAttribute("1")]
protected virtual void SetValueFast(string key, StringValues value);
    [NullableContextAttribute("1")]
protected virtual bool AddValueFast(string key, StringValues value);
    [NullableContextAttribute("1")]
protected virtual bool RemoveFast(string key);
    protected virtual void ClearFast();
    protected virtual bool CopyToFast(KeyValuePair`2[] array, int arrayIndex);
    [CompilerGeneratedAttribute]
public Func`2<string, Encoding> get_EncodingSelector();
    [CompilerGeneratedAttribute]
public void set_EncodingSelector(Func`2<string, Encoding> value);
    public Enumerator GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumeratorFast();
    private void SetValueUnknown(string key, StringValues value);
    private bool AddValueUnknown(string key, StringValues value);
    public virtual StringValues get_HeaderConnection();
    public virtual void set_HeaderConnection(StringValues value);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme : Enum {
    public int value__;
    public static HttpScheme Unknown;
    public static HttpScheme Http;
    public static HttpScheme Https;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpStreamState : Enum {
    public int value__;
    public static HttpStreamState Open;
    public static HttpStreamState Closed;
    public static HttpStreamState Aborted;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpUpgradeStream : Stream {
    private Stream _requestStream;
    private Stream _responseStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public HttpUpgradeStream(Stream requestStream, Stream responseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion : Enum {
    public sbyte value__;
    public static HttpVersion Unknown;
    public static HttpVersion Http10;
    public static HttpVersion Http11;
    public static HttpVersion Http2;
    public static HttpVersion Http3;
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod : ValueType {
    private ulong _versionAndMethod;
    public HttpVersion Version { get; public set; }
    public HttpMethod Method { get; }
    public int MethodEnd { get; }
    public HttpVersionAndMethod(HttpMethod method, int methodEnd);
    public HttpVersion get_Version();
    public void set_Version(HttpVersion value);
    public HttpMethod get_Method();
    public int get_MethodEnd();
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpHeadersHandler {
    public abstract virtual void OnStaticIndexedHeader(int index);
    public abstract virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeadersComplete(bool endStream);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter {
    public abstract virtual void Abort(ConnectionAbortedException abortReason);
    public abstract virtual void OnInputOrOutputCompleted();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer {
    public abstract virtual ValueTask`1<FlushResult> WriteChunkAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    [NullableContextAttribute("1")]
public abstract virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appCompleted);
    public abstract virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual Task WriteDataAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public abstract virtual void Advance(int bytes);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual void CancelPendingFlush();
    public abstract virtual void Stop();
    public abstract virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public abstract virtual void Reset();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpParser`1 {
    public abstract virtual bool ParseRequestLine(TRequestHandler handler, SequenceReader`1& reader);
    public abstract virtual bool ParseHeaders(TRequestHandler handler, SequenceReader`1& reader);
}
public interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpRequestLineHandler {
    public abstract virtual void OnStartLine(HttpVersionAndMethod versionAndMethod, TargetOffsetPathLength targetPath, Span`1<byte> startLine);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpResponseControl {
    public abstract virtual ValueTask`1<FlushResult> ProduceContinueAsync();
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual void Advance(int bytes);
    public abstract virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public abstract virtual void CancelPendingFlush();
    [NullableContextAttribute("1")]
public abstract virtual Task CompleteAsync(Exception exception);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpResponsePipeWriterControl {
    public abstract virtual void ProduceContinue();
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    public abstract virtual void Advance(int bytes);
    public abstract virtual ValueTask`1<FlushResult> FlushPipeAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<FlushResult> WritePipeAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public abstract virtual void CancelPendingFlush();
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.KnownHeaderType : Enum {
    public int value__;
    public static KnownHeaderType Unknown;
    public static KnownHeaderType Accept;
    public static KnownHeaderType AcceptCharset;
    public static KnownHeaderType AcceptEncoding;
    public static KnownHeaderType AcceptLanguage;
    public static KnownHeaderType AcceptRanges;
    public static KnownHeaderType AccessControlAllowCredentials;
    public static KnownHeaderType AccessControlAllowHeaders;
    public static KnownHeaderType AccessControlAllowMethods;
    public static KnownHeaderType AccessControlAllowOrigin;
    public static KnownHeaderType AccessControlExposeHeaders;
    public static KnownHeaderType AccessControlMaxAge;
    public static KnownHeaderType AccessControlRequestHeaders;
    public static KnownHeaderType AccessControlRequestMethod;
    public static KnownHeaderType Age;
    public static KnownHeaderType Allow;
    public static KnownHeaderType AltSvc;
    public static KnownHeaderType AltUsed;
    public static KnownHeaderType Authority;
    public static KnownHeaderType Authorization;
    public static KnownHeaderType Baggage;
    public static KnownHeaderType CacheControl;
    public static KnownHeaderType Connection;
    public static KnownHeaderType ContentEncoding;
    public static KnownHeaderType ContentLanguage;
    public static KnownHeaderType ContentLength;
    public static KnownHeaderType ContentLocation;
    public static KnownHeaderType ContentMD5;
    public static KnownHeaderType ContentRange;
    public static KnownHeaderType ContentType;
    public static KnownHeaderType Cookie;
    public static KnownHeaderType CorrelationContext;
    public static KnownHeaderType Date;
    public static KnownHeaderType ETag;
    public static KnownHeaderType Expect;
    public static KnownHeaderType Expires;
    public static KnownHeaderType From;
    public static KnownHeaderType GrpcAcceptEncoding;
    public static KnownHeaderType GrpcEncoding;
    public static KnownHeaderType GrpcMessage;
    public static KnownHeaderType GrpcStatus;
    public static KnownHeaderType GrpcTimeout;
    public static KnownHeaderType Host;
    public static KnownHeaderType IfMatch;
    public static KnownHeaderType IfModifiedSince;
    public static KnownHeaderType IfNoneMatch;
    public static KnownHeaderType IfRange;
    public static KnownHeaderType IfUnmodifiedSince;
    public static KnownHeaderType KeepAlive;
    public static KnownHeaderType LastModified;
    public static KnownHeaderType Location;
    public static KnownHeaderType MaxForwards;
    public static KnownHeaderType Method;
    public static KnownHeaderType Origin;
    public static KnownHeaderType Path;
    public static KnownHeaderType Pragma;
    public static KnownHeaderType Protocol;
    public static KnownHeaderType ProxyAuthenticate;
    public static KnownHeaderType ProxyAuthorization;
    public static KnownHeaderType ProxyConnection;
    public static KnownHeaderType Range;
    public static KnownHeaderType Referer;
    public static KnownHeaderType RequestId;
    public static KnownHeaderType RetryAfter;
    public static KnownHeaderType Scheme;
    public static KnownHeaderType Server;
    public static KnownHeaderType SetCookie;
    public static KnownHeaderType TE;
    public static KnownHeaderType TraceParent;
    public static KnownHeaderType TraceState;
    public static KnownHeaderType Trailer;
    public static KnownHeaderType TransferEncoding;
    public static KnownHeaderType Translate;
    public static KnownHeaderType Upgrade;
    public static KnownHeaderType UpgradeInsecureRequests;
    public static KnownHeaderType UserAgent;
    public static KnownHeaderType Vary;
    public static KnownHeaderType Via;
    public static KnownHeaderType Warning;
    public static KnownHeaderType WWWAuthenticate;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.MessageBody : object {
    private static MessageBody _zeroContentLengthClose;
    private static MessageBody _zeroContentLengthKeepAlive;
    private HttpProtocol _context;
    private bool _send100Continue;
    private long _observedBytes;
    private bool _stopped;
    protected bool _timingEnabled;
    protected bool _backpressure;
    protected long _alreadyTimedBytes;
    protected long _examinedUnconsumedBytes;
    [CompilerGeneratedAttribute]
private bool <RequestKeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestUpgrade>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendedConnect>k__BackingField;
    public static MessageBody ZeroContentLengthClose { get; }
    public static MessageBody ZeroContentLengthKeepAlive { get; }
    public bool RequestKeepAlive { get; protected set; }
    public bool RequestUpgrade { get; protected set; }
    public bool ExtendedConnect { get; protected set; }
    public HttpProtocol Context { get; }
    public bool IsEmpty { get; }
    protected KestrelTrace Log { get; }
    protected MessageBody(HttpProtocol context);
    private static MessageBody();
    public static MessageBody get_ZeroContentLengthClose();
    public static MessageBody get_ZeroContentLengthKeepAlive();
    [CompilerGeneratedAttribute]
public bool get_RequestKeepAlive();
    [CompilerGeneratedAttribute]
protected void set_RequestKeepAlive(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequestUpgrade();
    [CompilerGeneratedAttribute]
protected void set_RequestUpgrade(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExtendedConnect();
    [CompilerGeneratedAttribute]
protected void set_ExtendedConnect(bool value);
    public HttpProtocol get_Context();
    public virtual bool get_IsEmpty();
    protected KestrelTrace get_Log();
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public abstract virtual bool TryRead(ReadResult& readResult);
    public void AdvanceTo(SequencePosition consumed);
    public abstract virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public abstract virtual void CancelPendingRead();
    [NullableContextAttribute("2")]
public abstract virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual Task ConsumeAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.MessageBody/<ConsumeAwaited>d__41")]
private Task ConsumeAwaited(Task startTask);
    public virtual ValueTask StopAsync();
    protected virtual Task OnConsumeAsync();
    protected virtual ValueTask OnStopAsync();
    public virtual void Reset();
    [NullableContextAttribute("0")]
protected ValueTask`1<FlushResult> TryProduceContinueAsync();
    protected Task TryStartAsync();
    protected void TryStop();
    protected virtual void OnReadStarting();
    protected virtual Task OnReadStartedAsync();
    protected void AddAndCheckObservedBytes(long observedBytes);
    [NullableContextAttribute("0")]
protected ValueTask`1<ReadResult> StartTimingReadAsync(ValueTask`1<ReadResult> readAwaitable, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.MessageBody/<StartTimingReadAwaited>d__53")]
protected ValueTask`1<ReadResult> StartTimingReadAwaited(ValueTask`1<FlushResult> continueTask, ValueTask`1<ReadResult> readAwaitable, CancellationToken cancellationToken);
    protected void CountBytesRead(long bytesInReadResult);
    protected void StopTimingRead(long bytesInReadResult);
    protected long TrackConsumedAndExaminedBytes(ReadResult readResult, SequencePosition consumed, SequencePosition examined);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.PathNormalizer : object {
    private static byte ByteSlash;
    private static byte ByteDot;
    [NullableContextAttribute("1")]
public static string DecodePath(Span`1<byte> path, bool pathEncoded, string rawTarget, int queryLength);
    public static int RemoveDotSegments(Span`1<byte> input);
    public static int RemoveDotSegments(Byte* start, Byte* end);
    public static bool ContainsDotSegments(Byte* start, Byte* end);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ProduceEndType : Enum {
    public int value__;
    public static ProduceEndType SocketShutdown;
    public static ProduceEndType SocketDisconnect;
    public static ProduceEndType ConnectionKeepAlive;
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ReasonPhrases : object {
    private static Byte[] _bytesStatus100;
    private static Byte[] _bytesStatus101;
    private static Byte[] _bytesStatus102;
    private static Byte[] _bytesStatus200;
    private static Byte[] _bytesStatus201;
    private static Byte[] _bytesStatus202;
    private static Byte[] _bytesStatus203;
    private static Byte[] _bytesStatus204;
    private static Byte[] _bytesStatus205;
    private static Byte[] _bytesStatus206;
    private static Byte[] _bytesStatus207;
    private static Byte[] _bytesStatus208;
    private static Byte[] _bytesStatus226;
    private static Byte[] _bytesStatus300;
    private static Byte[] _bytesStatus301;
    private static Byte[] _bytesStatus302;
    private static Byte[] _bytesStatus303;
    private static Byte[] _bytesStatus304;
    private static Byte[] _bytesStatus305;
    private static Byte[] _bytesStatus306;
    private static Byte[] _bytesStatus307;
    private static Byte[] _bytesStatus308;
    private static Byte[] _bytesStatus400;
    private static Byte[] _bytesStatus401;
    private static Byte[] _bytesStatus402;
    private static Byte[] _bytesStatus403;
    private static Byte[] _bytesStatus404;
    private static Byte[] _bytesStatus405;
    private static Byte[] _bytesStatus406;
    private static Byte[] _bytesStatus407;
    private static Byte[] _bytesStatus408;
    private static Byte[] _bytesStatus409;
    private static Byte[] _bytesStatus410;
    private static Byte[] _bytesStatus411;
    private static Byte[] _bytesStatus412;
    private static Byte[] _bytesStatus413;
    private static Byte[] _bytesStatus414;
    private static Byte[] _bytesStatus415;
    private static Byte[] _bytesStatus416;
    private static Byte[] _bytesStatus417;
    private static Byte[] _bytesStatus418;
    private static Byte[] _bytesStatus419;
    private static Byte[] _bytesStatus421;
    private static Byte[] _bytesStatus422;
    private static Byte[] _bytesStatus423;
    private static Byte[] _bytesStatus424;
    private static Byte[] _bytesStatus426;
    private static Byte[] _bytesStatus428;
    private static Byte[] _bytesStatus429;
    private static Byte[] _bytesStatus431;
    private static Byte[] _bytesStatus451;
    private static Byte[] _bytesStatus499;
    private static Byte[] _bytesStatus500;
    private static Byte[] _bytesStatus501;
    private static Byte[] _bytesStatus502;
    private static Byte[] _bytesStatus503;
    private static Byte[] _bytesStatus504;
    private static Byte[] _bytesStatus505;
    private static Byte[] _bytesStatus506;
    private static Byte[] _bytesStatus507;
    private static Byte[] _bytesStatus508;
    private static Byte[] _bytesStatus510;
    private static Byte[] _bytesStatus511;
    private static ReasonPhrases();
    private static Byte[] CreateStatusBytes(int statusCode);
    private static Byte[] CreateStatusBytes(int statusCode, string reasonPhrase);
    [NullableContextAttribute("1")]
public static Byte[] ToStatusBytes(int statusCode, string reasonPhrase);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.RequestProcessingStatus : Enum {
    public int value__;
    public static RequestProcessingStatus RequestPending;
    public static RequestProcessingStatus ParsingRequestLine;
    public static RequestProcessingStatus ParsingHeaders;
    public static RequestProcessingStatus AppStarted;
    public static RequestProcessingStatus HeadersCommitted;
    public static RequestProcessingStatus HeadersFlushed;
    public static RequestProcessingStatus ResponseCompleted;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.RequestRejectionReason : Enum {
    public int value__;
    public static RequestRejectionReason TlsOverHttpError;
    public static RequestRejectionReason UnrecognizedHTTPVersion;
    public static RequestRejectionReason InvalidRequestLine;
    public static RequestRejectionReason InvalidRequestHeader;
    public static RequestRejectionReason InvalidRequestHeadersNoCRLF;
    public static RequestRejectionReason MalformedRequestInvalidHeaders;
    public static RequestRejectionReason InvalidContentLength;
    public static RequestRejectionReason MultipleContentLengths;
    public static RequestRejectionReason UnexpectedEndOfRequestContent;
    public static RequestRejectionReason BadChunkSuffix;
    public static RequestRejectionReason BadChunkSizeData;
    public static RequestRejectionReason ChunkedRequestIncomplete;
    public static RequestRejectionReason InvalidRequestTarget;
    public static RequestRejectionReason InvalidCharactersInHeaderName;
    public static RequestRejectionReason RequestLineTooLong;
    public static RequestRejectionReason HeadersExceedMaxTotalSize;
    public static RequestRejectionReason TooManyHeaders;
    public static RequestRejectionReason RequestBodyTooLarge;
    public static RequestRejectionReason RequestHeadersTimeout;
    public static RequestRejectionReason RequestBodyTimeout;
    public static RequestRejectionReason FinalTransferCodingNotChunked;
    public static RequestRejectionReason LengthRequiredHttp10;
    public static RequestRejectionReason OptionsMethodRequired;
    public static RequestRejectionReason ConnectMethodRequired;
    public static RequestRejectionReason MissingHostHeader;
    public static RequestRejectionReason MultipleHostHeaders;
    public static RequestRejectionReason InvalidHostHeader;
    public static RequestRejectionReason RequestBodyExceedsContentLength;
}
[IsReadOnlyAttribute]
public class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength : ValueType {
    private ulong _targetOffsetPathLength;
    public int Offset { get; }
    public int Length { get; }
    public bool IsEncoded { get; }
    public TargetOffsetPathLength(int offset, int length, bool isEncoded);
    public int get_Offset();
    public int get_Length();
    public bool get_IsEncoded();
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TransferCoding : Enum {
    public int value__;
    public static TransferCoding None;
    public static TransferCoding Chunked;
    public static TransferCoding Other;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.ZeroContentLengthMessageBody : MessageBody {
    public bool IsEmpty { get; }
    public ZeroContentLengthMessageBody(bool keepAlive);
    public virtual bool get_IsEmpty();
    public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task ConsumeAsync();
    public virtual ValueTask StopAsync();
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& result);
    [NullableContextAttribute("2")]
public virtual void Complete(Exception ex);
    public virtual void CancelPendingRead();
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Bitshifter : object {
    public static UInt32 ReadUInt24BigEndian(ReadOnlySpan`1<byte> source);
    public static void WriteUInt24BigEndian(Span`1<byte> destination, UInt32 value);
    public static UInt32 ReadUInt31BigEndian(ReadOnlySpan`1<byte> source);
    public static void WriteUInt31BigEndian(Span`1<byte> destination, UInt32 value);
    public static void WriteUInt31BigEndian(Span`1<byte> destination, UInt32 value, bool preserveHighestBit);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.FlowControl : ValueType {
    [CompilerGeneratedAttribute]
private int <Available>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAborted>k__BackingField;
    public int Available { get; private set; }
    public bool IsAborted { get; private set; }
    public FlowControl(UInt32 initialWindowSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Available();
    [CompilerGeneratedAttribute]
private void set_Available(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsAborted();
    [CompilerGeneratedAttribute]
private void set_IsAborted(bool value);
    public void Advance(int bytes);
    public bool TryUpdateWindow(int bytes);
    public void Abort();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.InputFlowControl : object {
    private int _initialWindowSize;
    private int _minWindowSizeIncrement;
    private FlowControl _flow;
    private int _pendingUpdateSize;
    private bool _windowUpdatesDisabled;
    private object _flowLock;
    public bool IsAvailabilityLow { get; }
    public InputFlowControl(UInt32 initialWindowSize, UInt32 minWindowSizeIncrement);
    public bool get_IsAvailabilityLow();
    public void Reset();
    public bool TryAdvance(int bytes);
    public bool TryUpdateWindow(int bytes, Int32& updateSize);
    public void StopWindowUpdates();
    public int Abort();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.FlowControl.StreamInputFlowControl : object {
    private InputFlowControl _connectionLevelFlowControl;
    private InputFlowControl _streamLevelFlowControl;
    private Http2Stream _stream;
    private Http2FrameWriter _frameWriter;
    private int StreamId { get; }
    [NullableContextAttribute("1")]
public StreamInputFlowControl(Http2Stream stream, Http2FrameWriter frameWriter, InputFlowControl connectionLevelFlowControl, UInt32 initialWindowSize, UInt32 minWindowSizeIncrement);
    private int get_StreamId();
    public void Reset();
    public void Advance(int bytes);
    public void UpdateWindows(int bytes);
    public void StopWindowUpdates();
    public void Abort();
    private void UpdateConnectionWindow(int bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.HPackHeaderWriter : object {
    public static bool BeginEncodeHeaders(int statusCode, DynamicHPackEncoder hpackEncoder, Http2HeadersEnumerator headersEnumerator, Span`1<byte> buffer, Int32& length);
    public static bool BeginEncodeHeaders(DynamicHPackEncoder hpackEncoder, Http2HeadersEnumerator headersEnumerator, Span`1<byte> buffer, Int32& length);
    public static bool ContinueEncodeHeaders(DynamicHPackEncoder hpackEncoder, Http2HeadersEnumerator headersEnumerator, Span`1<byte> buffer, Int32& length);
    private static bool EncodeStatusHeader(int statusCode, DynamicHPackEncoder hpackEncoder, Span`1<byte> buffer, Int32& length);
    private static bool EncodeHeadersCore(DynamicHPackEncoder hpackEncoder, Http2HeadersEnumerator headersEnumerator, Span`1<byte> buffer, bool throwIfNoneEncoded, Int32& length);
    private static HeaderEncodingHint ResolveHeaderEncodingHint(int staticTableId, string name);
    private static bool IsSensitive(int staticTableIndex, string name);
    private static bool IsNotDynamicallyIndexed(int staticTableIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection : object {
    [NullableAttribute("2")]
public static Byte[] InvalidHttp1xErrorResponseBytes;
    private static PseudoHeaderFields _mandatoryRequestPseudoHeaderFields;
    private static int InitialStreamPoolSize;
    private static int MaxStreamPoolSize;
    private TimeSpan StreamPoolExpiry;
    private static string MaximumEnhanceYourCalmCountProperty;
    private static int _enhanceYourCalmMaximumCount;
    private static int EnhanceYourCalmTickWindowCount;
    private HttpConnectionContext _context;
    private ConnectionMetricsContext _metricsContext;
    private Http2FrameWriter _frameWriter;
    private Pipe _input;
    private Task _inputTask;
    private int _minAllocBufferSize;
    private HPackDecoder _hpackDecoder;
    private InputFlowControl _inputFlowControl;
    private Http2PeerSettings _serverSettings;
    private Http2PeerSettings _clientSettings;
    private Http2Frame _incomingFrame;
    private bool _scheduleInline;
    private Http2Stream _currentHeadersStream;
    private RequestHeaderParsingState _requestHeaderParsingState;
    private PseudoHeaderFields _parsedPseudoHeaderFields;
    private Http2HeadersFrameFlags _headerFlags;
    private int _totalParsedHeaderSize;
    private bool _isMethodConnect;
    private int _highestOpenedStreamId;
    private bool _gracefulCloseStarted;
    private int _clientActiveStreamCount;
    private int _serverActiveStreamCount;
    private int _enhanceYourCalmCount;
    private int _tickCount;
    private ConcurrentQueue`1<Http2Stream> _completedStreams;
    private StreamCloseAwaitable _streamCompletionAwaitable;
    private int _gracefulCloseInitiator;
    private int _isClosed;
    [NullableAttribute("2")]
internal Http2KeepAlive _keepAlive;
    internal Dictionary`2<int, Http2Stream> _streams;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PooledStreamStack`1<Http2Stream> StreamPool;
    internal IHttp2StreamLifetimeHandler _streamLifetimeHandler;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ClientPrefaceBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> AuthorityBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> MethodBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> PathBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> SchemeBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> StatusBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ConnectionBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> TeBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> TrailersBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ConnectBytes { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ProtocolBytes { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> ClientPreface { get; }
    private static bool IsEnhanceYourCalmEnabled { get; }
    public string ConnectionId { get; }
    public PipeReader Input { get; }
    public KestrelTrace Log { get; }
    public IFeatureCollection ConnectionFeatures { get; }
    public TimeProvider TimeProvider { get; }
    public ITimeoutControl TimeoutControl { get; }
    public KestrelServerLimits Limits { get; }
    internal Http2PeerSettings ServerSettings { get; }
    internal UInt32 MaxTrackedStreams { get; }
    public Http2Connection(HttpConnectionContext context);
    private static Http2Connection();
    private static ReadOnlySpan`1<byte> get_ClientPrefaceBytes();
    private static ReadOnlySpan`1<byte> get_AuthorityBytes();
    private static ReadOnlySpan`1<byte> get_MethodBytes();
    private static ReadOnlySpan`1<byte> get_PathBytes();
    private static ReadOnlySpan`1<byte> get_SchemeBytes();
    private static ReadOnlySpan`1<byte> get_StatusBytes();
    private static ReadOnlySpan`1<byte> get_ConnectionBytes();
    private static ReadOnlySpan`1<byte> get_TeBytes();
    private static ReadOnlySpan`1<byte> get_TrailersBytes();
    private static ReadOnlySpan`1<byte> get_ConnectBytes();
    private static ReadOnlySpan`1<byte> get_ProtocolBytes();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_ClientPreface();
    private static int GetMaximumEnhanceYourCalmCount();
    private static bool get_IsEnhanceYourCalmEnabled();
    public string get_ConnectionId();
    public PipeReader get_Input();
    public KestrelTrace get_Log();
    public IFeatureCollection get_ConnectionFeatures();
    public TimeProvider get_TimeProvider();
    public ITimeoutControl get_TimeoutControl();
    public KestrelServerLimits get_Limits();
    internal Http2PeerSettings get_ServerSettings();
    internal UInt32 get_MaxTrackedStreams();
    public sealed virtual void OnInputOrOutputCompleted();
    public sealed virtual void Abort(ConnectionAbortedException ex);
    public sealed virtual void StopProcessingNextRequest();
    public sealed virtual void HandleRequestHeadersTimeout();
    public sealed virtual void HandleReadDataRateTimeout();
    public void StopProcessingNextRequest(bool serverInitiated);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<ProcessRequestsAsync>d__92`1")]
public sealed virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    private void ValidateTlsRequirements();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<TryReadPrefaceAsync>d__95")]
private Task`1<bool> TryReadPrefaceAsync();
    private bool ParseHttp1x(ReadOnlySequence`1<byte> buffer, HttpVersion& httpVersion);
    private static bool IsPreface(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    private Task ProcessFrameAsync(IHttpApplication`1<TContext> application, ReadOnlySequence`1& payload);
    private Task ProcessDataFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessHeadersFrameAsync(IHttpApplication`1<TContext> application, ReadOnlySequence`1& payload);
    private Http2Stream GetStream(IHttpApplication`1<TContext> application);
    private Http2StreamContext CreateHttp2StreamContext();
    private Task ProcessPriorityFrameAsync();
    private Task ProcessRstStreamFrameAsync();
    private Task ProcessSettingsFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessPingFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessGoAwayFrameAsync();
    private Task ProcessWindowUpdateFrameAsync();
    private Task ProcessContinuationFrameAsync(ReadOnlySequence`1& payload);
    private Task ProcessUnknownFrameAsync();
    private Task DecodeHeadersAsync(bool endHeaders, ReadOnlySequence`1& payload);
    private Task DecodeTrailersAsync(bool endHeaders, ReadOnlySequence`1& payload);
    private void StartStream();
    private void ResetRequestHeaderParsingState();
    private void ThrowIfIncomingFrameSentToIdleStream();
    private void AbortStream(int streamId, IOException error);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor.Tick(long timestamp);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.IHttp2StreamLifetimeHandler.OnStreamCompleted(Http2Stream stream);
    private void UpdateCompletedStreams();
    private void RemoveStream(Http2Stream stream);
    private void MakeSpaceInDrainQueue();
    private void UpdateConnectionState();
    [NullableContextAttribute("0")]
public sealed virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("0")]
public sealed virtual void OnDynamicIndexedHeader(Nullable`1<int> index, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public sealed virtual void OnStaticIndexedHeader(int index);
    [NullableContextAttribute("0")]
public sealed virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    private void OnHeaderCore(HeaderType headerType, Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public sealed virtual void OnHeadersComplete(bool endStream);
    private void ValidateHeaderContent(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void UpdateHeaderParsingState(ReadOnlySpan`1<byte> value, PseudoHeaderFields headerField);
    private static PseudoHeaderFields GetPseudoHeaderField(int staticTableIndex);
    private static PseudoHeaderFields GetPseudoHeaderField(ReadOnlySpan`1<byte> name);
    private static bool IsConnectionSpecificHeaderField(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private bool TryClose();
    public void IncrementActiveClientStreamCount();
    public sealed virtual void DecrementActiveClientStreamCount();
    private PipeOptions GetInputPipeOptions();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Connection/<CopyPipeAsync>d__139")]
private Task CopyPipeAsync(PipeReader reader, PipeWriter writer);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ConnectionErrorException : Exception {
    [CompilerGeneratedAttribute]
private Http2ErrorCode <ErrorCode>k__BackingField;
    public Http2ErrorCode ErrorCode { get; }
    [NullableContextAttribute("1")]
public Http2ConnectionErrorException(string message, Http2ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_ErrorCode();
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ContinuationFrameFlags : Enum {
    public byte value__;
    public static Http2ContinuationFrameFlags NONE;
    public static Http2ContinuationFrameFlags END_HEADERS;
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2DataFrameFlags : Enum {
    public byte value__;
    public static Http2DataFrameFlags NONE;
    public static Http2DataFrameFlags END_STREAM;
    public static Http2DataFrameFlags PADDED;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2ErrorCode : Enum {
    public UInt32 value__;
    public static Http2ErrorCode NO_ERROR;
    public static Http2ErrorCode PROTOCOL_ERROR;
    public static Http2ErrorCode INTERNAL_ERROR;
    public static Http2ErrorCode FLOW_CONTROL_ERROR;
    public static Http2ErrorCode SETTINGS_TIMEOUT;
    public static Http2ErrorCode STREAM_CLOSED;
    public static Http2ErrorCode FRAME_SIZE_ERROR;
    public static Http2ErrorCode REFUSED_STREAM;
    public static Http2ErrorCode CANCEL;
    public static Http2ErrorCode COMPRESSION_ERROR;
    public static Http2ErrorCode CONNECT_ERROR;
    public static Http2ErrorCode ENHANCE_YOUR_CALM;
    public static Http2ErrorCode INADEQUATE_SECURITY;
    public static Http2ErrorCode HTTP_1_1_REQUIRED;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Frame : object {
    [CompilerGeneratedAttribute]
private int <PayloadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2FrameType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <DataPadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GoAwayLastStreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <GoAwayErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HeadersPadLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeadersStreamDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HeadersPriorityWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorityStreamDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PriorityIsExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <PriorityWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <RstStreamErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WindowUpdateSizeIncrement>k__BackingField;
    public Http2ContinuationFrameFlags ContinuationFlags { get; public set; }
    public bool ContinuationEndHeaders { get; }
    public int PayloadLength { get; public set; }
    public Http2FrameType Type { get; public set; }
    public byte Flags { get; public set; }
    public int StreamId { get; public set; }
    public Http2DataFrameFlags DataFlags { get; public set; }
    public bool DataEndStream { get; }
    public bool DataHasPadding { get; }
    public byte DataPadLength { get; public set; }
    private int DataPayloadOffset { get; }
    public int DataPayloadLength { get; }
    public int GoAwayLastStreamId { get; public set; }
    public Http2ErrorCode GoAwayErrorCode { get; public set; }
    public Http2HeadersFrameFlags HeadersFlags { get; public set; }
    public bool HeadersEndHeaders { get; }
    public bool HeadersEndStream { get; }
    public bool HeadersHasPadding { get; }
    public bool HeadersHasPriority { get; }
    public byte HeadersPadLength { get; public set; }
    public int HeadersStreamDependency { get; public set; }
    public byte HeadersPriorityWeight { get; public set; }
    private int HeadersPayloadOffset { get; }
    public int HeadersPayloadLength { get; }
    public Http2PingFrameFlags PingFlags { get; public set; }
    public bool PingAck { get; }
    public int PriorityStreamDependency { get; public set; }
    public bool PriorityIsExclusive { get; public set; }
    public byte PriorityWeight { get; public set; }
    public Http2ErrorCode RstStreamErrorCode { get; public set; }
    public Http2SettingsFrameFlags SettingsFlags { get; public set; }
    public bool SettingsAck { get; }
    public int WindowUpdateSizeIncrement { get; public set; }
    public Http2ContinuationFrameFlags get_ContinuationFlags();
    public void set_ContinuationFlags(Http2ContinuationFrameFlags value);
    public bool get_ContinuationEndHeaders();
    public void PrepareContinuation(Http2ContinuationFrameFlags flags, int streamId);
    [CompilerGeneratedAttribute]
public int get_PayloadLength();
    [CompilerGeneratedAttribute]
public void set_PayloadLength(int value);
    [CompilerGeneratedAttribute]
public Http2FrameType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Http2FrameType value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(int value);
    internal object ShowFlags();
    public virtual string ToString();
    public Http2DataFrameFlags get_DataFlags();
    public void set_DataFlags(Http2DataFrameFlags value);
    public bool get_DataEndStream();
    public bool get_DataHasPadding();
    [CompilerGeneratedAttribute]
public byte get_DataPadLength();
    [CompilerGeneratedAttribute]
public void set_DataPadLength(byte value);
    private int get_DataPayloadOffset();
    public int get_DataPayloadLength();
    public void PrepareData(int streamId, Nullable`1<byte> padLength);
    [CompilerGeneratedAttribute]
public int get_GoAwayLastStreamId();
    [CompilerGeneratedAttribute]
public void set_GoAwayLastStreamId(int value);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_GoAwayErrorCode();
    [CompilerGeneratedAttribute]
public void set_GoAwayErrorCode(Http2ErrorCode value);
    public void PrepareGoAway(int lastStreamId, Http2ErrorCode errorCode);
    public Http2HeadersFrameFlags get_HeadersFlags();
    public void set_HeadersFlags(Http2HeadersFrameFlags value);
    public bool get_HeadersEndHeaders();
    public bool get_HeadersEndStream();
    public bool get_HeadersHasPadding();
    public bool get_HeadersHasPriority();
    [CompilerGeneratedAttribute]
public byte get_HeadersPadLength();
    [CompilerGeneratedAttribute]
public void set_HeadersPadLength(byte value);
    [CompilerGeneratedAttribute]
public int get_HeadersStreamDependency();
    [CompilerGeneratedAttribute]
public void set_HeadersStreamDependency(int value);
    [CompilerGeneratedAttribute]
public byte get_HeadersPriorityWeight();
    [CompilerGeneratedAttribute]
public void set_HeadersPriorityWeight(byte value);
    private int get_HeadersPayloadOffset();
    public int get_HeadersPayloadLength();
    public void PrepareHeaders(Http2HeadersFrameFlags flags, int streamId);
    public Http2PingFrameFlags get_PingFlags();
    public void set_PingFlags(Http2PingFrameFlags value);
    public bool get_PingAck();
    public void PreparePing(Http2PingFrameFlags flags);
    [CompilerGeneratedAttribute]
public int get_PriorityStreamDependency();
    [CompilerGeneratedAttribute]
public void set_PriorityStreamDependency(int value);
    [CompilerGeneratedAttribute]
public bool get_PriorityIsExclusive();
    [CompilerGeneratedAttribute]
public void set_PriorityIsExclusive(bool value);
    [CompilerGeneratedAttribute]
public byte get_PriorityWeight();
    [CompilerGeneratedAttribute]
public void set_PriorityWeight(byte value);
    public void PreparePriority(int streamId, int streamDependency, bool exclusive, byte weight);
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_RstStreamErrorCode();
    [CompilerGeneratedAttribute]
public void set_RstStreamErrorCode(Http2ErrorCode value);
    public void PrepareRstStream(int streamId, Http2ErrorCode errorCode);
    public Http2SettingsFrameFlags get_SettingsFlags();
    public void set_SettingsFlags(Http2SettingsFrameFlags value);
    public bool get_SettingsAck();
    public void PrepareSettings(Http2SettingsFrameFlags flags);
    [CompilerGeneratedAttribute]
public int get_WindowUpdateSizeIncrement();
    [CompilerGeneratedAttribute]
public void set_WindowUpdateSizeIncrement(int value);
    public void PrepareWindowUpdate(int streamId, int sizeIncrement);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameReader : object {
    public static int HeaderLength;
    private static int TypeOffset;
    private static int FlagsOffset;
    private static int StreamIdOffset;
    public static int SettingSize;
    public static bool TryReadFrame(ReadOnlySequence`1& buffer, Http2Frame frame, UInt32 maxFrameSize, ReadOnlySequence`1& framePayload);
    private static int ReadExtendedFields(Http2Frame frame, ReadOnlySequence`1& readableBuffer);
    [NullableContextAttribute("1")]
public static int GetPayloadFieldsLength(Http2Frame frame);
    public static IList`1<Http2PeerSetting> ReadSettings(ReadOnlySequence`1& payload);
    private static Http2PeerSetting ReadSetting(ReadOnlySpan`1<byte> payload);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameType : Enum {
    public byte value__;
    public static Http2FrameType DATA;
    public static Http2FrameType HEADERS;
    public static Http2FrameType PRIORITY;
    public static Http2FrameType RST_STREAM;
    public static Http2FrameType SETTINGS;
    public static Http2FrameType PUSH_PROMISE;
    public static Http2FrameType PING;
    public static Http2FrameType GOAWAY;
    public static Http2FrameType WINDOW_UPDATE;
    public static Http2FrameType CONTINUATION;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter : object {
    private static string MaximumFlowControlQueueSizeProperty;
    private static Nullable`1<int> ConfiguredMaximumFlowControlQueueSize;
    private int _maximumFlowControlQueueSize;
    private object _writeLock;
    private Http2Frame _outgoingFrame;
    private Http2HeadersEnumerator _headersEnumerator;
    private ConcurrentPipeWriter _outputWriter;
    private BaseConnectionContext _connectionContext;
    private Http2Connection _http2Connection;
    private string _connectionId;
    private KestrelTrace _log;
    private ITimeoutControl _timeoutControl;
    private MinDataRate _minResponseDataRate;
    private TimingPipeFlusher _flusher;
    private DynamicHPackEncoder _hpackEncoder;
    private Channel`1<Http2OutputProducer> _channel;
    private bool _scheduleInline;
    private UInt32 _maxFrameSize;
    private Byte[] _headerEncodingBuffer;
    private long _unflushedBytes;
    private bool _completed;
    private bool _aborted;
    private object _windowUpdateLock;
    private long _connectionWindow;
    private Queue`1<Http2OutputProducer> _waitingForMoreConnectionWindow;
    private Http2OutputProducer _lastWindowConsumer;
    private Task _writeQueueTask;
    private static ReadOnlySpan`1<byte> ContinueBytes { get; }
    private bool IsMaximumFlowControlQueueSizeEnabled { get; }
    [NullableContextAttribute("1")]
public Http2FrameWriter(PipeWriter outputPipeWriter, BaseConnectionContext connectionContext, Http2Connection http2Connection, int maxStreamsPerConnection, ITimeoutControl timeoutControl, MinDataRate minResponseDataRate, string connectionId, MemoryPool`1<byte> memoryPool, ServiceContext serviceContext);
    private static Http2FrameWriter();
    private static ReadOnlySpan`1<byte> get_ContinueBytes();
    private static Nullable`1<int> GetConfiguredMaximumFlowControlQueueSize();
    private bool get_IsMaximumFlowControlQueueSizeEnabled();
    [NullableContextAttribute("1")]
public void Schedule(Http2OutputProducer producer);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter/<WriteToOutputPipe>d__34")]
private Task WriteToOutputPipe();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter/<HandleFlowControlErrorAsync>d__35")]
private Task HandleFlowControlErrorAsync();
    private bool TryQueueProducerForConnectionWindowUpdate(long actual, Http2OutputProducer producer);
    public void UpdateMaxHeaderTableSize(UInt32 maxHeaderTableSize);
    public void UpdateMaxFrameSize(UInt32 maxFrameSize);
    private bool CompleteUnsynchronized();
    public void Complete();
    [NullableContextAttribute("1")]
public Task ShutdownAsync();
    [NullableContextAttribute("1")]
public void Abort(ConnectionAbortedException error);
    private ValueTask`1<FlushResult> FlushEndOfStreamHeadersAsync(Http2Stream stream);
    public ValueTask`1<FlushResult> Write100ContinueAsync(int streamId);
    [NullableContextAttribute("1")]
public void WriteResponseHeaders(int streamId, int statusCode, Http2HeadersFrameFlags headerFrameFlags, HttpResponseHeaders headers);
    private void WriteResponseHeadersUnsynchronized(int streamId, int statusCode, Http2HeadersFrameFlags headerFrameFlags, HttpResponseHeaders headers);
    private ValueTask`1<FlushResult> WriteDataAndTrailersAsync(Http2Stream stream, ReadOnlySequence`1& data, bool writeHeaders, HttpResponseTrailers headers);
    private void FinishWritingHeadersUnsynchronized(int streamId, int payloadLength, bool done);
    private void WriteDataUnsynchronized(int streamId, ReadOnlySequence`1& data, long dataLength, bool endStream);
    private ValueTask`1<FlushResult> WriteDataAsync(Http2Stream stream, ReadOnlySequence`1<byte> data, long dataLength, bool endStream, bool writeHeaders);
    public ValueTask`1<FlushResult> WriteWindowUpdateAsync(int streamId, int sizeIncrement);
    public ValueTask`1<FlushResult> WriteRstStreamAsync(int streamId, Http2ErrorCode errorCode);
    public ValueTask`1<FlushResult> WriteSettingsAsync(List`1<Http2PeerSetting> settings);
    internal static void WriteSettings(List`1<Http2PeerSetting> settings, Span`1<byte> destination);
    public ValueTask`1<FlushResult> WriteSettingsAckAsync();
    public ValueTask`1<FlushResult> WritePingAsync(Http2PingFrameFlags flags, ReadOnlySequence`1& payload);
    public ValueTask`1<FlushResult> WriteGoAwayAsync(int lastStreamId, Http2ErrorCode errorCode);
    private void WriteHeaderUnsynchronized();
    [NullableContextAttribute("1")]
internal static void WriteHeader(Http2Frame frame, PipeWriter output);
    private ValueTask`1<FlushResult> TimeFlushUnsynchronizedAsync();
    private long CheckConnectionWindow(long bytes);
    private void ConsumeConnectionWindow(long bytes);
    private void AbortConnectionFlowControl();
    public bool TryUpdateConnectionWindow(int bytes);
    private void EnqueueWaitingForMoreConnectionWindow(Http2OutputProducer producer);
    [CompilerGeneratedAttribute]
internal static bool <WriteToOutputPipe>g__HasStateFlag|34_0(State state, State flags);
    [CompilerGeneratedAttribute]
private void <WriteDataUnsynchronized>g__TrimAndWriteDataUnsynchronized|49_0(ReadOnlySequence`1& data, long dataLength, bool endStream);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2FrameWriter/<<WriteDataAsync>g__FlushAsyncAwaited|50_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<FlushResult> <WriteDataAsync>g__FlushAsyncAwaited|50_0(ValueTask`1<FlushResult> writeTask, ITimeoutControl timeoutControl, MinDataRate minResponseDataRate);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2HeadersEnumerator : object {
    private HeadersType _headersType;
    private Enumerator _headersEnumerator;
    private Enumerator _trailersEnumerator;
    private Enumerator _stringValuesEnumerator;
    private bool _hasMultipleValues;
    private KnownHeaderType _knownHeaderType;
    [CompilerGeneratedAttribute]
private Func`2<string, Encoding> <EncodingSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <Current>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> EncodingSelector { get; public set; }
    public int HPackStaticTableId { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, string> Current { get; private set; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    [CompilerGeneratedAttribute]
public Func`2<string, Encoding> get_EncodingSelector();
    [CompilerGeneratedAttribute]
public void set_EncodingSelector(Func`2<string, Encoding> value);
    public int get_HPackStaticTableId();
    [CompilerGeneratedAttribute]
public sealed virtual KeyValuePair`2<string, string> get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(KeyValuePair`2<string, string> value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [NullableContextAttribute("1")]
public void Initialize(HttpResponseHeaders headers);
    [NullableContextAttribute("1")]
public void Initialize(HttpResponseTrailers headers);
    public sealed virtual bool MoveNext();
    private static void ThrowUnexpectedHeadersType();
    private bool MoveNextOnStringEnumerator(string key);
    private bool SetCurrent(string name, StringValues value, KnownHeaderType knownHeaderType);
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    internal static int GetResponseHeaderStaticTableId(KnownHeaderType responseHeaderType);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2HeadersFrameFlags : Enum {
    public byte value__;
    public static Http2HeadersFrameFlags NONE;
    public static Http2HeadersFrameFlags END_STREAM;
    public static Http2HeadersFrameFlags END_HEADERS;
    public static Http2HeadersFrameFlags PADDED;
    public static Http2HeadersFrameFlags PRIORITY;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2KeepAlive : object {
    internal static ReadOnlySequence`1<byte> PingPayload;
    private long _keepAliveInterval;
    private long _keepAliveTimeout;
    private TimeProvider _timeProvider;
    private long _lastFrameReceivedTimestamp;
    private long _pingSentTimestamp;
    internal KeepAliveState _state;
    [NullableContextAttribute("1")]
public Http2KeepAlive(TimeSpan keepAliveInterval, TimeSpan keepAliveTimeout, TimeProvider timeProvider);
    private static Http2KeepAlive();
    public KeepAliveState ProcessKeepAlive(bool frameReceived);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2MessageBody : MessageBody {
    private Http2Stream _context;
    private ReadResult _readResult;
    [NullableContextAttribute("1")]
public Http2MessageBody(Http2Stream context);
    protected virtual void OnReadStarting();
    [NullableContextAttribute("1")]
protected virtual Task OnReadStartedAsync();
    public virtual void Reset();
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& readResult);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2MessageBody/<ReadAsync>d__8")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual void CancelPendingRead();
    protected virtual ValueTask OnStopAsync();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2OutputProducer : object {
    private Http2FrameWriter _frameWriter;
    private TimingPipeFlusher _flusher;
    private KestrelTrace _log;
    private MemoryPool`1<byte> _memoryPool;
    private Http2Stream _stream;
    private object _dataWriterLock;
    private Pipe _pipe;
    private ConcurrentPipeWriter _pipeWriter;
    private PipeReader _pipeReader;
    private IMemoryOwner`1<byte> _fakeMemoryOwner;
    private Byte[] _fakeMemory;
    private bool _startedWritingDataFrames;
    private bool _completeScheduled;
    private bool _suffixSent;
    private bool _appCompletedWithNoResponseBodyOrTrailers;
    private bool _writerComplete;
    private bool _isScheduled;
    internal bool _disposed;
    private long _unconsumedBytes;
    private long _streamWindow;
    private State _unobservedState;
    private State _currentState;
    private bool _completedResponse;
    private bool _requestProcessingComplete;
    private bool _waitingForWindowUpdates;
    private Nullable`1<Http2ErrorCode> _resetErrorCode;
    [CompilerGeneratedAttribute]
private bool <IsTimingWrite>k__BackingField;
    private int StreamId { get; }
    [NullableAttribute("1")]
public Http2Stream Stream { get; }
    [NullableAttribute("1")]
public PipeReader PipeReader { get; }
    public bool IsTimingWrite { get; public set; }
    public bool AppCompletedWithNoResponseBodyOrTrailers { get; }
    public bool CompletedResponse { get; }
    internal ValueTuple`5<int, long, State, State, long> SchedulingState { get; }
    public State UnobservedState { get; }
    public State CurrentState { get; }
    [NullableContextAttribute("1")]
public Http2OutputProducer(Http2Stream stream, Http2StreamContext context);
    private int get_StreamId();
    [NullableContextAttribute("1")]
public Http2Stream get_Stream();
    [NullableContextAttribute("1")]
public PipeReader get_PipeReader();
    [CompilerGeneratedAttribute]
public bool get_IsTimingWrite();
    [CompilerGeneratedAttribute]
public void set_IsTimingWrite(bool value);
    public bool get_AppCompletedWithNoResponseBodyOrTrailers();
    public bool get_CompletedResponse();
    internal ValueTuple`5<int, long, State, State, long> get_SchedulingState();
    public State get_UnobservedState();
    public State get_CurrentState();
    private void EnqueueDataWrite(long bytes);
    private void EnqueueStateUpdate(State state);
    public void SetWaitingForWindowUpdates();
    internal ValueTuple`4<bool, bool, State, bool> ObserveDataAndState(long bytes, State state);
    internal long CheckStreamWindow(long bytes);
    internal void ConsumeStreamWindow(long bytes);
    public void StreamReset(UInt32 initialWindowSize);
    public void Complete();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.Abort(ConnectionAbortedException abortReason);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.OnInputOrOutputCompleted();
    public sealed virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public void Schedule();
    public bool TryScheduleNextWriteIfStreamWindowHasSpace();
    public void ScheduleResumeFromWindowUpdate();
    public sealed virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    [NullableContextAttribute("1")]
public sealed virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appCompleted);
    public sealed virtual Task WriteDataAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    public ValueTask`1<FlushResult> WriteRstStreamAsync(Http2ErrorCode error);
    public sealed virtual void Advance(int bytes);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<FlushResult> Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputProducer.WriteChunkAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual void Stop();
    public sealed virtual void Reset();
    internal void OnRequestProcessingEnded();
    internal ValueTask`1<FlushResult> CompleteResponseAsync();
    internal Memory`1<byte> GetFakeMemory(int minSize);
    public bool TryUpdateStreamWindow(int bytes);
    [StackTraceHiddenAttribute]
private void ThrowIfSuffixSentOrCompleted();
    [StackTraceHiddenAttribute]
private static void ThrowSuffixSent();
    [StackTraceHiddenAttribute]
private static void ThrowWriterComplete();
    private static Pipe CreateDataPipe(MemoryPool`1<byte> pool, bool scheduleInline);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <TryUpdateStreamWindow>g__UpdateStreamWindow|79_0(long bytes);
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PeerSetting : ValueType {
    [CompilerGeneratedAttribute]
private Http2SettingsParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public Http2SettingsParameter Parameter { get; }
    public UInt32 Value { get; }
    public Http2PeerSetting(Http2SettingsParameter parameter, UInt32 value);
    [CompilerGeneratedAttribute]
public Http2SettingsParameter get_Parameter();
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PeerSettings : object {
    public static UInt32 DefaultHeaderTableSize;
    public static bool DefaultEnablePush;
    public static UInt32 DefaultMaxConcurrentStreams;
    public static UInt32 DefaultInitialWindowSize;
    public static UInt32 DefaultMaxFrameSize;
    public static UInt32 DefaultMaxHeaderListSize;
    public static UInt32 MaxWindowSize;
    internal static int MinAllowedMaxFrameSize;
    internal static int MaxAllowedMaxFrameSize;
    [CompilerGeneratedAttribute]
private UInt32 <HeaderTableSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePush>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxConcurrentStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <InitialWindowSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxFrameSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxHeaderListSize>k__BackingField;
    public UInt32 HeaderTableSize { get; public set; }
    public bool EnablePush { get; public set; }
    public UInt32 MaxConcurrentStreams { get; public set; }
    public UInt32 InitialWindowSize { get; public set; }
    public UInt32 MaxFrameSize { get; public set; }
    public UInt32 MaxHeaderListSize { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_HeaderTableSize();
    [CompilerGeneratedAttribute]
public void set_HeaderTableSize(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_EnablePush();
    [CompilerGeneratedAttribute]
public void set_EnablePush(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxConcurrentStreams();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentStreams(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_InitialWindowSize();
    [CompilerGeneratedAttribute]
public void set_InitialWindowSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxFrameSize();
    [CompilerGeneratedAttribute]
public void set_MaxFrameSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxHeaderListSize();
    [CompilerGeneratedAttribute]
public void set_MaxHeaderListSize(UInt32 value);
    public void Update(IList`1<Http2PeerSetting> settings);
    internal List`1<Http2PeerSetting> GetNonProtocolDefaults();
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2PingFrameFlags : Enum {
    public byte value__;
    public static Http2PingFrameFlags NONE;
    public static Http2PingFrameFlags ACK;
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsFrameFlags : Enum {
    public byte value__;
    public static Http2SettingsFrameFlags NONE;
    public static Http2SettingsFrameFlags ACK;
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsParameter : Enum {
    public ushort value__;
    public static Http2SettingsParameter SETTINGS_HEADER_TABLE_SIZE;
    public static Http2SettingsParameter SETTINGS_ENABLE_PUSH;
    public static Http2SettingsParameter SETTINGS_MAX_CONCURRENT_STREAMS;
    public static Http2SettingsParameter SETTINGS_INITIAL_WINDOW_SIZE;
    public static Http2SettingsParameter SETTINGS_MAX_FRAME_SIZE;
    public static Http2SettingsParameter SETTINGS_MAX_HEADER_LIST_SIZE;
    public static Http2SettingsParameter SETTINGS_ENABLE_CONNECT_PROTOCOL;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2SettingsParameterOutOfRangeException : Exception {
    [CompilerGeneratedAttribute]
private Http2SettingsParameter <Parameter>k__BackingField;
    public Http2SettingsParameter Parameter { get; }
    public Http2SettingsParameterOutOfRangeException(Http2SettingsParameter parameter, long lowerBound, long upperBound);
    [CompilerGeneratedAttribute]
public Http2SettingsParameter get_Parameter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream : HttpProtocol {
    private Http2StreamContext _context;
    private Http2OutputProducer _http2Output;
    private StreamInputFlowControl _inputFlowControl;
    private Http2MessageBody _messageBody;
    private bool _decrementCalled;
    [CompilerGeneratedAttribute]
private int <TotalParsedHeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <RequestBodyPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DrainExpirationTimestamp>k__BackingField;
    private StreamCompletionFlags _completionState;
    private object _completionLock;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <InputRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestBodyStarted>k__BackingField;
    private IHeaderDictionary _userTrailers;
    private IDictionary`2<object, object> _persistentState;
    public int TotalParsedHeaderSize { get; public set; }
    public Pipe RequestBodyPipe { get; private set; }
    internal long DrainExpirationTimestamp { get; internal set; }
    public int StreamId { get; }
    public BaseConnectionContext ConnectionContext { get; }
    public ConnectionMetricsContext MetricsContext { get; }
    public Nullable`1<long> InputRemaining { get; internal set; }
    public bool RequestBodyStarted { get; private set; }
    public bool EndStreamReceived { get; }
    private bool IsAborted { get; }
    internal bool RstStreamReceived { get; }
    public bool ReceivedEmptyRequestBody { get; }
    public bool CanReuse { get; }
    private long Microsoft.AspNetCore.Server.Kestrel.IPooledStream.PoolExpirationTimestamp { get; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.Trailers { get; private set; }
    private int Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature.StreamId { get; }
    [NullableAttribute("2")]
private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.MinDataRate { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.State { get; }
    [CompilerGeneratedAttribute]
public int get_TotalParsedHeaderSize();
    [CompilerGeneratedAttribute]
public void set_TotalParsedHeaderSize(int value);
    [CompilerGeneratedAttribute]
public Pipe get_RequestBodyPipe();
    [CompilerGeneratedAttribute]
private void set_RequestBodyPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal long get_DrainExpirationTimestamp();
    [CompilerGeneratedAttribute]
internal void set_DrainExpirationTimestamp(long value);
    public void Initialize(Http2StreamContext context);
    public void InitializeWithExistingContext(int streamId);
    public int get_StreamId();
    public BaseConnectionContext get_ConnectionContext();
    public ConnectionMetricsContext get_MetricsContext();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_InputRemaining();
    [CompilerGeneratedAttribute]
internal void set_InputRemaining(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_RequestBodyStarted();
    [CompilerGeneratedAttribute]
private void set_RequestBodyStarted(bool value);
    public bool get_EndStreamReceived();
    private bool get_IsAborted();
    internal bool get_RstStreamReceived();
    public bool get_ReceivedEmptyRequestBody();
    public bool get_CanReuse();
    protected virtual void OnReset();
    protected virtual void OnRequestProcessingEnded();
    public void CompleteStream(bool errored);
    protected virtual string CreateRequestId();
    protected virtual MessageBody CreateMessageBody();
    protected virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private bool TryValidatePseudoHeaders();
    private bool TryValidateMethod();
    private bool TryValidateAuthorityAndHost(String& hostText);
    [SkipLocalsInitAttribute]
private bool TryValidatePath(ReadOnlySpan`1<char> pathSegment);
    public Task OnDataAsync(Http2Frame dataFrame, ReadOnlySequence`1& payload);
    public void OnEndStreamReceived();
    public void OnDataRead(int bytesRead);
    public bool TryUpdateOutputWindow(int bytes);
    public void AbortRstStreamReceived();
    public void Abort(IOException abortReason);
    protected virtual void OnErrorAfterResponseStarted();
    protected virtual void ApplicationAbort();
    private void ApplicationAbort(ConnectionAbortedException abortReason, Http2ErrorCode error);
    internal void ResetAndAbort(ConnectionAbortedException abortReason, Http2ErrorCode error);
    private void AbortCore(Exception abortReason);
    public void DecrementActiveClientStreamCount();
    private Pipe CreateRequestBodyPipe();
    private ValueTuple`2<StreamCompletionFlags, StreamCompletionFlags> ApplyCompletionFlag(StreamCompletionFlags completionState);
    public abstract virtual void Execute();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
public virtual void OnHeader(int index, bool indexOnly, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void AppendHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.IPooledStream.DisposeCore();
    private sealed virtual override long Microsoft.AspNetCore.Server.Kestrel.IPooledStream.get_PoolExpirationTimestamp();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.get_Trailers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.set_Trailers(IHeaderDictionary value);
    private sealed virtual override int Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature.get_StreamId();
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResetFeature.Reset(int errorCode);
    private sealed virtual override IDictionary`2<object, object> Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.get_State();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2Stream`1 : Http2Stream {
    private IHttpApplication`1<TContext> _application;
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    [NullableAttribute("2")]
private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http2Stream`1(IHttpApplication`1<TContext> application, Http2StreamContext context);
    public virtual void Execute();
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamContext : HttpConnectionContext {
    [CompilerGeneratedAttribute]
private IHttp2StreamLifetimeHandler <StreamLifetimeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2PeerSettings <ClientPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2PeerSettings <ServerPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2FrameWriter <FrameWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private InputFlowControl <ConnectionInputFlowControl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    public IHttp2StreamLifetimeHandler StreamLifetimeHandler { get; }
    public Http2PeerSettings ClientPeerSettings { get; }
    public Http2PeerSettings ServerPeerSettings { get; }
    public Http2FrameWriter FrameWriter { get; }
    public InputFlowControl ConnectionInputFlowControl { get; }
    public int StreamId { get; public set; }
    public Http2StreamContext(string connectionId, HttpProtocols protocols, AltSvcHeader altSvcHeader, BaseConnectionContext connectionContext, ServiceContext serviceContext, IFeatureCollection connectionFeatures, MemoryPool`1<byte> memoryPool, IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, int streamId, IHttp2StreamLifetimeHandler streamLifetimeHandler, Http2PeerSettings clientPeerSettings, Http2PeerSettings serverPeerSettings, Http2FrameWriter frameWriter, InputFlowControl connectionInputFlowControl, ConnectionMetricsContext metricsContext);
    [CompilerGeneratedAttribute]
public IHttp2StreamLifetimeHandler get_StreamLifetimeHandler();
    [CompilerGeneratedAttribute]
public Http2PeerSettings get_ClientPeerSettings();
    [CompilerGeneratedAttribute]
public Http2PeerSettings get_ServerPeerSettings();
    [CompilerGeneratedAttribute]
public Http2FrameWriter get_FrameWriter();
    [CompilerGeneratedAttribute]
public InputFlowControl get_ConnectionInputFlowControl();
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(int value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.Http2StreamErrorException : Exception {
    [CompilerGeneratedAttribute]
private int <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Http2ErrorCode <ErrorCode>k__BackingField;
    public int StreamId { get; }
    public Http2ErrorCode ErrorCode { get; }
    [NullableContextAttribute("1")]
public Http2StreamErrorException(int streamId, string message, Http2ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public int get_StreamId();
    [CompilerGeneratedAttribute]
public Http2ErrorCode get_ErrorCode();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.IHttp2StreamLifetimeHandler {
    public abstract virtual void OnStreamCompleted(Http2Stream stream);
    public abstract virtual void DecrementActiveClientStreamCount();
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2.KeepAliveState : Enum {
    public int value__;
    public static KeepAliveState None;
    public static KeepAliveState SendPing;
    public static KeepAliveState PingSent;
    public static KeepAliveState Timeout;
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.DefaultStreamDirectionFeature : object {
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public DefaultStreamDirectionFeature(bool canRead, bool canWrite);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanWrite();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection : object {
    internal static object StreamPersistentStateKey;
    internal IHttp3StreamLifetimeHandler _streamLifetimeHandler;
    internal Dictionary`2<long, IHttp3Stream> _streams;
    internal Dictionary`2<long, Http3PendingStream> _unidentifiedStreams;
    internal MultiplexedConnectionContext _multiplexedContext;
    internal Http3PeerSettings _serverSettings;
    internal Http3PeerSettings _clientSettings;
    private static long DefaultHighestOpenedRequestStreamId;
    private object _sync;
    private HttpMultiplexedConnectionContext _context;
    private object _protocolSelectionLock;
    private StreamCloseAwaitable _streamCompletionAwaitable;
    private IProtocolErrorCodeFeature _errorCodeFeature;
    private Dictionary`2<long, WebTransportSession> _webtransportSessions;
    private long _highestOpenedRequestStreamId;
    private bool _aborted;
    private int _gracefulCloseInitiator;
    private int _stoppedAcceptingStreams;
    private bool _gracefulCloseStarted;
    private int _activeRequestCount;
    private CancellationTokenSource _acceptStreamsCts;
    [CompilerGeneratedAttribute]
private ConnectionMetricsContext <MetricsContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3ControlStream <OutboundControlStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3ControlStream <ControlStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3ControlStream <EncoderStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3ControlStream <DecoderStream>k__BackingField;
    private KestrelTrace Log { get; }
    public ConnectionMetricsContext MetricsContext { get; }
    public KestrelServerLimits Limits { get; }
    [NullableAttribute("2")]
public Http3ControlStream OutboundControlStream { get; public set; }
    [NullableAttribute("2")]
public Http3ControlStream ControlStream { get; public set; }
    [NullableAttribute("2")]
public Http3ControlStream EncoderStream { get; public set; }
    [NullableAttribute("2")]
public Http3ControlStream DecoderStream { get; public set; }
    public string ConnectionId { get; }
    public ITimeoutControl TimeoutControl { get; }
    public Http3Connection(HttpMultiplexedConnectionContext context);
    private static Http3Connection();
    private void UpdateHighestOpenedRequestStreamId(long streamId);
    private long GetCurrentGoAwayStreamId();
    private KestrelTrace get_Log();
    [CompilerGeneratedAttribute]
public ConnectionMetricsContext get_MetricsContext();
    public KestrelServerLimits get_Limits();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Http3ControlStream get_OutboundControlStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_OutboundControlStream(Http3ControlStream value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Http3ControlStream get_ControlStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ControlStream(Http3ControlStream value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Http3ControlStream get_EncoderStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_EncoderStream(Http3ControlStream value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Http3ControlStream get_DecoderStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DecoderStream(Http3ControlStream value);
    public string get_ConnectionId();
    public ITimeoutControl get_TimeoutControl();
    public sealed virtual void StopProcessingNextRequest();
    public void StopProcessingNextRequest(bool serverInitiated);
    public void OnConnectionClosed();
    private bool TryStopAcceptingStreams();
    public sealed virtual void Abort(ConnectionAbortedException ex);
    public void Abort(ConnectionAbortedException ex, Http3ErrorCode errorCode);
    public sealed virtual void Tick(long timestamp);
    private void ValidateOpenControlStreams(long timestamp);
    private void UpdateStreamTimeouts(long timestamp);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<ProcessRequestsAsync>d__60`1")]
public sealed virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<CreateHttp3Stream>d__61`1")]
private Task CreateHttp3Stream(ConnectionContext streamContext, IHttpApplication`1<TContext> application, long streamId);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<CreateAndAddWebTransportStream>d__62")]
private Task CreateAndAddWebTransportStream(Http3PendingStream stream, long streamId, WebTransportStreamType type);
    private static ConnectionAbortedException CreateConnectionAbortError(Exception error, bool clientAbort);
    internal Http3StreamContext CreateHttpStreamContext(ConnectionContext streamContext);
    private void UpdateConnectionState();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<ProcessOutboundControlStreamAsync>d__66")]
private ValueTask ProcessOutboundControlStreamAsync(Http3ControlStream controlStream);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<CreateNewUnidirectionalStreamAsync>d__67`1")]
private ValueTask`1<Http3ControlStream> CreateNewUnidirectionalStreamAsync(IHttpApplication`1<TContext> application);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Connection/<SendGoAwayAsync>d__68")]
private ValueTask`1<FlushResult> SendGoAwayAsync(long id);
    private sealed virtual override bool Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnInboundControlStream(Http3ControlStream stream);
    private sealed virtual override bool Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnInboundEncoderStream(Http3ControlStream stream);
    private sealed virtual override bool Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnInboundDecoderStream(Http3ControlStream stream);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnUnidentifiedStreamReceived(Http3PendingStream stream);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnStreamCreated(IHttp3Stream stream);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnStreamCompleted(IHttp3Stream stream);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnStreamConnectionError(Http3ConnectionErrorException ex);
    private void OnStreamConnectionError(Http3ConnectionErrorException ex);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnInboundControlStreamSetting(Http3SettingType type, long value);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler.OnStreamHeaderReceived(IHttp3Stream stream);
    public sealed virtual void HandleRequestHeadersTimeout();
    public sealed virtual void HandleReadDataRateTimeout();
    public sealed virtual void OnInputOrOutputCompleted();
    internal WebTransportSession OpenNewWebTransportSession(Http3Stream http3Stream);
    [CompilerGeneratedAttribute]
internal static void <ValidateOpenControlStreams>g__ValidateOpenControlStream|58_0(Http3ControlStream stream, Http3Connection connection, long timestamp);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ConnectionErrorException : Exception {
    [CompilerGeneratedAttribute]
private Http3ErrorCode <ErrorCode>k__BackingField;
    public Http3ErrorCode ErrorCode { get; }
    [NullableContextAttribute("1")]
public Http3ConnectionErrorException(string message, Http3ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public Http3ErrorCode get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream : object {
    private static int ControlStreamTypeId;
    private static int EncoderStreamTypeId;
    private static int DecoderStreamTypeId;
    private Http3FrameWriter _frameWriter;
    private Http3StreamContext _context;
    private Http3PeerSettings _serverPeerSettings;
    private IStreamIdFeature _streamIdFeature;
    private IStreamClosedFeature _streamClosedFeature;
    private IProtocolErrorCodeFeature _errorCodeFeature;
    private Http3RawFrame _incomingFrame;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isClosed;
    private long _headerType;
    private object _completionLock;
    private bool _haveReceivedSettingsFrame;
    private StreamCompletionFlags _completionState;
    [CompilerGeneratedAttribute]
private long <StreamTimeoutTimestamp>k__BackingField;
    public bool EndStreamReceived { get; }
    public bool IsAborted { get; }
    public bool IsCompleted { get; }
    public long StreamId { get; }
    public PipeReader Input { get; }
    public KestrelTrace Log { get; }
    public long StreamTimeoutTimestamp { get; public set; }
    public bool IsReceivingHeader { get; }
    public bool IsDraining { get; }
    public bool IsRequestStream { get; }
    public string TraceIdentifier { get; }
    public Http3ControlStream(Http3StreamContext context, Nullable`1<long> headerType);
    public sealed virtual bool get_EndStreamReceived();
    public sealed virtual bool get_IsAborted();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual long get_StreamId();
    private void OnStreamClosed();
    public PipeReader get_Input();
    public KestrelTrace get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual long get_StreamTimeoutTimestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StreamTimeoutTimestamp(long value);
    public sealed virtual bool get_IsReceivingHeader();
    public sealed virtual bool get_IsDraining();
    public sealed virtual bool get_IsRequestStream();
    public sealed virtual string get_TraceIdentifier();
    public sealed virtual void Abort(ConnectionAbortedException abortReason, Http3ErrorCode errorCode);
    public void OnInputOrOutputCompleted();
    private bool TryClose();
    private ValueTuple`2<StreamCompletionFlags, StreamCompletionFlags> ApplyCompletionFlag(StreamCompletionFlags completionState);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream/<ProcessOutboundSendsAsync>d__45")]
internal ValueTask ProcessOutboundSendsAsync(long id);
    [NullableContextAttribute("0")]
internal ValueTask`1<FlushResult> SendGoAway(long id);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream/<TryReadStreamHeaderAsync>d__47")]
private ValueTask`1<long> TryReadStreamHeaderAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream/<ProcessRequestAsync>d__48`1")]
public Task ProcessRequestAsync(IHttpApplication`1<TContext> application);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream/<HandleControlStream>d__49")]
private Task HandleControlStream();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream/<HandleEncodingDecodingTask>d__50")]
private ValueTask HandleEncodingDecodingTask();
    private ValueTask ProcessHttp3ControlStream(ReadOnlySequence`1& payload);
    private ValueTask ProcessSettingsFrameAsync(ReadOnlySequence`1<byte> payload);
    private void ProcessSetting(long id, long value);
    private ValueTask ProcessGoAwayFrameAsync();
    private ValueTask ProcessCancelPushFrameAsync();
    private ValueTask ProcessMaxPushIdFrameAsync();
    private ValueTask ProcessUnknownFrameAsync(Http3FrameType frameType);
    private void EnsureSettingsFrame(Http3FrameType frameType);
    public abstract virtual void Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3ControlStream`1 : Http3ControlStream {
    private IHttpApplication`1<TContext> _application;
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    [NullableAttribute("2")]
private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http3ControlStream`1(IHttpApplication`1<TContext> application, Http3StreamContext context, Nullable`1<long> headerType);
    public virtual void Execute();
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Formatting : object {
    public static string ToFormattedType(Http3FrameType type);
    public static string ToFormattedErrorCode(Http3ErrorCode errorCode);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3FrameReader : object {
    internal static bool TryReadFrame(ReadOnlySequence`1& readableBuffer, Http3RawFrame frame, ReadOnlySequence`1& framePayload);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3FrameWriter : object {
    private static int MaxDataFrameSize;
    private static int HeaderBufferSize;
    private object _writeLock;
    private int _maxTotalHeaderSize;
    private ConnectionContext _connectionContext;
    private ITimeoutControl _timeoutControl;
    private MinDataRate _minResponseDataRate;
    private MemoryPool`1<byte> _memoryPool;
    private KestrelTrace _log;
    private IStreamIdFeature _streamIdFeature;
    private IHttp3Stream _http3Stream;
    private Http3RawFrame _outgoingFrame;
    private TimingPipeFlusher _flusher;
    private PipeWriter _outputWriter;
    private string _connectionId;
    private ArrayBufferWriter`1<byte> _headerEncodingBuffer;
    private Http3HeadersEnumerator _headersEnumerator;
    private int _headersTotalSize;
    private long _unflushedBytes;
    private bool _completed;
    private bool _aborted;
    private static ReadOnlySpan`1<byte> ContinueBytes { get; }
    [NullableContextAttribute("1")]
public Http3FrameWriter(ConnectionContext connectionContext, ITimeoutControl timeoutControl, MinDataRate minResponseDataRate, MemoryPool`1<byte> memoryPool, KestrelTrace log, IStreamIdFeature streamIdFeature, Http3PeerSettings clientPeerSettings, IHttp3Stream http3Stream);
    private static ReadOnlySpan`1<byte> get_ContinueBytes();
    [NullableContextAttribute("1")]
public void Reset(PipeWriter output, string connectionId);
    [NullableContextAttribute("1")]
internal Task WriteSettingsAsync(List`1<Http3PeerSetting> settings);
    [NullableContextAttribute("1")]
internal static int CalculateSettingsSize(List`1<Http3PeerSetting> settings);
    internal static void WriteSettings(List`1<Http3PeerSetting> settings, Span`1<byte> destination);
    [NullableContextAttribute("1")]
internal Task WriteStreamIdAsync(long id);
    public ValueTask`1<FlushResult> WriteDataAsync(ReadOnlySequence`1& data);
    private void WriteDataUnsynchronized(ReadOnlySequence`1& data, long dataLength);
    internal ValueTask`1<FlushResult> WriteGoAway(long id);
    private void WriteHeaderUnsynchronized();
    public ValueTask`1<FlushResult> Write100ContinueAsync();
    [NullableContextAttribute("1")]
internal static int WriteHeader(Http3FrameType frameType, long frameLength, PipeWriter output);
    public ValueTask`1<FlushResult> WriteResponseTrailersAsync(long streamId, HttpResponseTrailers headers);
    private ValueTask`1<FlushResult> TimeFlushUnsynchronizedAsync();
    public ValueTask`1<FlushResult> FlushAsync(IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
internal void WriteResponseHeaders(int statusCode, HttpResponseHeaders headers);
    private void FinishWritingHeaders(int payloadLength, bool done);
    public ValueTask CompleteAsync();
    [NullableContextAttribute("1")]
public void Abort(ConnectionAbortedException error);
    [CompilerGeneratedAttribute]
private void <WriteDataUnsynchronized>g__SplitAndWriteDataUnsynchronized|30_0(ReadOnlySequence`1& data, long dataLength);
    [CompilerGeneratedAttribute]
private void <FinishWritingHeaders>g__ValidateHeadersTotalSize|39_0();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3HeadersEnumerator : object {
    private HeadersType _headersType;
    private Enumerator _headersEnumerator;
    private Enumerator _trailersEnumerator;
    private IEnumerator`1<KeyValuePair`2<string, StringValues>> _genericEnumerator;
    private Enumerator _stringValuesEnumerator;
    private bool _hasMultipleValues;
    private KnownHeaderType _knownHeaderType;
    [CompilerGeneratedAttribute]
private Func`2<string, Encoding> <EncodingSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <Current>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> EncodingSelector { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, string> Current { get; private set; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    [CompilerGeneratedAttribute]
public Func`2<string, Encoding> get_EncodingSelector();
    [CompilerGeneratedAttribute]
public void set_EncodingSelector(Func`2<string, Encoding> value);
    public ValueTuple`2<int, bool> GetQPackStaticTableId();
    [CompilerGeneratedAttribute]
public sealed virtual KeyValuePair`2<string, string> get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(KeyValuePair`2<string, string> value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [NullableContextAttribute("1")]
public void Initialize(HttpResponseHeaders headers);
    [NullableContextAttribute("1")]
public void Initialize(HttpResponseTrailers headers);
    [NullableContextAttribute("1")]
public void Initialize(IDictionary`2<string, StringValues> headers);
    public sealed virtual bool MoveNext();
    private bool MoveNextOnStringEnumerator(string key);
    private bool SetCurrent(string name, StringValues value, KnownHeaderType knownHeaderType);
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3MessageBody : MessageBody {
    private Http3Stream _context;
    private ReadResult _readResult;
    [NullableContextAttribute("1")]
public Http3MessageBody(Http3Stream context);
    protected virtual void OnReadStarting();
    public virtual void Reset();
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual bool TryRead(ReadResult& readResult);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3MessageBody/<ReadAsync>d__7")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual void CancelPendingRead();
    protected virtual ValueTask OnStopAsync();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3OutputProducer : object {
    private Http3FrameWriter _frameWriter;
    private TimingPipeFlusher _flusher;
    private KestrelTrace _log;
    private MemoryPool`1<byte> _memoryPool;
    private Http3Stream _stream;
    private Pipe _pipe;
    private PipeWriter _pipeWriter;
    private PipeReader _pipeReader;
    private object _dataWriterLock;
    private ValueTask`1<FlushResult> _dataWriteProcessingTask;
    private bool _startedWritingDataFrames;
    private bool _streamCompleted;
    private bool _disposed;
    private bool _suffixSent;
    private IMemoryOwner`1<byte> _fakeMemoryOwner;
    private Byte[] _fakeMemory;
    [NullableContextAttribute("1")]
public Http3OutputProducer(Http3FrameWriter frameWriter, MemoryPool`1<byte> pool, Http3Stream stream, KestrelTrace log);
    public void StreamReset();
    public void Dispose();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.Abort(ConnectionAbortedException abortReason);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpOutputAborter.OnInputOrOutputCompleted();
    public sealed virtual void Advance(int bytes);
    public sealed virtual void CancelPendingFlush();
    public sealed virtual ValueTask`1<FlushResult> FirstWriteAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FirstWriteChunkedAsync(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal Memory`1<byte> GetFakeMemory(int minSize);
    [StackTraceHiddenAttribute]
private void ThrowIfSuffixSent();
    [StackTraceHiddenAttribute]
private static void ThrowSuffixSent();
    public sealed virtual void Reset();
    public sealed virtual void Stop();
    public sealed virtual ValueTask`1<FlushResult> Write100ContinueAsync();
    public sealed virtual ValueTask`1<FlushResult> WriteChunkAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual Task WriteDataAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<FlushResult> WriteDataToPipeAsync(ReadOnlySpan`1<byte> data, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual void WriteResponseHeaders(int statusCode, string reasonPhrase, HttpResponseHeaders responseHeaders, bool autoChunk, bool appCompleted);
    public sealed virtual ValueTask`1<FlushResult> WriteStreamSuffixAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3OutputProducer/<ProcessDataWrites>d__39")]
private ValueTask`1<FlushResult> ProcessDataWrites();
    private static Pipe CreateDataPipe(MemoryPool`1<byte> pool);
    [CompilerGeneratedAttribute]
internal static void <ProcessDataWrites>g__ThrowUnexpectedState|39_0();
}
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3PeerSetting : ValueType {
    [CompilerGeneratedAttribute]
private Http3SettingType <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public Http3SettingType Parameter { get; }
    public UInt32 Value { get; }
    public Http3PeerSetting(Http3SettingType parameter, UInt32 value);
    [CompilerGeneratedAttribute]
public Http3SettingType get_Parameter();
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3PeerSettings : object {
    public static UInt32 DefaultHeaderTableSize;
    public static UInt32 DefaultMaxRequestHeaderFieldSize;
    public static UInt32 DefaultEnableWebTransport;
    public static UInt32 DefaultH3Datagram;
    [CompilerGeneratedAttribute]
private UInt32 <HeaderTableSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxRequestHeaderFieldSectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EnableWebTransport>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <H3Datagram>k__BackingField;
    public UInt32 HeaderTableSize { get; internal set; }
    public UInt32 MaxRequestHeaderFieldSectionSize { get; internal set; }
    public UInt32 EnableWebTransport { get; internal set; }
    public UInt32 H3Datagram { get; internal set; }
    [CompilerGeneratedAttribute]
public UInt32 get_HeaderTableSize();
    [CompilerGeneratedAttribute]
internal void set_HeaderTableSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxRequestHeaderFieldSectionSize();
    [CompilerGeneratedAttribute]
internal void set_MaxRequestHeaderFieldSectionSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EnableWebTransport();
    [CompilerGeneratedAttribute]
internal void set_EnableWebTransport(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_H3Datagram();
    [CompilerGeneratedAttribute]
internal void set_H3Datagram(UInt32 value);
    [NullableContextAttribute("1")]
internal List`1<Http3PeerSetting> GetNonProtocolDefaults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3PendingStream : object {
    private ConnectionAbortedException _abortedException;
    private bool _isClosed;
    internal Http3StreamContext Context;
    internal long StreamId;
    internal long StreamTimeoutTimestamp;
    public Http3PendingStream(Http3StreamContext context, long id);
    public void Abort(ConnectionAbortedException exception);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3PendingStream/<ReadNextStreamHeaderAsync>d__7")]
public ValueTask`1<long> ReadNextStreamHeaderAsync(Http3StreamContext context, long streamId, Nullable`1<Http3StreamType> advanceOn);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3PendingStreamException : Exception {
    [CompilerGeneratedAttribute]
private long <StreamId>k__BackingField;
    public long StreamId { get; }
    [NullableContextAttribute("1")]
public Http3PendingStreamException(string message, long streamId, Exception innerException);
    [CompilerGeneratedAttribute]
public long get_StreamId();
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3SettingType : Enum {
    public long value__;
    public static Http3SettingType QPackMaxTableCapacity;
    public static Http3SettingType MaxFieldSectionSize;
    public static Http3SettingType QPackBlockedStreams;
    public static Http3SettingType EnableWebTransport;
    public static Http3SettingType H3Datagram;
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Stream : HttpProtocol {
    private static PseudoHeaderFields _mandatoryRequestPseudoHeaderFields;
    private Http3FrameWriter _frameWriter;
    private Http3OutputProducer _http3Output;
    private Http3StreamContext _context;
    private IProtocolErrorCodeFeature _errorCodeFeature;
    private IStreamIdFeature _streamIdFeature;
    private IStreamAbortFeature _streamAbortFeature;
    private IStreamClosedFeature _streamClosedFeature;
    private PseudoHeaderFields _parsedPseudoHeaderFields;
    private StreamCompletionFlags _completionState;
    private int _isClosed;
    private int _totalParsedHeaderSize;
    private bool _isMethodConnect;
    private bool _isWebTransportSessionAccepted;
    private Http3MessageBody _messageBody;
    private ManualResetValueTaskSource`1<object> _appCompletedTaskSource;
    private object _completionLock;
    protected RequestHeaderParsingState _requestHeaderParsingState;
    [NullableAttribute("1")]
protected Http3RawFrame _incomingFrame;
    [CompilerGeneratedAttribute]
private Pipe <RequestBodyPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <InputRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private QPackDecoder <QPackDecoder>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StreamTimeoutTimestamp>k__BackingField;
    private IHeaderDictionary _userTrailers;
    private static ReadOnlySpan`1<byte> AuthorityBytes { get; }
    private static ReadOnlySpan`1<byte> MethodBytes { get; }
    private static ReadOnlySpan`1<byte> PathBytes { get; }
    private static ReadOnlySpan`1<byte> ProtocolBytes { get; }
    private static ReadOnlySpan`1<byte> SchemeBytes { get; }
    private static ReadOnlySpan`1<byte> StatusBytes { get; }
    private static ReadOnlySpan`1<byte> ConnectionBytes { get; }
    private static ReadOnlySpan`1<byte> TeBytes { get; }
    private static ReadOnlySpan`1<byte> TrailersBytes { get; }
    private static ReadOnlySpan`1<byte> ConnectBytes { get; }
    public bool EndStreamReceived { get; }
    public bool IsAborted { get; }
    private bool IsAbortedRead { get; }
    public bool IsCompleted { get; }
    [NullableAttribute("1")]
public Pipe RequestBodyPipe { get; private set; }
    public Nullable`1<long> InputRemaining { get; internal set; }
    [NullableAttribute("1")]
public QPackDecoder QPackDecoder { get; private set; }
    [NullableAttribute("1")]
public PipeReader Input { get; }
    [NullableAttribute("1")]
public KestrelServerLimits Limits { get; }
    public long StreamId { get; }
    public long StreamTimeoutTimestamp { get; public set; }
    public bool IsReceivingHeader { get; }
    public bool IsDraining { get; }
    public bool IsRequestStream { get; }
    [NullableAttribute("1")]
public BaseConnectionContext ConnectionContext { get; }
    public ConnectionMetricsContext MetricsContext { get; }
    [NullableAttribute("1")]
private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.Trailers { get; private set; }
    [NullableAttribute("2")]
private MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.MinDataRate { get; private set; }
    private static ReadOnlySpan`1<byte> get_AuthorityBytes();
    private static ReadOnlySpan`1<byte> get_MethodBytes();
    private static ReadOnlySpan`1<byte> get_PathBytes();
    private static ReadOnlySpan`1<byte> get_ProtocolBytes();
    private static ReadOnlySpan`1<byte> get_SchemeBytes();
    private static ReadOnlySpan`1<byte> get_StatusBytes();
    private static ReadOnlySpan`1<byte> get_ConnectionBytes();
    private static ReadOnlySpan`1<byte> get_TeBytes();
    private static ReadOnlySpan`1<byte> get_TrailersBytes();
    private static ReadOnlySpan`1<byte> get_ConnectBytes();
    public sealed virtual bool get_EndStreamReceived();
    public sealed virtual bool get_IsAborted();
    private bool get_IsAbortedRead();
    public sealed virtual bool get_IsCompleted();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Pipe get_RequestBodyPipe();
    [CompilerGeneratedAttribute]
private void set_RequestBodyPipe(Pipe value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_InputRemaining();
    [CompilerGeneratedAttribute]
internal void set_InputRemaining(Nullable`1<long> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public QPackDecoder get_QPackDecoder();
    [CompilerGeneratedAttribute]
private void set_QPackDecoder(QPackDecoder value);
    [NullableContextAttribute("1")]
public PipeReader get_Input();
    [NullableContextAttribute("1")]
public KestrelServerLimits get_Limits();
    public sealed virtual long get_StreamId();
    [CompilerGeneratedAttribute]
public sealed virtual long get_StreamTimeoutTimestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StreamTimeoutTimestamp(long value);
    public sealed virtual bool get_IsReceivingHeader();
    public sealed virtual bool get_IsDraining();
    public sealed virtual bool get_IsRequestStream();
    [NullableContextAttribute("1")]
public BaseConnectionContext get_ConnectionContext();
    public ConnectionMetricsContext get_MetricsContext();
    [NullableContextAttribute("1")]
public void Initialize(Http3StreamContext context);
    [NullableContextAttribute("1")]
public void InitializeWithExistingContext(IDuplexPipe transport);
    [NullableContextAttribute("1")]
public sealed virtual void Abort(ConnectionAbortedException abortReason, Http3ErrorCode errorCode);
    private void AbortCore(Exception exception, Http3ErrorCode errorCode);
    protected virtual void OnErrorAfterResponseStarted();
    public sealed virtual void OnHeadersComplete(bool endStream);
    public sealed virtual void OnStaticIndexedHeader(int index);
    public sealed virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    public sealed virtual void OnDynamicIndexedHeader(Nullable`1<int> index, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public sealed virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public virtual void OnHeader(int index, bool indexOnly, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void AppendHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void OnHeaderCore(HeaderType headerType, Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void ValidateHeaderContent(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void UpdateHeaderParsingState(ReadOnlySpan`1<byte> value, PseudoHeaderFields headerField);
    private static PseudoHeaderFields GetPseudoHeaderField(int staticTableIndex);
    private static PseudoHeaderFields GetPseudoHeaderField(ReadOnlySpan`1<byte> name);
    private static bool IsConnectionSpecificHeaderField(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    protected virtual void OnRequestProcessingEnded();
    private void CompleteStream(bool errored);
    private bool TryClose();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Stream/<ProcessRequestAsync>d__101`1")]
public Task ProcessRequestAsync(IHttpApplication`1<TContext> application);
    private ValueTask OnEndStreamReceived();
    private Task ProcessHttp3Stream(IHttpApplication`1<TContext> application, ReadOnlySequence`1& payload, bool isCompleted);
    private static Task ProcessUnknownFrameAsync();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Stream/<ProcessHeadersFrameAsync>d__105`1")]
private Task ProcessHeadersFrameAsync(IHttpApplication`1<TContext> application, ReadOnlySequence`1<byte> payload, bool isCompleted);
    private Task ProcessDataFrameAsync(ReadOnlySequence`1& payload);
    protected virtual void OnReset();
    protected virtual void ApplicationAbort();
    private void ApplicationAbort(ConnectionAbortedException abortReason, Http3ErrorCode error);
    [NullableContextAttribute("1")]
protected virtual string CreateRequestId();
    [NullableContextAttribute("1")]
protected virtual MessageBody CreateMessageBody();
    protected virtual bool TryParseRequest(ReadResult result, Boolean& endConnection);
    private bool TryValidatePseudoHeaders();
    private bool TryValidateMethod();
    private bool TryValidateAuthorityAndHost(String& hostText);
    [SkipLocalsInitAttribute]
private bool TryValidatePath(ReadOnlySpan`1<char> pathSegment);
    private Pipe CreateRequestBodyPipe(UInt32 windowSize);
    private ValueTuple`2<StreamCompletionFlags, StreamCompletionFlags> ApplyCompletionFlag(StreamCompletionFlags completionState);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Stream/<AcceptAsync>d__119")]
public virtual ValueTask`1<IWebTransportSession> AcceptAsync(CancellationToken token);
    public abstract virtual void Execute();
    public void Abort();
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.get_Trailers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseTrailersFeature.set_Trailers(IHeaderDictionary value);
    private sealed virtual override MinDataRate Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate();
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(MinDataRate value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResetFeature.Reset(int errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3Stream`1 : Http3Stream {
    private IHttpApplication`1<TContext> _application;
    [CompilerGeneratedAttribute]
private TContext <Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext>k__BackingField;
    [NullableAttribute("2")]
private TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.HostContext { get; private set; }
    public Http3Stream`1(IHttpApplication`1<TContext> application, Http3StreamContext context);
    public virtual void Execute();
    [CompilerGeneratedAttribute]
private sealed virtual override TContext Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.get_HostContext();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Hosting.Server.Abstractions.IHostContextContainer<TContext>.set_HostContext(TContext value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3StreamContext : HttpConnectionContext {
    [CompilerGeneratedAttribute]
private IHttp3StreamLifetimeHandler <StreamLifetimeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionContext <StreamContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3PeerSettings <ClientPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3PeerSettings <ServerPeerSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private WebTransportSession <WebTransportSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3Connection <Connection>k__BackingField;
    public IHttp3StreamLifetimeHandler StreamLifetimeHandler { get; }
    public ConnectionContext StreamContext { get; }
    public Http3PeerSettings ClientPeerSettings { get; }
    public Http3PeerSettings ServerPeerSettings { get; }
    [NullableAttribute("2")]
public WebTransportSession WebTransportSession { get; public set; }
    public Http3Connection Connection { get; }
    public Http3StreamContext(string connectionId, HttpProtocols protocols, AltSvcHeader altSvcHeader, BaseConnectionContext connectionContext, ServiceContext serviceContext, IFeatureCollection connectionFeatures, MemoryPool`1<byte> memoryPool, IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, ConnectionContext streamContext, Http3Connection connection);
    [CompilerGeneratedAttribute]
public IHttp3StreamLifetimeHandler get_StreamLifetimeHandler();
    [CompilerGeneratedAttribute]
public ConnectionContext get_StreamContext();
    [CompilerGeneratedAttribute]
public Http3PeerSettings get_ClientPeerSettings();
    [CompilerGeneratedAttribute]
public Http3PeerSettings get_ServerPeerSettings();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public WebTransportSession get_WebTransportSession();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_WebTransportSession(WebTransportSession value);
    [CompilerGeneratedAttribute]
public Http3Connection get_Connection();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.Http3StreamErrorException : Exception {
    [CompilerGeneratedAttribute]
private Http3ErrorCode <ErrorCode>k__BackingField;
    public Http3ErrorCode ErrorCode { get; }
    [NullableContextAttribute("1")]
public Http3StreamErrorException(string message, Http3ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public Http3ErrorCode get_ErrorCode();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3Stream {
    public long StreamId { get; }
    public long StreamTimeoutTimestamp { get; public set; }
    public bool IsReceivingHeader { get; }
    public bool IsDraining { get; }
    public bool IsRequestStream { get; }
    public bool EndStreamReceived { get; }
    public bool IsAborted { get; }
    public bool IsCompleted { get; }
    public string TraceIdentifier { get; }
    public abstract virtual long get_StreamId();
    public abstract virtual long get_StreamTimeoutTimestamp();
    public abstract virtual void set_StreamTimeoutTimestamp(long value);
    public abstract virtual bool get_IsReceivingHeader();
    public abstract virtual bool get_IsDraining();
    public abstract virtual bool get_IsRequestStream();
    public abstract virtual bool get_EndStreamReceived();
    public abstract virtual bool get_IsAborted();
    public abstract virtual bool get_IsCompleted();
    public abstract virtual string get_TraceIdentifier();
    public abstract virtual void Abort(ConnectionAbortedException abortReason, Http3ErrorCode errorCode);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.IHttp3StreamLifetimeHandler {
    public abstract virtual void OnUnidentifiedStreamReceived(Http3PendingStream stream);
    public abstract virtual void OnStreamCreated(IHttp3Stream stream);
    public abstract virtual void OnStreamHeaderReceived(IHttp3Stream stream);
    public abstract virtual void OnStreamCompleted(IHttp3Stream stream);
    public abstract virtual void OnStreamConnectionError(Http3ConnectionErrorException ex);
    public abstract virtual bool OnInboundControlStream(Http3ControlStream stream);
    public abstract virtual bool OnInboundEncoderStream(Http3ControlStream stream);
    public abstract virtual bool OnInboundDecoderStream(Http3ControlStream stream);
    public abstract virtual void OnInboundControlStreamSetting(Http3SettingType type, long value);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.QPack.DecoderStreamReader : object {
    private static byte HeaderAcknowledgementMask;
    private static byte HeaderAcknowledgementRepresentation;
    private static byte HeaderAcknowledgementPrefixMask;
    private static int HeaderAcknowledgementPrefix;
    private static byte StreamCancellationMask;
    private static byte StreamCancellationRepresentation;
    private static byte StreamCancellationPrefixMask;
    private static int StreamCancellationPrefix;
    private static byte InsertCountIncrementMask;
    private static byte InsertCountIncrementRepresentation;
    private static byte InsertCountIncrementPrefixMask;
    private static int InsertCountIncrementPrefix;
    private IntegerDecoder _integerDecoder;
    private State _state;
    public void Read(ReadOnlySequence`1<byte> data);
    private void OnByte(byte b);
    private void OnInsertCountIncrement(int intResult);
    private void OnStreamCancellation(int streamId);
    private void OnHeaderAcknowledgement(int intResult);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.QPack.DynamicTable : object {
    public HeaderField Item { get; }
    public DynamicTable(int maxSize);
    public HeaderField get_Item(int index);
    public static void Insert(Span`1<byte> name, Span`1<byte> value);
    public static void Resize(int maxSize);
    internal void Duplicate(int index);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.QPack.EncoderStreamReader : object {
    private static byte DynamicTableCapacityMask;
    private static byte DynamicTableCapacityRepresentation;
    private static byte DynamicTableCapacityPrefixMask;
    private static int DynamicTableCapacityPrefix;
    private static byte InsertWithNameReferenceMask;
    private static byte InsertWithNameReferenceRepresentation;
    private static byte InsertWithNameReferencePrefixMask;
    private static byte InsertWithNameReferenceStaticMask;
    private static int InsertWithNameReferencePrefix;
    private static byte InsertWithoutNameReferenceMask;
    private static byte InsertWithoutNameReferenceRepresentation;
    private static byte InsertWithoutNameReferencePrefixMask;
    private static byte InsertWithoutNameReferenceHuffmanMask;
    private static int InsertWithoutNameReferencePrefix;
    private static byte DuplicateMask;
    private static byte DuplicateRepresentation;
    private static byte DuplicatePrefixMask;
    private static int DuplicatePrefix;
    private static int StringLengthPrefix;
    private static byte HuffmanMask;
    private bool _s;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    private Byte[] _headerName;
    private int _headerNameLength;
    private int _headerValueLength;
    private int _stringLength;
    private int _stringIndex;
    private DynamicTable _dynamicTable;
    private IntegerDecoder _integerDecoder;
    private State _state;
    private bool _huffman;
    public EncoderStreamReader(int maxRequestHeaderFieldSize);
    public void Read(ReadOnlySequence`1<byte> data);
    private void OnByte(byte b);
    private void OnStringLength(int length, State nextState);
    private void ProcessValue();
    private void OnString(State nextState);
    private void OnNameIndex(int index);
    private void OnDynamicTableCapacity(int dynamicTableSize);
    private void OnDuplicate(int index);
    private HeaderField GetHeader(int index);
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|39_0(Byte[] dst);
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.QPackHeaderWriter : object {
    public static bool BeginEncodeHeaders(Http3HeadersEnumerator enumerator, Span`1<byte> buffer, Int32& totalHeaderSize, Int32& length);
    public static bool BeginEncodeHeaders(int statusCode, Http3HeadersEnumerator headersEnumerator, Span`1<byte> buffer, Int32& totalHeaderSize, Int32& length);
    public static bool Encode(Http3HeadersEnumerator headersEnumerator, Span`1<byte> buffer, Int32& totalHeaderSize, Int32& length);
    private static bool Encode(Http3HeadersEnumerator headersEnumerator, Span`1<byte> buffer, bool throwIfNoneEncoded, Int32& totalHeaderSize, Int32& length);
    private static bool EncodeHeader(Span`1<byte> buffer, int staticTableId, string name, string value, Encoding valueEncoding, Int32& headerLength);
    private static int EncodeStatusCode(int statusCode, Span`1<byte> buffer);
}
[FlagsAttribute]
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http3.StreamCompletionFlags : Enum {
    public int value__;
    public static StreamCompletionFlags None;
    public static StreamCompletionFlags EndStreamReceived;
    public static StreamCompletionFlags AbortedRead;
    public static StreamCompletionFlags Aborted;
    public static StreamCompletionFlags Completed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnection : object {
    private BaseHttpConnectionContext _context;
    private TimeProvider _timeProvider;
    private TimeoutControl _timeoutControl;
    private object _protocolSelectionLock;
    private ProtocolSelectionState _protocolSelectionState;
    private Http1Connection _http1Connection;
    [NullableAttribute("2")]
internal IRequestProcessor _requestProcessor;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> Http2Id { get; }
    private KestrelTrace Log { get; }
    public HttpConnection(BaseHttpConnectionContext context);
    private static ReadOnlySpan`1<byte> get_Http2Id();
    private KestrelTrace get_Log();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnection/<ProcessRequestsAsync>d__12`1")]
public Task ProcessRequestsAsync(IHttpApplication`1<TContext> httpApplication);
    private void AddMetricsHttpProtocolTag(string httpVersion);
    internal void Initialize(IRequestProcessor requestProcessor);
    private void StopProcessingNextRequest();
    private void OnConnectionClosed();
    private void Abort(ConnectionAbortedException ex);
    private HttpProtocols SelectProtocol();
    private void Tick();
    public sealed virtual void OnTimeout(TimeoutReason reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionBuilderExtensions : object {
    [ExtensionAttribute]
public static IConnectionBuilder UseHttpServer(IConnectionBuilder builder, ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols, bool addAltSvcHeader);
    [ExtensionAttribute]
public static IMultiplexedConnectionBuilder UseHttp3Server(IMultiplexedConnectionBuilder builder, ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols, bool addAltSvcHeader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionContext : BaseHttpConnectionContext {
    [CompilerGeneratedAttribute]
private IDuplexPipe <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionMetricsContext <MetricsContext>k__BackingField;
    public IDuplexPipe Transport { get; public set; }
    public ConnectionMetricsContext MetricsContext { get; }
    public HttpConnectionContext(string connectionId, HttpProtocols protocols, AltSvcHeader altSvcHeader, BaseConnectionContext connectionContext, ServiceContext serviceContext, IFeatureCollection connectionFeatures, MemoryPool`1<byte> memoryPool, IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, ConnectionMetricsContext metricsContext);
    [CompilerGeneratedAttribute]
public IDuplexPipe get_Transport();
    [CompilerGeneratedAttribute]
public void set_Transport(IDuplexPipe value);
    [CompilerGeneratedAttribute]
public ConnectionMetricsContext get_MetricsContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpConnectionMiddleware`1 : object {
    private ServiceContext _serviceContext;
    private IHttpApplication`1<TContext> _application;
    private HttpProtocols _endpointDefaultProtocols;
    private bool _addAltSvcHeader;
    public HttpConnectionMiddleware`1(ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols, bool addAltSvcHeader);
    public Task OnConnectionAsync(ConnectionContext connectionContext);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpMultiplexedConnectionContext : BaseHttpConnectionContext {
    [NullableContextAttribute("1")]
public HttpMultiplexedConnectionContext(string connectionId, HttpProtocols protocols, AltSvcHeader altSvcHeader, MultiplexedConnectionContext connectionContext, ServiceContext serviceContext, IFeatureCollection connectionFeatures, MemoryPool`1<byte> memoryPool, IPEndPoint localEndPoint, IPEndPoint remoteEndPoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpMultiplexedConnectionMiddleware`1 : object {
    private ServiceContext _serviceContext;
    private IHttpApplication`1<TContext> _application;
    private HttpProtocols _protocols;
    private bool _addAltSvcHeader;
    public HttpMultiplexedConnectionMiddleware`1(ServiceContext serviceContext, IHttpApplication`1<TContext> application, HttpProtocols protocols, bool addAltSvcHeader);
    public Task OnConnectionAsync(MultiplexedConnectionContext connectionContext);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.HttpProtocolsFeature : object {
    [CompilerGeneratedAttribute]
private HttpProtocols <HttpProtocols>k__BackingField;
    public HttpProtocols HttpProtocols { get; }
    public HttpProtocolsFeature(HttpProtocols httpProtocols);
    [CompilerGeneratedAttribute]
public HttpProtocols get_HttpProtocols();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.AltSvcHeader : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RawBytes>k__BackingField;
    public string Value { get; }
    public Byte[] RawBytes { get; }
    public AltSvcHeader(string value, Byte[] rawBytes);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Byte[] get_RawBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.BodyControl : object {
    private static ThrowingWasUpgradedWriteOnlyStream _throwingResponseStream;
    private static ThrowingPipeWriter _throwingUpgradedPipeWriter;
    private HttpResponseStream _response;
    private HttpResponsePipeWriter _responseWriter;
    private HttpRequestPipeReader _requestReader;
    private HttpRequestStream _request;
    private HttpRequestPipeReader _emptyRequestReader;
    private WrappingStream _upgradeableResponse;
    private WrappingPipeWriter _upgradeablePipeWriter;
    private StatusCheckPipeWriter _connectPipeWriter;
    private StatusCheckWriteStream _connectResponse;
    private HttpRequestStream _emptyRequest;
    private Stream _upgradeStream;
    [CompilerGeneratedAttribute]
private bool <CanHaveBody>k__BackingField;
    public bool CanHaveBody { get; private set; }
    public BodyControl(IHttpBodyControlFeature bodyControl, IHttpResponseControl responseControl);
    private static BodyControl();
    [CompilerGeneratedAttribute]
public bool get_CanHaveBody();
    [CompilerGeneratedAttribute]
private void set_CanHaveBody(bool value);
    public Stream Upgrade();
    public Stream AcceptConnect();
    public ValueTuple`4<Stream, Stream, PipeReader, PipeWriter> Start(MessageBody body);
    public Task StopAsync();
    public void Abort(Exception error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionManager : object {
    private Action`1<KestrelConnection> _walkCallback;
    private long _lastConnectionId;
    private ConcurrentDictionary`2<long, ConnectionReference> _connectionReferences;
    private KestrelTrace _trace;
    [CompilerGeneratedAttribute]
private ResourceCounter <UpgradedConnectionCount>k__BackingField;
    public ResourceCounter UpgradedConnectionCount { get; }
    public ConnectionManager(KestrelTrace trace, Nullable`1<long> upgradedConnectionLimit);
    public ConnectionManager(KestrelTrace trace, ResourceCounter upgradedConnections);
    public long GetNewConnectionId();
    [CompilerGeneratedAttribute]
public ResourceCounter get_UpgradedConnectionCount();
    public sealed virtual void OnHeartbeat();
    private void WalkCallback(KestrelConnection connection);
    public void AddConnection(long id, ConnectionReference connectionReference);
    public void RemoveConnection(long id);
    public void Walk(Action`1<KestrelConnection> callback);
    private static ResourceCounter GetCounter(Nullable`1<long> number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionMetricsContext : ValueType {
    [CompilerGeneratedAttribute]
private BaseConnectionContext <ConnectionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentConnectionsCounterEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConnectionDurationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QueuedConnectionsCounterEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QueuedRequestsCounterEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentUpgradedRequestsCounterEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentTlsHandshakesCounterEnabled>k__BackingField;
    public BaseConnectionContext ConnectionContext { get; }
    public bool CurrentConnectionsCounterEnabled { get; }
    public bool ConnectionDurationEnabled { get; }
    public bool QueuedConnectionsCounterEnabled { get; }
    public bool QueuedRequestsCounterEnabled { get; }
    public bool CurrentUpgradedRequestsCounterEnabled { get; }
    public bool CurrentTlsHandshakesCounterEnabled { get; }
    public ConnectionMetricsContext(BaseConnectionContext connectionContext, bool currentConnectionsCounterEnabled, bool connectionDurationEnabled, bool queuedConnectionsCounterEnabled, bool queuedRequestsCounterEnabled, bool currentUpgradedRequestsCounterEnabled, bool currentTlsHandshakesCounterEnabled);
    [CompilerGeneratedAttribute]
public BaseConnectionContext get_ConnectionContext();
    [CompilerGeneratedAttribute]
public bool get_CurrentConnectionsCounterEnabled();
    [CompilerGeneratedAttribute]
public bool get_ConnectionDurationEnabled();
    [CompilerGeneratedAttribute]
public bool get_QueuedConnectionsCounterEnabled();
    [CompilerGeneratedAttribute]
public bool get_QueuedRequestsCounterEnabled();
    [CompilerGeneratedAttribute]
public bool get_CurrentUpgradedRequestsCounterEnabled();
    [CompilerGeneratedAttribute]
public bool get_CurrentTlsHandshakesCounterEnabled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ConnectionReference : object {
    private long _id;
    private WeakReference`1<KestrelConnection> _weakReference;
    private TransportConnectionManager _transportConnectionManager;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    public string ConnectionId { get; }
    public ConnectionReference(long id, KestrelConnection connection, TransportConnectionManager transportConnectionManager);
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [NullableContextAttribute("2")]
public bool TryGetConnection(KestrelConnection& connection);
    public void StopTrasnsportTracking();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Constants : object {
    public static int MaxExceptionDetailSize;
    public static string DefaultServerAddress;
    public static string UnixPipeHostPrefix;
    public static string PipeDescriptorPrefix;
    public static string SocketDescriptorPrefix;
    public static string ServerName;
    public static TimeSpan RequestBodyDrainTimeout;
    private static Constants();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.DebuggerWrapper : object {
    [CompilerGeneratedAttribute]
private static IDebugger <Singleton>k__BackingField;
    [NullableAttribute("1")]
public static IDebugger Singleton { get; }
    public bool IsAttached { get; }
    private static DebuggerWrapper();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static IDebugger get_Singleton();
    public sealed virtual bool get_IsAttached();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Disposable : object {
    private Action _dispose;
    private bool _disposedValue;
    [NullableContextAttribute("1")]
public Disposable(Action dispose);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.Heartbeat : object {
    public static TimeSpan Interval;
    private IHeartbeatHandler[] _callbacks;
    private TimeProvider _timeProvider;
    private IDebugger _debugger;
    private KestrelTrace _trace;
    private TimeSpan _interval;
    private Thread _timerThread;
    private ManualResetEventSlim _stopEvent;
    [NullableContextAttribute("1")]
public Heartbeat(IHeartbeatHandler[] callbacks, TimeProvider timeProvider, IDebugger debugger, KestrelTrace trace, TimeSpan interval);
    private static Heartbeat();
    public void Start();
    internal void OnHeartbeat();
    private void TimerLoop();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.HttpUtilities : object {
    [NullableAttribute("1")]
public static string HttpUriScheme;
    [NullableAttribute("1")]
public static string HttpsUriScheme;
    private static ulong _httpSchemeLong;
    private static ulong _httpsSchemeLong;
    private static UInt32 _httpGetMethodInt;
    private static ulong _http10VersionLong;
    private static ulong _http11VersionLong;
    private static UTF8Encoding DefaultRequestHeaderEncoding;
    private static SpanAction`2<char, IntPtr> s_getHeaderName;
    private static String[] WordListForPerfectHashOfMethods;
    private static ulong _httpConnectMethodLong;
    private static ulong _httpDeleteMethodLong;
    private static ulong _httpHeadMethodLong;
    private static ulong _httpPatchMethodLong;
    private static ulong _httpPostMethodLong;
    private static ulong _httpPutMethodLong;
    private static ulong _httpOptionsMethodLong;
    private static ulong _httpTraceMethodLong;
    private static ulong _mask8Chars;
    private static ulong _mask7Chars;
    private static ulong _mask6Chars;
    private static ulong _mask5Chars;
    private static ulong _mask4Chars;
    private static Tuple`4[] _knownMethods;
    private static String[] _methodNames;
    private static HttpUtilities();
    private static void SetKnownMethod(ulong mask, ulong knownMethodUlong, HttpMethod knownMethod, int length);
    private static void FillKnownMethodsGaps();
    private static ulong GetAsciiStringAsLong(string str);
    private static UInt32 GetAsciiStringAsInt(string str);
    private static ulong GetMaskAsLong(Byte[] bytes);
    [ExtensionAttribute]
public static string GetHeaderName(ReadOnlySpan`1<byte> span);
    private static void GetHeaderName(Span`1<char> buffer, IntPtr state);
    [ExtensionAttribute]
public static string GetAsciiStringNonNullCharacters(Span`1<byte> span);
    [ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(ReadOnlySpan`1<byte> span);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetRequestHeaderString(ReadOnlySpan`1<byte> span, string name, Func`2<string, Encoding> encodingSelector, bool checkForNewlineChars);
    [ExtensionAttribute]
private static string GetRequestHeaderStringWithoutDefaultEncodingCore(ReadOnlySpan`1<byte> span, string name, Func`2<string, Encoding> encodingSelector);
    [ExtensionAttribute]
public static string GetAsciiStringEscaped(ReadOnlySpan`1<byte> span, int maxChars);
    [ExtensionAttribute]
public static bool GetKnownMethod(ReadOnlySpan`1<byte> span, HttpMethod& method, Int32& length);
    [ExtensionAttribute]
public static HttpMethod GetKnownMethod(ReadOnlySpan`1<byte> span, Int32& methodLength);
    [NullableContextAttribute("2")]
public static HttpMethod GetKnownMethod(string value);
    [ExtensionAttribute]
public static bool GetKnownVersion(ReadOnlySpan`1<byte> span, HttpVersion& knownVersion, Byte& length);
    [ExtensionAttribute]
internal static HttpVersion GetKnownVersion(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static bool GetKnownHttpScheme(Span`1<byte> span, HttpScheme& knownScheme);
    [NullableContextAttribute("1")]
public static string VersionToString(HttpVersion httpVersion);
    [NullableContextAttribute("2")]
public static string MethodToString(HttpMethod method);
    [NullableContextAttribute("2")]
public static string SchemeToString(HttpScheme scheme);
    [NullableContextAttribute("1")]
public static bool IsHostHeaderValid(string hostText);
    private static bool IsIPv6HostValid(string hostText);
    private static bool IsHostPortValid(string hostText, int offset);
    private static bool IsNumeric(char ch);
    private static bool IsHex(char ch);
    [NullableContextAttribute("1")]
public static AltSvcHeader GetEndpointAltSvc(IPEndPoint endpoint, HttpProtocols protocols);
    private static int GetKnownMethodIndex(ulong value);
    [CompilerGeneratedAttribute]
internal static UInt32 <GetKnownMethod>g__PerfectHash|23_0(ReadOnlySpan`1<char> str);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<byte> <GetKnownMethod>g__Methods|23_1();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IConnectionListener`1 {
    public abstract virtual ValueTask`1<T> AcceptAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IConnectionListenerBase {
    public EndPoint EndPoint { get; }
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual ValueTask UnbindAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IConnectionMetricsContextFeature {
    public ConnectionMetricsContext MetricsContext { get; }
    public abstract virtual ConnectionMetricsContext get_MetricsContext();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IDebugger {
    public bool IsAttached { get; }
    public abstract virtual bool get_IsAttached();
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.IHeartbeatHandler {
    public abstract virtual void OnHeartbeat();
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ITimeoutControl {
    public TimeoutReason TimerReason { get; }
    public abstract virtual TimeoutReason get_TimerReason();
    public abstract virtual void SetTimeout(TimeSpan timeout, TimeoutReason timeoutReason);
    public abstract virtual void ResetTimeout(TimeSpan timeout, TimeoutReason timeoutReason);
    public abstract virtual void CancelTimeout();
    public abstract virtual void InitializeHttp2(InputFlowControl connectionInputFlowControl);
    public abstract virtual void Tick(long timestamp);
    public abstract virtual void StartRequestBody(MinDataRate minRate);
    public abstract virtual void StopRequestBody();
    public abstract virtual void StartTimingRead();
    public abstract virtual void StopTimingRead();
    public abstract virtual void BytesRead(long count);
    public abstract virtual void StartTimingWrite();
    public abstract virtual void StopTimingWrite();
    public abstract virtual void BytesWrittenToBuffer(MinDataRate minRate, long count);
    public abstract virtual long GetResponseDrainDeadline(long timestamp, MinDataRate minRate);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ITimeoutHandler {
    public abstract virtual void OnTimeout(TimeoutReason reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Action`1<object>, object>> _heartbeatHandlers;
    private object _heartbeatLock;
    private Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onCompleted;
    private bool _completed;
    private CancellationTokenSource _connectionClosingCts;
    private TaskCompletionSource _completionTcs;
    protected long _id;
    protected ServiceContext _serviceContext;
    protected TransportConnectionManager _transportConnectionManager;
    [CompilerGeneratedAttribute]
private KestrelTrace <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionMetricsContext <MetricsContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectionClosedRequested>k__BackingField;
    protected KestrelTrace Logger { get; }
    public ConnectionMetricsContext MetricsContext { get; public set; }
    public CancellationToken ConnectionClosedRequested { get; public set; }
    public Task ExecutionTask { get; }
    public BaseConnectionContext TransportConnection { get; }
    public KestrelConnection(long id, ServiceContext serviceContext, TransportConnectionManager transportConnectionManager, KestrelTrace logger, ConnectionMetricsContext connectionMetricsContext);
    [CompilerGeneratedAttribute]
protected KestrelTrace get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual ConnectionMetricsContext get_MetricsContext();
    [CompilerGeneratedAttribute]
public void set_MetricsContext(ConnectionMetricsContext value);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_ConnectionClosedRequested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConnectionClosedRequested(CancellationToken value);
    public Task get_ExecutionTask();
    public void TickHeartbeat();
    public abstract virtual BaseConnectionContext get_TransportConnection();
    public sealed virtual void OnHeartbeat(Action`1<object> action, object state);
    private sealed virtual override void Microsoft.AspNetCore.Connections.Features.IConnectionCompleteFeature.OnCompleted(Func`2<object, Task> callback, object state);
    public Task FireOnCompletedAsync();
    private Task CompleteAsyncMayAwait(Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection/<CompleteAsyncAwaited>d__30")]
private Task CompleteAsyncAwaited(Task currentTask, Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> onCompleted);
    public sealed virtual void RequestClose();
    public void Complete();
    protected IDisposable BeginConnectionScope(BaseConnectionContext connectionContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection`1 : KestrelConnection {
    private Func`2<T, Task> _connectionDelegate;
    private T _transportConnection;
    private KestrelMetrics Metrics { get; }
    public BaseConnectionContext TransportConnection { get; }
    public KestrelConnection`1(long id, ServiceContext serviceContext, TransportConnectionManager transportConnectionManager, Func`2<T, Task> connectionDelegate, T connectionContext, KestrelTrace logger, ConnectionMetricsContext connectionMetricsContext);
    private KestrelMetrics get_Metrics();
    public virtual BaseConnectionContext get_TransportConnection();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection`1/<ExecuteAsync>d__8")]
internal Task ExecuteAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EventSourceAttribute]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelEventSource : EventSource {
    public static KestrelEventSource Log;
    private IncrementingPollingCounter _connectionsPerSecondCounter;
    private IncrementingPollingCounter _tlsHandshakesPerSecondCounter;
    private PollingCounter _totalConnectionsCounter;
    private PollingCounter _currentConnectionsCounter;
    private PollingCounter _totalTlsHandshakesCounter;
    private PollingCounter _currentTlsHandshakesCounter;
    private PollingCounter _failedTlsHandshakesCounter;
    private PollingCounter _connectionQueueLengthCounter;
    private PollingCounter _httpRequestQueueLengthCounter;
    private PollingCounter _currrentUpgradedHttpRequestsCounter;
    private long _totalConnections;
    private long _currentConnections;
    private long _connectionQueueLength;
    private long _totalTlsHandshakes;
    private long _currentTlsHandshakes;
    private long _failedTlsHandshakes;
    private long _httpRequestQueueLength;
    private long _currentUpgradedHttpRequests;
    private List`1<WeakReference`1<KestrelServerOptions>> _options;
    private static KestrelEventSource();
    [NonEventAttribute]
public void ConnectionStart(BaseConnectionContext connection);
    [EventAttribute("1")]
private void ConnectionStart(string connectionId, string localEndPoint, string remoteEndPoint);
    [NonEventAttribute]
public void ConnectionStop(BaseConnectionContext connection);
    [EventAttribute("2")]
private void ConnectionStop(string connectionId);
    [NonEventAttribute]
public void RequestStart(HttpProtocol httpProtocol);
    [EventAttribute("3")]
private void RequestStart(string connectionId, string requestId, string httpVersion, string path, string method);
    [NonEventAttribute]
public void RequestStop(HttpProtocol httpProtocol);
    [EventAttribute("4")]
private void RequestStop(string connectionId, string requestId, string httpVersion, string path, string method);
    [EventAttribute("5")]
public void ConnectionRejected(string connectionId);
    [NonEventAttribute]
public void ConnectionQueuedStart(BaseConnectionContext connection);
    [NonEventAttribute]
public void ConnectionQueuedStop(BaseConnectionContext connection);
    [NonEventAttribute]
public void TlsHandshakeStart(BaseConnectionContext connectionContext, SslServerAuthenticationOptions sslOptions);
    [EventAttribute("8")]
private void TlsHandshakeStart(string connectionId, string sslProtocols);
    [NonEventAttribute]
public void TlsHandshakeStop(BaseConnectionContext connectionContext, TlsConnectionFeature feature);
    [EventAttribute("9")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private void TlsHandshakeStop(string connectionId, string sslProtocols, string applicationProtocol, string hostName);
    [EventAttribute("10")]
public void TlsHandshakeFailed(string connectionId);
    [EventAttribute("11")]
public void Configuration(int instanceId, string configuration);
    [NonEventAttribute]
public void Configuration(KestrelServerOptions options);
    [NonEventAttribute]
public void AddServerOptions(KestrelServerOptions options);
    [NonEventAttribute]
public void RemoveServerOptions(KestrelServerOptions options);
    [NonEventAttribute]
public void RequestQueuedStart(HttpProtocol httpProtocol, string httpVersion);
    [NonEventAttribute]
public void RequestQueuedStop(HttpProtocol httpProtocol, string httpVersion);
    [NonEventAttribute]
public void RequestUpgradedStart(HttpProtocol httpProtocol);
    [NonEventAttribute]
public void RequestUpgradedStop(HttpProtocol httpProtocol);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [NonEventAttribute]
[SkipLocalsInitAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5);
    [CompilerGeneratedAttribute]
[NonEventAttribute]
private void <RequestStart>g__Core|25_0(HttpProtocol httpProtocol);
    [CompilerGeneratedAttribute]
[NonEventAttribute]
private void <RequestStop>g__Core|27_0(HttpProtocol httpProtocol);
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_0();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_1();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_2();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_3();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_4();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_5();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_6();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_7();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_8();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__45_9();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelMetrics : object {
    public static string MeterName;
    public static string Http11;
    public static string Http2;
    public static string Http3;
    private Meter _meter;
    private UpDownCounter`1<long> _activeConnectionsCounter;
    private Histogram`1<double> _connectionDuration;
    private Counter`1<long> _rejectedConnectionsCounter;
    private UpDownCounter`1<long> _queuedConnectionsCounter;
    private UpDownCounter`1<long> _queuedRequestsCounter;
    private UpDownCounter`1<long> _currentUpgradedRequestsCounter;
    private Histogram`1<double> _tlsHandshakeDuration;
    private UpDownCounter`1<long> _activeTlsHandshakesCounter;
    public KestrelMetrics(IMeterFactory meterFactory);
    public void ConnectionStart(ConnectionMetricsContext& metricsContext);
    private void ConnectionStartCore(ConnectionMetricsContext& metricsContext);
    [NullableContextAttribute("2")]
public void ConnectionStop(ConnectionMetricsContext& metricsContext, Exception exception, List`1<KeyValuePair`2<string, object>> customTags, long startTimestamp, long currentTimestamp);
    private void ConnectionStopCore(ConnectionMetricsContext& metricsContext, Exception exception, List`1<KeyValuePair`2<string, object>> customTags, long startTimestamp, long currentTimestamp);
    public void ConnectionRejected(ConnectionMetricsContext& metricsContext);
    private void ConnectionRejectedCore(ConnectionMetricsContext& metricsContext);
    public void ConnectionQueuedStart(ConnectionMetricsContext& metricsContext);
    private void ConnectionQueuedStartCore(ConnectionMetricsContext& metricsContext);
    public void ConnectionQueuedStop(ConnectionMetricsContext& metricsContext);
    private void ConnectionQueuedStopCore(ConnectionMetricsContext& metricsContext);
    public void RequestQueuedStart(ConnectionMetricsContext& metricsContext, string httpVersion);
    private void RequestQueuedStartCore(ConnectionMetricsContext& metricsContext, string httpVersion);
    public void RequestQueuedStop(ConnectionMetricsContext& metricsContext, string httpVersion);
    private void RequestQueuedStopCore(ConnectionMetricsContext& metricsContext, string httpVersion);
    public void RequestUpgradedStart(ConnectionMetricsContext& metricsContext);
    private void RequestUpgradedStartCore(ConnectionMetricsContext& metricsContext);
    public void RequestUpgradedStop(ConnectionMetricsContext& metricsContext);
    private void RequestUpgradedStopCore(ConnectionMetricsContext& metricsContext);
    public void TlsHandshakeStart(ConnectionMetricsContext& metricsContext);
    private void TlsHandshakeStartCore(ConnectionMetricsContext& metricsContext);
    [NullableContextAttribute("2")]
public void TlsHandshakeStop(ConnectionMetricsContext& metricsContext, long startTimestamp, long currentTimestamp, Nullable`1<SslProtocols> protocol, Exception exception);
    private void TlsHandshakeStopCore(ConnectionMetricsContext& metricsContext, long startTimestamp, long currentTimestamp, Nullable`1<SslProtocols> protocol, Exception exception);
    private static void InitializeConnectionTags(TagList& tags, ConnectionMetricsContext& metricsContext);
    public ConnectionMetricsContext CreateContext(BaseConnectionContext connection);
    [NullableContextAttribute("2")]
public static bool TryGetHandshakeProtocol(SslProtocols protocols, String& name, String& version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelTrace : object {
    private ILogger _generalLogger;
    private ILogger _badRequestsLogger;
    private ILogger _connectionsLogger;
    private ILogger _http2Logger;
    private ILogger _http3Logger;
    public KestrelTrace(ILoggerFactory loggerFactory);
    public void ConnectionBadRequest(string connectionId, BadHttpRequestException ex);
    public void RequestProcessingError(string connectionId, Exception ex);
    public void RequestBodyMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier, double rate);
    public void ResponseMinimumDataRateNotSatisfied(string connectionId, string traceIdentifier);
    public void PossibleInvalidHttpVersionDetected(string connectionId, HttpVersion expectedHttpVersion, HttpVersion detectedHttpVersion);
    public void ConnectionStart(string connectionId);
    public void ConnectionStop(string connectionId);
    public void ConnectionPause(string connectionId);
    public void ConnectionResume(string connectionId);
    public void ConnectionKeepAlive(string connectionId);
    public void ConnectionDisconnect(string connectionId);
    public void NotAllConnectionsClosedGracefully();
    public void NotAllConnectionsAborted();
    public void ConnectionRejected(string connectionId);
    public void ApplicationAbortedConnection(string connectionId, string traceIdentifier);
    public void ConnectionAccepted(string connectionId);
    [NullableContextAttribute("2")]
public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual IDisposable BeginScope(TState state);
    public void ApplicationError(string connectionId, string traceIdentifier, Exception ex);
    public void ConnectionHeadResponseBodyWrite(string connectionId, long count);
    public void HeartbeatSlow(TimeSpan heartbeatDuration, TimeSpan interval, DateTimeOffset now);
    public void ApplicationNeverCompleted(string connectionId);
    public void RequestBodyStart(string connectionId, string traceIdentifier);
    public void RequestBodyDone(string connectionId, string traceIdentifier);
    public void RequestBodyNotEntirelyRead(string connectionId, string traceIdentifier);
    public void RequestBodyDrainTimedOut(string connectionId, string traceIdentifier);
    public void InvalidResponseHeaderRemoved();
    public void Http2DisabledWithHttp1AndNoTls(EndPoint endPoint);
    public void Http3DisabledWithHttp1AndNoTls(EndPoint endPoint);
    public void RequestAborted(string connectionId, string traceIdentifier);
    public void Http2ConnectionError(string connectionId, Http2ConnectionErrorException ex);
    public void Http2StreamError(string connectionId, Http2StreamErrorException ex);
    public void HPackDecodingError(string connectionId, int streamId, Exception ex);
    public void Http2StreamResetAbort(string traceIdentifier, Http2ErrorCode error, ConnectionAbortedException abortReason);
    public void Http2ConnectionClosing(string connectionId);
    public void Http2FrameReceived(string connectionId, Http2Frame frame);
    public void HPackEncodingError(string connectionId, int streamId, Exception ex);
    public void Http2MaxConcurrentStreamsReached(string connectionId);
    public void Http2ConnectionClosed(string connectionId, int highestOpenedStreamId);
    public void Http2FrameSending(string connectionId, Http2Frame frame);
    public void Http2QueueOperationsExceeded(string connectionId, ConnectionAbortedException ex);
    public void Http2UnexpectedDataRemaining(int streamId, string connectionId);
    public void Http2ConnectionQueueProcessingCompleted(string connectionId);
    public void Http2UnexpectedConnectionQueueError(string connectionId, Exception ex);
    public void Http2TooManyEnhanceYourCalms(string connectionId, int count);
    public void Http2FlowControlQueueOperationsExceeded(string connectionId, int count);
    public void Http2FlowControlQueueMaximumTooLow(string connectionId, int expected, int actual);
    public void Http3ConnectionError(string connectionId, Http3ConnectionErrorException ex);
    public void Http3ConnectionClosing(string connectionId);
    public void Http3ConnectionClosed(string connectionId, Nullable`1<long> highestOpenedStreamId);
    public void Http3StreamAbort(string traceIdentifier, Http3ErrorCode error, ConnectionAbortedException abortReason);
    public void Http3FrameReceived(string connectionId, long streamId, Http3RawFrame frame);
    public void Http3FrameSending(string connectionId, long streamId, Http3RawFrame frame);
    public void Http3OutboundControlStreamError(string connectionId, Exception ex);
    public void QPackDecodingError(string connectionId, long streamId, Exception ex);
    public void QPackEncodingError(string connectionId, long streamId, Exception ex);
    public void Http3GoAwayStreamId(string connectionId, long goAwayStreamId);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.ConcurrentPipeWriter : PipeWriter {
    private static int InitialSegmentPoolSize;
    private static int MaxSegmentPoolSize;
    private static int MinimumBufferSize;
    private static Exception _successfullyCompletedSentinel;
    private object _sync;
    private PipeWriter _innerPipeWriter;
    private MemoryPool`1<byte> _pool;
    private BufferSegmentStack _bufferSegmentPool;
    private BufferSegment _head;
    private BufferSegment _tail;
    private Memory`1<byte> _tailMemory;
    private int _tailBytesBuffered;
    private long _bytesBuffered;
    private TaskCompletionSource`1<FlushResult> _currentFlushTcs;
    private bool _bufferedWritePending;
    private bool _aborted;
    private Exception _completeException;
    [NullableContextAttribute("1")]
public ConcurrentPipeWriter(PipeWriter innerPipeWriter, MemoryPool`1<byte> pool, object sync);
    private static ConcurrentPipeWriter();
    public void Reset();
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    public virtual void Advance(int bytes);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.ConcurrentPipeWriter/<FlushAsyncAwaited>d__23")]
private Task FlushAsyncAwaited(ValueTask`1<FlushResult> flushTask, CancellationToken cancellationToken);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    public void Abort();
    private void CleanupSegmentsUnsynchronized();
    private void CopyAndReturnSegmentsUnsynchronized();
    private void CompleteFlushUnsynchronized(FlushResult flushResult, Exception flushEx);
    private void AllocateMemoryUnsynchronized(int sizeHint);
    private BufferSegment AllocateSegmentUnsynchronized(int minSize);
    private BufferSegment CreateSegmentUnsynchronized();
    private void ReturnSegmentUnsynchronized(BufferSegment segment);
    private static int GetSegmentSize(int sizeHint, int maxBufferSize);
    private static void ThrowArgumentOutOfRangeException(string argumentName);
    private static Exception CreateArgumentOutOfRangeException(string argumentName);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.TimingPipeFlusher : object {
    private PipeWriter _writer;
    private ITimeoutControl _timeoutControl;
    private KestrelTrace _log;
    [NullableContextAttribute("1")]
public TimingPipeFlusher(ITimeoutControl timeoutControl, KestrelTrace log);
    [NullableContextAttribute("1")]
public void Initialize(PipeWriter output);
    public ValueTask`1<FlushResult> FlushAsync();
    public ValueTask`1<FlushResult> FlushAsync(IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    public ValueTask`1<FlushResult> FlushAsync(MinDataRate minRate, long count);
    [NullableContextAttribute("2")]
public ValueTask`1<FlushResult> FlushAsync(MinDataRate minRate, long count, IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.PipeWriterHelpers.TimingPipeFlusher/<TimeFlushAsyncAwaited>d__9")]
private ValueTask`1<FlushResult> TimeFlushAsyncAwaited(ValueTask`1<FlushResult> pipeFlushTask, MinDataRate minRate, IHttpOutputAborter outputAborter, CancellationToken cancellationToken);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ReadOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int WriteTimeout { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("1")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ResourceCounter : object {
    [CompilerGeneratedAttribute]
private static ResourceCounter <Unlimited>k__BackingField;
    public static ResourceCounter Unlimited { get; }
    private static ResourceCounter();
    public abstract virtual bool TryLockOne();
    public abstract virtual void ReleaseOne();
    [CompilerGeneratedAttribute]
public static ResourceCounter get_Unlimited();
    public static ResourceCounter Quota(long amount);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StatusCheckPipeWriter : PipeWriter {
    private PipeWriter _inner;
    private HttpProtocol _context;
    public bool CanGetUnflushedBytes { get; }
    public long UnflushedBytes { get; }
    [NullableContextAttribute("1")]
public StatusCheckPipeWriter(PipeWriter inner);
    [NullableContextAttribute("1")]
public void SetRequest(HttpProtocol context);
    public virtual bool get_CanGetUnflushedBytes();
    public virtual long get_UnflushedBytes();
    private void CheckStatus();
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    [NullableContextAttribute("1")]
public virtual Stream AsStream(bool leaveOpen);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StatusCheckWriteStream : WriteOnlyStream {
    private Stream _inner;
    private HttpProtocol _context;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int WriteTimeout { get; public set; }
    public StatusCheckWriteStream(Stream inner);
    public void SetRequest(HttpProtocol context);
    private void CheckStatus();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StreamCloseAwaitable : object {
    private static Action _callbackCompleted;
    private Action _callback;
    public bool IsCompleted { get; }
    private static StreamCloseAwaitable();
    [NullableContextAttribute("1")]
public StreamCloseAwaitable GetAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    public void Complete();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.StringUtilities : object {
    private static SpanAction`2<char, IntPtr> s_getAsciiOrUTF8StringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getAsciiStringNonNullCharacters;
    private static SpanAction`2<char, IntPtr> s_getLatin1StringNonNullCharacters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SpanAction`2<char, ValueTuple`3<string, char, UInt32>> s_populateSpanWithHexSuffix;
    private static StringUtilities();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetAsciiOrUTF8StringNonNullCharacters(ReadOnlySpan`1<byte> span, Encoding defaultEncoding);
    [ExtensionAttribute]
public static string GetAsciiStringNonNullCharacters(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static string GetLatin1StringNonNullCharacters(ReadOnlySpan`1<byte> span);
    public static bool TryGetAsciiString(Byte* input, Char* output, int count);
    public static bool TryGetLatin1String(Byte* input, Char* output, int count);
    public static bool BytesOrdinalEqualsStringAndAscii(string previousValue, ReadOnlySpan`1<byte> newValue);
    private static void WidenFourAsciiBytesToUtf16AndWriteToBuffer(Char* output, Byte* input, int value, Vector128`1<sbyte> zero);
    private static bool IsValidHeaderString(string value);
    [NullableContextAttribute("1")]
public static string ConcatAsHexSuffix(string str, char separator, UInt32 number);
    private static bool CheckBytesInAsciiRange(Vector`1<sbyte> check);
    private static bool CheckBytesInAsciiRange(Vector256`1<sbyte> check, Vector256`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(Vector128`1<sbyte> check, Vector128`1<sbyte> zero);
    private static bool CheckBytesInAsciiRange(long check);
    private static bool CheckBytesInAsciiRange(int check);
    private static bool CheckBytesInAsciiRange(short check);
    private static bool CheckBytesInAsciiRange(sbyte check);
    private static bool CheckBytesNotNull(Vector`1<byte> check);
    private static bool CheckBytesNotNull(long check);
    private static bool CheckBytesNotNull(int check);
    private static bool CheckBytesNotNull(short check);
    private static bool CheckBytesNotNull(sbyte check);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ThrowingPipeWriter : PipeWriter {
    private string _message;
    [NullableContextAttribute("1")]
public ThrowingPipeWriter(string message);
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.ThrowingWasUpgradedWriteOnlyStream : WriteOnlyStream {
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutControl : object {
    private ITimeoutHandler _timeoutHandler;
    private TimeProvider _timeProvider;
    private long _heartbeatIntervalTicks;
    private long _lastTimestamp;
    private long _timeoutTimestamp;
    private object _readTimingLock;
    private MinDataRate _minReadRate;
    private long _minReadRateGracePeriodTicks;
    private bool _readTimingEnabled;
    private bool _readTimingPauseRequested;
    private long _readTimingElapsedTicks;
    private long _readTimingBytesRead;
    private InputFlowControl _connectionInputFlowControl;
    private int _concurrentIncompleteRequestBodies;
    private int _concurrentAwaitingReads;
    private object _writeTimingLock;
    private int _concurrentAwaitingWrites;
    private long _writeTimingTimeoutTimestamp;
    [CompilerGeneratedAttribute]
private TimeoutReason <TimerReason>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugger <Debugger>k__BackingField;
    public TimeoutReason TimerReason { get; private set; }
    internal IDebugger Debugger { get; internal set; }
    public TimeoutControl(ITimeoutHandler timeoutHandler, TimeProvider timeProvider);
    [CompilerGeneratedAttribute]
public sealed virtual TimeoutReason get_TimerReason();
    [CompilerGeneratedAttribute]
private void set_TimerReason(TimeoutReason value);
    [CompilerGeneratedAttribute]
internal IDebugger get_Debugger();
    [CompilerGeneratedAttribute]
internal void set_Debugger(IDebugger value);
    internal void Initialize();
    public sealed virtual void Tick(long timestamp);
    private void CheckForTimeout(long timestamp);
    private void CheckForReadDataRateTimeout(long timestamp);
    private void CheckForWriteDataRateTimeout(long timestamp);
    public sealed virtual void SetTimeout(TimeSpan timeout, TimeoutReason timeoutReason);
    public sealed virtual void ResetTimeout(TimeSpan timeout, TimeoutReason timeoutReason);
    public sealed virtual void CancelTimeout();
    private void AssignTimeout(TimeSpan timeout, TimeoutReason timeoutReason);
    public sealed virtual void InitializeHttp2(InputFlowControl connectionInputFlowControl);
    public sealed virtual void StartRequestBody(MinDataRate minRate);
    public sealed virtual void StopRequestBody();
    public sealed virtual void StopTimingRead();
    public sealed virtual void StartTimingRead();
    public sealed virtual void BytesRead(long count);
    public sealed virtual void StartTimingWrite();
    public sealed virtual void StopTimingWrite();
    public sealed virtual void BytesWrittenToBuffer(MinDataRate minRate, long count);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature.SetTimeout(TimeSpan timeSpan);
    private sealed virtual override void Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature.ResetTimeout(TimeSpan timeSpan);
    public sealed virtual long GetResponseDrainDeadline(long timestamp, MinDataRate minRate);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutControlExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void StartDrainTimeout(ITimeoutControl timeoutControl, MinDataRate minDataRate, Nullable`1<long> maxResponseBufferSize);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TimeoutReason : Enum {
    public int value__;
    public static TimeoutReason None;
    public static TimeoutReason KeepAlive;
    public static TimeoutReason RequestHeaders;
    public static TimeoutReason ReadDataRate;
    public static TimeoutReason WriteDataRate;
    public static TimeoutReason RequestBodyDrain;
    public static TimeoutReason TimeoutFeature;
}
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TlsAlpn : object {
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static TlsAlpn();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportConnectionManager : object {
    private ConnectionManager _connectionManager;
    private ConcurrentDictionary`2<long, ConnectionReference> _connectionReferences;
    public TransportConnectionManager(ConnectionManager connectionManager);
    public long GetNewConnectionId();
    public void AddConnection(long id, KestrelConnection connection);
    public void RemoveConnection(long id);
    public void StopTracking(long id);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportConnectionManager/<CloseAllConnectionsAsync>d__7")]
public Task`1<bool> CloseAllConnectionsAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportConnectionManager/<AbortAllConnectionsAsync>d__8")]
public Task`1<bool> AbortAllConnectionsAsync();
    private static Task CancellationTokenAsTask(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportManager : object {
    private List`1<ActiveTransport> _transports;
    private List`1<IConnectionListenerFactory> _transportFactories;
    private List`1<IMultiplexedConnectionListenerFactory> _multiplexedTransportFactories;
    private IHttpsConfigurationService _httpsConfigurationService;
    private ServiceContext _serviceContext;
    private ConnectionManager ConnectionManager { get; }
    private KestrelTrace Trace { get; }
    public TransportManager(List`1<IConnectionListenerFactory> transportFactories, List`1<IMultiplexedConnectionListenerFactory> multiplexedTransportFactories, IHttpsConfigurationService httpsConfigurationService, ServiceContext serviceContext);
    private ConnectionManager get_ConnectionManager();
    private KestrelTrace get_Trace();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportManager/<BindAsync>d__10")]
public Task`1<EndPoint> BindAsync(EndPoint endPoint, ConnectionDelegate connectionDelegate, EndpointConfig endpointConfig, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportManager/<BindAsync>d__11")]
public Task`1<EndPoint> BindAsync(EndPoint endPoint, MultiplexedConnectionDelegate multiplexedConnectionDelegate, ListenOptions listenOptions, CancellationToken cancellationToken);
    private static bool CanBindFactory(EndPoint endPoint, IConnectionListenerFactorySelector selector);
    private void StartAcceptLoop(IConnectionListener`1<T> connectionListener, Func`2<T, Task> connectionDelegate, EndpointConfig endpointConfig);
    public Task StopEndpointsAsync(List`1<EndpointConfig> endpointsToStop, CancellationToken cancellationToken);
    public Task StopAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.TransportManager/<StopTransportsAsync>d__16")]
private Task StopTransportsAsync(List`1<ActiveTransport> transportsToStop, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.WrappingPipeWriter : PipeWriter {
    private PipeWriter _inner;
    public bool CanGetUnflushedBytes { get; }
    public long UnflushedBytes { get; }
    [NullableContextAttribute("1")]
public WrappingPipeWriter(PipeWriter inner);
    [NullableContextAttribute("1")]
public void SetInnerPipe(PipeWriter inner);
    public virtual bool get_CanGetUnflushedBytes();
    public virtual long get_UnflushedBytes();
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    [NullableContextAttribute("1")]
public virtual Stream AsStream(bool leaveOpen);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.WrappingStream : Stream {
    private Stream _inner;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public WrappingStream(Stream inner);
    public void SetInnerStream(Stream inner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual object InitializeLifetimeService();
    public virtual void Close();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.WriteOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("1")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> memory, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.Server.Kestrel.Core.Internal.IRequestProcessor {
    public abstract virtual Task ProcessRequestsAsync(IHttpApplication`1<TContext> application);
    public abstract virtual void StopProcessingNextRequest();
    public abstract virtual void HandleRequestHeadersTimeout();
    public abstract virtual void HandleReadDataRateTimeout();
    public abstract virtual void OnInputOrOutputCompleted();
    public abstract virtual void Tick(long timestamp);
    public abstract virtual void Abort(ConnectionAbortedException ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.KestrelServerOptionsSetup : object {
    private IServiceProvider _services;
    public KestrelServerOptionsSetup(IServiceProvider services);
    public sealed virtual void Configure(KestrelServerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggerExtensions : object {
    private static string BadDeveloperCertificateStateMessage;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __LocatedDevelopmentCertificateCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __UnableToLocateDevelopmentCertificateCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __FailedToLocateDevelopmentCertificateFileCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __FailedToLoadDevelopmentCertificateCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __BadDeveloperCertificateStateCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __DeveloperCertificateFirstRunCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __FailedToLoadCertificateCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __FailedToLoadCertificateKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __DeveloperCertificateNotTrustedCallback;
    private static LoggerExtensions();
    [ExtensionAttribute]
[LoggerMessageAttribute("0", "1", "Using development certificate: {certificateSubjectName} (Thumbprint: {certificateThumbprint})")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void LocatedDevelopmentCertificate(ILogger`1<KestrelServer> logger, string certificateSubjectName, string certificateThumbprint);
    [ExtensionAttribute]
public static void LocatedDevelopmentCertificate(ILogger`1<KestrelServer> logger, X509Certificate2 certificate);
    [ExtensionAttribute]
[LoggerMessageAttribute("1", "1", "Unable to locate an appropriate development https certificate.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UnableToLocateDevelopmentCertificate(ILogger`1<KestrelServer> logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("2", "1", "Failed to locate the development https certificate at '{certificatePath}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToLocateDevelopmentCertificateFile(ILogger`1<KestrelServer> logger, string certificatePath);
    [ExtensionAttribute]
[LoggerMessageAttribute("3", "1", "Failed to load the development https certificate at '{certificatePath}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToLoadDevelopmentCertificate(ILogger`1<KestrelServer> logger, string certificatePath);
    [ExtensionAttribute]
[LoggerMessageAttribute("4", "4", "The ASP.NET Core developer certificate is in an invalid state. To fix this issue, run the following commands 'dotnet dev-certs https --clean' and 'dotnet dev-certs https' to remove all existing ASP.NET Core development certificates and create a new untrusted developer certificate. On macOS or Windows, use 'dotnet dev-certs https --trust' to trust the new certificate.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void BadDeveloperCertificateState(ILogger`1<KestrelServer> logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("5", "3", "{Message}")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DeveloperCertificateFirstRun(ILogger`1<KestrelServer> logger, string message);
    [ExtensionAttribute]
[LoggerMessageAttribute("6", "4", "The certificate file at '{CertificateFilePath}' can not be found, contains malformed data or does not contain a certificate.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToLoadCertificate(ILogger`1<KestrelServer> logger, string certificateFilePath);
    [ExtensionAttribute]
[LoggerMessageAttribute("7", "4", "The certificate key file at '{CertificateKeyFilePath}' can not be found, contains malformed data or does not contain a PEM encoded key in PKCS8 format.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToLoadCertificateKey(ILogger`1<KestrelServer> logger, string certificateKeyFilePath);
    [ExtensionAttribute]
[LoggerMessageAttribute("8", "3", "The ASP.NET Core developer certificate is not trusted. For information about trusting the ASP.NET Core developer certificate, see https://aka.ms/aspnet/https-trust-dev-cert.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DeveloperCertificateNotTrusted(ILogger`1<KestrelServer> logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingConnectionMiddleware : object {
    private ConnectionDelegate _next;
    private ILogger _logger;
    public LoggingConnectionMiddleware(ConnectionDelegate next, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingConnectionMiddleware/<OnConnectionAsync>d__3")]
public Task OnConnectionAsync(ConnectionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingDuplexPipe : DuplexPipeStreamAdapter`1<LoggingStream> {
    private static StreamPipeReaderOptions _defaultReaderOptions;
    private static StreamPipeWriterOptions _defaultWriterOptions;
    public LoggingDuplexPipe(IDuplexPipe transport, ILogger logger);
    private static LoggingDuplexPipe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingMultiplexedConnectionMiddleware : object {
    private MultiplexedConnectionDelegate _multiplexedNext;
    private ILogger _logger;
    public LoggingMultiplexedConnectionMiddleware(MultiplexedConnectionDelegate multiplexedNext, ILogger logger);
    public Task OnConnectionAsync(MultiplexedConnectionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream : Stream {
    private Stream _inner;
    private ILogger _logger;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LoggingStream(Stream inner, ILogger logger);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> destination);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream/<ReadAsync>d__18")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.LoggingStream/<ReadAsync>d__19")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> source);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private void Log(string method, ReadOnlySpan`1<byte> buffer);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ManualResetValueTaskSource`1 : object {
    private ManualResetValueTaskSourceCore`1<T> _core;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    public bool get_RunContinuationsAsynchronously();
    public void set_RunContinuationsAsynchronously(bool value);
    public short get_Version();
    public void Reset();
    public void SetResult(T result);
    public void SetException(Exception error);
    public sealed virtual T GetResult(short token);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token);
    public sealed virtual ValueTaskSourceStatus GetStatus(short token);
    [NullableContextAttribute("2")]
public sealed virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public ValueTaskSourceStatus GetStatus();
    public void TrySetResult(T result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.MemoryPoolExtensions : object {
    [ExtensionAttribute]
public static int GetMinimumSegmentSize(MemoryPool`1<byte> pool);
    [ExtensionAttribute]
public static int GetMinimumAllocSize(MemoryPool`1<byte> pool);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServerAddressesCollection/ServerAddressesCollectionDebugView")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServerAddressesCollection : object {
    private List`1<string> _addresses;
    private PublicServerAddressesCollection _publicCollection;
    public ICollection`1<string> PublicCollection { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public ICollection`1<string> get_PublicCollection();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public void PreventPublicMutation();
    public sealed virtual void Add(string item);
    public sealed virtual bool Remove(string item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string item);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerToString(),nq}")]
[DebuggerTypeProxyAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServerAddressesFeature/ServerAddressesFeatureDebugView")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServerAddressesFeature : object {
    [CompilerGeneratedAttribute]
private ServerAddressesCollection <InternalCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferHostingUrls>k__BackingField;
    public ServerAddressesCollection InternalCollection { get; }
    private ICollection`1<string> Microsoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature.Addresses { get; }
    public bool PreferHostingUrls { get; public set; }
    [CompilerGeneratedAttribute]
public ServerAddressesCollection get_InternalCollection();
    private sealed virtual override ICollection`1<string> Microsoft.AspNetCore.Hosting.Server.Features.IServerAddressesFeature.get_Addresses();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreferHostingUrls();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreferHostingUrls(bool value);
    private string DebuggerToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.ServiceContext : object {
    [CompilerGeneratedAttribute]
private KestrelTrace <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpParser`1<Http1ParsingHandler> <HttpParser>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeProvider <TimeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DateHeaderValueManager <DateHeaderValueManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionManager <ConnectionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Heartbeat <Heartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <ServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticSource <DiagnosticSource>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelMetrics <Metrics>k__BackingField;
    public KestrelTrace Log { get; public set; }
    public PipeScheduler Scheduler { get; public set; }
    public IHttpParser`1<Http1ParsingHandler> HttpParser { get; public set; }
    public TimeProvider TimeProvider { get; public set; }
    public DateHeaderValueManager DateHeaderValueManager { get; public set; }
    public ConnectionManager ConnectionManager { get; public set; }
    public Heartbeat Heartbeat { get; public set; }
    public KestrelServerOptions ServerOptions { get; public set; }
    [NullableAttribute("2")]
public DiagnosticSource DiagnosticSource { get; public set; }
    public KestrelMetrics Metrics { get; public set; }
    [CompilerGeneratedAttribute]
public KestrelTrace get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(KestrelTrace value);
    [CompilerGeneratedAttribute]
public PipeScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public void set_Scheduler(PipeScheduler value);
    [CompilerGeneratedAttribute]
public IHttpParser`1<Http1ParsingHandler> get_HttpParser();
    [CompilerGeneratedAttribute]
public void set_HttpParser(IHttpParser`1<Http1ParsingHandler> value);
    [CompilerGeneratedAttribute]
public TimeProvider get_TimeProvider();
    [CompilerGeneratedAttribute]
public void set_TimeProvider(TimeProvider value);
    [CompilerGeneratedAttribute]
public DateHeaderValueManager get_DateHeaderValueManager();
    [CompilerGeneratedAttribute]
public void set_DateHeaderValueManager(DateHeaderValueManager value);
    [CompilerGeneratedAttribute]
public ConnectionManager get_ConnectionManager();
    [CompilerGeneratedAttribute]
public void set_ConnectionManager(ConnectionManager value);
    [CompilerGeneratedAttribute]
public Heartbeat get_Heartbeat();
    [CompilerGeneratedAttribute]
public void set_Heartbeat(Heartbeat value);
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_ServerOptions();
    [CompilerGeneratedAttribute]
public void set_ServerOptions(KestrelServerOptions value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DiagnosticSource get_DiagnosticSource();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DiagnosticSource(DiagnosticSource value);
    [CompilerGeneratedAttribute]
public KestrelMetrics get_Metrics();
    [CompilerGeneratedAttribute]
public void set_Metrics(KestrelMetrics value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.SniConfig : object {
    [CompilerGeneratedAttribute]
private Nullable`1<HttpProtocols> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SslProtocols> <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateConfig <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ClientCertificateMode> <ClientCertificateMode>k__BackingField;
    public Nullable`1<HttpProtocols> Protocols { get; public set; }
    public Nullable`1<SslProtocols> SslProtocols { get; public set; }
    public CertificateConfig Certificate { get; public set; }
    public Nullable`1<ClientCertificateMode> ClientCertificateMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<HttpProtocols> get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(Nullable`1<HttpProtocols> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SslProtocols> get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(Nullable`1<SslProtocols> value);
    [CompilerGeneratedAttribute]
public CertificateConfig get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(CertificateConfig value);
    [CompilerGeneratedAttribute]
public Nullable`1<ClientCertificateMode> get_ClientCertificateMode();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMode(Nullable`1<ClientCertificateMode> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static bool op_Equality(SniConfig lhs, SniConfig rhs);
    [NullableContextAttribute("1")]
public static bool op_Inequality(SniConfig lhs, SniConfig rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.SniOptionsSelector : object {
    private static string WildcardHost;
    private static string WildcardPrefix;
    private string _endpointName;
    private ILogger`1<HttpsConnectionMiddleware> _logger;
    private Func`3<ConnectionContext, string, X509Certificate2> _fallbackServerCertificateSelector;
    private Action`2<ConnectionContext, SslServerAuthenticationOptions> _onAuthenticateCallback;
    private Dictionary`2<string, SniOptions> _exactNameOptions;
    private SortedList`2<string, SniOptions> _wildcardPrefixOptions;
    private SniOptions _wildcardOptions;
    public SniOptionsSelector(string endpointName, Dictionary`2<string, SniConfig> sniDictionary, ICertificateConfigLoader certifcateConfigLoader, HttpsConnectionAdapterOptions fallbackHttpsOptions, HttpProtocols fallbackHttpProtocols, ILogger`1<HttpsConnectionMiddleware> logger);
    public ValueTuple`2<SslServerAuthenticationOptions, ClientCertificateMode> GetOptions(ConnectionContext connection, string serverName);
    public static ValueTask`1<SslServerAuthenticationOptions> OptionsCallback(TlsHandshakeCallbackContext callbackContext);
    internal static SslServerAuthenticationOptions CloneSslOptions(SslServerAuthenticationOptions sslOptions);
}
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.TlsConnectionFeature : object {
    private SslStream _sslStream;
    private ConnectionContext _context;
    private X509Certificate2 _clientCert;
    private Task`1<X509Certificate2> _clientCertTask;
    [CompilerGeneratedAttribute]
private bool <AllowDelayedClientCertificateNegotation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    internal bool AllowDelayedClientCertificateNegotation { get; internal set; }
    [NullableAttribute("2")]
public X509Certificate2 ClientCertificate { get; public set; }
    [NullableAttribute("1")]
public string HostName { get; public set; }
    public ReadOnlyMemory`1<byte> ApplicationProtocol { get; }
    public SslProtocols Protocol { get; }
    [NullableAttribute("1")]
public SslStream SslStream { get; }
    public Nullable`1<TlsCipherSuite> NegotiatedCipherSuite { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    [NullableContextAttribute("1")]
public TlsConnectionFeature(SslStream sslStream, ConnectionContext context);
    [CompilerGeneratedAttribute]
internal bool get_AllowDelayedClientCertificateNegotation();
    [CompilerGeneratedAttribute]
internal void set_AllowDelayedClientCertificateNegotation(bool value);
    [NullableContextAttribute("2")]
public sealed virtual X509Certificate2 get_ClientCertificate();
    [NullableContextAttribute("2")]
public sealed virtual void set_ClientCertificate(X509Certificate2 value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_HostName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_HostName(string value);
    public sealed virtual ReadOnlyMemory`1<byte> get_ApplicationProtocol();
    public sealed virtual SslProtocols get_Protocol();
    [NullableContextAttribute("1")]
public sealed virtual SslStream get_SslStream();
    public sealed virtual Nullable`1<TlsCipherSuite> get_NegotiatedCipherSuite();
    public sealed virtual CipherAlgorithmType get_CipherAlgorithm();
    public sealed virtual int get_CipherStrength();
    public sealed virtual HashAlgorithmType get_HashAlgorithm();
    public sealed virtual int get_HashStrength();
    public sealed virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public sealed virtual int get_KeyExchangeStrength();
    public sealed virtual Task`1<X509Certificate2> GetClientCertificateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.TlsConnectionFeature/<GetClientCertificateAsyncCore>d__37")]
private Task`1<X509Certificate2> GetClientCertificateAsyncCore(CancellationToken cancellationToken);
    private static X509Certificate2 ConvertToX509Certificate2(X509Certificate certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.WebTransport.WebTransportSession : object {
    private static IStreamDirectionFeature _outputStreamDirectionFeature;
    private CancellationTokenRegistration _connectionClosedRegistration;
    private ConcurrentDictionary`2<long, WebTransportStream> _openStreams;
    private Channel`1<WebTransportStream> _pendingStreams;
    private Http3Connection _connection;
    private Http3Stream _connectStream;
    private bool _isClosing;
    private static ReadOnlyMemory`1<byte> OutputStreamHeader;
    internal static string WebTransportProtocolValue;
    internal static string VersionEnabledIndicator;
    internal static string SecPrefix;
    internal static string VersionHeaderPrefix;
    internal static string CurrentSupportedVersionSuffix;
    internal static string CurrentSupportedVersion;
    public long SessionId { get; }
    internal WebTransportSession(Http3Connection connection, Http3Stream connectStream);
    private static WebTransportSession();
    public sealed virtual long get_SessionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IWebTransportSession.Abort(int errorCode);
    internal void OnClientConnectionClosed();
    internal void Abort(ConnectionAbortedException exception, Http3ErrorCode error);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.WebTransport.WebTransportSession/<OpenUnidirectionalStreamAsync>d__20")]
public sealed virtual ValueTask`1<ConnectionContext> OpenUnidirectionalStreamAsync(CancellationToken cancellationToken);
    internal void AddStream(WebTransportStream stream);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.WebTransport.WebTransportSession/<AcceptStreamAsync>d__22")]
public sealed virtual ValueTask`1<ConnectionContext> AcceptStreamAsync(CancellationToken cancellationToken);
    internal bool TryRemoveStream(long streamId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.Internal.WebTransport.WebTransportStream : ConnectionContext {
    private CancellationTokenRegistration _connectionClosedRegistration;
    private bool _canWrite;
    private bool _canRead;
    private DuplexPipe _duplexPipe;
    private IFeatureCollection _features;
    private KestrelTrace _log;
    private long _streamId;
    private IDictionary`2<object, object> _items;
    private bool _isClosed;
    public string ConnectionId { get; public set; }
    public IDuplexPipe Transport { get; public set; }
    public IFeatureCollection Features { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<object, object> Items { get; public set; }
    public long StreamId { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal WebTransportStream(Http3StreamContext context, WebTransportStreamType type);
    public virtual string get_ConnectionId();
    public virtual void set_ConnectionId(string value);
    public virtual IDuplexPipe get_Transport();
    public virtual void set_Transport(IDuplexPipe value);
    public virtual IFeatureCollection get_Features();
    public virtual IDictionary`2<object, object> get_Items();
    public virtual void set_Items(IDictionary`2<object, object> value);
    public sealed virtual long get_StreamId();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public virtual void Abort(ConnectionAbortedException abortReason);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.Internal.WebTransport.WebTransportStream/<DisposeAsync>d__28")]
public virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelBadHttpRequestException : object {
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, HttpMethod method);
    internal static BadHttpRequestException GetException(RequestRejectionReason reason);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, string detail);
    [StackTraceHiddenAttribute]
internal static void Throw(RequestRejectionReason reason, StringValues detail);
    internal static BadHttpRequestException GetException(RequestRejectionReason reason, string detail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer : object {
    private KestrelServerImpl _innerKestrelServer;
    public IFeatureCollection Features { get; }
    public KestrelServerOptions Options { get; }
    public KestrelServer(IOptions`1<KestrelServerOptions> options, IConnectionListenerFactory transportFactory, ILoggerFactory loggerFactory);
    public sealed virtual IFeatureCollection get_Features();
    public KestrelServerOptions get_Options();
    public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerImpl : object {
    private ServerAddressesFeature _serverAddresses;
    private TransportManager _transportManager;
    private List`1<IConnectionListenerFactory> _transportFactories;
    private List`1<IMultiplexedConnectionListenerFactory> _multiplexedTransportFactories;
    private IHttpsConfigurationService _httpsConfigurationService;
    private SemaphoreSlim _bindSemaphore;
    private bool _hasStarted;
    private int _stopping;
    private CancellationTokenSource _stopCts;
    private TaskCompletionSource _stoppedTcs;
    private IDisposable _configChangedRegistration;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceContext <ServiceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private AddressBindContext <AddressBindContext>k__BackingField;
    public IFeatureCollection Features { get; }
    public KestrelServerOptions Options { get; }
    private ServiceContext ServiceContext { get; }
    private KestrelTrace Trace { get; }
    [NullableAttribute("2")]
private AddressBindContext AddressBindContext { get; private set; }
    public KestrelServerImpl(IOptions`1<KestrelServerOptions> options, IEnumerable`1<IConnectionListenerFactory> transportFactories, IEnumerable`1<IMultiplexedConnectionListenerFactory> multiplexedFactories, IHttpsConfigurationService httpsConfigurationService, ILoggerFactory loggerFactory, KestrelMetrics metrics);
    internal KestrelServerImpl(IEnumerable`1<IConnectionListenerFactory> transportFactories, IEnumerable`1<IMultiplexedConnectionListenerFactory> multiplexedFactories, IHttpsConfigurationService httpsConfigurationService, ServiceContext serviceContext);
    private static ServiceContext CreateServiceContext(IOptions`1<KestrelServerOptions> options, ILoggerFactory loggerFactory, DiagnosticSource diagnosticSource, KestrelMetrics metrics);
    [CompilerGeneratedAttribute]
public sealed virtual IFeatureCollection get_Features();
    public KestrelServerOptions get_Options();
    [CompilerGeneratedAttribute]
private ServiceContext get_ServiceContext();
    private KestrelTrace get_Trace();
    [CompilerGeneratedAttribute]
private AddressBindContext get_AddressBindContext();
    [CompilerGeneratedAttribute]
private void set_AddressBindContext(AddressBindContext value);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerImpl/<StartAsync>d__28`1")]
public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerImpl/<StopAsync>d__29")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerImpl/<BindAsync>d__31")]
private Task BindAsync(CancellationToken cancellationToken);
    private static void TriggerRebind(object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerImpl/<RebindAsync>d__33")]
private Task RebindAsync();
    private void ValidateOptions();
    private static ConnectionDelegate EnforceConnectionLimit(ConnectionDelegate innerDelegate, Nullable`1<long> connectionLimit, KestrelTrace trace, KestrelMetrics metrics);
    private static MultiplexedConnectionDelegate EnforceConnectionLimit(MultiplexedConnectionDelegate innerDelegate, Nullable`1<long> connectionLimit, KestrelTrace trace, KestrelMetrics metrics);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits : object {
    private Nullable`1<long> _maxResponseBufferSize;
    private Nullable`1<long> _maxRequestBufferSize;
    private int _maxRequestLineSize;
    private int _maxRequestHeadersTotalSize;
    private Nullable`1<long> _maxRequestBodySize;
    private int _maxRequestHeaderCount;
    private TimeSpan _keepAliveTimeout;
    private TimeSpan _requestHeadersTimeout;
    private Nullable`1<long> _maxConcurrentConnections;
    private Nullable`1<long> _maxConcurrentUpgradedConnections;
    [CompilerGeneratedAttribute]
private Http2Limits <Http2>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3Limits <Http3>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinRequestBodyDataRate>k__BackingField;
    [CompilerGeneratedAttribute]
private MinDataRate <MinResponseDataRate>k__BackingField;
    public Nullable`1<long> MaxResponseBufferSize { get; public set; }
    public Nullable`1<long> MaxRequestBufferSize { get; public set; }
    public int MaxRequestLineSize { get; public set; }
    public int MaxRequestHeadersTotalSize { get; public set; }
    public int MaxRequestHeaderCount { get; public set; }
    public Nullable`1<long> MaxRequestBodySize { get; public set; }
    public TimeSpan KeepAliveTimeout { get; public set; }
    public TimeSpan RequestHeadersTimeout { get; public set; }
    public Nullable`1<long> MaxConcurrentConnections { get; public set; }
    public Nullable`1<long> MaxConcurrentUpgradedConnections { get; public set; }
    [NullableAttribute("1")]
public Http2Limits Http2 { get; }
    [NullableAttribute("1")]
public Http3Limits Http3 { get; }
    public MinDataRate MinRequestBodyDataRate { get; public set; }
    public MinDataRate MinResponseDataRate { get; public set; }
    public Nullable`1<long> get_MaxResponseBufferSize();
    public void set_MaxResponseBufferSize(Nullable`1<long> value);
    public Nullable`1<long> get_MaxRequestBufferSize();
    public void set_MaxRequestBufferSize(Nullable`1<long> value);
    public int get_MaxRequestLineSize();
    public void set_MaxRequestLineSize(int value);
    public int get_MaxRequestHeadersTotalSize();
    public void set_MaxRequestHeadersTotalSize(int value);
    public int get_MaxRequestHeaderCount();
    public void set_MaxRequestHeaderCount(int value);
    public Nullable`1<long> get_MaxRequestBodySize();
    public void set_MaxRequestBodySize(Nullable`1<long> value);
    public TimeSpan get_KeepAliveTimeout();
    public void set_KeepAliveTimeout(TimeSpan value);
    public TimeSpan get_RequestHeadersTimeout();
    public void set_RequestHeadersTimeout(TimeSpan value);
    public Nullable`1<long> get_MaxConcurrentConnections();
    public void set_MaxConcurrentConnections(Nullable`1<long> value);
    public Nullable`1<long> get_MaxConcurrentUpgradedConnections();
    public void set_MaxConcurrentUpgradedConnections(Nullable`1<long> value);
    [NullableContextAttribute("1")]
internal void Serialize(Utf8JsonWriter writer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Http2Limits get_Http2();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Http3Limits get_Http3();
    [CompilerGeneratedAttribute]
public MinDataRate get_MinRequestBodyDataRate();
    [CompilerGeneratedAttribute]
public void set_MinRequestBodyDataRate(MinDataRate value);
    [CompilerGeneratedAttribute]
public MinDataRate get_MinResponseDataRate();
    [CompilerGeneratedAttribute]
public void set_MinResponseDataRate(MinDataRate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions : object {
    internal static string DisableHttp1LineFeedTerminatorsSwitchKey;
    private static string FinOnErrorSwitch;
    internal static string CertificateFileWatchingSwitch;
    private static bool _finOnError;
    private static bool _disableCertificateFileWatching;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Func`2<string, Encoding> DefaultHeaderEncodingSelector;
    [CompilerGeneratedAttribute]
private bool <FinOnError>k__BackingField;
    private Func`2<string, Encoding> _requestHeaderEncodingSelector;
    private Func`2<string, Encoding> _responseHeaderEncodingSelector;
    [CompilerGeneratedAttribute]
private bool <AllowHostHeaderOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ListenOptions> <CodeBackedListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ListenOptions> <ConfigurationBackedListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ListenOptions> <OptionsInUse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddServerHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowResponseHeaderCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIO>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAlternateSchemes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableStringReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableAltSvc>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ApplicationServices>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerLimits <Limits>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelConfigurationLoader <ConfigurationLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ListenOptions> <EndpointDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<HttpsConnectionAdapterOptions> <HttpsDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <DevelopmentCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <TestOverrideDefaultCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentCertificateLoaded>k__BackingField;
    private Nullable`1<bool> _enableWebTransportAndH3Datagrams;
    private Nullable`1<bool> _disableHttp1LineFeedTerminators;
    internal bool FinOnError { get; internal set; }
    public bool AllowHostHeaderOverride { get; public set; }
    internal List`1<ListenOptions> CodeBackedListenOptions { get; }
    internal List`1<ListenOptions> ConfigurationBackedListenOptions { get; }
    internal List`1<ListenOptions> OptionsInUse { get; }
    public bool AddServerHeader { get; public set; }
    public bool AllowResponseHeaderCompression { get; public set; }
    public bool AllowSynchronousIO { get; public set; }
    public bool AllowAlternateSchemes { get; public set; }
    public bool DisableStringReuse { get; public set; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future version. It no longer has any impact on runtime behavior. Use ListenOptions.DisableAltSvcHeader to configure "Alt-Svc" behavior.", "True")]
public bool EnableAltSvc { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> RequestHeaderEncodingSelector { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, Encoding> ResponseHeaderEncodingSelector { get; public set; }
    public IServiceProvider ApplicationServices { get; public set; }
    public KestrelServerLimits Limits { get; }
    [NullableAttribute("2")]
public KestrelConfigurationLoader ConfigurationLoader { get; public set; }
    private Action`1<ListenOptions> EndpointDefaults { get; private set; }
    private Action`1<HttpsConnectionAdapterOptions> HttpsDefaults { get; private set; }
    [NullableAttribute("2")]
internal X509Certificate2 DevelopmentCertificate { get; private set; }
    [NullableAttribute("2")]
internal X509Certificate2 TestOverrideDefaultCertificate { get; internal set; }
    internal bool IsDevelopmentCertificateLoaded { get; internal set; }
    internal bool EnableWebTransportAndH3Datagrams { get; internal set; }
    internal bool DisableHttp1LineFeedTerminators { get; internal set; }
    private static KestrelServerOptions();
    [CompilerGeneratedAttribute]
internal bool get_FinOnError();
    [CompilerGeneratedAttribute]
internal void set_FinOnError(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowHostHeaderOverride();
    [CompilerGeneratedAttribute]
public void set_AllowHostHeaderOverride(bool value);
    [CompilerGeneratedAttribute]
internal List`1<ListenOptions> get_CodeBackedListenOptions();
    [CompilerGeneratedAttribute]
internal List`1<ListenOptions> get_ConfigurationBackedListenOptions();
    internal ListenOptions[] GetListenOptions();
    [CompilerGeneratedAttribute]
internal List`1<ListenOptions> get_OptionsInUse();
    [CompilerGeneratedAttribute]
public bool get_AddServerHeader();
    [CompilerGeneratedAttribute]
public void set_AddServerHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowResponseHeaderCompression();
    [CompilerGeneratedAttribute]
public void set_AllowResponseHeaderCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIO(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAlternateSchemes();
    [CompilerGeneratedAttribute]
public void set_AllowAlternateSchemes(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableStringReuse();
    [CompilerGeneratedAttribute]
public void set_DisableStringReuse(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableAltSvc();
    [CompilerGeneratedAttribute]
public void set_EnableAltSvc(bool value);
    public Func`2<string, Encoding> get_RequestHeaderEncodingSelector();
    public void set_RequestHeaderEncodingSelector(Func`2<string, Encoding> value);
    public Func`2<string, Encoding> get_ResponseHeaderEncodingSelector();
    public void set_ResponseHeaderEncodingSelector(Func`2<string, Encoding> value);
    [CompilerGeneratedAttribute]
public IServiceProvider get_ApplicationServices();
    [CompilerGeneratedAttribute]
public void set_ApplicationServices(IServiceProvider value);
    [CompilerGeneratedAttribute]
public KestrelServerLimits get_Limits();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public KestrelConfigurationLoader get_ConfigurationLoader();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ConfigurationLoader(KestrelConfigurationLoader value);
    [CompilerGeneratedAttribute]
private Action`1<ListenOptions> get_EndpointDefaults();
    [CompilerGeneratedAttribute]
private void set_EndpointDefaults(Action`1<ListenOptions> value);
    [CompilerGeneratedAttribute]
private Action`1<HttpsConnectionAdapterOptions> get_HttpsDefaults();
    [CompilerGeneratedAttribute]
private void set_HttpsDefaults(Action`1<HttpsConnectionAdapterOptions> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal X509Certificate2 get_DevelopmentCertificate();
    [CompilerGeneratedAttribute]
private void set_DevelopmentCertificate(X509Certificate2 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal X509Certificate2 get_TestOverrideDefaultCertificate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_TestOverrideDefaultCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
internal bool get_IsDevelopmentCertificateLoaded();
    [CompilerGeneratedAttribute]
internal void set_IsDevelopmentCertificateLoaded(bool value);
    internal bool get_EnableWebTransportAndH3Datagrams();
    internal void set_EnableWebTransportAndH3Datagrams(bool value);
    internal bool get_DisableHttp1LineFeedTerminators();
    internal void set_DisableHttp1LineFeedTerminators(bool value);
    public void ConfigureEndpointDefaults(Action`1<ListenOptions> configureOptions);
    internal void ApplyEndpointDefaults(ListenOptions listenOptions);
    public void ConfigureHttpsDefaults(Action`1<HttpsConnectionAdapterOptions> configureOptions);
    internal void ApplyHttpsDefaults(HttpsConnectionAdapterOptions httpsOptions);
    internal void ApplyDefaultCertificate(HttpsConnectionAdapterOptions httpsOptions);
    internal void EnableHttpsConfiguration();
    internal void Serialize(Utf8JsonWriter writer);
    private static X509Certificate2 GetDevelopmentCertificateFromStore(ILogger`1<KestrelServer> logger);
    public KestrelConfigurationLoader Configure();
    public KestrelConfigurationLoader Configure(IConfiguration config);
    public KestrelConfigurationLoader Configure(IConfiguration config, bool reloadOnChange);
    public void Listen(IPAddress address, int port);
    public void Listen(IPAddress address, int port, Action`1<ListenOptions> configure);
    public void Listen(IPEndPoint endPoint);
    public void Listen(EndPoint endPoint);
    public void Listen(IPEndPoint endPoint, Action`1<ListenOptions> configure);
    public void Listen(EndPoint endPoint, Action`1<ListenOptions> configure);
    public void ListenLocalhost(int port);
    public void ListenLocalhost(int port, Action`1<ListenOptions> configure);
    public void ListenAnyIP(int port);
    public void ListenAnyIP(int port, Action`1<ListenOptions> configure);
    public void ListenUnixSocket(string socketPath);
    public void ListenUnixSocket(string socketPath, Action`1<ListenOptions> configure);
    public void ListenHandle(ulong handle);
    public void ListenHandle(ulong handle, Action`1<ListenOptions> configure);
    public void ListenNamedPipe(string pipeName);
    public void ListenNamedPipe(string pipeName, Action`1<ListenOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions : object {
    internal static HttpProtocols DefaultHttpProtocols;
    private List`1<Func`2<ConnectionDelegate, ConnectionDelegate>> _middleware;
    private List`1<Func`2<MultiplexedConnectionDelegate, MultiplexedConnectionDelegate>> _multiplexedMiddleware;
    private HttpProtocols _protocols;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointConfig <EndpointConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <KestrelServerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProtocolsSetExplicitly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAltSvcHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTls>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpsConnectionAdapterOptions <HttpsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TlsHandshakeCallbackOptions <HttpsCallbackOptions>k__BackingField;
    public EndPoint EndPoint { get; internal set; }
    [NullableAttribute("2")]
internal EndpointConfig EndpointConfig { get; internal set; }
    [NullableAttribute("2")]
public IPEndPoint IPEndPoint { get; }
    [NullableAttribute("2")]
public string SocketPath { get; }
    [NullableAttribute("2")]
public string PipeName { get; }
    public ulong FileHandle { get; }
    public KestrelServerOptions KestrelServerOptions { get; internal set; }
    public HttpProtocols Protocols { get; public set; }
    internal bool ProtocolsSetExplicitly { get; private set; }
    public bool DisableAltSvcHeader { get; public set; }
    public IServiceProvider ApplicationServices { get; }
    internal string Scheme { get; }
    internal bool IsTls { get; internal set; }
    [NullableAttribute("2")]
internal HttpsConnectionAdapterOptions HttpsOptions { get; internal set; }
    [NullableAttribute("2")]
internal TlsHandshakeCallbackOptions HttpsCallbackOptions { get; internal set; }
    internal ListenOptions(EndPoint endPoint);
    internal ListenOptions(string socketPath);
    internal ListenOptions(ulong fileHandle);
    internal ListenOptions(ulong fileHandle, FileHandleType handleType);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
internal void set_EndPoint(EndPoint value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal EndpointConfig get_EndpointConfig();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_EndpointConfig(EndpointConfig value);
    [NullableContextAttribute("2")]
public IPEndPoint get_IPEndPoint();
    [NullableContextAttribute("2")]
public string get_SocketPath();
    [NullableContextAttribute("2")]
public string get_PipeName();
    public ulong get_FileHandle();
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_KestrelServerOptions();
    [CompilerGeneratedAttribute]
internal void set_KestrelServerOptions(KestrelServerOptions value);
    public HttpProtocols get_Protocols();
    public void set_Protocols(HttpProtocols value);
    [CompilerGeneratedAttribute]
internal bool get_ProtocolsSetExplicitly();
    [CompilerGeneratedAttribute]
private void set_ProtocolsSetExplicitly(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableAltSvcHeader();
    [CompilerGeneratedAttribute]
public void set_DisableAltSvcHeader(bool value);
    public sealed virtual IServiceProvider get_ApplicationServices();
    internal string get_Scheme();
    [CompilerGeneratedAttribute]
internal bool get_IsTls();
    [CompilerGeneratedAttribute]
internal void set_IsTls(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal HttpsConnectionAdapterOptions get_HttpsOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_HttpsOptions(HttpsConnectionAdapterOptions value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal TlsHandshakeCallbackOptions get_HttpsCallbackOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_HttpsCallbackOptions(TlsHandshakeCallbackOptions value);
    internal virtual string GetDisplayName();
    [NullableContextAttribute("2")]
public virtual string ToString();
    public sealed virtual IConnectionBuilder Use(Func`2<ConnectionDelegate, ConnectionDelegate> middleware);
    private sealed virtual override IMultiplexedConnectionBuilder Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder.Use(Func`2<MultiplexedConnectionDelegate, MultiplexedConnectionDelegate> middleware);
    public sealed virtual ConnectionDelegate Build();
    private sealed virtual override MultiplexedConnectionDelegate Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder.Build();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions/<BindAsync>d__61")]
internal virtual Task BindAsync(AddressBindContext context, CancellationToken cancellationToken);
    protected internal ListenOptions Clone(IPAddress address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.LocalhostListenOptions : ListenOptions {
    internal LocalhostListenOptions(int port);
    internal virtual string GetDisplayName();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Core.LocalhostListenOptions/<BindAsync>d__2")]
internal virtual Task BindAsync(AddressBindContext context, CancellationToken cancellationToken);
}
public class Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate : object {
    [CompilerGeneratedAttribute]
private double <BytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <GracePeriod>k__BackingField;
    public double BytesPerSecond { get; }
    public TimeSpan GracePeriod { get; }
    public MinDataRate(double bytesPerSecond, TimeSpan gracePeriod);
    [CompilerGeneratedAttribute]
public double get_BytesPerSecond();
    [CompilerGeneratedAttribute]
public TimeSpan get_GracePeriod();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Core.TlsConfigurationLoader : object {
    private ICertificateConfigLoader _certificateConfigLoader;
    private string _applicationName;
    private ILogger`1<KestrelServer> _serverLogger;
    private ILogger`1<HttpsConnectionMiddleware> _httpsLogger;
    public TlsConfigurationLoader(IHostEnvironment hostEnvironment, ILogger`1<KestrelServer> serverLogger, ILogger`1<HttpsConnectionMiddleware> httpsLogger);
    public void ApplyHttpsConfiguration(HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint, KestrelServerOptions serverOptions, CertificateConfig defaultCertificateConfig, ConfigurationReader configurationReader);
    public ListenOptions UseHttpsWithSni(ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions, EndpointConfig endpoint);
    public Nullable`1<CertificateAndConfig> LoadDefaultCertificate(ConfigurationReader configurationReader);
    private Nullable`1<CertificateAndConfig> FindDeveloperCertificateFile(ConfigurationReader configurationReader);
    private static bool IsDevelopmentCertificate(X509Certificate2 certificate);
    private static bool TryGetCertificatePath(string applicationName, String& path);
}
internal enum Microsoft.AspNetCore.Server.Kestrel.Core.WebTransport.WebTransportStreamType : Enum {
    public int value__;
    public static WebTransportStreamType Bidirectional;
    public static WebTransportStreamType Input;
    public static WebTransportStreamType Output;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <IsHttps>k__BackingField;
    [CompilerGeneratedAttribute]
private ListenOptions <ListenOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpsConnectionAdapterOptions <HttpsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationSection <ConfigSection>k__BackingField;
    public bool IsHttps { get; }
    public ListenOptions ListenOptions { get; }
    public HttpsConnectionAdapterOptions HttpsOptions { get; }
    public IConfigurationSection ConfigSection { get; }
    internal EndpointConfiguration(bool isHttps, ListenOptions listenOptions, HttpsConnectionAdapterOptions httpsOptions, IConfigurationSection configSection);
    [CompilerGeneratedAttribute]
public bool get_IsHttps();
    [CompilerGeneratedAttribute]
public ListenOptions get_ListenOptions();
    [CompilerGeneratedAttribute]
public HttpsConnectionAdapterOptions get_HttpsOptions();
    [CompilerGeneratedAttribute]
public IConfigurationSection get_ConfigSection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.AspNetCore.Server.Kestrel.Https.CertificateLoader : object {
    private static string ServerAuthenticationOid;
    public static X509Certificate2 LoadFromStoreCert(string subject, string storeName, StoreLocation storeLocation, bool allowInvalid);
    internal static bool IsCertificateAllowedForServerAuth(X509Certificate2 certificate);
    internal static bool DoesCertificateHaveAnAccessiblePrivateKey(X509Certificate2 certificate);
    internal static bool DoesCertificateHaveASubjectAlternativeName(X509Certificate2 certificate);
    private static void DisposeCertificates(X509Certificate2Collection certificates, X509Certificate2 except);
}
public enum Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode : Enum {
    public int value__;
    public static ClientCertificateMode NoCertificate;
    public static ClientCertificateMode AllowCertificate;
    public static ClientCertificateMode RequireCertificate;
    public static ClientCertificateMode DelayCertificate;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions : object {
    internal static TimeSpan DefaultHandshakeTimeout;
    private TimeSpan _handshakeTimeout;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <ServerCertificateChain>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<ConnectionContext, string, X509Certificate2> <ServerCertificateSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientCertificateMode <ClientCertificateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> <ClientCertificateValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<ConnectionContext, SslServerAuthenticationOptions> <OnAuthenticate>k__BackingField;
    public X509Certificate2 ServerCertificate { get; public set; }
    public X509Certificate2Collection ServerCertificateChain { get; public set; }
    public Func`3<ConnectionContext, string, X509Certificate2> ServerCertificateSelector { get; public set; }
    internal bool HasServerCertificateOrSelector { get; }
    public ClientCertificateMode ClientCertificateMode { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> ClientCertificateValidation { get; public set; }
    public SslProtocols SslProtocols { get; public set; }
    public bool CheckCertificateRevocation { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<ConnectionContext, SslServerAuthenticationOptions> OnAuthenticate { get; public set; }
    public TimeSpan HandshakeTimeout { get; public set; }
    private static HttpsConnectionAdapterOptions();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_ServerCertificateChain();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateChain(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public Func`3<ConnectionContext, string, X509Certificate2> get_ServerCertificateSelector();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelector(Func`3<ConnectionContext, string, X509Certificate2> value);
    internal bool get_HasServerCertificateOrSelector();
    [CompilerGeneratedAttribute]
public ClientCertificateMode get_ClientCertificateMode();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateMode(ClientCertificateMode value);
    [CompilerGeneratedAttribute]
public Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ClientCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateValidation(Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    [CompilerGeneratedAttribute]
public SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public bool get_CheckCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_CheckCertificateRevocation(bool value);
    public void AllowAnyClientCertificate();
    [CompilerGeneratedAttribute]
public Action`2<ConnectionContext, SslServerAuthenticationOptions> get_OnAuthenticate();
    [CompilerGeneratedAttribute]
public void set_OnAuthenticate(Action`2<ConnectionContext, SslServerAuthenticationOptions> value);
    public TimeSpan get_HandshakeTimeout();
    public void set_HandshakeTimeout(TimeSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware : object {
    private static string EnableWindows81Http2;
    private static bool _isWindowsVersionIncompatibleWithHttp2;
    private ConnectionDelegate _next;
    private TimeSpan _handshakeTimeout;
    private ILogger`1<HttpsConnectionMiddleware> _logger;
    private Func`2<Stream, SslStream> _sslStreamFactory;
    private HttpsConnectionAdapterOptions _options;
    private KestrelMetrics _metrics;
    private SslStreamCertificateContext _serverCertificateContext;
    private X509Certificate2 _serverCertificate;
    private Func`3<ConnectionContext, string, X509Certificate2> _serverCertificateSelector;
    private Func`2<TlsHandshakeCallbackContext, ValueTask`1<SslServerAuthenticationOptions>> _tlsCallbackOptions;
    private object _tlsCallbackOptionsState;
    internal HttpProtocols _httpProtocols;
    private CancellationTokenSourcePool _ctsPool;
    public HttpsConnectionMiddleware(ConnectionDelegate next, HttpsConnectionAdapterOptions options, HttpProtocols httpProtocols, KestrelMetrics metrics);
    public HttpsConnectionMiddleware(ConnectionDelegate next, HttpsConnectionAdapterOptions options, HttpProtocols httpProtocols, ILoggerFactory loggerFactory, KestrelMetrics metrics);
    internal HttpsConnectionMiddleware(ConnectionDelegate next, TlsHandshakeCallbackOptions tlsCallbackOptions, ILoggerFactory loggerFactory, KestrelMetrics metrics);
    private static HttpsConnectionMiddleware();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware/<OnConnectionAsync>d__18")]
public Task OnConnectionAsync(ConnectionContext context);
    private X509Certificate2 LocateCertificateWithPrivateKey(X509Certificate2 certificate);
    private Task DoOptionsBasedHandshakeAsync(ConnectionContext context, SslStream sslStream, TlsConnectionFeature feature, CancellationToken cancellationToken);
    internal static void ConfigureAlpn(SslServerAuthenticationOptions serverOptions, HttpProtocols httpProtocols);
    [NullableContextAttribute("2")]
internal static bool RemoteCertificateValidationCallback(ClientCertificateMode clientCertificateMode, Func`4<X509Certificate2, X509Chain, SslPolicyErrors, bool> clientCertificateValidation, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private bool RemoteCertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private SslDuplexPipe CreateSslDuplexPipe(IDuplexPipe transport, MemoryPool`1<byte> memoryPool);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware/<ServerOptionsCallback>d__25")]
private static ValueTask`1<SslServerAuthenticationOptions> ServerOptionsCallback(SslStream sslStream, SslClientHelloInfo clientHelloInfo, object state, CancellationToken cancellationToken);
    internal static void EnsureCertificateIsAllowedForServerAuth(X509Certificate2 certificate, ILogger`1<HttpsConnectionMiddleware> logger);
    private static X509Certificate2 ConvertToX509Certificate2(X509Certificate certificate);
    internal static HttpProtocols ValidateAndNormalizeHttpProtocols(HttpProtocols httpProtocols, ILogger`1<HttpsConnectionMiddleware> logger);
    private static bool IsWindowsVersionIncompatibleWithHttp2();
    internal static SslServerAuthenticationOptions CreateHttp3Options(HttpsConnectionAdapterOptions httpsOptions, ILogger`1<HttpsConnectionMiddleware> logger);
    [CompilerGeneratedAttribute]
internal static void <OnConnectionAsync>g__RecordHandshakeFailed|18_0(KestrelMetrics metrics, long startTimestamp, long currentTimestamp, ConnectionMetricsContext metricsContext, Exception ex);
    [CompilerGeneratedAttribute]
private X509Store <LocateCertificateWithPrivateKey>g__OpenStore|19_0(StoreLocation storeLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddlewareLoggerExtensions : object {
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __AuthenticationFailedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __AuthenticationTimedOutCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, SslProtocols, Exception> __HttpsConnectionEstablishedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __Http2DefaultCiphersInsufficientCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __LocatingCertWithPrivateKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __FoundCertWithPrivateKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __FailedToFindCertificateInStoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __FailedToOpenStoreCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __NoSubjectAlternativeNameCallback;
    private static HttpsConnectionMiddlewareLoggerExtensions();
    [ExtensionAttribute]
[LoggerMessageAttribute("1", "1", "Failed to authenticate HTTPS connection.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void AuthenticationFailed(ILogger`1<HttpsConnectionMiddleware> logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("2", "1", "Authentication of the HTTPS connection timed out.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void AuthenticationTimedOut(ILogger`1<HttpsConnectionMiddleware> logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("3", "1", "Connection {ConnectionId} established using the following protocol: {Protocol}")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void HttpsConnectionEstablished(ILogger`1<HttpsConnectionMiddleware> logger, string connectionId, SslProtocols protocol);
    [ExtensionAttribute]
[LoggerMessageAttribute("4", "2", "HTTP/2 over TLS is not supported on Windows versions older than Windows 10 and Windows Server 2016 due to incompatible ciphers or missing ALPN support. Falling back to HTTP/1.1 instead.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void Http2DefaultCiphersInsufficient(ILogger`1<HttpsConnectionMiddleware> logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("5", "1", "Searching for certificate with private key and thumbprint {Thumbprint} in the certificate store.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static void LocatingCertWithPrivateKey(ILogger`1<HttpsConnectionMiddleware> logger, string thumbPrint);
    [ExtensionAttribute]
public static void LocatingCertWithPrivateKey(ILogger`1<HttpsConnectionMiddleware> logger, X509Certificate2 certificate);
    [ExtensionAttribute]
[LoggerMessageAttribute("6", "1", "Found certificate with private key and thumbprint {Thumbprint} in certificate store {StoreName}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FoundCertWithPrivateKey(ILogger`1<HttpsConnectionMiddleware> logger, string thumbprint, string storeName);
    [ExtensionAttribute]
public static void FoundCertWithPrivateKey(ILogger`1<HttpsConnectionMiddleware> logger, X509Certificate2 certificate, StoreLocation storeLocation);
    [ExtensionAttribute]
[LoggerMessageAttribute("7", "1", "Failure to locate certificate from store.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToFindCertificateInStore(ILogger`1<HttpsConnectionMiddleware> logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("8", "1", "Failed to open certificate store {StoreName}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FailedToOpenStore(ILogger`1<HttpsConnectionMiddleware> logger, string storeName, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("9", "2", "Certificate with thumbprint {Thumbprint} lacks the subjectAlternativeName (SAN) extension and may not be accepted by browsers.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NoSubjectAlternativeName(ILogger`1<HttpsConnectionMiddleware> logger, string thumbprint);
    [ExtensionAttribute]
public static void FailedToOpenStore(ILogger`1<HttpsConnectionMiddleware> logger, StoreLocation storeLocation, Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.AspNetCore.Server.Kestrel.Https.Internal.SslDuplexPipe : DuplexPipeStreamAdapter`1<SslStream> {
    public SslDuplexPipe(IDuplexPipe transport, StreamPipeReaderOptions readerOptions, StreamPipeWriterOptions writerOptions);
    public SslDuplexPipe(IDuplexPipe transport, StreamPipeReaderOptions readerOptions, StreamPipeWriterOptions writerOptions, Func`2<Stream, SslStream> factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext : object {
    [CompilerGeneratedAttribute]
private SslStream <SslStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SslClientHelloInfo <ClientHelloInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionContext <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDelayedClientCertificateNegotation>k__BackingField;
    public SslStream SslStream { get; internal set; }
    public SslClientHelloInfo ClientHelloInfo { get; internal set; }
    [NullableAttribute("2")]
public object State { get; internal set; }
    public CancellationToken CancellationToken { get; internal set; }
    public ConnectionContext Connection { get; internal set; }
    public bool AllowDelayedClientCertificateNegotation { get; public set; }
    [CompilerGeneratedAttribute]
public SslStream get_SslStream();
    [CompilerGeneratedAttribute]
internal void set_SslStream(SslStream value);
    [CompilerGeneratedAttribute]
public SslClientHelloInfo get_ClientHelloInfo();
    [CompilerGeneratedAttribute]
internal void set_ClientHelloInfo(SslClientHelloInfo value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_State();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_State(object value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public ConnectionContext get_Connection();
    [CompilerGeneratedAttribute]
internal void set_Connection(ConnectionContext value);
    [CompilerGeneratedAttribute]
public bool get_AllowDelayedClientCertificateNegotation();
    [CompilerGeneratedAttribute]
public void set_AllowDelayedClientCertificateNegotation(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions : object {
    private TimeSpan _handshakeTimeout;
    [CompilerGeneratedAttribute]
private Func`2<TlsHandshakeCallbackContext, ValueTask`1<SslServerAuthenticationOptions>> <OnConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OnConnectionState>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <HttpProtocols>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<TlsHandshakeCallbackContext, ValueTask`1<SslServerAuthenticationOptions>> OnConnection { get; public set; }
    public object OnConnectionState { get; public set; }
    public TimeSpan HandshakeTimeout { get; public set; }
    internal HttpProtocols HttpProtocols { get; internal set; }
    [CompilerGeneratedAttribute]
public Func`2<TlsHandshakeCallbackContext, ValueTask`1<SslServerAuthenticationOptions>> get_OnConnection();
    [CompilerGeneratedAttribute]
public void set_OnConnection(Func`2<TlsHandshakeCallbackContext, ValueTask`1<SslServerAuthenticationOptions>> value);
    [CompilerGeneratedAttribute]
public object get_OnConnectionState();
    [CompilerGeneratedAttribute]
public void set_OnConnectionState(object value);
    public TimeSpan get_HandshakeTimeout();
    public void set_HandshakeTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
internal HttpProtocols get_HttpProtocols();
    [CompilerGeneratedAttribute]
internal void set_HttpProtocols(HttpProtocols value);
}
internal interface Microsoft.AspNetCore.Server.Kestrel.IPooledStream {
    public long PoolExpirationTimestamp { get; }
    public abstract virtual long get_PoolExpirationTimestamp();
    public abstract virtual void DisposeCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader : object {
    private IHttpsConfigurationService _httpsConfigurationService;
    private CertificatePathWatcher _certificatePathWatcher;
    private bool _loaded;
    private bool _endpointsToAddProcessed;
    private IChangeToken _reloadToken;
    [CompilerGeneratedAttribute]
private KestrelServerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReloadOnChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationReader <ConfigurationReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Action`1<EndpointConfiguration>> <EndpointConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Action> <EndpointsToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateConfig <DefaultCertificateConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <DefaultCertificate>k__BackingField;
    public KestrelServerOptions Options { get; }
    public IConfiguration Configuration { get; internal set; }
    internal bool ReloadOnChange { get; }
    private ConfigurationReader ConfigurationReader { get; private set; }
    private IDictionary`2<string, Action`1<EndpointConfiguration>> EndpointConfigurations { get; }
    private IList`1<Action> EndpointsToAdd { get; }
    [NullableAttribute("2")]
private CertificateConfig DefaultCertificateConfig { get; private set; }
    [NullableAttribute("2")]
internal X509Certificate2 DefaultCertificate { get; internal set; }
    internal KestrelConfigurationLoader(KestrelServerOptions options, IConfiguration configuration, IHttpsConfigurationService httpsConfigurationService, CertificatePathWatcher certificatePathWatcher, bool reloadOnChange);
    [CompilerGeneratedAttribute]
public KestrelServerOptions get_Options();
    [CompilerGeneratedAttribute]
public IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
internal void set_Configuration(IConfiguration value);
    [CompilerGeneratedAttribute]
internal bool get_ReloadOnChange();
    [CompilerGeneratedAttribute]
private ConfigurationReader get_ConfigurationReader();
    [CompilerGeneratedAttribute]
private void set_ConfigurationReader(ConfigurationReader value);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Action`1<EndpointConfiguration>> get_EndpointConfigurations();
    [CompilerGeneratedAttribute]
private IList`1<Action> get_EndpointsToAdd();
    [CompilerGeneratedAttribute]
private CertificateConfig get_DefaultCertificateConfig();
    [CompilerGeneratedAttribute]
private void set_DefaultCertificateConfig(CertificateConfig value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal X509Certificate2 get_DefaultCertificate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DefaultCertificate(X509Certificate2 value);
    public KestrelConfigurationLoader Endpoint(string name, Action`1<EndpointConfiguration> configureOptions);
    public KestrelConfigurationLoader Endpoint(IPAddress address, int port);
    public KestrelConfigurationLoader Endpoint(IPAddress address, int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader Endpoint(IPEndPoint endPoint);
    public KestrelConfigurationLoader Endpoint(IPEndPoint endPoint, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader LocalhostEndpoint(int port);
    public KestrelConfigurationLoader LocalhostEndpoint(int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader AnyIPEndpoint(int port);
    public KestrelConfigurationLoader AnyIPEndpoint(int port, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader UnixSocketEndpoint(string socketPath);
    public KestrelConfigurationLoader UnixSocketEndpoint(string socketPath, Action`1<ListenOptions> configure);
    public KestrelConfigurationLoader HandleEndpoint(ulong handle);
    public KestrelConfigurationLoader HandleEndpoint(ulong handle, Action`1<ListenOptions> configure);
    internal void ApplyEndpointDefaults(ListenOptions listenOptions);
    internal void ApplyHttpsDefaults(HttpsConnectionAdapterOptions httpsOptions);
    public void Load();
    internal void LoadInternal();
    internal void ProcessEndpointsToAdd();
    [NullableContextAttribute("2")]
internal IChangeToken GetReloadToken();
    internal ValueTuple`2<List`1<ListenOptions>, List`1<ListenOptions>> Reload();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.Server.Kestrel.PooledStreamStack`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal StreamAsValueType[] _array;
    private int _size;
    public int Count { get; }
    public PooledStreamStack`1(int size);
    [IsReadOnlyAttribute]
public int get_Count();
    [NullableContextAttribute("2")]
public bool TryPop(TValue& result);
    [NullableContextAttribute("2")]
public bool TryPeek(TValue& result);
    public void Push(TValue item);
    private void PushWithResize(TValue item);
    public void RemoveExpired(long timestamp);
    private static int CalculateRemoveCount(long timestamp, int size, StreamAsValueType[] array);
}
internal static class Microsoft.AspNetCore.Server.SharedStrings : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Http2ErrorUnexpectedFrameLength { get; }
    internal static string Http2ErrorFrameOverLimit { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_Http2ErrorUnexpectedFrameLength();
    internal static string FormatHttp2ErrorUnexpectedFrameLength(object frameType, object expectedLength);
    internal static string get_Http2ErrorFrameOverLimit();
    internal static string FormatHttp2ErrorFrameOverLimit(object size, object limit);
}
[ExtensionAttribute]
internal static class System.Buffers.BufferExtensions : object {
    private static int _maxULongByteLength;
    [ThreadStaticAttribute]
private static Byte[] _numericBytesScratch;
    [NullableAttribute("1")]
private static Byte[] NumericBytesScratch { get; }
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> ToSpan(ReadOnlySequence`1& buffer);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& buffer, PipeWriter pipeWriter);
    private static void CopyToMultiSegment(ReadOnlySequence`1& buffer, PipeWriter pipeWriter);
    [ExtensionAttribute]
public static ArraySegment`1<byte> GetArray(Memory`1<byte> buffer);
    [ExtensionAttribute]
public static ArraySegment`1<byte> GetArray(ReadOnlyMemory`1<byte> memory);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOfAny(ReadOnlySequence`1& source, T value0, T value1);
    private static Nullable`1<SequencePosition> PositionOfAnyMultiSegment(ReadOnlySequence`1& source, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void WriteAscii(BufferWriter`1& buffer, string data);
    [ExtensionAttribute]
internal static void WriteNumeric(BufferWriter`1& buffer, ulong number);
    [ExtensionAttribute]
private static void WriteNumericMultiWrite(BufferWriter`1& buffer, ulong number);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void WriteEncoded(BufferWriter`1& buffer, string data, Encoding encoding);
    [ExtensionAttribute]
private static void WriteEncodedMultiWrite(BufferWriter`1& buffer, string data, int encodedLength, Encoding encoding);
    private static Byte[] get_NumericBytesScratch();
    private static Byte[] CreateNumericBytesScratch();
}
internal class System.Buffers.BuffersThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Buffers.BufferWriter`1 : ValueType {
    private T _output;
    private Span`1<byte> _span;
    private int _buffered;
    private long _bytesCommitted;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    [NullableContextAttribute("1")]
public BufferWriter`1(T output);
    [IsReadOnlyAttribute]
public Span`1<byte> get_Span();
    [IsReadOnlyAttribute]
public long get_BytesCommitted();
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.BufferSegment : ReadOnlySequenceSegment`1<byte> {
    private object _memoryOwner;
    private BufferSegment _next;
    private int _end;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <AvailableMemory>k__BackingField;
    public int End { get; public set; }
    [NullableAttribute("2")]
public BufferSegment NextSegment { get; public set; }
    [NullableAttribute("2")]
internal object MemoryOwner { get; }
    [NullableAttribute("0")]
public Memory`1<byte> AvailableMemory { get; private set; }
    public int Length { get; }
    public int WritableBytes { get; }
    public int get_End();
    public void set_End(int value);
    [NullableContextAttribute("2")]
public BufferSegment get_NextSegment();
    [NullableContextAttribute("2")]
public void set_NextSegment(BufferSegment value);
    public void SetOwnedMemory(IMemoryOwner`1<byte> memoryOwner);
    public void SetOwnedMemory(Byte[] arrayPoolBuffer);
    public void ResetMemory();
    [NullableContextAttribute("2")]
internal object get_MemoryOwner();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Memory`1<byte> get_AvailableMemory();
    [CompilerGeneratedAttribute]
private void set_AvailableMemory(Memory`1<byte> value);
    public int get_Length();
    public int get_WritableBytes();
    public void SetNext(BufferSegment segment);
    internal static long GetLength(BufferSegment startSegment, int startIndex, BufferSegment endSegment, int endIndex);
    internal static long GetLength(long startPosition, BufferSegment endSegment, int endIndex);
}
internal class System.IO.Pipelines.BufferSegmentStack : ValueType {
    private SegmentAsValueType[] _array;
    private int _size;
    public int Count { get; }
    public BufferSegmentStack(int size);
    [IsReadOnlyAttribute]
public int get_Count();
    [NullableContextAttribute("2")]
public bool TryPop(BufferSegment& result);
    [NullableContextAttribute("1")]
public void Push(BufferSegment item);
    private void PushWithResize(BufferSegment item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.DuplexPipe : object {
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public DuplexPipe(PipeReader reader, PipeWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    public static DuplexPipePair CreateConnectionPair(PipeOptions inputOptions, PipeOptions outputOptions);
}
internal class System.Net.Http.HPack.DynamicHPackEncoder : object {
    public static int DefaultHeaderTableSize;
    [NullableAttribute("1")]
internal EncoderHeaderEntry Head;
    private bool _allowDynamicCompression;
    private EncoderHeaderEntry[] _headerBuckets;
    private byte _hashMask;
    private UInt32 _headerTableSize;
    private UInt32 _maxHeaderTableSize;
    private bool _pendingTableSizeUpdate;
    private EncoderHeaderEntry _removed;
    internal UInt32 TableSize { get; }
    public DynamicHPackEncoder(bool allowDynamicCompression, UInt32 maxHeaderTableSize);
    internal UInt32 get_TableSize();
    public void UpdateMaxHeaderTableSize(UInt32 maxHeaderTableSize);
    public bool EnsureDynamicTableSizeUpdate(Span`1<byte> buffer, Int32& length);
    [NullableContextAttribute("1")]
public bool EncodeHeader(Span`1<byte> buffer, int staticTableIndex, HeaderEncodingHint encodingHint, string name, string value, Encoding valueEncoding, Int32& bytesWritten);
    private int ResolveDynamicTableIndex(int staticTableIndex, string name);
    private bool EncodeDynamicHeader(Span`1<byte> buffer, int staticTableIndex, string name, string value, int headerLength, Encoding valueEncoding, Int32& bytesWritten);
    private void EnsureCapacity(UInt32 headerSize);
    private EncoderHeaderEntry GetEntry(string name, string value);
    private int CalculateDynamicTableIndex(string name);
    private int CalculateDynamicTableIndex(int index);
    private void AddHeaderEntry(string name, string value, UInt32 headerSize);
    private void PushRemovedEntry(EncoderHeaderEntry removed);
    private EncoderHeaderEntry PopRemovedEntry();
    private EncoderHeaderEntry RemoveHeaderEntry();
    private int CalculateBucketIndex(int hash);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.Http.HPack.DynamicTable : object {
    private HeaderField[] _buffer;
    private int _maxSize;
    private int _size;
    private int _count;
    private int _insertIndex;
    private int _removeIndex;
    public int Count { get; }
    public int Size { get; }
    public int MaxSize { get; }
    [IsReadOnlyAttribute]
public HeaderField& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public DynamicTable(int maxSize);
    public int get_Count();
    public int get_Size();
    public int get_MaxSize();
    public HeaderField& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public void Insert(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public void Insert(Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public void Resize(int maxSize);
    private void EnsureAvailable(int available);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Name = {Name} Value = {Value}")]
internal class System.Net.Http.HPack.EncoderHeaderEntry : object {
    public string Name;
    public string Value;
    public UInt32 Size;
    public EncoderHeaderEntry Next;
    public int Hash;
    public int Index;
    public EncoderHeaderEntry Before;
    public EncoderHeaderEntry After;
    [NullableContextAttribute("1")]
public void Initialize(int hash, string name, string value, UInt32 size, int index, EncoderHeaderEntry next);
    public void Remove();
    [NullableContextAttribute("1")]
public void AddBefore(EncoderHeaderEntry existingEntry);
}
internal static class System.Net.Http.HPack.H2StaticTable : object {
    public static int Authority;
    public static int MethodGet;
    public static int MethodPost;
    public static int PathSlash;
    public static int SchemeHttp;
    public static int SchemeHttps;
    public static int Status200;
    public static int AcceptCharset;
    public static int AcceptEncoding;
    public static int AcceptLanguage;
    public static int AcceptRanges;
    public static int Accept;
    public static int AccessControlAllowOrigin;
    public static int Age;
    public static int Allow;
    public static int Authorization;
    public static int CacheControl;
    public static int ContentDisposition;
    public static int ContentEncoding;
    public static int ContentLanguage;
    public static int ContentLength;
    public static int ContentLocation;
    public static int ContentRange;
    public static int ContentType;
    public static int Cookie;
    public static int Date;
    public static int ETag;
    public static int Expect;
    public static int Expires;
    public static int From;
    public static int Host;
    public static int IfMatch;
    public static int IfModifiedSince;
    public static int IfNoneMatch;
    public static int IfRange;
    public static int IfUnmodifiedSince;
    public static int LastModified;
    public static int Link;
    public static int Location;
    public static int MaxForwards;
    public static int ProxyAuthenticate;
    public static int ProxyAuthorization;
    public static int Range;
    public static int Referer;
    public static int Refresh;
    public static int RetryAfter;
    public static int Server;
    public static int SetCookie;
    public static int StrictTransportSecurity;
    public static int TransferEncoding;
    public static int UserAgent;
    public static int Vary;
    public static int Via;
    public static int WwwAuthenticate;
    private static HeaderField[] s_staticDecoderTable;
    public static int Count { get; }
    private static H2StaticTable();
    public static int get_Count();
    public static HeaderField& modreq(System.Runtime.InteropServices.InAttribute) Get(int index);
    public static bool TryGetStatusIndex(int status, Int32& index);
    private static HeaderField CreateHeaderField(int staticTableIndex, string name, string value);
}
internal enum System.Net.Http.HPack.HeaderEncodingHint : Enum {
    public int value__;
    public static HeaderEncodingHint Index;
    public static HeaderEncodingHint IgnoreIndex;
    public static HeaderEncodingHint NeverIndex;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Net.Http.HPack.HeaderField : ValueType {
    public static int RfcOverhead;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StaticTableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Nullable`1<int> StaticTableIndex { get; }
    public Byte[] Name { get; }
    public Byte[] Value { get; }
    public int Length { get; }
    [NullableContextAttribute("0")]
public HeaderField(Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StaticTableIndex();
    [CompilerGeneratedAttribute]
public Byte[] get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public int get_Length();
    public static int GetLength(int nameLength, int valueLength);
    public virtual string ToString();
}
internal class System.Net.Http.HPack.HPackDecoder : object {
    public static int DefaultHeaderTableSize;
    public static int DefaultStringOctetsSize;
    public static int DefaultMaxHeadersLength;
    private static byte IndexedHeaderFieldMask;
    private static byte LiteralHeaderFieldWithIncrementalIndexingMask;
    private static byte LiteralHeaderFieldWithoutIndexingMask;
    private static byte LiteralHeaderFieldNeverIndexedMask;
    private static byte DynamicTableSizeUpdateMask;
    private static byte HuffmanMask;
    private static int IndexedHeaderFieldPrefix;
    private static int LiteralHeaderFieldWithIncrementalIndexingPrefix;
    private static int LiteralHeaderFieldWithoutIndexingPrefix;
    private static int LiteralHeaderFieldNeverIndexedPrefix;
    private static int DynamicTableSizeUpdatePrefix;
    private static int StringLengthPrefix;
    private int _maxDynamicTableSize;
    private int _maxHeadersLength;
    private DynamicTable _dynamicTable;
    private IntegerDecoder _integerDecoder;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerNameRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerValueRange;
    private State _state;
    private Byte[] _headerName;
    private int _headerStaticIndex;
    private int _stringIndex;
    private int _stringLength;
    private int _headerNameLength;
    private int _headerValueLength;
    private bool _index;
    private bool _huffman;
    private bool _headersObserved;
    public HPackDecoder(int maxDynamicTableSize, int maxHeadersLength);
    [NullableContextAttribute("1")]
internal HPackDecoder(int maxDynamicTableSize, int maxHeadersLength, DynamicTable dynamicTable);
    public void Decode(ReadOnlySequence`1& data, bool endHeaders, IHttpStreamHeadersHandler handler);
    public void Decode(ReadOnlySpan`1<byte> data, bool endHeaders, IHttpStreamHeadersHandler handler);
    private void DecodeInternal(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void ParseDynamicTableSizeUpdate(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParseHeaderValueLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderFieldIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void Parse(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseLiteralHeaderField(ReadOnlySpan`1<byte> data, Int32& currentIndex, byte b, byte mask, byte indexPrefix, bool index, IHttpStreamHeadersHandler handler);
    private void ParseHeaderName(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void CheckIncompleteHeaderBlock(bool endHeaders);
    private void ProcessHeaderValue(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    public void CompleteDecode();
    private void OnIndexedHeaderField(int index, IHttpStreamHeadersHandler handler);
    private void OnIndexedHeaderName(int index);
    private void OnStringLength(int length, State nextState);
    private void OnString(State nextState);
    private void EnsureStringCapacity(Byte[]& dst, int stringLength);
    private bool TryDecodeInteger(ReadOnlySpan`1<byte> data, Int32& currentIndex, Int32& result);
    private static bool IsHuffmanEncoded(byte b);
    private HeaderField& modreq(System.Runtime.InteropServices.InAttribute) GetDynamicHeader(int index);
    private void SetDynamicHeaderTableSize(int size);
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|57_0(Byte[]& dst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Net.Http.HPack.HPackDecodingException : Exception {
    public HPackDecodingException(string message);
    public HPackDecodingException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public HPackDecodingException(SerializationInfo info, StreamingContext context);
}
internal static class System.Net.Http.HPack.HPackEncoder : object {
    public static bool EncodeIndexedHeaderField(int index, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeStatusHeader(int statusCode, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexing(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldNeverIndexing(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldIndexing(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexing(int index, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool EncodeLiteralHeaderFieldIndexingNewName(string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool EncodeLiteralHeaderFieldNeverIndexingNewName(string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    private static bool EncodeLiteralHeaderNewNameCore(byte mask, string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, ReadOnlySpan`1<string> values, string separator, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, Span`1<byte> destination, Int32& bytesWritten);
    private static bool EncodeLiteralHeaderName(string value, Span`1<byte> destination, Int32& bytesWritten);
    private static void EncodeValueStringPart(string value, Span`1<byte> destination);
    public static bool EncodeStringLiteral(ReadOnlySpan`1<byte> value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeStringLiteral(string value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeStringLiteral(string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeDynamicTableSizeUpdate(int value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeStringLiterals(ReadOnlySpan`1<string> values, string separator, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("2")]
public static bool EncodeStringLiterals(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingToAllocatedArray(int index);
    [NullableContextAttribute("1")]
public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingNewNameToAllocatedArray(string name);
    [NullableContextAttribute("1")]
public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingToAllocatedArray(int index, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Net.Http.HPack.HPackEncodingException : Exception {
    public HPackEncodingException(string message);
    public HPackEncodingException(string message, Exception innerException);
}
internal static class System.Net.Http.HPack.Huffman : object {
    private static UInt16[] s_decodingTree;
    private static ReadOnlySpan`1<UInt32> EncodingTableCodes { get; }
    private static ReadOnlySpan`1<byte> EncodingTableBitLengths { get; }
    private static Huffman();
    private static ReadOnlySpan`1<UInt32> get_EncodingTableCodes();
    private static ReadOnlySpan`1<byte> get_EncodingTableBitLengths();
    public static ValueTuple`2<UInt32, int> Encode(int data);
    private static UInt16[] GenerateDecodingLookupTree();
    public static int Decode(ReadOnlySpan`1<byte> src, Byte[]& dstArray);
}
internal class System.Net.Http.HPack.HuffmanDecodingException : Exception {
    [NullableContextAttribute("1")]
public HuffmanDecodingException(string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private HuffmanDecodingException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.Http.HPack.IntegerDecoder : ValueType {
    private int _i;
    private int _m;
    public bool BeginTryDecode(byte b, int prefixLength, Int32& result);
    public bool TryDecode(byte b, Int32& result);
}
internal static class System.Net.Http.HPack.IntegerEncoder : object {
    public static int MaxInt32EncodedLength;
    public static bool Encode(int value, int numBits, Span`1<byte> destination, Int32& bytesWritten);
    private static byte MaskHigh(int n);
}
internal static class System.Net.Http.HPack.StatusCodes : object {
    public static ReadOnlySpan`1<byte> ToStatusBytes(int statusCode);
    [NullableContextAttribute("1")]
public static string ToStatusString(int statusCode);
}
internal enum System.Net.Http.Http3ErrorCode : Enum {
    public long value__;
    public static Http3ErrorCode NoError;
    public static Http3ErrorCode ProtocolError;
    public static Http3ErrorCode InternalError;
    public static Http3ErrorCode StreamCreationError;
    public static Http3ErrorCode ClosedCriticalStream;
    public static Http3ErrorCode UnexpectedFrame;
    public static Http3ErrorCode FrameError;
    public static Http3ErrorCode ExcessiveLoad;
    public static Http3ErrorCode IdError;
    public static Http3ErrorCode SettingsError;
    public static Http3ErrorCode MissingSettings;
    public static Http3ErrorCode RequestRejected;
    public static Http3ErrorCode RequestCancelled;
    public static Http3ErrorCode RequestIncomplete;
    public static Http3ErrorCode MessageError;
    public static Http3ErrorCode ConnectError;
    public static Http3ErrorCode VersionFallback;
}
internal static class System.Net.Http.Http3Frame : object {
    public static int MaximumEncodedFrameEnvelopeLength;
    public static bool TryReadIntegerPair(ReadOnlySpan`1<byte> buffer, Int64& a, Int64& b, Int32& bytesRead);
    public static bool TryWriteFrameEnvelope(Http3FrameType frameType, long payloadLength, Span`1<byte> buffer, Int32& bytesWritten);
}
internal enum System.Net.Http.Http3FrameType : Enum {
    public long value__;
    public static Http3FrameType Data;
    public static Http3FrameType Headers;
    public static Http3FrameType ReservedHttp2Priority;
    public static Http3FrameType CancelPush;
    public static Http3FrameType Settings;
    public static Http3FrameType PushPromise;
    public static Http3FrameType ReservedHttp2Ping;
    public static Http3FrameType GoAway;
    public static Http3FrameType ReservedHttp2WindowUpdate;
    public static Http3FrameType ReservedHttp2Continuation;
    public static Http3FrameType MaxPushId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Net.Http.Http3RawFrame : object {
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Http3FrameType <Type>k__BackingField;
    public long Length { get; public set; }
    public Http3FrameType Type { get; internal set; }
    public string FormattedType { get; }
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
    [CompilerGeneratedAttribute]
public Http3FrameType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(Http3FrameType value);
    public string get_FormattedType();
    public virtual string ToString();
    public void PrepareData();
    public void PrepareGoAway();
    public void PrepareHeaders();
    public void PrepareSettings();
}
internal enum System.Net.Http.Http3SettingType : Enum {
    public long value__;
    public static Http3SettingType QPackMaxTableCapacity;
    public static Http3SettingType ReservedHttp2EnablePush;
    public static Http3SettingType ReservedHttp2MaxConcurrentStreams;
    public static Http3SettingType ReservedHttp2InitialWindowSize;
    public static Http3SettingType ReservedHttp2MaxFrameSize;
    public static Http3SettingType MaxHeaderListSize;
    public static Http3SettingType QPackBlockedStreams;
    public static Http3SettingType EnableWebTransport;
    public static Http3SettingType H3Datagram;
}
internal enum System.Net.Http.Http3StreamType : Enum {
    public long value__;
    public static Http3StreamType Control;
    public static Http3StreamType Push;
    public static Http3StreamType QPackEncoder;
    public static Http3StreamType QPackDecoder;
    public static Http3StreamType WebTransportUnidirectional;
    public static Http3StreamType WebTransportBidirectional;
}
internal interface System.Net.Http.IHttpStreamHeadersHandler {
    public abstract virtual void OnStaticIndexedHeader(int index);
    public abstract virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeadersComplete(bool endStream);
    public abstract virtual void OnDynamicIndexedHeader(Nullable`1<int> index, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Net.Http.QPack.H3StaticTable : object {
    public static int Authority;
    public static int PathSlash;
    public static int Age0;
    public static int ContentDisposition;
    public static int ContentLength0;
    public static int Cookie;
    public static int Date;
    public static int ETag;
    public static int IfModifiedSince;
    public static int IfNoneMatch;
    public static int LastModified;
    public static int Link;
    public static int Location;
    public static int Referer;
    public static int SetCookie;
    public static int MethodConnect;
    public static int MethodDelete;
    public static int MethodGet;
    public static int MethodHead;
    public static int MethodOptions;
    public static int MethodPost;
    public static int MethodPut;
    public static int SchemeHttp;
    public static int SchemeHttps;
    public static int Status103;
    public static int Status200;
    public static int Status304;
    public static int Status404;
    public static int Status503;
    public static int AcceptAny;
    public static int AcceptEncodingGzipDeflateBr;
    public static int AcceptRangesBytes;
    public static int AccessControlAllowHeadersCacheControl;
    public static int AccessControlAllowOriginAny;
    public static int CacheControlMaxAge0;
    public static int ContentEncodingBr;
    public static int ContentTypeApplicationDnsMessage;
    public static int RangeBytes0ToAll;
    public static int StrictTransportSecurityMaxAge31536000;
    public static int VaryAcceptEncoding;
    public static int XContentTypeOptionsNoSniff;
    public static int Status100;
    public static int Status204;
    public static int Status206;
    public static int Status302;
    public static int Status400;
    public static int Status403;
    public static int Status421;
    public static int Status425;
    public static int Status500;
    public static int AcceptLanguage;
    public static int AccessControlAllowCredentials;
    public static int AccessControlAllowMethodsGet;
    public static int AccessControlExposeHeadersContentLength;
    public static int AltSvcClear;
    public static int Authorization;
    public static int ContentSecurityPolicyAllNone;
    public static int IfRange;
    public static int Origin;
    public static int Server;
    public static int UpgradeInsecureRequests1;
    public static int UserAgent;
    public static int XFrameOptionsDeny;
    private static Dictionary`2<HttpMethod, int> s_methodIndex;
    private static HeaderField[] s_staticTable;
    public static int Count { get; }
    public static IReadOnlyDictionary`2<HttpMethod, int> MethodIndex { get; }
    private static H3StaticTable();
    public static bool TryGetStatusIndex(int status, Int32& index);
    public static int get_Count();
    public static IReadOnlyDictionary`2<HttpMethod, int> get_MethodIndex();
    public static HeaderField& modreq(System.Runtime.InteropServices.InAttribute) Get(int index);
    private static HeaderField CreateHeaderField(string name, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Net.Http.QPack.HeaderField : ValueType {
    public static int RfcOverhead;
    [CompilerGeneratedAttribute]
private Byte[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Name { get; }
    public Byte[] Value { get; }
    public int Length { get; }
    public HeaderField(Byte[] name, Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public int get_Length();
    public static int GetLength(int nameLength, int valueLength);
    public virtual string ToString();
}
internal class System.Net.Http.QPack.QPackDecoder : object {
    private static int RequiredInsertCountPrefix;
    private static int BaseMask;
    private static int BasePrefix;
    private static byte IndexedHeaderStaticMask;
    private static byte IndexedHeaderStaticRepresentation;
    private static byte IndexedHeaderFieldPrefixMask;
    private static int IndexedHeaderFieldPrefix;
    private static byte PostBaseIndexMask;
    private static int PostBaseIndexPrefix;
    private static byte LiteralHeaderFieldStaticMask;
    private static byte LiteralHeaderFieldPrefixMask;
    private static int LiteralHeaderFieldPrefix;
    private static byte LiteralHeaderFieldPostBasePrefixMask;
    private static int LiteralHeaderFieldPostBasePrefix;
    private static byte LiteralHeaderFieldWithoutNameReferenceHuffmanMask;
    private static byte LiteralHeaderFieldWithoutNameReferencePrefixMask;
    private static int LiteralHeaderFieldWithoutNameReferencePrefix;
    private static int StringLengthPrefix;
    private static byte HuffmanMask;
    private static int HeaderStaticIndexUnset;
    private int _maxHeadersLength;
    private State _state;
    private bool _huffman;
    private Byte[] _headerName;
    private int _headerStaticIndex;
    private int _headerNameLength;
    private int _headerValueLength;
    private int _stringLength;
    private int _stringIndex;
    private IntegerDecoder _integerDecoder;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerNameRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerValueRange;
    [NullableAttribute("1")]
private static ArrayPool`1<byte> Pool { get; }
    public QPackDecoder(int maxHeadersLength);
    private static ArrayPool`1<byte> get_Pool();
    public sealed virtual void Dispose();
    public void Reset();
    public void Decode(ReadOnlySequence`1& data, bool endHeaders, IHttpStreamHeadersHandler handler);
    public void Decode(ReadOnlySpan`1<byte> data, bool endHeaders, IHttpStreamHeadersHandler handler);
    private void DecodeInternal(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndexPostBase(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParsePostBaseIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParseHeaderNameLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderName(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderFieldIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseCompressedHeaders(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseRequiredInsertCountContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseBase(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseBaseContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseRequiredInsertCount(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void CheckIncompleteHeaderBlock(bool endHeaders);
    private void ProcessHeaderValue(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void OnStringLength(int length, State nextState);
    private void OnString(State nextState);
    private static void EnsureStringCapacity(Byte[]& buffer, int requiredLength, int existingLength);
    private bool TryDecodeInteger(ReadOnlySpan`1<byte> data, Int32& currentIndex, Int32& result);
    private static bool IsHuffmanEncoded(byte b);
    private void OnIndexedHeaderName(int index);
    private static void OnIndexedHeaderNamePostBase(int _);
    private static void OnPostBaseIndex();
    private void OnBase(int deltaBase);
    private void OnRequiredInsertCount(int requiredInsertCount);
    private void OnIndexedHeaderField(int index, IHttpStreamHeadersHandler handler);
    private static void ThrowDynamicTableNotSupported();
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|61_0(Byte[]& dst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Net.Http.QPack.QPackDecodingException : Exception {
    public QPackDecodingException(string message);
    public QPackDecodingException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private QPackDecodingException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Net.Http.QPack.QPackEncoder : object {
    [NullableContextAttribute("0")]
public static bool EncodeStaticIndexedHeaderField(int index, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeStaticIndexedHeaderFieldToArray(int index);
    [NullableContextAttribute("0")]
public static bool EncodeLiteralHeaderFieldWithStaticNameReference(int index, string value, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static bool EncodeLiteralHeaderFieldWithStaticNameReference(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeLiteralHeaderFieldWithStaticNameReferenceToArray(int index);
    public static Byte[] EncodeLiteralHeaderFieldWithStaticNameReferenceToArray(int index, string value);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, string value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, ReadOnlySpan`1<string> values, string valueSeparator, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, ReadOnlySpan`1<string> values, string valueSeparator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeLiteralHeaderFieldWithoutNameReferenceToArray(string name);
    public static Byte[] EncodeLiteralHeaderFieldWithoutNameReferenceToArray(string name, string value);
    private static bool EncodeValueString(string s, Encoding valueEncoding, Span`1<byte> buffer, Int32& length);
    [NullableContextAttribute("0")]
public static bool EncodeValueString(ReadOnlySpan`1<string> values, string separator, Span`1<byte> buffer, Int32& length);
    [NullableContextAttribute("2")]
public static bool EncodeValueString(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> buffer, Int32& length);
    private static void EncodeValueStringPart(string s, Span`1<byte> buffer);
    private static bool EncodeNameString(string s, Span`1<byte> buffer, Int32& length);
    private static bool EncodeHeaderBlockPrefix(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Net.Http.QPack.QPackEncodingException : Exception {
    public QPackEncodingException(string message);
    public QPackEncodingException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private QPackEncodingException(SerializationInfo info, StreamingContext context);
}
internal static class System.Net.Http.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string net_http_headers_exceeded_length { get; }
    internal static string net_http_headers_invalid_header_name { get; }
    internal static string net_http_hpack_bad_integer { get; }
    internal static string net_http_hpack_encode_failure { get; }
    internal static string net_http_hpack_huffman_decode_failed { get; }
    internal static string net_http_hpack_incomplete_header_block { get; }
    internal static string net_http_hpack_invalid_index { get; }
    internal static string net_http_hpack_large_table_size_update { get; }
    internal static string net_http_hpack_late_dynamic_table_size_update { get; }
    internal static string net_http_hpack_unexpected_end { get; }
    internal static string net_http_invalid_header_name { get; }
    internal static string net_http_qpack_no_dynamic_table { get; }
    internal static string net_http_request_invalid_char_encoding { get; }
    internal static string net_quic_connectionaborted { get; }
    internal static string net_quic_notsupported { get; }
    internal static string net_quic_operationaborted { get; }
    internal static string net_quic_streamaborted { get; }
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_net_http_headers_exceeded_length();
    internal static string Formatnet_http_headers_exceeded_length(object p0);
    internal static string get_net_http_headers_invalid_header_name();
    internal static string get_net_http_hpack_bad_integer();
    internal static string get_net_http_hpack_encode_failure();
    internal static string get_net_http_hpack_huffman_decode_failed();
    internal static string get_net_http_hpack_incomplete_header_block();
    internal static string get_net_http_hpack_invalid_index();
    internal static string Formatnet_http_hpack_invalid_index(object p0);
    internal static string get_net_http_hpack_large_table_size_update();
    internal static string Formatnet_http_hpack_large_table_size_update(object p0, object p1);
    internal static string get_net_http_hpack_late_dynamic_table_size_update();
    internal static string get_net_http_hpack_unexpected_end();
    internal static string get_net_http_invalid_header_name();
    internal static string Formatnet_http_invalid_header_name(object p0);
    internal static string get_net_http_qpack_no_dynamic_table();
    internal static string get_net_http_request_invalid_char_encoding();
    internal static string get_net_quic_connectionaborted();
    internal static string Formatnet_quic_connectionaborted(object p0);
    internal static string get_net_quic_notsupported();
    internal static string get_net_quic_operationaborted();
    internal static string get_net_quic_streamaborted();
    internal static string Formatnet_quic_streamaborted(object p0);
}
internal static class System.Net.Http.VariableLengthIntegerHelper : object {
    public static int MaximumEncodedLength;
    private static byte LengthMask;
    private static byte InitialOneByteLengthMask;
    private static byte InitialTwoByteLengthMask;
    private static byte InitialFourByteLengthMask;
    private static byte InitialEightByteLengthMask;
    private static UInt32 TwoByteLengthMask;
    private static UInt32 FourByteLengthMask;
    private static ulong EightByteLengthMask;
    public static UInt32 OneByteLimit;
    public static UInt32 TwoByteLimit;
    public static UInt32 FourByteLimit;
    public static long EightByteLimit;
    public static bool TryRead(ReadOnlySpan`1<byte> buffer, Int64& value, Int32& bytesRead);
    public static bool TryRead(SequenceReader`1& reader, Int64& value);
    public static long GetInteger(ReadOnlySequence`1& buffer, SequencePosition& consumed, SequencePosition& examined);
    public static bool TryWrite(Span`1<byte> buffer, long longToEncode, Int32& bytesWritten);
    public static int WriteInteger(Span`1<byte> buffer, long longToEncode);
    public static int GetByteCount(long value);
    [CompilerGeneratedAttribute]
internal static bool <TryRead>g__TryReadSlow|14_0(SequenceReader`1& reader, Int64& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string LegacyFormatterImplMessage;
    internal static string LegacyFormatterImplDiagId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.TimeExtensions : object {
    [ExtensionAttribute]
public static long ToTicks(TimeSpan timeSpan, TimeProvider timeProvider);
    [ExtensionAttribute]
public static long ToTicks(TimeSpan timeSpan, long tickFrequency);
    [ExtensionAttribute]
public static long GetTimestamp(TimeProvider timeProvider, TimeSpan timeSpan);
    [ExtensionAttribute]
public static long GetTimestamp(TimeProvider timeProvider, long timeStamp, TimeSpan timeSpan);
}
