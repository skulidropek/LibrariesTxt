internal class Microsoft.CodeAnalysis.ClrGlobalAssemblyCache : GlobalAssemblyCache {
    private static int MAX_PATH;
    private static int S_OK;
    private static int S_FALSE;
    private static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, ASM_CACHE dwFlags, IntPtr pvReserved);
    private static void CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(AssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<string> GetAssemblySimpleNames(ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    private static IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(IAssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ClrGlobalAssemblyCache/<GetAssemblyObjects>d__12")]
internal static IEnumerable`1<IAssemblyName> GetAssemblyObjects(IAssemblyName partialNameFilter, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual AssemblyIdentity ResolvePartialName(string displayName, String& location, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
    internal static string GetAssemblyLocation(IAssemblyName nameObject);
}
internal static class Microsoft.CodeAnalysis.CoreClrShim : object {
    internal static bool IsRunningOnCoreClr { get; }
    internal static bool get_IsRunningOnCoreClr();
}
internal class Microsoft.CodeAnalysis.DotNetCoreGlobalAssemblyCache : GlobalAssemblyCache {
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(AssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<string> GetAssemblySimpleNames(ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    [NullableContextAttribute("2")]
public virtual AssemblyIdentity ResolvePartialName(string displayName, String& location, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeAnalysis.FusionAssemblyIdentity : object {
    private static object s_assemblyIdentityGate;
    private static int ERROR_INSUFFICIENT_BUFFER;
    private static int FUSION_E_INVALID_NAME;
    private static FusionAssemblyIdentity();
    private static int CreateAssemblyNameObject(IAssemblyName& ppEnum, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    private static int RealCreateAssemblyNameObject(IAssemblyName& ppEnum, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    internal static string GetDisplayName(IAssemblyName nameObject, ASM_DISPLAYF displayFlags);
    internal static Byte[] GetPropertyBytes(IAssemblyName nameObject, PropertyId propertyId);
    internal static string GetPropertyString(IAssemblyName nameObject, PropertyId propertyId);
    internal static bool IsKeyOrTokenEmpty(IAssemblyName nameObject, PropertyId propertyId);
    internal static Version GetVersion(IAssemblyName nameObject);
    internal static Version GetVersion(IAssemblyName name, AssemblyIdentityParts& parts);
    internal static Byte[] GetPublicKeyToken(IAssemblyName nameObject);
    internal static Byte[] GetPublicKey(IAssemblyName nameObject);
    internal static Nullable`1<UInt32> GetPropertyWord(IAssemblyName nameObject, PropertyId propertyId);
    internal static string GetName(IAssemblyName nameObject);
    internal static string GetCulture(IAssemblyName nameObject);
    internal static AssemblyContentType GetContentType(IAssemblyName nameObject);
    internal static ProcessorArchitecture GetProcessorArchitecture(IAssemblyName nameObject);
    internal static AssemblyNameFlags GetFlags(IAssemblyName nameObject);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, string data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, Byte[] data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, ushort data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, UInt32 data);
    private static void SetPublicKeyToken(IAssemblyName nameObject, Byte[] value);
    internal static AssemblyIdentity ToAssemblyIdentity(IAssemblyName nameObject);
    internal static IAssemblyName ToAssemblyNameObject(AssemblyName name);
    internal static IAssemblyName ToAssemblyNameObject(string displayName);
    internal static IAssemblyName GetBestMatch(IEnumerable`1<IAssemblyName> candidates, string preferredCultureOpt);
}
internal abstract class Microsoft.CodeAnalysis.GlobalAssemblyCache : object {
    [NullableAttribute("1")]
internal static GlobalAssemblyCache Instance;
    public static ImmutableArray`1<ProcessorArchitecture> CurrentArchitectures;
    private static GlobalAssemblyCache();
    [NullableContextAttribute("1")]
private static GlobalAssemblyCache CreateInstance();
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(AssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public abstract virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public abstract virtual IEnumerable`1<string> GetAssemblySimpleNames(ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    [NullableContextAttribute("2")]
public AssemblyIdentity ResolvePartialName(string displayName, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
    [NullableContextAttribute("2")]
public abstract virtual AssemblyIdentity ResolvePartialName(string displayName, String& location, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
}
internal static class Microsoft.CodeAnalysis.GlobalAssemblyCacheLocation : object {
    public static ImmutableArray`1<string> s_rootLocations;
    public static ImmutableArray`1<string> RootLocations { get; }
    private static int GetCachePath(ASM_CACHE id, Byte* path, Int32& length);
    public static ImmutableArray`1<string> get_RootLocations();
    private static string GetLocation(ASM_CACHE gacId);
}
internal class Microsoft.CodeAnalysis.MonoGlobalAssemblyCache : GlobalAssemblyCache {
    private static string s_corlibDirectory;
    private static string s_gacDirectory;
    private static MonoGlobalAssemblyCache();
    private static AssemblyName CreateAssemblyNameFromFile(string path);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.MonoGlobalAssemblyCache/<GetGacAssemblyPaths>d__4")]
private static IEnumerable`1<string> GetGacAssemblyPaths(string gacPath, string name, Version version, Byte[] publicKeyTokenBytes);
    private static IEnumerable`1<ValueTuple`2<AssemblyIdentity, string>> GetAssemblyIdentitiesAndPaths(AssemblyName name, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.MonoGlobalAssemblyCache/<GetAssemblyIdentitiesAndPaths>d__6")]
private static IEnumerable`1<ValueTuple`2<AssemblyIdentity, string>> GetAssemblyIdentitiesAndPaths(string name, Version version, Byte[] publicKeyToken, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(AssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual IEnumerable`1<string> GetAssemblySimpleNames(ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public virtual AssemblyIdentity ResolvePartialName(string displayName, String& location, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
    private static string ToHexString(Byte[] bytes);
}
internal class Microsoft.CodeAnalysis.RelativePathResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Microsoft.CodeAnalysis.Scripting.CompilationErrorException : Exception {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Diagnostics>k__BackingField;
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public CompilationErrorException(string message, ImmutableArray`1<Diagnostic> diagnostics);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Diagnostics();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.AssemblyAndLocation : ValueType {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GlobalAssemblyCache>k__BackingField;
    public Assembly Assembly { get; }
    public string Location { get; }
    public bool GlobalAssemblyCache { get; }
    public bool IsDefault { get; }
    internal AssemblyAndLocation(Assembly assembly, string location, bool fromGac);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public bool get_GlobalAssemblyCache();
    public bool get_IsDefault();
    public sealed virtual bool Equals(AssemblyAndLocation other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.AssemblyLoaderImpl : object {
    internal InteractiveAssemblyLoader Loader;
    protected AssemblyLoaderImpl(InteractiveAssemblyLoader loader);
    public static AssemblyLoaderImpl Create(InteractiveAssemblyLoader loader);
    private static AssemblyLoaderImpl CreateCoreImpl(InteractiveAssemblyLoader loader);
    public abstract virtual Assembly LoadFromStream(Stream peStream, Stream pdbStream);
    public abstract virtual AssemblyAndLocation LoadFromPath(string path);
    public abstract virtual void Dispose();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.AssemblyLoadResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalPath>k__BackingField;
    public bool IsSuccessful { get; }
    public string Path { get; }
    public string OriginalPath { get; }
    public AssemblyLoadResult(string path, string originalPath, bool isSuccessful);
    [CompilerGeneratedAttribute]
public bool get_IsSuccessful();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_OriginalPath();
    internal static AssemblyLoadResult CreateSuccessful(string path, string originalPath);
    internal static AssemblyLoadResult CreateAlreadyLoaded(string path, string originalPath);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Scripting.Hosting.CommandLineHelpers : object {
    public static ImmutableArray`1<string> GetImports(CommandLineArguments args);
    [ExtensionAttribute]
internal static ScriptOptions RemoveImportsAndReferences(ScriptOptions options);
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.CommandLineRunner : object {
    private ConsoleIO _console;
    private CommonCompiler _compiler;
    private ScriptCompiler _scriptCompiler;
    private ObjectFormatter _objectFormatter;
    internal ConsoleIO Console { get; }
    internal CommonCompiler Compiler { get; }
    internal CommandLineRunner(ConsoleIO console, CommonCompiler compiler, ScriptCompiler scriptCompiler, ObjectFormatter objectFormatter);
    internal ConsoleIO get_Console();
    internal CommonCompiler get_Compiler();
    internal int RunInteractive();
    private int RunInteractiveCore(ErrorLogger errorLogger);
    private static ScriptOptions GetScriptOptions(CommandLineArguments arguments, string scriptPathOpt, CommonMessageProvider messageProvider, List`1<DiagnosticInfo> diagnostics, bool emitDebugInformation);
    internal static MetadataReferenceResolver GetMetadataReferenceResolver(CommandLineArguments arguments, TouchedFileLogger loggerOpt);
    internal static SourceReferenceResolver GetSourceReferenceResolver(CommandLineArguments arguments, TouchedFileLogger loggerOpt);
    private int RunScript(ScriptOptions options, SourceText code, ErrorLogger errorLogger, CancellationToken cancellationToken);
    private void RunInteractiveLoop(ScriptOptions options, string initialScriptCodeOpt, CancellationToken cancellationToken);
    private void BuildAndRun(Script`1<object> newScript, InteractiveScriptGlobals globals, ScriptState`1& state, ScriptOptions& options, bool displayResult, CancellationToken cancellationToken);
    private static ScriptOptions UpdateOptions(ScriptOptions options, InteractiveScriptGlobals globals);
    private void DisplayException(Exception e);
    private static bool IsHelpCommand(string text);
    private void DisplayHelpText();
    private void DisplayDiagnostics(ImmutableArray`1<Diagnostic> diagnostics);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.CommandLineScriptGlobals : object {
    private TextWriter _outputWriter;
    private ObjectFormatter _objectFormatter;
    [CompilerGeneratedAttribute]
private IList`1<string> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintOptions <PrintOptions>k__BackingField;
    public IList`1<string> Args { get; }
    public PrintOptions PrintOptions { get; }
    public CommandLineScriptGlobals(TextWriter outputWriter, ObjectFormatter objectFormatter);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Args();
    [CompilerGeneratedAttribute]
public PrintOptions get_PrintOptions();
    public void Print(object value);
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.CommonMemberFilter : MemberFilter {
    public virtual bool Include(StackFrame frame);
    public virtual bool Include(MemberInfo member);
    private bool IsHiddenMember(MemberInfo info);
    private static bool IsTaskAwaiter(Type type);
    protected virtual bool IsGeneratedMemberName(string name);
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.CommonObjectFormatter : ObjectFormatter {
    [CompilerGeneratedAttribute]
private MemberFilter <Filter>k__BackingField;
    protected MemberFilter Filter { get; }
    protected CommonTypeNameFormatter TypeNameFormatter { get; }
    protected CommonPrimitiveFormatter PrimitiveFormatter { get; }
    public virtual string FormatObject(object obj, PrintOptions options);
    [CompilerGeneratedAttribute]
protected virtual MemberFilter get_Filter();
    protected abstract virtual CommonTypeNameFormatter get_TypeNameFormatter();
    protected abstract virtual CommonPrimitiveFormatter get_PrimitiveFormatter();
    protected virtual BuilderOptions GetInternalBuilderOptions(PrintOptions printOptions);
    protected virtual CommonPrimitiveFormatterOptions GetPrimitiveOptions(PrintOptions printOptions);
    protected virtual CommonTypeNameFormatterOptions GetTypeNameOptions(PrintOptions printOptions);
    public virtual string FormatException(Exception e);
    protected internal virtual string FormatMethodSignature(MethodBase method);
    protected abstract virtual string FormatRefKind(ParameterInfo parameter);
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.CommonPrimitiveFormatter : object {
    protected string NullLiteral { get; }
    protected abstract virtual string get_NullLiteral();
    protected abstract virtual string FormatLiteral(bool value);
    protected abstract virtual string FormatLiteral(string value, bool quote, bool escapeNonPrintable, int numberRadix);
    protected abstract virtual string FormatLiteral(char value, bool quote, bool escapeNonPrintable, bool includeCodePoints, int numberRadix);
    protected abstract virtual string FormatLiteral(sbyte value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(byte value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(short value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(ushort value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(int value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(UInt32 value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(long value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(ulong value, int numberRadix, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(double value, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(float value, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(decimal value, CultureInfo cultureInfo);
    protected abstract virtual string FormatLiteral(DateTime value, CultureInfo cultureInfo);
    public string FormatPrimitive(object obj, CommonPrimitiveFormatterOptions options);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.CommonPrimitiveFormatterOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <NumberRadix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeCharacterCodePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuoteStringsAndCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeNonPrintableCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    public int NumberRadix { get; }
    public bool IncludeCharacterCodePoints { get; }
    public bool QuoteStringsAndCharacters { get; }
    public bool EscapeNonPrintableCharacters { get; }
    public CultureInfo CultureInfo { get; }
    public CommonPrimitiveFormatterOptions(int numberRadix, bool includeCodePoints, bool quoteStringsAndCharacters, bool escapeNonPrintableCharacters, CultureInfo cultureInfo);
    [CompilerGeneratedAttribute]
public int get_NumberRadix();
    [CompilerGeneratedAttribute]
public bool get_IncludeCharacterCodePoints();
    [CompilerGeneratedAttribute]
public bool get_QuoteStringsAndCharacters();
    [CompilerGeneratedAttribute]
public bool get_EscapeNonPrintableCharacters();
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.CommonTypeNameFormatter : object {
    protected string GenericParameterOpening { get; }
    protected string GenericParameterClosing { get; }
    protected string ArrayOpening { get; }
    protected string ArrayClosing { get; }
    protected CommonPrimitiveFormatter PrimitiveFormatter { get; }
    protected abstract virtual string GetPrimitiveTypeName(SpecialType type);
    protected abstract virtual string get_GenericParameterOpening();
    protected abstract virtual string get_GenericParameterClosing();
    protected abstract virtual string get_ArrayOpening();
    protected abstract virtual string get_ArrayClosing();
    protected abstract virtual CommonPrimitiveFormatter get_PrimitiveFormatter();
    public virtual string FormatTypeName(Type type, CommonTypeNameFormatterOptions options);
    private static string FormatNonGenericTypeName(TypeInfo typeInfo, CommonTypeNameFormatterOptions options);
    public virtual string FormatTypeArguments(Type[] typeArguments, CommonTypeNameFormatterOptions options);
    public virtual string FormatArrayTypeName(Type arrayType, Array arrayOpt, CommonTypeNameFormatterOptions options);
    private void AppendArrayBound(StringBuilder sb, long bound, int numberRadix);
    private void AppendArrayRank(StringBuilder sb, Type arrayType);
    private string FormatGenericTypeName(TypeInfo typeInfo, CommonTypeNameFormatterOptions options);
    private void AppendTypeInstantiation(StringBuilder builder, TypeInfo typeInfo, Type[] genericArguments, Int32& genericArgIndex, CommonTypeNameFormatterOptions options);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.CommonTypeNameFormatterOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <ArrayBoundRadix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowNamespaces>k__BackingField;
    public int ArrayBoundRadix { get; }
    public bool ShowNamespaces { get; }
    public CommonTypeNameFormatterOptions(int arrayBoundRadix, bool showNamespaces);
    [CompilerGeneratedAttribute]
public int get_ArrayBoundRadix();
    [CompilerGeneratedAttribute]
public bool get_ShowNamespaces();
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.ConsoleIO : object {
    public static ConsoleIO Default;
    [CompilerGeneratedAttribute]
private TextWriter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private TextReader <In>k__BackingField;
    public TextWriter Error { get; }
    public TextWriter Out { get; }
    public TextReader In { get; }
    public ConsoleIO(TextWriter output, TextWriter error, TextReader input);
    private static ConsoleIO();
    [CompilerGeneratedAttribute]
public TextWriter get_Error();
    [CompilerGeneratedAttribute]
public TextWriter get_Out();
    [CompilerGeneratedAttribute]
public TextReader get_In();
    public virtual void SetForegroundColor(ConsoleColor consoleColor);
    public virtual void ResetColor();
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.CoreAssemblyLoaderImpl : AssemblyLoaderImpl {
    private LoadContext _inMemoryAssemblyContext;
    internal CoreAssemblyLoaderImpl(InteractiveAssemblyLoader loader);
    public virtual Assembly LoadFromStream(Stream peStream, Stream pdbStream);
    public virtual AssemblyAndLocation LoadFromPath(string path);
    public virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.DesktopAssemblyLoaderImpl : AssemblyLoaderImpl {
    private Func`3<string, Assembly, Assembly> _assemblyResolveHandlerOpt;
    public DesktopAssemblyLoaderImpl(InteractiveAssemblyLoader loader);
    public virtual void Dispose();
    public virtual Assembly LoadFromStream(Stream peStream, Stream pdbStream);
    public virtual AssemblyAndLocation LoadFromPath(string path);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.FileShadowCopy : object {
    [CompilerGeneratedAttribute]
private string <OriginalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    private IDisposable _stream;
    public string OriginalPath { get; }
    public string FullPath { get; }
    internal FileShadowCopy(IDisposable stream, string originalPath, string fullPath);
    [CompilerGeneratedAttribute]
public string get_OriginalPath();
    [CompilerGeneratedAttribute]
public string get_FullPath();
    internal void DisposeFileStream();
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.GacFileResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ProcessorArchitecture> <Architectures>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <PreferredCulture>k__BackingField;
    public static bool IsAvailable { get; }
    public ImmutableArray`1<ProcessorArchitecture> Architectures { get; }
    public CultureInfo PreferredCulture { get; }
    public GacFileResolver(ImmutableArray`1<ProcessorArchitecture> architectures, CultureInfo preferredCulture);
    public static bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ProcessorArchitecture> get_Architectures();
    [CompilerGeneratedAttribute]
public CultureInfo get_PreferredCulture();
    public string Resolve(string assemblyName);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(GacFileResolver other);
    public virtual bool Equals(object obj);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.InteractiveAssemblyLoader : object {
    private AssemblyLoaderImpl _runtimeAssemblyLoader;
    private MetadataShadowCopyProvider _shadowCopyProvider;
    private object _referencesLock;
    private Dictionary`2<Assembly, LoadedAssembly> _assembliesLoadedFromLocation;
    private Dictionary`2<string, AssemblyAndLocation> _assembliesLoadedFromLocationByFullPath;
    private Dictionary`2<string, List`1<LoadedAssemblyInfo>> _loadedAssembliesBySimpleName;
    private Dictionary`2<string, List`1<AssemblyIdentityAndLocation>> _dependenciesWithLocationBySimpleName;
    public InteractiveAssemblyLoader(MetadataShadowCopyProvider shadowCopyProvider);
    public sealed virtual void Dispose();
    internal Assembly LoadAssemblyFromStream(Stream peStream, Stream pdbStream);
    private AssemblyAndLocation Load(string reference);
    public void RegisterDependency(AssemblyIdentity dependency, string path);
    public void RegisterDependency(Assembly dependency);
    private void RegisterLoadedAssemblySimpleNameNoLock(Assembly assembly, string locationOpt);
    private void RegisterDependencyNoLock(AssemblyIdentityAndLocation dependency);
    internal Assembly ResolveAssembly(string assemblyDisplayName, Assembly requestingAssemblyOpt);
    internal Assembly ResolveAssembly(AssemblyIdentity identity, string loadDirectoryOpt);
    private static string FindExistingAssemblyFile(string simpleName, string directory);
    private Assembly TryGetAssemblyLoadedFromPath(AssemblyIdentity identity, string directory);
    private static bool TryReadMvid(string filePath, Guid& mvid);
    private Assembly GetOrLoadKnownAssembly(AssemblyIdentity identity);
    private AssemblyAndLocation ShadowCopyAndLoadDependency(string originalPath);
    private static Assembly FindHighestVersionOrFirstMatchingIdentity(AssemblyIdentity identity, IEnumerable`1<LoadedAssemblyInfo> infos);
    private static AssemblyIdentityAndLocation FindHighestVersionOrFirstMatchingIdentity(AssemblyIdentity identity, IEnumerable`1<AssemblyIdentityAndLocation> assemblies);
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.InteractiveAssemblyLoaderException : NotSupportedException {
    internal InteractiveAssemblyLoaderException(string message);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.InteractiveScriptGlobals : object {
    private TextWriter _outputWriter;
    private ObjectFormatter _objectFormatter;
    [CompilerGeneratedAttribute]
private IList`1<string> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ReferencePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <SourcePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintOptions <PrintOptions>k__BackingField;
    public IList`1<string> Args { get; }
    public IList`1<string> ReferencePaths { get; }
    public IList`1<string> SourcePaths { get; }
    public PrintOptions PrintOptions { get; }
    public InteractiveScriptGlobals(TextWriter outputWriter, ObjectFormatter objectFormatter);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Args();
    public void Print(object value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ReferencePaths();
    [CompilerGeneratedAttribute]
public IList`1<string> get_SourcePaths();
    [CompilerGeneratedAttribute]
public PrintOptions get_PrintOptions();
}
public enum Microsoft.CodeAnalysis.Scripting.Hosting.MemberDisplayFormat : Enum {
    public int value__;
    public static MemberDisplayFormat SingleLine;
    public static MemberDisplayFormat SeparateLines;
    public static MemberDisplayFormat Hidden;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Scripting.Hosting.MemberDisplayFormatExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(MemberDisplayFormat value);
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.MemberFilter : object {
    public virtual bool Include(StackFrame frame);
    public virtual bool Include(MemberInfo member);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.MetadataShadowCopy : object {
    [CompilerGeneratedAttribute]
private FileShadowCopy <PrimaryModule>k__BackingField;
    [CompilerGeneratedAttribute]
private FileShadowCopy <DocumentationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Metadata <Metadata>k__BackingField;
    public FileShadowCopy PrimaryModule { get; }
    public FileShadowCopy DocumentationFile { get; }
    public Metadata Metadata { get; }
    internal MetadataShadowCopy(FileShadowCopy primaryModule, FileShadowCopy documentationFileOpt, Metadata metadataCopy);
    [CompilerGeneratedAttribute]
public FileShadowCopy get_PrimaryModule();
    [CompilerGeneratedAttribute]
public FileShadowCopy get_DocumentationFile();
    [CompilerGeneratedAttribute]
public Metadata get_Metadata();
    internal void DisposeFileHandles();
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.MetadataShadowCopyProvider : object {
    private CultureInfo _documentationCommentsCulture;
    private string _baseDirectory;
    internal string ShadowCopyDirectory;
    private ImmutableArray`1<string> _noShadowCopyDirectories;
    private Dictionary`2<FileKey, CacheEntry`1<MetadataShadowCopy>> _shadowCopies;
    private Dictionary`2<FileKey, CacheEntry`1<Metadata>> _noShadowCopyCache;
    private HashSet`1<string> _lazySuppressedFiles;
    private object Guard { get; }
    internal int CacheSize { get; }
    public MetadataShadowCopyProvider(string directory, IEnumerable`1<string> noShadowCopyDirectories, CultureInfo documentationCommentsCulture);
    private object get_Guard();
    private static void RequireAbsolutePath(string path, string argumentName);
    public bool IsShadowCopy(string fullPath);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void DisposeShadowCopies();
    private void DeleteShadowCopyDirectory();
    private static void StripReadOnlyAttributeFromFile(FileInfo fileInfo);
    public Metadata GetMetadata(string fullPath, MetadataImageKind kind);
    public MetadataShadowCopy GetMetadataShadowCopy(string fullPath, MetadataImageKind kind);
    private MetadataShadowCopy GetMetadataShadowCopyNoCheck(string fullPath, MetadataImageKind kind);
    private bool CopyExistsOrIsSuppressed(FileKey key, CacheEntry`1& existing);
    public void SuppressShadowCopy(string originalPath);
    public bool NeedsShadowCopy(string fullPath);
    private CacheEntry`1<MetadataShadowCopy> CreateMetadataShadowCopy(string originalPath, MetadataImageKind kind);
    private AssemblyMetadata CreateAssemblyMetadata(FileStream manifestModuleCopyStream, string originalPath, string shadowCopyPath);
    private static ModuleMetadata CreateModuleMetadata(FileStream stream);
    private string CreateUniqueDirectory(string basePath);
    private static FileShadowCopy TryCopyDocumentationFile(string originalAssemblyPath, string assemblyCopyDirectory, CultureInfo docCultureOpt);
    private static bool TryFindCollocatedDocumentationFile(string assemblyDirectory, string assemblyFileName, CultureInfo culture, String& docSubdirectory, String& docFileName);
    private static FileStream CopyFile(string originalPath, string shadowCopyPath, bool fileMayNotExist);
    internal int get_CacheSize();
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.NotImplementedAnalyzerLoader : object {
    public sealed virtual void AddDependencyLocation(string fullPath);
    public sealed virtual Assembly LoadFromPath(string fullPath);
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.NuGetPackageResolver : object {
    private static string ReferencePrefix;
    internal static bool TryParsePackageReference(string reference, String& name, String& version);
    internal abstract virtual ImmutableArray`1<string> ResolveNuGetPackage(string packageName, string packageVersion);
}
public abstract class Microsoft.CodeAnalysis.Scripting.Hosting.ObjectFormatter : object {
    public string FormatObject(object obj);
    public abstract virtual string FormatObject(object obj, PrintOptions options);
    public abstract virtual string FormatException(Exception e);
}
internal static class Microsoft.CodeAnalysis.Scripting.Hosting.ObjectFormatterHelpers : object {
    internal static object VoidValue;
    internal static int NumberRadixDecimal;
    internal static int NumberRadixHexadecimal;
    private static ObjectFormatterHelpers();
    internal static bool HasOverriddenToString(TypeInfo type);
    internal static DebuggerDisplayAttribute GetApplicableDebuggerDisplayAttribute(MemberInfo member);
    private static DebuggerTypeProxyAttribute GetApplicableDebuggerTypeProxyAttribute(TypeInfo type);
    private static bool IsApplicableAttribute(TypeInfo type, TypeInfo targetType, string targetTypeName);
    private static bool AreEquivalent(TypeInfo type, TypeInfo other);
    internal static object GetDebuggerTypeProxy(object obj);
    internal static MemberInfo ResolveMember(object obj, string memberName, bool callableOnly);
    internal static object GetMemberValue(MemberInfo member, object obj, Exception& exception);
    internal static SpecialType GetPrimitiveSpecialType(Type type);
    internal static ObjectDisplayOptions GetObjectDisplayOptions(bool useQuotes, bool escapeNonPrintable, bool includeCodePoints, int numberRadix);
    internal static string ParseSimpleMemberName(string str, int start, int end, Boolean& noQuotes, Boolean& isCallable);
    private static void EatTrailingWhiteSpace(string str, int start, Int32& i);
    private static void EatLeadingWhiteSpace(string str, Int32& i, int end);
}
public class Microsoft.CodeAnalysis.Scripting.Hosting.PrintOptions : object {
    private int _numberRadix;
    private MemberDisplayFormat _memberDisplayFormat;
    private int _maximumOutputLength;
    [CompilerGeneratedAttribute]
private string <Ellipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EscapeNonPrintableCharacters>k__BackingField;
    public string Ellipsis { get; public set; }
    public bool EscapeNonPrintableCharacters { get; public set; }
    public int NumberRadix { get; public set; }
    public MemberDisplayFormat MemberDisplayFormat { get; public set; }
    public int MaximumOutputLength { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Ellipsis();
    [CompilerGeneratedAttribute]
public void set_Ellipsis(string value);
    [CompilerGeneratedAttribute]
public bool get_EscapeNonPrintableCharacters();
    [CompilerGeneratedAttribute]
public void set_EscapeNonPrintableCharacters(bool value);
    public int get_NumberRadix();
    public void set_NumberRadix(int value);
    protected virtual bool IsValidRadix(int radix);
    public MemberDisplayFormat get_MemberDisplayFormat();
    public void set_MemberDisplayFormat(MemberDisplayFormat value);
    public int get_MaximumOutputLength();
    public void set_MaximumOutputLength(int value);
}
internal abstract class Microsoft.CodeAnalysis.Scripting.Hosting.ReplServiceProvider : object {
    public ObjectFormatter ObjectFormatter { get; }
    public CommandLineParser CommandLineParser { get; }
    public DiagnosticFormatter DiagnosticFormatter { get; }
    public string Logo { get; }
    public abstract virtual ObjectFormatter get_ObjectFormatter();
    public abstract virtual CommandLineParser get_CommandLineParser();
    public abstract virtual DiagnosticFormatter get_DiagnosticFormatter();
    public abstract virtual string get_Logo();
    public abstract virtual Script`1<T> CreateScript(string code, ScriptOptions options, Type globalsTypeOpt, InteractiveAssemblyLoader assemblyLoader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.RuntimeMetadataReferenceResolver : MetadataReferenceResolver {
    private static MetadataReferenceProperties s_resolvedMissingAssemblyReferenceProperties;
    internal ImmutableDictionary`2<string, string> TrustedPlatformAssemblies;
    internal RelativePathResolver PathResolver;
    [NullableAttribute("2")]
internal NuGetPackageResolver PackageResolver;
    [NullableAttribute("2")]
internal GacFileResolver GacFileResolver;
    private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> _fileReferenceProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> AssemblyExtensions;
    private static Char[] s_directorySeparators;
    public bool ResolveMissingAssemblies { get; }
    [NullableContextAttribute("2")]
internal RuntimeMetadataReferenceResolver(ImmutableArray`1<string> searchPaths, string baseDirectory, NuGetPackageResolver packageResolver, GacFileResolver gacFileResolver, ImmutableArray`1<string> platformAssemblyPaths, Func`3<string, MetadataReferenceProperties, PortableExecutableReference> fileReferenceProvider);
    internal RuntimeMetadataReferenceResolver(RelativePathResolver pathResolver, NuGetPackageResolver packageResolver, GacFileResolver gacFileResolver, ImmutableDictionary`2<string, string> trustedPlatformAssemblies, Func`3<string, MetadataReferenceProperties, PortableExecutableReference> fileReferenceProvider);
    private static RuntimeMetadataReferenceResolver();
    [NullableContextAttribute("2")]
internal static string GetDesktopFrameworkDirectory();
    internal static RuntimeMetadataReferenceResolver CreateCurrentPlatformResolver(ImmutableArray`1<string> searchPaths, string baseDirectory, Func`3<string, MetadataReferenceProperties, PortableExecutableReference> fileReferenceProvider);
    public virtual bool get_ResolveMissingAssemblies();
    public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity);
    private PortableExecutableReference CreateResolvedMissingReference(string fullPath);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    private PortableExecutableReference ResolveTrustedPlatformAssembly(string name, MetadataReferenceProperties properties);
    internal static ImmutableArray`1<string> GetTrustedPlatformAssemblyPaths();
    internal static ImmutableDictionary`2<string, string> GetTrustedPlatformAssemblies(ImmutableArray`1<string> paths);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RuntimeMetadataReferenceResolver other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    internal RuntimeMetadataReferenceResolver WithRelativePathResolver(RelativePathResolver resolver);
}
internal class Microsoft.CodeAnalysis.Scripting.Hosting.SearchPaths : SynchronizedList`1<string> {
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Scripting.Hosting.SynchronizedList`1 : object {
    private object _guard;
    private List`1<T> _list;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Scripting.IListExtensions : object {
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, ImmutableArray`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, T[] items);
}
internal static class Microsoft.CodeAnalysis.Scripting.ParameterValidationHelpers : object {
    internal static ImmutableArray`1<T> CheckImmutableArray(ImmutableArray`1<T> items, string parameterName);
    internal static ImmutableArray`1<T> ToImmutableArrayChecked(IEnumerable`1<T> items, string parameterName);
    internal static ImmutableArray`1<T> ConcatChecked(ImmutableArray`1<T> existing, IEnumerable`1<T> items, string parameterName);
    internal static void AddRangeChecked(ArrayBuilder`1<T> builder, IEnumerable`1<T> items, string parameterName);
    internal static IEnumerable`1<S> SelectChecked(IEnumerable`1<T> items, string parameterName, Func`2<T, S> selector);
    internal static void RequireNonNull(IEnumerable`1<T> items, string parameterName);
}
internal static class Microsoft.CodeAnalysis.Scripting.PdbHelpers : object {
    public static DebugInformationFormat GetPlatformSpecificDebugInformationFormat();
}
public abstract class Microsoft.CodeAnalysis.Scripting.Script : object {
    internal ScriptCompiler Compiler;
    internal ScriptBuilder Builder;
    private Compilation _lazyCompilation;
    [CompilerGeneratedAttribute]
private Script <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <SourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GlobalsType>k__BackingField;
    internal static MetadataReferenceProperties HostAssemblyReferenceProperties;
    public Script Previous { get; }
    public ScriptOptions Options { get; }
    public string Code { get; }
    internal SourceText SourceText { get; }
    public Type GlobalsType { get; }
    public Type ReturnType { get; }
    internal Script(ScriptCompiler compiler, ScriptBuilder builder, SourceText sourceText, ScriptOptions options, Type globalsTypeOpt, Script previousOpt);
    private static Script();
    internal static Script`1<T> CreateInitialScript(ScriptCompiler compiler, SourceText sourceText, ScriptOptions optionsOpt, Type globalsTypeOpt, InteractiveAssemblyLoader assemblyLoaderOpt);
    [CompilerGeneratedAttribute]
public Script get_Previous();
    [CompilerGeneratedAttribute]
public ScriptOptions get_Options();
    public string get_Code();
    [CompilerGeneratedAttribute]
internal SourceText get_SourceText();
    [CompilerGeneratedAttribute]
public Type get_GlobalsType();
    public abstract virtual Type get_ReturnType();
    public Script WithOptions(ScriptOptions options);
    internal abstract virtual Script WithOptionsInternal(ScriptOptions options);
    public Script`1<object> ContinueWith(string code, ScriptOptions options);
    public Script`1<object> ContinueWith(Stream code, ScriptOptions options);
    public Script`1<TResult> ContinueWith(string code, ScriptOptions options);
    public Script`1<TResult> ContinueWith(Stream code, ScriptOptions options);
    private static ScriptOptions InheritOptions(ScriptOptions previous);
    public Compilation GetCompilation();
    internal Task`1<object> EvaluateAsync(object globals, CancellationToken cancellationToken);
    internal abstract virtual Task`1<object> CommonEvaluateAsync(object globals, CancellationToken cancellationToken);
    public Task`1<ScriptState> RunAsync(object globals, CancellationToken cancellationToken);
    public Task`1<ScriptState> RunAsync(object globals, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    internal abstract virtual Task`1<ScriptState> CommonRunAsync(object globals, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    public Task`1<ScriptState> RunFromAsync(ScriptState previousState, CancellationToken cancellationToken);
    public Task`1<ScriptState> RunFromAsync(ScriptState previousState, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    internal abstract virtual Task`1<ScriptState> CommonRunFromAsync(ScriptState previousState, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    public ImmutableArray`1<Diagnostic> Compile(CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<Diagnostic> CommonCompile(CancellationToken cancellationToken);
    internal abstract virtual Func`2<Object[], Task> CommonGetExecutor(CancellationToken cancellationToken);
    internal ImmutableArray`1<MetadataReference> GetReferencesForCompilation(CommonMessageProvider messageProvider, DiagnosticBag diagnostics, MetadataReference languageRuntimeReferenceOpt);
    internal bool HasReturnValue();
}
public class Microsoft.CodeAnalysis.Scripting.Script`1 : Script {
    private ImmutableArray`1<Func`2<Object[], Task>> _lazyPrecedingExecutors;
    private Func`2<Object[], Task`1<T>> _lazyExecutor;
    public Type ReturnType { get; }
    internal Script`1(ScriptCompiler compiler, ScriptBuilder builder, SourceText sourceText, ScriptOptions options, Type globalsTypeOpt, Script previousOpt);
    public virtual Type get_ReturnType();
    public Script`1<T> WithOptions(ScriptOptions options);
    internal virtual Script WithOptionsInternal(ScriptOptions options);
    internal virtual ImmutableArray`1<Diagnostic> CommonCompile(CancellationToken cancellationToken);
    internal virtual Func`2<Object[], Task> CommonGetExecutor(CancellationToken cancellationToken);
    internal virtual Task`1<object> CommonEvaluateAsync(object globals, CancellationToken cancellationToken);
    internal virtual Task`1<ScriptState> CommonRunAsync(object globals, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    internal virtual Task`1<ScriptState> CommonRunFromAsync(ScriptState previousState, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    private Func`2<Object[], Task`1<T>> GetExecutor(CancellationToken cancellationToken);
    private ImmutableArray`1<Func`2<Object[], Task>> GetPrecedingExecutors(CancellationToken cancellationToken);
    private ImmutableArray`1<Func`2<Object[], Task>> TryGetPrecedingExecutors(Script lastExecutedScriptInChainOpt, CancellationToken cancellationToken);
    internal Task`1<T> EvaluateAsync(object globals, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<T>> RunAsync(object globals, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<T>> RunAsync(object globals, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    public ScriptRunner`1<T> CreateDelegate(CancellationToken cancellationToken);
    public Task`1<ScriptState`1<T>> RunFromAsync(ScriptState previousState, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<T>> RunFromAsync(ScriptState previousState, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Scripting.Script`1/<RunSubmissionsAsync>d__21")]
private Task`1<ScriptState`1<T>> RunSubmissionsAsync(ScriptExecutionState executionState, ImmutableArray`1<Func`2<Object[], Task>> precedingExecutors, Func`2<Object[], Task> currentExecutor, Func`2<Exception, bool> catchExceptionOpt, CancellationToken cancellationToken);
    private static void ValidateGlobals(object globals, Type globalsType);
}
internal class Microsoft.CodeAnalysis.Scripting.ScriptBuilder : object {
    private static string s_globalAssemblyNamePrefix;
    private static int s_engineIdDispenser;
    private int _submissionIdDispenser;
    private string _assemblyNamePrefix;
    private InteractiveAssemblyLoader _assemblyLoader;
    private static EmitOptions s_EmitOptionsWithDebuggingInformation;
    private static ScriptBuilder();
    public ScriptBuilder(InteractiveAssemblyLoader assemblyLoader);
    public int GenerateSubmissionId(String& assemblyName, String& typeName);
    internal Func`2<Object[], Task`1<T>> CreateExecutor(ScriptCompiler compiler, Compilation compilation, bool emitDebugInformation, CancellationToken cancellationToken);
    private static void ThrowIfAnyCompilationErrors(DiagnosticBag diagnostics, DiagnosticFormatter formatter);
    private Func`2<Object[], Task`1<T>> Build(Compilation compilation, DiagnosticBag diagnostics, bool emitDebugInformation, CancellationToken cancellationToken);
    internal static EmitOptions GetEmitOptions(bool emitDebugInformation);
    internal static EmitResult Emit(Stream peStream, Stream pdbStreamOpt, Compilation compilation, EmitOptions options, CancellationToken cancellationToken);
    internal static MethodInfo GetEntryPointRuntimeMethod(IMethodSymbol entryPoint, Assembly assembly);
}
internal abstract class Microsoft.CodeAnalysis.Scripting.ScriptCompiler : object {
    public DiagnosticFormatter DiagnosticFormatter { get; }
    public StringComparer IdentifierComparer { get; }
    public abstract virtual Compilation CreateSubmission(Script script);
    public abstract virtual DiagnosticFormatter get_DiagnosticFormatter();
    public abstract virtual StringComparer get_IdentifierComparer();
    public abstract virtual SyntaxTree ParseSubmission(SourceText text, ParseOptions parseOptions, CancellationToken cancellationToken);
    public abstract virtual bool IsCompleteSubmission(SyntaxTree tree);
}
internal class Microsoft.CodeAnalysis.Scripting.ScriptExecutionState : object {
    private Object[] _submissionStates;
    private int _count;
    private int _frozen;
    public int SubmissionStateCount { get; }
    private ScriptExecutionState(Object[] submissionStates, int count);
    public static ScriptExecutionState Create(object globals);
    public ScriptExecutionState FreezeAndClone();
    public int get_SubmissionStateCount();
    public object GetSubmissionState(int index);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Scripting.ScriptExecutionState/<RunSubmissionsAsync>d__9`1")]
internal Task`1<TResult> RunSubmissionsAsync(ImmutableArray`1<Func`2<Object[], Task>> precedingExecutors, Func`2<Object[], Task> currentExecutor, StrongBox`1<Exception> exceptionHolderOpt, Func`2<Exception, bool> catchExceptionOpt, CancellationToken cancellationToken);
    private void EnsureStateCapacity();
    private void AdvanceStateCounter();
}
internal static class Microsoft.CodeAnalysis.Scripting.ScriptingResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string StackOverflowWhileEvaluating { get; }
    internal static string CantAssignTo { get; }
    internal static string ExpectedAnAssemblyReference { get; }
    internal static string DisplayNameOrPathCannotBe { get; }
    internal static string AbsolutePathExpected { get; }
    internal static string GlobalsNotAssignable { get; }
    internal static string StartingStateIncompatible { get; }
    internal static string InvalidAssemblyName { get; }
    internal static string InvalidCharactersInAssemblyName { get; }
    internal static string ScriptRequiresGlobalVariables { get; }
    internal static string GlobalVariablesWithoutGlobalType { get; }
    internal static string PlusAdditionalError { get; }
    internal static string PlusAdditionalErrors { get; }
    internal static string AtFileLine { get; }
    internal static string CannotSetReadOnlyVariable { get; }
    internal static string CannotSetConstantVariable { get; }
    internal static string HelpPrompt { get; }
    internal static string HelpText { get; }
    internal static string AssemblyAlreadyLoaded { get; }
    internal static string AssemblyAlreadyLoadedNotSigned { get; }
    internal static string CannotSetLanguageSpecificOption { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_StackOverflowWhileEvaluating();
    internal static string get_CantAssignTo();
    internal static string get_ExpectedAnAssemblyReference();
    internal static string get_DisplayNameOrPathCannotBe();
    internal static string get_AbsolutePathExpected();
    internal static string get_GlobalsNotAssignable();
    internal static string get_StartingStateIncompatible();
    internal static string get_InvalidAssemblyName();
    internal static string get_InvalidCharactersInAssemblyName();
    internal static string get_ScriptRequiresGlobalVariables();
    internal static string get_GlobalVariablesWithoutGlobalType();
    internal static string get_PlusAdditionalError();
    internal static string get_PlusAdditionalErrors();
    internal static string get_AtFileLine();
    internal static string get_CannotSetReadOnlyVariable();
    internal static string get_CannotSetConstantVariable();
    internal static string get_HelpPrompt();
    internal static string get_HelpText();
    internal static string get_AssemblyAlreadyLoaded();
    internal static string get_AssemblyAlreadyLoadedNotSigned();
    internal static string get_CannotSetLanguageSpecificOption();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Scripting.ScriptMetadataResolver : MetadataReferenceResolver {
    [CompilerGeneratedAttribute]
private static ScriptMetadataResolver <Default>k__BackingField;
    private RuntimeMetadataReferenceResolver _resolver;
    public static ScriptMetadataResolver Default { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public bool ResolveMissingAssemblies { get; }
    internal ScriptMetadataResolver(RuntimeMetadataReferenceResolver resolver);
    private static ScriptMetadataResolver();
    [CompilerGeneratedAttribute]
public static ScriptMetadataResolver get_Default();
    public ImmutableArray`1<string> get_SearchPaths();
    public string get_BaseDirectory();
    public ScriptMetadataResolver WithSearchPaths(String[] searchPaths);
    public ScriptMetadataResolver WithSearchPaths(IEnumerable`1<string> searchPaths);
    public ScriptMetadataResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public ScriptMetadataResolver WithBaseDirectory(string baseDirectory);
    public virtual bool get_ResolveMissingAssemblies();
    public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ScriptMetadataResolver other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.Scripting.ScriptOptions : object {
    [CompilerGeneratedAttribute]
private static ScriptOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MetadataReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReferenceResolver <MetadataResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceReferenceResolver <SourceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <FileEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private OptimizationLevel <OptimizationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    private static MetadataReferenceProperties s_assemblyReferenceProperties;
    public static ScriptOptions Default { get; }
    public ImmutableArray`1<MetadataReference> MetadataReferences { get; private set; }
    public MetadataReferenceResolver MetadataResolver { get; private set; }
    public SourceReferenceResolver SourceResolver { get; private set; }
    public ImmutableArray`1<string> Imports { get; private set; }
    public bool EmitDebugInformation { get; private set; }
    public Encoding FileEncoding { get; private set; }
    public string FilePath { get; private set; }
    public OptimizationLevel OptimizationLevel { get; private set; }
    public bool CheckOverflow { get; private set; }
    public bool AllowUnsafe { get; private set; }
    public int WarningLevel { get; private set; }
    internal ParseOptions ParseOptions { get; private set; }
    internal ScriptOptions(string filePath, ImmutableArray`1<MetadataReference> references, ImmutableArray`1<string> namespaces, MetadataReferenceResolver metadataResolver, SourceReferenceResolver sourceResolver, bool emitDebugInformation, Encoding fileEncoding, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, int warningLevel, ParseOptions parseOptions);
    private ScriptOptions(ScriptOptions other);
    private static ScriptOptions();
    [CompilerGeneratedAttribute]
public static ScriptOptions get_Default();
    private static ImmutableArray`1<MetadataReference> GetDefaultMetadataReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MetadataReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
private void set_MetadataReferences(ImmutableArray`1<MetadataReference> value);
    [CompilerGeneratedAttribute]
public MetadataReferenceResolver get_MetadataResolver();
    [CompilerGeneratedAttribute]
private void set_MetadataResolver(MetadataReferenceResolver value);
    [CompilerGeneratedAttribute]
public SourceReferenceResolver get_SourceResolver();
    [CompilerGeneratedAttribute]
private void set_SourceResolver(SourceReferenceResolver value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Imports();
    [CompilerGeneratedAttribute]
private void set_Imports(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_EmitDebugInformation();
    [CompilerGeneratedAttribute]
private void set_EmitDebugInformation(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_FileEncoding();
    [CompilerGeneratedAttribute]
private void set_FileEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public OptimizationLevel get_OptimizationLevel();
    [CompilerGeneratedAttribute]
private void set_OptimizationLevel(OptimizationLevel value);
    [CompilerGeneratedAttribute]
public bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
private void set_CheckOverflow(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsafe();
    [CompilerGeneratedAttribute]
private void set_AllowUnsafe(bool value);
    [CompilerGeneratedAttribute]
public int get_WarningLevel();
    [CompilerGeneratedAttribute]
private void set_WarningLevel(int value);
    [CompilerGeneratedAttribute]
internal ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
private void set_ParseOptions(ParseOptions value);
    public ScriptOptions WithFilePath(string filePath);
    private static MetadataReference CreateUnresolvedReference(string reference);
    private ScriptOptions WithReferences(ImmutableArray`1<MetadataReference> references);
    public ScriptOptions WithReferences(IEnumerable`1<MetadataReference> references);
    public ScriptOptions WithReferences(MetadataReference[] references);
    public ScriptOptions AddReferences(IEnumerable`1<MetadataReference> references);
    public ScriptOptions AddReferences(MetadataReference[] references);
    public ScriptOptions WithReferences(IEnumerable`1<Assembly> references);
    public ScriptOptions WithReferences(Assembly[] references);
    public ScriptOptions AddReferences(IEnumerable`1<Assembly> references);
    private static MetadataReference CreateReferenceFromAssembly(Assembly assembly);
    public ScriptOptions AddReferences(Assembly[] references);
    public ScriptOptions WithReferences(IEnumerable`1<string> references);
    public ScriptOptions WithReferences(String[] references);
    public ScriptOptions AddReferences(IEnumerable`1<string> references);
    public ScriptOptions AddReferences(String[] references);
    public ScriptOptions WithMetadataResolver(MetadataReferenceResolver resolver);
    public ScriptOptions WithSourceResolver(SourceReferenceResolver resolver);
    private ScriptOptions WithImports(ImmutableArray`1<string> imports);
    public ScriptOptions WithImports(IEnumerable`1<string> imports);
    public ScriptOptions WithImports(String[] imports);
    public ScriptOptions AddImports(IEnumerable`1<string> imports);
    public ScriptOptions AddImports(String[] imports);
    public ScriptOptions WithEmitDebugInformation(bool emitDebugInformation);
    public ScriptOptions WithFileEncoding(Encoding encoding);
    public ScriptOptions WithOptimizationLevel(OptimizationLevel optimizationLevel);
    public ScriptOptions WithAllowUnsafe(bool allowUnsafe);
    public ScriptOptions WithCheckOverflow(bool checkOverflow);
    public ScriptOptions WithWarningLevel(int warningLevel);
    internal ScriptOptions WithParseOptions(ParseOptions parseOptions);
}
public class Microsoft.CodeAnalysis.Scripting.ScriptRunner`1 : MulticastDelegate {
    public ScriptRunner`1(object object, IntPtr method);
    public virtual Task`1<T> Invoke(object globals, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(object globals, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<T> EndInvoke(IAsyncResult result);
}
public class Microsoft.CodeAnalysis.Scripting.ScriptSourceResolver : SourceFileResolver {
    [CompilerGeneratedAttribute]
private static ScriptSourceResolver <Default>k__BackingField;
    public static ScriptSourceResolver Default { get; }
    private ScriptSourceResolver(ImmutableArray`1<string> sourcePaths, string baseDirectory);
    private static ScriptSourceResolver();
    [CompilerGeneratedAttribute]
public static ScriptSourceResolver get_Default();
    public ScriptSourceResolver WithSearchPaths(String[] searchPaths);
    public ScriptSourceResolver WithSearchPaths(IEnumerable`1<string> searchPaths);
    public ScriptSourceResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public ScriptSourceResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(ScriptSourceResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Microsoft.CodeAnalysis.Scripting.ScriptState : object {
    [CompilerGeneratedAttribute]
private Script <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptExecutionState <ExecutionState>k__BackingField;
    private ImmutableArray`1<ScriptVariable> _lazyVariables;
    private IReadOnlyDictionary`2<string, int> _lazyVariableMap;
    public Script Script { get; }
    public Exception Exception { get; }
    internal ScriptExecutionState ExecutionState { get; }
    public object ReturnValue { get; }
    public ImmutableArray`1<ScriptVariable> Variables { get; }
    internal ScriptState(ScriptExecutionState executionState, Script script, Exception exceptionOpt);
    [CompilerGeneratedAttribute]
public Script get_Script();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
internal ScriptExecutionState get_ExecutionState();
    public object get_ReturnValue();
    internal abstract virtual object GetReturnValue();
    public ImmutableArray`1<ScriptVariable> get_Variables();
    public ScriptVariable GetVariable(string name);
    private ImmutableArray`1<ScriptVariable> CreateVariables();
    private IReadOnlyDictionary`2<string, int> GetVariableMap();
    public Task`1<ScriptState`1<object>> ContinueWithAsync(string code, ScriptOptions options, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<object>> ContinueWithAsync(string code, ScriptOptions options, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<TResult>> ContinueWithAsync(string code, ScriptOptions options, CancellationToken cancellationToken);
    public Task`1<ScriptState`1<TResult>> ContinueWithAsync(string code, ScriptOptions options, Func`2<Exception, bool> catchException, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.Scripting.ScriptState`1 : ScriptState {
    [CompilerGeneratedAttribute]
private T <ReturnValue>k__BackingField;
    public T ReturnValue { get; }
    internal ScriptState`1(ScriptExecutionState executionState, Script script, T value, Exception exceptionOpt);
    [CompilerGeneratedAttribute]
public T get_ReturnValue();
    internal virtual object GetReturnValue();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Scripting.ScriptStateTaskExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Scripting.ScriptStateTaskExtensions/<CastAsync>d__0`2")]
[ExtensionAttribute]
internal static Task`1<T> CastAsync(Task`1<S> task);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Scripting.ScriptStateTaskExtensions/<GetEvaluationResultAsync>d__1`1")]
[ExtensionAttribute]
internal static Task`1<T> GetEvaluationResultAsync(Task`1<ScriptState`1<T>> task);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Scripting.ScriptVariable : object {
    private object _instance;
    private FieldInfo _field;
    public string Name { get; }
    public Type Type { get; }
    public bool IsReadOnly { get; }
    public object Value { get; public set; }
    internal ScriptVariable(object instance, FieldInfo field);
    public string get_Name();
    public Type get_Type();
    public bool get_IsReadOnly();
    public object get_Value();
    public void set_Value(object value);
    private string GetDebuggerDisplay();
}
internal static class Roslyn.Utilities.CoreLightup : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
