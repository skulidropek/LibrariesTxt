[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.AddressSpaceExtensions : object {
    [ExtensionAttribute]
public static Byte[] Read(IAddressSpace addressSpace, ulong position, UInt32 count);
}
public static class Microsoft.FileFormats.ArrayHelper : object {
    public static E[] New(UInt32 count);
}
internal class Microsoft.FileFormats.ArrayLayout : LayoutBase {
    private UInt32 _numElements;
    private ILayout _elementLayout;
    public ArrayLayout(Type arrayType, ILayout elementLayout, UInt32 numElements);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
[AttributeUsageAttribute("256")]
public class Microsoft.FileFormats.ArraySizeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <NumElements>k__BackingField;
    public UInt32 NumElements { get; private set; }
    public ArraySizeAttribute(UInt32 numElements);
    [CompilerGeneratedAttribute]
public UInt32 get_NumElements();
    [CompilerGeneratedAttribute]
private void set_NumElements(UInt32 value);
}
public class Microsoft.FileFormats.BadInputFormatException : InputParsingException {
    public BadInputFormatException(string message);
}
public class Microsoft.FileFormats.BoolLayout : PrimitiveTypeLayout {
    public BoolLayout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.CharLayout : PrimitiveTypeLayout {
    public CharLayout(bool isBigEndian);
    public CharLayout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.DoubleLayout : PrimitiveTypeLayout {
    public DoubleLayout(bool isBigEndian);
    public DoubleLayout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public enum Microsoft.FileFormats.ELF.ELFClass : Enum {
    public byte value__;
    public static ELFClass None;
    public static ELFClass Class32;
    public static ELFClass Class64;
}
public class Microsoft.FileFormats.ELF.ELFCoreFile : object {
    private ELFFile _elf;
    private Lazy`1<ELFFileTable> _fileTable;
    private Lazy`1<ELFLoadedImage[]> _images;
    public ELFFileTable FileTable { get; }
    public ELFLoadedImage[] LoadedImages { get; }
    public IAddressSpace DataSource { get; }
    public bool Is64Bit { get; }
    public IEnumerable`1<ELFProgramSegment> Segments { get; }
    public ELFCoreFile(IAddressSpace dataSource);
    public ELFFileTable get_FileTable();
    public ELFLoadedImage[] get_LoadedImages();
    public IAddressSpace get_DataSource();
    public bool IsValid();
    public bool get_Is64Bit();
    public IEnumerable`1<ELFProgramSegment> get_Segments();
    private ELFFileTable ReadFileTable();
    private ELFLoadedImage[] ReadLoadedImages();
}
public enum Microsoft.FileFormats.ELF.ELFData : Enum {
    public byte value__;
    public static ELFData None;
    public static ELFData LittleEndian;
    public static ELFData BigEndian;
}
public class Microsoft.FileFormats.ELF.ELFFile : object {
    private ulong _position;
    private bool _isDataSourceVirtualAddressSpace;
    private Reader _reader;
    private Lazy`1<ELFHeaderIdent> _ident;
    private Lazy`1<Reader> _dataSourceReader;
    private Lazy`1<ELFHeader> _header;
    private Lazy`1<IEnumerable`1<ELFProgramSegment>> _segments;
    private Lazy`1<ELFSection[]> _sections;
    private Lazy`1<Reader> _virtualAddressReader;
    private Lazy`1<Byte[]> _buildId;
    private Lazy`1<Byte[]> _sectionNameTable;
    public ELFHeaderIdent Ident { get; }
    public ELFHeader Header { get; }
    private Reader DataSourceReader { get; }
    public IEnumerable`1<ELFProgramSegment> Segments { get; }
    public ELFSection[] Sections { get; }
    public Reader VirtualAddressReader { get; }
    public Byte[] BuildID { get; }
    public Byte[] SectionNameTable { get; }
    public bool IsBigEndian { get; }
    public bool Is64Bit { get; }
    public ulong PreferredVMBaseAddress { get; }
    public ValidationRule IsHeaderProgramHeaderOffsetValid { get; }
    public ValidationRule IsHeaderProgramHeaderEntrySizeValid { get; }
    public ValidationRule IsHeaderSectionHeaderOffsetValid { get; }
    public ValidationRule IsHeaderSectionHeaderEntrySizeValid { get; }
    public ELFFile(IAddressSpace dataSource, ulong position, bool isDataSourceVirtualAddressSpace);
    public ELFHeaderIdent get_Ident();
    public ELFHeader get_Header();
    private Reader get_DataSourceReader();
    public IEnumerable`1<ELFProgramSegment> get_Segments();
    public ELFSection[] get_Sections();
    public Reader get_VirtualAddressReader();
    public Byte[] get_BuildID();
    public Byte[] get_SectionNameTable();
    public sealed virtual void Dispose();
    public bool IsValid();
    public bool get_IsBigEndian();
    public bool get_Is64Bit();
    public ulong get_PreferredVMBaseAddress();
    public ELFSection FindSectionByName(string name);
    private IEnumerable`1<ELFProgramSegment> ReadSegments();
    private ELFSection[] ReadSections();
    private Reader CreateVirtualAddressReader();
    private Byte[] ReadBuildId();
    private Byte[] ReadBuildIdNote(Reader noteReader);
    private Byte[] ReadSectionNameTable();
    public ValidationRule get_IsHeaderProgramHeaderOffsetValid();
    public ValidationRule get_IsHeaderProgramHeaderEntrySizeValid();
    public ValidationRule get_IsHeaderSectionHeaderOffsetValid();
    public ValidationRule get_IsHeaderSectionHeaderEntrySizeValid();
    [CompilerGeneratedAttribute]
private bool <get_IsHeaderProgramHeaderOffsetValid>b__44_0();
    [CompilerGeneratedAttribute]
private bool <get_IsHeaderProgramHeaderEntrySizeValid>b__46_0();
    [CompilerGeneratedAttribute]
private bool <get_IsHeaderSectionHeaderOffsetValid>b__48_0();
    [CompilerGeneratedAttribute]
private bool <get_IsHeaderSectionHeaderEntrySizeValid>b__50_0();
}
public class Microsoft.FileFormats.ELF.ELFFileTable : object {
    private Reader _noteReader;
    private Lazy`1<IEnumerable`1<ELFFileTableEntry>> _files;
    public IEnumerable`1<ELFFileTableEntry> Files { get; }
    public ELFFileTable(Reader noteReader);
    public IEnumerable`1<ELFFileTableEntry> get_Files();
    private IEnumerable`1<ELFFileTableEntry> ReadFiles();
}
public class Microsoft.FileFormats.ELF.ELFFileTableEntry : object {
    private ELFFileTableEntryPointers _ptrs;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public ulong PageOffset { get; }
    public ulong LoadAddress { get; }
    public string Path { get; private set; }
    public ELFFileTableEntry(string path, ELFFileTableEntryPointers ptrs);
    public ulong get_PageOffset();
    public ulong get_LoadAddress();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public class Microsoft.FileFormats.ELF.ELFFileTableEntryPointers : TStruct {
    public VirtualAddress Start;
    public VirtualAddress Stop;
    public SizeT PageOffset;
}
public class Microsoft.FileFormats.ELF.ELFFileTableHeader : TStruct {
    public SizeT EntryCount;
    public SizeT PageSize;
}
public class Microsoft.FileFormats.ELF.ELFHeader : ELFHeaderIdent {
    public ELFHeaderType Type;
    public ushort Machine;
    public UInt32 Version;
    public VirtualAddress Entry;
    public FileOffset ProgramHeaderOffset;
    public FileOffset SectionHeaderOffset;
    public UInt32 Flags;
    public ushort EHSize;
    public ushort ProgramHeaderEntrySize;
    public ushort ProgramHeaderCount;
    public ushort SectionHeaderEntrySize;
    public ushort SectionHeaderCount;
    public ushort SectionHeaderStringIndex;
    public ValidationRule IsProgramHeaderCountReasonable { get; }
    public ValidationRule IsSectionHeaderCountReasonable { get; }
    public ValidationRule get_IsProgramHeaderCountReasonable();
    public ValidationRule get_IsSectionHeaderCountReasonable();
    [CompilerGeneratedAttribute]
private bool <get_IsProgramHeaderCountReasonable>b__14_0();
    [CompilerGeneratedAttribute]
private bool <get_IsSectionHeaderCountReasonable>b__16_0();
}
public class Microsoft.FileFormats.ELF.ELFHeaderIdent : TStruct {
    [ArraySizeAttribute("16")]
public Byte[] Ident;
    public ELFClass Class { get; }
    public ELFData Data { get; }
    public ValidationRule IsIdentMagicValid { get; }
    public ValidationRule IsClassValid { get; }
    public ValidationRule IsDataValid { get; }
    public ELFClass get_Class();
    public ELFData get_Data();
    public ValidationRule get_IsIdentMagicValid();
    public ValidationRule get_IsClassValid();
    public ValidationRule get_IsDataValid();
    [CompilerGeneratedAttribute]
private bool <get_IsIdentMagicValid>b__6_0();
    [CompilerGeneratedAttribute]
private bool <get_IsClassValid>b__8_0();
    [CompilerGeneratedAttribute]
private bool <get_IsDataValid>b__10_0();
}
public enum Microsoft.FileFormats.ELF.ELFHeaderType : Enum {
    public ushort value__;
    public static ELFHeaderType Relocatable;
    public static ELFHeaderType Executable;
    public static ELFHeaderType Shared;
    public static ELFHeaderType Core;
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.ELF.ELFLayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddELFTypes(LayoutManager layouts, bool isBigEndian, bool is64Bit);
}
public class Microsoft.FileFormats.ELF.ELFLoadedImage : object {
    private ulong _loadAddress;
    private ulong _minimumPointer;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ELFFile <Image>k__BackingField;
    public ulong LoadAddress { get; }
    public string Path { get; }
    public ELFFile Image { get; internal set; }
    public ELFLoadedImage(ELFFile image, ELFFileTableEntry entry);
    public ELFLoadedImage(string path);
    public ulong get_LoadAddress();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public ELFFile get_Image();
    [CompilerGeneratedAttribute]
internal void set_Image(ELFFile value);
    internal void AddTableEntryPointers(ELFFileTableEntry entry);
}
public class Microsoft.FileFormats.ELF.ELFNote : object {
    private Reader _elfSegmentReader;
    private ulong _noteHeaderOffset;
    private Lazy`1<ELFNoteHeader> _header;
    private Lazy`1<string> _name;
    private Lazy`1<Reader> _contents;
    public ELFNoteHeader Header { get; }
    public UInt32 Size { get; }
    public string Name { get; }
    public Reader Contents { get; }
    private UInt32 HeaderSize { get; }
    public ELFNote(Reader elfSegmentReader, ulong offset);
    public ELFNoteHeader get_Header();
    public UInt32 get_Size();
    public string get_Name();
    public Reader get_Contents();
    private UInt32 get_HeaderSize();
    private string ReadName();
    private Reader CreateContentsReader();
    private UInt32 Align4(UInt32 x);
    [CompilerGeneratedAttribute]
private ELFNoteHeader <.ctor>b__5_0();
}
public class Microsoft.FileFormats.ELF.ELFNoteHeader : TStruct {
    public UInt32 NameSize;
    public UInt32 ContentSize;
    public ELFNoteType Type;
}
public class Microsoft.FileFormats.ELF.ELFNoteList : object {
    private Reader _elfSegmentReader;
    private Lazy`1<IEnumerable`1<ELFNote>> _notes;
    public IEnumerable`1<ELFNote> Notes { get; }
    public ELFNoteList(Reader elfSegmentReader);
    public IEnumerable`1<ELFNote> get_Notes();
    private IEnumerable`1<ELFNote> ReadNotes();
}
public enum Microsoft.FileFormats.ELF.ELFNoteType : Enum {
    public int value__;
    public static ELFNoteType PrpsInfo;
    public static ELFNoteType GnuBuildId;
    public static ELFNoteType File;
}
public class Microsoft.FileFormats.ELF.ELFProgramHeader : TStruct {
    public ELFProgramHeaderType Type;
    [IfAttribute("64BIT")]
public UInt32 Flags;
    public FileOffset FileOffset;
    public VirtualAddress VirtualAddress;
    public SizeT PhysicalAddress;
    public SizeT FileSize;
    public SizeT VirtualSize;
    [IfAttribute("32BIT")]
public UInt32 Flags32;
    public SizeT Alignment;
}
[FlagsAttribute]
public enum Microsoft.FileFormats.ELF.ELFProgramHeaderFlags : Enum {
    public UInt32 value__;
    public static ELFProgramHeaderFlags Executable;
    public static ELFProgramHeaderFlags Writable;
    public static ELFProgramHeaderFlags Readable;
    public static ELFProgramHeaderFlags ReadWriteExecute;
    public static ELFProgramHeaderFlags OSMask;
    public static ELFProgramHeaderFlags ProcessorMask;
}
public enum Microsoft.FileFormats.ELF.ELFProgramHeaderType : Enum {
    public UInt32 value__;
    public static ELFProgramHeaderType Null;
    public static ELFProgramHeaderType Load;
    public static ELFProgramHeaderType Dynamic;
    public static ELFProgramHeaderType Interp;
    public static ELFProgramHeaderType Note;
    public static ELFProgramHeaderType Shlib;
    public static ELFProgramHeaderType Phdr;
    public static ELFProgramHeaderType GnuEHFrame;
}
public class Microsoft.FileFormats.ELF.ELFProgramSegment : object {
    private Lazy`1<Reader> _contents;
    [CompilerGeneratedAttribute]
private ELFProgramHeader <Header>k__BackingField;
    public ELFProgramHeader Header { get; }
    public Reader Contents { get; }
    public ELFProgramSegment(Reader dataSourceReader, ulong elfOffset, ulong programHeaderOffset, bool isDataSourceVirtualAddressSpace);
    [CompilerGeneratedAttribute]
public ELFProgramHeader get_Header();
    public Reader get_Contents();
    public virtual string ToString();
}
public class Microsoft.FileFormats.ELF.ELFSection : object {
    private ELFFile _elfFile;
    private Reader _dataSourceReader;
    private Lazy`1<ELFSectionHeader> _header;
    private Lazy`1<string> _name;
    private Lazy`1<Reader> _contents;
    private static ASCIIEncoding _decoder;
    public ELFSectionHeader Header { get; }
    public string Name { get; }
    public Reader Contents { get; }
    public ELFSection(ELFFile elfFile, Reader dataSourceReader, ulong elfOffset, ulong sectionHeaderOffset);
    private static ELFSection();
    public ELFSectionHeader get_Header();
    public string get_Name();
    public Reader get_Contents();
    private string ReadName();
}
public class Microsoft.FileFormats.ELF.ELFSectionHeader : TStruct {
    public UInt32 NameIndex;
    public ELFSectionHeaderType Type;
    public SizeT Flags;
    public VirtualAddress VirtualAddress;
    public FileOffset FileOffset;
    public SizeT FileSize;
    public UInt32 Link;
    public UInt32 Info;
    public SizeT Alignment;
    public SizeT EntrySize;
}
public enum Microsoft.FileFormats.ELF.ELFSectionHeaderType : Enum {
    public UInt32 value__;
    public static ELFSectionHeaderType Null;
    public static ELFSectionHeaderType ProgBits;
    public static ELFSectionHeaderType SymTab;
    public static ELFSectionHeaderType StrTab;
    public static ELFSectionHeaderType Rela;
    public static ELFSectionHeaderType Hash;
    public static ELFSectionHeaderType Dynamic;
    public static ELFSectionHeaderType Note;
    public static ELFSectionHeaderType NoBits;
    public static ELFSectionHeaderType Rel;
    public static ELFSectionHeaderType ShLib;
    public static ELFSectionHeaderType DynSym;
    public static ELFSectionHeaderType InitArray;
    public static ELFSectionHeaderType FiniArray;
    public static ELFSectionHeaderType PreInitArray;
    public static ELFSectionHeaderType Group;
    public static ELFSectionHeaderType SymTabIndexes;
    public static ELFSectionHeaderType Num;
    public static ELFSectionHeaderType GnuAttributes;
    public static ELFSectionHeaderType GnuHash;
    public static ELFSectionHeaderType GnuLibList;
    public static ELFSectionHeaderType CheckSum;
    public static ELFSectionHeaderType GnuVerDef;
    public static ELFSectionHeaderType GnuVerNeed;
    public static ELFSectionHeaderType GnuVerSym;
}
public class Microsoft.FileFormats.ELF.ELFVirtualAddressSpace : object {
    private ELFProgramSegment[] _segments;
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public ulong Length { get; private set; }
    public ELFVirtualAddressSpace(IEnumerable`1<ELFProgramSegment> segments);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
}
public class Microsoft.FileFormats.ELF.FileOffset : FileOffset`1<byte> {
}
public class Microsoft.FileFormats.ELF.FileOffset`1 : Pointer`2<T, SizeT> {
}
public class Microsoft.FileFormats.ELF.VirtualAddress : VirtualAddress`1<byte> {
}
public class Microsoft.FileFormats.ELF.VirtualAddress`1 : Pointer`2<T, SizeT> {
}
public class Microsoft.FileFormats.EnumLayout : LayoutBase {
    private ILayout _underlyingIntegralLayout;
    public EnumLayout(Type enumType, ILayout underlyingIntegralLayout);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
internal static class Microsoft.FileFormats.Helpers : object {
    private static Byte[] CharToHexLookup { get; }
    public static bool TryConvertHexStringToBytes(string hexString, Byte[]& bytes);
    private static Byte[] get_CharToHexLookup();
}
public interface Microsoft.FileFormats.IAddressSpace {
    public ulong Length { get; }
    public abstract virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    public abstract virtual ulong get_Length();
}
[AttributeUsageAttribute("256")]
public class Microsoft.FileFormats.IfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefineName>k__BackingField;
    public string DefineName { get; private set; }
    public IfAttribute(string defineName);
    [CompilerGeneratedAttribute]
public string get_DefineName();
    [CompilerGeneratedAttribute]
private void set_DefineName(string value);
}
public interface Microsoft.FileFormats.IField {
    public string Name { get; }
    public ILayout Layout { get; }
    public ILayout DeclaringLayout { get; }
    public UInt32 Offset { get; }
    public abstract virtual string get_Name();
    public abstract virtual ILayout get_Layout();
    public abstract virtual ILayout get_DeclaringLayout();
    public abstract virtual UInt32 get_Offset();
    public abstract virtual object GetValue(TStruct tStruct);
    public abstract virtual void SetValue(TStruct tStruct, object fieldValue);
}
public interface Microsoft.FileFormats.ILayout {
    public Type Type { get; }
    public UInt32 Size { get; }
    public bool IsFixedSize { get; }
    public UInt32 NaturalAlignment { get; }
    public IEnumerable`1<IField> Fields { get; }
    public UInt32 SizeAsBaseType { get; }
    public abstract virtual Type get_Type();
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual UInt32 get_NaturalAlignment();
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual UInt32 get_SizeAsBaseType();
    public abstract virtual object Read(IAddressSpace dataSource, ulong position);
    public abstract virtual object Read(IAddressSpace dataSource, ulong position, UInt32& bytesRead);
}
public abstract class Microsoft.FileFormats.InputParsingException : Exception {
    public InputParsingException(string message);
}
public class Microsoft.FileFormats.Int16Layout : PrimitiveTypeLayout {
    public Int16Layout(bool isBigEndian);
    public Int16Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.Int32Layout : PrimitiveTypeLayout {
    public Int32Layout(bool isBigEndian);
    public Int32Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.Int64Layout : PrimitiveTypeLayout {
    public Int64Layout(bool isBigEndian);
    public Int64Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.Int8Layout : PrimitiveTypeLayout {
    public Int8Layout(bool isBigEndian);
    public Int8Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.InvalidVirtualAddressException : InputParsingException {
    public InvalidVirtualAddressException(string message);
}
public abstract class Microsoft.FileFormats.LayoutBase : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IField> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NaturalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeAsBaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public IEnumerable`1<IField> Fields { get; private set; }
    public UInt32 NaturalAlignment { get; private set; }
    public bool IsFixedSize { get; private set; }
    public UInt32 Size { get; private set; }
    public UInt32 SizeAsBaseType { get; private set; }
    public Type Type { get; private set; }
    public LayoutBase(Type type);
    public LayoutBase(Type type, UInt32 size);
    public LayoutBase(Type type, UInt32 size, UInt32 naturalAlignment);
    public LayoutBase(Type type, UInt32 size, UInt32 naturalAlignment, UInt32 sizeAsBaseType);
    public LayoutBase(Type type, UInt32 size, UInt32 naturalAlignment, UInt32 sizeAsBaseType, IField[] fields);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IField> get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(IEnumerable`1<IField> value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_NaturalAlignment();
    [CompilerGeneratedAttribute]
private void set_NaturalAlignment(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFixedSize();
    [CompilerGeneratedAttribute]
private void set_IsFixedSize(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_SizeAsBaseType();
    [CompilerGeneratedAttribute]
private void set_SizeAsBaseType(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public virtual object Read(IAddressSpace dataSource, ulong position, UInt32& bytesRead);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.LayoutException : Exception {
    public LayoutException(string message);
}
public class Microsoft.FileFormats.LayoutManager : object {
    private Dictionary`2<Type, ILayout> _layouts;
    private List`1<Func`3<Type, LayoutManager, ILayout>> _layoutProviders;
    private Dictionary`2<Tuple`2<Type, UInt32>, ILayout> _arrayLayouts;
    public void AddLayout(ILayout layout);
    public void AddLayoutProvider(Func`3<Type, LayoutManager, ILayout> layoutProvider);
    public ILayout GetArrayLayout(Type arrayType, UInt32 numElements);
    public ILayout GetArrayLayout(UInt32 numElements);
    public ILayout GetLayout();
    public ILayout GetLayout(Type t);
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.LayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddEnumTypes(LayoutManager layoutManager);
    private static ILayout GetEnumLayout(Type enumType, LayoutManager layoutManager);
    [ExtensionAttribute]
public static LayoutManager AddNullTerminatedString(LayoutManager layouts);
    [ExtensionAttribute]
public static LayoutManager AddNullTerminatedString(LayoutManager layouts, Encoding encoding);
    [ExtensionAttribute]
public static LayoutManager AddPointerTypes(LayoutManager layouts);
    private static ILayout GetPointerLayout(Type pointerType, LayoutManager layoutManager);
    [ExtensionAttribute]
public static LayoutManager AddPrimitives(LayoutManager layouts, bool isBigEndian);
    [ExtensionAttribute]
public static LayoutManager AddSizeT(LayoutManager layouts, int size);
    [ExtensionAttribute]
public static LayoutManager AddTStructTypes(LayoutManager layouts);
    [ExtensionAttribute]
public static LayoutManager AddTStructTypes(LayoutManager layouts, IEnumerable`1<string> enabledDefines);
    [ExtensionAttribute]
public static LayoutManager AddReflectionTypes(LayoutManager layouts, IEnumerable`1<string> enabledDefines, Type requiredBaseType);
    [ExtensionAttribute]
public static LayoutManager AddReflectionTypes(LayoutManager layouts, IEnumerable`1<string> enabledDefines, Func`2<Type, bool> typeFilter);
    private static ILayout GetTStructLayout(Type tStructType, LayoutManager layoutManager, IEnumerable`1<string> enabledDefines);
    private static bool IsFieldIncludedInDefines(FieldInfo fieldInfo, IEnumerable`1<string> enabledDefines);
    private static ILayout GetFieldLayout(FieldInfo fieldInfo, LayoutManager layoutManager);
    private static UInt32 AlignUp(UInt32 p, UInt32 align);
}
public class Microsoft.FileFormats.MachO.DyldImageAllInfosV2 : DyldImageAllInfosVersion {
    public UInt32 InfoArrayCount;
    public SizeT InfoArray;
    public SizeT Notification;
    public SizeT Undetermined;
    public SizeT ImageLoadAddress;
}
public class Microsoft.FileFormats.MachO.DyldImageAllInfosVersion : TStruct {
    public UInt32 Version;
}
public class Microsoft.FileFormats.MachO.DyldImageInfo : TStruct {
    public SizeT Address;
    public SizeT PathAddress;
    public SizeT ModDate;
}
public class Microsoft.FileFormats.MachO.DyldLoadedImage : object {
    private DyldImageInfo _imageInfo;
    public string Path;
    public ulong LoadAddress { get; }
    public DyldLoadedImage(string path, DyldImageInfo imageInfo);
    public ulong get_LoadAddress();
}
public enum Microsoft.FileFormats.MachO.LoadCommandType : Enum {
    public int value__;
    public static LoadCommandType Segment;
    public static LoadCommandType Symtab;
    public static LoadCommandType Thread;
    public static LoadCommandType DySymtab;
    public static LoadCommandType Segment64;
    public static LoadCommandType Uuid;
}
public class Microsoft.FileFormats.MachO.MachCore : object {
    private MachOFile _machO;
    private ulong _dylinkerHintAddress;
    private Lazy`1<ulong> _dylinkerAddress;
    private Lazy`1<MachDyld> _dylinker;
    private Lazy`1<MachLoadedImage[]> _loadedImages;
    public Reader VirtualAddressReader { get; }
    public ulong DylinkerAddress { get; }
    public MachDyld Dylinker { get; }
    public IEnumerable`1<MachLoadedImage> LoadedImages { get; }
    public MachCore(IAddressSpace dataSource, ulong dylinkerHintAddress);
    public Reader get_VirtualAddressReader();
    public ulong get_DylinkerAddress();
    public MachDyld get_Dylinker();
    public IEnumerable`1<MachLoadedImage> get_LoadedImages();
    public bool IsValid();
    private ulong FindDylinker();
    private bool TryFindDylinker(bool firstPass, UInt64& position);
    private bool IsValidDylinkerAddress(ulong possibleDylinkerAddress);
    private MachLoadedImage[] ReadImages();
    [CompilerGeneratedAttribute]
private MachDyld <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private MachLoadedImage <ReadImages>b__18_0(DyldLoadedImage i);
}
public class Microsoft.FileFormats.MachO.MachDyld : object {
    private MachOFile _dyldImage;
    private Lazy`1<ulong> _dyldAllImageInfosAddress;
    private Lazy`1<DyldImageAllInfosV2> _dyldAllImageInfos;
    private Lazy`1<DyldImageInfo[]> _imageInfos;
    private Lazy`1<DyldLoadedImage[]> _images;
    public ulong AllImageInfosAddress { get; }
    public DyldImageAllInfosV2 AllImageInfos { get; }
    public IEnumerable`1<DyldImageInfo> ImageInfos { get; }
    public IEnumerable`1<DyldLoadedImage> Images { get; }
    public MachDyld(MachOFile dyldImage);
    public ulong get_AllImageInfosAddress();
    public DyldImageAllInfosV2 get_AllImageInfos();
    public IEnumerable`1<DyldImageInfo> get_ImageInfos();
    public IEnumerable`1<DyldLoadedImage> get_Images();
    private ulong FindAllImageInfosAddress();
    private DyldImageAllInfosV2 ReadAllImageInfos();
    private DyldImageInfo[] ReadImageInfos();
    private DyldLoadedImage[] ReadLoadedImages();
    [CompilerGeneratedAttribute]
private DyldLoadedImage <ReadLoadedImages>b__17_0(DyldImageInfo i);
}
public class Microsoft.FileFormats.MachO.MachDySymtabLoadCommand : MachLoadCommand {
    public UInt32 ILocalSym;
    public UInt32 NLocalSym;
    public UInt32 IExtDefSym;
    public UInt32 NextDefSym;
    public UInt32 IUndefSym;
    public UInt32 NUndefSym;
    public UInt32 ToCoff;
    public UInt32 NToc;
    public UInt32 ModTabOff;
    public UInt32 MModTab;
    public UInt32 ExtrefSymOff;
    public UInt32 NextrefSyms;
    public UInt32 IndirectSymOff;
    public UInt32 NindirectSyms;
    public UInt32 ExtrelOff;
    public UInt32 Nextrel;
    public UInt32 LocrelOff;
    public UInt32 NLocrel;
}
public class Microsoft.FileFormats.MachO.MachFatArch : TStruct {
    public UInt32 CpuType;
    public UInt32 CpuSubType;
    public UInt32 Offset;
    public UInt32 Size;
    public UInt32 Align;
}
public class Microsoft.FileFormats.MachO.MachFatHeader : MachFatHeaderMagic {
    public UInt32 CountFatArches;
    public ValidationRule IsCountFatArchesReasonable { get; }
    public ValidationRule get_IsCountFatArchesReasonable();
    [CompilerGeneratedAttribute]
private bool <get_IsCountFatArchesReasonable>b__2_0();
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.MachO.MachFatHeaderLayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddMachFatHeaderTypes(LayoutManager layoutManager, bool isBigEndian);
}
public class Microsoft.FileFormats.MachO.MachFatHeaderMagic : TStruct {
    public MachFatHeaderMagicKind Magic;
    public ValidationRule IsMagicValid { get; }
    public ValidationRule get_IsMagicValid();
    [CompilerGeneratedAttribute]
private bool <get_IsMagicValid>b__2_0();
}
public enum Microsoft.FileFormats.MachO.MachFatHeaderMagicKind : Enum {
    public UInt32 value__;
    public static MachFatHeaderMagicKind LittleEndian;
    public static MachFatHeaderMagicKind BigEndian;
}
public class Microsoft.FileFormats.MachO.MachFixedLengthString16 : TStruct {
    [ArraySizeAttribute("16")]
public Byte[] Bytes;
    public virtual string ToString();
}
public class Microsoft.FileFormats.MachO.MachHeader : MachHeaderMagic {
    public UInt32 CpuType;
    public UInt32 CpuSubType;
    public MachHeaderFileType FileType;
    public UInt32 NumberCommands;
    public UInt32 SizeOfCommands;
    public UInt32 Flags;
    public ValidationRule IsFileTypeValid { get; }
    public ValidationRule IsNumberCommandsReasonable { get; }
    public ValidationRule get_IsFileTypeValid();
    public ValidationRule get_IsNumberCommandsReasonable();
    [CompilerGeneratedAttribute]
private bool <get_IsFileTypeValid>b__7_0();
    [CompilerGeneratedAttribute]
private bool <get_IsNumberCommandsReasonable>b__9_0();
}
public enum Microsoft.FileFormats.MachO.MachHeaderFileType : Enum {
    public UInt32 value__;
    public static MachHeaderFileType Object;
    public static MachHeaderFileType Execute;
    public static MachHeaderFileType FvmLib;
    public static MachHeaderFileType Core;
    public static MachHeaderFileType Preload;
    public static MachHeaderFileType Dylib;
    public static MachHeaderFileType Dylinker;
    public static MachHeaderFileType Bundle;
    public static MachHeaderFileType DylibStub;
    public static MachHeaderFileType Dsym;
    public static MachHeaderFileType KextBundle;
}
public class Microsoft.FileFormats.MachO.MachHeaderMagic : TStruct {
    public MachHeaderMagicType Magic;
    public ValidationRule IsMagicValid { get; }
    public ValidationRule get_IsMagicValid();
    [CompilerGeneratedAttribute]
private bool <get_IsMagicValid>b__2_0();
}
public enum Microsoft.FileFormats.MachO.MachHeaderMagicType : Enum {
    public UInt32 value__;
    public static MachHeaderMagicType LittleEndian64Bit;
    public static MachHeaderMagicType LittleEndian32Bit;
    public static MachHeaderMagicType BigEndian64Bit;
    public static MachHeaderMagicType BigEndian32Bit;
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.MachO.MachLayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddMachTypes(LayoutManager layoutManager, bool isBigEndian, bool is64Bit);
}
public class Microsoft.FileFormats.MachO.MachLoadCommand : TStruct {
    public LoadCommandType Command;
    public UInt32 CommandSize;
    public ValidationRule IsCmdSizeReasonable { get; }
    public ValidationRule IsCommandRecognized { get; }
    public virtual string ToString();
    public ValidationRule get_IsCmdSizeReasonable();
    public ValidationRule get_IsCommandRecognized();
    [CompilerGeneratedAttribute]
private bool <get_IsCmdSizeReasonable>b__4_0();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandRecognized>b__6_0();
}
public class Microsoft.FileFormats.MachO.MachLoadedImage : object {
    private DyldLoadedImage _dyldLoadedImage;
    [CompilerGeneratedAttribute]
private MachOFile <Image>k__BackingField;
    public MachOFile Image { get; private set; }
    public ulong LoadAddress { get; }
    public string Path { get; }
    public MachLoadedImage(MachOFile image, DyldLoadedImage dyldLoadedImage);
    [CompilerGeneratedAttribute]
public MachOFile get_Image();
    [CompilerGeneratedAttribute]
private void set_Image(MachOFile value);
    public ulong get_LoadAddress();
    public string get_Path();
}
public class Microsoft.FileFormats.MachO.MachOFatFile : object {
    private Reader _reader;
    private Lazy`1<MachFatHeaderMagic> _headerMagic;
    private Lazy`1<Reader> _headerReader;
    private Lazy`1<MachFatHeader> _header;
    private Lazy`1<MachFatArch[]> _arches;
    private Lazy`1<MachOFile[]> _archSpecificFiles;
    public MachFatHeaderMagic HeaderMagic { get; }
    public MachFatHeader Header { get; }
    public MachFatArch[] Arches { get; }
    public MachOFile[] ArchSpecificFiles { get; }
    public bool IsBigEndian { get; }
    public MachOFatFile(IAddressSpace dataSource);
    public MachFatHeaderMagic get_HeaderMagic();
    public MachFatHeader get_Header();
    public MachFatArch[] get_Arches();
    public MachOFile[] get_ArchSpecificFiles();
    public sealed virtual void Dispose();
    public bool IsValid();
    public bool get_IsBigEndian();
    private MachFatArch[] ReadArches();
    private MachOFile[] ReadArchSpecificFiles();
    [CompilerGeneratedAttribute]
private MachOFile <ReadArchSpecificFiles>b__20_0(MachFatArch a);
}
public class Microsoft.FileFormats.MachO.MachOFile : object {
    private ulong _position;
    private bool _dataSourceIsVirtualAddressSpace;
    private Reader _reader;
    private Lazy`1<MachHeaderMagic> _headerMagic;
    private Lazy`1<Reader> _dataSourceReader;
    private Lazy`1<MachHeader> _header;
    private Lazy`1<Tuple`2[]> _loadCommands;
    private Lazy`1<MachSegment[]> _segments;
    private Lazy`1<MachSection[]> _sections;
    private Lazy`1<Reader> _virtualAddressReader;
    private Lazy`1<Reader> _physicalAddressReader;
    private Lazy`1<Byte[]> _uuid;
    private Lazy`1<MachSymtab> _symtab;
    public MachHeaderMagic HeaderMagic { get; }
    public MachHeader Header { get; }
    public Byte[] Uuid { get; }
    public MachSegment[] Segments { get; }
    public MachSection[] Sections { get; }
    public Reader VirtualAddressReader { get; }
    public Reader PhysicalAddressReader { get; }
    public MachSymtab Symtab { get; }
    private Reader DataSourceReader { get; }
    public bool IsBigEndian { get; }
    public bool Is64Bit { get; }
    public ulong PreferredVMBaseAddress { get; }
    public ulong LoadAddress { get; }
    public ValidationRule IsAtMostOneUuidLoadCommand { get; }
    public ValidationRule IsAtLeastOneUuidLoadCommand { get; }
    public ValidationRule IsAtMostOneSymtabLoadCommand { get; }
    public ValidationRule IsAtLeastOneSymtabLoadCommand { get; }
    public ValidationRule IsAtLeastOneSegmentAtFileOffsetZero { get; }
    public MachOFile(IAddressSpace dataSource, ulong position, bool dataSourceIsVirtualAddressSpace);
    public MachHeaderMagic get_HeaderMagic();
    public MachHeader get_Header();
    public Byte[] get_Uuid();
    public MachSegment[] get_Segments();
    public MachSection[] get_Sections();
    public Reader get_VirtualAddressReader();
    public Reader get_PhysicalAddressReader();
    public MachSymtab get_Symtab();
    private Reader get_DataSourceReader();
    public sealed virtual void Dispose();
    public bool IsValid();
    public bool get_IsBigEndian();
    public bool get_Is64Bit();
    public ulong get_PreferredVMBaseAddress();
    public ulong get_LoadAddress();
    private Reader CreateDataSourceReader();
    private Reader CreateVirtualReader();
    private Reader CreatePhysicalReader();
    private Tuple`2[] ReadLoadCommands();
    private Byte[] ReadUuid();
    private MachSegment[] ReadSegments();
    private MachSymtab ReadSymtab();
    public ValidationRule get_IsAtMostOneUuidLoadCommand();
    public ValidationRule get_IsAtLeastOneUuidLoadCommand();
    public ValidationRule get_IsAtMostOneSymtabLoadCommand();
    public ValidationRule get_IsAtLeastOneSymtabLoadCommand();
    public ValidationRule get_IsAtLeastOneSegmentAtFileOffsetZero();
    [CompilerGeneratedAttribute]
private MachHeaderMagic <.ctor>b__13_0();
    [CompilerGeneratedAttribute]
private MachHeader <.ctor>b__13_1();
    [CompilerGeneratedAttribute]
private MachSection[] <.ctor>b__13_2();
    [CompilerGeneratedAttribute]
private bool <get_IsAtMostOneUuidLoadCommand>b__50_0();
    [CompilerGeneratedAttribute]
private bool <get_IsAtLeastOneUuidLoadCommand>b__52_0();
    [CompilerGeneratedAttribute]
private bool <get_IsAtMostOneSymtabLoadCommand>b__54_0();
    [CompilerGeneratedAttribute]
private bool <get_IsAtLeastOneSymtabLoadCommand>b__56_0();
    [CompilerGeneratedAttribute]
private bool <get_IsAtLeastOneSegmentAtFileOffsetZero>b__58_0();
}
public class Microsoft.FileFormats.MachO.MachPhysicalAddressSpace : PiecewiseAddressSpace {
    public MachPhysicalAddressSpace(IAddressSpace virtualAddressSpace, ulong preferredVMBaseAddress, IEnumerable`1<MachSegment> segments);
    private static PiecewiseAddressSpaceRange ToRange(IAddressSpace virtualAddressSpace, ulong preferredVMBaseAddress, MachSegment segment);
}
public class Microsoft.FileFormats.MachO.MachSection : TStruct {
    public MachFixedLengthString16 SectionName;
    public MachFixedLengthString16 SegmentName;
    public SizeT Address;
    public SizeT Size;
    public UInt32 Offset;
    public UInt32 Align;
    public UInt32 RelativeOffset;
    public UInt32 CountRelocs;
    public UInt32 Flags;
    public UInt32 Reserved1;
    public UInt32 Reserved2;
}
public class Microsoft.FileFormats.MachO.MachSegment : object {
    private Reader _dataSourceReader;
    private ulong _position;
    private bool _readerIsVirtualAddressSpace;
    private Lazy`1<MachSegmentLoadCommand> _loadCommand;
    private Lazy`1<MachSection[]> _sections;
    private Lazy`1<Reader> _physicalContents;
    private Lazy`1<Reader> _virtualContents;
    public MachSegmentLoadCommand LoadCommand { get; }
    public IEnumerable`1<MachSection> Sections { get; }
    public Reader PhysicalContents { get; }
    public Reader VirtualContents { get; }
    public MachSegment(Reader machReader, ulong position, bool readerIsVirtualAddressSpace);
    public MachSegmentLoadCommand get_LoadCommand();
    public IEnumerable`1<MachSection> get_Sections();
    public Reader get_PhysicalContents();
    public Reader get_VirtualContents();
    private MachSection[] ReadSections();
    private Reader CreatePhysicalSegmentAddressSpace();
    private Reader CreateVirtualSegmentAddressSpace();
    [CompilerGeneratedAttribute]
private MachSegmentLoadCommand <.ctor>b__7_0();
}
public class Microsoft.FileFormats.MachO.MachSegmentLoadCommand : MachLoadCommand {
    public MachFixedLengthString16 SegName;
    public SizeT VMAddress;
    public SizeT VMSize;
    public SizeT FileOffset;
    public SizeT FileSize;
    public UInt32 MaxProt;
    public UInt32 InitProt;
    public UInt32 CountSections;
    public UInt32 Flags;
    private ValidationRule IsCommandValid { get; }
    private ValidationRule get_IsCommandValid();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandValid>b__10_0();
}
public class Microsoft.FileFormats.MachO.MachSymbol : object {
    public string Name;
    public NList Raw;
    public ulong Value { get; }
    public ulong get_Value();
    public virtual string ToString();
}
public class Microsoft.FileFormats.MachO.MachSymtab : object {
    private Reader _machReader;
    private Reader _physicalAddressSpace;
    private Lazy`1<MachSymtabLoadCommand> _symtabLoadCommand;
    private Lazy`1<MachDySymtabLoadCommand> _dysymtabLoadCommand;
    private Lazy`1<MachSymbol[]> _symbols;
    private Lazy`1<Reader> _stringReader;
    private Lazy`1<NList[]> _symbolTable;
    public IEnumerable`1<MachSymbol> Symbols { get; }
    public MachSymtab(Reader machReader, ulong symtabPosition, ulong dysymtabPosition, Reader physicalAddressSpace);
    public IEnumerable`1<MachSymbol> get_Symbols();
    public bool TryLookupSymbol(string symbol, UInt64& offset);
    private bool TryLookupSymbol(UInt32 start, UInt32 nsyms, string symbol, UInt64& offset);
    private MachSymbol[] ReadSymbols();
    private Reader GetStringReader();
    private NList[] ReadSymbolTable();
}
public class Microsoft.FileFormats.MachO.MachSymtabLoadCommand : MachLoadCommand {
    public UInt32 SymOffset;
    public UInt32 SymCount;
    public UInt32 StringOffset;
    public UInt32 StringSize;
    public ValidationRule IsCommandValid { get; }
    public ValidationRule IsCommandSizeValid { get; }
    public ValidationRule IsNSymsReasonable { get; }
    public ValidationRule get_IsCommandValid();
    public ValidationRule get_IsCommandSizeValid();
    public ValidationRule get_IsNSymsReasonable();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandValid>b__5_0();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandSizeValid>b__7_0();
    [CompilerGeneratedAttribute]
private bool <get_IsNSymsReasonable>b__9_0();
}
public class Microsoft.FileFormats.MachO.MachUuidLoadCommand : MachLoadCommand {
    [ArraySizeAttribute("16")]
public Byte[] Uuid;
    public ValidationRule IsCommandValid { get; }
    public ValidationRule IsCommandSizeValid { get; }
    public ValidationRule get_IsCommandValid();
    public ValidationRule get_IsCommandSizeValid();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandValid>b__2_0();
    [CompilerGeneratedAttribute]
private bool <get_IsCommandSizeValid>b__4_0();
}
public class Microsoft.FileFormats.MachO.MachVirtualAddressSpace : PiecewiseAddressSpace {
    public MachVirtualAddressSpace(IEnumerable`1<MachSegment> segments);
    private static PiecewiseAddressSpaceRange ToRange(MachSegment segment);
}
public class Microsoft.FileFormats.MachO.NList : TStruct {
    public UInt32 StringIndex;
    public byte Type;
    public byte Section;
    public ushort Desc;
    public SizeT Value;
}
public class Microsoft.FileFormats.MemoryBufferAddressSpace : object {
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    private Byte[] _bytes;
    public ulong Length { get; private set; }
    public MemoryBufferAddressSpace(IEnumerable`1<byte> bytes);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.Minidump.CrashDumpLayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddCrashDumpTypes(LayoutManager layouts, bool isBigEndian, bool is64Bit);
}
internal class Microsoft.FileFormats.Minidump.FixedFileInfo : TStruct {
    public UInt32 Signature;
    public UInt32 StrucVersion;
    public UInt32 FileVersionMS;
    public UInt32 FileVersionLS;
    public UInt32 ProductVersionMS;
    public UInt32 ProductVersionLS;
    public UInt32 FileFlagsMask;
    public UInt32 FileFlags;
    public UInt32 FileOS;
    public UInt32 FileType;
    public UInt32 FileSubtype;
    public UInt32 FileDateMS;
    public UInt32 FileDateLS;
}
public class Microsoft.FileFormats.Minidump.Minidump : object {
    private ulong _position;
    private Reader _dataSourceReader;
    private MinidumpHeader _header;
    private MinidumpDirectory[] _directory;
    private MinidumpSystemInfo _systemInfo;
    private int _moduleListStream;
    private Lazy`1<List`1<MinidumpLoadedImage>> _loadedImages;
    private Lazy`1<List`1<MinidumpSegment>> _memoryRanges;
    private Lazy`1<Reader> _virtualAddressReader;
    public ProcessorArchitecture Architecture { get; }
    public Reader DataSourceReader { get; }
    public Reader VirtualAddressReader { get; }
    public ReadOnlyCollection`1<MinidumpLoadedImage> LoadedImages { get; }
    public ReadOnlyCollection`1<MinidumpSegment> Segments { get; }
    public bool Is64Bit { get; }
    public Minidump(IAddressSpace dataSource, ulong position);
    public static bool IsValid(IAddressSpace addressSpace, ulong position);
    public ProcessorArchitecture get_Architecture();
    public Reader get_DataSourceReader();
    public Reader get_VirtualAddressReader();
    public ReadOnlyCollection`1<MinidumpLoadedImage> get_LoadedImages();
    public ReadOnlyCollection`1<MinidumpSegment> get_Segments();
    public bool get_Is64Bit();
    private Reader CreateVirtualAddressReader();
    private List`1<MinidumpLoadedImage> CreateLoadedImageList();
    private List`1<MinidumpSegment> CreateSegmentList();
    [CompilerGeneratedAttribute]
private MinidumpLoadedImage <CreateLoadedImageList>b__24_0(MinidumpModule module);
}
internal class Microsoft.FileFormats.Minidump.MinidumpDirectory : TStruct {
    public MinidumpStreamType StreamType;
    public UInt32 DataSize;
    public UInt32 Rva;
}
internal class Microsoft.FileFormats.Minidump.MinidumpHeader : TStruct {
    public static int MinidumpVersion;
    public UInt32 Signature;
    public UInt32 Version;
    public UInt32 NumberOfStreams;
    public UInt32 StreamDirectoryRva;
    public UInt32 CheckSum;
    public UInt32 TimeDateStamp;
    public ulong Flags;
    public ValidationRule IsSignatureValid { get; }
    public ValidationRule get_IsSignatureValid();
    [CompilerGeneratedAttribute]
private bool <get_IsSignatureValid>b__9_0();
}
public class Microsoft.FileFormats.Minidump.MinidumpLoadedImage : object {
    private MinidumpModule _module;
    private Lazy`1<PEFile> _peFile;
    private Lazy`1<string> _moduleName;
    [CompilerGeneratedAttribute]
private Minidump <Minidump>k__BackingField;
    public Minidump Minidump { get; private set; }
    public ulong BaseAddress { get; }
    public UInt32 CheckSum { get; }
    public UInt32 TimeDateStamp { get; }
    public UInt32 ImageSize { get; }
    public string ModuleName { get; }
    public PEFile Image { get; }
    public UInt32 Major { get; }
    public UInt32 Minor { get; }
    public UInt32 Revision { get; }
    public UInt32 Patch { get; }
    internal MinidumpLoadedImage(Minidump minidump, MinidumpModule module);
    [CompilerGeneratedAttribute]
public Minidump get_Minidump();
    [CompilerGeneratedAttribute]
private void set_Minidump(Minidump value);
    public ulong get_BaseAddress();
    public UInt32 get_CheckSum();
    public UInt32 get_TimeDateStamp();
    public UInt32 get_ImageSize();
    public string get_ModuleName();
    public PEFile get_Image();
    public UInt32 get_Major();
    public UInt32 get_Minor();
    public UInt32 get_Revision();
    public UInt32 get_Patch();
    private PEFile CreatePEFile();
    private string GetModuleName();
}
internal class Microsoft.FileFormats.Minidump.MinidumpLocationDescriptor : TStruct {
    public UInt32 DataSize;
    public UInt32 Rva;
}
internal class Microsoft.FileFormats.Minidump.MinidumpMemoryDescriptor : TStruct {
    public ulong StartOfMemoryRange;
    public MinidumpLocationDescriptor Memory;
}
internal class Microsoft.FileFormats.Minidump.MinidumpMemoryDescriptor64 : TStruct {
    public ulong StartOfMemoryRange;
    public ulong DataSize;
}
[PackAttribute("4")]
internal class Microsoft.FileFormats.Minidump.MinidumpModule : TStruct {
    public ulong Baseofimage;
    public UInt32 SizeOfImage;
    public UInt32 CheckSum;
    public UInt32 TimeDateStamp;
    public UInt32 ModuleNameRva;
    public FixedFileInfo VersionInfo;
    public MinidumpLocationDescriptor CvRecord;
    public MinidumpLocationDescriptor MiscRecord;
    private ulong _reserved0;
    private ulong _reserved1;
}
[ExtensionAttribute]
internal static class Microsoft.FileFormats.Minidump.MinidumpReaderExtensions : object {
    [ExtensionAttribute]
public static string ReadCountedString(Reader self, ulong position, Encoding encoding);
    [ExtensionAttribute]
public static T[] ReadCountedArray(Reader self, ulong position);
}
public class Microsoft.FileFormats.Minidump.MinidumpSegment : object {
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    public ulong FileOffset { get; private set; }
    public ulong VirtualAddress { get; private set; }
    public ulong Size { get; private set; }
    internal MinidumpSegment(MinidumpMemoryDescriptor region);
    internal MinidumpSegment(MinidumpMemoryDescriptor64 region, ulong rva);
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
private void set_FileOffset(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_VirtualAddress();
    [CompilerGeneratedAttribute]
private void set_VirtualAddress(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ulong value);
    public bool Contains(ulong address);
}
internal enum Microsoft.FileFormats.Minidump.MinidumpStreamType : Enum {
    public int value__;
    public static MinidumpStreamType UnusedStream;
    public static MinidumpStreamType ReservedStream0;
    public static MinidumpStreamType ReservedStream1;
    public static MinidumpStreamType ThreadListStream;
    public static MinidumpStreamType ModuleListStream;
    public static MinidumpStreamType MemoryListStream;
    public static MinidumpStreamType ExceptionStream;
    public static MinidumpStreamType SystemInfoStream;
    public static MinidumpStreamType ThreadExListStream;
    public static MinidumpStreamType Memory64ListStream;
    public static MinidumpStreamType CommentStreamA;
    public static MinidumpStreamType CommentStreamW;
    public static MinidumpStreamType HandleDataStream;
    public static MinidumpStreamType FunctionTableStream;
    public static MinidumpStreamType UnloadedModuleListStream;
    public static MinidumpStreamType MiscInfoStream;
    public static MinidumpStreamType MemoryInfoListStream;
    public static MinidumpStreamType ThreadInfoListStream;
    public static MinidumpStreamType LastReservedStream;
}
internal class Microsoft.FileFormats.Minidump.MinidumpSystemInfo : TStruct {
    public ProcessorArchitecture ProcessorArchitecture;
    public ushort ProcessorLevel;
    public ushort ProcessorRevision;
    public byte NumberOfProcessors;
    public byte ProductType;
    public UInt32 MajorVersion;
    public UInt32 MinorVersion;
    public UInt32 BuildNumber;
    public UInt32 PlatformId;
    public UInt32 CSDVersionRva;
}
public class Microsoft.FileFormats.Minidump.MinidumpVirtualAddressSpace : object {
    private IAddressSpace _addressSpace;
    private ReadOnlyCollection`1<MinidumpSegment> _segments;
    private ulong _length;
    public ulong Length { get; }
    public MinidumpVirtualAddressSpace(ReadOnlyCollection`1<MinidumpSegment> segments, IAddressSpace addressSpace);
    public sealed virtual ulong get_Length();
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    private MinidumpSegment FindSegment(ulong position);
}
public enum Microsoft.FileFormats.Minidump.ProcessorArchitecture : Enum {
    public ushort value__;
    public static ProcessorArchitecture Intel;
    public static ProcessorArchitecture Mips;
    public static ProcessorArchitecture Alpha;
    public static ProcessorArchitecture Ppc;
    public static ProcessorArchitecture Shx;
    public static ProcessorArchitecture Arm;
    public static ProcessorArchitecture Ia64;
    public static ProcessorArchitecture Alpha64;
    public static ProcessorArchitecture Msil;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Ia32OnWin64;
}
public class Microsoft.FileFormats.NullTerminatedStringLayout : object {
    private Encoding _encoding;
    public IEnumerable`1<IField> Fields { get; }
    public UInt32 NaturalAlignment { get; }
    public bool IsFixedSize { get; }
    public UInt32 Size { get; }
    public UInt32 SizeAsBaseType { get; }
    public Type Type { get; }
    public NullTerminatedStringLayout(Encoding encoding);
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual UInt32 get_NaturalAlignment();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual UInt32 get_Size();
    public sealed virtual UInt32 get_SizeAsBaseType();
    public sealed virtual Type get_Type();
    public sealed virtual object Read(IAddressSpace dataSource, ulong position);
    public sealed virtual object Read(IAddressSpace dataSource, ulong position, UInt32& bytesRead);
}
[AttributeUsageAttribute("4")]
public class Microsoft.FileFormats.PackAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <Pack>k__BackingField;
    public UInt32 Pack { get; private set; }
    public PackAttribute(UInt32 pack);
    [CompilerGeneratedAttribute]
public UInt32 get_Pack();
    [CompilerGeneratedAttribute]
private void set_Pack(UInt32 value);
}
public class Microsoft.FileFormats.PDB.DbiStream : object {
    private Reader _streamReader;
    private Lazy`1<DbiStreamHeader> _header;
    public DbiStreamHeader Header { get; }
    public DbiStream(Reader streamReader);
    public bool IsValid();
    public DbiStreamHeader get_Header();
    [CompilerGeneratedAttribute]
private DbiStreamHeader <.ctor>b__2_0();
}
public class Microsoft.FileFormats.PDB.DbiStreamHeader : TStruct {
    private static UInt32 CurrentSignature;
    private static UInt32 CurrentVersion;
    public UInt32 Signature;
    public UInt32 Version;
    public UInt32 Age;
    public ValidationRule IsHeaderValid { get; }
    public ValidationRule get_IsHeaderValid();
    [CompilerGeneratedAttribute]
private bool <get_IsHeaderValid>b__6_0();
}
public class Microsoft.FileFormats.PDB.NameIndexStreamHeader : TStruct {
    public UInt32 Version;
    public UInt32 Signature;
    public UInt32 Age;
    [ArraySizeAttribute("16")]
public Byte[] Guid;
    public UInt32 CountStringBytes;
}
public class Microsoft.FileFormats.PDB.PDBFile : object {
    private Reader _reader;
    private Lazy`1<PDBFileHeader> _header;
    private Lazy`1<Reader[]> _streams;
    private Lazy`1<PDBNameStream> _nameStream;
    private Lazy`1<DbiStream> _dbiStream;
    public PDBFileHeader Header { get; }
    public IList`1<Reader> Streams { get; }
    public PDBNameStream NameStream { get; }
    public DbiStream DbiStream { get; }
    public UInt32 Age { get; }
    public UInt32 DbiAge { get; }
    public Guid Signature { get; }
    public PDBFile(IAddressSpace dataSource);
    public PDBFileHeader get_Header();
    public IList`1<Reader> get_Streams();
    public PDBNameStream get_NameStream();
    public DbiStream get_DbiStream();
    public UInt32 get_Age();
    public UInt32 get_DbiAge();
    public Guid get_Signature();
    public sealed virtual void Dispose();
    public bool IsValid();
    private Reader[] ReadDirectory();
    private PDBPagedAddressSpace CreatePagedAddressSpace(IAddressSpace indicesData, ulong offset, UInt32 length);
    private UInt32 ToPageCount(UInt32 size);
    [CompilerGeneratedAttribute]
private PDBFileHeader <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private PDBNameStream <.ctor>b__5_1();
    [CompilerGeneratedAttribute]
private DbiStream <.ctor>b__5_2();
}
public class Microsoft.FileFormats.PDB.PDBFileHeader : TStruct {
    [ArraySizeAttribute("32")]
public Byte[] Magic;
    public UInt32 PageSize;
    public UInt32 FreePageMap;
    public UInt32 PagesUsed;
    public UInt32 DirectorySize;
    public UInt32 Reserved;
    private Byte[] ExpectedMagic { get; }
    public ValidationRule IsMagicValid { get; }
    private Byte[] get_ExpectedMagic();
    public ValidationRule get_IsMagicValid();
    [CompilerGeneratedAttribute]
private bool <get_IsMagicValid>b__9_0();
}
public class Microsoft.FileFormats.PDB.PDBNameStream : object {
    private Reader _streamReader;
    private Lazy`1<NameIndexStreamHeader> _header;
    public NameIndexStreamHeader Header { get; }
    public PDBNameStream(Reader streamReader);
    public NameIndexStreamHeader get_Header();
    [CompilerGeneratedAttribute]
private NameIndexStreamHeader <.ctor>b__2_0();
}
internal class Microsoft.FileFormats.PDB.PDBPagedAddressSpace : object {
    private IAddressSpace _physicalAddresses;
    private UInt32[] _pageIndices;
    private UInt32 _pageSize;
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public ulong Length { get; private set; }
    public PDBPagedAddressSpace(IAddressSpace physicalAddresses, UInt32[] pageIndices, UInt32 pageSize, ulong length);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    private ulong GetPhysicalAddress(ulong virtualAddress, UInt32& virtualOffset);
}
public class Microsoft.FileFormats.PE.CvInfoPdb70 : TStruct {
    public static int PDB70CvSignature;
    public int CvSignature;
    [ArraySizeAttribute("16")]
public Byte[] Signature;
    public int Age;
}
[FlagsAttribute]
public enum Microsoft.FileFormats.PE.FileInfoFlags : Enum {
    public UInt32 value__;
    public static FileInfoFlags Debug;
    public static FileInfoFlags SpecialBuild;
}
public class Microsoft.FileFormats.PE.ImageDataDirectory : TStruct {
    public UInt32 VirtualAddress;
    public UInt32 Size;
}
public class Microsoft.FileFormats.PE.ImageDebugDirectory : TStruct {
    public static ushort PortablePDBMinorVersion;
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public ImageDebugType Type;
    public UInt32 SizeOfData;
    public UInt32 AddressOfRawData;
    public UInt32 PointerToRawData;
}
public enum Microsoft.FileFormats.PE.ImageDebugType : Enum {
    public int value__;
    public static ImageDebugType Unknown;
    public static ImageDebugType Coff;
    public static ImageDebugType Codeview;
    public static ImageDebugType Fpo;
    public static ImageDebugType Misc;
    public static ImageDebugType Bbt;
    public static ImageDebugType Reproducible;
    public static ImageDebugType EmbeddedPortablePdb;
    public static ImageDebugType PdbChecksum;
    public static ImageDebugType PerfMap;
}
public enum Microsoft.FileFormats.PE.ImageDirectoryEntry : Enum {
    public int value__;
    public static ImageDirectoryEntry Export;
    public static ImageDirectoryEntry Import;
    public static ImageDirectoryEntry Resource;
    public static ImageDirectoryEntry Exception;
    public static ImageDirectoryEntry Certificates;
    public static ImageDirectoryEntry BaseRelocation;
    public static ImageDirectoryEntry Debug;
    public static ImageDirectoryEntry Architecture;
    public static ImageDirectoryEntry GlobalPointers;
    public static ImageDirectoryEntry ThreadStorage;
    public static ImageDirectoryEntry LoadConfiguration;
    public static ImageDirectoryEntry BoundImport;
    public static ImageDirectoryEntry ImportAddress;
    public static ImageDirectoryEntry DelayImport;
    public static ImageDirectoryEntry ComDescriptor;
}
public class Microsoft.FileFormats.PE.ImageExportDirectory : TStruct {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public UInt32 Name;
    public UInt32 Base;
    public UInt32 NumberOfFunctions;
    public UInt32 NumberOfNames;
    public UInt32 AddressOfFunctions;
    public UInt32 AddressOfNames;
    public UInt32 AddressOfNameOrdinals;
}
[FlagsAttribute]
public enum Microsoft.FileFormats.PE.ImageFile : Enum {
    public ushort value__;
    public static ImageFile RelocsStripped;
    public static ImageFile ExecutableImage;
    public static ImageFile LargeAddressAware;
    public static ImageFile System;
    public static ImageFile Dll;
}
public class Microsoft.FileFormats.PE.ImageFileHeader : TStruct {
    public ushort Machine;
    public ushort NumberOfSections;
    public UInt32 TimeDateStamp;
    public UInt32 PointerToSymbolTable;
    public UInt32 NumberOfSymbols;
    public ushort SizeOfOptionalHeader;
    public ushort Characteristics;
}
public enum Microsoft.FileFormats.PE.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine Unknown;
    public static ImageFileMachine Amd64;
    public static ImageFileMachine I386;
    public static ImageFileMachine Arm;
    public static ImageFileMachine Thumb;
    public static ImageFileMachine ArmNT;
    public static ImageFileMachine Arm64;
}
public enum Microsoft.FileFormats.PE.ImageMagic : Enum {
    public ushort value__;
    public static ImageMagic Magic32;
    public static ImageMagic Magic64;
}
public class Microsoft.FileFormats.PE.ImageOptionalHeader : ImageOptionalHeaderMagic {
    public byte MajorLinkerVersion;
    public byte MinorLinkerVersion;
    public UInt32 SizeOfCode;
    public UInt32 SizeOfInitializedData;
    public UInt32 SizeOfUninitializedData;
    public UInt32 RVAOfEntryPoint;
    public UInt32 BaseOfCode;
    [IfAttribute("PE32")]
public UInt32 BaseOfData;
    public SizeT ImageBase;
    public UInt32 SectionAlignment;
    public UInt32 FileAlignment;
    public ushort MajorOperatingSystemVersion;
    public ushort MinorOperatingSystemVersion;
    public ushort MajorImageVersion;
    public ushort MinorImageVersion;
    public ushort MajorSubsystemVersion;
    public ushort MinorSubsystemVersion;
    public UInt32 Win32VersionValue;
    public UInt32 SizeOfImage;
    public UInt32 SizeOfHeaders;
    public UInt32 CheckSum;
    public ushort Subsystem;
    public ushort DllCharacteristics;
    public SizeT SizeOfStackReserve;
    public SizeT SizeOfStackCommit;
    public SizeT SizeOfHeapReserve;
    public SizeT SizeOfHeapCommit;
    public UInt32 LoaderFlags;
    public UInt32 NumberOfRvaAndSizes;
}
public class Microsoft.FileFormats.PE.ImageOptionalHeaderMagic : TStruct {
    public ImageMagic Magic;
    public ValidationRule IsMagicValid { get; }
    public ValidationRule get_IsMagicValid();
    [CompilerGeneratedAttribute]
private bool <get_IsMagicValid>b__2_0();
}
public class Microsoft.FileFormats.PE.ImageResourceDataEntry : TStruct {
    public UInt32 OffsetToData;
    public UInt32 Size;
    public UInt32 CodePage;
    public UInt32 Reserved;
}
public class Microsoft.FileFormats.PE.ImageResourceDirectory : TStruct {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public ushort NumberOfNamedEntries;
    public ushort NumberOfIdEntries;
}
public class Microsoft.FileFormats.PE.ImageResourceDirectoryEntry : TStruct {
    public UInt32 Id;
    public UInt32 OffsetToData;
}
public class Microsoft.FileFormats.PE.ImageSectionHeader : TStruct {
    [ArraySizeAttribute("8")]
public Byte[] Name;
    public UInt32 VirtualSize;
    public UInt32 VirtualAddress;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
    public UInt32 PointerToRelocations;
    public UInt32 PointerToLinenumbers;
    public ushort NumberOfRelocations;
    public ushort NumberOfLinenumbers;
    public UInt32 Characteristics;
}
[ExtensionAttribute]
public static class Microsoft.FileFormats.PE.LayoutManagerExtensions : object {
    [ExtensionAttribute]
public static LayoutManager AddPETypes(LayoutManager layouts, bool is64Bit);
}
public class Microsoft.FileFormats.PE.PdbChecksum : TStruct {
    [CompilerGeneratedAttribute]
private string <AlgorithmName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public string AlgorithmName { get; }
    public Byte[] Checksum { get; }
    public PdbChecksum(string algorithmName, Byte[] checksum);
    [CompilerGeneratedAttribute]
public string get_AlgorithmName();
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    public virtual string ToString();
    public static string ToHexString(Byte[] bytes);
}
public class Microsoft.FileFormats.PE.PEAddressSpace : object {
    private Lazy`1<ulong> _length;
    private ReadOnlyCollection`1<ImageSectionHeader> _segments;
    private ulong _baseAddress;
    private IAddressSpace _addressSpace;
    public ulong Length { get; }
    public PEAddressSpace(IAddressSpace addressSpace, ulong baseAddress, ReadOnlyCollection`1<ImageSectionHeader> segments);
    public sealed virtual ulong get_Length();
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    private ulong GetLength();
}
public class Microsoft.FileFormats.PE.PEFile : object {
    private bool _isDataSourceVirtualAddressSpace;
    private Reader _headerReader;
    private Lazy`1<ushort> _dosHeaderMagic;
    private Lazy`1<ImageFileHeader> _fileHeader;
    private Lazy`1<UInt32> _peHeaderOffset;
    private Lazy`1<UInt32> _peSignature;
    private Lazy`1<ImageOptionalHeaderMagic> _optionalHeaderMagic;
    private Lazy`1<Reader> _fileReader;
    private Lazy`1<ImageOptionalHeader> _optionalHeader;
    private Lazy`1<List`1<ImageDataDirectory>> _imageDataDirectory;
    private Lazy`1<IEnumerable`1<PEPdbRecord>> _pdb;
    private Lazy`1<List`1<ImageSectionHeader>> _segments;
    private Lazy`1<VsFixedFileInfo> _vsFixedFileInfo;
    private Lazy`1<IEnumerable`1<PdbChecksum>> _pdbChecksum;
    private Lazy`1<IEnumerable`1<PEPerfMapRecord>> _perfMapsV1;
    private Lazy`1<Reader> _virtualAddressReader;
    private Lazy`1<ImageExportDirectory> _exportDirectory;
    private static ushort ExpectedDosHeaderMagic;
    private static int PESignatureOffsetLocation;
    private static UInt32 ExpectedPESignature;
    private static int ImageDataDirectoryCount;
    public static UInt32 ChecksumLength;
    public static UInt32 CertDirectoryLength;
    public static int CertDirectoryIndex;
    private static UInt32 VersionResourceType;
    private static UInt32 VersionResourceName;
    private static UInt32 VersionResourceLanguage;
    public ushort DosHeaderMagic { get; }
    public UInt32 PEHeaderOffset { get; }
    public UInt32 PESignature { get; }
    public ImageFileHeader FileHeader { get; }
    public UInt32 Timestamp { get; }
    public ImageOptionalHeaderMagic OptionalHeaderMagic { get; }
    public Reader FileReader { get; }
    public ImageOptionalHeader OptionalHeader { get; }
    public UInt32 SizeOfImage { get; }
    public ReadOnlyCollection`1<ImageDataDirectory> ImageDataDirectory { get; }
    public IEnumerable`1<PEPdbRecord> Pdbs { get; }
    public Reader RelativeVirtualAddressReader { get; }
    public ReadOnlyCollection`1<ImageSectionHeader> Segments { get; }
    public VsFixedFileInfo VersionInfo { get; }
    public IEnumerable`1<PEPerfMapRecord> PerfMapsV1 { get; }
    public IEnumerable`1<PdbChecksum> PdbChecksums { get; }
    public bool IsILImage { get; }
    public ImageDataDirectory ComDataDirectory { get; }
    private UInt32 PEOptionalHeaderOffset { get; }
    public UInt32 PEChecksumOffset { get; }
    public UInt32 CertificateTableOffset { get; }
    public ValidationRule HasValidDosSignature { get; }
    public ValidationRule HasValidPESignature { get; }
    public PEFile(IAddressSpace dataSource, bool isDataSourceVirtualAddressSpace);
    public ushort get_DosHeaderMagic();
    public UInt32 get_PEHeaderOffset();
    public UInt32 get_PESignature();
    public ImageFileHeader get_FileHeader();
    public UInt32 get_Timestamp();
    public ImageOptionalHeaderMagic get_OptionalHeaderMagic();
    public Reader get_FileReader();
    public ImageOptionalHeader get_OptionalHeader();
    public UInt32 get_SizeOfImage();
    public ReadOnlyCollection`1<ImageDataDirectory> get_ImageDataDirectory();
    public IEnumerable`1<PEPdbRecord> get_Pdbs();
    public Reader get_RelativeVirtualAddressReader();
    public ReadOnlyCollection`1<ImageSectionHeader> get_Segments();
    public VsFixedFileInfo get_VersionInfo();
    public IEnumerable`1<PEPerfMapRecord> get_PerfMapsV1();
    public IEnumerable`1<PdbChecksum> get_PdbChecksums();
    public sealed virtual void Dispose();
    public bool IsValid();
    public bool get_IsILImage();
    public ImageDataDirectory get_ComDataDirectory();
    public bool TryGetExportSymbol(string symbolName, UInt64& offset);
    private ImageExportDirectory ReadExportDirectory();
    private UInt32 ReadPEHeaderOffset();
    private UInt32 get_PEOptionalHeaderOffset();
    public UInt32 get_PEChecksumOffset();
    public UInt32 get_CertificateTableOffset();
    private ImageFileHeader ReadFileHeader();
    private ImageOptionalHeaderMagic ReadOptionalHeaderMagic();
    private Reader CreateFileReader();
    private ImageOptionalHeader ReadOptionalHeader();
    private List`1<ImageDataDirectory> ReadImageDataDirectory();
    private List`1<ImageSectionHeader> ReadSectionHeaders();
    [IteratorStateMachineAttribute("Microsoft.FileFormats.PE.PEFile/<ReadPdbInfo>d__78")]
private IEnumerable`1<PEPdbRecord> ReadPdbInfo();
    [IteratorStateMachineAttribute("Microsoft.FileFormats.PE.PEFile/<ReadPdbChecksum>d__79")]
private IEnumerable`1<PdbChecksum> ReadPdbChecksum();
    [IteratorStateMachineAttribute("Microsoft.FileFormats.PE.PEFile/<ReadPerfMapV1Entries>d__80")]
private IEnumerable`1<PEPerfMapRecord> ReadPerfMapV1Entries();
    private VsFixedFileInfo ReadVersionResource();
    private ImageResourceDataEntry GetResourceDataEntry(UInt32 type, UInt32 name, UInt32 language);
    private bool GetNextLevelResourceEntryRva(ImageResourceDirectory resourceDirectory, UInt32 id, UInt32 rva, UInt32& nextLevelRva);
    private Reader CreateVirtualAddressReader();
    public ValidationRule get_HasValidDosSignature();
    public ValidationRule get_HasValidPESignature();
    [CompilerGeneratedAttribute]
private ushort <.ctor>b__24_0();
    [CompilerGeneratedAttribute]
private UInt32 <.ctor>b__24_1();
    [CompilerGeneratedAttribute]
private bool <get_HasValidDosSignature>b__89_0();
    [CompilerGeneratedAttribute]
private bool <get_HasValidPESignature>b__91_0();
}
public class Microsoft.FileFormats.PE.PEPdbRecord : object {
    [CompilerGeneratedAttribute]
private bool <IsPortablePDB>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Age>k__BackingField;
    public bool IsPortablePDB { get; private set; }
    public string Path { get; private set; }
    public Guid Signature { get; private set; }
    public int Age { get; private set; }
    public PEPdbRecord(bool isPortablePDB, string path, Guid sig, int age);
    [CompilerGeneratedAttribute]
public bool get_IsPortablePDB();
    [CompilerGeneratedAttribute]
private void set_IsPortablePDB(bool value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(Guid value);
    [CompilerGeneratedAttribute]
public int get_Age();
    [CompilerGeneratedAttribute]
private void set_Age(int value);
}
public class Microsoft.FileFormats.PE.PEPerfMapRecord : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    public string Path { get; private set; }
    public Byte[] Signature { get; private set; }
    public UInt32 Version { get; private set; }
    public PEPerfMapRecord(string path, Byte[] sig, UInt32 version);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(UInt32 value);
}
public class Microsoft.FileFormats.PE.PerfMapIdV1 : TStruct {
    public static int PerfMapEntryMagic;
    public int Magic;
    [ArraySizeAttribute("16")]
public Byte[] Signature;
    public UInt32 Version;
}
public class Microsoft.FileFormats.PE.VsFixedFileInfo : TStruct {
    public static UInt32 FixedFileInfoSignature;
    public UInt32 Signature;
    public UInt32 StrucVersion;
    public ushort FileVersionMinor;
    public ushort FileVersionMajor;
    public ushort FileVersionRevision;
    public ushort FileVersionBuild;
    public ushort ProductVersionMinor;
    public ushort ProductVersionMajor;
    public ushort ProductVersionRevision;
    public ushort ProductVersionBuild;
    public UInt32 FileFlagsMask;
    public FileInfoFlags FileFlags;
    public UInt32 FileOS;
    public UInt32 FileType;
    public UInt32 FileSubtype;
    public UInt32 FileDateMS;
    public UInt32 FileDateLS;
}
public class Microsoft.FileFormats.PE.VsVersionInfo : TStruct {
    public ushort Length;
    public ushort ValueLength;
    public ushort Type;
    [ArraySizeAttribute("16")]
public Char[] Key;
    public ushort Padding1;
    public VsFixedFileInfo Value;
}
public class Microsoft.FileFormats.PerfMap.PerfMapFile : object {
    private static int PerfMapV1SigLength;
    private static int PerfMapV1HeaderRecordCount;
    public static int MaxKnownPerfMapVersion;
    private static int HeaderRecordPseudoLength;
    private Stream _stream;
    private Lazy`1<PerfMapHeader> _header;
    public PerfMapHeader Header { get; }
    public bool IsValid { get; }
    public IEnumerable`1<PerfMapRecord> PerfRecords { get; }
    public PerfMapFile(Stream stream);
    private static PerfMapFile();
    public PerfMapHeader get_Header();
    public bool get_IsValid();
    [IteratorStateMachineAttribute("Microsoft.FileFormats.PerfMap.PerfMapFile/<get_PerfRecords>d__15")]
public IEnumerable`1<PerfMapRecord> get_PerfRecords();
    private void ThrowIfInvalid();
    private PerfMapHeader ReadHeader();
    private static PerfMapRecord ReadRecord(StreamReader reader);
    [CompilerGeneratedAttribute]
internal static bool <ReadHeader>g__IsValidHeaderRecord|18_0(PerfMapPseudoRVAToken expectedToken, PerfMapRecord record);
}
public class Microsoft.FileFormats.PiecewiseAddressSpace : object {
    private PiecewiseAddressSpaceRange[] _ranges;
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public ulong Length { get; private set; }
    public PiecewiseAddressSpace(PiecewiseAddressSpaceRange[] ranges);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
}
public class Microsoft.FileFormats.PiecewiseAddressSpaceRange : ValueType {
    public ulong Start;
    public ulong Length;
    public IAddressSpace AddressSpace;
}
public class Microsoft.FileFormats.Pointer : object {
    public ulong Value;
    protected ILayout _targetLayout;
    public bool IsNull { get; }
    public bool get_IsNull();
    public virtual string ToString();
    public static ulong op_Implicit(Pointer instance);
    internal void Init(ILayout targetLayout, ulong value);
}
public class Microsoft.FileFormats.Pointer`2 : Pointer {
    public TargetType Dereference(IAddressSpace addressSpace);
    public TargetType Element(IAddressSpace addressSpace, UInt32 index);
}
public class Microsoft.FileFormats.PointerLayout : LayoutBase {
    protected ILayout _storageLayout;
    private LayoutManager _layoutManager;
    private Type _targetType;
    private ILayout _targetLayout;
    public ILayout TargetLayout { get; }
    public PointerLayout(LayoutManager layoutManager, Type pointerType, ILayout storageLayout, Type targetType);
    public ILayout get_TargetLayout();
}
public abstract class Microsoft.FileFormats.PrimitiveTypeLayout : LayoutBase {
    [CompilerGeneratedAttribute]
private bool <IsBigEndian>k__BackingField;
    public bool IsBigEndian { get; private set; }
    public PrimitiveTypeLayout(Type type, bool isBigEndian, UInt32 size);
    [CompilerGeneratedAttribute]
public bool get_IsBigEndian();
    [CompilerGeneratedAttribute]
private void set_IsBigEndian(bool value);
}
public class Microsoft.FileFormats.Reader : object {
    [CompilerGeneratedAttribute]
private LayoutManager <LayoutManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IAddressSpace <DataSource>k__BackingField;
    public LayoutManager LayoutManager { get; private set; }
    public IAddressSpace DataSource { get; private set; }
    public ulong Length { get; }
    public Reader(IAddressSpace dataSource, bool isBigEndian);
    public Reader(IAddressSpace dataSource, LayoutManager layoutManager);
    [CompilerGeneratedAttribute]
public LayoutManager get_LayoutManager();
    [CompilerGeneratedAttribute]
private void set_LayoutManager(LayoutManager value);
    [CompilerGeneratedAttribute]
public IAddressSpace get_DataSource();
    [CompilerGeneratedAttribute]
private void set_DataSource(IAddressSpace value);
    public T[] ReadArray(ulong position, UInt32 elementCount);
    public T[] ReadArray(UInt64& position, UInt32 elementCount);
    public bool TryRead(ulong position, T& value);
    public T Read(ulong position);
    public T Read(UInt64& position);
    public UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    public Byte[] Read(ulong position, UInt32 count);
    public Byte[] Read(UInt64& position, UInt32 count);
    public ulong get_Length();
    public UInt32 SizeOf();
    public Reader WithRelativeAddressSpace(ulong startOffset, ulong length);
    public Reader WithRelativeAddressSpace(ulong startOffset, ulong length, long baseToRelativeShift);
    public Reader WithAddressSpace(IAddressSpace addressSpace);
}
public class Microsoft.FileFormats.RelativeAddressSpace : object {
    private IAddressSpace _baseAddressSpace;
    private ulong _baseStart;
    private ulong _length;
    private long _baseToRelativeShift;
    public ulong Length { get; }
    public RelativeAddressSpace(IAddressSpace baseAddressSpace, ulong startOffset, ulong length);
    public RelativeAddressSpace(IAddressSpace baseAddressSpace, ulong startOffset, ulong length, long baseToRelativeShift);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    public sealed virtual ulong get_Length();
}
public class Microsoft.FileFormats.SingleLayout : PrimitiveTypeLayout {
    public SingleLayout(bool isBigEndian);
    public SingleLayout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.SizeT : ValueType {
    private ulong _value;
    internal SizeT(ulong value);
    public static ulong op_Implicit(SizeT instance);
    public static long op_Explicit(SizeT instance);
    public static UInt32 op_Explicit(SizeT instance);
    public virtual string ToString();
}
public class Microsoft.FileFormats.SizeTPointerLayout : PointerLayout {
    public SizeTPointerLayout(LayoutManager layoutManager, Type pointerType, ILayout storageLayout, Type targetType);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.StreamAddressSpace : object {
    private Stream _stream;
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public ulong Length { get; private set; }
    public StreamAddressSpace(Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
    public sealed virtual void Dispose();
}
public class Microsoft.FileFormats.TField : object {
    [CompilerGeneratedAttribute]
private FieldInfo <FieldInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private ILayout <DeclaringLayout>k__BackingField;
    public FieldInfo FieldInfo { get; private set; }
    public UInt32 Offset { get; private set; }
    public UInt32 Size { get; }
    public UInt32 NaturalAlignment { get; }
    public ILayout Layout { get; private set; }
    public ILayout DeclaringLayout { get; public set; }
    public string Name { get; }
    public TField(FieldInfo fieldInfo, ILayout layout, UInt32 offset);
    [CompilerGeneratedAttribute]
public FieldInfo get_FieldInfo();
    [CompilerGeneratedAttribute]
private void set_FieldInfo(FieldInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(UInt32 value);
    public UInt32 get_Size();
    public UInt32 get_NaturalAlignment();
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
private void set_Layout(ILayout value);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_DeclaringLayout();
    [CompilerGeneratedAttribute]
public void set_DeclaringLayout(ILayout value);
    public sealed virtual string get_Name();
    public sealed virtual object GetValue(TStruct tStruct);
    public virtual string ToString();
    public sealed virtual void SetValue(TStruct tStruct, object newValue);
}
public class Microsoft.FileFormats.TLayout : LayoutBase {
    public TLayout(Type type, UInt32 size, UInt32 naturalAlignment, UInt32 sizeAsBaseType, IField[] fields);
    public virtual object Read(IAddressSpace dataTarget, ulong position);
}
public abstract class Microsoft.FileFormats.TStruct : object {
}
public class Microsoft.FileFormats.UInt16Layout : PrimitiveTypeLayout {
    public UInt16Layout(bool isBigEndian);
    public UInt16Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt32Layout : PrimitiveTypeLayout {
    public UInt32Layout(bool isBigEndian);
    public UInt32Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt32PointerLayout : PointerLayout {
    public UInt32PointerLayout(LayoutManager layoutManager, Type pointerType, ILayout storageLayout, Type targetType);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt32SizeTLayout : LayoutBase {
    private ILayout _storageLayout;
    public UInt32SizeTLayout(ILayout storageLayout);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt64Layout : PrimitiveTypeLayout {
    public UInt64Layout(bool isBigEndian);
    public UInt64Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt64PointerLayout : PointerLayout {
    public UInt64PointerLayout(LayoutManager layoutManager, Type pointerType, ILayout storageLayout, Type targetType);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt64SizeTLayout : LayoutBase {
    private ILayout _storageLayout;
    public UInt64SizeTLayout(ILayout storageLayout);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.UInt8Layout : PrimitiveTypeLayout {
    public UInt8Layout(bool isBigEndian);
    public UInt8Layout(Type type, bool isBigEndian);
    public virtual object Read(IAddressSpace dataSource, ulong position);
}
public class Microsoft.FileFormats.ValidationRule : object {
    private Func`1<bool> _checkFunc;
    private ValidationRule[] _prereqs;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public string ErrorMessage { get; private set; }
    public ValidationRule(string errorMessage, Func`1<bool> checkFunc);
    public ValidationRule(string errorMessage, Func`1<bool> checkFunc, ValidationRule[] prerequisiteValidations);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ErrorMessage(string value);
    public bool CheckPrerequisites();
    public bool Check();
    public void CheckThrowing();
}
public class Microsoft.FileFormats.ZeroAddressSpace : object {
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public ulong Length { get; private set; }
    public ZeroAddressSpace(ulong length);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ulong value);
    public sealed virtual UInt32 Read(ulong position, Byte[] buffer, UInt32 bufferOffset, UInt32 count);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
