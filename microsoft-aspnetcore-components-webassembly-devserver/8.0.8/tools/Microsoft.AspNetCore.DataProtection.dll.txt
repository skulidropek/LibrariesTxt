[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ActivatorExtensions : object {
    [ExtensionAttribute]
public static T CreateInstance(IActivator activator, string implementationTypeName);
    [ExtensionAttribute]
public static IActivator GetActivator(IServiceProvider serviceProvider);
}
[AttributeUsageAttribute("128")]
internal class Microsoft.AspNetCore.DataProtection.ApplyPolicyAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ArraySegmentExtensions : object {
    [ExtensionAttribute]
public static Byte[] AsStandaloneArray(ArraySegment`1<byte> arraySegment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Validate(ArraySegment`1<T> arraySegment);
}
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AlgorithmAssert : object {
    private static UInt32 SYMMETRIC_ALG_MIN_BLOCK_SIZE_IN_BITS;
    private static UInt32 SYMMETRIC_ALG_MIN_KEY_LENGTH_IN_BITS;
    private static UInt32 HASH_ALG_MIN_DIGEST_LENGTH_IN_BITS;
    private static UInt32 MAX_SIZE_IN_BITS;
    public static void IsAllowableSymmetricAlgorithmBlockSize(UInt32 blockSizeInBits);
    public static void IsAllowableSymmetricAlgorithmKeySize(UInt32 keySizeInBits);
    public static void IsAllowableValidationAlgorithmDigestSize(UInt32 digestSizeInBits);
    private static bool IsValidCore(UInt32 value, UInt32 minValue);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorExtensions : object {
    [ExtensionAttribute]
public static Byte[] Encrypt(IAuthenticatedEncryptor encryptor, ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void PerformSelfTest(IAuthenticatedEncryptor encryptor);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory : object {
    private ILoggerFactory _loggerFactory;
    [NullableContextAttribute("1")]
public AuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    [NullableContextAttribute("2")]
internal IAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, AuthenticatedEncryptorConfiguration authenticatedConfiguration);
    internal static bool IsGcmAlgorithm(EncryptionAlgorithm algorithm);
    private static int GetAlgorithmKeySizeInBits(EncryptionAlgorithm algorithm);
    private static string GetBCryptAlgorithmNameFromEncryptionAlgorithm(EncryptionAlgorithm algorithm);
    private static string GetBCryptAlgorithmNameFromValidationAlgorithm(ValidationAlgorithm algorithm);
    private static Type GetManagedTypeFromEncryptionAlgorithm(EncryptionAlgorithm algorithm);
    private static Type GetManagedTypeFromValidationAlgorithm(ValidationAlgorithm algorithm);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    [NullableContextAttribute("1")]
public CngCbcAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
internal CbcAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, CngCbcAuthenticatedEncryptorConfiguration configuration);
    [SupportedOSPlatformAttribute("windows")]
private BCryptAlgorithmHandle GetHmacAlgorithmHandle(CngCbcAuthenticatedEncryptorConfiguration configuration);
    [SupportedOSPlatformAttribute("windows")]
private BCryptAlgorithmHandle GetSymmetricBlockCipherAlgorithmHandle(CngCbcAuthenticatedEncryptorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    public CngGcmAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    [SupportedOSPlatformAttribute("windows")]
internal CngGcmAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, CngGcmAuthenticatedEncryptorConfiguration configuration);
    [SupportedOSPlatformAttribute("windows")]
private BCryptAlgorithmHandle GetSymmetricBlockCipherAlgorithmHandle(CngGcmAuthenticatedEncryptorConfiguration configuration);
}
public abstract class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration : object {
    internal static int KDK_SIZE_IN_BYTES;
    [NullableContextAttribute("1")]
public abstract virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationAlgorithm <ValidationAlgorithm>k__BackingField;
    public EncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    public ValidationAlgorithm ValidationAlgorithm { get; public set; }
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public ValidationAlgorithm get_ValidationAlgorithm();
    [CompilerGeneratedAttribute]
public void set_ValidationAlgorithm(ValidationAlgorithm value);
    [NullableContextAttribute("1")]
public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal AuthenticatedEncryptorConfiguration Configuration { get; }
    public AuthenticatedEncryptorDescriptor(AuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal AuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithmProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashAlgorithmProvider>k__BackingField;
    [ApplyPolicyAttribute]
public string EncryptionAlgorithm { get; public set; }
    [NullableAttribute("2")]
[ApplyPolicyAttribute]
public string EncryptionAlgorithmProvider { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [ApplyPolicyAttribute]
public string HashAlgorithm { get; public set; }
    [NullableAttribute("2")]
[ApplyPolicyAttribute]
public string HashAlgorithmProvider { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_EncryptionAlgorithmProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmProvider(string value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_HashAlgorithmProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_HashAlgorithmProvider(string value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CngCbcAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal CngCbcAuthenticatedEncryptorConfiguration Configuration { get; }
    public CngCbcAuthenticatedEncryptorDescriptor(CngCbcAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal CngCbcAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptorDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionAlgorithmProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [ApplyPolicyAttribute]
public string EncryptionAlgorithm { get; public set; }
    [NullableAttribute("2")]
[ApplyPolicyAttribute]
public string EncryptionAlgorithmProvider { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithm(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_EncryptionAlgorithmProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmProvider(string value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CngGcmAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal CngGcmAuthenticatedEncryptorConfiguration Configuration { get; }
    public CngGcmAuthenticatedEncryptorDescriptor(CngGcmAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal CngGcmAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptorDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
    public abstract virtual XmlSerializedDescriptorInfo ExportToXml();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptorDeserializer {
    public abstract virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration {
    public abstract virtual IAuthenticatedEncryptorDescriptor CreateDescriptorFromSecret(ISecret secret);
    public abstract virtual void Validate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAlgorithmHelpers : object {
    private static List`1<Type> KnownAlgorithmTypes;
    private static ManagedAlgorithmHelpers();
    public static string TypeToFriendlyName(Type type);
    [UnconditionalSuppressMessageAttribute("Trimmer", "IL2075")]
[UnconditionalSuppressMessageAttribute("Trimmer", "IL2073")]
public static Type FriendlyNameToType(string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration : AlgorithmConfiguration {
    [CompilerGeneratedAttribute]
private Type <EncryptionAlgorithmType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionAlgorithmKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValidationAlgorithmType>k__BackingField;
    [ApplyPolicyAttribute]
[DynamicallyAccessedMembersAttribute("1")]
public Type EncryptionAlgorithmType { get; public set; }
    [ApplyPolicyAttribute]
public int EncryptionAlgorithmKeySize { get; public set; }
    [ApplyPolicyAttribute]
[DynamicallyAccessedMembersAttribute("1")]
public Type ValidationAlgorithmType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_EncryptionAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmType(Type value);
    [CompilerGeneratedAttribute]
public int get_EncryptionAlgorithmKeySize();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithmKeySize(int value);
    [CompilerGeneratedAttribute]
public Type get_ValidationAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_ValidationAlgorithmType(Type value);
    public virtual IAuthenticatedEncryptorDescriptor CreateNewDescriptor();
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.CreateDescriptorFromSecret(ISecret secret);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IInternalAlgorithmConfiguration.Validate();
    private static string TypeToFriendlyName(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptor : object {
    [CompilerGeneratedAttribute]
private ISecret <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedAuthenticatedEncryptorConfiguration <Configuration>k__BackingField;
    internal ISecret MasterKey { get; }
    internal ManagedAuthenticatedEncryptorConfiguration Configuration { get; }
    public ManagedAuthenticatedEncryptorDescriptor(ManagedAuthenticatedEncryptorConfiguration configuration, ISecret masterKey);
    [CompilerGeneratedAttribute]
internal ISecret get_MasterKey();
    [CompilerGeneratedAttribute]
internal ManagedAuthenticatedEncryptorConfiguration get_Configuration();
    public sealed virtual XmlSerializedDescriptorInfo ExportToXml();
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptorDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptorDescriptor ImportFromXml(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.SecretExtensions : object {
    [ExtensionAttribute]
public static XElement ToMasterKeyElement(ISecret secret);
    [ExtensionAttribute]
public static Secret ToSecret(string base64String);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlExtensions : object {
    [ExtensionAttribute]
internal static bool IsMarkedAsRequiringEncryption(XElement element);
    [ExtensionAttribute]
public static void MarkAsRequiresEncryption(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo : object {
    [CompilerGeneratedAttribute]
private Type <DeserializerType>k__BackingField;
    [CompilerGeneratedAttribute]
private XElement <SerializedDescriptorElement>k__BackingField;
    public Type DeserializerType { get; }
    public XElement SerializedDescriptorElement { get; }
    public XmlSerializedDescriptorInfo(XElement serializedDescriptorElement, Type deserializerType);
    [CompilerGeneratedAttribute]
public Type get_DeserializerType();
    [CompilerGeneratedAttribute]
public XElement get_SerializedDescriptorElement();
}
public enum Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm AES_128_CBC;
    public static EncryptionAlgorithm AES_192_CBC;
    public static EncryptionAlgorithm AES_256_CBC;
    public static EncryptionAlgorithm AES_128_GCM;
    public static EncryptionAlgorithm AES_192_GCM;
    public static EncryptionAlgorithm AES_256_GCM;
}
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor {
    public abstract virtual Byte[] Decrypt(ArraySegment`1<byte> ciphertext, ArraySegment`1<byte> additionalAuthenticatedData);
    public abstract virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory {
    public abstract virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
}
internal interface Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IOptimizedAuthenticatedEncryptor {
    public abstract virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
}
public class Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory : object {
    private ILogger _logger;
    [NullableContextAttribute("1")]
public ManagedAuthenticatedEncryptorFactory(ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual IAuthenticatedEncryptor CreateEncryptorInstance(IKey key);
    [NullableContextAttribute("2")]
internal ManagedAuthenticatedEncryptor CreateAuthenticatedEncryptorInstance(ISecret secret, ManagedAuthenticatedEncryptorConfiguration configuration);
    private Func`1<KeyedHashAlgorithm> GetKeyedHashAlgorithmFactory(ManagedAuthenticatedEncryptorConfiguration configuration);
    private Func`1<SymmetricAlgorithm> GetSymmetricBlockCipherAlgorithmFactory(ManagedAuthenticatedEncryptorConfiguration configuration);
}
public enum Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm : Enum {
    public int value__;
    public static ValidationAlgorithm HMACSHA256;
    public static ValidationAlgorithm HMACSHA512;
}
internal static class Microsoft.AspNetCore.DataProtection.BitHelpers : object {
    public static void WriteTo(Void* ptr, UInt32 value);
    public static void WriteTo(Byte*& ptr, UInt32 value);
    [NullableContextAttribute("1")]
public static void WriteTo(Byte[] buffer, Int32& idx, int value);
    [NullableContextAttribute("1")]
public static void WriteTo(Byte[] buffer, Int32& idx, UInt32 value);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.BCryptGenRandomImpl : object {
    [NullableAttribute("1")]
public static BCryptGenRandomImpl Instance;
    private static BCryptGenRandomImpl();
    public sealed virtual void GenRandom(Byte* pbBuffer, UInt32 cbBuffer);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.CbcAuthenticatedEncryptor : CngAuthenticatedEncryptorBase {
    private static UInt32 KEY_MODIFIER_SIZE_IN_BYTES;
    private Byte[] _contextHeader;
    private IBCryptGenRandom _genRandom;
    private BCryptAlgorithmHandle _hmacAlgorithmHandle;
    private UInt32 _hmacAlgorithmDigestLengthInBytes;
    private UInt32 _hmacAlgorithmSubkeyLengthInBytes;
    private ISP800_108_CTR_HMACSHA512Provider _sp800_108_ctr_hmac_provider;
    private BCryptAlgorithmHandle _symmetricAlgorithmHandle;
    private UInt32 _symmetricAlgorithmBlockSizeInBytes;
    private UInt32 _symmetricAlgorithmSubkeyLengthInBytes;
    [NullableContextAttribute("1")]
public CbcAuthenticatedEncryptor(Secret keyDerivationKey, BCryptAlgorithmHandle symmetricAlgorithmHandle, UInt32 symmetricAlgorithmKeySizeInBytes, BCryptAlgorithmHandle hmacAlgorithmHandle, IBCryptGenRandom genRandom);
    private Byte[] CreateContextHeader();
    protected virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public virtual void Dispose();
    private Byte[] DoCbcDecrypt(BCryptKeyHandle symmetricKeyHandle, Byte* pbIV, Byte* pbInput, UInt32 cbInput);
    private void DoCbcEncrypt(BCryptKeyHandle symmetricKeyHandle, Byte* pbIV, Byte* pbInput, UInt32 cbInput, Byte* pbOutput, UInt32 cbOutput);
    protected virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
    private UInt32 GetCbcEncryptedOutputSizeWithPadding(BCryptKeyHandle symmetricKeyHandle, Byte* pbInput, UInt32 cbInput);
    private bool ValidateHash(BCryptHashHandle hashHandle, Byte* pbInput, UInt32 cbInput, Byte* pbExpectedDigest);
}
internal class Microsoft.AspNetCore.DataProtection.Cng.CngGcmAuthenticatedEncryptor : CngAuthenticatedEncryptorBase {
    private static UInt32 KEY_MODIFIER_SIZE_IN_BYTES;
    private static UInt32 NONCE_SIZE_IN_BYTES;
    private static UInt32 TAG_SIZE_IN_BYTES;
    private Byte[] _contextHeader;
    private IBCryptGenRandom _genRandom;
    private ISP800_108_CTR_HMACSHA512Provider _sp800_108_ctr_hmac_provider;
    private BCryptAlgorithmHandle _symmetricAlgorithmHandle;
    private UInt32 _symmetricAlgorithmSubkeyLengthInBytes;
    [NullableContextAttribute("1")]
public CngGcmAuthenticatedEncryptor(Secret keyDerivationKey, BCryptAlgorithmHandle symmetricAlgorithmHandle, UInt32 symmetricAlgorithmKeySizeInBytes, IBCryptGenRandom genRandom);
    private Byte[] CreateContextHeader();
    protected virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public virtual void Dispose();
    private void DoGcmEncrypt(Byte* pbKey, UInt32 cbKey, Byte* pbNonce, Byte* pbPlaintextData, UInt32 cbPlaintextData, Byte* pbEncryptedData, Byte* pbTag);
    protected virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.DataProtection.Cng.DpapiSecretSerializerHelper : object {
    private static UInt32 NCRYPT_SILENT_FLAG;
    private static UInt32 CRYPTPROTECT_UI_FORBIDDEN;
    private static UInt32 CRYPTPROTECT_LOCAL_MACHINE;
    private static Byte[] _purpose;
    private static DpapiSecretSerializerHelper();
    public static bool CanProtectToCurrentUserAccount();
    public static Byte[] ProtectWithDpapi(ISecret secret, bool protectToLocalMachine);
    [NullableContextAttribute("0")]
internal static Byte[] ProtectWithDpapiCore(Byte* pbSecret, UInt32 cbSecret, Byte* pbOptionalEntropy, UInt32 cbOptionalEntropy, bool fLocalMachine);
    public static Byte[] ProtectWithDpapiNG(ISecret secret, NCryptDescriptorHandle protectionDescriptorHandle);
    private static Byte[] ProtectWithDpapiNGCore(NCryptDescriptorHandle protectionDescriptorHandle, Byte* pbData, UInt32 cbData);
    public static Secret UnprotectWithDpapi(Byte[] protectedSecret);
    [NullableContextAttribute("0")]
internal static Secret UnprotectWithDpapiCore(Byte* pbProtectedData, UInt32 cbProtectedData, Byte* pbOptionalEntropy, UInt32 cbOptionalEntropy);
    public static Secret UnprotectWithDpapiNG(Byte[] protectedData);
    private static Secret UnprotectWithDpapiNGCore(Byte* pbData, UInt32 cbData);
    public static string GetRuleFromDpapiNGProtectedPayload(Byte[] protectedData);
    private static string GetRuleFromDpapiNGProtectedPayloadCore(Byte* pbData, UInt32 cbData);
}
internal interface Microsoft.AspNetCore.DataProtection.Cng.IBCryptGenRandom {
    public abstract virtual void GenRandom(Byte* pbBuffer, UInt32 cbBuffer);
}
internal abstract class Microsoft.AspNetCore.DataProtection.Cng.Internal.CngAuthenticatedEncryptorBase : object {
    public sealed virtual Byte[] Decrypt(ArraySegment`1<byte> ciphertext, ArraySegment`1<byte> additionalAuthenticatedData);
    protected abstract virtual Byte[] DecryptImpl(Byte* pbCiphertext, UInt32 cbCiphertext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData);
    public abstract virtual void Dispose();
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
    protected abstract virtual Byte[] EncryptImpl(Byte* pbPlaintext, UInt32 cbPlaintext, Byte* pbAdditionalAuthenticatedData, UInt32 cbAdditionalAuthenticatedData, UInt32 cbPreBuffer, UInt32 cbPostBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions : object {
    [ExtensionAttribute]
public static IDataProtectionBuilder SetApplicationName(IDataProtectionBuilder builder, string applicationName);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder, IKeyEscrowSink sink);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyEscrowSink(IDataProtectionBuilder builder, Func`2<IServiceProvider, IKeyEscrowSink> factory);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddKeyManagementOptions(IDataProtectionBuilder builder, Action`1<KeyManagementOptions> setupAction);
    [ExtensionAttribute]
public static IDataProtectionBuilder DisableAutomaticKeyGeneration(IDataProtectionBuilder builder);
    [ExtensionAttribute]
public static IDataProtectionBuilder PersistKeysToFileSystem(IDataProtectionBuilder builder, DirectoryInfo directory);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder PersistKeysToRegistry(IDataProtectionBuilder builder, RegistryKey registryKey);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithCertificate(IDataProtectionBuilder builder, X509Certificate2 certificate);
    [ExtensionAttribute]
public static IDataProtectionBuilder ProtectKeysWithCertificate(IDataProtectionBuilder builder, string thumbprint);
    [ExtensionAttribute]
public static IDataProtectionBuilder UnprotectKeysWithAnyCertificate(IDataProtectionBuilder builder, X509Certificate2[] certificates);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder ProtectKeysWithDpapi(IDataProtectionBuilder builder);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder ProtectKeysWithDpapi(IDataProtectionBuilder builder, bool protectToLocalMachine);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder ProtectKeysWithDpapiNG(IDataProtectionBuilder builder);
    [ExtensionAttribute]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder ProtectKeysWithDpapiNG(IDataProtectionBuilder builder, string protectionDescriptorRule, DpapiNGProtectionDescriptorFlags flags);
    [ExtensionAttribute]
public static IDataProtectionBuilder SetDefaultKeyLifetime(IDataProtectionBuilder builder, TimeSpan lifetime);
    [ExtensionAttribute]
public static IDataProtectionBuilder UseCryptographicAlgorithms(IDataProtectionBuilder builder, AuthenticatedEncryptorConfiguration configuration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, CngCbcAuthenticatedEncryptorConfiguration configuration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, CngGcmAuthenticatedEncryptorConfiguration configuration);
    [ExtensionAttribute]
[EditorBrowsableAttribute("2")]
public static IDataProtectionBuilder UseCustomCryptographicAlgorithms(IDataProtectionBuilder builder, ManagedAuthenticatedEncryptorConfiguration configuration);
    private static IDataProtectionBuilder UseCryptographicAlgorithmsCore(IDataProtectionBuilder builder, AlgorithmConfiguration configuration);
    [ExtensionAttribute]
public static IDataProtectionBuilder UseEphemeralDataProtectionProvider(IDataProtectionBuilder builder);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.DataProtectionOptions : object {
    [CompilerGeneratedAttribute]
private string <ApplicationDiscriminator>k__BackingField;
    public string ApplicationDiscriminator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationDiscriminator();
    [CompilerGeneratedAttribute]
public void set_ApplicationDiscriminator(string value);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.DataProtection.DataProtectionUtilityExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static string GetApplicationUniqueIdentifier(IServiceProvider services);
}
internal static class Microsoft.AspNetCore.DataProtection.EncodingUtil : object {
    [NullableAttribute("1")]
public static UTF8Encoding SecureUtf8Encoding;
    private static EncodingUtil();
}
public class Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider : object {
    private KeyRingBasedDataProtectionProvider _dataProtectionProvider;
    [NullableContextAttribute("1")]
public EphemeralDataProtectionProvider(ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual IDataProtector CreateProtector(string purpose);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.DataProtection.Error : object {
    public static InvalidOperationException CertificateXmlEncryptor_CertificateNotFound(string thumbprint);
    public static ArgumentException Common_ArgumentCannotBeNullOrEmpty(string parameterName);
    public static ArgumentException Common_BufferIncorrectlySized(string parameterName, int actualSize, int expectedSize);
    public static CryptographicException CryptCommon_GenericError(Exception inner);
    public static CryptographicException CryptCommon_PayloadInvalid();
    public static InvalidOperationException Common_PropertyCannotBeNullOrEmpty(string propertyName);
    public static InvalidOperationException Common_PropertyMustBeNonNegative(string propertyName);
    public static CryptographicException Common_EncryptionFailed(Exception inner);
    public static CryptographicException Common_KeyNotFound(Guid id);
    public static CryptographicException Common_KeyRevoked(Guid id);
    public static ArgumentOutOfRangeException Common_ValueMustBeNonNegative(string paramName);
    public static CryptographicException DecryptionFailed(Exception inner);
    public static CryptographicException ProtectionProvider_BadMagicHeader();
    public static CryptographicException ProtectionProvider_BadVersion();
    public static InvalidOperationException XmlKeyManager_DuplicateKey(Guid keyId);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.ExceptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool RequiresHomogenization(Exception ex);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
    public IServiceCollection Services { get; }
    public abstract virtual IServiceCollection get_Services();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.DataProtection.Internal.ContainerUtils : object {
    private static Lazy`1<bool> _isContainer;
    private static string RunningInContainerVariableName;
    private static string DeprecatedRunningInContainerVariableName;
    public static bool IsContainer { get; }
    private static ContainerUtils();
    public static bool get_IsContainer();
    public static bool IsVolumeMountedFolder(DirectoryInfo directory);
    internal static bool IsDirectoryMounted(DirectoryInfo directory, IEnumerable`1<string> fstab);
    private static bool IsProcessRunningInContainer();
    private static bool GetBooleanEnvVar(string envVarName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionBuilder : object {
    [CompilerGeneratedAttribute]
private IServiceCollection <Services>k__BackingField;
    public IServiceCollection Services { get; }
    public DataProtectionBuilder(IServiceCollection services);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceCollection get_Services();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionHostedService : object {
    private IKeyRingProvider _keyRingProvider;
    private ILogger`1<DataProtectionHostedService> _logger;
    public DataProtectionHostedService(IKeyRingProvider keyRingProvider);
    public DataProtectionHostedService(IKeyRingProvider keyRingProvider, ILoggerFactory loggerFactory);
    public sealed virtual Task StartAsync(CancellationToken token);
    public sealed virtual Task StopAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Internal.DataProtectionOptionsSetup : object {
    private IServiceProvider _services;
    public DataProtectionOptionsSetup(IServiceProvider provider);
    public sealed virtual void Configure(DataProtectionOptions options);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.DefaultTypeNameResolver : object {
    [NullableAttribute("1")]
public static DefaultTypeNameResolver Instance;
    private static DefaultTypeNameResolver();
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimmer", "IL2057")]
public sealed virtual bool TryResolveType(string typeName, Type& type);
}
internal class Microsoft.AspNetCore.DataProtection.Internal.HostingApplicationDiscriminator : object {
    private IHostEnvironment _hosting;
    private string DirectorySeparator;
    private string AltDirectorySeparator;
    [NullableAttribute("2")]
public string Discriminator { get; }
    [NullableContextAttribute("1")]
public HostingApplicationDiscriminator(IHostEnvironment hosting);
    [NullableContextAttribute("2")]
public sealed virtual string get_Discriminator();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.Internal.IActivator {
    public abstract virtual object CreateInstance(Type expectedBaseType, string implementationTypeName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.DataProtection.Internal.ITypeNameResolver {
    public abstract virtual bool TryResolveType(string typeName, Type& type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Internal.KeyManagementOptionsPostSetup : object {
    internal static string ReadOnlyDataProtectionKeyDirectoryKey;
    private string _keyDirectoryPath;
    private ILoggerFactory _loggerFactory;
    private ILogger`1<KeyManagementOptionsPostSetup> _logger;
    public KeyManagementOptionsPostSetup(IConfiguration configuration, ILoggerFactory loggerFactory);
    private sealed virtual override void Microsoft.Extensions.Options.IPostConfigureOptions<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>.PostConfigure(string name, KeyManagementOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Internal.KeyManagementOptionsSetup : object {
    private IRegistryPolicyResolver _registryPolicyResolver;
    private ILoggerFactory _loggerFactory;
    public KeyManagementOptionsSetup(ILoggerFactory loggerFactory);
    public KeyManagementOptionsSetup(IRegistryPolicyResolver registryPolicyResolver);
    public KeyManagementOptionsSetup(ILoggerFactory loggerFactory, IRegistryPolicyResolver registryPolicyResolver);
    public sealed virtual void Configure(KeyManagementOptions options);
}
public interface Microsoft.AspNetCore.DataProtection.IPersistedDataProtector {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] DangerousUnprotect(Byte[] protectedData, bool ignoreRevocationErrors, Boolean& requiresMigration, Boolean& wasRevoked);
}
[NullableContextAttribute("2")]
internal interface Microsoft.AspNetCore.DataProtection.IRegistryPolicyResolver {
    public abstract virtual RegistryPolicy ResolvePolicy();
}
public interface Microsoft.AspNetCore.DataProtection.ISecret {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual void WriteSecretIntoBuffer(ArraySegment`1<byte> buffer);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.DefaultKeyResolver : object {
    private TimeSpan _keyPropagationWindow;
    private ILogger _logger;
    private TimeSpan _maxServerToServerClockSkew;
    [NullableContextAttribute("1")]
public DefaultKeyResolver(ILoggerFactory loggerFactory);
    private bool CanCreateAuthenticatedEncryptor(IKey key);
    private IKey FindDefaultKey(DateTimeOffset now, IEnumerable`1<IKey> allKeys, IKey& fallbackKey, Boolean& callerShouldGenerateNewKey);
    [NullableContextAttribute("1")]
public sealed virtual DefaultKeyResolution ResolveDefaultKeyPolicy(DateTimeOffset now, IEnumerable`1<IKey> allKeys);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.DeferredKey : KeyBase {
    [NullableContextAttribute("1")]
public DeferredKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, IInternalXmlKeyManager keyManager, XElement keyElement, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
    private static Func`1<IAuthenticatedEncryptorDescriptor> GetLazyDescriptorDelegate(IInternalXmlKeyManager keyManager, XElement keyElement);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKey {
    public DateTimeOffset ActivationDate { get; }
    public DateTimeOffset CreationDate { get; }
    public DateTimeOffset ExpirationDate { get; }
    public bool IsRevoked { get; }
    public Guid KeyId { get; }
    public IAuthenticatedEncryptorDescriptor Descriptor { get; }
    public abstract virtual DateTimeOffset get_ActivationDate();
    public abstract virtual DateTimeOffset get_CreationDate();
    public abstract virtual DateTimeOffset get_ExpirationDate();
    public abstract virtual bool get_IsRevoked();
    public abstract virtual Guid get_KeyId();
    public abstract virtual IAuthenticatedEncryptorDescriptor get_Descriptor();
    [NullableContextAttribute("2")]
public abstract virtual IAuthenticatedEncryptor CreateEncryptor();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink {
    public abstract virtual void Store(Guid keyId, XElement element);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager {
    public abstract virtual IKey CreateNewKey(DateTimeOffset activationDate, DateTimeOffset expirationDate);
    public abstract virtual IReadOnlyCollection`1<IKey> GetAllKeys();
    public abstract virtual CancellationToken GetCacheExpirationToken();
    [NullableContextAttribute("2")]
public abstract virtual void RevokeKey(Guid keyId, string reason);
    [NullableContextAttribute("2")]
public abstract virtual void RevokeAllKeys(DateTimeOffset revocationDate, string reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing : object {
    private CancellationToken _expirationToken;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyRing <KeyRing>k__BackingField;
    internal DateTime ExpirationTimeUtc { get; }
    internal IKeyRing KeyRing { get; }
    internal CacheableKeyRing(CancellationToken expirationToken, DateTimeOffset expirationTime, IKey defaultKey, IEnumerable`1<IKey> allKeys);
    internal CacheableKeyRing(CancellationToken expirationToken, DateTimeOffset expirationTime, IKeyRing keyRing);
    [CompilerGeneratedAttribute]
internal DateTime get_ExpirationTimeUtc();
    [CompilerGeneratedAttribute]
internal IKeyRing get_KeyRing();
    [NullableContextAttribute("2")]
internal static bool IsValid(CacheableKeyRing keyRing, DateTime utcNow);
    internal CacheableKeyRing WithTemporaryExtendedLifetime(DateTimeOffset now);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution : ValueType {
    public IKey DefaultKey;
    public IKey FallbackKey;
    public bool ShouldGenerateNewKey;
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider {
    public abstract virtual CacheableKeyRing GetCacheableKeyRing(DateTimeOffset now);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IDefaultKeyResolver {
    public abstract virtual DefaultKeyResolution ResolveDefaultKeyPolicy(DateTimeOffset now, IEnumerable`1<IKey> allKeys);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager {
    public abstract virtual IKey CreateNewKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    public abstract virtual IAuthenticatedEncryptorDescriptor DeserializeDescriptorFromKeyElement(XElement keyElement);
    [NullableContextAttribute("2")]
public abstract virtual void RevokeSingleKey(Guid keyId, DateTimeOffset revocationDate, string reason);
}
[NullableContextAttribute("2")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing {
    public IAuthenticatedEncryptor DefaultAuthenticatedEncryptor { get; }
    public Guid DefaultKeyId { get; }
    public abstract virtual IAuthenticatedEncryptor get_DefaultAuthenticatedEncryptor();
    public abstract virtual Guid get_DefaultKeyId();
    public abstract virtual IAuthenticatedEncryptor GetAuthenticatedEncryptorByKeyId(Guid keyId, Boolean& isRevoked);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRingProvider {
    public abstract virtual IKeyRing GetCurrentKeyRing();
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.Key : KeyBase {
    [NullableContextAttribute("1")]
public Key(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, IAuthenticatedEncryptorDescriptor descriptor, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyBase : object {
    private Lazy`1<IAuthenticatedEncryptorDescriptor> _lazyDescriptor;
    private IEnumerable`1<IAuthenticatedEncryptorFactory> _encryptorFactories;
    private IAuthenticatedEncryptor _encryptor;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ActivationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRevoked>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <KeyId>k__BackingField;
    public DateTimeOffset ActivationDate { get; }
    public DateTimeOffset CreationDate { get; }
    public DateTimeOffset ExpirationDate { get; }
    public bool IsRevoked { get; private set; }
    public Guid KeyId { get; }
    public IAuthenticatedEncryptorDescriptor Descriptor { get; }
    public KeyBase(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate, Lazy`1<IAuthenticatedEncryptorDescriptor> lazyDescriptor, IEnumerable`1<IAuthenticatedEncryptorFactory> encryptorFactories);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_ActivationDate();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_CreationDate();
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_ExpirationDate();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRevoked();
    [CompilerGeneratedAttribute]
private void set_IsRevoked(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_KeyId();
    public sealed virtual IAuthenticatedEncryptorDescriptor get_Descriptor();
    [NullableContextAttribute("2")]
public sealed virtual IAuthenticatedEncryptor CreateEncryptor();
    internal void SetRevoked();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyEscrowServiceProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IKeyEscrowSink GetKeyEscrowSink(IServiceProvider services);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsExpired(IKey key, DateTimeOffset now);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions : object {
    private static TimeSpan _keyPropagationWindow;
    private static TimeSpan _keyRingRefreshPeriod;
    private static TimeSpan _maxServerClockSkew;
    private TimeSpan _newKeyLifetime;
    [CompilerGeneratedAttribute]
private bool <AutoGenerateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmConfiguration <AuthenticatedEncryptorConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IKeyEscrowSink> <KeyEscrowSinks>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlRepository <XmlRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlEncryptor <XmlEncryptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAuthenticatedEncryptorFactory> <AuthenticatedEncryptorFactories>k__BackingField;
    public bool AutoGenerateKeys { get; public set; }
    internal static TimeSpan KeyPropagationWindow { get; }
    internal static TimeSpan KeyRingRefreshPeriod { get; }
    internal static TimeSpan MaxServerClockSkew { get; }
    public TimeSpan NewKeyLifetime { get; public set; }
    public AlgorithmConfiguration AuthenticatedEncryptorConfiguration { get; public set; }
    [NullableAttribute("1")]
public IList`1<IKeyEscrowSink> KeyEscrowSinks { get; }
    public IXmlRepository XmlRepository { get; public set; }
    public IXmlEncryptor XmlEncryptor { get; public set; }
    [NullableAttribute("1")]
public IList`1<IAuthenticatedEncryptorFactory> AuthenticatedEncryptorFactories { get; }
    [NullableContextAttribute("1")]
internal KeyManagementOptions(KeyManagementOptions other);
    private static KeyManagementOptions();
    [CompilerGeneratedAttribute]
public bool get_AutoGenerateKeys();
    [CompilerGeneratedAttribute]
public void set_AutoGenerateKeys(bool value);
    internal static TimeSpan get_KeyPropagationWindow();
    internal static TimeSpan get_KeyRingRefreshPeriod();
    internal static TimeSpan get_MaxServerClockSkew();
    public TimeSpan get_NewKeyLifetime();
    public void set_NewKeyLifetime(TimeSpan value);
    [CompilerGeneratedAttribute]
public AlgorithmConfiguration get_AuthenticatedEncryptorConfiguration();
    [CompilerGeneratedAttribute]
public void set_AuthenticatedEncryptorConfiguration(AlgorithmConfiguration value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<IKeyEscrowSink> get_KeyEscrowSinks();
    [CompilerGeneratedAttribute]
public IXmlRepository get_XmlRepository();
    [CompilerGeneratedAttribute]
public void set_XmlRepository(IXmlRepository value);
    [CompilerGeneratedAttribute]
public IXmlEncryptor get_XmlEncryptor();
    [CompilerGeneratedAttribute]
public void set_XmlEncryptor(IXmlEncryptor value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<IAuthenticatedEncryptorFactory> get_AuthenticatedEncryptorFactories();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRing : object {
    private KeyHolder _defaultKeyHolder;
    private Dictionary`2<Guid, KeyHolder> _keyIdToKeyHolderMap;
    [CompilerGeneratedAttribute]
private Guid <DefaultKeyId>k__BackingField;
    public IAuthenticatedEncryptor DefaultAuthenticatedEncryptor { get; }
    public Guid DefaultKeyId { get; }
    [NullableContextAttribute("1")]
public KeyRing(IKey defaultKey, IEnumerable`1<IKey> allKeys);
    public sealed virtual IAuthenticatedEncryptor get_DefaultAuthenticatedEncryptor();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_DefaultKeyId();
    public sealed virtual IAuthenticatedEncryptor GetAuthenticatedEncryptorByKeyId(Guid keyId, Boolean& isRevoked);
}
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtectionProvider : object {
    private IKeyRingProvider _keyRingProvider;
    private ILogger _logger;
    [NullableContextAttribute("1")]
public KeyRingBasedDataProtectionProvider(IKeyRingProvider keyRingProvider, ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual IDataProtector CreateProtector(string purpose);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector : object {
    private static UInt32 MAGIC_HEADER_V0;
    private AdditionalAuthenticatedDataTemplate _aadTemplate;
    private IKeyRingProvider _keyRingProvider;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private String[] <Purposes>k__BackingField;
    internal String[] Purposes { get; }
    public KeyRingBasedDataProtector(IKeyRingProvider keyRingProvider, ILogger logger, String[] originalPurposes, string newPurpose);
    [CompilerGeneratedAttribute]
internal String[] get_Purposes();
    private static String[] ConcatPurposes(String[] originalPurposes, string newPurpose);
    public sealed virtual IDataProtector CreateProtector(string purpose);
    private static string JoinPurposesForLog(IEnumerable`1<string> purposes);
    public sealed virtual Byte[] DangerousUnprotect(Byte[] protectedData, bool ignoreRevocationErrors, Boolean& requiresMigration, Boolean& wasRevoked);
    public sealed virtual Byte[] Protect(Byte[] plaintext);
    private static Guid ReadGuid(Void* ptr);
    private static UInt32 ReadBigEndian32BitInteger(Byte* ptr);
    private static bool TryGetVersionFromMagicHeader(UInt32 magicHeader, Int32& version);
    public sealed virtual Byte[] Unprotect(Byte[] protectedData);
    private Byte[] UnprotectCore(Byte[] protectedData, bool allowOperationsOnRevokedKeys, UnprotectStatus& status);
    private static void WriteGuid(Void* ptr, Guid value);
    private static void WriteBigEndianInteger(Byte* ptr, UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingProvider : object {
    private CacheableKeyRing _cacheableKeyRing;
    private object _cacheableKeyRingLockObj;
    private IDefaultKeyResolver _defaultKeyResolver;
    private KeyManagementOptions _keyManagementOptions;
    private IKeyManager _keyManager;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private ICacheableKeyRingProvider <CacheableKeyRingProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AutoRefreshWindowEnd>k__BackingField;
    internal ICacheableKeyRingProvider CacheableKeyRingProvider { get; internal set; }
    internal DateTime AutoRefreshWindowEnd { get; internal set; }
    public KeyRingProvider(IKeyManager keyManager, IOptions`1<KeyManagementOptions> keyManagementOptions, IDefaultKeyResolver defaultKeyResolver);
    public KeyRingProvider(IKeyManager keyManager, IOptions`1<KeyManagementOptions> keyManagementOptions, IDefaultKeyResolver defaultKeyResolver, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
internal ICacheableKeyRingProvider get_CacheableKeyRingProvider();
    [CompilerGeneratedAttribute]
internal void set_CacheableKeyRingProvider(ICacheableKeyRingProvider value);
    [CompilerGeneratedAttribute]
internal DateTime get_AutoRefreshWindowEnd();
    [CompilerGeneratedAttribute]
internal void set_AutoRefreshWindowEnd(DateTime value);
    internal bool InAutoRefreshWindow();
    private CacheableKeyRing CreateCacheableKeyRingCore(DateTimeOffset now, IKey keyJustAdded);
    private CacheableKeyRing CreateCacheableKeyRingCoreStep2(DateTimeOffset now, CancellationToken cacheExpirationToken, IKey defaultKey, IEnumerable`1<IKey> allKeys);
    public sealed virtual IKeyRing GetCurrentKeyRing();
    internal IKeyRing RefreshCurrentKeyRing();
    internal IKeyRing GetCurrentKeyRingCore(DateTime utcNow, bool forceRefresh);
    private static TimeSpan GetRefreshPeriodWithJitter(TimeSpan refreshPeriod);
    private static DateTimeOffset Min(DateTimeOffset a, DateTimeOffset b);
    private sealed virtual override CacheableKeyRing Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider.GetCacheableKeyRing(DateTimeOffset now);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager : object {
    internal static XName KeyElementName;
    internal static XName IdAttributeName;
    internal static XName VersionAttributeName;
    internal static XName CreationDateElementName;
    internal static XName ActivationDateElementName;
    internal static XName ExpirationDateElementName;
    internal static XName DescriptorElementName;
    internal static XName DeserializerTypeAttributeName;
    internal static XName RevocationElementName;
    internal static XName RevocationDateElementName;
    internal static XName ReasonElementName;
    private static string RevokeAllKeysValue;
    private IActivator _activator;
    private ITypeNameResolver _typeNameResolver;
    private AlgorithmConfiguration _authenticatedEncryptorConfiguration;
    private IKeyEscrowSink _keyEscrowSink;
    private IInternalXmlKeyManager _internalKeyManager;
    private ILoggerFactory _loggerFactory;
    private ILogger _logger;
    private IEnumerable`1<IAuthenticatedEncryptorFactory> _encryptorFactories;
    private IDefaultKeyStorageDirectories _keyStorageDirectories;
    private CancellationTokenSource _cacheExpirationTokenSource;
    [CompilerGeneratedAttribute]
private IXmlEncryptor <KeyEncryptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXmlRepository <KeyRepository>k__BackingField;
    [NullableAttribute("2")]
internal IXmlEncryptor KeyEncryptor { get; }
    internal IXmlRepository KeyRepository { get; }
    public XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator);
    public XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory);
    internal XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory, IDefaultKeyStorageDirectories keyStorageDirectories);
    internal XmlKeyManager(IOptions`1<KeyManagementOptions> keyManagementOptions, IActivator activator, ILoggerFactory loggerFactory, IInternalXmlKeyManager internalXmlKeyManager);
    private static XmlKeyManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IXmlEncryptor get_KeyEncryptor();
    [CompilerGeneratedAttribute]
internal IXmlRepository get_KeyRepository();
    public sealed virtual IKey CreateNewKey(DateTimeOffset activationDate, DateTimeOffset expirationDate);
    private static string DateTimeOffsetToFilenameSafeString(DateTimeOffset dateTime);
    public sealed virtual IReadOnlyCollection`1<IKey> GetAllKeys();
    public sealed virtual CancellationToken GetCacheExpirationToken();
    private KeyBase ProcessKeyElement(XElement keyElement);
    private object ProcessRevocationElement(XElement revocationElement);
    [NullableContextAttribute("2")]
public sealed virtual void RevokeAllKeys(DateTimeOffset revocationDate, string reason);
    [NullableContextAttribute("2")]
public sealed virtual void RevokeKey(Guid keyId, string reason);
    private void TriggerAndResetCacheExpirationToken(string opName, bool suppressLogging);
    private void WriteKeyDeserializationErrorToLog(Exception error, XElement keyElement);
    private sealed virtual override IKey Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.CreateNewKey(Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    private sealed virtual override IAuthenticatedEncryptorDescriptor Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.DeserializeDescriptorFromKeyElement(XElement keyElement);
    private IAuthenticatedEncryptorDescriptorDeserializer CreateDeserializer(string descriptorDeserializerTypeName);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.RevokeSingleKey(Guid keyId, DateTimeOffset revocationDate, string reason);
    internal KeyValuePair`2<IXmlRepository, IXmlEncryptor> GetFallbackKeyRepositoryEncryptorPair();
}
internal class Microsoft.AspNetCore.DataProtection.Managed.AesGcmAuthenticatedEncryptor : object {
    private static int KEY_MODIFIER_SIZE_IN_BYTES;
    private static int NONCE_SIZE_IN_BYTES;
    private static int TAG_SIZE_IN_BYTES;
    private static Byte[] AES_128_GCM_Header;
    private static Byte[] AES_192_GCM_Header;
    private static Byte[] AES_256_GCM_Header;
    private static Func`2<Byte[], HashAlgorithm> _kdkPrfFactory;
    private Byte[] _contextHeader;
    private Secret _keyDerivationKey;
    private int _derivedkeySizeInBytes;
    private IManagedGenRandom _genRandom;
    [NullableContextAttribute("1")]
public AesGcmAuthenticatedEncryptor(ISecret keyDerivationKey, int derivedKeySizeInBytes, IManagedGenRandom genRandom);
    private static AesGcmAuthenticatedEncryptor();
    public sealed virtual Byte[] Decrypt(ArraySegment`1<byte> ciphertext, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData, UInt32 preBufferSize, UInt32 postBufferSize);
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.Managed.HashAlgorithmExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int GetDigestSizeInBytes(HashAlgorithm hashAlgorithm);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.DataProtection.Managed.IManagedGenRandom {
    public abstract virtual Byte[] GenRandom(int numBytes);
}
internal class Microsoft.AspNetCore.DataProtection.Managed.ManagedAuthenticatedEncryptor : object {
    private static int KEY_MODIFIER_SIZE_IN_BYTES;
    private static Func`2<Byte[], HashAlgorithm> _kdkPrfFactory;
    private Byte[] _contextHeader;
    private IManagedGenRandom _genRandom;
    private Secret _keyDerivationKey;
    private Func`1<SymmetricAlgorithm> _symmetricAlgorithmFactory;
    private int _symmetricAlgorithmBlockSizeInBytes;
    private int _symmetricAlgorithmSubkeyLengthInBytes;
    private int _validationAlgorithmDigestLengthInBytes;
    private int _validationAlgorithmSubkeyLengthInBytes;
    private Func`1<KeyedHashAlgorithm> _validationAlgorithmFactory;
    [NullableContextAttribute("1")]
public ManagedAuthenticatedEncryptor(Secret keyDerivationKey, Func`1<SymmetricAlgorithm> symmetricAlgorithmFactory, int symmetricAlgorithmKeySizeInBytes, Func`1<KeyedHashAlgorithm> validationAlgorithmFactory, IManagedGenRandom genRandom);
    private static ManagedAuthenticatedEncryptor();
    private Byte[] CreateContextHeader();
    private SymmetricAlgorithm CreateSymmetricAlgorithm();
    private KeyedHashAlgorithm CreateValidationAlgorithm(Byte[] key);
    public sealed virtual Byte[] Decrypt(ArraySegment`1<byte> protectedPayload, ArraySegment`1<byte> additionalAuthenticatedData);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Encrypt(ArraySegment`1<byte> plaintext, ArraySegment`1<byte> additionalAuthenticatedData);
}
internal class Microsoft.AspNetCore.DataProtection.Managed.ManagedGenRandomImpl : object {
    [NullableAttribute("1")]
public static ManagedGenRandomImpl Instance;
    private static ManagedGenRandomImpl();
    [NullableContextAttribute("1")]
public sealed virtual Byte[] GenRandom(int numBytes);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.Managed.SymmetricAlgorithmExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int GetBlockSizeInBytes(SymmetricAlgorithm symmetricAlgorithm);
}
internal static class Microsoft.AspNetCore.DataProtection.MemoryProtection : object {
    private static UInt32 CRYPTPROTECTMEMORY_SAME_PROCESS;
    [NullableContextAttribute("1")]
public static void CryptProtectMemory(SafeHandle pBuffer, UInt32 byteCount);
    public static void CryptUnprotectMemory(Byte* pBuffer, UInt32 byteCount);
    [NullableContextAttribute("1")]
public static void CryptUnprotectMemory(SafeHandle pBuffer, UInt32 byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.RegistryPolicy : object {
    [CompilerGeneratedAttribute]
private AlgorithmConfiguration <EncryptorConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IKeyEscrowSink> <KeyEscrowSinks>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DefaultKeyLifetime>k__BackingField;
    [NullableAttribute("2")]
public AlgorithmConfiguration EncryptorConfiguration { get; }
    public IEnumerable`1<IKeyEscrowSink> KeyEscrowSinks { get; }
    public Nullable`1<int> DefaultKeyLifetime { get; }
    public RegistryPolicy(AlgorithmConfiguration configuration, IEnumerable`1<IKeyEscrowSink> keyEscrowSinks, Nullable`1<int> defaultKeyLifetime);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AlgorithmConfiguration get_EncryptorConfiguration();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IKeyEscrowSink> get_KeyEscrowSinks();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DefaultKeyLifetime();
}
[SupportedOSPlatformAttribute("windows")]
internal class Microsoft.AspNetCore.DataProtection.RegistryPolicyResolver : object {
    private Func`1<RegistryKey> _getPolicyRegKey;
    private IActivator _activator;
    [NullableContextAttribute("1")]
public RegistryPolicyResolver(IActivator activator);
    [NullableContextAttribute("1")]
internal RegistryPolicyResolver(RegistryKey policyRegKey, IActivator activator);
    private static List`1<string> ReadKeyEscrowSinks(RegistryKey key);
    [NullableContextAttribute("2")]
public sealed virtual RegistryPolicy ResolvePolicy();
    private RegistryPolicy ResolvePolicyCore(RegistryKey policyRegKey);
    private static CngCbcAuthenticatedEncryptorConfiguration GetCngCbcAuthenticatedEncryptorConfiguration(RegistryKey key);
    private static CngGcmAuthenticatedEncryptorConfiguration GetCngGcmAuthenticatedEncryptorConfiguration(RegistryKey key);
    private static ManagedAuthenticatedEncryptorConfiguration GetManagedAuthenticatedEncryptorConfiguration(RegistryKey key);
}
internal class Microsoft.AspNetCore.DataProtection.Repositories.DefaultKeyStorageDirectories : object {
    private static Lazy`1<DirectoryInfo> _defaultDirectoryLazy;
    [CompilerGeneratedAttribute]
private static IDefaultKeyStorageDirectories <Instance>k__BackingField;
    private static string DataProtectionKeysFolderName;
    [NullableAttribute("1")]
public static IDefaultKeyStorageDirectories Instance { get; }
    private static DefaultKeyStorageDirectories();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static IDefaultKeyStorageDirectories get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual DirectoryInfo GetKeyStorageDirectory();
    private static DirectoryInfo GetKeyStorageDirectoryImpl();
    [NullableContextAttribute("2")]
public sealed virtual DirectoryInfo GetKeyStorageDirectoryForAzureWebSites();
    private static DirectoryInfo GetKeyStorageDirectoryFromBaseAppDataPath(string basePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.Repositories.EphemeralXmlRepository : object {
    private List`1<XElement> _storedElements;
    public EphemeralXmlRepository(ILoggerFactory loggerFactory);
    public sealed virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.EphemeralXmlRepository/<GetAllElementsCore>d__3")]
private IEnumerable`1<XElement> GetAllElementsCore();
    public sealed virtual void StoreElement(XElement element, string friendlyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository : object {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private DirectoryInfo <Directory>k__BackingField;
    [NullableAttribute("2")]
public static DirectoryInfo DefaultKeyStorageDirectory { get; }
    public DirectoryInfo Directory { get; }
    public FileSystemXmlRepository(DirectoryInfo directory, ILoggerFactory loggerFactory);
    [NullableContextAttribute("2")]
public static DirectoryInfo get_DefaultKeyStorageDirectory();
    [CompilerGeneratedAttribute]
public DirectoryInfo get_Directory();
    public virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository/<GetAllElementsCore>d__8")]
private IEnumerable`1<XElement> GetAllElementsCore();
    private static bool IsSafeFilename(string filename);
    private XElement ReadElementFromFile(string fullPath);
    public virtual void StoreElement(XElement element, string friendlyName);
    private void StoreElementCore(XElement element, string filename);
}
[NullableContextAttribute("2")]
internal interface Microsoft.AspNetCore.DataProtection.Repositories.IDefaultKeyStorageDirectories {
    public abstract virtual DirectoryInfo GetKeyStorageDirectory();
    public abstract virtual DirectoryInfo GetKeyStorageDirectoryForAzureWebSites();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository {
    public abstract virtual IReadOnlyCollection`1<XElement> GetAllElements();
    public abstract virtual void StoreElement(XElement element, string friendlyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository : object {
    private static Lazy`1<RegistryKey> _defaultRegistryKeyLazy;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private RegistryKey <RegistryKey>k__BackingField;
    [NullableAttribute("2")]
public static RegistryKey DefaultRegistryKey { get; }
    public RegistryKey RegistryKey { get; }
    public RegistryXmlRepository(RegistryKey registryKey, ILoggerFactory loggerFactory);
    private static RegistryXmlRepository();
    [NullableContextAttribute("2")]
public static RegistryKey get_DefaultRegistryKey();
    [CompilerGeneratedAttribute]
public RegistryKey get_RegistryKey();
    public virtual IReadOnlyCollection`1<XElement> GetAllElements();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository/<GetAllElementsCore>d__9")]
private IEnumerable`1<XElement> GetAllElementsCore();
    private static RegistryKey GetDefaultHklmStorageKey();
    private static bool IsSafeRegistryValueName(string filename);
    private XElement ReadElementFromRegKey(RegistryKey regKey, string valueName);
    public virtual void StoreElement(XElement element, string friendlyName);
    private void StoreElementCore(XElement element, string valueName);
}
internal static class Microsoft.AspNetCore.DataProtection.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string CryptCommon_GenericError { get; }
    internal static string Common_BufferIncorrectlySized { get; }
    internal static string CryptCommon_PayloadInvalid { get; }
    internal static string Common_PropertyCannotBeNullOrEmpty { get; }
    internal static string Common_DecryptionFailed { get; }
    internal static string Common_EncryptionFailed { get; }
    internal static string Common_KeyNotFound { get; }
    internal static string Common_KeyRevoked { get; }
    internal static string ProtectionProvider_BadMagicHeader { get; }
    internal static string ProtectionProvider_BadVersion { get; }
    internal static string Common_ValueMustBeNonNegative { get; }
    internal static string TypeExtensions_BadCast { get; }
    internal static string KeyManagementOptions_MinNewKeyLifetimeViolated { get; }
    internal static string XmlKeyManager_DuplicateKey { get; }
    internal static string Common_ArgumentCannotBeNullOrEmpty { get; }
    internal static string Common_PropertyMustBeNonNegative { get; }
    internal static string Platform_WindowsRequiredForGcm { get; }
    internal static string CertificateXmlEncryptor_CertificateNotFound { get; }
    internal static string EncryptedXmlDecryptor_DoesNotWorkOnCoreClr { get; }
    internal static string AlgorithmAssert_BadBlockSize { get; }
    internal static string AlgorithmAssert_BadDigestSize { get; }
    internal static string AlgorithmAssert_BadKeySize { get; }
    internal static string KeyRingProvider_NoDefaultKey_AutoGenerateDisabled { get; }
    internal static string LifetimeMustNotBeNegative { get; }
    internal static string FileSystem_EphemeralKeysLocationInContainer { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    private static string GetResourceString(string resourceKey, String[] formatterNames);
    internal static string get_CryptCommon_GenericError();
    internal static string get_Common_BufferIncorrectlySized();
    internal static string FormatCommon_BufferIncorrectlySized(object p0, object p1);
    internal static string get_CryptCommon_PayloadInvalid();
    internal static string get_Common_PropertyCannotBeNullOrEmpty();
    internal static string FormatCommon_PropertyCannotBeNullOrEmpty(object p0);
    internal static string get_Common_DecryptionFailed();
    internal static string get_Common_EncryptionFailed();
    internal static string get_Common_KeyNotFound();
    internal static string get_Common_KeyRevoked();
    internal static string get_ProtectionProvider_BadMagicHeader();
    internal static string get_ProtectionProvider_BadVersion();
    internal static string get_Common_ValueMustBeNonNegative();
    internal static string get_TypeExtensions_BadCast();
    internal static string FormatTypeExtensions_BadCast(object p0, object p1);
    internal static string get_KeyManagementOptions_MinNewKeyLifetimeViolated();
    internal static string get_XmlKeyManager_DuplicateKey();
    internal static string get_Common_ArgumentCannotBeNullOrEmpty();
    internal static string get_Common_PropertyMustBeNonNegative();
    internal static string FormatCommon_PropertyMustBeNonNegative(object p0);
    internal static string get_Platform_WindowsRequiredForGcm();
    internal static string get_CertificateXmlEncryptor_CertificateNotFound();
    internal static string FormatCertificateXmlEncryptor_CertificateNotFound(object p0);
    internal static string get_EncryptedXmlDecryptor_DoesNotWorkOnCoreClr();
    internal static string get_AlgorithmAssert_BadBlockSize();
    internal static string FormatAlgorithmAssert_BadBlockSize(object p0);
    internal static string get_AlgorithmAssert_BadDigestSize();
    internal static string FormatAlgorithmAssert_BadDigestSize(object p0);
    internal static string get_AlgorithmAssert_BadKeySize();
    internal static string FormatAlgorithmAssert_BadKeySize(object p0);
    internal static string get_KeyRingProvider_NoDefaultKey_AutoGenerateDisabled();
    internal static string get_LifetimeMustNotBeNegative();
    internal static string FormatLifetimeMustNotBeNegative(object p0);
    internal static string get_FileSystem_EphemeralKeysLocationInContainer();
    internal static string FormatFileSystem_EphemeralKeysLocationInContainer(object path);
}
public class Microsoft.AspNetCore.DataProtection.Secret : object {
    private static UInt32 CRYPTPROTECTMEMORY_BLOCK_SIZE;
    private SecureLocalAllocHandle _localAllocHandle;
    private UInt32 _plaintextLength;
    public int Length { get; }
    public Secret(ArraySegment`1<byte> value);
    [NullableContextAttribute("1")]
public Secret(Byte[] value);
    public Secret(Byte* secret, int secretLength);
    [NullableContextAttribute("1")]
public Secret(ISecret secret);
    public sealed virtual int get_Length();
    public sealed virtual void Dispose();
    private static SecureLocalAllocHandle Protect(ArraySegment`1<byte> plaintext);
    private static SecureLocalAllocHandle Protect(Byte* pbPlaintext, UInt32 cbPlaintext);
    [NullableContextAttribute("1")]
public static Secret Random(int numBytes);
    private void UnprotectInto(Byte* pbBuffer);
    public sealed virtual void WriteSecretIntoBuffer(ArraySegment`1<byte> buffer);
    public void WriteSecretIntoBuffer(Byte* buffer, int bufferLength);
}
internal class Microsoft.AspNetCore.DataProtection.SimpleActivator : object {
    private static Type[] _serviceProviderTypeArray;
    [NullableAttribute("1")]
internal static SimpleActivator DefaultWithoutServices;
    private IServiceProvider _services;
    [NullableContextAttribute("2")]
public SimpleActivator(IServiceProvider services);
    private static SimpleActivator();
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimmer", "IL2072")]
[UnconditionalSuppressMessageAttribute("Trimmer", "IL2075")]
public virtual object CreateInstance(Type expectedBaseType, string implementationTypeName);
}
internal interface Microsoft.AspNetCore.DataProtection.SP800_108.ISP800_108_CTR_HMACSHA512Provider {
    public abstract virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
}
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.ManagedSP800_108_CTR_HMACSHA512 : object {
    public static void DeriveKeys(Byte[] kdk, ArraySegment`1<byte> label, ArraySegment`1<byte> context, Func`2<Byte[], HashAlgorithm> prfFactory, ArraySegment`1<byte> output);
    public static void DeriveKeysWithContextHeader(Byte[] kdk, ArraySegment`1<byte> label, Byte[] contextHeader, ArraySegment`1<byte> context, Func`2<Byte[], HashAlgorithm> prfFactory, ArraySegment`1<byte> output);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.SP800_108_CTR_HMACSHA512Extensions : object {
    [ExtensionAttribute]
public static void DeriveKeyWithContextHeader(ISP800_108_CTR_HMACSHA512Provider provider, Byte* pbLabel, UInt32 cbLabel, Byte[] contextHeader, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
}
internal static class Microsoft.AspNetCore.DataProtection.SP800_108.SP800_108_CTR_HMACSHA512Util : object {
    [NullableContextAttribute("1")]
public static ISP800_108_CTR_HMACSHA512Provider CreateEmptyProvider();
    public static ISP800_108_CTR_HMACSHA512Provider CreateProvider(Byte* pbKdk, UInt32 cbKdk);
    [NullableContextAttribute("1")]
public static ISP800_108_CTR_HMACSHA512Provider CreateProvider(Secret kdk);
}
internal class Microsoft.AspNetCore.DataProtection.SP800_108.Win7SP800_108_CTR_HMACSHA512Provider : object {
    private BCryptHashHandle _hashHandle;
    public Win7SP800_108_CTR_HMACSHA512Provider(Byte* pbKdk, UInt32 cbKdk);
    public sealed virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
    public sealed virtual void Dispose();
}
internal class Microsoft.AspNetCore.DataProtection.SP800_108.Win8SP800_108_CTR_HMACSHA512Provider : object {
    private BCryptKeyHandle _keyHandle;
    public Win8SP800_108_CTR_HMACSHA512Provider(Byte* pbKdk, UInt32 cbKdk);
    public sealed virtual void DeriveKey(Byte* pbLabel, UInt32 cbLabel, Byte* pbContext, UInt32 cbContext, Byte* pbDerivedKey, UInt32 cbDerivedKey);
    public sealed virtual void Dispose();
    private static BCryptKeyHandle ImportKey(Byte* pbKdk, UInt32 cbKdk);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.TypeExtensions : object {
    [ExtensionAttribute]
public static void AssertIsAssignableFrom(Type expectedBaseType, Type implementationType);
    [UnconditionalSuppressMessageAttribute("Trimmer", "IL2057")]
public static Type GetTypeWithTrimFriendlyErrorMessage(string typeName);
    [ExtensionAttribute]
public static bool MatchName(Type matchType, string resolvedTypeName, ITypeNameResolver typeNameResolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.TypeForwardingActivator : SimpleActivator {
    private static string OldNamespace;
    private static string CurrentNamespace;
    private ILogger _logger;
    public TypeForwardingActivator(IServiceProvider services);
    public TypeForwardingActivator(IServiceProvider services, ILoggerFactory loggerFactory);
    public virtual object CreateInstance(Type expectedBaseType, string originalTypeName);
    [UnconditionalSuppressMessageAttribute("Trimmer", "IL2057")]
internal object CreateInstance(Type expectedBaseType, string originalTypeName, Boolean& forwarded);
    internal static bool TryForwardTypeName(string originalTypeName, String& forwardedTypeName);
    protected static string RemoveVersionFromAssemblyName(string forwardedTypeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.AspNetCore.DataProtection.XmlConstants : object {
    private static XNamespace RootNamespace;
    internal static XName DecryptorTypeAttributeName;
    internal static XName DeserializerTypeAttributeName;
    internal static XName EncryptedSecretElementName;
    internal static XName RequiresEncryptionAttributeName;
    private static XmlConstants();
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateResolver : object {
    [NullableContextAttribute("1")]
public virtual X509Certificate2 ResolveCertificate(string thumbprint);
    private static X509Certificate2 GetCertificateFromStore(StoreLocation location, string thumbprint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor : object {
    private Func`1<X509Certificate2> _certFactory;
    private IInternalCertificateXmlEncryptor _encryptor;
    private ILogger _logger;
    public CertificateXmlEncryptor(string thumbprint, ICertificateResolver certificateResolver, ILoggerFactory loggerFactory);
    public CertificateXmlEncryptor(X509Certificate2 certificate, ILoggerFactory loggerFactory);
    internal CertificateXmlEncryptor(ILoggerFactory loggerFactory, IInternalCertificateXmlEncryptor encryptor);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
    [UnconditionalSuppressMessageAttribute("AOT", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:RequiresDynamicCode")]
private XElement EncryptElement(XElement plaintextElement);
    private Func`1<X509Certificate2> CreateCertFactory(string thumbprint, ICertificateResolver resolver);
    private sealed virtual override EncryptedData Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalCertificateXmlEncryptor.PerformEncryption(EncryptedXml encryptedXml, XmlElement elementToEncrypt);
}
[FlagsAttribute]
public enum Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags : Enum {
    public int value__;
    public static DpapiNGProtectionDescriptorFlags None;
    public static DpapiNGProtectionDescriptorFlags NamedDescriptor;
    public static DpapiNGProtectionDescriptorFlags MachineKey;
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor : object {
    private ILogger _logger;
    [NullableContextAttribute("2")]
public DpapiNGXmlDecryptor(IServiceProvider services);
    [NullableContextAttribute("1")]
public sealed virtual XElement Decrypt(XElement encryptedElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor : object {
    private ILogger _logger;
    private NCryptDescriptorHandle _protectionDescriptorHandle;
    public DpapiNGXmlEncryptor(string protectionDescriptorRule, DpapiNGProtectionDescriptorFlags flags, ILoggerFactory loggerFactory);
    public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
    internal static string GetDefaultProtectionDescriptorString();
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor : object {
    private ILogger _logger;
    [NullableContextAttribute("2")]
public DpapiXmlDecryptor(IServiceProvider services);
    [NullableContextAttribute("1")]
public sealed virtual XElement Decrypt(XElement encryptedElement);
}
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor : object {
    private ILogger _logger;
    private bool _protectToLocalMachine;
    [NullableContextAttribute("1")]
public DpapiXmlEncryptor(bool protectToLocalMachine, ILoggerFactory loggerFactory);
    [NullableContextAttribute("1")]
public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor : object {
    private IInternalEncryptedXmlDecryptor _decryptor;
    private XmlKeyDecryptionOptions _options;
    [NullableContextAttribute("2")]
public EncryptedXmlDecryptor(IServiceProvider services);
    [NullableContextAttribute("1")]
[DynamicDependencyAttribute("1", "System.Security.Cryptography.RijndaelManaged")]
[UnconditionalSuppressMessageAttribute("AOT", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:RequiresDynamicCode")]
public sealed virtual XElement Decrypt(XElement encryptedElement);
    private sealed virtual override void Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalEncryptedXmlDecryptor.PerformPreDecryptionSetup(EncryptedXml encryptedXml);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo : object {
    [CompilerGeneratedAttribute]
private Type <DecryptorType>k__BackingField;
    [CompilerGeneratedAttribute]
private XElement <EncryptedElement>k__BackingField;
    public Type DecryptorType { get; }
    public XElement EncryptedElement { get; }
    public EncryptedXmlInfo(XElement encryptedElement, Type decryptorType);
    [CompilerGeneratedAttribute]
public Type get_DecryptorType();
    [CompilerGeneratedAttribute]
public XElement get_EncryptedElement();
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver {
    public abstract virtual X509Certificate2 ResolveCertificate(string thumbprint);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalCertificateXmlEncryptor {
    public abstract virtual EncryptedData PerformEncryption(EncryptedXml encryptedXml, XmlElement elementToEncrypt);
}
[NullableContextAttribute("1")]
internal interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IInternalEncryptedXmlDecryptor {
    public abstract virtual void PerformPreDecryptionSetup(EncryptedXml encryptedXml);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlDecryptor {
    public abstract virtual XElement Decrypt(XElement encryptedElement);
}
[NullableContextAttribute("1")]
public interface Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor {
    public abstract virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlDecryptor : object {
    [NullableContextAttribute("1")]
public sealed virtual XElement Decrypt(XElement encryptedElement);
}
public class Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor : object {
    private ILogger _logger;
    [NullableContextAttribute("2")]
public NullXmlEncryptor(IServiceProvider services);
    [NullableContextAttribute("1")]
public sealed virtual EncryptedXmlInfo Encrypt(XElement plaintextElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.XmlEncryption.XmlEncryptionExtensions : object {
    [ExtensionAttribute]
public static XElement DecryptElement(XElement element, IActivator activator);
    private static IXmlDecryptor CreateDecryptor(IActivator activator, string decryptorTypeName);
    [ExtensionAttribute]
public static XElement EncryptIfNecessary(IXmlEncryptor encryptor, XElement element);
    [ExtensionAttribute]
public static Secret ToSecret(XElement element);
    [ExtensionAttribute]
public static XElement ToXElement(Secret secret);
    private static bool DoesElementOrDescendentRequireDecryption(XElement element);
    private static bool DoesElementOrDescendentRequireEncryption(XElement element);
    private static bool DoesSingleElementRequireEncryption(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.AspNetCore.DataProtection.XmlEncryption.XmlKeyDecryptionOptions : object {
    private Dictionary`2<string, List`1<X509Certificate2>> _certs;
    public int KeyDecryptionCertificateCount { get; }
    public int get_KeyDecryptionCertificateCount();
    public bool TryGetKeyDecryptionCertificates(X509Certificate2 certInfo, IReadOnlyList`1& keyDecryptionCerts);
    public void AddKeyDecryptionCertificate(X509Certificate2 certificate);
    private static string GetKey(X509Certificate2 cert);
}
[ExtensionAttribute]
internal static class Microsoft.AspNetCore.DataProtection.XmlExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static XElement WithoutChildNodes(XElement element);
}
internal static class Microsoft.AspNetCore.Shared.ArgumentNullThrowHelper : object {
    [NullableContextAttribute("2")]
public static void ThrowIfNull(object argument, string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IDataProtectionBuilder AddDataProtection(IServiceCollection services);
    [ExtensionAttribute]
public static IDataProtectionBuilder AddDataProtection(IServiceCollection services, Action`1<DataProtectionOptions> setupAction);
    private static void AddDataProtectionServices(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Logging.LoggingExtensions : object {
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, DateTimeOffset, Exception> __UsingFallbackKeyWithExpirationAsDefaultKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __UsingKeyAsDefaultKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __OpeningCNGAlgorithmFromProviderWithHMACCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __OpeningCNGAlgorithmFromProviderWithChainingModeCBCCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, string, Exception> __PerformingUnprotectOperationToKeyWithPurposesCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyWasNotFoundInTheKeyRingUnprotectOperationCannotProceedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyWasRevokedCallerRequestedUnprotectOperationProceedRegardlessCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyWasRevokedUnprotectOperationCannotProceedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __OpeningCNGAlgorithmFromProviderWithChainingModeGCMCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingManagedKeyedHashAlgorithmCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingManagedSymmetricAlgorithmCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, string, Exception> __KeyIsIneligibleToBeTheDefaultKeyBecauseItsMethodFailedCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, DateTimeOffset, Exception> __ConsideringKeyWithExpirationDateAsDefaultKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyIsNoLongerUnderConsiderationAsDefaultCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, XName, Exception> __UnknownElementWithNameFoundInKeyringSkippingCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __MarkedKeyAsRevokedInTheKeyringCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __TriedToProcessRevocationOfKeyButNoSuchKeyWasFoundCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __FoundKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, DateTimeOffset, Exception> __FoundRevocationOfAllKeysCreatedPriorToCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __FoundRevocationOfKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, XElement, Exception> __ExceptionWhileProcessingRevocationElementCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, DateTimeOffset, string, Exception> __RevokingAllKeysAsOfForReasonCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __KeyCacheExpirationTokenTriggeredByOperationCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, XElement, Exception> __ExceptionWhileProcessingKeyElementCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, XElement, Exception> __AnExceptionOccurredWhileProcessingElementDebugCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __EncryptingToWindowsDPAPIForCurrentUserAccountCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __AnErrorOccurredWhileEncryptingToX509CertificateWithThumbprintCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __EncryptingToX509CertificateWithThumbprintCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __ExceptionWhileTryingToResolveCertificateWithThumbprintCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, string, Exception> __PerformingProtectOperationToKeyWithPurposesCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, Guid, string, Exception> __DescriptorDeserializerTypeForKeyIsCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyEscrowSinkFoundWritingKeyToEscrowCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __NoKeyEscrowSinkFoundNotWritingKeyToEscrowCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __NoXMLEncryptorConfiguredKeyMayBePersistedToStorageInUnencryptedFormCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`5<ILogger, Guid, DateTimeOffset, string, Exception> __RevokingKeyForReasonCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __ReadingDataFromFileCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __NameIsNotSafeFileNameCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __WritingDataToFileCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, RegistryKey, string, Exception> __ReadingDataFromRegistryKeyValueCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __NameIsNotSafeRegistryValueNameCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __DecryptingSecretElementUsingWindowsDPAPINGCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __EncryptingToWindowsDPAPINGUsingProtectionDescriptorRuleCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ExceptionOccurredTryingToDecryptElementCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __EncryptingUsingNullEncryptorCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __UsingEphemeralDataProtectionProviderCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ExistingCachedKeyRingIsExpiredCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ErrorOccurredWhileRefreshingKeyRingCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ErrorOccurredWhileReadingKeyRingCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __KeyRingDoesNotContainValidDefaultKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __UsingInmemoryRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __DecryptingSecretElementUsingWindowsDPAPICallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __DefaultKeyExpirationImminentAndRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __RepositoryContainsNoViableDefaultKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ErrorOccurredWhileEncryptingToWindowsDPAPICallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __EncryptingToWindowsDPAPIForLocalMachineAccountCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __ErrorOccurredWhileEncryptingToWindowsDPAPINGCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __PolicyResolutionStatesThatANewKeyShouldBeAddedToTheKeyRingCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`6<ILogger, Guid, DateTimeOffset, DateTimeOffset, DateTimeOffset, Exception> __CreatingKeyCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __UsingEphemeralKeyRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingRegistryAsKeyRepositoryWithDPAPICallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingProfileAsKeyRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingProfileAsKeyRepositoryWithDPAPICallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingAzureAsKeyRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, Guid, Exception> __KeyRingWasLoadedOnStartupCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __KeyRingFailedToLoadOnStartupCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingEphemeralFileSystemLocationInContainerCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`4<ILogger, string, string, Exception> __IgnoringReadOnlyConfigurationForNonDefaultOptionsCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`3<ILogger, string, Exception> __UsingReadOnlyKeyConfigurationCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __NotUsingReadOnlyKeyConfigurationBecauseOfRepositoryCallback;
    [GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
private static Action`2<ILogger, Exception> __NotUsingReadOnlyKeyConfigurationBecauseOfEncryptorCallback;
    private static LoggingExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDebugLevelEnabled(ILogger logger);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTraceLevelEnabled(ILogger logger);
    private static bool IsLogLevelEnabledCore(ILogger logger, LogLevel level);
    [ExtensionAttribute]
[LoggerMessageAttribute("1", "3", "Policy resolution states that a new key should be added to the key ring, but automatic generation of keys is disabled. Using fallback key {KeyId:B} with expiration {ExpirationDate:u} as default key.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingFallbackKeyWithExpirationAsDefaultKey(ILogger logger, Guid keyId, DateTimeOffset expirationDate);
    [ExtensionAttribute]
[LoggerMessageAttribute("2", "1", "Using key {KeyId:B} as the default key.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingKeyAsDefaultKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("3", "1", "Opening CNG algorithm '{HashAlgorithm}' from provider '{HashAlgorithmProvider}' with HMAC.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void OpeningCNGAlgorithmFromProviderWithHMAC(ILogger logger, string hashAlgorithm, string hashAlgorithmProvider);
    [ExtensionAttribute]
[LoggerMessageAttribute("4", "1", "Opening CNG algorithm '{EncryptionAlgorithm}' from provider '{EncryptionAlgorithmProvider}' with chaining mode CBC.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void OpeningCNGAlgorithmFromProviderWithChainingModeCBC(ILogger logger, string encryptionAlgorithm, string encryptionAlgorithmProvider);
    [ExtensionAttribute]
[LoggerMessageAttribute("5", "0", "Performing unprotect operation to key {KeyId:B} with purposes {Purposes}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void PerformingUnprotectOperationToKeyWithPurposes(ILogger logger, Guid keyId, string purposes);
    [ExtensionAttribute]
[LoggerMessageAttribute("6", "0", "Key {KeyId:B} was not found in the key ring. Unprotect operation cannot proceed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyWasNotFoundInTheKeyRingUnprotectOperationCannotProceed(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("7", "1", "Key {KeyId:B} was revoked. Caller requested unprotect operation proceed regardless.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyWasRevokedCallerRequestedUnprotectOperationProceedRegardless(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("8", "1", "Key {KeyId:B} was revoked. Unprotect operation cannot proceed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyWasRevokedUnprotectOperationCannotProceed(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("9", "1", "Opening CNG algorithm '{EncryptionAlgorithm}' from provider '{EncryptionAlgorithmProvider}' with chaining mode GCM.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void OpeningCNGAlgorithmFromProviderWithChainingModeGCM(ILogger logger, string encryptionAlgorithm, string encryptionAlgorithmProvider);
    [ExtensionAttribute]
[LoggerMessageAttribute("10", "1", "Using managed keyed hash algorithm '{FullName}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingManagedKeyedHashAlgorithm(ILogger logger, string fullName);
    [ExtensionAttribute]
[LoggerMessageAttribute("11", "1", "Using managed symmetric algorithm '{FullName}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingManagedSymmetricAlgorithm(ILogger logger, string fullName);
    [ExtensionAttribute]
[LoggerMessageAttribute("12", "3", "Key {KeyId:B} is ineligible to be the default key because its {MethodName} method failed.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyIsIneligibleToBeTheDefaultKeyBecauseItsMethodFailed(ILogger logger, Guid keyId, string methodName, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("13", "1", "Considering key {KeyId:B} with expiration date {ExpirationDate:u} as default key.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ConsideringKeyWithExpirationDateAsDefaultKey(ILogger logger, Guid keyId, DateTimeOffset expirationDate);
    [ExtensionAttribute]
[LoggerMessageAttribute("14", "1", "Key {KeyId:B} is no longer under consideration as default key because it is expired, revoked, or cannot be deciphered.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyIsNoLongerUnderConsiderationAsDefault(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("15", "3", "Unknown element with name '{Name}' found in keyring, skipping.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UnknownElementWithNameFoundInKeyringSkipping(ILogger logger, XName name);
    [ExtensionAttribute]
[LoggerMessageAttribute("16", "1", "Marked key {KeyId:B} as revoked in the keyring.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void MarkedKeyAsRevokedInTheKeyring(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("17", "3", "Tried to process revocation of key {KeyId:B}, but no such key was found in keyring. Skipping.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void TriedToProcessRevocationOfKeyButNoSuchKeyWasFound(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("18", "1", "Found key {KeyId:B}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FoundKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("19", "1", "Found revocation of all keys created prior to {RevocationDate:u}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FoundRevocationOfAllKeysCreatedPriorTo(ILogger logger, DateTimeOffset revocationDate);
    [ExtensionAttribute]
[LoggerMessageAttribute("20", "1", "Found revocation of key {KeyId:B}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void FoundRevocationOfKey(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("21", "4", "An exception occurred while processing the revocation element '{RevocationElement}'. Cannot continue keyring processing.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ExceptionWhileProcessingRevocationElement(ILogger logger, XElement revocationElement, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("22", "2", "Revoking all keys as of {RevocationDate:u} for reason '{Reason}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RevokingAllKeysAsOfForReason(ILogger logger, DateTimeOffset revocationDate, string reason);
    [ExtensionAttribute]
[LoggerMessageAttribute("23", "1", "Key cache expiration token triggered by '{OperationName}' operation.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyCacheExpirationTokenTriggeredByOperation(ILogger logger, string operationName);
    [ExtensionAttribute]
[LoggerMessageAttribute("24", "4", "An exception occurred while processing the key element '{Element}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ExceptionWhileProcessingKeyElement(ILogger logger, XElement element, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("25", "0", "An exception occurred while processing the key element '{Element}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void AnExceptionOccurredWhileProcessingElementDebug(ILogger logger, XElement element, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("26", "1", "Encrypting to Windows DPAPI for current user account ({Name}).")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EncryptingToWindowsDPAPIForCurrentUserAccount(ILogger logger, string name);
    [ExtensionAttribute]
[LoggerMessageAttribute("28", "4", "An error occurred while encrypting to X.509 certificate with thumbprint '{Thumbprint}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void AnErrorOccurredWhileEncryptingToX509CertificateWithThumbprint(ILogger logger, string thumbprint, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("29", "1", "Encrypting to X.509 certificate with thumbprint '{Thumbprint}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EncryptingToX509CertificateWithThumbprint(ILogger logger, string thumbprint);
    [ExtensionAttribute]
[LoggerMessageAttribute("30", "4", "An exception occurred while trying to resolve certificate with thumbprint '{Thumbprint}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ExceptionWhileTryingToResolveCertificateWithThumbprint(ILogger logger, string thumbprint, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("31", "0", "Performing protect operation to key {KeyId:B} with purposes {Purposes}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void PerformingProtectOperationToKeyWithPurposes(ILogger logger, Guid keyId, string purposes);
    [ExtensionAttribute]
[LoggerMessageAttribute("32", "1", "Descriptor deserializer type for key {KeyId:B} is '{AssemblyQualifiedName}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DescriptorDeserializerTypeForKeyIs(ILogger logger, Guid keyId, string assemblyQualifiedName);
    [ExtensionAttribute]
[LoggerMessageAttribute("33", "1", "Key escrow sink found. Writing key {KeyId:B} to escrow.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyEscrowSinkFoundWritingKeyToEscrow(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("34", "1", "No key escrow sink found. Not writing key {KeyId:B} to escrow.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NoKeyEscrowSinkFoundNotWritingKeyToEscrow(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("35", "3", "No XML encryptor configured. Key {KeyId:B} may be persisted to storage in unencrypted form.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NoXMLEncryptorConfiguredKeyMayBePersistedToStorageInUnencryptedForm(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("36", "2", "Revoking key {KeyId:B} at {RevocationDate:u} for reason '{Reason}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RevokingKeyForReason(ILogger logger, Guid keyId, DateTimeOffset revocationDate, string reason);
    [ExtensionAttribute]
[LoggerMessageAttribute("37", "1", "Reading data from file '{FullPath}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ReadingDataFromFile(ILogger logger, string fullPath);
    [ExtensionAttribute]
[LoggerMessageAttribute("38", "1", "The name '{FriendlyName}' is not a safe file name, using '{NewFriendlyName}' instead.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NameIsNotSafeFileName(ILogger logger, string friendlyName, string newFriendlyName);
    [ExtensionAttribute]
[LoggerMessageAttribute("39", "2", "Writing data to file '{FileName}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void WritingDataToFile(ILogger logger, string fileName);
    [ExtensionAttribute]
[LoggerMessageAttribute("40", "1", "Reading data from registry key '{RegistryKeyName}', value '{Value}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ReadingDataFromRegistryKeyValue(ILogger logger, RegistryKey registryKeyName, string value);
    [ExtensionAttribute]
[LoggerMessageAttribute("41", "1", "The name '{FriendlyName}' is not a safe registry value name, using '{NewFriendlyName}' instead.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NameIsNotSafeRegistryValueName(ILogger logger, string friendlyName, string newFriendlyName);
    [ExtensionAttribute]
[LoggerMessageAttribute("42", "1", "Decrypting secret element using Windows DPAPI-NG with protection descriptor rule '{DescriptorRule}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DecryptingSecretElementUsingWindowsDPAPING(ILogger logger, string descriptorRule);
    [ExtensionAttribute]
[LoggerMessageAttribute("27", "1", "Encrypting to Windows DPAPI-NG using protection descriptor rule '{DescriptorRule}'.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EncryptingToWindowsDPAPINGUsingProtectionDescriptorRule(ILogger logger, string descriptorRule);
    [ExtensionAttribute]
[LoggerMessageAttribute("43", "4", "An exception occurred while trying to decrypt the element.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ExceptionOccurredTryingToDecryptElement(ILogger logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("44", "3", "Encrypting using a null encryptor; secret information isn't being protected.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EncryptingUsingNullEncryptor(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("45", "2", "Using ephemeral data protection provider. Payloads will be undecipherable upon application shutdown.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingEphemeralDataProtectionProvider(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("46", "1", "Existing cached key ring is expired. Refreshing.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ExistingCachedKeyRingIsExpired(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("47", "4", "An error occurred while refreshing the key ring. Will try again in 2 minutes.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ErrorOccurredWhileRefreshingKeyRing(ILogger logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("48", "4", "An error occurred while reading the key ring.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ErrorOccurredWhileReadingKeyRing(ILogger logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("49", "4", "The key ring does not contain a valid default protection key. The data protection system cannot create a new key because auto-generation of keys is disabled. For more information go to http://aka.ms/dataprotectionwarning")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyRingDoesNotContainValidDefaultKey(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("50", "3", "Using an in-memory repository. Keys will not be persisted to storage.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingInmemoryRepository(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("51", "1", "Decrypting secret element using Windows DPAPI.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DecryptingSecretElementUsingWindowsDPAPI(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("52", "1", "Default key expiration imminent and repository contains no viable successor. Caller should generate a successor.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void DefaultKeyExpirationImminentAndRepository(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("53", "1", "Repository contains no viable default key. Caller should generate a key with immediate activation.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void RepositoryContainsNoViableDefaultKey(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("54", "4", "An error occurred while encrypting to Windows DPAPI.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ErrorOccurredWhileEncryptingToWindowsDPAPI(ILogger logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("55", "1", "Encrypting to Windows DPAPI for local machine account.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void EncryptingToWindowsDPAPIForLocalMachineAccount(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("56", "4", "An error occurred while encrypting to Windows DPAPI-NG.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void ErrorOccurredWhileEncryptingToWindowsDPAPING(ILogger logger, Exception exception);
    [ExtensionAttribute]
[LoggerMessageAttribute("57", "1", "Policy resolution states that a new key should be added to the key ring.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void PolicyResolutionStatesThatANewKeyShouldBeAddedToTheKeyRing(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("58", "2", "Creating key {KeyId:B} with creation date {CreationDate:u}, activation date {ActivationDate:u}, and expiration date {ExpirationDate:u}.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void CreatingKey(ILogger logger, Guid keyId, DateTimeOffset creationDate, DateTimeOffset activationDate, DateTimeOffset expirationDate);
    [ExtensionAttribute]
[LoggerMessageAttribute("59", "3", "Neither user profile nor HKLM registry available. Using an ephemeral key repository. Protected data will be unavailable when application exits.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingEphemeralKeyRepository(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("61", "2", "User profile not available. Using '{Name}' as key repository and Windows DPAPI to encrypt keys at rest.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingRegistryAsKeyRepositoryWithDPAPI(ILogger logger, string name);
    [ExtensionAttribute]
[LoggerMessageAttribute("62", "2", "User profile is available. Using '{FullName}' as key repository; keys will not be encrypted at rest.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingProfileAsKeyRepository(ILogger logger, string fullName);
    [ExtensionAttribute]
[LoggerMessageAttribute("63", "2", "User profile is available. Using '{FullName}' as key repository and Windows DPAPI to encrypt keys at rest.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingProfileAsKeyRepositoryWithDPAPI(ILogger logger, string fullName);
    [ExtensionAttribute]
[LoggerMessageAttribute("64", "2", "Azure Web Sites environment detected. Using '{FullName}' as key repository; keys will not be encrypted at rest.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingAzureAsKeyRepository(ILogger logger, string fullName);
    [ExtensionAttribute]
[LoggerMessageAttribute("65", "1", "Key ring with default key {KeyId:B} was loaded during application startup.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyRingWasLoadedOnStartup(ILogger logger, Guid keyId);
    [ExtensionAttribute]
[LoggerMessageAttribute("66", "2", "Key ring failed to load during application startup.")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void KeyRingFailedToLoadOnStartup(ILogger logger, Exception innerException);
    [ExtensionAttribute]
[LoggerMessageAttribute("60", "3", "Storing keys in a directory '{path}' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingEphemeralFileSystemLocationInContainer(ILogger logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("61", "0", "Ignoring configuration '{PropertyName}' for options instance '{OptionsName}'")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void IgnoringReadOnlyConfigurationForNonDefaultOptions(ILogger logger, string propertyName, string optionsName);
    [ExtensionAttribute]
[LoggerMessageAttribute("62", "2", "Enabling read-only key access with repository directory '{Path}'")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void UsingReadOnlyKeyConfiguration(ILogger logger, string path);
    [ExtensionAttribute]
[LoggerMessageAttribute("63", "1", "Not enabling read-only key access because an XML repository has been specified")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NotUsingReadOnlyKeyConfigurationBecauseOfRepository(ILogger logger);
    [ExtensionAttribute]
[LoggerMessageAttribute("64", "1", "Not enabling read-only key access because an XML encryptor has been specified")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.10.36612")]
public static void NotUsingReadOnlyKeyConfigurationBecauseOfEncryptor(ILogger logger);
}
[ExtensionAttribute]
internal static class System.LoggingServiceProviderExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ILogger GetLogger(IServiceProvider services);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ILogger GetLogger(IServiceProvider services, Type type);
}
