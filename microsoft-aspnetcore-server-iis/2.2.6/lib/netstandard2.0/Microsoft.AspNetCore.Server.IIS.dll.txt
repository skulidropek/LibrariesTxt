public class Microsoft.AspNetCore.Builder.IISServerOptions : object {
    [CompilerGeneratedAttribute]
private bool <AutomaticAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForwardWindowsAuthentication>k__BackingField;
    public bool AutomaticAuthentication { get; public set; }
    public string AuthenticationDisplayName { get; public set; }
    internal bool ForwardWindowsAuthentication { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_AutomaticAuthentication();
    [CompilerGeneratedAttribute]
public void set_AutomaticAuthentication(bool value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationDisplayName();
    [CompilerGeneratedAttribute]
public void set_AuthenticationDisplayName(string value);
    [CompilerGeneratedAttribute]
internal bool get_ForwardWindowsAuthentication();
    [CompilerGeneratedAttribute]
internal void set_ForwardWindowsAuthentication(bool value);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Hosting.WebHostBuilderIISExtensions : object {
    [ExtensionAttribute]
public static IWebHostBuilder UseIIS(IWebHostBuilder hostBuilder);
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.AspNetCore.Http.Features.IServerVariablesFeature {
    public string Item { get; public set; }
    public abstract virtual string get_Item(string variableName);
    public abstract virtual void set_Item(string variableName, string value);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.Constants : object {
    internal static string HttpScheme;
    internal static string HttpsScheme;
    internal static string Chunked;
    internal static string Close;
    internal static string Zero;
    internal static string SchemeDelimiter;
    internal static string DefaultServerAddress;
    internal static Version V1_0;
    internal static Version V1_1;
    internal static Version V2;
    private static Constants();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.CookedUrl : object {
    private HTTP_COOKED_URL _nativeCookedUrl;
    internal CookedUrl(HTTP_COOKED_URL nativeCookedUrl);
    internal string GetFullUrl();
    internal string GetHost();
    internal string GetAbsPath();
    internal string GetQueryString();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.HttpSys.Internal.HeaderCollection : object {
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private IDictionary`2<string, StringValues> Store { get; private set; }
    public bool IsReadOnly { get; internal set; }
    public StringValues Item { get; public set; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<StringValues> Values { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public HeaderCollection(IDictionary`2<string, StringValues> store);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, StringValues> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    public sealed virtual StringValues get_Item(string key);
    public sealed virtual void set_Item(string key, StringValues value);
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<StringValues> get_Values();
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual void set_ContentLength(Nullable`1<long> value);
    public sealed virtual void Add(KeyValuePair`2<string, StringValues> item);
    public sealed virtual void Add(string key, StringValues value);
    public void Append(string key, string value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, StringValues>> GetEnumerator();
    public IEnumerable`1<string> GetValues(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, StringValues> item);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    public static void ValidateHeaderCharacters(StringValues headerValues);
    public static void ValidateHeaderCharacters(string headerCharacters);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderEncoding : object {
    private static Encoding Encoding;
    private static HeaderEncoding();
    internal static string GetString(Byte* pBytes, int byteCount);
    internal static Byte[] GetBytes(string myString);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HeaderParser : object {
    internal static IEnumerable`1<string> Empty;
    private static HeaderParser();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.HeaderParser/<SplitValues>d__1")]
internal static IEnumerable`1<string> SplitValues(StringValues values);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.HeapAllocHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static IntPtr ProcessHeap;
    private static HeapAllocHandle();
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HttpApiTypes : object {
    internal static int MaxTimeout;
    internal static String[] HttpVerbs;
    private static HttpApiTypes();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.HttpKnownHeaderNames : object {
    internal static string CacheControl;
    internal static string Connection;
    internal static string Date;
    internal static string KeepAlive;
    internal static string Pragma;
    internal static string ProxyConnection;
    internal static string Trailer;
    internal static string TransferEncoding;
    internal static string Upgrade;
    internal static string Via;
    internal static string Warning;
    internal static string ContentLength;
    internal static string ContentType;
    internal static string ContentDisposition;
    internal static string ContentEncoding;
    internal static string ContentLanguage;
    internal static string ContentLocation;
    internal static string ContentRange;
    internal static string Expires;
    internal static string LastModified;
    internal static string Age;
    internal static string Location;
    internal static string ProxyAuthenticate;
    internal static string RetryAfter;
    internal static string Server;
    internal static string SetCookie;
    internal static string SetCookie2;
    internal static string Vary;
    internal static string WWWAuthenticate;
    internal static string Accept;
    internal static string AcceptCharset;
    internal static string AcceptEncoding;
    internal static string AcceptLanguage;
    internal static string Authorization;
    internal static string Cookie;
    internal static string Cookie2;
    internal static string Expect;
    internal static string From;
    internal static string Host;
    internal static string IfMatch;
    internal static string IfModifiedSince;
    internal static string IfNoneMatch;
    internal static string IfRange;
    internal static string IfUnmodifiedSince;
    internal static string MaxForwards;
    internal static string ProxyAuthorization;
    internal static string Referer;
    internal static string Range;
    internal static string UserAgent;
    internal static string ContentMD5;
    internal static string ETag;
    internal static string TE;
    internal static string Allow;
    internal static string AcceptRanges;
    internal static string P3P;
    internal static string XPoweredBy;
    internal static string XAspNetVersion;
    internal static string SecWebSocketKey;
    internal static string SecWebSocketExtensions;
    internal static string SecWebSocketAccept;
    internal static string Origin;
    internal static string SecWebSocketProtocol;
    internal static string SecWebSocketVersion;
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysRequestHeader : Enum {
    public int value__;
    public static HttpSysRequestHeader CacheControl;
    public static HttpSysRequestHeader Connection;
    public static HttpSysRequestHeader Date;
    public static HttpSysRequestHeader KeepAlive;
    public static HttpSysRequestHeader Pragma;
    public static HttpSysRequestHeader Trailer;
    public static HttpSysRequestHeader TransferEncoding;
    public static HttpSysRequestHeader Upgrade;
    public static HttpSysRequestHeader Via;
    public static HttpSysRequestHeader Warning;
    public static HttpSysRequestHeader Allow;
    public static HttpSysRequestHeader ContentLength;
    public static HttpSysRequestHeader ContentType;
    public static HttpSysRequestHeader ContentEncoding;
    public static HttpSysRequestHeader ContentLanguage;
    public static HttpSysRequestHeader ContentLocation;
    public static HttpSysRequestHeader ContentMd5;
    public static HttpSysRequestHeader ContentRange;
    public static HttpSysRequestHeader Expires;
    public static HttpSysRequestHeader LastModified;
    public static HttpSysRequestHeader Accept;
    public static HttpSysRequestHeader AcceptCharset;
    public static HttpSysRequestHeader AcceptEncoding;
    public static HttpSysRequestHeader AcceptLanguage;
    public static HttpSysRequestHeader Authorization;
    public static HttpSysRequestHeader Cookie;
    public static HttpSysRequestHeader Expect;
    public static HttpSysRequestHeader From;
    public static HttpSysRequestHeader Host;
    public static HttpSysRequestHeader IfMatch;
    public static HttpSysRequestHeader IfModifiedSince;
    public static HttpSysRequestHeader IfNoneMatch;
    public static HttpSysRequestHeader IfRange;
    public static HttpSysRequestHeader IfUnmodifiedSince;
    public static HttpSysRequestHeader MaxForwards;
    public static HttpSysRequestHeader ProxyAuthorization;
    public static HttpSysRequestHeader Referer;
    public static HttpSysRequestHeader Range;
    public static HttpSysRequestHeader Te;
    public static HttpSysRequestHeader Translate;
    public static HttpSysRequestHeader UserAgent;
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.HttpSysResponseHeader : Enum {
    public int value__;
    public static HttpSysResponseHeader CacheControl;
    public static HttpSysResponseHeader Connection;
    public static HttpSysResponseHeader Date;
    public static HttpSysResponseHeader KeepAlive;
    public static HttpSysResponseHeader Pragma;
    public static HttpSysResponseHeader Trailer;
    public static HttpSysResponseHeader TransferEncoding;
    public static HttpSysResponseHeader Upgrade;
    public static HttpSysResponseHeader Via;
    public static HttpSysResponseHeader Warning;
    public static HttpSysResponseHeader Allow;
    public static HttpSysResponseHeader ContentLength;
    public static HttpSysResponseHeader ContentType;
    public static HttpSysResponseHeader ContentEncoding;
    public static HttpSysResponseHeader ContentLanguage;
    public static HttpSysResponseHeader ContentLocation;
    public static HttpSysResponseHeader ContentMd5;
    public static HttpSysResponseHeader ContentRange;
    public static HttpSysResponseHeader Expires;
    public static HttpSysResponseHeader LastModified;
    public static HttpSysResponseHeader AcceptRanges;
    public static HttpSysResponseHeader Age;
    public static HttpSysResponseHeader ETag;
    public static HttpSysResponseHeader Location;
    public static HttpSysResponseHeader ProxyAuthenticate;
    public static HttpSysResponseHeader RetryAfter;
    public static HttpSysResponseHeader Server;
    public static HttpSysResponseHeader SetCookie;
    public static HttpSysResponseHeader Vary;
    public static HttpSysResponseHeader WwwAuthenticate;
}
internal class Microsoft.AspNetCore.HttpSys.Internal.NativeRequestContext : object {
    private static int AlignmentPadding;
    private IntPtr _originalBufferAddress;
    private HTTP_REQUEST* _nativeRequest;
    private Byte[] _backingBuffer;
    private int _bufferAlignment;
    private SafeNativeOverlapped _nativeOverlapped;
    private bool _permanentlyPinned;
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal HTTP_REQUEST* NativeRequest { get; }
    internal HTTP_REQUEST_V2* NativeRequestV2 { get; }
    internal ulong RequestId { get; internal set; }
    internal ulong ConnectionId { get; }
    internal HTTP_VERB VerbId { get; }
    internal ulong UrlContext { get; }
    internal ushort UnknownHeaderCount { get; }
    internal SslStatus SslStatus { get; }
    internal bool IsHttp2 { get; }
    internal UInt32 Size { get; }
    internal NativeRequestContext(SafeNativeOverlapped nativeOverlapped, int bufferAlignment, HTTP_REQUEST* nativeRequest, Byte[] backingBuffer, ulong requestId);
    internal NativeRequestContext(HTTP_REQUEST* request);
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal HTTP_REQUEST* get_NativeRequest();
    internal HTTP_REQUEST_V2* get_NativeRequestV2();
    internal ulong get_RequestId();
    internal void set_RequestId(ulong value);
    internal ulong get_ConnectionId();
    internal HTTP_VERB get_VerbId();
    internal ulong get_UrlContext();
    internal ushort get_UnknownHeaderCount();
    internal SslStatus get_SslStatus();
    internal bool get_IsHttp2();
    internal UInt32 get_Size();
    internal void ReleasePins();
    public virtual void Dispose();
    internal string GetVerb();
    internal string GetRawUrl();
    internal Byte[] GetRawUrlInBytes();
    internal CookedUrl GetCookedUrl();
    internal Version GetVersion();
    internal bool CheckAuthenticated();
    internal WindowsPrincipal GetUser();
    private static string GetAuthTypeFromRequest(HTTP_REQUEST_AUTH_TYPE input);
    internal string GetKnownHeader(HttpSysRequestHeader header);
    private string GetKnowHeaderHelper(HttpSysRequestHeader header, long fixup, HTTP_REQUEST* request);
    internal void GetUnknownHeaders(IDictionary`2<string, StringValues> unknownHeaders);
    private void GetUnknownHeadersHelper(IDictionary`2<string, StringValues> unknownHeaders, long fixup, HTTP_REQUEST* request);
    internal SocketAddress GetRemoteEndPoint();
    internal SocketAddress GetLocalEndPoint();
    private SocketAddress GetEndPoint(bool localEndpoint);
    private SocketAddress GetEndPointHelper(bool localEndpoint, HTTP_REQUEST* request, Byte* pMemoryBlob);
    private static SocketAddress CopyOutAddress(IntPtr address);
    internal UInt32 GetChunks(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size);
    private UInt32 GetChunksHelper(Int32& dataChunkIndex, UInt32& dataChunkOffset, Byte[] buffer, int offset, int size, long fixup, HTTP_REQUEST* request);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.NclUtilities : object {
    internal static bool HasShutdownStarted { get; }
    internal static bool get_HasShutdownStarted();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.PathNormalizer : object {
    private static byte ByteSlash;
    private static byte ByteDot;
    public static int RemoveDotSegments(Span`1<byte> input);
    public static int RemoveDotSegments(Byte* start, Byte* end);
    public static bool ContainsDotSegments(Byte* start, Byte* end);
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RawUrlHelper : object {
    private static Byte[] _forwardSlashPath;
    private static RawUrlHelper();
    public static ArraySegment`1<byte> GetPath(Byte[] raw);
    private static int FindHttpOrHttps(Byte[] raw);
    private static int Find(Byte[] raw, int begin, char target);
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("TextTemplatingFileGenerator", "")]
internal class Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders : object {
    private IDictionary`2<string, StringValues> _extra;
    private NativeRequestContext _requestMemoryBlob;
    private Nullable`1<long> _contentLength;
    private StringValues _contentLengthText;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private UInt32 _flag0;
    private UInt32 _flag1;
    private StringValues _Accept;
    private StringValues _AcceptCharset;
    private StringValues _AcceptEncoding;
    private StringValues _AcceptLanguage;
    private StringValues _Allow;
    private StringValues _Authorization;
    private StringValues _CacheControl;
    private StringValues _Connection;
    private StringValues _ContentEncoding;
    private StringValues _ContentLanguage;
    private StringValues _ContentLength;
    private StringValues _ContentLocation;
    private StringValues _ContentMd5;
    private StringValues _ContentRange;
    private StringValues _ContentType;
    private StringValues _Cookie;
    private StringValues _Date;
    private StringValues _Expect;
    private StringValues _Expires;
    private StringValues _From;
    private StringValues _Host;
    private StringValues _IfMatch;
    private StringValues _IfModifiedSince;
    private StringValues _IfNoneMatch;
    private StringValues _IfRange;
    private StringValues _IfUnmodifiedSince;
    private StringValues _KeepAlive;
    private StringValues _LastModified;
    private StringValues _MaxForwards;
    private StringValues _Pragma;
    private StringValues _ProxyAuthorization;
    private StringValues _Range;
    private StringValues _Referer;
    private StringValues _Te;
    private StringValues _Trailer;
    private StringValues _TransferEncoding;
    private StringValues _Translate;
    private StringValues _Upgrade;
    private StringValues _UserAgent;
    private StringValues _Via;
    private StringValues _Warning;
    public bool IsReadOnly { get; internal set; }
    private IDictionary`2<string, StringValues> Extra { get; }
    private StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Item { get; private set; }
    public ICollection`1<string> Keys { get; }
    private ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.IsReadOnly { get; }
    private Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.ContentLength { get; private set; }
    public StringValues Item { get; public set; }
    private StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.Item { get; private set; }
    internal StringValues Accept { get; internal set; }
    internal StringValues AcceptCharset { get; internal set; }
    internal StringValues AcceptEncoding { get; internal set; }
    internal StringValues AcceptLanguage { get; internal set; }
    internal StringValues Allow { get; internal set; }
    internal StringValues Authorization { get; internal set; }
    internal StringValues CacheControl { get; internal set; }
    internal StringValues Connection { get; internal set; }
    internal StringValues ContentEncoding { get; internal set; }
    internal StringValues ContentLanguage { get; internal set; }
    internal StringValues ContentLength { get; internal set; }
    internal StringValues ContentLocation { get; internal set; }
    internal StringValues ContentMd5 { get; internal set; }
    internal StringValues ContentRange { get; internal set; }
    internal StringValues ContentType { get; internal set; }
    internal StringValues Cookie { get; internal set; }
    internal StringValues Date { get; internal set; }
    internal StringValues Expect { get; internal set; }
    internal StringValues Expires { get; internal set; }
    internal StringValues From { get; internal set; }
    internal StringValues Host { get; internal set; }
    internal StringValues IfMatch { get; internal set; }
    internal StringValues IfModifiedSince { get; internal set; }
    internal StringValues IfNoneMatch { get; internal set; }
    internal StringValues IfRange { get; internal set; }
    internal StringValues IfUnmodifiedSince { get; internal set; }
    internal StringValues KeepAlive { get; internal set; }
    internal StringValues LastModified { get; internal set; }
    internal StringValues MaxForwards { get; internal set; }
    internal StringValues Pragma { get; internal set; }
    internal StringValues ProxyAuthorization { get; internal set; }
    internal StringValues Range { get; internal set; }
    internal StringValues Referer { get; internal set; }
    internal StringValues Te { get; internal set; }
    internal StringValues Trailer { get; internal set; }
    internal StringValues TransferEncoding { get; internal set; }
    internal StringValues Translate { get; internal set; }
    internal StringValues Upgrade { get; internal set; }
    internal StringValues UserAgent { get; internal set; }
    internal StringValues Via { get; internal set; }
    internal StringValues Warning { get; internal set; }
    internal RequestHeaders(NativeRequestContext requestMemoryBlob);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    private IDictionary`2<string, StringValues> get_Extra();
    private sealed virtual override StringValues System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.set_Item(string key, StringValues value);
    private string GetKnownHeader(HttpSysRequestHeader header);
    private void GetUnknownHeaders(IDictionary`2<string, StringValues> extra);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.Add(string key, StringValues value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection`1<StringValues> System.Collections.Generic.IDictionary<System.String,Microsoft.Extensions.Primitives.StringValues>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, StringValues& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Add(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Contains(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.get_IsReadOnly();
    private sealed virtual override Nullable`1<long> Microsoft.AspNetCore.Http.IHeaderDictionary.get_ContentLength();
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_ContentLength(Nullable`1<long> value);
    public StringValues get_Item(string key);
    public void set_Item(string key, StringValues value);
    private sealed virtual override StringValues Microsoft.AspNetCore.Http.IHeaderDictionary.get_Item(string key);
    private sealed virtual override void Microsoft.AspNetCore.Http.IHeaderDictionary.set_Item(string key, StringValues value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.Remove(KeyValuePair`2<string, StringValues> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, StringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Extensions.Primitives.StringValues>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfReadOnly();
    public IEnumerable`1<string> GetValues(string key);
    internal StringValues get_Accept();
    internal void set_Accept(StringValues value);
    internal StringValues get_AcceptCharset();
    internal void set_AcceptCharset(StringValues value);
    internal StringValues get_AcceptEncoding();
    internal void set_AcceptEncoding(StringValues value);
    internal StringValues get_AcceptLanguage();
    internal void set_AcceptLanguage(StringValues value);
    internal StringValues get_Allow();
    internal void set_Allow(StringValues value);
    internal StringValues get_Authorization();
    internal void set_Authorization(StringValues value);
    internal StringValues get_CacheControl();
    internal void set_CacheControl(StringValues value);
    internal StringValues get_Connection();
    internal void set_Connection(StringValues value);
    internal StringValues get_ContentEncoding();
    internal void set_ContentEncoding(StringValues value);
    internal StringValues get_ContentLanguage();
    internal void set_ContentLanguage(StringValues value);
    internal StringValues get_ContentLength();
    internal void set_ContentLength(StringValues value);
    internal StringValues get_ContentLocation();
    internal void set_ContentLocation(StringValues value);
    internal StringValues get_ContentMd5();
    internal void set_ContentMd5(StringValues value);
    internal StringValues get_ContentRange();
    internal void set_ContentRange(StringValues value);
    internal StringValues get_ContentType();
    internal void set_ContentType(StringValues value);
    internal StringValues get_Cookie();
    internal void set_Cookie(StringValues value);
    internal StringValues get_Date();
    internal void set_Date(StringValues value);
    internal StringValues get_Expect();
    internal void set_Expect(StringValues value);
    internal StringValues get_Expires();
    internal void set_Expires(StringValues value);
    internal StringValues get_From();
    internal void set_From(StringValues value);
    internal StringValues get_Host();
    internal void set_Host(StringValues value);
    internal StringValues get_IfMatch();
    internal void set_IfMatch(StringValues value);
    internal StringValues get_IfModifiedSince();
    internal void set_IfModifiedSince(StringValues value);
    internal StringValues get_IfNoneMatch();
    internal void set_IfNoneMatch(StringValues value);
    internal StringValues get_IfRange();
    internal void set_IfRange(StringValues value);
    internal StringValues get_IfUnmodifiedSince();
    internal void set_IfUnmodifiedSince(StringValues value);
    internal StringValues get_KeepAlive();
    internal void set_KeepAlive(StringValues value);
    internal StringValues get_LastModified();
    internal void set_LastModified(StringValues value);
    internal StringValues get_MaxForwards();
    internal void set_MaxForwards(StringValues value);
    internal StringValues get_Pragma();
    internal void set_Pragma(StringValues value);
    internal StringValues get_ProxyAuthorization();
    internal void set_ProxyAuthorization(StringValues value);
    internal StringValues get_Range();
    internal void set_Range(StringValues value);
    internal StringValues get_Referer();
    internal void set_Referer(StringValues value);
    internal StringValues get_Te();
    internal void set_Te(StringValues value);
    internal StringValues get_Trailer();
    internal void set_Trailer(StringValues value);
    internal StringValues get_TransferEncoding();
    internal void set_TransferEncoding(StringValues value);
    internal StringValues get_Translate();
    internal void set_Translate(StringValues value);
    internal StringValues get_Upgrade();
    internal void set_Upgrade(StringValues value);
    internal StringValues get_UserAgent();
    internal void set_UserAgent(StringValues value);
    internal StringValues get_Via();
    internal void set_Via(StringValues value);
    internal StringValues get_Warning();
    internal void set_Warning(StringValues value);
    private bool PropertiesContainsKey(string key);
    private bool PropertiesTryGetValue(string key, StringValues& value);
    private bool PropertiesTrySetValue(string key, StringValues value);
    private bool PropertiesTryRemove(string key);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesKeys>d__216")]
private IEnumerable`1<string> PropertiesKeys();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesValues>d__217")]
private IEnumerable`1<StringValues> PropertiesValues();
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.HttpSys.Internal.RequestHeaders/<PropertiesEnumerable>d__218")]
private IEnumerable`1<KeyValuePair`2<string, StringValues>> PropertiesEnumerable();
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.RequestUriBuilder : object {
    private static Encoding UTF8;
    private static RequestUriBuilder();
    public static string DecodeAndUnescapePath(Byte[] rawUrlBytes);
    private static ArraySegment`1<byte> Unescape(ArraySegment`1<byte> rawPath);
    private static bool DecodeCore(Int32& reader, Int32& writer, int end, Byte[] buffer);
    private static void Copy(int begin, int end, Int32& writer, Byte[] buffer);
    private static Nullable`1<int> UnescapePercentEncoding(Int32& scan, int end, Byte[] buffer);
    private static Nullable`1<int> ReadHex(Int32& scan, int end, Byte[] buffer);
    private static bool SkipUnescape(int value1, int value2);
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalFreeChannelBinding : ChannelBinding {
    private static int LMEM_FIXED;
    private int size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    public static SafeLocalFreeChannelBinding LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeLocalMemHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLocalMemHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.AspNetCore.HttpSys.Internal.SafeNativeOverlapped : SafeHandle {
    internal static SafeNativeOverlapped Zero;
    private ThreadPoolBoundHandle _boundHandle;
    public bool IsInvalid { get; }
    internal SafeNativeOverlapped(ThreadPoolBoundHandle boundHandle, NativeOverlapped* handle);
    private static SafeNativeOverlapped();
    public virtual bool get_IsInvalid();
    public void ReinitializeNativeOverlapped();
    protected virtual bool ReleaseHandle();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.AspNetCore.HttpSys.Internal.SocketAddress : object {
    private static int NumberOfIPv6Labels;
    private static string IPv6NumberFormat;
    private static string IPv6StringSeparator;
    private static string IPv4StringFormat;
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    private static int WriteableOffset;
    private int _size;
    private Byte[] _buffer;
    private int _hash;
    internal Byte[] Buffer { get; }
    internal AddressFamily Family { get; }
    internal int Size { get; }
    private byte Item { get; }
    public SocketAddress(AddressFamily family, int size);
    internal Byte[] get_Buffer();
    internal AddressFamily get_Family();
    internal int get_Size();
    private byte get_Item(int offset);
    internal int GetPort();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    internal IPAddress GetIPAddress();
    private IPAddress GetIpv6Address();
    private IPAddress GetIPv4Address();
    public virtual string ToString();
    internal string GetIPAddressString();
    private string GetIPv4AddressString();
    private string GetIpv6AddressString();
    private static string GetIPv6AddressString(UInt16* numbers);
    private static KeyValuePair`2<int, int> FindCompressionRange(UInt16* numbers);
    private static bool ShouldHaveIpv4Embedded(UInt16* numbers);
}
internal enum Microsoft.AspNetCore.HttpSys.Internal.SslStatus : Enum {
    public byte value__;
    public static SslStatus Insecure;
    public static SslStatus NoClientCert;
    public static SslStatus ClientCert;
}
internal static class Microsoft.AspNetCore.HttpSys.Internal.UnsafeNclNativeMethods : object {
    private static string sspicli_LIB;
    private static string api_ms_win_core_processthreads_LIB;
    private static string api_ms_win_core_io_LIB;
    private static string api_ms_win_core_handle_LIB;
    private static string api_ms_win_core_libraryloader_LIB;
    private static string api_ms_win_core_heap_LIB;
    private static string api_ms_win_core_heap_obsolete_LIB;
    private static string api_ms_win_core_kernel32_legacy_LIB;
    private static string TOKENBINDING;
    internal static UInt32 CancelIoEx(SafeHandle handle, SafeNativeOverlapped overlapped);
    internal static bool SetFileCompletionNotificationModes(SafeHandle handle, FileCompletionNotificationModes modes);
    public static int TokenBindingVerifyMessage(Byte* tokenBindingMessage, UInt32 tokenBindingMessageSize, Char* keyType, Byte* tlsUnique, UInt32 tlsUniqueSize, HeapAllocHandle& resultList);
    internal static IntPtr GetProcessHeap();
    internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.DuplexStream : Stream {
    private Stream _requestBody;
    private Stream _responseBody;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DuplexStream(Stream requestBody, Stream responseBody);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.EmptyStream : ReadOnlyStream {
    private IHttpBodyControlFeature _bodyControl;
    private HttpStreamState _state;
    private Exception _error;
    public EmptyStream(IHttpBodyControlFeature bodyControl);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public void StopAcceptingReads();
    public void Abort(Exception error);
    private void ValidateState(CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.HttpRequestStream : ReadOnlyStream {
    private IHttpBodyControlFeature _bodyControl;
    private IISHttpContext _body;
    private HttpStreamState _state;
    private Exception _error;
    public HttpRequestStream(IHttpBodyControlFeature bodyControl);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    private Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.HttpRequestStream/<ReadAsyncInternal>d__10")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public void StartAcceptingReads(IISHttpContext body);
    public void StopAcceptingReads();
    public void Abort(Exception error);
    private void ValidateState(CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.HttpResponseStream : WriteOnlyStream {
    private IHttpBodyControlFeature _bodyControl;
    private IISHttpContext _context;
    private HttpStreamState _state;
    public HttpResponseStream(IHttpBodyControlFeature bodyControl, IISHttpContext context);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, object state);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public void StartAcceptingWrites();
    public void StopAcceptingWrites();
    public void Abort();
    private void ValidateState(CancellationToken cancellationToken);
}
internal enum Microsoft.AspNetCore.Server.IIS.Core.HttpStreamState : Enum {
    public int value__;
    public static HttpStreamState Open;
    public static HttpStreamState Closed;
    public static HttpStreamState Aborted;
}
internal class Microsoft.AspNetCore.Server.IIS.Core.HttpUpgradeStream : Stream {
    private Stream _requestStream;
    private Stream _responseStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public HttpUpgradeStream(Stream requestStream, Stream responseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IISConfigurationData : ValueType {
    public IntPtr pNativeApplication;
    public string pwzFullApplicationPath;
    public string pwzVirtualApplicationPath;
    public bool fWindowsAuthEnabled;
    public bool fBasicAuthEnabled;
    public bool fAnonymousAuthEnable;
}
internal interface Microsoft.AspNetCore.Server.IIS.Core.IISContextFactory {
    public abstract virtual IISHttpContext CreateHttpContext(IntPtr pInProcessHandler);
}
internal abstract class Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext : NativeRequestContext {
    private static int MinAllocBufferSize;
    private static int PauseWriterThreshold;
    private static int ResumeWriterTheshold;
    protected IntPtr _pInProcessHandler;
    private IISServerOptions _options;
    protected Streams _streams;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasResponseStarted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasRequestReadingStarted;
    private int _statusCode;
    private string _reasonPhrase;
    private object _contextLock;
    protected Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onStarting;
    protected Stack`1<KeyValuePair`2<Func`2<object, Task>, object>> _onCompleted;
    protected Exception _applicationException;
    private MemoryPool`1<byte> _memoryPool;
    private IISHttpServer _server;
    private ILogger _logger;
    private GCHandle _thisHandle;
    protected Task _readBodyTask;
    protected Task _writeBodyTask;
    private bool _wasUpgraded;
    protected int _requestAborted;
    protected Pipe _bodyInputPipe;
    protected OutputProducer _bodyOutput;
    private static string NtlmString;
    private static string NegotiateString;
    private static string BasicString;
    [CompilerGeneratedAttribute]
private Version <HttpVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <RemoteIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemotePort>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <LocalIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsPrincipal <WindowsUser>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <RequestBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncIOEngine <AsyncIO>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <RequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IHeaderDictionary <ResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderCollection <HttpResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private HTTP_VERB <KnownMethod>k__BackingField;
    private bool disposedValue;
    private int _featureRevision;
    private string _httpProtocolVersion;
    private X509Certificate2 _certificate;
    private List`1<KeyValuePair`2<Type, object>> MaybeExtra;
    [CompilerGeneratedAttribute]
private IAuthenticationHandler <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO>k__BackingField;
    private static Type IHttpRequestFeatureType;
    private static Type IHttpResponseFeatureType;
    private static Type IHttpRequestIdentifierFeatureType;
    private static Type IServiceProvidersFeatureType;
    private static Type IHttpRequestLifetimeFeatureType;
    private static Type IHttpConnectionFeatureType;
    private static Type IHttpAuthenticationFeatureType;
    private static Type IQueryFeatureType;
    private static Type IFormFeatureType;
    private static Type IHttpUpgradeFeatureType;
    private static Type IResponseCookiesFeatureType;
    private static Type IItemsFeatureType;
    private static Type ITlsConnectionFeatureType;
    private static Type IHttpWebSocketFeatureType;
    private static Type ISessionFeatureType;
    private static Type IHttpBodyControlFeatureType;
    private static Type IHttpSendFileFeatureType;
    private static Type IISHttpContextType;
    private static Type IServerVariablesFeature;
    private static Type IHttpBufferingFeature;
    private object _currentIHttpRequestFeature;
    private object _currentIHttpResponseFeature;
    private object _currentIHttpRequestIdentifierFeature;
    private object _currentIServiceProvidersFeature;
    private object _currentIHttpRequestLifetimeFeature;
    private object _currentIHttpConnectionFeature;
    private object _currentIHttpAuthenticationFeature;
    private object _currentIQueryFeature;
    private object _currentIFormFeature;
    private object _currentIHttpUpgradeFeature;
    private object _currentIResponseCookiesFeature;
    private object _currentIItemsFeature;
    private object _currentITlsConnectionFeature;
    private object _currentIHttpWebSocketFeature;
    private object _currentISessionFeature;
    private object _currentIHttpBodyControlFeature;
    private object _currentIHttpSendFileFeature;
    private object _currentIServerVariablesFeature;
    private object _currentIHttpBufferingFeature;
    private CancellationTokenSource _abortedCts;
    private Nullable`1<CancellationToken> _manuallySetRequestAbortToken;
    public Version HttpVersion { get; public set; }
    public string Scheme { get; public set; }
    public string Method { get; public set; }
    public string PathBase { get; public set; }
    public string Path { get; public set; }
    public string QueryString { get; public set; }
    public string RawTarget { get; public set; }
    public bool HasResponseStarted { get; }
    public IPAddress RemoteIpAddress { get; public set; }
    public int RemotePort { get; public set; }
    public IPAddress LocalIpAddress { get; public set; }
    public int LocalPort { get; public set; }
    public string RequestConnectionId { get; public set; }
    public string TraceIdentifier { get; public set; }
    public ClaimsPrincipal User { get; public set; }
    internal WindowsPrincipal WindowsUser { get; internal set; }
    public Stream RequestBody { get; public set; }
    public Stream ResponseBody { get; public set; }
    protected IAsyncIOEngine AsyncIO { get; protected set; }
    public IHeaderDictionary RequestHeaders { get; public set; }
    public IHeaderDictionary ResponseHeaders { get; public set; }
    private HeaderCollection HttpResponseHeaders { get; private set; }
    internal HTTP_VERB KnownMethod { get; private set; }
    public int StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    internal IISHttpServer Server { get; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Protocol { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Scheme { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Method { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.PathBase { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Path { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.QueryString { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.RawTarget { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Headers { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.Body { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.StatusCode { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.ReasonPhrase { get; private set; }
    private IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Headers { get; private set; }
    private Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.Body { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.HasStarted { get; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.IsUpgradableRequest { get; }
    private bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.IsReadOnly { get; }
    private int Microsoft.AspNetCore.Http.Features.IFeatureCollection.Revision { get; }
    private ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.User { get; private set; }
    public IAuthenticationHandler Handler { get; public set; }
    private string Microsoft.AspNetCore.Http.Features.IServerVariablesFeature.Item { get; private set; }
    private object Microsoft.AspNetCore.Http.Features.IFeatureCollection.Item { get; private set; }
    private X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.ClientCertificate { get; private set; }
    private bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.AllowSynchronousIO { get; private set; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemoteIpAddress { get; private set; }
    private IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalIpAddress { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.RemotePort { get; private set; }
    private int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.LocalPort { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.ConnectionId { get; private set; }
    private string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.TraceIdentifier { get; private set; }
    private CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.RequestAborted { get; private set; }
    private CancellationTokenSource RequestAbortedSource { get; }
    internal IISHttpContext(MemoryPool`1<byte> memoryPool, IntPtr pInProcessHandler, IISServerOptions options, IISHttpServer server, ILogger logger);
    private static IISHttpContext();
    [CompilerGeneratedAttribute]
public Version get_HttpVersion();
    [CompilerGeneratedAttribute]
public void set_HttpVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public void set_Scheme(string value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
public void set_PathBase(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_QueryString();
    [CompilerGeneratedAttribute]
public void set_QueryString(string value);
    [CompilerGeneratedAttribute]
public string get_RawTarget();
    [CompilerGeneratedAttribute]
public void set_RawTarget(string value);
    public bool get_HasResponseStarted();
    [CompilerGeneratedAttribute]
public IPAddress get_RemoteIpAddress();
    [CompilerGeneratedAttribute]
public void set_RemoteIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_RemotePort();
    [CompilerGeneratedAttribute]
public void set_RemotePort(int value);
    [CompilerGeneratedAttribute]
public IPAddress get_LocalIpAddress();
    [CompilerGeneratedAttribute]
public void set_LocalIpAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public int get_LocalPort();
    [CompilerGeneratedAttribute]
public void set_LocalPort(int value);
    [CompilerGeneratedAttribute]
public string get_RequestConnectionId();
    [CompilerGeneratedAttribute]
public void set_RequestConnectionId(string value);
    [CompilerGeneratedAttribute]
public string get_TraceIdentifier();
    [CompilerGeneratedAttribute]
public void set_TraceIdentifier(string value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_User();
    [CompilerGeneratedAttribute]
public void set_User(ClaimsPrincipal value);
    [CompilerGeneratedAttribute]
internal WindowsPrincipal get_WindowsUser();
    [CompilerGeneratedAttribute]
internal void set_WindowsUser(WindowsPrincipal value);
    [CompilerGeneratedAttribute]
public Stream get_RequestBody();
    [CompilerGeneratedAttribute]
public void set_RequestBody(Stream value);
    [CompilerGeneratedAttribute]
public Stream get_ResponseBody();
    [CompilerGeneratedAttribute]
public void set_ResponseBody(Stream value);
    [CompilerGeneratedAttribute]
protected IAsyncIOEngine get_AsyncIO();
    [CompilerGeneratedAttribute]
protected void set_AsyncIO(IAsyncIOEngine value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_RequestHeaders();
    [CompilerGeneratedAttribute]
public void set_RequestHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
public IHeaderDictionary get_ResponseHeaders();
    [CompilerGeneratedAttribute]
public void set_ResponseHeaders(IHeaderDictionary value);
    [CompilerGeneratedAttribute]
private HeaderCollection get_HttpResponseHeaders();
    [CompilerGeneratedAttribute]
private void set_HttpResponseHeaders(HeaderCollection value);
    [CompilerGeneratedAttribute]
internal HTTP_VERB get_KnownMethod();
    [CompilerGeneratedAttribute]
private void set_KnownMethod(HTTP_VERB value);
    protected void InitializeContext();
    private string GetOriginalPath();
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    internal IISHttpServer get_Server();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<InitializeResponse>d__128")]
private Task InitializeResponse(bool flushHeaders);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<ProduceStart>d__129")]
private Task ProduceStart(bool flushHeaders);
    private bool StatusCodeCanHaveBody();
    private void InitializeRequestIO();
    private void EnsureIOInitialized();
    private void ThrowResponseAbortedException();
    protected Task ProduceEnd();
    private void SetErrorResponseHeaders(int statusCode);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<ProduceEndAwaited>d__136")]
private Task ProduceEndAwaited();
    public void SetResponseHeaders();
    public abstract virtual Task`1<bool> ProcessRequestAsync();
    public void OnStarting(Func`2<object, Task> callback, object state);
    public void OnCompleted(Func`2<object, Task> callback, object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<FireOnStarting>d__141")]
protected Task FireOnStarting();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<FireOnCompleted>d__142")]
protected Task FireOnCompleted();
    protected void ReportApplicationError(Exception ex);
    public void PostCompletion(REQUEST_NOTIFICATION_STATUS requestNotificationStatus);
    internal void OnAsyncCompletion(int hr, int bytes);
    protected virtual void Dispose(bool disposing);
    public virtual void Dispose();
    private void ThrowResponseAlreadyStartedException(string name);
    private WindowsPrincipal GetWindowsPrincipal();
    public void ResetFeatureCollection();
    private object ExtraFeatureGet(Type key);
    private void ExtraFeatureSet(Type key, object value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Protocol();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Protocol(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Scheme();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Scheme(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Method();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Method(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_PathBase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_PathBase(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Path();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Path(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_QueryString();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_QueryString(string value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_RawTarget();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_RawTarget(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestFeature.set_Body(Stream value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_StatusCode();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_StatusCode(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_ReasonPhrase();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_ReasonPhrase(string value);
    private sealed virtual override IHeaderDictionary Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Headers();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Headers(IHeaderDictionary value);
    private sealed virtual override Stream Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_Body();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.set_Body(Stream value);
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.get_HasStarted();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.get_IsUpgradableRequest();
    private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_IsReadOnly();
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Revision();
    private sealed virtual override ClaimsPrincipal Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.get_User();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.Authentication.IHttpAuthenticationFeature.set_User(ClaimsPrincipal value);
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationHandler get_Handler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Handler(IAuthenticationHandler value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IServerVariablesFeature.get_Item(string variableName);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IServerVariablesFeature.set_Item(string variableName, string value);
    private sealed virtual override object Microsoft.AspNetCore.Http.Features.IFeatureCollection.get_Item(Type key);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.set_Item(Type key, object value);
    private sealed virtual override TFeature Microsoft.AspNetCore.Http.Features.IFeatureCollection.Get();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IFeatureCollection.Set(TFeature instance);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnStarting(Func`2<object, Task> callback, object state);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpResponseFeature.OnCompleted(Func`2<object, Task> callback, object state);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<Microsoft-AspNetCore-Http-Features-IHttpUpgradeFeature-UpgradeAsync>d__222")]
private sealed virtual override Task`1<Stream> Microsoft.AspNetCore.Http.Features.IHttpUpgradeFeature.UpgradeAsync();
    private sealed virtual override Task`1<X509Certificate2> Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.GetClientCertificateAsync(CancellationToken cancellationToken);
    private sealed virtual override X509Certificate2 Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.get_ClientCertificate();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.ITlsConnectionFeature.set_ClientCertificate(X509Certificate2 value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<Type, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private sealed virtual override bool Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.get_AllowSynchronousIO();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBodyControlFeature.set_AllowSynchronousIO(bool value);
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBufferingFeature.DisableRequestBuffering();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpBufferingFeature.DisableResponseBuffering();
    private void DisableCompression();
    private void Initialize();
    internal object FastFeatureGet(Type key);
    internal void FastFeatureSet(Type key, object feature);
    [IteratorStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<FastEnumerable>d__278")]
private IEnumerable`1<KeyValuePair`2<Type, object>> FastEnumerable();
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemoteIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemoteIpAddress(IPAddress value);
    private sealed virtual override IPAddress Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalIpAddress();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalIpAddress(IPAddress value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_RemotePort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_RemotePort(int value);
    private sealed virtual override int Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_LocalPort();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_LocalPort(int value);
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.get_ConnectionId();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpConnectionFeature.set_ConnectionId(string value);
    private void InitializeLocalEndpoint();
    private void InitializeRemoteEndpoint();
    private void InitializeConnectionId();
    private sealed virtual override string Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.get_TraceIdentifier();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestIdentifierFeature.set_TraceIdentifier(string value);
    private void InitializeHttpRequestIdentifierFeature();
    private sealed virtual override CancellationToken Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.get_RequestAborted();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.set_RequestAborted(CancellationToken value);
    private CancellationTokenSource get_RequestAbortedSource();
    private sealed virtual override void Microsoft.AspNetCore.Http.Features.IHttpRequestLifetimeFeature.Abort();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<ReadAsync>d__309")]
internal Task`1<int> ReadAsync(Memory`1<byte> memory, CancellationToken cancellationToken);
    internal Task WriteAsync(ReadOnlyMemory`1<byte> memory, CancellationToken cancellationToken);
    internal Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<ReadBody>d__312")]
private Task ReadBody();
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContext/<WriteBody>d__313")]
private Task WriteBody(bool flush);
    private bool AbortIO();
    public void Abort(Exception reason);
    internal void ConnectionReset();
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IISHttpContextOfT`1 : IISHttpContext {
    private IHttpApplication`1<TContext> _application;
    public IISHttpContextOfT`1(MemoryPool`1<byte> memoryPool, IHttpApplication`1<TContext> application, IntPtr pInProcessHandler, IISServerOptions options, IISHttpServer server, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpContextOfT`1/<ProcessRequestAsync>d__2")]
public virtual Task`1<bool> ProcessRequestAsync();
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IISHttpServer : object {
    private static string WebSocketVersionString;
    private static PFN_REQUEST_HANDLER _requestHandler;
    private static PFN_SHUTDOWN_HANDLER _shutdownHandler;
    private static PFN_DISCONNECT_HANDLER _onDisconnect;
    private static PFN_ASYNC_COMPLETION _onAsyncCompletion;
    private IISContextFactory _iisContextFactory;
    private MemoryPool`1<byte> _memoryPool;
    private GCHandle _httpServerHandle;
    private IApplicationLifetime _applicationLifetime;
    private ILogger`1<IISHttpServer> _logger;
    private IISServerOptions _options;
    private IISNativeApplication _nativeApplication;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _stopping;
    private int _outstandingRequests;
    private TaskCompletionSource`1<object> _shutdownSignal;
    private Nullable`1<bool> _websocketAvailable;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    private bool Stopping { get; }
    public IFeatureCollection Features { get; }
    public IISHttpServer(IISNativeApplication nativeApplication, IApplicationLifetime applicationLifetime, IAuthenticationSchemeProvider authentication, IOptions`1<IISServerOptions> options, ILogger`1<IISHttpServer> logger);
    private static IISHttpServer();
    private bool get_Stopping();
    [CompilerGeneratedAttribute]
public sealed virtual IFeatureCollection get_Features();
    public bool IsWebSocketAvailable(IntPtr pInProcessHandler);
    public sealed virtual Task StartAsync(IHttpApplication`1<TContext> application, CancellationToken cancellationToken);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private static REQUEST_NOTIFICATION_STATUS HandleRequest(IntPtr pInProcessHandler, IntPtr pvRequestContext);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.IISHttpServer/<HandleRequest>d__27")]
private static Task HandleRequest(IISHttpContext context);
    private static bool HandleShutdown(IntPtr pvRequestContext);
    private static void OnDisconnect(IntPtr pvManagedHttpContext);
    private static REQUEST_NOTIFICATION_STATUS OnAsyncCompletion(IntPtr pvManagedHttpContext, int hr, int bytes);
    private static void CompleteRequest(IISHttpContext context, bool result);
    private static REQUEST_NOTIFICATION_STATUS ConvertRequestCompletionResults(bool success);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IISNativeApplication : object {
    private IntPtr _nativeApplication;
    public IISNativeApplication(IntPtr nativeApplication);
    public void StopIncomingRequests();
    public void StopCallsIntoManaged();
    public void RegisterCallbacks(PFN_REQUEST_HANDLER requestHandler, PFN_SHUTDOWN_HANDLER shutdownHandler, PFN_DISCONNECT_HANDLER disconnectHandler, PFN_ASYNC_COMPLETION onAsyncCompletion, IntPtr requestContext, IntPtr shutdownContext);
    public void Dispose();
    protected virtual override void Finalize();
}
public class Microsoft.AspNetCore.Server.IIS.Core.IISServerAuthenticationHandler : object {
    private HttpContext _context;
    private IISHttpContext _iisHttpContext;
    [CompilerGeneratedAttribute]
private AuthenticationScheme <Scheme>k__BackingField;
    internal AuthenticationScheme Scheme { get; private set; }
    [CompilerGeneratedAttribute]
internal AuthenticationScheme get_Scheme();
    [CompilerGeneratedAttribute]
private void set_Scheme(AuthenticationScheme value);
    public sealed virtual Task`1<AuthenticateResult> AuthenticateAsync();
    public sealed virtual Task ChallengeAsync(AuthenticationProperties properties);
    public sealed virtual Task ForbidAsync(AuthenticationProperties properties);
    public sealed virtual Task InitializeAsync(AuthenticationScheme scheme, HttpContext context);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IISServerSetupFilter : object {
    private string _virtualPath;
    public IISServerSetupFilter(string virtualPath);
    public sealed virtual Action`1<IApplicationBuilder> Configure(Action`1<IApplicationBuilder> next);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IO.AsyncIOEngine : object {
    private object _contextSync;
    private IntPtr _handler;
    private bool _stopped;
    private AsyncIOOperation _nextOperation;
    private AsyncIOOperation _runningOperation;
    private AsyncReadOperation _cachedAsyncReadOperation;
    private AsyncWriteOperation _cachedAsyncWriteOperation;
    private AsyncFlushOperation _cachedAsyncFlushOperation;
    public AsyncIOEngine(object contextSync, IntPtr handler);
    public sealed virtual ValueTask`1<int> ReadAsync(Memory`1<byte> memory);
    public sealed virtual ValueTask`1<int> WriteAsync(ReadOnlySequence`1<byte> data);
    private void Run(AsyncIOOperation ioOperation);
    public sealed virtual ValueTask FlushAsync(bool moreData);
    public sealed virtual void NotifyCompletion(int hr, int bytes);
    public sealed virtual void Dispose();
    private AsyncReadOperation GetReadOperation();
    private AsyncWriteOperation GetWriteOperation();
    private AsyncFlushOperation GetFlushOperation();
    private void ReturnOperation(AsyncReadOperation operation);
    private void ReturnOperation(AsyncWriteOperation operation);
    private void ReturnOperation(AsyncFlushOperation operation);
}
internal abstract class Microsoft.AspNetCore.Server.IIS.Core.IO.AsyncIOOperation : object {
    private static Action`1<object> CallbackCompleted;
    private Action`1<object> _continuation;
    private object _state;
    private int _result;
    private Exception _exception;
    private static AsyncIOOperation();
    public sealed virtual ValueTaskSourceStatus GetStatus(short token);
    public sealed virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private static void ThrowMultipleContinuations();
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token);
    public sealed virtual int GetResult(short token);
    public Nullable`1<AsyncContinuation> Invoke();
    protected abstract virtual bool InvokeOperation(Int32& hr, Int32& bytes);
    public AsyncContinuation Complete(int hr, int bytes);
    protected virtual bool IsSuccessfulResult(int hr);
    public virtual void FreeOperationResources(int hr, int bytes);
    protected virtual void ResetOperation();
}
internal abstract class Microsoft.AspNetCore.Server.IIS.Core.IO.AsyncWriteOperationBase : AsyncIOOperation {
    private static int HttpDataChunkStackLimit;
    private IntPtr _requestHandler;
    private ReadOnlySequence`1<byte> _buffer;
    private MemoryHandle[] _handles;
    public void Initialize(IntPtr requestHandler, ReadOnlySequence`1<byte> buffer);
    protected virtual bool InvokeOperation(Int32& hr, Int32& bytes);
    public virtual void FreeOperationResources(int hr, int bytes);
    protected virtual void ResetOperation();
    private int GetChunkCount();
    private int WriteSequence(int nChunks, ReadOnlySequence`1<byte> buffer, HTTP_DATA_CHUNK* pDataChunks, Boolean& fCompletionExpected);
    protected abstract virtual int WriteChunks(IntPtr requestHandler, int chunkCount, HTTP_DATA_CHUNK* dataChunks, Boolean& completionExpected);
}
internal interface Microsoft.AspNetCore.Server.IIS.Core.IO.IAsyncIOEngine {
    public abstract virtual ValueTask`1<int> ReadAsync(Memory`1<byte> memory);
    public abstract virtual ValueTask`1<int> WriteAsync(ReadOnlySequence`1<byte> data);
    public abstract virtual ValueTask FlushAsync(bool moreData);
    public abstract virtual void NotifyCompletion(int hr, int bytes);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.IO.WebSocketsAsyncIOEngine : object {
    private object _contextLock;
    private IntPtr _handler;
    private bool _isInitialized;
    private AsyncInitializeOperation _initializationFlush;
    private WebSocketWriteOperation _cachedWebSocketWriteOperation;
    private WebSocketReadOperation _cachedWebSocketReadOperation;
    private AsyncInitializeOperation _cachedAsyncInitializeOperation;
    public WebSocketsAsyncIOEngine(object contextLock, IntPtr handler);
    public sealed virtual ValueTask`1<int> ReadAsync(Memory`1<byte> memory);
    public sealed virtual ValueTask`1<int> WriteAsync(ReadOnlySequence`1<byte> data);
    public sealed virtual ValueTask FlushAsync(bool moreData);
    public sealed virtual void NotifyCompletion(int hr, int bytes);
    private void ThrowIfNotInitialized();
    public sealed virtual void Dispose();
    private WebSocketReadOperation GetReadOperation();
    private WebSocketWriteOperation GetWriteOperation();
    private AsyncInitializeOperation GetInitializeOperation();
    private void ReturnOperation(AsyncInitializeOperation operation);
    private void ReturnOperation(WebSocketWriteOperation operation);
    private void ReturnOperation(WebSocketReadOperation operation);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.OutputProducer : object {
    private object _contextLock;
    private ValueTask`1<FlushResult> _flushTask;
    private bool _completed;
    private Pipe _pipe;
    private TaskCompletionSource`1<object> _flushTcs;
    private object _flushLock;
    private Action _flushCompleted;
    public PipeReader Reader { get; }
    public OutputProducer(Pipe pipe);
    public PipeReader get_Reader();
    public Task FlushAsync(CancellationToken cancellationToken);
    public void Dispose();
    public void Abort(Exception error);
    public Task WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    private Task FlushAsync(PipeWriter pipeWriter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.AspNetCore.Server.IIS.Core.OutputProducer/<FlushAsyncAwaited>d__15")]
private Task FlushAsyncAwaited(ValueTask`1<FlushResult> awaitable, CancellationToken cancellationToken);
    private void OnFlushCompleted();
}
internal abstract class Microsoft.AspNetCore.Server.IIS.Core.ReadOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int WriteTimeout { get; public set; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.Streams : object {
    private static ThrowingWasUpgradedWriteOnlyStream _throwingResponseStream;
    private IISHttpContext _context;
    private HttpResponseStream _response;
    private HttpRequestStream _request;
    private WrappingStream _upgradeableRequest;
    private WrappingStream _upgradeableResponse;
    private EmptyStream _emptyRequest;
    private Stream _upgradeStream;
    public Streams(IISHttpContext context);
    private static Streams();
    public Stream Upgrade();
    public ValueTuple`2<Stream, Stream> Start();
    public void Stop();
    public void Abort(Exception error);
}
public class Microsoft.AspNetCore.Server.IIS.Core.ThrowingWasUpgradedWriteOnlyStream : WriteOnlyStream {
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class Microsoft.AspNetCore.Server.IIS.Core.WrappingStream : Stream {
    private Stream _inner;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public WrappingStream(Stream inner);
    public void SetInnerStream(Stream inner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual object InitializeLifetimeService();
    public virtual void Close();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.AspNetCore.Server.IIS.Core.WriteOnlyStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal static class Microsoft.AspNetCore.Server.IIS.CoreStrings : object {
    private static ResourceManager _resourceManager;
    internal static string ResponseStreamWasUpgraded { get; }
    internal static string UnhandledApplicationException { get; }
    internal static string CannotUpgradeNonUpgradableRequest { get; }
    internal static string UpgradeCannotBeCalledMultipleTimes { get; }
    internal static string SynchronousReadsDisallowed { get; }
    internal static string SynchronousWritesDisallowed { get; }
    internal static string WritingToResponseBodyAfterResponseCompleted { get; }
    internal static string ConnectionAbortedByApplication { get; }
    internal static string ConnectionOrStreamAbortedByCancellationToken { get; }
    internal static string ParameterReadOnlyAfterResponseStarted { get; }
    private static CoreStrings();
    internal static string get_ResponseStreamWasUpgraded();
    internal static string FormatResponseStreamWasUpgraded();
    internal static string get_UnhandledApplicationException();
    internal static string FormatUnhandledApplicationException();
    internal static string get_CannotUpgradeNonUpgradableRequest();
    internal static string FormatCannotUpgradeNonUpgradableRequest();
    internal static string get_UpgradeCannotBeCalledMultipleTimes();
    internal static string FormatUpgradeCannotBeCalledMultipleTimes();
    internal static string get_SynchronousReadsDisallowed();
    internal static string FormatSynchronousReadsDisallowed();
    internal static string get_SynchronousWritesDisallowed();
    internal static string FormatSynchronousWritesDisallowed();
    internal static string get_WritingToResponseBodyAfterResponseCompleted();
    internal static string FormatWritingToResponseBodyAfterResponseCompleted();
    internal static string get_ConnectionAbortedByApplication();
    internal static string FormatConnectionAbortedByApplication();
    internal static string get_ConnectionOrStreamAbortedByCancellationToken();
    internal static string FormatConnectionOrStreamAbortedByCancellationToken();
    internal static string get_ParameterReadOnlyAfterResponseStarted();
    internal static string FormatParameterReadOnlyAfterResponseStarted(object name);
    private static string GetString(string name, String[] formatterNames);
}
[ExtensionAttribute]
public static class Microsoft.AspNetCore.Server.IIS.HttpContextExtensions : object {
    [ExtensionAttribute]
public static string GetIISServerVariable(HttpContext context, string variableName);
}
public class Microsoft.AspNetCore.Server.IIS.IISServerDefaults : object {
    public static string AuthenticationScheme;
}
internal static class Microsoft.AspNetCore.Server.IIS.NativeMethods : object {
    internal static int HR_OK;
    internal static int ERROR_NOT_FOUND;
    internal static int ERROR_OPERATION_ABORTED;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_HANDLE_EOF;
    private static string KERNEL32;
    internal static string AspNetCoreModuleDll;
    public static bool CloseHandle(IntPtr handle);
    private static IntPtr GetModuleHandle(string lpModuleName);
    public static bool IsAspNetCoreModuleLoaded();
    private static int http_post_completion(IntPtr pInProcessHandler, int cbBytes);
    private static int http_set_completion_status(IntPtr pInProcessHandler, REQUEST_NOTIFICATION_STATUS rquestNotificationStatus);
    private static void http_indicate_completion(IntPtr pInProcessHandler, REQUEST_NOTIFICATION_STATUS notificationStatus);
    private static int register_callbacks(IntPtr pInProcessApplication, PFN_REQUEST_HANDLER requestCallback, PFN_SHUTDOWN_HANDLER shutdownCallback, PFN_DISCONNECT_HANDLER disconnectCallback, PFN_ASYNC_COMPLETION asyncCallback, IntPtr pvRequestContext, IntPtr pvShutdownContext);
    private static int http_write_response_bytes(IntPtr pInProcessHandler, HTTP_DATA_CHUNK* pDataChunks, int nChunks, Boolean& fCompletionExpected);
    private static int http_flush_response_bytes(IntPtr pInProcessHandler, bool fMoreData, Boolean& fCompletionExpected);
    private static HTTP_REQUEST_V2* http_get_raw_request(IntPtr pInProcessHandler);
    private static int http_stop_calls_into_managed(IntPtr pInProcessApplication);
    private static int http_stop_incoming_requests(IntPtr pInProcessApplication);
    private static int http_disable_buffering(IntPtr pInProcessApplication);
    private static int http_set_response_status_code(IntPtr pInProcessHandler, ushort statusCode, string pszReason);
    private static int http_read_request_bytes(IntPtr pInProcessHandler, Byte* pvBuffer, int cbBuffer, Int32& dwBytesReceived, Boolean& fCompletionExpected);
    private static void http_get_completion_info(IntPtr pCompletionInfo, Int32& cbBytes, Int32& hr);
    private static int http_set_managed_context(IntPtr pInProcessHandler, IntPtr pvManagedContext);
    private static int http_get_application_properties(IISConfigurationData& iiConfigData);
    private static int http_get_server_variable(IntPtr pInProcessHandler, string variableName, String& value);
    private static int http_set_server_variable(IntPtr pInProcessHandler, string variableName, string value);
    private static int http_websockets_read_bytes(IntPtr pInProcessHandler, Byte* pvBuffer, int cbBuffer, PFN_WEBSOCKET_ASYNC_COMPLETION pfnCompletionCallback, IntPtr pvCompletionContext, Int32& dwBytesReceived, Boolean& fCompletionExpected);
    private static int http_websockets_write_bytes(IntPtr pInProcessHandler, HTTP_DATA_CHUNK* pDataChunks, int nChunks, PFN_WEBSOCKET_ASYNC_COMPLETION pfnCompletionCallback, IntPtr pvCompletionContext, Boolean& fCompletionExpected);
    private static int http_enable_websockets(IntPtr pInProcessHandler);
    private static int http_cancel_io(IntPtr pInProcessHandler);
    private static int http_close_connection(IntPtr pInProcessHandler);
    private static int http_response_set_unknown_header(IntPtr pInProcessHandler, Byte* pszHeaderName, Byte* pszHeaderValue, ushort usHeaderValueLength, bool fReplace);
    private static int http_response_set_known_header(IntPtr pInProcessHandler, int headerId, Byte* pHeaderValue, ushort length, bool fReplace);
    private static int http_get_authentication_information(IntPtr pInProcessHandler, String& authType, IntPtr& token);
    public static void HttpPostCompletion(IntPtr pInProcessHandler, int cbBytes);
    public static void HttpSetCompletionStatus(IntPtr pInProcessHandler, REQUEST_NOTIFICATION_STATUS rquestNotificationStatus);
    public static void HttpRegisterCallbacks(IntPtr pInProcessApplication, PFN_REQUEST_HANDLER requestCallback, PFN_SHUTDOWN_HANDLER shutdownCallback, PFN_DISCONNECT_HANDLER disconnectCallback, PFN_ASYNC_COMPLETION asyncCallback, IntPtr pvRequestContext, IntPtr pvShutdownContext);
    public static int HttpWriteResponseBytes(IntPtr pInProcessHandler, HTTP_DATA_CHUNK* pDataChunks, int nChunks, Boolean& fCompletionExpected);
    public static int HttpFlushResponseBytes(IntPtr pInProcessHandler, bool fMoreData, Boolean& fCompletionExpected);
    public static HTTP_REQUEST_V2* HttpGetRawRequest(IntPtr pInProcessHandler);
    public static void HttpStopCallsIntoManaged(IntPtr pInProcessApplication);
    public static void HttpStopIncomingRequests(IntPtr pInProcessApplication);
    public static void HttpDisableBuffering(IntPtr pInProcessApplication);
    public static void HttpSetResponseStatusCode(IntPtr pInProcessHandler, ushort statusCode, string pszReason);
    public static int HttpReadRequestBytes(IntPtr pInProcessHandler, Byte* pvBuffer, int cbBuffer, Int32& dwBytesReceived, Boolean& fCompletionExpected);
    public static void HttpGetCompletionInfo(IntPtr pCompletionInfo, Int32& cbBytes, Int32& hr);
    public static void HttpSetManagedContext(IntPtr pInProcessHandler, IntPtr pvManagedContext);
    public static IISConfigurationData HttpGetApplicationProperties();
    public static bool HttpTryGetServerVariable(IntPtr pInProcessHandler, string variableName, String& value);
    public static void HttpSetServerVariable(IntPtr pInProcessHandler, string variableName, string value);
    public static int HttpWebsocketsReadBytes(IntPtr pInProcessHandler, Byte* pvBuffer, int cbBuffer, PFN_WEBSOCKET_ASYNC_COMPLETION pfnCompletionCallback, IntPtr pvCompletionContext, Int32& dwBytesReceived, Boolean& fCompletionExpected);
    public static int HttpWebsocketsWriteBytes(IntPtr pInProcessHandler, HTTP_DATA_CHUNK* pDataChunks, int nChunks, PFN_WEBSOCKET_ASYNC_COMPLETION pfnCompletionCallback, IntPtr pvCompletionContext, Boolean& fCompletionExpected);
    public static void HttpEnableWebsockets(IntPtr pInProcessHandler);
    public static bool HttpTryCancelIO(IntPtr pInProcessHandler);
    public static void HttpCloseConnection(IntPtr pInProcessHandler);
    public static void HttpResponseSetUnknownHeader(IntPtr pInProcessHandler, Byte* pszHeaderName, Byte* pszHeaderValue, ushort usHeaderValueLength, bool fReplace);
    public static void HttpResponseSetKnownHeader(IntPtr pInProcessHandler, int headerId, Byte* pHeaderValue, ushort length, bool fReplace);
    public static void HttpGetAuthenticationInformation(IntPtr pInProcessHandler, String& authType, IntPtr& token);
    private static void Validate(int hr);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Buffers.DiagnosticMemoryPool : MemoryPool`1<byte> {
    private MemoryPool`1<byte> _pool;
    private bool _allowLateReturn;
    private bool _rentTracking;
    private object _syncObj;
    private HashSet`1<DiagnosticPoolBlock> _blocks;
    private List`1<Exception> _blockAccessExceptions;
    private TaskCompletionSource`1<object> _allBlocksReturned;
    private int _totalBlocks;
    private static int AnySize;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public int MaxBufferSize { get; }
    public DiagnosticMemoryPool(MemoryPool`1<byte> pool, bool allowLateReturn, bool rentTracking);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual IMemoryOwner`1<byte> Rent(int size);
    public virtual int get_MaxBufferSize();
    internal void Return(DiagnosticPoolBlock block);
    internal void ReportException(Exception exception);
    protected virtual void Dispose(bool disposing);
    private void SetAllBlocksReturned();
    private AggregateException CreateAccessExceptions();
    [AsyncStateMachineAttribute("System.Buffers.DiagnosticMemoryPool/<WhenAllBlocksReturnedAsync>d__22")]
public Task WhenAllBlocksReturnedAsync(TimeSpan timeout);
}
internal class System.Buffers.DiagnosticPoolBlock : MemoryManager`1<byte> {
    private DiagnosticMemoryPool _pool;
    private IMemoryOwner`1<byte> _memoryOwner;
    private Nullable`1<MemoryHandle> _memoryHandle;
    private Memory`1<byte> _memory;
    private object _syncObj;
    private bool _isDisposed;
    private int _pinCount;
    [CompilerGeneratedAttribute]
private StackTrace <Leaser>k__BackingField;
    public Memory`1<byte> Memory { get; }
    public StackTrace Leaser { get; public set; }
    internal DiagnosticPoolBlock(DiagnosticMemoryPool pool, IMemoryOwner`1<byte> memoryOwner);
    public virtual Memory`1<byte> get_Memory();
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<byte> GetSpan();
    public virtual MemoryHandle Pin(int byteOffset);
    protected virtual bool TryGetArray(ArraySegment`1& segment);
    public virtual void Unpin();
    [CompilerGeneratedAttribute]
public StackTrace get_Leaser();
    [CompilerGeneratedAttribute]
public void set_Leaser(StackTrace value);
    public void Track();
}
internal class System.Buffers.MemoryPoolBlock : object {
    private int _offset;
    private int _length;
    [CompilerGeneratedAttribute]
private SlabMemoryPool <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPoolSlab <Slab>k__BackingField;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <Memory>k__BackingField;
    public SlabMemoryPool Pool { get; }
    public MemoryPoolSlab Slab { get; }
    public Memory`1<byte> Memory { get; }
    internal MemoryPoolBlock(SlabMemoryPool pool, MemoryPoolSlab slab, int offset, int length);
    [CompilerGeneratedAttribute]
public SlabMemoryPool get_Pool();
    [CompilerGeneratedAttribute]
public MemoryPoolSlab get_Slab();
    [CompilerGeneratedAttribute]
public sealed virtual Memory`1<byte> get_Memory();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void Lease();
}
internal class System.Buffers.MemoryPoolSlab : object {
    private GCHandle _gcHandle;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IntPtr <NativePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Array>k__BackingField;
    public bool IsActive { get; }
    public IntPtr NativePointer { get; private set; }
    public Byte[] Array { get; private set; }
    public MemoryPoolSlab(Byte[] data);
    public bool get_IsActive();
    [CompilerGeneratedAttribute]
public IntPtr get_NativePointer();
    [CompilerGeneratedAttribute]
private void set_NativePointer(IntPtr value);
    [CompilerGeneratedAttribute]
public Byte[] get_Array();
    [CompilerGeneratedAttribute]
private void set_Array(Byte[] value);
    public static MemoryPoolSlab Create(int length);
    protected void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class System.Buffers.MemoryPoolThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(int sourceLength, int offset);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(int sourceLength, int offset);
    public static void ThrowInvalidOperationException_PinCountZero(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_ReturningPinnedBlock(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DoubleDispose();
    public static void ThrowInvalidOperationException_BlockDoubleDispose(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockReturnedToDisposedPool(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_BlockIsBackedByDisposedSlab(DiagnosticPoolBlock block);
    public static void ThrowInvalidOperationException_DisposingPoolWithActiveBlocks(int returned, int total, DiagnosticPoolBlock[] blocks);
    public static void ThrowInvalidOperationException_BlocksWereNotReturnedInTime(int returned, int total, DiagnosticPoolBlock[] blocks);
    private static string GenerateMessage(string message, DiagnosticPoolBlock[] blocks);
    public static void ThrowArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    public static void ThrowObjectDisposedException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException_BufferRequestTooLarge(int maxSize);
    private static ObjectDisposedException GetObjectDisposedException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
internal class System.Buffers.SlabMemoryPool : MemoryPool`1<byte> {
    private static int _blockSize;
    private static int _blockCount;
    [CompilerGeneratedAttribute]
private int <MaxBufferSize>k__BackingField;
    private static int _slabLength;
    private ConcurrentQueue`1<MemoryPoolBlock> _blocks;
    private ConcurrentStack`1<MemoryPoolSlab> _slabs;
    private bool _isDisposed;
    private int _totalAllocatedBlocks;
    private object _disposeSync;
    private static int AnySize;
    public int MaxBufferSize { get; }
    private static SlabMemoryPool();
    [CompilerGeneratedAttribute]
public virtual int get_MaxBufferSize();
    public virtual IMemoryOwner`1<byte> Rent(int size);
    private MemoryPoolBlock Lease();
    private MemoryPoolBlock AllocateSlab();
    internal void Return(MemoryPoolBlock block);
    protected virtual void Dispose(bool disposing);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
