internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.Bootstrapper : object {
    private static ILog Logger;
    private IPartitionSynchronizer synchronizer;
    private ILeaseStore leaseStore;
    private TimeSpan lockTime;
    private TimeSpan sleepTime;
    public Bootstrapper(IPartitionSynchronizer synchronizer, ILeaseStore leaseStore, TimeSpan lockTime, TimeSpan sleepTime);
    private static Bootstrapper();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.Bootstrapper/<InitializeAsync>d__6")]
public sealed virtual Task InitializeAsync();
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.IBootstrapper {
    public abstract virtual Task InitializeAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer : object {
    private static ILog Logger;
    private IChangeFeedDocumentClient documentClient;
    private string collectionSelfLink;
    private ILeaseContainer leaseContainer;
    private ILeaseManager leaseManager;
    private int degreeOfParallelism;
    private int maxBatchSize;
    public PartitionSynchronizer(IChangeFeedDocumentClient documentClient, string collectionSelfLink, ILeaseContainer leaseContainer, ILeaseManager leaseManager, int degreeOfParallelism, int maxBatchSize);
    private static PartitionSynchronizer();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer/<CreateMissingLeasesAsync>d__8")]
public sealed virtual Task CreateMissingLeasesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer/<SplitPartitionAsync>d__9")]
public sealed virtual Task`1<IEnumerable`1<ILease>> SplitPartitionAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer/<EnumPartitionKeyRangesAsync>d__10")]
private Task`1<List`1<PartitionKeyRange>> EnumPartitionKeyRangesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer/<CreateLeasesAsync>d__11")]
private Task CreateLeasesAsync(HashSet`1<string> partitionIds);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Bootstrapping.PartitionSynchronizer/<<CreateLeasesAsync>b__11_1>d")]
[CompilerGeneratedAttribute]
private Task <CreateLeasesAsync>b__11_1(string addedRangeId);
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder class and use the BuildAsync method for building the change feed processor host or the BuildEstimatorAsync method for building the remaining work estimator.")]
public class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost : object {
    private static TraceLogProvider TraceLogProvider;
    private ChangeFeedProcessorBuilder builder;
    private IChangeFeedProcessor processor;
    private IRemainingWorkEstimator remainingWorkEstimator;
    public string HostName { get; }
    private static ChangeFeedEventHost();
    public ChangeFeedEventHost(string hostName, DocumentCollectionInfo documentCollectionLocation, DocumentCollectionInfo leaseCollectionLocation);
    public ChangeFeedEventHost(string hostName, DocumentCollectionInfo feedCollectionLocation, DocumentCollectionInfo leaseCollectionLocation, ChangeFeedHostOptions changeFeedHostOptions);
    public ChangeFeedEventHost(string hostName, DocumentCollectionInfo feedCollectionLocation, DocumentCollectionInfo leaseCollectionLocation, ChangeFeedOptions changeFeedOptions, ChangeFeedHostOptions changeFeedHostOptions);
    public string get_HostName();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost/<RegisterObserverAsync>d__10`1")]
public Task RegisterObserverAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost/<RegisterObserverFactoryAsync>d__11")]
public Task RegisterObserverFactoryAsync(IChangeFeedObserverFactory factory);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost/<UnregisterObserversAsync>d__12")]
public Task UnregisterObserversAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost/<GetEstimatedRemainingWork>d__13")]
public Task`1<long> GetEstimatedRemainingWork();
    internal static ChangeFeedProcessorOptions CreateProcessorOptions(ChangeFeedOptions feedOptions, ChangeFeedHostOptions hostOptions);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedEventHost/<CreateHost>d__15")]
private Task CreateHost();
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder class and use its WithChangeFeedProcessorOptions method to pass the options.")]
public class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedHostOptions : object {
    private static int DefaultQueryPartitionsMaxBatchSize;
    private static TimeSpan DefaultRenewInterval;
    private static TimeSpan DefaultAcquireInterval;
    private static TimeSpan DefaultExpirationInterval;
    private static TimeSpan DefaultFeedPollDelay;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseRenewInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseAcquireInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseExpirationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FeedPollDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckpointFrequency <CheckpointFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeasePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinPartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardExistingLeases>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryPartitionsMaxBatchSize>k__BackingField;
    public TimeSpan LeaseRenewInterval { get; public set; }
    public TimeSpan LeaseAcquireInterval { get; public set; }
    public TimeSpan LeaseExpirationInterval { get; public set; }
    public TimeSpan FeedPollDelay { get; public set; }
    public CheckpointFrequency CheckpointFrequency { get; public set; }
    public string LeasePrefix { get; public set; }
    [ObsoleteAttribute("IsAutoCheckpointEnabled is deprecated, please use CheckpointFrequency.ExplicitCheckpoint instead.")]
public bool IsAutoCheckpointEnabled { get; public set; }
    internal int MinPartitionCount { get; internal set; }
    internal int MaxPartitionCount { get; internal set; }
    internal bool DiscardExistingLeases { get; internal set; }
    internal int QueryPartitionsMaxBatchSize { get; internal set; }
    private static ChangeFeedHostOptions();
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseRenewInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseRenewInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseAcquireInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseAcquireInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseExpirationInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseExpirationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_FeedPollDelay();
    [CompilerGeneratedAttribute]
public void set_FeedPollDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public CheckpointFrequency get_CheckpointFrequency();
    [CompilerGeneratedAttribute]
public void set_CheckpointFrequency(CheckpointFrequency value);
    [CompilerGeneratedAttribute]
public string get_LeasePrefix();
    [CompilerGeneratedAttribute]
public void set_LeasePrefix(string value);
    public bool get_IsAutoCheckpointEnabled();
    public void set_IsAutoCheckpointEnabled(bool value);
    [CompilerGeneratedAttribute]
internal int get_MinPartitionCount();
    [CompilerGeneratedAttribute]
internal void set_MinPartitionCount(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxPartitionCount();
    [CompilerGeneratedAttribute]
internal void set_MaxPartitionCount(int value);
    [CompilerGeneratedAttribute]
internal bool get_DiscardExistingLeases();
    [CompilerGeneratedAttribute]
internal void set_DiscardExistingLeases(bool value);
    [CompilerGeneratedAttribute]
internal int get_QueryPartitionsMaxBatchSize();
    [CompilerGeneratedAttribute]
internal void set_QueryPartitionsMaxBatchSize(int value);
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder for building the change feed processor and use new enum Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedObserverCloseReason.")]
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedObserverCloseReason : Enum {
    public int value__;
    public static ChangeFeedObserverCloseReason Unknown;
    public static ChangeFeedObserverCloseReason Shutdown;
    public static ChangeFeedObserverCloseReason ResourceGone;
    public static ChangeFeedObserverCloseReason LeaseLost;
    public static ChangeFeedObserverCloseReason ObserverError;
    public static ChangeFeedObserverCloseReason LeaseGone;
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder for building the change feed processor and use new interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserverContext.")]
public abstract class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedObserverContext : object {
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeedResponse`1<Document> <FeedResponse>k__BackingField;
    public string PartitionKeyRangeId { get; protected set; }
    public IFeedResponse`1<Document> FeedResponse { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
protected void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public IFeedResponse`1<Document> get_FeedResponse();
    [CompilerGeneratedAttribute]
protected void set_FeedResponse(IFeedResponse`1<Document> value);
    public abstract virtual Task CheckpointAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessor : object {
    private static ILog Logger;
    private IPartitionManager partitionManager;
    public ChangeFeedProcessor(IPartitionManager partitionManager);
    private static ChangeFeedProcessor();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessor/<StartAsync>d__3")]
public sealed virtual Task StartAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessor/<StopAsync>d__4")]
public sealed virtual Task StopAsync();
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder : object {
    internal static string IdPkPathName;
    internal static string PartitionKeyPkPathName;
    private static ILog Logger;
    private static long DefaultUnhealthinessDuration;
    private TimeSpan sleepTime;
    private TimeSpan lockTime;
    private DocumentCollectionInfo feedCollectionLocation;
    private ChangeFeedProcessorOptions changeFeedProcessorOptions;
    private IChangeFeedDocumentClient feedDocumentClient;
    private IChangeFeedObserverFactory observerFactory;
    private string databaseResourceId;
    private string collectionResourceId;
    private DocumentCollectionInfo leaseCollectionLocation;
    private IChangeFeedDocumentClient leaseDocumentClient;
    private IParitionLoadBalancingStrategy loadBalancingStrategy;
    private IPartitionProcessorFactory partitionProcessorFactory;
    private ICheckpointPartitionProcessorFactory checkpointPartitionProcessorFactory;
    private IHealthMonitor healthMonitor;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private ILeaseStoreManager <LeaseStoreManager>k__BackingField;
    internal string HostName { get; private set; }
    internal ILeaseStoreManager LeaseStoreManager { get; private set; }
    private static ChangeFeedProcessorBuilder();
    [CompilerGeneratedAttribute]
internal string get_HostName();
    [CompilerGeneratedAttribute]
private void set_HostName(string value);
    [CompilerGeneratedAttribute]
internal ILeaseStoreManager get_LeaseStoreManager();
    [CompilerGeneratedAttribute]
private void set_LeaseStoreManager(ILeaseStoreManager value);
    public ChangeFeedProcessorBuilder WithHostName(string hostName);
    public ChangeFeedProcessorBuilder WithFeedCollection(DocumentCollectionInfo feedCollectionLocation);
    public ChangeFeedProcessorBuilder WithFeedDocumentClient(DocumentClient feedDocumentClient);
    public ChangeFeedProcessorBuilder WithFeedDocumentClient(IChangeFeedDocumentClient feedDocumentClient);
    public ChangeFeedProcessorBuilder WithProcessorOptions(ChangeFeedProcessorOptions changeFeedProcessorOptions);
    public ChangeFeedProcessorBuilder WithObserverFactory(IChangeFeedObserverFactory observerFactory);
    public ChangeFeedProcessorBuilder WithObserver();
    public ChangeFeedProcessorBuilder WithDatabaseResourceId(string databaseResourceId);
    public ChangeFeedProcessorBuilder WithCollectionResourceId(string collectionResourceId);
    public ChangeFeedProcessorBuilder WithLeaseCollection(DocumentCollectionInfo leaseCollectionLocation);
    public ChangeFeedProcessorBuilder WithLeaseDocumentClient(DocumentClient leaseDocumentClient);
    public ChangeFeedProcessorBuilder WithLeaseDocumentClient(IChangeFeedDocumentClient leaseDocumentClient);
    public ChangeFeedProcessorBuilder WithPartitionLoadBalancingStrategy(IParitionLoadBalancingStrategy strategy);
    public ChangeFeedProcessorBuilder WithPartitionProcessorFactory(IPartitionProcessorFactory partitionProcessorFactory);
    public ChangeFeedProcessorBuilder WithCheckpointPartitionProcessorFactory(ICheckpointPartitionProcessorFactory partitionProcessorFactory);
    public ChangeFeedProcessorBuilder WithLeaseStoreManager(ILeaseStoreManager leaseStoreManager);
    public ChangeFeedProcessorBuilder WithHealthMonitor(IHealthMonitor healthMonitor);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<BuildAsync>d__43")]
public Task`1<IChangeFeedProcessor> BuildAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<BuildEstimatorAsync>d__44")]
public Task`1<IRemainingWorkEstimator> BuildEstimatorAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<GetDatabaseResourceIdAsync>d__45")]
private static Task`1<string> GetDatabaseResourceIdAsync(IChangeFeedDocumentClient documentClient, DocumentCollectionInfo collectionLocation);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<GetCollectionResourceIdAsync>d__46")]
private static Task`1<string> GetCollectionResourceIdAsync(IChangeFeedDocumentClient documentClient, DocumentCollectionInfo collectionLocation);
    private IPartitionManager BuildPartitionManager(ILeaseStoreManager leaseStoreManager);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<GetLeaseStoreManagerAsync>d__48")]
private Task`1<ILeaseStoreManager> GetLeaseStoreManagerAsync(DocumentCollectionInfo collectionInfo);
    private string GetLeasePrefix();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorBuilder/<InitializeCollectionPropertiesForBuildAsync>d__50")]
private Task InitializeCollectionPropertiesForBuildAsync();
    private ICheckpointPartitionProcessorFactory GetPartitionProcessorFactory(string feedCollectionSelfLink);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.ChangeFeedProcessorOptions : object {
    private static int DefaultQueryPartitionsMaxBatchSize;
    private static TimeSpan DefaultRenewInterval;
    private static TimeSpan DefaultAcquireInterval;
    private static TimeSpan DefaultExpirationInterval;
    private static TimeSpan DefaultFeedPollDelay;
    private static TimeSpan DefaultFeedTimeout;
    private Nullable`1<DateTime> startTime;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseRenewInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseAcquireInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseExpirationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FeedPollDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckpointFrequency <CheckpointFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeasePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartContinuation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartFromBeginning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ChangeFeedTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinPartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardExistingLeases>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryPartitionsMaxBatchSize>k__BackingField;
    public TimeSpan LeaseRenewInterval { get; public set; }
    public TimeSpan LeaseAcquireInterval { get; public set; }
    public TimeSpan LeaseExpirationInterval { get; public set; }
    public TimeSpan FeedPollDelay { get; public set; }
    public CheckpointFrequency CheckpointFrequency { get; public set; }
    public string LeasePrefix { get; public set; }
    public Nullable`1<int> MaxItemCount { get; public set; }
    public string StartContinuation { get; public set; }
    public Nullable`1<DateTime> StartTime { get; public set; }
    public bool StartFromBeginning { get; public set; }
    public string SessionToken { get; public set; }
    public TimeSpan ChangeFeedTimeout { get; public set; }
    internal int MinPartitionCount { get; internal set; }
    internal int MaxPartitionCount { get; internal set; }
    internal bool DiscardExistingLeases { get; internal set; }
    internal int QueryPartitionsMaxBatchSize { get; internal set; }
    internal int DegreeOfParallelism { get; }
    private static ChangeFeedProcessorOptions();
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseRenewInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseRenewInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseAcquireInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseAcquireInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseExpirationInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseExpirationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_FeedPollDelay();
    [CompilerGeneratedAttribute]
public void set_FeedPollDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public CheckpointFrequency get_CheckpointFrequency();
    [CompilerGeneratedAttribute]
public void set_CheckpointFrequency(CheckpointFrequency value);
    [CompilerGeneratedAttribute]
public string get_LeasePrefix();
    [CompilerGeneratedAttribute]
public void set_LeasePrefix(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxItemCount();
    [CompilerGeneratedAttribute]
public void set_MaxItemCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_StartContinuation();
    [CompilerGeneratedAttribute]
public void set_StartContinuation(string value);
    public Nullable`1<DateTime> get_StartTime();
    public void set_StartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_StartFromBeginning();
    [CompilerGeneratedAttribute]
public void set_StartFromBeginning(bool value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ChangeFeedTimeout();
    [CompilerGeneratedAttribute]
public void set_ChangeFeedTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
internal int get_MinPartitionCount();
    [CompilerGeneratedAttribute]
internal void set_MinPartitionCount(int value);
    [CompilerGeneratedAttribute]
internal int get_MaxPartitionCount();
    [CompilerGeneratedAttribute]
internal void set_MaxPartitionCount(int value);
    [CompilerGeneratedAttribute]
internal bool get_DiscardExistingLeases();
    [CompilerGeneratedAttribute]
internal void set_DiscardExistingLeases(bool value);
    [CompilerGeneratedAttribute]
internal int get_QueryPartitionsMaxBatchSize();
    [CompilerGeneratedAttribute]
internal void set_QueryPartitionsMaxBatchSize(int value);
    internal int get_DegreeOfParallelism();
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.CheckpointFrequency : object {
    [CompilerGeneratedAttribute]
private bool <ExplicitCheckpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProcessedDocumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeInterval>k__BackingField;
    public bool ExplicitCheckpoint { get; public set; }
    public Nullable`1<int> ProcessedDocumentCount { get; public set; }
    public Nullable`1<TimeSpan> TimeInterval { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ExplicitCheckpoint();
    [CompilerGeneratedAttribute]
public void set_ExplicitCheckpoint(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProcessedDocumentCount();
    [CompilerGeneratedAttribute]
public void set_ProcessedDocumentCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_TimeInterval();
    [CompilerGeneratedAttribute]
public void set_TimeInterval(Nullable`1<TimeSpan> value);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient : object {
    private DocumentClient documentClient;
    public ChangeFeedDocumentClient(DocumentClient documentClient);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<ReadPartitionKeyRangeFeedAsync>d__2")]
public sealed virtual Task`1<IFeedResponse`1<PartitionKeyRange>> ReadPartitionKeyRangeFeedAsync(string partitionKeyRangesOrCollectionLink, FeedOptions options);
    public sealed virtual IChangeFeedDocumentQuery`1<Document> CreateDocumentChangeFeedQuery(string collectionLink, ChangeFeedOptions feedOptions);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<ReadDatabaseAsync>d__4")]
public sealed virtual Task`1<IResourceResponse`1<Database>> ReadDatabaseAsync(Uri databaseUri, RequestOptions options);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<ReadDocumentCollectionAsync>d__5")]
public sealed virtual Task`1<IResourceResponse`1<DocumentCollection>> ReadDocumentCollectionAsync(Uri documentCollectionUri, RequestOptions options);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<CreateDocumentAsync>d__6")]
public sealed virtual Task`1<IResourceResponse`1<Document>> CreateDocumentAsync(string documentsFeedOrDatabaseLink, object document, RequestOptions options, bool disableAutomaticIdGeneration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<DeleteDocumentAsync>d__7")]
public sealed virtual Task`1<IResourceResponse`1<Document>> DeleteDocumentAsync(Uri documentUri, RequestOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<ReplaceDocumentAsync>d__8")]
public sealed virtual Task`1<IResourceResponse`1<Document>> ReplaceDocumentAsync(Uri documentUri, object document, RequestOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentClient/<ReadDocumentAsync>d__9")]
public sealed virtual Task`1<IResourceResponse`1<Document>> ReadDocumentAsync(Uri documentUri, RequestOptions options, CancellationToken cancellationToken);
    public sealed virtual IQueryable`1<T> CreateDocumentQuery(string documentCollectionUri, SqlQuerySpec querySpec, FeedOptions feedOptions);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentQuery`1 : object {
    private IDocumentQuery`1<T> query;
    public bool HasMoreResults { get; }
    public ChangeFeedDocumentQuery`1(IDocumentQuery`1<T> query);
    public sealed virtual bool get_HasMoreResults();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.ChangeFeedDocumentQuery`1/<ExecuteNextAsync>d__5`1")]
public sealed virtual Task`1<IFeedResponse`1<TResult>> ExecuteNextAsync(CancellationToken token);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.IChangeFeedDocumentClient {
    public abstract virtual Task`1<IFeedResponse`1<PartitionKeyRange>> ReadPartitionKeyRangeFeedAsync(string partitionKeyRangesOrCollectionLink, FeedOptions options);
    public abstract virtual IChangeFeedDocumentQuery`1<Document> CreateDocumentChangeFeedQuery(string collectionLink, ChangeFeedOptions feedOptions);
    public abstract virtual Task`1<IResourceResponse`1<Database>> ReadDatabaseAsync(Uri databaseUri, RequestOptions options);
    public abstract virtual Task`1<IResourceResponse`1<DocumentCollection>> ReadDocumentCollectionAsync(Uri documentCollectionUri, RequestOptions options);
    public abstract virtual Task`1<IResourceResponse`1<Document>> CreateDocumentAsync(string collectionLink, object document, RequestOptions options, bool disableAutomaticIdGeneration, CancellationToken cancellationToken);
    public abstract virtual Task`1<IResourceResponse`1<Document>> DeleteDocumentAsync(Uri documentUri, RequestOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<IResourceResponse`1<Document>> ReplaceDocumentAsync(Uri documentUri, object document, RequestOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<IResourceResponse`1<Document>> ReadDocumentAsync(Uri documentUri, RequestOptions options, CancellationToken cancellationToken);
    public abstract virtual IQueryable`1<T> CreateDocumentQuery(string documentCollectionUri, SqlQuerySpec querySpec, FeedOptions feedOptions);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.DataAccess.IChangeFeedDocumentQuery`1 {
    public bool HasMoreResults { get; }
    public abstract virtual bool get_HasMoreResults();
    public abstract virtual Task`1<IFeedResponse`1<TResult>> ExecuteNextAsync(CancellationToken token);
}
internal enum Microsoft.Azure.Documents.ChangeFeedProcessor.DocDBErrors.DocDbError : Enum {
    public int value__;
    public static DocDbError Undefined;
    public static DocDbError PartitionNotFound;
    public static DocDbError PartitionSplit;
    public static DocDbError TransientError;
    public static DocDbError MaxItemCountTooLarge;
    public static DocDbError ReadSessionNotAvailable;
}
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.DocDBErrors.ExceptionClassifier : object {
    public static DocDbError ClassifyClientException(DocumentClientException clientException);
}
internal enum Microsoft.Azure.Documents.ChangeFeedProcessor.DocDBErrors.SubStatusCode : Enum {
    public int value__;
    public static SubStatusCode Undefined;
    public static SubStatusCode PartitionKeyRangeGone;
    public static SubStatusCode Splitting;
    public static SubStatusCode ReadSessionNotAvailable;
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.DocDBErrors.SubStatusHelpers : object {
    [ExtensionAttribute]
public static SubStatusCode GetSubStatusCode(DocumentClientException exception);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.DocumentCollectionInfo : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MasterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsistencyLevel> <ConsistencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionPolicy <ConnectionPolicy>k__BackingField;
    public Uri Uri { get; public set; }
    public string MasterKey { get; public set; }
    public string DatabaseName { get; public set; }
    public string CollectionName { get; public set; }
    public Nullable`1<ConsistencyLevel> ConsistencyLevel { get; public set; }
    public ConnectionPolicy ConnectionPolicy { get; public set; }
    public DocumentCollectionInfo(DocumentCollectionInfo other);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public string get_MasterKey();
    [CompilerGeneratedAttribute]
public void set_MasterKey(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsistencyLevel> get_ConsistencyLevel();
    [CompilerGeneratedAttribute]
public void set_ConsistencyLevel(Nullable`1<ConsistencyLevel> value);
    [CompilerGeneratedAttribute]
public ConnectionPolicy get_ConnectionPolicy();
    [CompilerGeneratedAttribute]
public void set_ConnectionPolicy(ConnectionPolicy value);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.LeaseLostException : Exception {
    private static string DefaultMessage;
    [CompilerGeneratedAttribute]
private ILease <Lease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGone>k__BackingField;
    public ILease Lease { get; }
    public bool IsGone { get; }
    public LeaseLostException(ILease lease);
    public LeaseLostException(string message);
    public LeaseLostException(string message, Exception innerException);
    public LeaseLostException(ILease lease, Exception innerException, bool isGone);
    protected LeaseLostException(SerializationInfo info, StreamingContext context);
    private static LeaseLostException();
    [CompilerGeneratedAttribute]
public ILease get_Lease();
    [CompilerGeneratedAttribute]
public bool get_IsGone();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.ObserverException : Exception {
    private static string DefaultMessage;
    public ObserverException(Exception originalException);
    protected ObserverException(SerializationInfo info, StreamingContext context);
    private static ObserverException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.PartitionException : Exception {
    [CompilerGeneratedAttribute]
private string <LastContinuation>k__BackingField;
    public string LastContinuation { get; }
    protected PartitionException(string message, string lastContinuation);
    protected PartitionException(string message, string lastContinuation, Exception innerException);
    protected PartitionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_LastContinuation();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.PartitionNotFoundException : PartitionException {
    public PartitionNotFoundException(string message, string lastContinuation);
    public PartitionNotFoundException(string message, string lastContinuation, Exception innerException);
    protected PartitionNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.PartitionSplitException : PartitionException {
    public PartitionSplitException(string message, string lastContinuation);
    protected PartitionSplitException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Exceptions.ReadSessionNotAvailableException : PartitionException {
    public ReadSessionNotAvailableException(string message, string lastContinuation);
    public ReadSessionNotAvailableException(string message, string lastContinuation, Exception innerException);
    protected ReadSessionNotAvailableException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.Adapters.CheckpointPartitionProcessorFactoryAdapter : object {
    private IPartitionProcessorFactory partitionProcessorFactory;
    public CheckpointPartitionProcessorFactoryAdapter(IPartitionProcessorFactory partitionProcessorFactory);
    public sealed virtual IPartitionProcessor Create(ILease lease, ILeaseCheckpointer leaseCheckpointer, IChangeFeedObserver observer);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.AutoCheckpointer : object {
    private CheckpointFrequency checkpointFrequency;
    private IChangeFeedObserver observer;
    private int processedDocCount;
    private DateTime lastCheckpointTime;
    public AutoCheckpointer(CheckpointFrequency checkpointFrequency, IChangeFeedObserver observer);
    public sealed virtual Task OpenAsync(IChangeFeedObserverContext context);
    public sealed virtual Task CloseAsync(IChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.AutoCheckpointer/<ProcessChangesAsync>d__7")]
public sealed virtual Task ProcessChangesAsync(IChangeFeedObserverContext context, IReadOnlyList`1<Document> docs, CancellationToken cancellationToken);
    private bool IsCheckpointNeeded();
}
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedObserverCloseReason : Enum {
    public int value__;
    public static ChangeFeedObserverCloseReason Unknown;
    public static ChangeFeedObserverCloseReason Shutdown;
    public static ChangeFeedObserverCloseReason ResourceGone;
    public static ChangeFeedObserverCloseReason LeaseLost;
    public static ChangeFeedObserverCloseReason ObserverError;
    public static ChangeFeedObserverCloseReason LeaseGone;
    public static ChangeFeedObserverCloseReason ReadSessionNotAvailable;
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedObserverContext : object {
    private IPartitionCheckpointer checkpointer;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeedResponse`1<Document> <FeedResponse>k__BackingField;
    public string PartitionKeyRangeId { get; }
    public IFeedResponse`1<Document> FeedResponse { get; }
    internal ChangeFeedObserverContext(string partitionId);
    internal ChangeFeedObserverContext(string partitionId, IFeedResponse`1<Document> feedResponse, IPartitionCheckpointer checkpointer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public sealed virtual IFeedResponse`1<Document> get_FeedResponse();
    public virtual Task CheckpointAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedObserverFactory`1 : object {
    public sealed virtual IChangeFeedObserver CreateObserver();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedQueryTimeoutDecorator : object {
    private IChangeFeedDocumentQuery`1<Document> query;
    private IHealthMonitor monitor;
    private ILease lease;
    private TimeSpan timeout;
    public bool HasMoreResults { get; }
    public ChangeFeedQueryTimeoutDecorator(IChangeFeedDocumentQuery`1<Document> query, IHealthMonitor monitor, TimeSpan timeout, ILease lease);
    public sealed virtual bool get_HasMoreResults();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ChangeFeedQueryTimeoutDecorator/<ExecuteNextAsync>d__7`1")]
public sealed virtual Task`1<IFeedResponse`1<TResult>> ExecuteNextAsync(CancellationToken token);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.CheckpointerObserverFactory : object {
    private IChangeFeedObserverFactory observerFactory;
    private CheckpointFrequency checkpointFrequency;
    public CheckpointerObserverFactory(IChangeFeedObserverFactory observerFactory, CheckpointFrequency checkpointFrequency);
    public sealed virtual IChangeFeedObserver CreateObserver();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserver {
    public abstract virtual Task OpenAsync(IChangeFeedObserverContext context);
    public abstract virtual Task CloseAsync(IChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    public abstract virtual Task ProcessChangesAsync(IChangeFeedObserverContext context, IReadOnlyList`1<Document> docs, CancellationToken cancellationToken);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserverContext {
    public string PartitionKeyRangeId { get; }
    public IFeedResponse`1<Document> FeedResponse { get; }
    public abstract virtual string get_PartitionKeyRangeId();
    public abstract virtual IFeedResponse`1<Document> get_FeedResponse();
    public abstract virtual Task CheckpointAsync();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserverFactory {
    public abstract virtual IChangeFeedObserver CreateObserver();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ICheckpointPartitionProcessorFactory {
    public abstract virtual IPartitionProcessor Create(ILease lease, ILeaseCheckpointer leaseCheckpointer, IChangeFeedObserver observer);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IPartitionProcessor {
    public abstract virtual Task RunAsync(CancellationToken cancellationToken);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IPartitionProcessorFactory {
    public abstract virtual IPartitionProcessor Create(ILease lease, IChangeFeedObserver observer);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ObserverExceptionWrappingChangeFeedObserverDecorator : object {
    private static ILog Logger;
    private IChangeFeedObserver changeFeedObserver;
    public ObserverExceptionWrappingChangeFeedObserverDecorator(IChangeFeedObserver changeFeedObserver);
    private static ObserverExceptionWrappingChangeFeedObserverDecorator();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ObserverExceptionWrappingChangeFeedObserverDecorator/<CloseAsync>d__3")]
public sealed virtual Task CloseAsync(IChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ObserverExceptionWrappingChangeFeedObserverDecorator/<OpenAsync>d__4")]
public sealed virtual Task OpenAsync(IChangeFeedObserverContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ObserverExceptionWrappingChangeFeedObserverDecorator/<ProcessChangesAsync>d__5")]
public sealed virtual Task ProcessChangesAsync(IChangeFeedObserverContext context, IReadOnlyList`1<Document> docs, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.PartitionProcessor : object {
    private static int DefaultMaxItemCount;
    private ILog logger;
    private IChangeFeedDocumentQuery`1<Document> query;
    private ProcessorSettings settings;
    private IPartitionCheckpointer checkpointer;
    private IChangeFeedObserver observer;
    private ChangeFeedOptions options;
    public PartitionProcessor(IChangeFeedObserver observer, IChangeFeedDocumentQuery`1<Document> query, ChangeFeedOptions options, ProcessorSettings settings, IPartitionCheckpointer checkpointer);
    private static PartitionProcessor();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.PartitionProcessor/<RunAsync>d__8")]
public sealed virtual Task RunAsync(CancellationToken cancellationToken);
    private Task DispatchChanges(IFeedResponse`1<Document> response, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.PartitionProcessorFactory : object {
    private IChangeFeedDocumentClient documentClient;
    private ChangeFeedProcessorOptions changeFeedProcessorOptions;
    private string collectionSelfLink;
    private IHealthMonitor healthMonitor;
    public PartitionProcessorFactory(IChangeFeedDocumentClient documentClient, ChangeFeedProcessorOptions changeFeedProcessorOptions, string collectionSelfLink, IHealthMonitor healthMonitor);
    public sealed virtual IPartitionProcessor Create(ILease lease, ILeaseCheckpointer leaseCheckpointer, IChangeFeedObserver observer);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.ProcessorSettings : object {
    [CompilerGeneratedAttribute]
private string <CollectionSelfLink>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FeedPollDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartContinuation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartFromBeginning>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    public string CollectionSelfLink { get; public set; }
    public string PartitionKeyRangeId { get; public set; }
    public Nullable`1<int> MaxItemCount { get; public set; }
    public TimeSpan FeedPollDelay { get; public set; }
    public string StartContinuation { get; public set; }
    public bool StartFromBeginning { get; public set; }
    public Nullable`1<DateTime> StartTime { get; public set; }
    public string SessionToken { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CollectionSelfLink();
    [CompilerGeneratedAttribute]
public void set_CollectionSelfLink(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public void set_PartitionKeyRangeId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxItemCount();
    [CompilerGeneratedAttribute]
public void set_MaxItemCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_FeedPollDelay();
    [CompilerGeneratedAttribute]
public void set_FeedPollDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_StartContinuation();
    [CompilerGeneratedAttribute]
public void set_StartContinuation(string value);
    [CompilerGeneratedAttribute]
public bool get_StartFromBeginning();
    [CompilerGeneratedAttribute]
public void set_StartFromBeginning(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.HealthMonitoringPartitionControllerDecorator : object {
    private IPartitionController inner;
    private IHealthMonitor monitor;
    public HealthMonitoringPartitionControllerDecorator(IPartitionController inner, IHealthMonitor monitor);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.HealthMonitoringPartitionControllerDecorator/<AddOrUpdateLeaseAsync>d__3")]
public sealed virtual Task AddOrUpdateLeaseAsync(ILease lease);
    public sealed virtual Task InitializeAsync();
    public sealed virtual Task ShutdownAsync();
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder for building the change feed processor and use new interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserver with cancellation token support.")]
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.IChangeFeedObserver {
    public abstract virtual Task OpenAsync(ChangeFeedObserverContext context);
    public abstract virtual Task CloseAsync(ChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    public abstract virtual Task ProcessChangesAsync(ChangeFeedObserverContext context, IReadOnlyList`1<Document> docs);
}
[ObsoleteAttribute("Switch to the ChangeFeedProcessorBuilder for building the change feed processor host and use new interface Microsoft.Azure.Documents.ChangeFeedProcessor.FeedProcessing.IChangeFeedObserverFactory.")]
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.IChangeFeedObserverFactory {
    public abstract virtual IChangeFeedObserver CreateObserver();
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.IPartitionCheckpointer {
    public abstract virtual Task CheckpointPartitionAsync(string сontinuationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLease : object {
    internal static string IdPropertyName;
    internal static string LeasePartitionKeyPropertyName;
    private static DateTime UnixStartTime;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private LeaseAcquireReason <AcquireReason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExplicitTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TS>k__BackingField;
    [JsonPropertyAttribute("id")]
public string Id { get; public set; }
    [JsonPropertyAttribute]
public string PartitionKey { get; public set; }
    [JsonPropertyAttribute("_etag")]
public string ETag { get; public set; }
    [JsonPropertyAttribute("PartitionId")]
public string PartitionId { get; public set; }
    [JsonPropertyAttribute("Owner")]
public string Owner { get; public set; }
    [JsonPropertyAttribute("ContinuationToken")]
public string ContinuationToken { get; public set; }
    [JsonIgnoreAttribute]
public DateTime Timestamp { get; public set; }
    [JsonIgnoreAttribute]
public string ConcurrencyToken { get; }
    [JsonPropertyAttribute("properties")]
public Dictionary`2<string, string> Properties { get; public set; }
    [JsonIgnoreAttribute]
public LeaseAcquireReason AcquireReason { get; public set; }
    [JsonPropertyAttribute("timestamp")]
private Nullable`1<DateTime> ExplicitTimestamp { get; private set; }
    [JsonPropertyAttribute("_ts")]
private long TS { get; private set; }
    [JsonPropertyAttribute]
unknown string LeaseToken {private set; }
    public DocumentServiceLease(DocumentServiceLease other);
    private static DocumentServiceLease();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public string get_ETag();
    [CompilerGeneratedAttribute]
public void set_ETag(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PartitionId();
    [CompilerGeneratedAttribute]
public void set_PartitionId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Owner(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContinuationToken(string value);
    public sealed virtual DateTime get_Timestamp();
    public sealed virtual void set_Timestamp(DateTime value);
    public sealed virtual string get_ConcurrencyToken();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual LeaseAcquireReason get_AcquireReason();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AcquireReason(LeaseAcquireReason value);
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> get_ExplicitTimestamp();
    [CompilerGeneratedAttribute]
private void set_ExplicitTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
private long get_TS();
    [CompilerGeneratedAttribute]
private void set_TS(long value);
    private void set_LeaseToken(string value);
    public static DocumentServiceLease FromDocument(Document document);
    public virtual string ToString();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStore : object {
    private IChangeFeedDocumentClient client;
    private DocumentCollectionInfo leaseStoreCollectionInfo;
    private string containerNamePrefix;
    private string leaseCollectionLink;
    private IRequestOptionsFactory requestOptionsFactory;
    private string lockETag;
    public DocumentServiceLeaseStore(IChangeFeedDocumentClient client, DocumentCollectionInfo leaseCollectionInfo, string containerNamePrefix, string leaseCollectionLink, IRequestOptionsFactory requestOptionsFactory);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStore/<IsInitializedAsync>d__7")]
public sealed virtual Task`1<bool> IsInitializedAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStore/<MarkInitializedAsync>d__8")]
public sealed virtual Task MarkInitializedAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStore/<AcquireInitializationLockAsync>d__9")]
public sealed virtual Task`1<bool> AcquireInitializationLockAsync(TimeSpan lockTime);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStore/<ReleaseInitializationLockAsync>d__10")]
public sealed virtual Task`1<bool> ReleaseInitializationLockAsync();
    private string GetStoreMarkerName();
    private string GetStoreLockName();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager : object {
    private static ILog Logger;
    private DocumentServiceLeaseStoreManagerSettings settings;
    private IChangeFeedDocumentClient client;
    private IRequestOptionsFactory requestOptionsFactory;
    private IDocumentServiceLeaseUpdater leaseUpdater;
    private ILeaseStore leaseStore;
    public DocumentServiceLeaseStoreManager(DocumentServiceLeaseStoreManagerSettings settings, IChangeFeedDocumentClient leaseDocumentClient, IRequestOptionsFactory requestOptionsFactory);
    internal DocumentServiceLeaseStoreManager(DocumentServiceLeaseStoreManagerSettings settings, IChangeFeedDocumentClient leaseDocumentClient, IRequestOptionsFactory requestOptionsFactory, IDocumentServiceLeaseUpdater leaseUpdater);
    private static DocumentServiceLeaseStoreManager();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<GetAllLeasesAsync>d__8")]
public sealed virtual Task`1<IReadOnlyList`1<ILease>> GetAllLeasesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<GetOwnedLeasesAsync>d__9")]
public sealed virtual Task`1<IEnumerable`1<ILease>> GetOwnedLeasesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<CreateLeaseIfNotExistAsync>d__10")]
public sealed virtual Task`1<ILease> CreateLeaseIfNotExistAsync(string partitionId, string continuationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<CheckpointAsync>d__11")]
public sealed virtual Task`1<ILease> CheckpointAsync(ILease lease, string continuationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<AcquireAsync>d__12")]
public sealed virtual Task`1<ILease> AcquireAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<RenewAsync>d__13")]
public sealed virtual Task`1<ILease> RenewAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<ReleaseAsync>d__14")]
public sealed virtual Task ReleaseAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<DeleteAsync>d__15")]
public sealed virtual Task DeleteAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<UpdatePropertiesAsync>d__16")]
public sealed virtual Task`1<ILease> UpdatePropertiesAsync(ILease lease);
    public sealed virtual Task`1<bool> IsInitializedAsync();
    public sealed virtual Task MarkInitializedAsync();
    public sealed virtual Task`1<bool> AcquireInitializationLockAsync(TimeSpan lockExpirationTime);
    public sealed virtual Task`1<bool> ReleaseInitializationLockAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<TryGetLeaseAsync>d__21")]
private Task`1<DocumentServiceLease> TryGetLeaseAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManager/<ListDocumentsAsync>d__22")]
private Task`1<IReadOnlyList`1<DocumentServiceLease>> ListDocumentsAsync(string prefix);
    private string GetDocumentId(string partitionId);
    private string GetPartitionLeasePrefix();
    private Uri CreateDocumentUri(string leaseId);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManagerBuilder : object {
    private DocumentServiceLeaseStoreManagerSettings settings;
    private IChangeFeedDocumentClient client;
    private IRequestOptionsFactory requestOptionsFactory;
    public DocumentServiceLeaseStoreManagerBuilder WithLeaseCollection(DocumentCollectionInfo leaseCollectionLocation);
    public DocumentServiceLeaseStoreManagerBuilder WithLeaseDocumentClient(IChangeFeedDocumentClient leaseDocumentClient);
    public DocumentServiceLeaseStoreManagerBuilder WithLeasePrefix(string leasePrefix);
    public DocumentServiceLeaseStoreManagerBuilder WithLeaseCollectionLink(string leaseCollectionLink);
    public DocumentServiceLeaseStoreManagerBuilder WithRequestOptionsFactory(IRequestOptionsFactory requestOptionsFactory);
    public DocumentServiceLeaseStoreManagerBuilder WithHostName(string hostName);
    public Task`1<ILeaseStoreManager> BuildAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseStoreManagerSettings : object {
    [CompilerGeneratedAttribute]
private DocumentCollectionInfo <LeaseCollectionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerNamePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeaseCollectionLink>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    internal DocumentCollectionInfo LeaseCollectionInfo { get; internal set; }
    internal string ContainerNamePrefix { get; internal set; }
    internal string LeaseCollectionLink { get; internal set; }
    internal string HostName { get; internal set; }
    [CompilerGeneratedAttribute]
internal DocumentCollectionInfo get_LeaseCollectionInfo();
    [CompilerGeneratedAttribute]
internal void set_LeaseCollectionInfo(DocumentCollectionInfo value);
    [CompilerGeneratedAttribute]
internal string get_ContainerNamePrefix();
    [CompilerGeneratedAttribute]
internal void set_ContainerNamePrefix(string value);
    [CompilerGeneratedAttribute]
internal string get_LeaseCollectionLink();
    [CompilerGeneratedAttribute]
internal void set_LeaseCollectionLink(string value);
    [CompilerGeneratedAttribute]
internal string get_HostName();
    [CompilerGeneratedAttribute]
internal void set_HostName(string value);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseUpdater : object {
    private static int RetryCountOnConflict;
    private static ILog Logger;
    private IChangeFeedDocumentClient client;
    public DocumentServiceLeaseUpdater(IChangeFeedDocumentClient client);
    private static DocumentServiceLeaseUpdater();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseUpdater/<UpdateLeaseAsync>d__4")]
public sealed virtual Task`1<ILease> UpdateLeaseAsync(ILease cachedLease, Uri documentUri, RequestOptions requestOptions, Func`2<ILease, ILease> updateLease, bool retryOnConflict);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.DocumentServiceLeaseUpdater/<TryReplaceLeaseAsync>d__5")]
private Task`1<Document> TryReplaceLeaseAsync(ILease lease, Uri leaseUri);
    private RequestOptions CreateIfMatchOptions(ILease lease);
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.IDocumentServiceLeaseUpdater {
    public abstract virtual Task`1<ILease> UpdateLeaseAsync(ILease cachedLease, Uri documentUri, RequestOptions requestOptions, Func`2<ILease, ILease> updateLease, bool retryOnConflict);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.ILeaseCheckpointer {
    public abstract virtual Task`1<ILease> CheckpointAsync(ILease lease, string continuationToken);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.ILeaseContainer {
    public abstract virtual Task`1<IReadOnlyList`1<ILease>> GetAllLeasesAsync();
    public abstract virtual Task`1<IEnumerable`1<ILease>> GetOwnedLeasesAsync();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.ILeaseManager {
    public abstract virtual Task`1<ILease> CreateLeaseIfNotExistAsync(string partitionId, string continuationToken);
    public abstract virtual Task DeleteAsync(ILease lease);
    public abstract virtual Task`1<ILease> AcquireAsync(ILease lease);
    public abstract virtual Task ReleaseAsync(ILease lease);
    public abstract virtual Task`1<ILease> RenewAsync(ILease lease);
    public abstract virtual Task`1<ILease> UpdatePropertiesAsync(ILease leaseToUpdatePropertiesFrom);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.ILeaseStore {
    public abstract virtual Task`1<bool> IsInitializedAsync();
    public abstract virtual Task MarkInitializedAsync();
    public abstract virtual Task`1<bool> AcquireInitializationLockAsync(TimeSpan lockExpirationTime);
    public abstract virtual Task`1<bool> ReleaseInitializationLockAsync();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.ILeaseStoreManager {
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.IRequestOptionsFactory {
    public abstract virtual RequestOptions CreateRequestOptions(ILease lease);
    public abstract virtual FeedOptions CreateFeedOptions();
    public abstract virtual void AddPartitionKeyIfNeeded(ILease lease, string partitionKey);
    public abstract virtual void AddPartitionKeyIfNeeded(Document doc, string partitionKey);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.PartitionedByIdCollectionRequestOptionsFactory : object {
    public sealed virtual RequestOptions CreateRequestOptions(ILease lease);
    public sealed virtual FeedOptions CreateFeedOptions();
    public sealed virtual void AddPartitionKeyIfNeeded(ILease lease, string partitionKey);
    public sealed virtual void AddPartitionKeyIfNeeded(Document doc, string partitionKey);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.PartitionedByPartitionKeyCollectionRequestOptionsFactory : object {
    public sealed virtual RequestOptions CreateRequestOptions(ILease lease);
    public sealed virtual FeedOptions CreateFeedOptions();
    public sealed virtual void AddPartitionKeyIfNeeded(ILease lease, string partitionKey);
    public sealed virtual void AddPartitionKeyIfNeeded(Document doc, string partitionKey);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.LeaseManagement.SinglePartitionRequestOptionsFactory : object {
    public sealed virtual FeedOptions CreateFeedOptions();
    public sealed virtual RequestOptions CreateRequestOptions(ILease lease);
    public sealed virtual void AddPartitionKeyIfNeeded(ILease lease, string partitionKey);
    public sealed virtual void AddPartitionKeyIfNeeded(Document doc, string partitionKey);
}
[GeneratedCodeAttribute("liblog", "4.2")]
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.ILog {
    public abstract virtual bool Log(LogLevel logLevel, Func`1<string> messageFunc, Exception exception, Object[] formatParameters);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.ILogProvider {
    public abstract virtual Logger GetLogger(string name);
    public abstract virtual IDisposable OpenNestedContext(string message);
    public abstract virtual IDisposable OpenMappedContext(string key, string value);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogExtensions : object {
    [ExtensionAttribute]
public static bool IsDebugEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsErrorEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsFatalEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsInfoEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsWarnEnabled(ILog logger);
    [ExtensionAttribute]
public static void Debug(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Debug(ILog logger, string message);
    [ExtensionAttribute]
public static void DebugFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void DebugException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void DebugException(ILog logger, string message, Exception exception, Object[] formatParams);
    [ExtensionAttribute]
public static void Error(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Error(ILog logger, string message);
    [ExtensionAttribute]
public static void ErrorFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void ErrorException(ILog logger, string message, Exception exception, Object[] formatParams);
    [ExtensionAttribute]
public static void Fatal(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Fatal(ILog logger, string message);
    [ExtensionAttribute]
public static void FatalFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void FatalException(ILog logger, string message, Exception exception, Object[] formatParams);
    [ExtensionAttribute]
public static void Info(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Info(ILog logger, string message);
    [ExtensionAttribute]
public static void InfoFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void InfoException(ILog logger, string message, Exception exception, Object[] formatParams);
    [ExtensionAttribute]
public static void Trace(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Trace(ILog logger, string message);
    [ExtensionAttribute]
public static void TraceFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void TraceException(ILog logger, string message, Exception exception, Object[] formatParams);
    [ExtensionAttribute]
public static void Warn(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Warn(ILog logger, string message);
    [ExtensionAttribute]
public static void WarnFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void WarnException(ILog logger, string message, Exception exception, Object[] formatParams);
    private static void GuardAgainstNullLogger(ILog logger);
    [ExtensionAttribute]
private static void LogFormat(ILog logger, LogLevel logLevel, string message, Object[] args);
    [ExtensionAttribute]
private static Func`1<T> AsFunc(T value);
    [ExtensionAttribute]
private static T Return(T value);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.Logger : MulticastDelegate {
    public Logger(object object, IntPtr method);
    public virtual bool Invoke(LogLevel logLevel, Func`1<string> messageFunc, Exception exception, Object[] formatParameters);
    public virtual IAsyncResult BeginInvoke(LogLevel logLevel, Func`1<string> messageFunc, Exception exception, Object[] formatParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LoggerExecutionWrapper : object {
    private Logger _logger;
    private Func`1<bool> _getIsDisabled;
    internal static string FailedToGenerateLogMessage;
    internal Logger WrappedLogger { get; }
    internal LoggerExecutionWrapper(Logger logger, Func`1<bool> getIsDisabled);
    internal Logger get_WrappedLogger();
    public sealed virtual bool Log(LogLevel logLevel, Func`1<string> messageFunc, Exception exception, Object[] formatParameters);
}
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
}
public static class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProvider : object {
    private static string NullLogProvider;
    [DynamicAttribute]
private static object s_currentLogProvider;
    private static Action`1<ILogProvider> s_onCurrentLogProviderSet;
    [CompilerGeneratedAttribute]
private static bool <IsDisabled>k__BackingField;
    internal static List`1<Tuple`2<IsLoggerAvailable, CreateLogProvider>> LogProviderResolvers;
    public static bool IsDisabled { get; public set; }
    unknown static Action`1<ILogProvider> OnCurrentLogProviderSet {internal set; }
    internal static ILogProvider CurrentLogProvider { get; }
    private static LogProvider();
    public static void SetCurrentLogProvider(ILogProvider logProvider);
    [CompilerGeneratedAttribute]
public static bool get_IsDisabled();
    [CompilerGeneratedAttribute]
public static void set_IsDisabled(bool value);
    internal static void set_OnCurrentLogProviderSet(Action`1<ILogProvider> value);
    internal static ILogProvider get_CurrentLogProvider();
    internal static ILog For();
    internal static ILog GetCurrentClassLogger();
    internal static ILog GetLogger(Type type, string fallbackTypeName);
    internal static ILog GetLogger(string name);
    internal static IDisposable OpenNestedContext(string message);
    internal static IDisposable OpenMappedContext(string key, string value);
    private static void RaiseOnCurrentLogProviderSet();
    internal static ILogProvider ResolveLogProvider();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.DisposableAction : object {
    private Action _onDispose;
    public DisposableAction(Action onDispose);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.EntLibLogProvider : LogProviderBase {
    private static string TypeTemplate;
    private static bool s_providerIsAvailableOverride;
    private static Type LogEntryType;
    private static Type LoggerType;
    private static Type TraceEventTypeType;
    private static Action`3<string, string, int> WriteLogEntry;
    private static Func`3<string, int, bool> ShouldLogEntry;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static EntLibLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public virtual Logger GetLogger(string name);
    internal static bool IsLoggerAvailable();
    private static Action`3<string, string, int> GetWriteLogEntry();
    private static Func`3<string, int, bool> GetShouldLogEntry();
    private static MemberInitExpression GetWriteLogExpression(Expression message, Expression severityParameter, ParameterExpression logNameParameter);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.Log4NetLogProvider : LogProviderBase {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private static bool s_providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static Log4NetLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public virtual Logger GetLogger(string name);
    internal static bool IsLoggerAvailable();
    protected virtual OpenNdc GetOpenNdcMethod();
    protected virtual OpenMdc GetOpenMdcMethod();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetGetLoggerMethodCall();
}
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.LogMessageFormatter : object {
    private static Regex Pattern;
    private static LogMessageFormatter();
    public static Func`1<string> SimulateStructuredLogging(Func`1<string> messageBuilder, Object[] formatParameters);
    private static string ReplaceFirst(string text, string search, string replace);
    public static string FormatStructuredMessage(string targetMessage, Object[] formatParameters, IEnumerable`1& patternMatches);
}
internal abstract class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.LogProviderBase : object {
    private Lazy`1<OpenNdc> _lazyOpenNdcMethod;
    private Lazy`1<OpenMdc> _lazyOpenMdcMethod;
    private static IDisposable NoopDisposableInstance;
    private static LogProviderBase();
    public abstract virtual Logger GetLogger(string name);
    public sealed virtual IDisposable OpenNestedContext(string message);
    public sealed virtual IDisposable OpenMappedContext(string key, string value);
    protected virtual OpenNdc GetOpenNdcMethod();
    protected virtual OpenMdc GetOpenMdcMethod();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.LoupeLogProvider : LogProviderBase {
    private static bool s_providerIsAvailableOverride;
    private WriteDelegate _logWriteDelegate;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static LoupeLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public virtual Logger GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static WriteDelegate GetLogWriteDelegate();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.NLogLogProvider : LogProviderBase {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private static bool s_providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static NLogLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public virtual Logger GetLogger(string name);
    public static bool IsLoggerAvailable();
    protected virtual OpenNdc GetOpenNdcMethod();
    protected virtual OpenMdc GetOpenMdcMethod();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetGetLoggerMethodCall();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.SerilogLogProvider : LogProviderBase {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private static bool s_providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static SerilogLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public virtual Logger GetLogger(string name);
    internal static bool IsLoggerAvailable();
    protected virtual OpenNdc GetOpenNdcMethod();
    protected virtual OpenMdc GetOpenMdcMethod();
    private static Func`3<string, string, IDisposable> GetPushProperty();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetForContextMethodCall();
}
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.TraceEventTypeValues : object {
    internal static Type Type;
    internal static int Verbose;
    internal static int Information;
    internal static int Warning;
    internal static int Error;
    internal static int Critical;
    private static TraceEventTypeValues();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.LogProviders.TypeExtensions : object {
    [ExtensionAttribute]
internal static ConstructorInfo GetConstructorPortable(Type type, Type[] types);
    [ExtensionAttribute]
internal static MethodInfo GetMethodPortable(Type type, string name);
    [ExtensionAttribute]
internal static MethodInfo GetMethodPortable(Type type, string name, Type[] types);
    [ExtensionAttribute]
internal static PropertyInfo GetPropertyPortable(Type type, string name);
    [ExtensionAttribute]
internal static IEnumerable`1<FieldInfo> GetFieldsPortable(Type type);
    [ExtensionAttribute]
internal static Type GetBaseTypePortable(Type type);
    [ExtensionAttribute]
internal static object CreateDelegate(MethodInfo methodInfo, Type delegateType);
    [ExtensionAttribute]
internal static Assembly GetAssemblyPortable(Type type);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Logging.TraceLogProvider : object {
    private static string DefaultTraceSourceName;
    private TraceLogProviderImplementation logProvider;
    public TraceLogProvider(TraceSource traceSource);
    private static TraceLogProvider();
    public sealed virtual Logger GetLogger(string name);
    public sealed virtual IDisposable OpenNestedContext(string message);
    public sealed virtual IDisposable OpenMappedContext(string key, string value);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.Monitoring.HealthMonitoringRecord : object {
    [CompilerGeneratedAttribute]
private HealthSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoredOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ILease <Lease>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public HealthSeverity Severity { get; }
    public MonitoredOperation Operation { get; }
    public ILease Lease { get; }
    public Exception Exception { get; }
    public HealthMonitoringRecord(HealthSeverity severity, MonitoredOperation operation, ILease lease, Exception exception);
    [CompilerGeneratedAttribute]
public HealthSeverity get_Severity();
    [CompilerGeneratedAttribute]
public MonitoredOperation get_Operation();
    [CompilerGeneratedAttribute]
public ILease get_Lease();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.Monitoring.HealthSeverity : Enum {
    public int value__;
    public static HealthSeverity Critical;
    public static HealthSeverity Error;
    public static HealthSeverity Informational;
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.Monitoring.IHealthMonitor {
    public abstract virtual Task InspectAsync(HealthMonitoringRecord record);
}
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.Monitoring.MonitoredOperation : Enum {
    public int value__;
    public static MonitoredOperation AcquireLease;
    public static MonitoredOperation ReadChangeFeed;
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Monitoring.TraceHealthMonitor : object {
    private static ILog Logger;
    private static TraceHealthMonitor();
    public sealed virtual Task InspectAsync(HealthMonitoringRecord record);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Obsolete.Adapters.ChangeFeedObserverAdapter : object {
    private IChangeFeedObserver observer;
    internal ChangeFeedObserverAdapter(IChangeFeedObserver observer);
    public sealed virtual Task OpenAsync(IChangeFeedObserverContext context);
    public sealed virtual Task CloseAsync(IChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    public sealed virtual Task ProcessChangesAsync(IChangeFeedObserverContext context, IReadOnlyList`1<Document> docs, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Obsolete.Adapters.ChangeFeedObserverAdapter`1 : object {
    private T observer;
    public sealed virtual Task OpenAsync(IChangeFeedObserverContext context);
    public sealed virtual Task CloseAsync(IChangeFeedObserverContext context, ChangeFeedObserverCloseReason reason);
    public sealed virtual Task ProcessChangesAsync(IChangeFeedObserverContext context, IReadOnlyList`1<Document> docs, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Obsolete.Adapters.ChangeFeedObserverContextAdapter : ChangeFeedObserverContext {
    private IChangeFeedObserverContext inner;
    public ChangeFeedObserverContextAdapter(IChangeFeedObserverContext inner);
    public virtual Task CheckpointAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.Obsolete.Adapters.ChangeFeedObserverFactoryAdapter : object {
    private IChangeFeedObserverFactory factory;
    internal ChangeFeedObserverFactoryAdapter(IChangeFeedObserverFactory factory);
    public sealed virtual IChangeFeedObserver CreateObserver();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionCheckpointer : object {
    private static ILog Logger;
    private ILeaseCheckpointer leaseCheckpointer;
    private ILease lease;
    public PartitionCheckpointer(ILeaseCheckpointer leaseCheckpointer, ILease lease);
    private static PartitionCheckpointer();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionCheckpointer/<CheckpointPartitionAsync>d__4")]
public sealed virtual Task CheckpointPartitionAsync(string сontinuationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.EqualPartitionsBalancingStrategy : object {
    private static ILog Logger;
    private string hostName;
    private int minPartitionCount;
    private int maxPartitionCount;
    private TimeSpan leaseExpirationInterval;
    public EqualPartitionsBalancingStrategy(string hostName, int minPartitionCount, int maxPartitionCount, TimeSpan leaseExpirationInterval);
    private static EqualPartitionsBalancingStrategy();
    public sealed virtual IEnumerable`1<ILease> SelectLeasesToTake(IEnumerable`1<ILease> allLeases);
    private static ILease GetLeaseToSteal(Dictionary`2<string, int> workerToPartitionCount, int target, int partitionsNeededForMe, Dictionary`2<string, ILease> allPartitions);
    private static KeyValuePair`2<string, int> FindWorkerWithMostPartitions(Dictionary`2<string, int> workerToPartitionCount);
    private int CalculateTargetPartitionCount(int partitionCount, int workerCount);
    private void CategorizeLeases(IEnumerable`1<ILease> allLeases, Dictionary`2<string, ILease> allPartitions, List`1<ILease> expiredLeases, List`1<ILease> leasesWithoutOwner, Dictionary`2<string, int> workerToPartitionCount);
    private bool IsExpired(ILease lease);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IChangeFeedProcessor {
    public abstract virtual Task StartAsync();
    public abstract virtual Task StopAsync();
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.ILease {
    public string PartitionId { get; }
    public string Owner { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string ContinuationToken { get; public set; }
    public string Id { get; }
    public string ConcurrencyToken { get; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public abstract virtual string get_PartitionId();
    public abstract virtual string get_Owner();
    public abstract virtual void set_Owner(string value);
    public abstract virtual DateTime get_Timestamp();
    public abstract virtual void set_Timestamp(DateTime value);
    public abstract virtual string get_ContinuationToken();
    public abstract virtual void set_ContinuationToken(string value);
    public abstract virtual string get_Id();
    public abstract virtual string get_ConcurrencyToken();
    public abstract virtual Dictionary`2<string, string> get_Properties();
    public abstract virtual void set_Properties(Dictionary`2<string, string> value);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.ILeaseAcquireReasonProvider {
    public LeaseAcquireReason AcquireReason { get; public set; }
    public abstract virtual LeaseAcquireReason get_AcquireReason();
    public abstract virtual void set_AcquireReason(LeaseAcquireReason value);
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.ILeaseRenewer {
    public abstract virtual Task RunAsync(CancellationToken cancellationToken);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IParitionLoadBalancingStrategy {
    public abstract virtual IEnumerable`1<ILease> SelectLeasesToTake(IEnumerable`1<ILease> allLeases);
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionController {
    public abstract virtual Task AddOrUpdateLeaseAsync(ILease lease);
    public abstract virtual Task InitializeAsync();
    public abstract virtual Task ShutdownAsync();
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionLoadBalancer {
    public abstract virtual void Start();
    public abstract virtual Task StopAsync();
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionManager {
    public abstract virtual Task StartAsync();
    public abstract virtual Task StopAsync();
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionSupervisor {
    public abstract virtual Task RunAsync(CancellationToken shutdownToken);
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionSupervisorFactory {
    public abstract virtual IPartitionSupervisor Create(ILease lease);
}
internal interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IPartitionSynchronizer {
    public abstract virtual Task CreateMissingLeasesAsync();
    public abstract virtual Task`1<IEnumerable`1<ILease>> SplitPartitionAsync(ILease lease);
}
public interface Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.IRemainingWorkEstimator {
    public abstract virtual Task`1<long> GetEstimatedRemainingWork();
    public abstract virtual Task`1<IReadOnlyList`1<RemainingPartitionWork>> GetEstimatedRemainingWorkPerPartitionAsync();
}
public enum Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.LeaseAcquireReason : Enum {
    public int value__;
    public static LeaseAcquireReason Unknown;
    public static LeaseAcquireReason NotOwned;
    public static LeaseAcquireReason Expired;
    public static LeaseAcquireReason Steal;
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.LeaseRenewer : object {
    private static ILog Logger;
    private ILeaseManager leaseManager;
    private TimeSpan leaseRenewInterval;
    private ILease lease;
    public LeaseRenewer(ILease lease, ILeaseManager leaseManager, TimeSpan leaseRenewInterval);
    private static LeaseRenewer();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.LeaseRenewer/<RunAsync>d__5")]
public sealed virtual Task RunAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.LeaseRenewer/<RenewAsync>d__6")]
private Task RenewAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController : object {
    private static ILog Logger;
    private ConcurrentDictionary`2<string, TaskCompletionSource`1<bool>> currentlyOwnedPartitions;
    private ILeaseContainer leaseContainer;
    private ILeaseManager leaseManager;
    private IPartitionSupervisorFactory partitionSupervisorFactory;
    private IPartitionSynchronizer synchronizer;
    private CancellationTokenSource shutdownCts;
    public PartitionController(ILeaseContainer leaseContainer, ILeaseManager leaseManager, IPartitionSupervisorFactory partitionSupervisorFactory, IPartitionSynchronizer synchronizer);
    private static PartitionController();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<InitializeAsync>d__8")]
public sealed virtual Task InitializeAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<AddOrUpdateLeaseAsync>d__9")]
public sealed virtual Task AddOrUpdateLeaseAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<ShutdownAsync>d__10")]
public sealed virtual Task ShutdownAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<LoadLeasesAsync>d__11")]
private Task LoadLeasesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<RemoveLeaseAsync>d__12")]
private Task RemoveLeaseAsync(ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<ProcessPartition>d__13")]
private Task ProcessPartition(IPartitionSupervisor partitionSupervisor, ILease lease);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionController/<HandleSplitAsync>d__14")]
private Task HandleSplitAsync(ILease lease, string lastContinuationToken);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionLoadBalancer : object {
    private static ILog Logger;
    private IPartitionController partitionController;
    private ILeaseContainer leaseContainer;
    private IParitionLoadBalancingStrategy partitionLoadBalancingStrategy;
    private TimeSpan leaseAcquireInterval;
    private CancellationTokenSource cancellationTokenSource;
    private Task runTask;
    public PartitionLoadBalancer(IPartitionController partitionController, ILeaseContainer leaseContainer, IParitionLoadBalancingStrategy partitionLoadBalancingStrategy, TimeSpan leaseAcquireInterval);
    private static PartitionLoadBalancer();
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionLoadBalancer/<StopAsync>d__9")]
public sealed virtual Task StopAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionLoadBalancer/<RunAsync>d__10")]
private Task RunAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionManager : object {
    private IBootstrapper bootstrapper;
    private IPartitionController partitionController;
    private IPartitionLoadBalancer partitionLoadBalancer;
    public PartitionManager(IBootstrapper bootstrapper, IPartitionController partitionController, IPartitionLoadBalancer partitionLoadBalancer);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionManager/<StartAsync>d__4")]
public sealed virtual Task StartAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionManager/<StopAsync>d__5")]
public sealed virtual Task StopAsync();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionSupervisor : object {
    private ILease lease;
    private IChangeFeedObserver observer;
    private IPartitionProcessor processor;
    private ILeaseRenewer renewer;
    private CancellationTokenSource renewerCancellation;
    private CancellationTokenSource processorCancellation;
    public PartitionSupervisor(ILease lease, IChangeFeedObserver observer, IPartitionProcessor processor, ILeaseRenewer renewer);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionSupervisor/<RunAsync>d__7")]
public sealed virtual Task RunAsync(CancellationToken shutdownToken);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <RunAsync>b__7_0(Task _);
    [CompilerGeneratedAttribute]
private void <RunAsync>b__7_1(Task _);
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.PartitionSupervisorFactory : object {
    private IChangeFeedObserverFactory observerFactory;
    private ILeaseManager leaseManager;
    private ILeaseCheckpointer leaseCheckpointer;
    private ChangeFeedProcessorOptions changeFeedProcessorOptions;
    private ICheckpointPartitionProcessorFactory partitionProcessorFactory;
    public PartitionSupervisorFactory(IChangeFeedObserverFactory observerFactory, ILeaseManager leaseManager, ILeaseCheckpointer leaseCheckpointer, ICheckpointPartitionProcessorFactory partitionProcessorFactory, ChangeFeedProcessorOptions options);
    public sealed virtual IPartitionSupervisor Create(ILease lease);
}
public class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.RemainingPartitionWork : object {
    [CompilerGeneratedAttribute]
private string <PartitionKeyRangeId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RemainingWork>k__BackingField;
    public string PartitionKeyRangeId { get; }
    public long RemainingWork { get; }
    public RemainingPartitionWork(string partitionKeyRangeId, long remainingWork);
    [CompilerGeneratedAttribute]
public string get_PartitionKeyRangeId();
    [CompilerGeneratedAttribute]
public long get_RemainingWork();
}
internal class Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.RemainingWorkEstimator : object {
    private static char PKRangeIdSeparator;
    private static char SegmentSeparator;
    private static string LSNPropertyName;
    private static ILog Logger;
    private IChangeFeedDocumentClient feedDocumentClient;
    private ILeaseContainer leaseContainer;
    private string collectionSelfLink;
    private int degreeOfParallelism;
    public RemainingWorkEstimator(ILeaseContainer leaseContainer, IChangeFeedDocumentClient feedDocumentClient, string collectionSelfLink, int degreeOfParallelism);
    private static RemainingWorkEstimator();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.RemainingWorkEstimator/<GetEstimatedRemainingWork>d__9")]
public sealed virtual Task`1<long> GetEstimatedRemainingWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.RemainingWorkEstimator/<GetEstimatedRemainingWorkPerPartitionAsync>d__10")]
public sealed virtual Task`1<IReadOnlyList`1<RemainingPartitionWork>> GetEstimatedRemainingWorkPerPartitionAsync();
    internal static string ExtractLsnFromSessionToken(string sessionToken);
    private static Document GetFirstDocument(IFeedResponse`1<Document> response);
    private static long TryConvertToNumber(string number);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.PartitionManagement.RemainingWorkEstimator/<GetRemainingWorkAsync>d__14")]
private Task`1<long> GetRemainingWorkAsync(ILease existingLease);
    [CompilerGeneratedAttribute]
private Task`1<List`1<RemainingPartitionWork>> <GetEstimatedRemainingWorkPerPartitionAsync>b__10_0(IEnumerator`1<ILease> partition);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentClientExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentClientExtensions/<TryGetDocumentAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Document> TryGetDocumentAsync(IChangeFeedDocumentClient client, Uri documentUri, RequestOptions requestOptions);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentClientExtensions/<TryCreateDocumentAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Document> TryCreateDocumentAsync(IChangeFeedDocumentClient client, string collectionLink, object document);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentClientExtensions/<TryDeleteDocumentAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Document> TryDeleteDocumentAsync(IChangeFeedDocumentClient client, Uri documentUri, RequestOptions requestOptions);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentClientExtensions/<GetDocumentCollectionAsync>d__3")]
[ExtensionAttribute]
public static Task`1<DocumentCollection> GetDocumentCollectionAsync(IChangeFeedDocumentClient client, DocumentCollectionInfo collectionInfo);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.DocumentCollectionHelper : object {
    private static string DefaultUserAgentSuffix;
    [ExtensionAttribute]
public static DocumentCollectionInfo Canonicalize(DocumentCollectionInfo collectionInfo);
    [ExtensionAttribute]
internal static IChangeFeedDocumentClient CreateDocumentClient(DocumentCollectionInfo collectionInfo);
    [ExtensionAttribute]
internal static string GetCollectionSelfLink(DocumentCollectionInfo collectionInfo);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.ParallelHelper : object {
    [ExtensionAttribute]
public static Task ForEachAsync(IEnumerable`1<TSource> source, Func`2<TSource, Task> worker, int maxParallelTaskCount, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.TaskExtensions : object {
    private static ILog Logger;
    private static TaskExtensions();
    [ExtensionAttribute]
public static void LogException(Task task);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.TaskExtensions/<IgnoreException>d__2")]
[ExtensionAttribute]
public static Task IgnoreException(Task task);
    [AsyncStateMachineAttribute("Microsoft.Azure.Documents.ChangeFeedProcessor.Utils.TaskExtensions/<AbortOnTimeout>d__3`1")]
[ExtensionAttribute]
public static Task`1<TResult> AbortOnTimeout(Task`1<TResult> responseTask, TimeSpan timeout, CancellationToken token);
}
