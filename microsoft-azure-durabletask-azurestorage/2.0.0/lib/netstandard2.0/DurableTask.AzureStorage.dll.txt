[EventSourceAttribute]
internal class DurableTask.AzureStorage.AnalyticsEventSource : EventSource {
    public static AnalyticsEventSource Log;
    private static AnalyticsEventSource();
    [NonEventAttribute]
public static void SetLogicalTraceActivityId(Guid activityId);
    private static void SetCoreTraceActivityId(Guid activityId);
    [EventAttribute("101")]
public void SendingMessage(Guid relatedActivityId, string Account, string TaskHub, string EventType, int TaskEventId, string InstanceId, string ExecutionId, long SizeInBytes, string PartitionId, string TargetInstanceId, string TargetExecutionId, long SequenceNumber, int Episode, string AppName, string ExtensionVersion);
    [EventAttribute("102")]
public void ReceivedMessage(Guid relatedActivityId, string Account, string TaskHub, string EventType, int TaskEventId, string InstanceId, string ExecutionId, string MessageId, int Age, long DequeueCount, string NextVisibleTime, long SizeInBytes, string PartitionId, long SequenceNumber, string PopReceipt, int Episode, string AppName, string ExtensionVersion);
    [EventAttribute("103")]
public void DeletingMessage(string Account, string TaskHub, string EventType, int TaskEventId, string MessageId, string InstanceId, string ExecutionId, string PartitionId, long SequenceNumber, string PopReceipt, string AppName, string ExtensionVersion);
    [EventAttribute("104")]
public void AbandoningMessage(string Account, string TaskHub, string EventType, int TaskEventId, string MessageId, string InstanceId, string ExecutionId, string PartitionId, long SequenceNumber, string PopReceipt, int VisibilityTimeoutSeconds, string AppName, string ExtensionVersion);
    [EventAttribute("105")]
public void AssertFailure(string Account, string TaskHub, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("106")]
public void MessageGone(string Account, string TaskHub, string EventType, int TaskEventId, string MessageId, string InstanceId, string ExecutionId, string PartitionId, string Details, string PopReceipt, string AppName, string ExtensionVersion);
    [EventAttribute("107")]
public void GeneralError(string Account, string TaskHub, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("108")]
public void DuplicateMessageDetected(string Account, string TaskHub, string EventType, int TaskEventId, string MessageId, string InstanceId, string ExecutionId, string PartitionId, long DequeueCount, string PopReceipt, string AppName, string ExtensionVersion);
    [EventAttribute("109")]
public void PoisonMessageDetected(string Account, string TaskHub, string EventType, int TaskEventId, string MessageId, string InstanceId, string ExecutionId, string PartitionId, long DequeueCount, string AppName, string ExtensionVersion);
    [EventAttribute("110")]
public void FetchedInstanceHistory(string Account, string TaskHub, string InstanceId, string ExecutionId, int EventCount, int Episode, int RequestCount, long LatencyMs, string ETag, DateTime LastCheckpointTime, string AppName, string ExtensionVersion);
    [EventAttribute("111")]
public void AppendedInstanceHistory(string Account, string TaskHub, string InstanceId, string ExecutionId, int NewEventCount, int TotalEventCount, string NewEvents, int Episode, long LatencyMs, int SizeInBytes, string ETag, bool IsCheckpointComplete, string AppName, string ExtensionVersion);
    [EventAttribute("112")]
public void OrchestrationServiceStats(string Account, string TaskHub, long StorageRequests, long MessagesSent, long MessagesRead, long MessagesUpdated, long TableEntitiesWritten, long TableEntitiesRead, long PendingOrchestrators, long PendingOrchestratorMessages, long ActiveOrchestrators, long ActiveActivities, string AppName, string ExtensionVersion);
    [EventAttribute("113")]
public void RenewingMessage(string Account, string TaskHub, string InstanceId, string ExecutionId, string PartitionId, string EventType, int TaskEventId, string MessageId, string PopReceipt, int VisibilityTimeoutSeconds, string AppName, string ExtensionVersion);
    [EventAttribute("114")]
public void MessageFailure(string Account, string TaskHub, string MessageId, string InstanceId, string ExecutionId, string PartitionId, string EventType, int TaskEventId, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("115")]
public void OrchestrationProcessingFailure(string Account, string TaskHub, string InstanceId, string ExecutionId, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("116")]
public void PendingOrchestratorMessageLimitReached(string Account, string TaskHub, string PartitionId, long PendingOrchestratorMessages, string AppName, string ExtensionVersion);
    [EventAttribute("117")]
public void WaitingForMoreMessages(string Account, string TaskHub, string PartitionId, string AppName, string ExtensionVersion);
    [EventAttribute("118")]
public void ReceivedOutOfOrderMessage(string Account, string TaskHub, string InstanceId, string ExecutionId, string PartitionId, string EventType, int TaskEventId, string MessageId, int Episode, DateTime LastCheckpointTime, string AppName, string ExtensionVersion);
    [EventAttribute("120")]
public void PartitionManagerInfo(string Account, string TaskHub, string WorkerName, string PartitionId, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("121")]
public void PartitionManagerWarning(string Account, string TaskHub, string WorkerName, string PartitionId, string Details, string AppName, string ExtensionVersion);
    [NonEventAttribute]
public void PartitionManagerError(string account, string taskHub, string workerName, string partitionId, Exception exception, string ExtensionVersion);
    [EventAttribute("122")]
public void PartitionManagerError(string Account, string TaskHub, string WorkerName, string PartitionId, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("123")]
public void StartingLeaseRenewal(string Account, string TaskHub, string WorkerName, string PartitionId, string Token, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("124")]
public void LeaseRenewalResult(string Account, string TaskHub, string WorkerName, string PartitionId, bool Success, string Token, string LeaseType, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("125")]
public void LeaseRenewalFailed(string Account, string TaskHub, string WorkerName, string PartitionId, string Token, string LeaseType, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("126")]
public void LeaseAcquisitionStarted(string Account, string TaskHub, string WorkerName, string PartitionId, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("127")]
public void LeaseAcquisitionSucceeded(string Account, string TaskHub, string WorkerName, string PartitionId, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("128")]
public void LeaseAcquisitionFailed(string Account, string TaskHub, string WorkerName, string PartitionId, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("129")]
public void AttemptingToStealLease(string Account, string TaskHub, string WorkerName, string FromWorkerName, string LeaseType, string PartitionId, string AppName, string ExtensionVersion);
    [EventAttribute("130")]
public void LeaseStealingSucceeded(string Account, string TaskHub, string WorkerName, string FromWorkerName, string LeaseType, string PartitionId, string AppName, string ExtensionVersion);
    [EventAttribute("131")]
public void LeaseStealingFailed(string Account, string TaskHub, string WorkerName, string PartitionId, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("132")]
public void PartitionRemoved(string Account, string TaskHub, string WorkerName, string PartitionId, string Token, string AppName, string ExtensionVersion);
    [EventAttribute("133")]
public void LeaseRemoved(string Account, string TaskHub, string WorkerName, string PartitionId, string Token, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("134")]
public void LeaseRemovalFailed(string Account, string TaskHub, string WorkerName, string PartitionId, string Token, string LeaseType, string AppName, string ExtensionVersion);
    [EventAttribute("135")]
public void InstanceStatusUpdate(string Account, string TaskHub, string InstanceId, string ExecutionId, string RuntimeStatus, int Episode, long LatencyMs, string AppName, string ExtensionVersion);
    [EventAttribute("136")]
public void FetchedInstanceStatus(string Account, string TaskHub, string InstanceId, string ExecutionId, string RuntimeStatus, long LatencyMs, string AppName, string ExtensionVersion);
    [EventAttribute("137")]
public void GeneralWarning(string Account, string TaskHub, string Details, string AppName, string ExtensionVersion, string InstanceId);
    [EventAttribute("138")]
public void SplitBrainDetected(string Account, string TaskHub, string InstanceId, string ExecutionId, int NewEventCount, int TotalEventCount, string NewEvents, long LatencyMs, string ETag, string AppName, string ExtensionVersion);
    [EventAttribute("139")]
public void DiscardingWorkItem(string Account, string TaskHub, string InstanceId, string ExecutionId, int NewEventCount, int TotalEventCount, string NewEvents, string Details, string AppName, string ExtensionVersion);
    [EventAttribute("140")]
public void ProcessingMessage(Guid relatedActivityId, string Account, string TaskHub, string EventType, int TaskEventId, string InstanceId, string ExecutionId, string MessageId, int Age, long SequenceNumber, int Episode, bool IsExtendedSession, string AppName, string ExtensionVersion);
    [EventAttribute("141")]
public void PurgeInstanceHistory(string Account, string TaskHub, string InstanceId, string CreatedTimeFrom, string CreatedTimeTo, string RuntimeStatus, int RequestCount, int InstanceCount, long LatencyMs, string AppName, string ExtensionVersion);
}
internal class DurableTask.AzureStorage.AsyncAutoResetEvent : object {
    private LinkedList`1<TaskCompletionSource`1<bool>> waiters;
    [CompilerGeneratedAttribute]
private bool <IsSignaled>k__BackingField;
    public bool IsSignaled { get; private set; }
    public int QueueLength { get; }
    public AsyncAutoResetEvent(bool signaled);
    [CompilerGeneratedAttribute]
public bool get_IsSignaled();
    [CompilerGeneratedAttribute]
private void set_IsSignaled(bool value);
    public int get_QueueLength();
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AsyncAutoResetEvent/<WaitAsync>d__9")]
public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Set();
    public virtual string ToString();
}
internal class DurableTask.AzureStorage.AsyncManualResetEvent : object {
    private object mutex;
    private TaskCompletionSource`1<object> tcs;
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AsyncManualResetEvent/<WaitAsync>d__2")]
public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public void Set();
    public void Reset();
    [CompilerGeneratedAttribute]
private void <Set>b__3_0();
}
internal class DurableTask.AzureStorage.AsyncQueue`1 : object {
    private SemaphoreSlim semaphore;
    private ConcurrentQueue`1<T> innerQueue;
    public int Count { get; }
    public int get_Count();
    public void Enqueue(T item);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AsyncQueue`1/<DequeueAsync>d__5")]
public Task`1<T> DequeueAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class DurableTask.AzureStorage.AzureStorageOrchestrationService : object {
    private static HistoryEvent[] EmptyHistoryEventList;
    private static OrchestrationInstance EmptySourceInstance;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceSettings settings;
    private AzureStorageOrchestrationServiceStats stats;
    private ConcurrentDictionary`2<string, ControlQueue> allControlQueues;
    private WorkItemQueue workItemQueue;
    private ConcurrentDictionary`2<string, ActivitySession> activeActivitySessions;
    private MessageManager messageManager;
    private ITrackingStore trackingStore;
    private ResettableLazy`1<Task> taskHubCreator;
    private BlobPartitionLeaseManager leaseManager;
    private AppLeaseManager appLeaseManager;
    private OrchestrationSessionManager orchestrationSessionManager;
    private IPartitionManager partitionManager;
    private object hubCreationLock;
    private bool isStarted;
    private Task statsLoop;
    private CancellationTokenSource shutdownSource;
    [CompilerGeneratedAttribute]
private int <TaskActivityDispatcherCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TaskOrchestrationDispatcherCount>k__BackingField;
    internal string WorkerId { get; }
    internal IEnumerable`1<ControlQueue> AllControlQueues { get; }
    internal IEnumerable`1<ControlQueue> OwnedControlQueues { get; }
    internal WorkItemQueue WorkItemQueue { get; }
    internal ITrackingStore TrackingStore { get; }
    public int MaxConcurrentTaskOrchestrationWorkItems { get; }
    public int MaxConcurrentTaskActivityWorkItems { get; }
    public BehaviorOnContinueAsNew EventBehaviourForContinueAsNew { get; }
    public int TaskActivityDispatcherCount { get; }
    public int TaskOrchestrationDispatcherCount { get; }
    private EntityBackendProperties DurableTask.Core.Entities.IEntityOrchestrationService.EntityBackendProperties { get; }
    private EntityBackendQueries DurableTask.Core.Entities.IEntityOrchestrationService.EntityBackendQueries { get; }
    public AzureStorageOrchestrationService(AzureStorageOrchestrationServiceSettings settings);
    public AzureStorageOrchestrationService(AzureStorageOrchestrationServiceSettings settings, IOrchestrationServiceInstanceStore customInstanceStore);
    private static AzureStorageOrchestrationService();
    public virtual string ToString();
    internal string get_WorkerId();
    internal IEnumerable`1<ControlQueue> get_AllControlQueues();
    internal IEnumerable`1<ControlQueue> get_OwnedControlQueues();
    internal WorkItemQueue get_WorkItemQueue();
    internal ITrackingStore get_TrackingStore();
    internal static string GetControlQueueName(string taskHub, int partitionIndex);
    internal static string GetWorkItemQueueName(string taskHub);
    internal static string GetQueueName(string taskHub, string suffix);
    internal static BlobPartitionLeaseManager GetBlobLeaseManager(AzureStorageClient azureStorageClient, string leaseType);
    private static void ValidateSettings(AzureStorageOrchestrationServiceSettings settings);
    public sealed virtual int get_MaxConcurrentTaskOrchestrationWorkItems();
    public sealed virtual int get_MaxConcurrentTaskActivityWorkItems();
    public sealed virtual BehaviorOnContinueAsNew get_EventBehaviourForContinueAsNew();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TaskActivityDispatcherCount();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TaskOrchestrationDispatcherCount();
    private sealed virtual override EntityBackendProperties DurableTask.Core.Entities.IEntityOrchestrationService.get_EntityBackendProperties();
    private sealed virtual override EntityBackendQueries DurableTask.Core.Entities.IEntityOrchestrationService.get_EntityBackendQueries();
    private sealed virtual override Task`1<TaskOrchestrationWorkItem> DurableTask.Core.Entities.IEntityOrchestrationService.LockNextOrchestrationWorkItemAsync(TimeSpan receiveTimeout, CancellationToken cancellationToken);
    private sealed virtual override Task`1<TaskOrchestrationWorkItem> DurableTask.Core.Entities.IEntityOrchestrationService.LockNextEntityWorkItemAsync(TimeSpan receiveTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CreateAsync>d__55")]
public sealed virtual Task CreateAsync();
    public sealed virtual Task CreateIfNotExistsAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<EnsureTaskHubAsync>d__57")]
private Task EnsureTaskHubAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetTaskHubCreatorTask>d__58")]
private Task GetTaskHubCreatorTask();
    public sealed virtual Task DeleteAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CreateAsync>d__60")]
public sealed virtual Task CreateAsync(bool recreateInstanceStore);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<DeleteAsync>d__61")]
public sealed virtual Task DeleteAsync(bool deleteInstanceStore);
    private Task DeleteTrackingStore();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<StartAsync>d__63")]
public sealed virtual Task StartAsync();
    public sealed virtual Task StopAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<StopAsync>d__65")]
public sealed virtual Task StopAsync(bool isForced);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<ReportStatsLoop>d__66")]
private Task ReportStatsLoop(CancellationToken cancellationToken);
    private void ReportStats();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<OnIntentLeaseAquiredAsync>d__68")]
internal Task OnIntentLeaseAquiredAsync(BlobPartitionLease lease);
    internal Task OnIntentLeaseReleasedAsync(BlobPartitionLease lease, CloseReason reason);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<OnOwnershipLeaseAquiredAsync>d__70")]
internal Task OnOwnershipLeaseAquiredAsync(BlobPartitionLease lease);
    internal void DropLostControlQueue(TablePartitionLease partition);
    internal Task OnOwnershipLeaseReleasedAsync(BlobPartitionLease lease, CloseReason reason);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<OnTableLeaseAcquiredAsync>d__73")]
internal Task OnTableLeaseAcquiredAsync(TablePartitionLease lease);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<DrainTablePartitionAsync>d__74")]
internal Task DrainTablePartitionAsync(TablePartitionLease lease, CloseReason reason);
    internal IAsyncEnumerable`1<BlobPartitionLease> ListBlobLeasesAsync(CancellationToken cancellationToken);
    internal IAsyncEnumerable`1<TablePartitionLease> ListTableLeasesAsync(CancellationToken cancellationToken);
    internal void SimulateUnhealthyWorker(CancellationToken testToken);
    internal void KillPartitionManagerLoop();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetControlQueuesAsync>d__79")]
internal static Task`1<Queue[]> GetControlQueuesAsync(AzureStorageClient azureStorageClient, int defaultPartitionCount);
    internal static Queue GetWorkItemQueue(AzureStorageClient azureStorageClient);
    private static TaskHubInfo GetTaskHubInfo(string taskHub, int partitionCount);
    public sealed virtual Task`1<TaskOrchestrationWorkItem> LockNextTaskOrchestrationWorkItemAsync(TimeSpan receiveTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<LockNextTaskOrchestrationWorkItemAsync>d__83")]
private Task`1<TaskOrchestrationWorkItem> LockNextTaskOrchestrationWorkItemAsync(bool entitiesOnly, CancellationToken cancellationToken);
    private TraceContextBase GetParentTraceContext(OrchestrationSession session);
    private static bool IsActivityOrOrchestrationFailedOrCompleted(IList`1<MessageData> messages);
    private static TraceContextBase GetRequestTraceContext(bool isReplaying, TraceContextBase parentTraceContext);
    internal static Guid StartNewLogicalTraceScope(bool useExisting);
    internal static void TraceMessageReceived(AzureStorageOrchestrationServiceSettings settings, MessageData data, string storageAccountName);
    private bool IsExecutableInstance(OrchestrationRuntimeState runtimeState, IList`1<TaskMessage> newMessages, String& message);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<AbandonAndReleaseSessionAsync>d__90")]
private Task AbandonAndReleaseSessionAsync(OrchestrationSession session);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CompleteTaskOrchestrationWorkItemAsync>d__91")]
public sealed virtual Task CompleteTaskOrchestrationWorkItemAsync(TaskOrchestrationWorkItem workItem, OrchestrationRuntimeState newOrchestrationRuntimeState, IList`1<TaskMessage> outboundMessages, IList`1<TaskMessage> orchestratorMessages, IList`1<TaskMessage> timerMessages, TaskMessage continuedAsNewMessage, OrchestrationState orchestrationState);
    private static bool DependencyTelemetryStarted(IList`1<TaskMessage> outboundMessages, IList`1<TaskMessage> orchestratorMessages, IList`1<TaskMessage> timerMessages, TaskMessage continuedAsNewMessage, OrchestrationState orchestrationState);
    private void TrackExtendedSessionDependencyTelemetry(OrchestrationSession session);
    private static TraceContextBase CreateOrRestoreRequestTraceContextWithDependencyTrackingSettings(TraceContextBase traceContext, OrchestrationState orchestrationState, bool dependencyTelemetryStarted);
    private void TrackOrchestrationRequestTelemetry(TraceContextBase traceContext, OrchestrationState orchestrationState, string operationName);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CommitOutboundQueueMessages>d__96")]
private Task CommitOutboundQueueMessages(OrchestrationSession session, IList`1<TaskMessage> outboundMessages, IList`1<TaskMessage> orchestratorMessages, IList`1<TaskMessage> timerMessages, TaskMessage continuedAsNewMessage);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<DeleteMessageBatchAsync>d__97")]
private Task DeleteMessageBatchAsync(OrchestrationSession session, IList`1<MessageData> messagesToDelete);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<RenewTaskOrchestrationWorkItemLockAsync>d__98")]
public sealed virtual Task RenewTaskOrchestrationWorkItemLockAsync(TaskOrchestrationWorkItem workItem);
    public sealed virtual Task AbandonTaskOrchestrationWorkItemAsync(TaskOrchestrationWorkItem workItem);
    private Task AbandonSessionAsync(OrchestrationSession session);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<AbandonMessagesAsync>d__101")]
private Task AbandonMessagesAsync(OrchestrationSession session, IList`1<MessageData> messages);
    public sealed virtual Task ReleaseTaskOrchestrationWorkItemAsync(TaskOrchestrationWorkItem workItem);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<ReleaseSessionAsync>d__103")]
private Task ReleaseSessionAsync(string instanceId);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<LockNextTaskActivityWorkItem>d__104")]
public sealed virtual Task`1<TaskActivityWorkItem> LockNextTaskActivityWorkItem(TimeSpan receiveTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CompleteTaskActivityWorkItemAsync>d__105")]
public sealed virtual Task CompleteTaskActivityWorkItemAsync(TaskActivityWorkItem workItem, TaskMessage responseTaskMessage);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<RenewTaskActivityWorkItemLockAsync>d__106")]
public sealed virtual Task`1<TaskActivityWorkItem> RenewTaskActivityWorkItemLockAsync(TaskActivityWorkItem workItem);
    private static TaskActivityWorkItem ExpireWorkItem(TaskActivityWorkItem workItem);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<AbandonTaskActivityWorkItemAsync>d__108")]
public sealed virtual Task AbandonTaskActivityWorkItemAsync(TaskActivityWorkItem workItem);
    public sealed virtual bool IsMaxMessageCountExceeded(int currentMessageCount, OrchestrationRuntimeState runtimeState);
    public sealed virtual int GetDelayInSecondsAfterOnFetchException(Exception exception);
    public sealed virtual int GetDelayInSecondsAfterOnProcessException(Exception exception);
    public sealed virtual Task CreateTaskOrchestrationAsync(TaskMessage creationMessage);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<CreateTaskOrchestrationAsync>d__113")]
public sealed virtual Task CreateTaskOrchestrationAsync(TaskMessage creationMessage, OrchestrationStatus[] dedupeStatuses);
    public sealed virtual Task SendTaskOrchestrationMessageBatchAsync(TaskMessage[] messages);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<SendTaskOrchestrationMessageAsync>d__115")]
public sealed virtual Task SendTaskOrchestrationMessageAsync(TaskMessage message);
    private Task`1<MessageData> SendTaskOrchestrationMessageInternalAsync(OrchestrationInstance sourceInstance, ControlQueue controlQueue, TaskMessage message);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__117")]
public sealed virtual Task`1<IList`1<OrchestrationState>> GetOrchestrationStateAsync(string instanceId, bool allExecutions);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__118")]
public sealed virtual Task`1<OrchestrationState> GetOrchestrationStateAsync(string instanceId, string executionId);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__119")]
public Task`1<IList`1<OrchestrationState>> GetOrchestrationStateAsync(string instanceId, bool allExecutions, bool fetchInput);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__120")]
public Task`1<IList`1<OrchestrationState>> GetOrchestrationStateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__121")]
public Task`1<IList`1<OrchestrationState>> GetOrchestrationStateAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__122")]
public Task`1<DurableStatusQueryResult> GetOrchestrationStateAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, int top, string continuationToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationStateAsync>d__123")]
public Task`1<DurableStatusQueryResult> GetOrchestrationStateAsync(OrchestrationInstanceStatusQueryCondition condition, int top, string continuationToken, CancellationToken cancellationToken);
    public sealed virtual Task ForceTerminateTaskOrchestrationAsync(string instanceId, string reason);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<RewindTaskOrchestrationAsync>d__125")]
public Task RewindTaskOrchestrationAsync(string instanceId, string reason);
    public Task ForceChangeAppLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationHistoryAsync>d__127")]
public sealed virtual Task`1<string> GetOrchestrationHistoryAsync(string instanceId, string executionId);
    public Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(string instanceId);
    public Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<DurableTask-Core-IOrchestrationServicePurgeClient-PurgeInstanceStateAsync>d__130")]
private sealed virtual override Task`1<PurgeResult> DurableTask.Core.IOrchestrationServicePurgeClient.PurgeInstanceStateAsync(string instanceId);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<DurableTask-Core-IOrchestrationServicePurgeClient-PurgeInstanceStateAsync>d__131")]
private sealed virtual override Task`1<PurgeResult> DurableTask.Core.IOrchestrationServicePurgeClient.PurgeInstanceStateAsync(PurgeInstanceFilter purgeInstanceFilter);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<WaitForOrchestrationAsync>d__132")]
public sealed virtual Task`1<OrchestrationState> WaitForOrchestrationAsync(string instanceId, string executionId, TimeSpan timeout, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task PurgeOrchestrationHistoryAsync(DateTime thresholdDateTimeUtc, OrchestrationStateTimeRangeFilterType timeRangeFilterType);
    [NullableContextAttribute("1")]
public Task`1<string> DownloadBlobAsync(string blobUri);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetControlQueueAsync>d__135")]
private Task`1<ControlQueue> GetControlQueueAsync(string instanceId);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.AzureStorageOrchestrationService/<GetOrchestrationWithQueryAsync>d__137")]
public sealed virtual Task`1<OrchestrationQueryResult> GetOrchestrationWithQueryAsync(OrchestrationQuery query, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static OrchestrationInstanceStatusQueryCondition ToAzureStorageCondition(OrchestrationQuery condition);
    [NullableContextAttribute("1")]
private static OrchestrationQueryResult ConvertFrom(DurableStatusQueryResult statusContext);
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__63_0();
    [CompilerGeneratedAttribute]
private Task <SendTaskOrchestrationMessageBatchAsync>b__114_0(TaskMessage msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DurableTask.AzureStorage.AzureStorageOrchestrationServiceSettings : object {
    internal static int DefaultPartitionCount;
    internal static TimeSpan DefaultMaxQueuePollingInterval;
    [NullableAttribute("2")]
private LogHelper logHelper;
    [CompilerGeneratedAttribute]
private string <AppName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ControlQueueBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ControlQueueBufferThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ControlQueueVisibilityTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WorkItemQueueVisibilityTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrackingStoreNamePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentTaskActivityWorkItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentTaskOrchestrationWorkItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentTaskEntityWorkItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStorageOperationConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCheckpointBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendedSessionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FetchLargeMessageDataEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExtendedSessionIdleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseRenewInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseAcquireInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxQueuePollingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAppLease>k__BackingField;
    [CompilerGeneratedAttribute]
private AppLeaseOptions <AppLeaseOptions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private StorageAccountClientProvider <StorageAccountClientProvider>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TrackingServiceClientProvider <TrackingServiceClientProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private BehaviorOnContinueAsNew <EventBehaviourForContinueAsNew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptionOnInvalidDedupeStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLegacyPartitionManagement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTablePartitionManagement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDataContractSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerFactory <LoggerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableExecutionStartedDeduplication>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICustomTypeBinder <CustomMessageTypeBinder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxEntityOperationBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EntityMessageReorderWindowInMinutes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSeparateQueueForEntityWorkItems>k__BackingField;
    public string AppName { get; public set; }
    public int ControlQueueBatchSize { get; public set; }
    public int ControlQueueBufferThreshold { get; public set; }
    public TimeSpan ControlQueueVisibilityTimeout { get; public set; }
    public TimeSpan WorkItemQueueVisibilityTimeout { get; public set; }
    public string TrackingStoreNamePrefix { get; public set; }
    public string TaskHubName { get; public set; }
    public int MaxConcurrentTaskActivityWorkItems { get; public set; }
    public int MaxConcurrentTaskOrchestrationWorkItems { get; public set; }
    public int MaxConcurrentTaskEntityWorkItems { get; public set; }
    public int MaxStorageOperationConcurrency { get; public set; }
    public int MaxCheckpointBatchSize { get; public set; }
    public string WorkerId { get; public set; }
    public int PartitionCount { get; public set; }
    public bool ExtendedSessionsEnabled { get; public set; }
    public bool FetchLargeMessageDataEnabled { get; public set; }
    public TimeSpan ExtendedSessionIdleTimeout { get; public set; }
    public TimeSpan LeaseRenewInterval { get; public set; }
    public TimeSpan LeaseAcquireInterval { get; public set; }
    public TimeSpan LeaseInterval { get; public set; }
    public TimeSpan MaxQueuePollingInterval { get; public set; }
    public bool UseAppLease { get; public set; }
    public AppLeaseOptions AppLeaseOptions { get; public set; }
    [NullableAttribute("2")]
public StorageAccountClientProvider StorageAccountClientProvider { get; public set; }
    [NullableAttribute("2")]
public TrackingServiceClientProvider TrackingServiceClientProvider { get; public set; }
    public BehaviorOnContinueAsNew EventBehaviourForContinueAsNew { get; public set; }
    public bool ThrowExceptionOnInvalidDedupeStatus { get; public set; }
    public bool UseLegacyPartitionManagement { get; public set; }
    public bool UseTablePartitionManagement { get; public set; }
    public bool UseDataContractSerialization { get; public set; }
    public ILoggerFactory LoggerFactory { get; public set; }
    public bool DisableExecutionStartedDeduplication { get; public set; }
    [NullableAttribute("2")]
public ICustomTypeBinder CustomMessageTypeBinder { get; public set; }
    public bool HasTrackingStoreStorageAccount { get; }
    internal string HistoryTableName { get; }
    internal string InstanceTableName { get; }
    internal string PartitionTableName { get; }
    internal LogHelper Logger { get; }
    public Nullable`1<int> MaxEntityOperationBatchSize { get; public set; }
    public int EntityMessageReorderWindowInMinutes { get; public set; }
    public bool UseSeparateQueueForEntityWorkItems { get; public set; }
    private static AzureStorageOrchestrationServiceSettings();
    [CompilerGeneratedAttribute]
public string get_AppName();
    [CompilerGeneratedAttribute]
public void set_AppName(string value);
    [CompilerGeneratedAttribute]
public int get_ControlQueueBatchSize();
    [CompilerGeneratedAttribute]
public void set_ControlQueueBatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_ControlQueueBufferThreshold();
    [CompilerGeneratedAttribute]
public void set_ControlQueueBufferThreshold(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ControlQueueVisibilityTimeout();
    [CompilerGeneratedAttribute]
public void set_ControlQueueVisibilityTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WorkItemQueueVisibilityTimeout();
    [CompilerGeneratedAttribute]
public void set_WorkItemQueueVisibilityTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_TrackingStoreNamePrefix();
    [CompilerGeneratedAttribute]
public void set_TrackingStoreNamePrefix(string value);
    [CompilerGeneratedAttribute]
public string get_TaskHubName();
    [CompilerGeneratedAttribute]
public void set_TaskHubName(string value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentTaskActivityWorkItems();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentTaskActivityWorkItems(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentTaskOrchestrationWorkItems();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentTaskOrchestrationWorkItems(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentTaskEntityWorkItems();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentTaskEntityWorkItems(int value);
    [CompilerGeneratedAttribute]
public int get_MaxStorageOperationConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaxStorageOperationConcurrency(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCheckpointBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxCheckpointBatchSize(int value);
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    [CompilerGeneratedAttribute]
public void set_WorkerId(string value);
    [CompilerGeneratedAttribute]
public int get_PartitionCount();
    [CompilerGeneratedAttribute]
public void set_PartitionCount(int value);
    [CompilerGeneratedAttribute]
public bool get_ExtendedSessionsEnabled();
    [CompilerGeneratedAttribute]
public void set_ExtendedSessionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_FetchLargeMessageDataEnabled();
    [CompilerGeneratedAttribute]
public void set_FetchLargeMessageDataEnabled(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ExtendedSessionIdleTimeout();
    [CompilerGeneratedAttribute]
public void set_ExtendedSessionIdleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseRenewInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseRenewInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseAcquireInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseAcquireInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxQueuePollingInterval();
    [CompilerGeneratedAttribute]
public void set_MaxQueuePollingInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_UseAppLease();
    [CompilerGeneratedAttribute]
public void set_UseAppLease(bool value);
    [CompilerGeneratedAttribute]
public AppLeaseOptions get_AppLeaseOptions();
    [CompilerGeneratedAttribute]
public void set_AppLeaseOptions(AppLeaseOptions value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public StorageAccountClientProvider get_StorageAccountClientProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_StorageAccountClientProvider(StorageAccountClientProvider value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TrackingServiceClientProvider get_TrackingServiceClientProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TrackingServiceClientProvider(TrackingServiceClientProvider value);
    [CompilerGeneratedAttribute]
public BehaviorOnContinueAsNew get_EventBehaviourForContinueAsNew();
    [CompilerGeneratedAttribute]
public void set_EventBehaviourForContinueAsNew(BehaviorOnContinueAsNew value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptionOnInvalidDedupeStatus();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptionOnInvalidDedupeStatus(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseLegacyPartitionManagement();
    [CompilerGeneratedAttribute]
public void set_UseLegacyPartitionManagement(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseTablePartitionManagement();
    [CompilerGeneratedAttribute]
public void set_UseTablePartitionManagement(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDataContractSerialization();
    [CompilerGeneratedAttribute]
public void set_UseDataContractSerialization(bool value);
    [CompilerGeneratedAttribute]
public ILoggerFactory get_LoggerFactory();
    [CompilerGeneratedAttribute]
public void set_LoggerFactory(ILoggerFactory value);
    [CompilerGeneratedAttribute]
public bool get_DisableExecutionStartedDeduplication();
    [CompilerGeneratedAttribute]
public void set_DisableExecutionStartedDeduplication(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICustomTypeBinder get_CustomMessageTypeBinder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CustomMessageTypeBinder(ICustomTypeBinder value);
    public bool get_HasTrackingStoreStorageAccount();
    internal string get_HistoryTableName();
    internal string get_InstanceTableName();
    internal string get_PartitionTableName();
    internal LogHelper get_Logger();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxEntityOperationBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxEntityOperationBatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_EntityMessageReorderWindowInMinutes();
    [CompilerGeneratedAttribute]
public void set_EntityMessageReorderWindowInMinutes(int value);
    [CompilerGeneratedAttribute]
public bool get_UseSeparateQueueForEntityWorkItems();
    [CompilerGeneratedAttribute]
public void set_UseSeparateQueueForEntityWorkItems(bool value);
}
internal class DurableTask.AzureStorage.BackoffPollingHelper : object {
    private RandomizedExponentialBackoffStrategy backoffStrategy;
    private AsyncAutoResetEvent resetEvent;
    public BackoffPollingHelper(TimeSpan minimumInterval, TimeSpan maximumInterval);
    public void Reset();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.BackoffPollingHelper/<WaitAsync>d__4")]
public Task`1<bool> WaitAsync(CancellationToken hostCancellationToken);
}
internal class DurableTask.AzureStorage.DataContractJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static DataContractJsonSerializer CreateSerializer(Type type, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.DefaultStorageServiceClientProvider`2 : object {
    private Func`2<TClientOptions, TClient> factory;
    private TClientOptions options;
    public DefaultStorageServiceClientProvider`2(Func`2<TClientOptions, TClient> factory, TClientOptions options);
    public sealed virtual TClient CreateClient(TClientOptions options);
    public sealed virtual TClientOptions CreateOptions();
}
internal class DurableTask.AzureStorage.DispatchQueue : object {
    private SemaphoreSlim messagesSemaphore;
    private ConcurrentQueue`1<Func`1<Task>> tasks;
    private int dispatcherCount;
    private int initialized;
    public DispatchQueue(int dispatcherCount);
    public void EnqueueAndDispatch(Func`1<Task> task);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.DispatchQueue/<DispatchLoop>d__6")]
private Task DispatchLoop();
    public sealed virtual void Dispose();
}
public class DurableTask.AzureStorage.DurableStatusQueryResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<OrchestrationState> <OrchestrationState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public IEnumerable`1<OrchestrationState> OrchestrationState { get; public set; }
    public string ContinuationToken { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<OrchestrationState> get_OrchestrationState();
    [CompilerGeneratedAttribute]
public void set_OrchestrationState(IEnumerable`1<OrchestrationState> value);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public void set_ContinuationToken(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.EntityTrackingStoreQueries : EntityBackendQueries {
    private MessageManager messageManager;
    private ITrackingStore trackingStore;
    private Func`1<Task> ensureTaskHub;
    private EntityBackendProperties properties;
    private Func`2<TaskMessage, Task> sendEvent;
    private static TimeSpan timeLimitForCleanEntityStorageLoop;
    public EntityTrackingStoreQueries(MessageManager messageManager, ITrackingStore trackingStore, Func`1<Task> ensureTaskHub, EntityBackendProperties properties, Func`2<TaskMessage, Task> sendEvent);
    private static EntityTrackingStoreQueries();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.EntityTrackingStoreQueries/<GetEntityAsync>d__7")]
public virtual Task`1<Nullable`1<EntityMetadata>> GetEntityAsync(EntityId id, bool includeState, bool includeStateless, CancellationToken cancellation);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.EntityTrackingStoreQueries/<QueryEntitiesAsync>d__8")]
public virtual Task`1<EntityQueryResult> QueryEntitiesAsync(EntityQuery filter, CancellationToken cancellation);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.EntityTrackingStoreQueries/<CleanEntityStorageAsync>d__9")]
public virtual Task`1<CleanEntityStorageResult> CleanEntityStorageAsync(CleanEntityStorageRequest request, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.EntityTrackingStoreQueries/<GetEntityMetadataAsync>d__10")]
private ValueTask`1<Nullable`1<EntityMetadata>> GetEntityMetadataAsync(OrchestrationState state, bool includeTransient, bool includeState);
    [CompilerGeneratedAttribute]
internal static bool <CleanEntityStorageAsync>g__OrchestrationIsRunning|9_2(Nullable`1<OrchestrationStatus> status);
}
internal static class DurableTask.AzureStorage.Fnv1aHashHelper : object {
    private static UInt32 FnvPrime;
    private static UInt32 FnvOffsetBasis;
    public static UInt32 ComputeHash(string value);
    public static UInt32 ComputeHash(string value, Encoding encoding);
    public static UInt32 ComputeHash(string value, Encoding encoding, UInt32 hash);
    public static UInt32 ComputeHash(Byte[] array);
    public static UInt32 ComputeHash(Byte[] array, UInt32 hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Http.LeaseTimeoutHttpPipelinePolicy : HttpPipelinePolicy {
    private TimeSpan leaseRenewalTimeout;
    public LeaseTimeoutHttpPipelinePolicy(TimeSpan leaseRenewalTimeout);
    public virtual void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    public virtual ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    private static bool IsBlobLeaseRenewal(string query, RequestHeaders headers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Http.MonitoringHttpPipelinePolicy : HttpPipelinePolicy {
    private AzureStorageOrchestrationServiceStats stats;
    public MonitoringHttpPipelinePolicy(AzureStorageOrchestrationServiceStats stats);
    public virtual void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    public virtual ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Http.ThrottlingHttpPipelinePolicy : HttpPipelinePolicy {
    private SemaphoreSlim throttle;
    public ThrottlingHttpPipelinePolicy(int maxRequests);
    public sealed virtual void Dispose();
    public virtual void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    public virtual ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Http.ThrottlingHttpPipelinePolicy/<ThrottledProcessNextAsync>d__5")]
private ValueTask ThrottledProcessNextAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline);
    private static bool IsBlobLease(string query);
}
public interface DurableTask.AzureStorage.ICustomTypeBinder {
    public abstract virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public abstract virtual Type BindToType(string assemblyName, string typeName);
}
[NullableContextAttribute("1")]
public interface DurableTask.AzureStorage.IStorageServiceClientProvider`2 {
    public abstract virtual TClientOptions CreateOptions();
    public abstract virtual TClient CreateClient(TClientOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DurableTask.AzureStorage.Linq.AsyncEnumerableExtensions : object {
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Linq.AsyncEnumerableExtensions/<SelectAsync>d__0`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<TResult> SelectAsync(IEnumerable`1<TSource> source, Func`3<TSource, CancellationToken, ValueTask`1<TResult>> selectAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static AsyncPageable`1<TResult> TransformPages(AsyncPageable`1<TSource> source, Func`2<Page`1<TSource>, IEnumerable`1<TResult>> transform);
    [ExtensionAttribute]
public static AsyncPageable`1<TResult> TransformPagesAsync(AsyncPageable`1<TSource> source, Func`3<Page`1<TSource>, CancellationToken, IAsyncEnumerable`1<TResult>> transformAsync);
}
internal static class DurableTask.AzureStorage.Logging.EventIds : object {
    public static int SendingMessage;
    public static int ReceivedMessage;
    public static int DeletingMessage;
    public static int AbandoningMessage;
    public static int AssertFailure;
    public static int MessageGone;
    public static int GeneralError;
    public static int DuplicateMessageDetected;
    public static int PoisonMessageDetected;
    public static int FetchedInstanceHistory;
    public static int AppendedInstanceHistory;
    public static int OrchestrationServiceStats;
    public static int RenewingMessage;
    public static int MessageFailure;
    public static int OrchestrationProcessingFailure;
    public static int PendingOrchestratorMessageLimitReached;
    public static int WaitingForMoreMessages;
    public static int ReceivedOutOfOrderMessage;
    public static int PartitionManagerInfo;
    public static int PartitionManagerWarning;
    public static int PartitionManagerError;
    public static int StartingLeaseRenewal;
    public static int LeaseRenewalResult;
    public static int LeaseRenewalFailed;
    public static int LeaseAcquisitionStarted;
    public static int LeaseAcquisitionSucceeded;
    public static int LeaseAcquisitionFailed;
    public static int AttemptingToStealLease;
    public static int LeaseStealingSucceeded;
    public static int LeaseStealingFailed;
    public static int PartitionRemoved;
    public static int LeaseRemoved;
    public static int LeaseRemovalFailed;
    public static int InstanceStatusUpdate;
    public static int FetchedInstanceStatus;
    public static int GeneralWarning;
    public static int SplitBrainDetected;
    public static int DiscardingWorkItem;
    public static int ProcessingMessage;
    public static int PurgeInstanceHistory;
}
internal static class DurableTask.AzureStorage.Logging.LogEvents : object {
}
internal class DurableTask.AzureStorage.Logging.LogHelper : object {
    private ILogger log;
    public LogHelper(ILogger log);
    internal void SendingMessage(Guid relatedActivityId, string account, string taskHub, string eventType, int taskEventId, string instanceId, string executionId, long sizeInBytes, string partitionId, string targetInstanceId, string targetExecutionId, long sequenceNumber, int episode);
    internal void ReceivedMessage(Guid relatedActivityId, string account, string taskHub, string eventType, int taskEventId, string instanceId, string executionId, string messageId, int age, long dequeueCount, string nextVisibleTime, long sizeInBytes, string partitionId, long sequenceNumber, string popReceipt, int episode);
    internal void DeletingMessage(string account, string taskHub, string eventType, int taskEventId, string messageId, string instanceId, string executionId, string partitionId, long sequenceNumber, string popReceipt);
    internal void AbandoningMessage(string account, string taskHub, string eventType, int taskEventId, string messageId, string instanceId, string executionId, string partitionId, long sequenceNumber, string popReceipt, int visibilityTimeoutSeconds);
    internal void AssertFailure(string account, string taskHub, string details);
    internal void MessageGone(string account, string taskHub, string messageId, string instanceId, string executionId, string partitionId, string eventType, int taskEventId, string details, string popReceipt);
    internal void GeneralError(string account, string taskHub, string details);
    internal void DuplicateMessageDetected(string account, string taskHub, string eventType, int taskEventId, string messageId, string instanceId, string executionId, string partitionId, long dequeueCount, string popReceipt);
    internal void PoisonMessageDetected(string account, string taskHub, string eventType, int taskEventId, string messageId, string instanceId, string executionId, string partitionId, long dequeueCount);
    internal void FetchedInstanceHistory(string account, string taskHub, string instanceId, string executionId, int eventCount, int episode, int requestCount, long latencyMs, string eTag, DateTime lastCheckpointTime);
    internal void AppendedInstanceHistory(string account, string taskHub, string instanceId, string executionId, int newEventCount, int totalEventCount, string newEvents, int episode, long latencyMs, int sizeInBytes, string eTag, bool isCheckpointComplete);
    internal void OrchestrationServiceStats(string account, string taskHub, long storageRequests, long messagesSent, long messagesRead, long messagesUpdated, long tableEntitiesWritten, long tableEntitiesRead, long pendingOrchestrators, long pendingOrchestratorMessages, long activeOrchestrators, long activeActivities);
    internal void RenewingMessage(string account, string taskHub, string instanceId, string executionId, string partitionId, string eventType, int taskEventId, string messageId, string popReceipt, int visibilityTimeoutSeconds);
    internal void MessageFailure(string account, string taskHub, string messageId, string instanceId, string executionId, string partitionId, string eventType, int taskEventId, string details);
    internal void OrchestrationProcessingFailure(string account, string taskHub, string instanceId, string executionId, string details);
    internal void PendingOrchestratorMessageLimitReached(string account, string taskHub, string partitionId, long pendingOrchestratorMessages);
    internal void WaitingForMoreMessages(string account, string taskHub, string partitionId);
    internal void ReceivedOutOfOrderMessage(string account, string taskHub, string instanceId, string executionId, string partitionId, string eventType, int taskEventId, string messageId, int episode, DateTime lastCheckpointTime);
    internal void PartitionManagerInfo(string account, string taskHub, string workerName, string partitionId, string details);
    internal void PartitionManagerWarning(string account, string taskHub, string workerName, string partitionId, string details);
    internal void PartitionManagerError(string account, string taskHub, string workerName, string partitionId, string details);
    internal void StartingLeaseRenewal(string account, string taskHub, string workerName, string partitionId, string token, string leaseType);
    internal void LeaseRenewalResult(string account, string taskHub, string workerName, string partitionId, bool success, string token, string leaseType, string details);
    internal void LeaseRenewalFailed(string account, string taskHub, string workerName, string partitionId, string token, string leaseType, string details);
    internal void LeaseAcquisitionStarted(string account, string taskHub, string workerName, string partitionId, string leaseType);
    internal void LeaseAcquisitionSucceeded(string account, string taskHub, string workerName, string partitionId, string leaseType);
    internal void LeaseAcquisitionFailed(string account, string taskHub, string workerName, string partitionId, string leaseType);
    internal void AttemptingToStealLease(string account, string taskHub, string workerName, string fromWorkerName, string leaseType, string partitionId);
    internal void LeaseStealingSucceeded(string account, string taskHub, string workerName, string fromWorkerName, string leaseType, string partitionId);
    internal void LeaseStealingFailed(string account, string taskHub, string workerName, string partitionId, string leaseType);
    internal void PartitionRemoved(string account, string taskHub, string workerName, string partitionId, string token);
    internal void LeaseRemoved(string account, string taskHub, string workerName, string partitionId, string token, string leaseType);
    internal void LeaseRemovalFailed(string account, string taskHub, string workerName, string partitionId, string token, string leaseType);
    internal void InstanceStatusUpdate(string account, string taskHub, string instanceId, string executionId, OrchestrationStatus runtimeStatus, int episode, long latencyMs);
    internal void FetchedInstanceStatus(string account, string taskHub, string instanceId, string executionId, string runtimeStatus, long latencyMs);
    internal void GeneralWarning(string account, string taskHub, string details, string instanceId);
    internal void SplitBrainDetected(string account, string taskHub, string instanceId, string executionId, int newEventCount, int totalEventCount, string newEvents, long latencyMs, string eTag);
    internal void DiscardingWorkItem(string account, string taskHub, string instanceId, string executionId, int newEventCount, int totalEventCount, string newEvents, string details);
    internal void ProcessingMessage(Guid relatedActivityId, string account, string taskHub, string eventType, int taskEventId, string instanceId, string executionId, string messageId, int age, long sequenceNumber, int episode, bool isExtendedSession);
    internal void PurgeInstanceHistory(string account, string taskHub, string instanceId, string createdTimeFrom, string createdTimeTo, string runtimeStatus, int requestCount, int instanceCount, long latencyMs);
    private void WriteStructuredLog(ILogEvent logEvent, Exception exception);
}
internal class DurableTask.AzureStorage.Logging.NoOpLoggerFactory : object {
    public static NoOpLoggerFactory Instance;
    private static NoOpLoggerFactory();
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
[DataContractAttribute]
public class DurableTask.AzureStorage.MessageData : object {
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskMessage <TaskMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompressedBlobName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Episode>k__BackingField;
    [CompilerGeneratedAttribute]
private OrchestrationInstance <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializableTraceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueMessage <OriginalQueueMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalMessageSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageFormatFlags <MessageFormat>k__BackingField;
    [DataMemberAttribute]
public Guid ActivityId { get; private set; }
    [DataMemberAttribute]
public TaskMessage TaskMessage { get; private set; }
    [DataMemberAttribute]
public string CompressedBlobName { get; public set; }
    [DataMemberAttribute]
public long SequenceNumber { get; public set; }
    [DataMemberAttribute]
public Nullable`1<int> Episode { get; private set; }
    [DataMemberAttribute]
[JsonPropertyAttribute]
public OrchestrationInstance Sender { get; private set; }
    [DataMemberAttribute]
public string SerializableTraceContext { get; public set; }
    internal string Id { get; }
    internal string QueueName { get; internal set; }
    internal QueueMessage OriginalQueueMessage { get; internal set; }
    internal long TotalMessageSizeBytes { get; internal set; }
    internal MessageFormatFlags MessageFormat { get; internal set; }
    public MessageData(TaskMessage message, Guid activityId, string queueName, Nullable`1<int> orchestrationEpisode, OrchestrationInstance sender);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public TaskMessage get_TaskMessage();
    [CompilerGeneratedAttribute]
private void set_TaskMessage(TaskMessage value);
    [CompilerGeneratedAttribute]
public string get_CompressedBlobName();
    [CompilerGeneratedAttribute]
public void set_CompressedBlobName(string value);
    [CompilerGeneratedAttribute]
public long get_SequenceNumber();
    [CompilerGeneratedAttribute]
public void set_SequenceNumber(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Episode();
    [CompilerGeneratedAttribute]
private void set_Episode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public OrchestrationInstance get_Sender();
    [CompilerGeneratedAttribute]
private void set_Sender(OrchestrationInstance value);
    [CompilerGeneratedAttribute]
public string get_SerializableTraceContext();
    [CompilerGeneratedAttribute]
public void set_SerializableTraceContext(string value);
    internal string get_Id();
    [CompilerGeneratedAttribute]
internal string get_QueueName();
    [CompilerGeneratedAttribute]
internal void set_QueueName(string value);
    [CompilerGeneratedAttribute]
internal QueueMessage get_OriginalQueueMessage();
    [CompilerGeneratedAttribute]
internal void set_OriginalQueueMessage(QueueMessage value);
    [CompilerGeneratedAttribute]
internal long get_TotalMessageSizeBytes();
    [CompilerGeneratedAttribute]
internal void set_TotalMessageSizeBytes(long value);
    [CompilerGeneratedAttribute]
internal MessageFormatFlags get_MessageFormat();
    [CompilerGeneratedAttribute]
internal void set_MessageFormat(MessageFormatFlags value);
    internal void Update(UpdateReceipt receipt);
}
[FlagsAttribute]
public enum DurableTask.AzureStorage.MessageFormatFlags : Enum {
    public int value__;
    public static MessageFormatFlags InlineJson;
    public static MessageFormatFlags StorageBlob;
}
internal class DurableTask.AzureStorage.MessageManager : object {
    private static int MaxStorageQueuePayloadSizeInBytes;
    private static int DefaultBufferSize;
    private AzureStorageOrchestrationServiceSettings settings;
    private AzureStorageClient azureStorageClient;
    private BlobContainer blobContainer;
    private JsonSerializerSettings taskMessageSerializerSettings;
    private JsonSerializer serializer;
    private bool containerInitialized;
    public MessageManager(AzureStorageOrchestrationServiceSettings settings, AzureStorageClient azureStorageClient, string blobContainerName);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<EnsureContainerAsync>d__9")]
public Task`1<bool> EnsureContainerAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<DeleteContainerAsync>d__10")]
public Task`1<bool> DeleteContainerAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<SerializeMessageDataAsync>d__11")]
public Task`1<string> SerializeMessageDataAsync(MessageData messageData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<FetchLargeMessageIfNecessary>d__12")]
public Task`1<string> FetchLargeMessageIfNecessary(string message, CancellationToken cancellationToken);
    internal static bool TryGetLargeMessageReference(string messagePayload, Uri& blobUrl);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<DeserializeQueueMessageAsync>d__14")]
public Task`1<MessageData> DeserializeQueueMessageAsync(QueueMessage queueMessage, string queueName, CancellationToken cancellationToken);
    internal MessageData DeserializeMessageData(string json);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<CompressAndUploadAsBytesAsync>d__16")]
public Task CompressAndUploadAsBytesAsync(Byte[] payloadBuffer, string blobName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<DownloadAndDecompressAsBytesAsync>d__17")]
public Task`1<string> DownloadAndDecompressAsBytesAsync(string blobName, CancellationToken cancellationToken);
    public Task`1<string> DownloadAndDecompressAsBytesAsync(Uri blobUri, CancellationToken cancellationToken);
    public Task`1<bool> DeleteBlobAsync(string blobName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<DownloadAndDecompressAsBytesAsync>d__20")]
private Task`1<string> DownloadAndDecompressAsBytesAsync(Blob blob, CancellationToken cancellationToken);
    public string GetBlobUrl(string blobName);
    public MessageFormatFlags GetMessageFormatFlags(MessageData messageData);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<UploadToBlobAsync>d__23")]
public Task UploadToBlobAsync(Byte[] data, int dataByteCount, string blobName, CancellationToken cancellationToken);
    public string GetNewLargeMessageBlobName(MessageData message);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.MessageManager/<DeleteLargeMessageBlobs>d__25")]
public Task`1<int> DeleteLargeMessageBlobs(string sanitizedInstanceId, CancellationToken cancellationToken);
}
internal class DurableTask.AzureStorage.Messaging.ActivitySession : SessionBase {
    private int orchestrationEpisode;
    [CompilerGeneratedAttribute]
private MessageData <MessageData>k__BackingField;
    public MessageData MessageData { get; }
    public ActivitySession(AzureStorageOrchestrationServiceSettings settings, string storageAccountName, MessageData message, Guid traceActivityId);
    [CompilerGeneratedAttribute]
public MessageData get_MessageData();
    public virtual int GetCurrentEpisode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Messaging.ControlQueue : TaskHubQueue {
    private static List`1<MessageData> EmptyMessageList;
    private CancellationTokenSource releaseTokenSource;
    private CancellationToken releaseCancellationToken;
    private AzureStorageOrchestrationServiceStats stats;
    [CompilerGeneratedAttribute]
private bool <IsReleased>k__BackingField;
    public bool IsReleased { get; private set; }
    protected TimeSpan MessageVisibilityTimeout { get; }
    public ControlQueue(AzureStorageClient azureStorageClient, string queueName, MessageManager messageManager);
    private static ControlQueue();
    [CompilerGeneratedAttribute]
public bool get_IsReleased();
    [CompilerGeneratedAttribute]
private void set_IsReleased(bool value);
    protected virtual TimeSpan get_MessageVisibilityTimeout();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.ControlQueue/<GetMessagesAsync>d__11")]
public Task`1<IReadOnlyList`1<MessageData>> GetMessagesAsync(CancellationToken cancellationToken);
    public Task`1<UpdateReceipt> AbandonMessageAsync(QueueMessage queueMessage);
    public virtual Task AbandonMessageAsync(MessageData message, SessionBase session);
    public virtual Task DeleteMessageAsync(MessageData message, SessionBase session);
    public void Release(Nullable`1<CloseReason> reason, string caller);
    public virtual void Dispose();
}
internal class DurableTask.AzureStorage.Messaging.MessageCollection : List`1<MessageData> {
    public void AddOrReplace(MessageData message);
}
internal class DurableTask.AzureStorage.Messaging.OrchestrationSession : SessionBase {
    private TimeSpan idleTimeout;
    private AsyncAutoResetEvent messagesAvailableEvent;
    private MessageCollection nextMessageBatch;
    [CompilerGeneratedAttribute]
private ControlQueue <ControlQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MessageData> <CurrentMessageBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageCollection <DeferredMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageCollection <DiscardedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private OrchestrationRuntimeState <RuntimeState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ETag> <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastCheckpointTime>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TrackingStoreContext>k__BackingField;
    public ControlQueue ControlQueue { get; }
    public List`1<MessageData> CurrentMessageBatch { get; private set; }
    public MessageCollection DeferredMessages { get; }
    public MessageCollection DiscardedMessages { get; }
    public OrchestrationRuntimeState RuntimeState { get; private set; }
    public Nullable`1<ETag> ETag { get; public set; }
    public DateTime LastCheckpointTime { get; }
    public object TrackingStoreContext { get; }
    public IReadOnlyList`1<MessageData> PendingMessages { get; }
    public OrchestrationSession(AzureStorageOrchestrationServiceSettings settings, string storageAccountName, OrchestrationInstance orchestrationInstance, ControlQueue controlQueue, List`1<MessageData> initialMessageBatch, OrchestrationRuntimeState runtimeState, Nullable`1<ETag> eTag, DateTime lastCheckpointTime, object trackingStoreContext, TimeSpan idleTimeout, Guid traceActivityId);
    [CompilerGeneratedAttribute]
public ControlQueue get_ControlQueue();
    [CompilerGeneratedAttribute]
public List`1<MessageData> get_CurrentMessageBatch();
    [CompilerGeneratedAttribute]
private void set_CurrentMessageBatch(List`1<MessageData> value);
    [CompilerGeneratedAttribute]
public MessageCollection get_DeferredMessages();
    [CompilerGeneratedAttribute]
public MessageCollection get_DiscardedMessages();
    [CompilerGeneratedAttribute]
public OrchestrationRuntimeState get_RuntimeState();
    [CompilerGeneratedAttribute]
private void set_RuntimeState(OrchestrationRuntimeState value);
    [CompilerGeneratedAttribute]
public Nullable`1<ETag> get_ETag();
    [CompilerGeneratedAttribute]
public void set_ETag(Nullable`1<ETag> value);
    [CompilerGeneratedAttribute]
public DateTime get_LastCheckpointTime();
    [CompilerGeneratedAttribute]
public object get_TrackingStoreContext();
    public IReadOnlyList`1<MessageData> get_PendingMessages();
    public virtual int GetCurrentEpisode();
    public void AddOrReplaceMessages(IEnumerable`1<MessageData> messages);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.OrchestrationSession/<FetchNewOrchestrationMessagesAsync>d__35")]
public sealed virtual Task`1<IList`1<TaskMessage>> FetchNewOrchestrationMessagesAsync(TaskOrchestrationWorkItem workItem);
    public void UpdateRuntimeState(OrchestrationRuntimeState runtimeState);
    public void DeferMessage(MessageData message);
    public void DiscardMessage(MessageData data);
    public bool IsOutOfOrderMessage(MessageData message);
    private Nullable`1<Guid> FindRequestId(string input);
    private bool IsNonexistantInstance();
    [CompilerGeneratedAttribute]
private bool <AddOrReplaceMessages>b__34_0();
}
internal abstract class DurableTask.AzureStorage.Messaging.SessionBase : object {
    private AzureStorageOrchestrationServiceSettings settings;
    private string storageAccountName;
    private string taskHubName;
    [CompilerGeneratedAttribute]
private OrchestrationInstance <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TraceActivityId>k__BackingField;
    public OrchestrationInstance Instance { get; protected set; }
    public Guid TraceActivityId { get; }
    public SessionBase(AzureStorageOrchestrationServiceSettings settings, string storageAccountName, OrchestrationInstance orchestrationInstance, Guid traceActivityId);
    [CompilerGeneratedAttribute]
public OrchestrationInstance get_Instance();
    [CompilerGeneratedAttribute]
protected void set_Instance(OrchestrationInstance value);
    [CompilerGeneratedAttribute]
public Guid get_TraceActivityId();
    public void StartNewLogicalTraceScope();
    public void TraceProcessingMessage(MessageData data, bool isExtendedSession);
    public abstract virtual int GetCurrentEpisode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DurableTask.AzureStorage.Messaging.TaskHubQueue : object {
    private static long messageSequenceNumber;
    protected AzureStorageClient azureStorageClient;
    protected Queue storageQueue;
    protected MessageManager messageManager;
    protected string storageAccountName;
    protected AzureStorageOrchestrationServiceSettings settings;
    protected BackoffPollingHelper backoffHelper;
    public string Name { get; }
    public Uri Uri { get; }
    protected TimeSpan MessageVisibilityTimeout { get; }
    internal Queue InnerQueue { get; }
    public TaskHubQueue(AzureStorageClient azureStorageClient, string queueName, MessageManager messageManager);
    public string get_Name();
    public Uri get_Uri();
    protected abstract virtual TimeSpan get_MessageVisibilityTimeout();
    internal Queue get_InnerQueue();
    public Task AddMessageAsync(TaskMessage message, SessionBase sourceSession);
    public Task`1<MessageData> AddMessageAsync(TaskMessage message, OrchestrationInstance sourceInstance);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<AddMessageAsync>d__18")]
private Task`1<MessageData> AddMessageAsync(TaskMessage taskMessage, OrchestrationInstance sourceInstance, SessionBase session);
    private static string GetSerializableTraceContext(TaskMessage taskMessage);
    private static Nullable`1<TimeSpan> GetVisibilityDelay(TaskMessage taskMessage);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<AbandonMessageAsync>d__21")]
public virtual Task AbandonMessageAsync(MessageData message, SessionBase session);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<AbandonMessageAsync>d__22")]
protected Task`1<UpdateReceipt> AbandonMessageAsync(QueueMessage queueMessage, TaskMessage taskMessage, OrchestrationInstance instance, Nullable`1<Guid> traceActivityId, long sequenceNumber);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<RenewMessageAsync>d__23")]
public Task RenewMessageAsync(MessageData message, SessionBase session);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<DeleteMessageAsync>d__24")]
public virtual Task DeleteMessageAsync(MessageData message, SessionBase session);
    private bool IsMessageGoneException(Exception e);
    private void HandleMessagingExceptions(Exception e, MessageData message, string details);
    private void HandleMessagingExceptions(Exception e, string messageId, string instanceId, string executionId, string eventType, int taskEventId, string details, string popReceipt);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<CreateIfNotExistsAsync>d__28")]
public Task CreateIfNotExistsAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.TaskHubQueue/<DeleteIfExistsAsync>d__29")]
public Task DeleteIfExistsAsync();
}
internal class DurableTask.AzureStorage.Messaging.WorkItemQueue : TaskHubQueue {
    protected TimeSpan MessageVisibilityTimeout { get; }
    public WorkItemQueue(AzureStorageClient azureStorageClient, string queueName, MessageManager messageManager);
    protected virtual TimeSpan get_MessageVisibilityTimeout();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Messaging.WorkItemQueue/<GetMessageAsync>d__3")]
public Task`1<MessageData> GetMessageAsync(CancellationToken cancellationToken);
}
internal class DurableTask.AzureStorage.Monitoring.AzureStorageOrchestrationServiceStats : object {
    [CompilerGeneratedAttribute]
private Counter <StorageRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <MessagesSent>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <MessagesRead>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <MessagesUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <TableEntitiesWritten>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <TableEntitiesRead>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <ActiveActivityExecutions>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, byte> <PendingOrchestratorMessages>k__BackingField;
    public Counter StorageRequests { get; }
    public Counter MessagesSent { get; }
    public Counter MessagesRead { get; }
    public Counter MessagesUpdated { get; }
    public Counter TableEntitiesWritten { get; }
    public Counter TableEntitiesRead { get; }
    public Counter ActiveActivityExecutions { get; }
    public ConcurrentDictionary`2<string, byte> PendingOrchestratorMessages { get; }
    [CompilerGeneratedAttribute]
public Counter get_StorageRequests();
    [CompilerGeneratedAttribute]
public Counter get_MessagesSent();
    [CompilerGeneratedAttribute]
public Counter get_MessagesRead();
    [CompilerGeneratedAttribute]
public Counter get_MessagesUpdated();
    [CompilerGeneratedAttribute]
public Counter get_TableEntitiesWritten();
    [CompilerGeneratedAttribute]
public Counter get_TableEntitiesRead();
    [CompilerGeneratedAttribute]
public Counter get_ActiveActivityExecutions();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, byte> get_PendingOrchestratorMessages();
}
public class DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor : object {
    internal static int QueueLengthSampleSize;
    internal static int MaxMessagesPerWorkerRatio;
    private static int LowLatencyThreshold;
    private static Random Random;
    private List`1<QueueMetricHistory> controlQueueLatencies;
    private QueueMetricHistory workItemQueueLatencies;
    private AzureStorageOrchestrationServiceSettings settings;
    private AzureStorageClient azureStorageClient;
    private int maxPollingLatency;
    private int highLatencyThreshold;
    private int currentPartitionCount;
    private int currentWorkItemQueueLength;
    private Int32[] currentControlQueueLengths;
    [CompilerGeneratedAttribute]
private bool <EnableRandomScaleDownOnLowLatency>k__BackingField;
    public bool EnableRandomScaleDownOnLowLatency { get; public set; }
    internal int PartitionCount { get; }
    internal List`1<QueueMetricHistory> ControlQueueLatencies { get; }
    internal QueueMetricHistory WorkItemQueueLatencies { get; }
    public DisconnectedPerformanceMonitor(string storageConnectionString, string taskHub, Nullable`1<int> maxPollingIntervalMilliseconds);
    public DisconnectedPerformanceMonitor(AzureStorageOrchestrationServiceSettings settings);
    private static DisconnectedPerformanceMonitor();
    [CompilerGeneratedAttribute]
public bool get_EnableRandomScaleDownOnLowLatency();
    [CompilerGeneratedAttribute]
public void set_EnableRandomScaleDownOnLowLatency(bool value);
    internal virtual int get_PartitionCount();
    internal List`1<QueueMetricHistory> get_ControlQueueLatencies();
    internal QueueMetricHistory get_WorkItemQueueLatencies();
    private static AzureStorageOrchestrationServiceSettings GetSettings(string connectionString, string taskHub, Nullable`1<int> maxPollingIntervalMilliseconds);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<PulseAsync>d__26")]
public virtual Task`1<PerformanceHeartbeat> PulseAsync(int currentWorkerCount);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<PulseAsync>d__27")]
public virtual Task`1<PerformanceHeartbeat> PulseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<UpdateQueueMetrics>d__28")]
internal virtual Task`1<bool> UpdateQueueMetrics();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<GetQueueMetricsAsync>d__29")]
private Task`1<QueueMetric> GetQueueMetricsAsync(Queue queue);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<GetQueueLatencyAsync>d__30")]
private static Task`1<TimeSpan> GetQueueLatencyAsync(Queue queue);
    private static Task`1<int> GetQueueLengthAsync(Queue queue);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<GetWorkItemQueueStatusAsync>d__33")]
protected virtual Task`1<WorkItemQueueData> GetWorkItemQueueStatusAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Monitoring.DisconnectedPerformanceMonitor/<GetAggregateControlQueueLengthAsync>d__34")]
protected virtual Task`1<ControlQueueData> GetAggregateControlQueueLengthAsync();
    public virtual ScaleRecommendation MakeScaleRecommendation(int workerCount);
    public virtual ScaleRecommendation MakeScaleRecommendation(int workerCount, PerformanceHeartbeat[] performanceHeartbeats);
    internal ScaleRecommendation MakeScaleRecommendation(int workerCount, int partitionCount, QueueMetricHistory workItemQueueLatencyHistory, List`1<QueueMetricHistory> controlQueueLatencyHistory);
    private bool IsHighLatency(QueueMetricHistory history);
    private static bool IsLowLatency(QueueMetricHistory history);
    private static bool IsIdle(QueueMetricHistory history);
}
public class DurableTask.AzureStorage.Monitoring.PerformanceHeartbeat : object {
    [CompilerGeneratedAttribute]
private int <PartitionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<int> <ControlQueueLengths>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TimeSpan> <ControlQueueLatencies>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WorkItemQueueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <WorkItemQueueLatencyTrend>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WorkItemQueueLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private ScaleRecommendation <ScaleRecommendation>k__BackingField;
    public int PartitionCount { get; public set; }
    public IReadOnlyList`1<int> ControlQueueLengths { get; public set; }
    public IReadOnlyList`1<TimeSpan> ControlQueueLatencies { get; public set; }
    public int WorkItemQueueLength { get; public set; }
    public double WorkItemQueueLatencyTrend { get; public set; }
    public TimeSpan WorkItemQueueLatency { get; public set; }
    public ScaleRecommendation ScaleRecommendation { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_PartitionCount();
    [CompilerGeneratedAttribute]
public void set_PartitionCount(int value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<int> get_ControlQueueLengths();
    [CompilerGeneratedAttribute]
public void set_ControlQueueLengths(IReadOnlyList`1<int> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TimeSpan> get_ControlQueueLatencies();
    [CompilerGeneratedAttribute]
public void set_ControlQueueLatencies(IReadOnlyList`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_WorkItemQueueLength();
    [CompilerGeneratedAttribute]
public void set_WorkItemQueueLength(int value);
    [CompilerGeneratedAttribute]
public double get_WorkItemQueueLatencyTrend();
    [CompilerGeneratedAttribute]
public void set_WorkItemQueueLatencyTrend(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WorkItemQueueLatency();
    [CompilerGeneratedAttribute]
public void set_WorkItemQueueLatency(TimeSpan value);
    [CompilerGeneratedAttribute]
public ScaleRecommendation get_ScaleRecommendation();
    [CompilerGeneratedAttribute]
internal void set_ScaleRecommendation(ScaleRecommendation value);
    public virtual string ToString();
}
public enum DurableTask.AzureStorage.Monitoring.ScaleAction : Enum {
    public int value__;
    public static ScaleAction None;
    public static ScaleAction AddWorker;
    public static ScaleAction RemoveWorker;
}
public class DurableTask.AzureStorage.Monitoring.ScaleRecommendation : EventArgs {
    [CompilerGeneratedAttribute]
private ScaleAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepWorkersAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public ScaleAction Action { get; }
    public bool KeepWorkersAlive { get; }
    public string Reason { get; }
    internal ScaleRecommendation(ScaleAction scaleAction, bool keepWorkersAlive, string reason);
    [CompilerGeneratedAttribute]
public ScaleAction get_Action();
    [CompilerGeneratedAttribute]
public bool get_KeepWorkersAlive();
    [CompilerGeneratedAttribute]
public string get_Reason();
    public virtual string ToString();
}
internal static class DurableTask.AzureStorage.Net.UriPath : object {
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2);
}
internal class DurableTask.AzureStorage.OrchestrationInstanceStatus : object {
    [CompilerGeneratedAttribute]
private string <ExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastUpdatedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CompletedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ScheduledStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RowKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    public string ExecutionId { get; public set; }
    public string Name { get; public set; }
    public string Version { get; public set; }
    public string Input { get; public set; }
    public string Output { get; public set; }
    public string CustomStatus { get; public set; }
    public DateTime CreatedTime { get; public set; }
    public DateTime LastUpdatedTime { get; public set; }
    public Nullable`1<DateTime> CompletedTime { get; public set; }
    public string RuntimeStatus { get; public set; }
    public Nullable`1<DateTime> ScheduledStartTime { get; public set; }
    public int Generation { get; public set; }
    public string Tags { get; public set; }
    public string PartitionKey { get; public set; }
    public string RowKey { get; public set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; public set; }
    public ETag ETag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExecutionId();
    [CompilerGeneratedAttribute]
public void set_ExecutionId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Input();
    [CompilerGeneratedAttribute]
public void set_Input(string value);
    [CompilerGeneratedAttribute]
public string get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(string value);
    [CompilerGeneratedAttribute]
public string get_CustomStatus();
    [CompilerGeneratedAttribute]
public void set_CustomStatus(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedTime();
    [CompilerGeneratedAttribute]
public void set_CreatedTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastUpdatedTime();
    [CompilerGeneratedAttribute]
public void set_LastUpdatedTime(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CompletedTime();
    [CompilerGeneratedAttribute]
public void set_CompletedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_RuntimeStatus();
    [CompilerGeneratedAttribute]
public void set_RuntimeStatus(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ScheduledStartTime();
    [CompilerGeneratedAttribute]
public void set_ScheduledStartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public int get_Generation();
    [CompilerGeneratedAttribute]
public void set_Generation(int value);
    [CompilerGeneratedAttribute]
public string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PartitionKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RowKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RowKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual ETag get_ETag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ETag(ETag value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.OrchestrationSessionManager : object {
    private Dictionary`2<string, OrchestrationSession> activeOrchestrationSessions;
    private ConcurrentDictionary`2<string, ControlQueue> ownedControlQueues;
    private LinkedList`1<PendingMessageBatch> pendingOrchestrationMessageBatches;
    private AsyncQueue`1<LinkedListNode`1<PendingMessageBatch>> orchestrationsReadyForProcessingQueue;
    private AsyncQueue`1<LinkedListNode`1<PendingMessageBatch>> entitiesReadyForProcessingQueue;
    private object messageAndSessionLock;
    private string storageAccountName;
    private AzureStorageOrchestrationServiceSettings settings;
    private AzureStorageOrchestrationServiceStats stats;
    private ITrackingStore trackingStore;
    private DispatchQueue fetchRuntimeStateQueue;
    internal IEnumerable`1<ControlQueue> Queues { get; }
    public OrchestrationSessionManager(string queueAccountName, AzureStorageOrchestrationServiceSettings settings, AzureStorageOrchestrationServiceStats stats, ITrackingStore trackingStore);
    internal IEnumerable`1<ControlQueue> get_Queues();
    public void AddQueue(string partitionId, ControlQueue controlQueue, CancellationToken cancellationToken);
    public void RemoveQueue(string partitionId, Nullable`1<CloseReason> reason, string caller);
    public void ReleaseQueue(string partitionId, Nullable`1<CloseReason> reason, string caller);
    public bool ResumeListeningIfOwnQueue(string partitionId, ControlQueue controlQueue, CancellationToken shutdownToken);
    public bool IsControlQueueReceivingMessages(string partitionId);
    public bool IsControlQueueProcessingMessages(string partitionId);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.OrchestrationSessionManager/<DequeueLoop>d__20")]
private Task DequeueLoop(string partitionId, ControlQueue controlQueue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.OrchestrationSessionManager/<DrainAsync>d__21")]
public Task DrainAsync(string partitionId, CloseReason reason, CancellationToken cancellationToken, string caller);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.OrchestrationSessionManager/<DedupeExecutionStartedMessagesAsync>d__22")]
private Task`1<IEnumerable`1<MessageData>> DedupeExecutionStartedMessagesAsync(ControlQueue controlQueue, IReadOnlyList`1<MessageData> messages, Guid traceActivityId, CancellationToken cancellationToken);
    private bool IsScheduledAfterInstanceUpdate(MessageData msg, OrchestrationState remoteInstance);
    internal void AddMessageToPendingOrchestration(ControlQueue controlQueue, IEnumerable`1<MessageData> queueMessages, Guid traceActivityId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.OrchestrationSessionManager/<ScheduleOrchestrationStatePrefetch>d__25")]
private Task ScheduleOrchestrationStatePrefetch(LinkedListNode`1<PendingMessageBatch> node, Guid traceActivityId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.OrchestrationSessionManager/<GetNextSessionAsync>d__26")]
public Task`1<OrchestrationSession> GetNextSessionAsync(bool entitiesOnly, CancellationToken cancellationToken);
    public bool TryGetExistingSession(string instanceId, OrchestrationSession& session);
    public bool TryReleaseSession(string instanceId, CancellationToken cancellationToken, OrchestrationSession& session);
    public void GetStats(Int32& pendingOrchestratorInstances, Int32& pendingOrchestrationMessages, Int32& activeOrchestrationSessions);
    public virtual void Dispose();
}
internal class DurableTask.AzureStorage.Partitioning.AppLeaseManager : object {
    private static string LeaseType;
    private AzureStorageClient azureStorageClient;
    private IPartitionManager partitionManager;
    private AzureStorageOrchestrationServiceSettings settings;
    private string appLeaseContainerName;
    private string appLeaseInfoBlobName;
    private AppLeaseOptions options;
    private string storageAccountName;
    private string taskHub;
    private string workerName;
    private string appName;
    private bool appLeaseIsEnabled;
    private BlobContainer appLeaseContainer;
    private Blob appLeaseInfoBlob;
    private string appLeaseId;
    private AsyncManualResetEvent shutdownCompletedEvent;
    private bool isLeaseOwner;
    private int appLeaseIsStarted;
    private Task renewTask;
    private Task acquireTask;
    private CancellationTokenSource starterTokenSource;
    private CancellationTokenSource leaseRenewerCancellationTokenSource;
    public AppLeaseManager(AzureStorageClient azureStorageClient, IPartitionManager partitionManager, string appLeaseContainerName, string appLeaseInfoBlobName, AppLeaseOptions options);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<StartAsync>d__23")]
public Task StartAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<PartitionManagerStarter>d__24")]
private Task PartitionManagerStarter(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<RestartAppLeaseStarterTask>d__25")]
private Task RestartAppLeaseStarterTask();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<AppLeaseManagerStarter>d__26")]
private Task AppLeaseManagerStarter(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<StopAsync>d__27")]
public Task StopAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<ForceChangeAppLeaseAsync>d__28")]
public Task ForceChangeAppLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<CreateContainerIfNotExistsAsync>d__29")]
public Task`1<bool> CreateContainerIfNotExistsAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<DeleteContainerAsync>d__30")]
public Task DeleteContainerAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<CreateAppLeaseInfoIfNotExistsAsync>d__31")]
private Task CreateAppLeaseInfoIfNotExistsAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<StartAppLeaseAsync>d__32")]
private Task StartAppLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<StopAppLeaseAsync>d__33")]
private Task StopAppLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<TryAcquireAppLeaseAsync>d__34")]
private Task`1<bool> TryAcquireAppLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<ChangeLeaseAsync>d__35")]
private Task`1<bool> ChangeLeaseAsync(string currentLeaseId);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<TryAcquireLeaseAsync>d__36")]
private Task`1<bool> TryAcquireLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<LeaseRenewer>d__37")]
private Task LeaseRenewer(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<RenewLeaseAsync>d__38")]
private Task`1<bool> RenewLeaseAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<UpdateOwnerAppIdToCurrentApp>d__39")]
private Task UpdateOwnerAppIdToCurrentApp();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<UpdateDesiredSwapAppIdToCurrentApp>d__40")]
private Task UpdateDesiredSwapAppIdToCurrentApp();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<UpdateAppLeaseInfoBlob>d__41")]
private Task UpdateAppLeaseInfoBlob(AppLeaseInfo appLeaseInfo);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.AppLeaseManager/<GetAppLeaseInfoAsync>d__42")]
private Task`1<AppLeaseInfo> GetAppLeaseInfoAsync();
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__23_0();
    [CompilerGeneratedAttribute]
private Task <RestartAppLeaseStarterTask>b__25_0();
    [CompilerGeneratedAttribute]
private Task <StartAppLeaseAsync>b__32_0();
}
public class DurableTask.AzureStorage.Partitioning.AppLeaseOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <RenewInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AcquireInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseInterval>k__BackingField;
    public TimeSpan RenewInterval { get; public set; }
    public TimeSpan AcquireInterval { get; public set; }
    public TimeSpan LeaseInterval { get; public set; }
    public static AppLeaseOptions DefaultOptions { get; }
    [CompilerGeneratedAttribute]
public TimeSpan get_RenewInterval();
    [CompilerGeneratedAttribute]
public void set_RenewInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_AcquireInterval();
    [CompilerGeneratedAttribute]
public void set_AcquireInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseInterval(TimeSpan value);
    public static AppLeaseOptions get_DefaultOptions();
}
internal class DurableTask.AzureStorage.Partitioning.BlobPartitionLease : Lease {
    [CompilerGeneratedAttribute]
private Blob <Blob>k__BackingField;
    [JsonIgnoreAttribute]
public Blob Blob { get; public set; }
    public BlobPartitionLease(Blob leaseBlob);
    public BlobPartitionLease(BlobPartitionLease source);
    [CompilerGeneratedAttribute]
public Blob get_Blob();
    [CompilerGeneratedAttribute]
public void set_Blob(Blob value);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLease/<IsExpiredAsync>d__7")]
public virtual Task`1<bool> IsExpiredAsync(CancellationToken cancellationToken);
}
internal class DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager : object {
    private static string TaskHubInfoBlobName;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceSettings settings;
    private string storageAccountName;
    private string taskHubName;
    private string workerName;
    private string leaseContainerName;
    private TimeSpan leaseInterval;
    private BlobContainer taskHubContainer;
    private string blobDirectoryName;
    private Blob taskHubInfoBlob;
    public BlobPartitionLeaseManager(AzureStorageClient azureStorageClient, string leaseContainerName, string leaseType);
    public sealed virtual Task`1<bool> LeaseStoreExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<CreateLeaseStoreIfNotExistsAsync>d__13")]
public sealed virtual Task`1<bool> CreateLeaseStoreIfNotExistsAsync(TaskHubInfo eventHubInfo, bool checkIfStale, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<ListLeasesAsync>d__14")]
public sealed virtual IAsyncEnumerable`1<BlobPartitionLease> ListLeasesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<CreateLeaseIfNotExistAsync>d__15")]
public sealed virtual Task CreateLeaseIfNotExistAsync(string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<GetLeaseAsync>d__16")]
public sealed virtual Task`1<BlobPartitionLease> GetLeaseAsync(string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<RenewAsync>d__17")]
public sealed virtual Task`1<bool> RenewAsync(BlobPartitionLease lease, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<AcquireAsync>d__18")]
public sealed virtual Task`1<bool> AcquireAsync(BlobPartitionLease lease, string owner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<ReleaseAsync>d__19")]
public sealed virtual Task`1<bool> ReleaseAsync(BlobPartitionLease lease, CancellationToken cancellationToken);
    public sealed virtual Task DeleteAsync(BlobPartitionLease lease, CancellationToken cancellationToken);
    public sealed virtual Task DeleteAllAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<UpdateAsync>d__22")]
public sealed virtual Task`1<bool> UpdateAsync(BlobPartitionLease lease, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<CreateTaskHubInfoIfNotExistAsync>d__23")]
public Task CreateTaskHubInfoIfNotExistAsync(TaskHubInfo taskHubInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<GetOrCreateTaskHubInfoAsync>d__24")]
internal Task`1<TaskHubInfo> GetOrCreateTaskHubInfoAsync(TaskHubInfo newTaskHubInfo, bool checkIfStale, CancellationToken cancellationToken);
    private bool IsStale(TaskHubInfo currentTaskHubInfo, TaskHubInfo newTaskHubInfo);
    private void Initialize();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<GetTaskHubInfoAsync>d__27")]
private Task`1<TaskHubInfo> GetTaskHubInfoAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.BlobPartitionLeaseManager/<DownloadLeaseBlob>d__28")]
private Task`1<BlobPartitionLease> DownloadLeaseBlob(Blob blob, CancellationToken cancellationToken);
    private static Exception HandleStorageException(Lease lease, DurableTaskStorageException storageException, bool ignoreLeaseLost);
}
internal enum DurableTask.AzureStorage.Partitioning.CloseReason : Enum {
    public int value__;
    public static CloseReason Shutdown;
    public static CloseReason LeaseLost;
}
internal interface DurableTask.AzureStorage.Partitioning.ILeaseManager`1 {
    public abstract virtual Task`1<bool> LeaseStoreExistsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CreateLeaseStoreIfNotExistsAsync(TaskHubInfo eventHubInfo, bool checkIfStale, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<T> ListLeasesAsync(CancellationToken cancellationToken);
    public abstract virtual Task CreateLeaseIfNotExistAsync(string partitionId, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetLeaseAsync(string partitionId, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> RenewAsync(T lease, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AcquireAsync(T lease, string owner, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ReleaseAsync(T lease, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(T lease, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAllAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> UpdateAsync(T lease, CancellationToken cancellationToken);
}
internal interface DurableTask.AzureStorage.Partitioning.IPartitionManager {
    public abstract virtual Task StartAsync();
    public abstract virtual Task StopAsync();
    public abstract virtual Task CreateLeaseStore();
    public abstract virtual Task CreateLease(string leaseName);
    public abstract virtual Task DeleteLeases();
    public abstract virtual IAsyncEnumerable`1<BlobPartitionLease> GetOwnershipBlobLeasesAsync(CancellationToken cancellationToken);
}
internal class DurableTask.AzureStorage.Partitioning.Lease : object {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Epoch>k__BackingField;
    public string PartitionId { get; public set; }
    public string Owner { get; public set; }
    public string Token { get; public set; }
    public long Epoch { get; public set; }
    public Lease(Lease source);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public void set_PartitionId(string value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [CompilerGeneratedAttribute]
public long get_Epoch();
    [CompilerGeneratedAttribute]
public void set_Epoch(long value);
    public virtual Task`1<bool> IsExpiredAsync(CancellationToken cancellationToken);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1 : object {
    private string leaseType;
    private string accountName;
    private string taskHub;
    private string workerName;
    private ILeaseManager`1<T> leaseManager;
    private LeaseCollectionBalancerOptions options;
    private AzureStorageOrchestrationServiceSettings settings;
    private ConcurrentDictionary`2<string, T> currentlyOwnedShards;
    private ConcurrentDictionary`2<string, T> keepRenewingDuringClose;
    private LeaseObserverManager<T> leaseObserverManager;
    private Func`2<string, bool> shouldAquireLeaseDelegate;
    private Func`2<string, bool> shouldRenewLeaseDelegate;
    private int isStarted;
    private bool shutdownComplete;
    private Task renewTask;
    private Task takerTask;
    private CancellationTokenSource leaseTakerCancellationTokenSource;
    private CancellationTokenSource leaseRenewerCancellationTokenSource;
    public LeaseCollectionBalancer`1(string leaseType, AzureStorageOrchestrationServiceSettings settings, string blobAccountName, ILeaseManager`1<T> leaseManager, LeaseCollectionBalancerOptions options, Func`2<string, bool> shouldAquireLeaseDelegate, Func`2<string, bool> shouldRenewLeaseDelegate);
    private static bool DefaultLeaseDecisionDelegate(string leaseId);
    public ConcurrentDictionary`2<string, T> GetCurrentlyOwnedLeases();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<InitializeAsync>d__21")]
public Task InitializeAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<StartAsync>d__22")]
public Task StartAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<StopAsync>d__23")]
public Task StopAsync();
    public Task`1<IDisposable> SubscribeAsync(Func`2<T, Task> leaseAquiredDelegate, Func`3<T, CloseReason, Task> leaseReleasedDelegate);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<TryReleasePartitionAsync>d__25")]
public Task TryReleasePartitionAsync(string partitionId, string leaseToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<LeaseRenewer>d__26")]
private Task LeaseRenewer();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<LeaseTakerAsync>d__27")]
private Task LeaseTakerAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<TakeLeasesAsync>d__28")]
private Task`1<IDictionary`2<string, T>> TakeLeasesAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<ShutdownAsync>d__29")]
private Task ShutdownAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<RenewLeaseAsync>d__30")]
private Task`1<bool> RenewLeaseAsync(T lease);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<AcquireLeaseAsync>d__31")]
private Task`1<bool> AcquireLeaseAsync(T lease);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<StealLeaseAsync>d__32")]
private Task`1<bool> StealLeaseAsync(T lease);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<AddLeaseAsync>d__33")]
private Task AddLeaseAsync(T lease);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancer`1/<RemoveLeaseAsync>d__34")]
private Task RemoveLeaseAsync(T lease, bool hasOwnership);
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__22_0();
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__22_1();
    [CompilerGeneratedAttribute]
private Task <LeaseRenewer>b__26_0(T lease);
    [CompilerGeneratedAttribute]
private Task <ShutdownAsync>b__29_0(T lease);
}
internal class DurableTask.AzureStorage.Partitioning.LeaseCollectionBalancerOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <RenewInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AcquireInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldStealLeases>k__BackingField;
    public TimeSpan RenewInterval { get; public set; }
    public TimeSpan AcquireInterval { get; public set; }
    public TimeSpan LeaseInterval { get; public set; }
    public bool ShouldStealLeases { get; public set; }
    public static LeaseCollectionBalancerOptions DefaultOptions { get; }
    [CompilerGeneratedAttribute]
public TimeSpan get_RenewInterval();
    [CompilerGeneratedAttribute]
public void set_RenewInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_AcquireInterval();
    [CompilerGeneratedAttribute]
public void set_AcquireInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseInterval();
    [CompilerGeneratedAttribute]
public void set_LeaseInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_ShouldStealLeases();
    [CompilerGeneratedAttribute]
public void set_ShouldStealLeases(bool value);
    public static LeaseCollectionBalancerOptions get_DefaultOptions();
}
internal class DurableTask.AzureStorage.Partitioning.LeaseLostException : Exception {
    [CompilerGeneratedAttribute]
private Lease <Lease>k__BackingField;
    public Lease Lease { get; private set; }
    public LeaseLostException(Lease lease);
    public LeaseLostException(Lease lease, Exception innerException);
    public LeaseLostException(string message);
    public LeaseLostException(string message, Exception innerException);
    protected LeaseLostException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Lease get_Lease();
    [CompilerGeneratedAttribute]
private void set_Lease(Lease value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class DurableTask.AzureStorage.Partitioning.LeaseObserver`1 : object {
    private Func`2<T, Task> leaseAquiredDelegate;
    private Func`3<T, CloseReason, Task> leaseReleasedDelegate;
    public LeaseObserver`1(Func`2<T, Task> leaseAquiredDelegate, Func`3<T, CloseReason, Task> leaseReleasedDelegate);
    public Task OnLeaseAquiredAsync(T lease);
    public Task OnLeaseReleasedAsync(T lease, CloseReason reason);
}
internal class DurableTask.AzureStorage.Partitioning.LegacyPartitionManager : object {
    private AzureStorageOrchestrationService service;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceSettings settings;
    private BlobPartitionLeaseManager leaseManager;
    private LeaseCollectionBalancer`1<BlobPartitionLease> leaseCollectionManager;
    public LegacyPartitionManager(AzureStorageOrchestrationService service, AzureStorageClient azureStorageClient);
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLease(string leaseName);
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLeaseStore();
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.DeleteLeases();
    private sealed virtual override IAsyncEnumerable`1<BlobPartitionLease> DurableTask.AzureStorage.Partitioning.IPartitionManager.GetOwnershipBlobLeasesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.LegacyPartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-StartAsync>d__10")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StartAsync();
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StopAsync();
}
internal class DurableTask.AzureStorage.Partitioning.SafePartitionManager : object {
    private AzureStorageOrchestrationService service;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceSettings settings;
    private OrchestrationSessionManager sessionManager;
    private BlobPartitionLeaseManager intentLeaseManager;
    private LeaseCollectionBalancer`1<BlobPartitionLease> intentLeaseCollectionManager;
    private BlobPartitionLeaseManager ownershipLeaseManager;
    private LeaseCollectionBalancer`1<BlobPartitionLease> ownershipLeaseCollectionManager;
    private IDisposable intentLeaseSubscription;
    private IDisposable ownershipLeaseSubscription;
    public SafePartitionManager(AzureStorageOrchestrationService service, AzureStorageClient azureStorageClient, OrchestrationSessionManager sessionManager);
    private sealed virtual override IAsyncEnumerable`1<BlobPartitionLease> DurableTask.AzureStorage.Partitioning.IPartitionManager.GetOwnershipBlobLeasesAsync(CancellationToken cancellationToken);
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLeaseStore();
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.DeleteLeases();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.SafePartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-StartAsync>d__14")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StartAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.SafePartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-StopAsync>d__15")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StopAsync();
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLease(string leaseName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DurableTask.AzureStorage.Partitioning.TablePartitionLease : object {
    [NullableAttribute("1")]
internal static string DefaultPartitionKey;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RowKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <OwnedSince>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastRenewal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpiresAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDraining>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    [NullableAttribute("1")]
public string PartitionKey { get; public set; }
    public string RowKey { get; public set; }
    public string CurrentOwner { get; public set; }
    public string NextOwner { get; public set; }
    public Nullable`1<DateTime> OwnedSince { get; public set; }
    public Nullable`1<DateTime> LastRenewal { get; public set; }
    public Nullable`1<DateTime> ExpiresAt { get; public set; }
    public bool IsDraining { get; public set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; public set; }
    public ETag ETag { get; public set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_PartitionKey();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RowKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RowKey(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentOwner();
    [CompilerGeneratedAttribute]
public void set_CurrentOwner(string value);
    [CompilerGeneratedAttribute]
public string get_NextOwner();
    [CompilerGeneratedAttribute]
public void set_NextOwner(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_OwnedSince();
    [CompilerGeneratedAttribute]
public void set_OwnedSince(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastRenewal();
    [CompilerGeneratedAttribute]
public void set_LastRenewal(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpiresAt();
    [CompilerGeneratedAttribute]
public void set_ExpiresAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsDraining();
    [CompilerGeneratedAttribute]
public void set_IsDraining(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual ETag get_ETag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ETag(ETag value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Partitioning.TablePartitionManager : object {
    private static string NotApplicable;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationService service;
    private AzureStorageOrchestrationServiceSettings settings;
    private CancellationTokenSource gracefulShutdownTokenSource;
    private CancellationTokenSource forcefulShutdownTokenSource;
    private string storageAccountName;
    private Table partitionTable;
    private TableLeaseManager tableLeaseManager;
    private LeaseCollectionBalancerOptions options;
    private Task partitionManagerTask;
    public TablePartitionManager(AzureStorageOrchestrationService service, AzureStorageClient azureStorageClient);
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StartAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.TablePartitionManager/<PartitionManagerLoop>d__13")]
private Task PartitionManagerLoop(CancellationToken gracefulShutdownToken, CancellationToken forcefulShutdownToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.TablePartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-StopAsync>d__14")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.StopAsync();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.TablePartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-CreateLeaseStore>d__15")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLeaseStore();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Partitioning.TablePartitionManager/<DurableTask-AzureStorage-Partitioning-IPartitionManager-CreateLease>d__16")]
private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.CreateLease(string partitionId);
    private sealed virtual override IAsyncEnumerable`1<BlobPartitionLease> DurableTask.AzureStorage.Partitioning.IPartitionManager.GetOwnershipBlobLeasesAsync(CancellationToken cancellationToken);
    internal IAsyncEnumerable`1<TablePartitionLease> GetTableLeasesAsync(CancellationToken cancellationToken);
    private sealed virtual override Task DurableTask.AzureStorage.Partitioning.IPartitionManager.DeleteLeases();
    internal void SimulateUnhealthyWorker(CancellationToken testToken);
    internal void KillLoop();
    public sealed virtual void Dispose();
}
internal class DurableTask.AzureStorage.Partitioning.TaskHubInfo : object {
    [CompilerGeneratedAttribute]
private string <TaskHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PartitionCount>k__BackingField;
    public string TaskHubName { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public int PartitionCount { get; private set; }
    public TaskHubInfo(string TaskHubName, DateTime createdAt, int partitionCount);
    [CompilerGeneratedAttribute]
public string get_TaskHubName();
    [CompilerGeneratedAttribute]
private void set_TaskHubName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
private void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public int get_PartitionCount();
    [CompilerGeneratedAttribute]
private void set_PartitionCount(int value);
}
public class DurableTask.AzureStorage.PurgeHistoryResult : object {
    [CompilerGeneratedAttribute]
private int <StorageRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstancesDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowsDeleted>k__BackingField;
    public int StorageRequests { get; }
    public int InstancesDeleted { get; }
    public int RowsDeleted { get; }
    public PurgeHistoryResult(int storageRequests, int instancesDeleted, int rowsDeleted);
    [CompilerGeneratedAttribute]
public int get_StorageRequests();
    [CompilerGeneratedAttribute]
public int get_InstancesDeleted();
    [CompilerGeneratedAttribute]
public int get_RowsDeleted();
    public PurgeResult ToCorePurgeHistoryResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.AzureStorageClient : object {
    private BlobServiceClient blobClient;
    private QueueServiceClient queueClient;
    private TableServiceClient tableClient;
    [CompilerGeneratedAttribute]
private AzureStorageOrchestrationServiceSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureStorageOrchestrationServiceStats <Stats>k__BackingField;
    public AzureStorageOrchestrationServiceSettings Settings { get; }
    public AzureStorageOrchestrationServiceStats Stats { get; }
    public string BlobAccountName { get; }
    public string QueueAccountName { get; }
    public string TableAccountName { get; }
    public AzureStorageClient(AzureStorageOrchestrationServiceSettings settings);
    [CompilerGeneratedAttribute]
public AzureStorageOrchestrationServiceSettings get_Settings();
    [CompilerGeneratedAttribute]
public AzureStorageOrchestrationServiceStats get_Stats();
    public string get_BlobAccountName();
    public string get_QueueAccountName();
    public string get_TableAccountName();
    public Blob GetBlobReference(string container, string blobName);
    internal Blob GetBlobReference(Uri blobUri);
    public BlobContainer GetBlobContainerReference(string container);
    public Queue GetQueueReference(string queueName);
    public Table GetTableReference(string tableName);
    private static TClient CreateClient(IStorageServiceClientProvider`2<TClient, TClientOptions> storageProvider, Action`1<TClientOptions> configurePolicies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.Blob : object {
    private BlockBlobClient blockBlobClient;
    public string Name { get; }
    public Uri Uri { get; }
    public Blob(BlobServiceClient blobServiceClient, string containerName, string blobName);
    public Blob(BlobServiceClient blobServiceClient, Uri blobUri);
    public string get_Name();
    public Uri get_Uri();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<ExistsAsync>d__7")]
public Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<DeleteIfExistsAsync>d__8")]
public Task`1<bool> DeleteIfExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<IsLeasedAsync>d__9")]
public Task`1<bool> IsLeasedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<UploadTextAsync>d__10")]
public Task UploadTextAsync(string content, string leaseId, bool ifDoesntExist, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<UploadFromByteArrayAsync>d__11")]
public Task UploadFromByteArrayAsync(Byte[] buffer, int index, int byteCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<OpenWriteAsync>d__12")]
public Task`1<Stream> OpenWriteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<DownloadTextAsync>d__13")]
public Task`1<string> DownloadTextAsync(CancellationToken cancellationToken);
    public Task DownloadToStreamAsync(MemoryStream target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<DownloadStreamingAsync>d__15")]
public Task`1<BlobDownloadStreamingResult> DownloadStreamingAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<AcquireLeaseAsync>d__16")]
public Task`1<string> AcquireLeaseAsync(TimeSpan leaseInterval, string leaseId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Blob/<ChangeLeaseAsync>d__17")]
public Task`1<string> ChangeLeaseAsync(string proposedLeaseId, string currentLeaseId, CancellationToken cancellationToken);
    public Task RenewLeaseAsync(string leaseId, CancellationToken cancellationToken);
    public Task ReleaseLeaseAsync(string leaseId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.BlobContainer : object {
    private AzureStorageClient azureStorageClient;
    private string containerName;
    private BlobContainerClient blobContainerClient;
    public BlobContainer(AzureStorageClient azureStorageClient, BlobServiceClient blobServiceClient, string name);
    public Blob GetBlobReference(string blobName, string blobPrefix);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.BlobContainer/<CreateIfNotExistsAsync>d__5")]
public Task`1<bool> CreateIfNotExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.BlobContainer/<ExistsAsync>d__6")]
public Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.BlobContainer/<DeleteIfExistsAsync>d__7")]
public Task`1<bool> DeleteIfExistsAsync(string appLeaseId, CancellationToken cancellationToken);
    public AsyncPageable`1<Blob> ListBlobsAsync(string prefix, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.BlobContainer/<AcquireLeaseAsync>d__9")]
public Task`1<string> AcquireLeaseAsync(TimeSpan leaseInterval, string leaseId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.BlobContainer/<ChangeLeaseAsync>d__10")]
public Task`1<string> ChangeLeaseAsync(string proposedLeaseId, string currentLeaseId, CancellationToken cancellationToken);
    public Task RenewLeaseAsync(string leaseId, CancellationToken cancellationToken);
    private static bool IsHnsFolder(BlobItem item);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Blob> <ListBlobsAsync>b__8_0(Page`1<BlobItem> p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Blob <ListBlobsAsync>b__8_2(BlobItem b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DurableTask.AzureStorage.Storage.ClientResponseExtensions : object {
    [ExtensionAttribute]
public static AsyncPageable`1<T> DecorateFailure(AsyncPageable`1<T> paginatedResponse);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.ClientResponseExtensions/<DecorateFailure>d__1")]
[ExtensionAttribute]
public static Task`1<Response> DecorateFailure(Task`1<Response> responseTask);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.ClientResponseExtensions/<DecorateFailure>d__2`1")]
[ExtensionAttribute]
public static Task`1<Response`1<T>> DecorateFailure(Task`1<Response`1<T>> responseTask);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.DurableTaskStorageException : Exception {
    [CompilerGeneratedAttribute]
private int <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LeaseLost>k__BackingField;
    public int HttpStatusCode { get; }
    public bool LeaseLost { get; }
    public DurableTaskStorageException(string message);
    public DurableTaskStorageException(string message, Exception inner);
    public DurableTaskStorageException(RequestFailedException requestFailedException);
    [CompilerGeneratedAttribute]
public int get_HttpStatusCode();
    [CompilerGeneratedAttribute]
public bool get_LeaseLost();
}
internal static class DurableTask.AzureStorage.Storage.OperationContext : object {
    [NullableContextAttribute("1")]
public static IDisposable CreateClientRequestScope(Nullable`1<Guid> clientRequestId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.Queue : object {
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceStats stats;
    private QueueClient queueClient;
    public string Name { get; }
    public Uri Uri { get; }
    public Queue(AzureStorageClient azureStorageClient, QueueServiceClient queueServiceClient, string queueName);
    public string get_Name();
    public Uri get_Uri();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<GetApproximateMessagesCountAsync>d__8")]
public Task`1<int> GetApproximateMessagesCountAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<AddMessageAsync>d__9")]
public Task AddMessageAsync(string message, Nullable`1<TimeSpan> visibilityDelay, Nullable`1<Guid> clientRequestId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<UpdateMessageAsync>d__10")]
public Task`1<UpdateReceipt> UpdateMessageAsync(QueueMessage queueMessage, TimeSpan visibilityTimeout, Nullable`1<Guid> clientRequestId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<DeleteMessageAsync>d__11")]
public Task DeleteMessageAsync(QueueMessage queueMessage, Nullable`1<Guid> clientRequestId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<GetMessageAsync>d__12")]
public Task`1<QueueMessage> GetMessageAsync(TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<ExistsAsync>d__13")]
public Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<CreateIfNotExistsAsync>d__14")]
public Task`1<bool> CreateIfNotExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<DeleteIfExistsAsync>d__15")]
public Task`1<bool> DeleteIfExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<GetMessagesAsync>d__16")]
public Task`1<IReadOnlyCollection`1<QueueMessage>> GetMessagesAsync(int batchSize, TimeSpan visibilityTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<PeekMessagesAsync>d__17")]
public Task`1<IReadOnlyCollection`1<PeekedMessage>> PeekMessagesAsync(int batchSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Queue/<PeekMessageAsync>d__18")]
public Task`1<PeekedMessage> PeekMessageAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class DurableTask.AzureStorage.Storage.QueueExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.QueueExtensions/<UpdateMessageAsync>d__0")]
[ExtensionAttribute]
public static Task UpdateMessageAsync(Queue queue, MessageData messageData, TimeSpan visibilityTimeout, Nullable`1<Guid> clientRequestId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.Table : object {
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceStats stats;
    private TableServiceClient tableServiceClient;
    private TableClient tableClient;
    public string Name { get; }
    internal Uri Uri { get; }
    public Table(AzureStorageClient azureStorageClient, TableServiceClient tableServiceClient, string tableName);
    public string get_Name();
    internal Uri get_Uri();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<CreateIfNotExistsAsync>d__9")]
public Task`1<bool> CreateIfNotExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<DeleteIfExistsAsync>d__10")]
public Task`1<bool> DeleteIfExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<ExistsAsync>d__11")]
public Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<DeleteAsync>d__12")]
public Task DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<ReplaceEntityAsync>d__13`1")]
public Task ReplaceEntityAsync(T tableEntity, ETag ifMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<DeleteEntityAsync>d__14`1")]
public Task DeleteEntityAsync(T tableEntity, ETag ifMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<InsertEntityAsync>d__15`1")]
public Task InsertEntityAsync(T tableEntity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<MergeEntityAsync>d__16`1")]
public Task MergeEntityAsync(T tableEntity, ETag ifMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<InsertOrMergeEntityAsync>d__17`1")]
public Task InsertOrMergeEntityAsync(T tableEntity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<InsertOrReplaceEntityAsync>d__18`1")]
public Task InsertOrReplaceEntityAsync(T tableEntity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<DeleteBatchAsync>d__19`1")]
public Task`1<TableTransactionResults> DeleteBatchAsync(IEnumerable`1<T> entityBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<InsertOrMergeBatchAsync>d__20`1")]
public Task`1<TableTransactionResults> InsertOrMergeBatchAsync(IEnumerable`1<T> entityBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<ExecuteBatchAsync>d__21`1")]
private Task`1<TableTransactionResults> ExecuteBatchAsync(IEnumerable`1<T> entityBatch, Func`2<T, TableTransactionAction> batchOperation, int batchSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.Table/<ExecuteBatchAsync>d__22")]
public Task`1<TableTransactionResults> ExecuteBatchAsync(IEnumerable`1<TableTransactionAction> batchOperation, CancellationToken cancellationToken);
    public TableQueryResponse`1<T> ExecuteQueryAsync(string filter, Nullable`1<int> maxPerPage, IEnumerable`1<string> select, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DurableTask.AzureStorage.Storage.TableQueryResponse`1 : AsyncPageable`1<T> {
    private AsyncPageable`1<T> query;
    public TableQueryResponse`1(AsyncPageable`1<T> query);
    public virtual IAsyncEnumerable`1<Page`1<T>> AsPages(string continuationToken, Nullable`1<int> pageSizeHint);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Storage.TableQueryResponse`1/<GetResultsAsync>d__3")]
public Task`1<TableQueryResults`1<T>> GetResultsAsync(string continuationToken, Nullable`1<int> pageSizeHint, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.TableQueryResults`1 : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<T> <Entities>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestCount>k__BackingField;
    public IReadOnlyList`1<T> Entities { get; }
    public TimeSpan Elapsed { get; }
    public int ElapsedMilliseconds { get; }
    public int RequestCount { get; }
    public TableQueryResults`1(IReadOnlyList`1<T> entities, TimeSpan elapsed, int requestCount);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<T> get_Entities();
    [CompilerGeneratedAttribute]
public TimeSpan get_Elapsed();
    public int get_ElapsedMilliseconds();
    [CompilerGeneratedAttribute]
public int get_RequestCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.TableTransactionResults : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Response> <Responses>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestCount>k__BackingField;
    public IReadOnlyList`1<Response> Responses { get; }
    public TimeSpan Elapsed { get; }
    public int ElapsedMilliseconds { get; }
    public int RequestCount { get; }
    public TableTransactionResults(IReadOnlyList`1<Response> responses, TimeSpan elapsed, int requestCount);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Response> get_Responses();
    [CompilerGeneratedAttribute]
public TimeSpan get_Elapsed();
    public int get_ElapsedMilliseconds();
    [CompilerGeneratedAttribute]
public int get_RequestCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DurableTask.AzureStorage.Storage.TableTransactionResultsBuilder : object {
    private TimeSpan _elapsed;
    private int _requestCount;
    private List`1<Response> _responses;
    public TableTransactionResultsBuilder Add(TableTransactionResults batch);
    public TableTransactionResults ToResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DurableTask.AzureStorage.StorageAccountClientProvider : TrackingServiceClientProvider {
    [CompilerGeneratedAttribute]
private IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> <Queue>k__BackingField;
    public IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> Queue { get; }
    public StorageAccountClientProvider(string connectionString);
    public StorageAccountClientProvider(string accountName, TokenCredential tokenCredential);
    public StorageAccountClientProvider(Uri blobServiceUri, Uri queueServiceUri, Uri tableServiceUri, TokenCredential tokenCredential);
    public StorageAccountClientProvider(IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> blob, IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> queue, IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> table);
    [CompilerGeneratedAttribute]
public IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> get_Queue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class DurableTask.AzureStorage.StorageServiceClientProvider : object {
    public static IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> ForBlob(string connectionString, BlobClientOptions options);
    public static IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> ForBlob(string accountName, TokenCredential tokenCredential, BlobClientOptions options);
    public static IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> ForBlob(Uri serviceUri, TokenCredential tokenCredential, BlobClientOptions options);
    public static IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> ForQueue(string connectionString, QueueClientOptions options);
    public static IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> ForQueue(string accountName, TokenCredential tokenCredential, QueueClientOptions options);
    public static IStorageServiceClientProvider`2<QueueServiceClient, QueueClientOptions> ForQueue(Uri serviceUri, TokenCredential tokenCredential, QueueClientOptions options);
    public static IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> ForTable(string connectionString, TableClientOptions options);
    public static IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> ForTable(string accountName, TokenCredential tokenCredential, TableClientOptions options);
    public static IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> ForTable(Uri serviceUri, TokenCredential tokenCredential, TableClientOptions options);
    private static Uri CreateDefaultServiceUri(string accountName, string service);
}
internal class DurableTask.AzureStorage.Tracking.AzureTableTrackingStore : TrackingStoreBase {
    private static string NameProperty;
    private static string InputProperty;
    private static string ResultProperty;
    private static string OutputProperty;
    private static string RowKeyProperty;
    private static string PartitionKeyProperty;
    private static string TimestampProperty;
    private static string SentinelRowKey;
    private static string IsCheckpointCompleteProperty;
    private static string CheckpointCompletedTimestampProperty;
    private static int MaxTablePropertySizeInBytes;
    private static String[] VariableSizeEntityProperties;
    private string storageAccountName;
    private string taskHubName;
    private AzureStorageClient azureStorageClient;
    private AzureStorageOrchestrationServiceSettings settings;
    private AzureStorageOrchestrationServiceStats stats;
    private IReadOnlyDictionary`2<EventType, Type> eventTypeMap;
    private MessageManager messageManager;
    [CompilerGeneratedAttribute]
private Table <HistoryTable>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <InstancesTable>k__BackingField;
    internal Table HistoryTable { get; }
    internal Table InstancesTable { get; }
    public AzureTableTrackingStore(AzureStorageClient azureStorageClient, MessageManager messageManager);
    internal AzureTableTrackingStore(AzureStorageOrchestrationServiceStats stats, Table instancesTable);
    private static AzureTableTrackingStore();
    [CompilerGeneratedAttribute]
internal Table get_HistoryTable();
    [CompilerGeneratedAttribute]
internal Table get_InstancesTable();
    public virtual Task CreateAsync(CancellationToken cancellationToken);
    public virtual Task DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<ExistsAsync>d__29")]
public virtual Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<GetHistoryEventsAsync>d__30")]
public virtual Task`1<OrchestrationHistory> GetHistoryEventsAsync(string instanceId, string expectedExecutionId, CancellationToken cancellationToken);
    private TableQueryResponse`1<TableEntity> GetHistoryEntitiesResponseInfoAsync(string instanceId, string expectedExecutionId, IList`1<string> projectionColumns, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<QueryHistoryAsync>d__32")]
private Task`1<IReadOnlyList`1<TableEntity>> QueryHistoryAsync(string filter, string instanceId, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<RewindHistoryAsync>d__33")]
public virtual IAsyncEnumerable`1<string> RewindHistoryAsync(string instanceId, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<GetStateAsync>d__34")]
public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(string instanceId, bool allExecutions, bool fetchInput, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<GetStateAsync>d__35")]
public virtual Task`1<OrchestrationState> GetStateAsync(string instanceId, string executionId, bool fetchInput, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual Task`1<InstanceStatus> FetchInstanceStatusAsync(string instanceId, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<FetchInstanceStatusInternalAsync>d__37")]
internal Task`1<InstanceStatus> FetchInstanceStatusInternalAsync(string instanceId, bool fetchInput, CancellationToken cancellationToken);
    private Task`1<OrchestrationState> ConvertFromAsync(OrchestrationInstanceStatus tableEntity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<ConvertFromAsync>d__39")]
private Task`1<OrchestrationState> ConvertFromAsync(OrchestrationInstanceStatus orchestrationInstanceStatus, string instanceId, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<GetStateAsync>d__40")]
public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(IEnumerable`1<string> instanceIds, CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(CancellationToken cancellationToken);
    public virtual AsyncPageable`1<OrchestrationState> GetStateAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<OrchestrationState> GetStateAsync(OrchestrationInstanceStatusQueryCondition condition, CancellationToken cancellationToken);
    private AsyncPageable`1<OrchestrationState> QueryStateAsync(string filter, IEnumerable`1<string> select, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<DeleteHistoryAsync>d__45")]
private Task`1<PurgeHistoryResult> DeleteHistoryAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<DeleteAllDataForOrchestrationInstance>d__46")]
private Task`1<PurgeHistoryResult> DeleteAllDataForOrchestrationInstance(OrchestrationInstanceStatus orchestrationInstanceStatus, CancellationToken cancellationToken);
    public virtual Task PurgeHistoryAsync(DateTime thresholdDateTimeUtc, OrchestrationStateTimeRangeFilterType timeRangeFilterType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<PurgeInstanceHistoryAsync>d__48")]
public virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(string instanceId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<PurgeInstanceHistoryAsync>d__49")]
public virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<SetNewExecutionAsync>d__50")]
public virtual Task`1<bool> SetNewExecutionAsync(ExecutionStartedEvent executionStartedEvent, Nullable`1<ETag> eTag, string inputPayloadOverride, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<UpdateStatusForRewindAsync>d__51")]
public virtual Task UpdateStatusForRewindAsync(string instanceId, CancellationToken cancellationToken);
    public virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<UpdateStateAsync>d__53")]
public virtual Task`1<Nullable`1<ETag>> UpdateStateAsync(OrchestrationRuntimeState newRuntimeState, OrchestrationRuntimeState oldRuntimeState, string instanceId, string executionId, Nullable`1<ETag> eTagValue, object trackingStoreContext, CancellationToken cancellationToken);
    private static int GetEstimatedByteCount(TableEntity entity);
    private Type GetTypeForTableEntity(TableEntity tableEntity);
    private void SetInstancesTablePropertyFromHistoryProperty(TableEntity TableEntity, TableEntity instanceEntity, string historyPropertyName, string instancePropertyName, string data);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<CompressLargeMessageAsync>d__57")]
private Task CompressLargeMessageAsync(TableEntity entity, List`1<string> listOfBlobs, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<DecompressLargeEntityProperties>d__58")]
private Task DecompressLargeEntityProperties(TableEntity entity, List`1<string> listOfBlobs, CancellationToken cancellationToken);
    private static string GetBlobPropertyName(string originalPropertyName);
    private static string GetBlobName(TableEntity entity, string property);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.AzureTableTrackingStore/<UploadHistoryBatch>d__61")]
private Task`1<Nullable`1<ETag>> UploadHistoryBatch(string instanceId, string sanitizedInstanceId, string executionId, IList`1<TableTransactionAction> historyEventBatch, StringBuilder historyEventNamesBuffer, int numberOfTotalEvents, int episodeNumber, int estimatedBatchSizeInBytes, Nullable`1<ETag> eTagValue, bool isFinalBatch, CancellationToken cancellationToken);
    private bool ExceedsMaxTablePropertySize(string data);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IAsyncEnumerable`1<OrchestrationState> <QueryStateAsync>b__44_0(Page`1<OrchestrationInstanceStatus> p, CancellationToken t);
    [CompilerGeneratedAttribute]
private ValueTask`1<OrchestrationState> <QueryStateAsync>b__44_1(OrchestrationInstanceStatus s, CancellationToken t);
}
internal class DurableTask.AzureStorage.Tracking.InstanceStatus : object {
    [CompilerGeneratedAttribute]
private OrchestrationState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ETag <ETag>k__BackingField;
    public OrchestrationState State { get; }
    public ETag ETag { get; }
    public InstanceStatus(OrchestrationState state);
    public InstanceStatus(OrchestrationState state, Nullable`1<ETag> eTag);
    [CompilerGeneratedAttribute]
public OrchestrationState get_State();
    [CompilerGeneratedAttribute]
public ETag get_ETag();
}
internal class DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore : TrackingStoreBase {
    private IOrchestrationServiceInstanceStore instanceStore;
    public InstanceStoreBackedTrackingStore(IOrchestrationServiceInstanceStore instanceStore);
    public virtual Task CreateAsync(CancellationToken cancellationToken);
    public virtual Task DeleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<GetHistoryEventsAsync>d__4")]
public virtual Task`1<OrchestrationHistory> GetHistoryEventsAsync(string instanceId, string expectedExecutionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<FetchInstanceStatusAsync>d__5")]
public virtual Task`1<InstanceStatus> FetchInstanceStatusAsync(string instanceId, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<GetStateAsync>d__6")]
public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(string instanceId, bool allExecutions, bool fetchInput, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<GetStateAsync>d__7")]
public virtual Task`1<OrchestrationState> GetStateAsync(string instanceId, string executionId, bool fetchInput, CancellationToken cancellationToken);
    public virtual Task PurgeHistoryAsync(DateTime thresholdDateTimeUtc, OrchestrationStateTimeRangeFilterType timeRangeFilterType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<SetNewExecutionAsync>d__9")]
public virtual Task`1<bool> SetNewExecutionAsync(ExecutionStartedEvent executionStartedEvent, Nullable`1<ETag> eTag, string inputStatusOverride, CancellationToken cancellationToken);
    public virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<UpdateStateAsync>d__11")]
public virtual Task`1<Nullable`1<ETag>> UpdateStateAsync(OrchestrationRuntimeState newRuntimeState, OrchestrationRuntimeState oldRuntimeState, string instanceId, string executionId, Nullable`1<ETag> eTag, object executionData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Tracking.InstanceStoreBackedTrackingStore/<UpdateStateAsync>d__12")]
private Task`1<Nullable`1<ETag>> UpdateStateAsync(OrchestrationRuntimeState runtimeState, string instanceId, string executionId, Nullable`1<ETag> eTag, CancellationToken cancellationToken);
}
internal interface DurableTask.AzureStorage.Tracking.ITrackingStore {
    public abstract virtual Task CreateAsync(CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    public abstract virtual Task StartAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<OrchestrationHistory> GetHistoryEventsAsync(string instanceId, string expectedExecutionId, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<string> RewindHistoryAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ETag>> UpdateStateAsync(OrchestrationRuntimeState newRuntimeState, OrchestrationRuntimeState oldRuntimeState, string instanceId, string executionId, Nullable`1<ETag> eTag, object trackingStoreContext, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(string instanceId, bool allExecutions, bool fetchInput, CancellationToken cancellationToken);
    public abstract virtual Task`1<OrchestrationState> GetStateAsync(string instanceId, string executionId, bool fetchInput, CancellationToken cancellationToken);
    public abstract virtual Task`1<InstanceStatus> FetchInstanceStatusAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(IEnumerable`1<string> instanceIds, CancellationToken cancellationToken);
    public abstract virtual AsyncPageable`1<OrchestrationState> GetStateAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    public abstract virtual AsyncPageable`1<OrchestrationState> GetStateAsync(OrchestrationInstanceStatusQueryCondition condition, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> SetNewExecutionAsync(ExecutionStartedEvent executionStartedEvent, Nullable`1<ETag> eTag, string inputPayloadOverride, CancellationToken cancellationToken);
    public abstract virtual Task UpdateStatusForRewindAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task PurgeHistoryAsync(DateTime thresholdDateTimeUtc, OrchestrationStateTimeRangeFilterType timeRangeFilterType, CancellationToken cancellationToken);
    public abstract virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
}
internal static class DurableTask.AzureStorage.Tracking.KeySanitation : object {
    private static char escapeChar;
    private static char offset;
    public static string EscapePartitionKey(string key);
    public static string UnescapePartitionKey(string key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DurableTask.AzureStorage.Tracking.ODataCondition : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Select>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> Select { get; }
    public string Filter { get; }
    public ODataCondition(IEnumerable`1<string> select, string filter);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Select();
    [CompilerGeneratedAttribute]
public string get_Filter();
}
internal class DurableTask.AzureStorage.Tracking.OrchestrationHistory : object {
    [CompilerGeneratedAttribute]
private IList`1<HistoryEvent> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ETag> <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastCheckpointTime>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TrackingStoreContext>k__BackingField;
    public IList`1<HistoryEvent> Events { get; }
    public Nullable`1<ETag> ETag { get; }
    public DateTime LastCheckpointTime { get; }
    public object TrackingStoreContext { get; }
    public OrchestrationHistory(IList`1<HistoryEvent> historyEvents);
    public OrchestrationHistory(IList`1<HistoryEvent> historyEvents, DateTime lastCheckpointTime);
    public OrchestrationHistory(IList`1<HistoryEvent> historyEvents, DateTime lastCheckpointTime, Nullable`1<ETag> eTag);
    public OrchestrationHistory(IList`1<HistoryEvent> historyEvents, DateTime lastCheckpointTime, Nullable`1<ETag> eTag, object trackingStoreContext);
    [CompilerGeneratedAttribute]
public IList`1<HistoryEvent> get_Events();
    [CompilerGeneratedAttribute]
public Nullable`1<ETag> get_ETag();
    [CompilerGeneratedAttribute]
public DateTime get_LastCheckpointTime();
    [CompilerGeneratedAttribute]
public object get_TrackingStoreContext();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DurableTask.AzureStorage.Tracking.OrchestrationInstanceStatusQueryCondition : object {
    [NullableAttribute("1")]
private static String[] ColumnNames;
    [CompilerGeneratedAttribute]
private IEnumerable`1<OrchestrationStatus> <RuntimeStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTimeFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTimeTo>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <TaskHubNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceIdPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FetchInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FetchOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeEntities>k__BackingField;
    public IEnumerable`1<OrchestrationStatus> RuntimeStatus { get; public set; }
    public DateTime CreatedTimeFrom { get; public set; }
    public DateTime CreatedTimeTo { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> TaskHubNames { get; public set; }
    public string InstanceIdPrefix { get; public set; }
    public string InstanceId { get; public set; }
    public bool FetchInput { get; public set; }
    public bool FetchOutput { get; public set; }
    public bool ExcludeEntities { get; public set; }
    private static OrchestrationInstanceStatusQueryCondition();
    [CompilerGeneratedAttribute]
public IEnumerable`1<OrchestrationStatus> get_RuntimeStatus();
    [CompilerGeneratedAttribute]
public void set_RuntimeStatus(IEnumerable`1<OrchestrationStatus> value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedTimeFrom();
    [CompilerGeneratedAttribute]
public void set_CreatedTimeFrom(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedTimeTo();
    [CompilerGeneratedAttribute]
public void set_CreatedTimeTo(DateTime value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_TaskHubNames();
    [CompilerGeneratedAttribute]
public void set_TaskHubNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_InstanceIdPrefix();
    [CompilerGeneratedAttribute]
public void set_InstanceIdPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_InstanceId();
    [CompilerGeneratedAttribute]
public void set_InstanceId(string value);
    [CompilerGeneratedAttribute]
public bool get_FetchInput();
    [CompilerGeneratedAttribute]
public void set_FetchInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_FetchOutput();
    [CompilerGeneratedAttribute]
public void set_FetchOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEntities();
    [CompilerGeneratedAttribute]
public void set_ExcludeEntities(bool value);
    internal ODataCondition ToOData();
    private string GetODataFilter();
    [NullableContextAttribute("1")]
public static OrchestrationInstanceStatusQueryCondition Parse(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus);
}
internal class DurableTask.AzureStorage.Tracking.TableEntityConverter : object {
    private static ConcurrentDictionary`2<Type, Func`2<TableEntity, object>> DeserializeCache;
    private static ConcurrentDictionary`2<Type, Func`2<object, TableEntity>> SerializerCache;
    private static TableEntityConverter();
    public static TableEntity Serialize(object obj);
    public static object Deserialize(TableEntity entity, Type type);
    private static Func`2<TableEntity, object> CreateTableEntityDeserializer(Type type);
    private static Func`2<object, TableEntity> CreateTableEntitySerializer(Type type);
    [IteratorStateMachineAttribute("DurableTask.AzureStorage.Tracking.TableEntityConverter/<EnumerateMembers>d__6")]
private static IEnumerable`1<ValueTuple`3<string, Type, MemberInfo>> EnumerateMembers(Type type);
    private static bool IsSupportedType(Type type);
    private static MethodInfo GetEntityAccessor(Type type);
}
internal static class DurableTask.AzureStorage.Tracking.TagsSerializer : object {
    public static string Serialize(IDictionary`2<string, string> tags);
    public static IDictionary`2<string, string> Deserialize(string tags);
}
internal abstract class DurableTask.AzureStorage.Tracking.TrackingStoreBase : object {
    public abstract virtual Task CreateAsync(CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> ExistsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<OrchestrationHistory> GetHistoryEventsAsync(string instanceId, string expectedExecutionId, CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<string> RewindHistoryAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task`1<InstanceStatus> FetchInstanceStatusAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(string instanceId, bool allExecutions, bool fetchInput, CancellationToken cancellationToken);
    public abstract virtual Task`1<OrchestrationState> GetStateAsync(string instanceId, string executionId, bool fetchInput, CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<OrchestrationState> GetStateAsync(IEnumerable`1<string> instanceIds, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<OrchestrationState> GetStateAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<OrchestrationState> GetStateAsync(OrchestrationInstanceStatusQueryCondition condition, CancellationToken cancellationToken);
    public abstract virtual Task PurgeHistoryAsync(DateTime thresholdDateTimeUtc, OrchestrationStateTimeRangeFilterType timeRangeFilterType, CancellationToken cancellationToken);
    public virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(string instanceId, CancellationToken cancellationToken);
    public virtual Task`1<PurgeHistoryResult> PurgeInstanceHistoryAsync(DateTime createdTimeFrom, Nullable`1<DateTime> createdTimeTo, IEnumerable`1<OrchestrationStatus> runtimeStatus, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> SetNewExecutionAsync(ExecutionStartedEvent executionStartedEvent, Nullable`1<ETag> eTag, string inputStatusOverride, CancellationToken cancellationToken);
    public virtual Task UpdateStatusForRewindAsync(string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task StartAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ETag>> UpdateStateAsync(OrchestrationRuntimeState newRuntimeState, OrchestrationRuntimeState oldRuntimeState, string instanceId, string executionId, Nullable`1<ETag> eTag, object executionData, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DurableTask.AzureStorage.TrackingServiceClientProvider : object {
    [CompilerGeneratedAttribute]
private IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> <Blob>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> <Table>k__BackingField;
    public IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> Blob { get; }
    public IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> Table { get; }
    public TrackingServiceClientProvider(string connectionString);
    public TrackingServiceClientProvider(string accountName, TokenCredential tokenCredential);
    public TrackingServiceClientProvider(Uri blobServiceUri, Uri tableServiceUri, TokenCredential tokenCredential);
    public TrackingServiceClientProvider(IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> blob, IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> table);
    [CompilerGeneratedAttribute]
public IStorageServiceClientProvider`2<BlobServiceClient, BlobClientOptions> get_Blob();
    [CompilerGeneratedAttribute]
public IStorageServiceClientProvider`2<TableServiceClient, TableClientOptions> get_Table();
}
internal class DurableTask.AzureStorage.TypeNameSerializationBinder : object {
    private ICustomTypeBinder customBinder;
    public TypeNameSerializationBinder(ICustomTypeBinder customBinder);
    public sealed virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public sealed virtual Type BindToType(string assemblyName, string typeName);
}
internal static class DurableTask.AzureStorage.TypeNameSerializationHelper : object {
    private static Assembly DurableTaskCore;
    private static Assembly DurableTaskAzureStorage;
    private static TypeNameSerializationHelper();
    public static void BindToName(ICustomTypeBinder customBinder, Type serializedType, String& assemblyName, String& typeName);
    public static Type BindToType(ICustomTypeBinder customBinder, string assemblyName, string typeName);
}
[ExtensionAttribute]
internal static class DurableTask.AzureStorage.Utils : object {
    public static Task CompletedTask;
    public static string ExtensionVersion;
    public static string AppName;
    private static JsonSerializer DefaultJsonSerializer;
    private static Utils();
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Utils/<ParallelForEachAsync>d__4`1")]
[ExtensionAttribute]
public static Task ParallelForEachAsync(IEnumerable`1<TSource> enumerable, Func`2<TSource, Task> action);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Utils/<ParallelForEachAsync>d__5`1")]
[ExtensionAttribute]
public static Task ParallelForEachAsync(IList`1<T> items, int maxConcurrency, Func`2<T, Task> action);
    [AsyncStateMachineAttribute("DurableTask.AzureStorage.Utils/<InvokeThrottledAction>d__6`1")]
private static Task InvokeThrottledAction(T item, Func`2<T, Task> action, SemaphoreSlim semaphore);
    [ExtensionAttribute]
public static double Next(Random random, double minValue, double maxValue);
    public static int GetEpisodeNumber(OrchestrationRuntimeState runtimeState);
    public static int GetEpisodeNumber(IEnumerable`1<HistoryEvent> historyEvents);
    public static int GetTaskEventId(HistoryEvent historyEvent);
    public static bool TryGetTaskScheduledId(HistoryEvent historyEvent, Int32& taskScheduledId);
    [ExtensionAttribute]
public static string GetTargetClassName(string s);
    public static string SerializeToJson(object payload);
    public static string SerializeToJson(JsonSerializer serializer, object payload);
    public static T DeserializeFromJson(JsonSerializer serializer, string jsonString);
    public static T DeserializeFromJson(Stream stream);
    public static T DeserializeFromJson(JsonSerializer serializer, Stream stream);
    public static T DeserializeFromJson(string jsonString);
    public static object DeserializeFromJson(string jsonString, Type type);
    public static object DeserializeFromJson(JsonSerializer serializer, string jsonString, Type type);
    public static void ConvertDateTimeInHistoryEventsToUTC(HistoryEvent historyEvent);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
