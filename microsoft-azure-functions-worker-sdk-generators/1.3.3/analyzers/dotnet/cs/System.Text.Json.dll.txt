internal static class FxResources.System.Text.Json.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Buffers.ArrayBufferWriter`1 : object {
    private static int ArrayMaxLength;
    private static int DefaultInitialBufferSize;
    private T[] _buffer;
    private int _index;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public void ResetWrittenCount();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
    private static void ThrowOutOfMemoryException(UInt32 capacity);
}
internal enum System.Buffers.Text.SequenceValidity : Enum {
    public int value__;
    public static SequenceValidity Empty;
    public static SequenceValidity WellFormed;
    public static SequenceValidity Incomplete;
    public static SequenceValidity Invalid;
}
internal class System.Collections.Generic.ReferenceEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ReferenceEqualityComparer <Instance>k__BackingField;
    public static ReferenceEqualityComparer Instance { get; }
    private static ReferenceEqualityComparer();
    [CompilerGeneratedAttribute]
public static ReferenceEqualityComparer get_Instance();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.StackExtensions : object {
    [ExtensionAttribute]
public static bool TryPeek(Stack`1<T> stack, T& result);
    [ExtensionAttribute]
public static bool TryPop(Stack`1<T> stack, T& result);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public DynamicDependencyAttribute(string memberSignature);
    public DynamicDependencyAttribute(string memberSignature, Type type);
    public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[AttributeUsageAttribute("6140")]
internal class System.ObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string Message { get; }
    public bool IsError { get; }
    public string DiagnosticId { get; public set; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public void set_DiagnosticId(string value);
    [CompilerGeneratedAttribute]
public string get_UrlFormat();
    [CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadResetAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
    internal static string RegexCompileToAssemblyMessage;
    internal static string RegexCompileToAssemblyDiagId;
    internal static string AssemblyNameMembersMessage;
    internal static string AssemblyNameMembersDiagId;
    internal static string SystemDataSerializationFormatBinaryMessage;
    internal static string SystemDataSerializationFormatBinaryDiagId;
    internal static string TlsVersion10and11Message;
    internal static string TlsVersion10and11DiagId;
    internal static string EncryptionPolicyMessage;
    internal static string EncryptionPolicyDiagId;
    internal static string Rfc2898OutdatedCtorMessage;
    internal static string Rfc2898OutdatedCtorDiagId;
    internal static string EccXmlExportImportMessage;
    internal static string EccXmlExportImportDiagId;
    internal static string EcDhPublicKeyBlobMessage;
    internal static string EcDhPublicKeyBlobDiagId;
    internal static string AssemblyNameCodeBaseMessage;
    internal static string AssemblyNameCodeBaseDiagId;
    internal static string CryptoStringFactoryMessage;
    internal static string CryptoStringFactoryDiagId;
    internal static string ControlledExecutionRunMessage;
    internal static string ControlledExecutionRunDiagId;
    internal static string XmlSecureResolverMessage;
    internal static string XmlSecureResolverDiagId;
    internal static string RsaEncryptDecryptValueMessage;
    internal static string RsaEncryptDecryptDiagId;
    internal static string JsonSerializerOptionsAddContextMessage;
    internal static string JsonSerializerOptionsAddContextDiagId;
    internal static string LegacyFormatterMessage;
    internal static string LegacyFormatterDiagId;
    internal static string LegacyFormatterImplMessage;
    internal static string LegacyFormatterImplDiagId;
    internal static string RegexExtensibilityImplMessage;
    internal static string RegexExtensibilityDiagId;
    internal static string AesGcmTagConstructorMessage;
    internal static string AesGcmTagConstructorDiagId;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
[AttributeUsageAttribute("6143")]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayDepthTooLarge { get; }
    internal static string CallFlushToAvoidDataLoss { get; }
    internal static string CannotReadIncompleteUTF16 { get; }
    internal static string CannotReadInvalidUTF16 { get; }
    internal static string CannotStartObjectArrayAfterPrimitiveOrClose { get; }
    internal static string CannotStartObjectArrayWithoutProperty { get; }
    internal static string CannotTranscodeInvalidUtf8 { get; }
    internal static string CannotDecodeInvalidBase64 { get; }
    internal static string CannotTranscodeInvalidUtf16 { get; }
    internal static string CannotEncodeInvalidUTF16 { get; }
    internal static string CannotEncodeInvalidUTF8 { get; }
    internal static string CannotWritePropertyWithinArray { get; }
    internal static string CannotWritePropertyAfterProperty { get; }
    internal static string CannotWriteValueAfterPrimitiveOrClose { get; }
    internal static string CannotWriteValueWithinObject { get; }
    internal static string DepthTooLarge { get; }
    internal static string DestinationTooShort { get; }
    internal static string EmptyJsonIsInvalid { get; }
    internal static string EndOfCommentNotFound { get; }
    internal static string EndOfStringNotFound { get; }
    internal static string ExpectedEndAfterSingleJson { get; }
    internal static string ExpectedEndOfDigitNotFound { get; }
    internal static string ExpectedFalse { get; }
    internal static string ExpectedJsonTokens { get; }
    internal static string ExpectedOneCompleteToken { get; }
    internal static string ExpectedNextDigitEValueNotFound { get; }
    internal static string ExpectedNull { get; }
    internal static string ExpectedSeparatorAfterPropertyNameNotFound { get; }
    internal static string ExpectedStartOfPropertyNotFound { get; }
    internal static string ExpectedStartOfPropertyOrValueNotFound { get; }
    internal static string ExpectedStartOfValueNotFound { get; }
    internal static string ExpectedTrue { get; }
    internal static string ExpectedValueAfterPropertyNameNotFound { get; }
    internal static string FailedToGetLargerSpan { get; }
    internal static string FoundInvalidCharacter { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidCharacterAfterEscapeWithinString { get; }
    internal static string InvalidCharacterWithinString { get; }
    internal static string InvalidEnumTypeWithSpecialChar { get; }
    internal static string InvalidEndOfJsonNonPrimitive { get; }
    internal static string InvalidHexCharacterWithinString { get; }
    internal static string JsonDocumentDoesNotSupportComments { get; }
    internal static string JsonElementHasWrongType { get; }
    internal static string DefaultTypeInfoResolverImmutable { get; }
    internal static string TypeInfoResolverChainImmutable { get; }
    internal static string TypeInfoImmutable { get; }
    internal static string MaxDepthMustBePositive { get; }
    internal static string CommentHandlingMustBeValid { get; }
    internal static string MismatchedObjectArray { get; }
    internal static string CannotWriteEndAfterProperty { get; }
    internal static string ObjectDepthTooLarge { get; }
    internal static string PropertyNameTooLarge { get; }
    internal static string FormatDecimal { get; }
    internal static string FormatDouble { get; }
    internal static string FormatInt32 { get; }
    internal static string FormatInt64 { get; }
    internal static string FormatSingle { get; }
    internal static string FormatUInt32 { get; }
    internal static string FormatUInt64 { get; }
    internal static string RequiredDigitNotFoundAfterDecimal { get; }
    internal static string RequiredDigitNotFoundAfterSign { get; }
    internal static string RequiredDigitNotFoundEndOfData { get; }
    internal static string SpecialNumberValuesNotSupported { get; }
    internal static string ValueTooLarge { get; }
    internal static string ZeroDepthAtEnd { get; }
    internal static string DeserializeUnableToConvertValue { get; }
    internal static string DeserializeWrongType { get; }
    internal static string SerializationInvalidBufferSize { get; }
    internal static string BufferWriterAdvancedTooFar { get; }
    internal static string InvalidComparison { get; }
    internal static string UnsupportedFormat { get; }
    internal static string ExpectedStartOfPropertyOrValueAfterComment { get; }
    internal static string TrailingCommaNotAllowedBeforeArrayEnd { get; }
    internal static string TrailingCommaNotAllowedBeforeObjectEnd { get; }
    internal static string SerializerOptionsReadOnly { get; }
    internal static string SerializerOptions_InvalidChainedResolver { get; }
    internal static string StreamNotWritable { get; }
    internal static string CannotWriteCommentWithEmbeddedDelimiter { get; }
    internal static string SerializerPropertyNameConflict { get; }
    internal static string SerializerPropertyNameNull { get; }
    internal static string SerializationDataExtensionPropertyInvalid { get; }
    internal static string SerializationDuplicateTypeAttribute { get; }
    internal static string ExtensionDataConflictsWithUnmappedMemberHandling { get; }
    internal static string SerializationNotSupportedType { get; }
    internal static string TypeRequiresAsyncSerialization { get; }
    internal static string InvalidCharacterAtStartOfComment { get; }
    internal static string UnexpectedEndOfDataWhileReadingComment { get; }
    internal static string CannotSkip { get; }
    internal static string NotEnoughData { get; }
    internal static string UnexpectedEndOfLineSeparator { get; }
    internal static string JsonSerializerDoesNotSupportComments { get; }
    internal static string DeserializeNoConstructor { get; }
    internal static string DeserializePolymorphicInterface { get; }
    internal static string SerializationConverterOnAttributeNotCompatible { get; }
    internal static string SerializationConverterOnAttributeInvalid { get; }
    internal static string SerializationConverterRead { get; }
    internal static string SerializationConverterNotCompatible { get; }
    internal static string ResolverTypeNotCompatible { get; }
    internal static string ResolverTypeInfoOptionsNotCompatible { get; }
    internal static string SerializationConverterWrite { get; }
    internal static string NamingPolicyReturnNull { get; }
    internal static string SerializationDuplicateAttribute { get; }
    internal static string SerializeUnableToSerialize { get; }
    internal static string FormatByte { get; }
    internal static string FormatInt16 { get; }
    internal static string FormatSByte { get; }
    internal static string FormatUInt16 { get; }
    internal static string SerializerCycleDetected { get; }
    internal static string InvalidLeadingZeroInNumber { get; }
    internal static string MetadataCannotParsePreservedObjectToImmutable { get; }
    internal static string MetadataDuplicateIdFound { get; }
    internal static string MetadataIdIsNotFirstProperty { get; }
    internal static string MetadataInvalidReferenceToValueType { get; }
    internal static string MetadataInvalidTokenAfterValues { get; }
    internal static string MetadataPreservedArrayFailed { get; }
    internal static string MetadataInvalidPropertyInArrayMetadata { get; }
    internal static string MetadataStandaloneValuesProperty { get; }
    internal static string MetadataReferenceCannotContainOtherProperties { get; }
    internal static string MetadataReferenceNotFound { get; }
    internal static string MetadataValueWasNotString { get; }
    internal static string MetadataInvalidPropertyWithLeadingDollarSign { get; }
    internal static string MetadataUnexpectedProperty { get; }
    internal static string UnmappedJsonProperty { get; }
    internal static string MetadataDuplicateTypeProperty { get; }
    internal static string MultipleMembersBindWithConstructorParameter { get; }
    internal static string ConstructorParamIncompleteBinding { get; }
    internal static string ObjectWithParameterizedCtorRefMetadataNotSupported { get; }
    internal static string SerializerConverterFactoryReturnsNull { get; }
    internal static string SerializationNotSupportedParentType { get; }
    internal static string ExtensionDataCannotBindToCtorParam { get; }
    internal static string BufferMaximumSizeExceeded { get; }
    internal static string CannotSerializeInvalidType { get; }
    internal static string SerializeTypeInstanceNotSupported { get; }
    internal static string JsonIncludeOnInaccessibleProperty { get; }
    internal static string CannotSerializeInvalidMember { get; }
    internal static string CannotPopulateCollection { get; }
    internal static string ConstructorContainsNullParameterNames { get; }
    internal static string DefaultIgnoreConditionAlreadySpecified { get; }
    internal static string DefaultIgnoreConditionInvalid { get; }
    internal static string DictionaryKeyTypeNotSupported { get; }
    internal static string IgnoreConditionOnValueTypeInvalid { get; }
    internal static string NumberHandlingOnPropertyInvalid { get; }
    internal static string ConverterCanConvertMultipleTypes { get; }
    internal static string MetadataReferenceOfTypeCannotBeAssignedToType { get; }
    internal static string DeserializeUnableToAssignValue { get; }
    internal static string DeserializeUnableToAssignNull { get; }
    internal static string SerializerConverterFactoryReturnsJsonConverterFactory { get; }
    internal static string SerializerConverterFactoryInvalidArgument { get; }
    internal static string NodeElementWrongType { get; }
    internal static string NodeElementCannotBeObjectOrArray { get; }
    internal static string NodeAlreadyHasParent { get; }
    internal static string NodeCycleDetected { get; }
    internal static string NodeUnableToConvert { get; }
    internal static string NodeUnableToConvertElement { get; }
    internal static string NodeValueNotAllowed { get; }
    internal static string NodeWrongType { get; }
    internal static string NodeParentWrongType { get; }
    internal static string NodeDuplicateKey { get; }
    internal static string SerializerContextOptionsReadOnly { get; }
    internal static string ConverterForPropertyMustBeValid { get; }
    internal static string NoMetadataForType { get; }
    internal static string AmbiguousMetadataForType { get; }
    internal static string CollectionIsReadOnly { get; }
    internal static string ArrayIndexNegative { get; }
    internal static string ArrayTooSmall { get; }
    internal static string NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty { get; }
    internal static string NoMetadataForTypeProperties { get; }
    internal static string FieldCannotBeVirtual { get; }
    internal static string MissingFSharpCoreMember { get; }
    internal static string FSharpDiscriminatedUnionsNotSupported { get; }
    internal static string Polymorphism_BaseConverterDoesNotSupportMetadata { get; }
    internal static string Polymorphism_DerivedConverterDoesNotSupportMetadata { get; }
    internal static string Polymorphism_TypeDoesNotSupportPolymorphism { get; }
    internal static string Polymorphism_DerivedTypeIsNotSupported { get; }
    internal static string Polymorphism_DerivedTypeIsAlreadySpecified { get; }
    internal static string Polymorphism_TypeDicriminatorIdIsAlreadySpecified { get; }
    internal static string Polymorphism_InvalidCustomTypeDiscriminatorPropertyName { get; }
    internal static string Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes { get; }
    internal static string Polymorphism_UnrecognizedTypeDiscriminator { get; }
    internal static string Polymorphism_RuntimeTypeNotSupported { get; }
    internal static string Polymorphism_RuntimeTypeDiamondAmbiguity { get; }
    internal static string InvalidJsonTypeInfoOperationForKind { get; }
    internal static string CreateObjectConverterNotCompatible { get; }
    internal static string JsonPropertyInfoBoundToDifferentParent { get; }
    internal static string JsonSerializerOptionsNoTypeInfoResolverSpecified { get; }
    internal static string JsonSerializerIsReflectionDisabled { get; }
    internal static string JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo { get; }
    internal static string JsonPropertyRequiredAndNotDeserializable { get; }
    internal static string JsonPropertyRequiredAndExtensionData { get; }
    internal static string JsonRequiredPropertiesMissing { get; }
    internal static string ObjectCreationHandlingPopulateNotSupportedByConverter { get; }
    internal static string ObjectCreationHandlingPropertyMustHaveAGetter { get; }
    internal static string ObjectCreationHandlingPropertyValueTypeMustHaveASetter { get; }
    internal static string ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization { get; }
    internal static string ObjectCreationHandlingPropertyCannotAllowReadOnlyMember { get; }
    internal static string ObjectCreationHandlingPropertyCannotAllowReferenceHandling { get; }
    internal static string ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors { get; }
    internal static string FormatInt128 { get; }
    internal static string FormatUInt128 { get; }
    internal static string FormatHalf { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayDepthTooLarge();
    internal static string get_CallFlushToAvoidDataLoss();
    internal static string get_CannotReadIncompleteUTF16();
    internal static string get_CannotReadInvalidUTF16();
    internal static string get_CannotStartObjectArrayAfterPrimitiveOrClose();
    internal static string get_CannotStartObjectArrayWithoutProperty();
    internal static string get_CannotTranscodeInvalidUtf8();
    internal static string get_CannotDecodeInvalidBase64();
    internal static string get_CannotTranscodeInvalidUtf16();
    internal static string get_CannotEncodeInvalidUTF16();
    internal static string get_CannotEncodeInvalidUTF8();
    internal static string get_CannotWritePropertyWithinArray();
    internal static string get_CannotWritePropertyAfterProperty();
    internal static string get_CannotWriteValueAfterPrimitiveOrClose();
    internal static string get_CannotWriteValueWithinObject();
    internal static string get_DepthTooLarge();
    internal static string get_DestinationTooShort();
    internal static string get_EmptyJsonIsInvalid();
    internal static string get_EndOfCommentNotFound();
    internal static string get_EndOfStringNotFound();
    internal static string get_ExpectedEndAfterSingleJson();
    internal static string get_ExpectedEndOfDigitNotFound();
    internal static string get_ExpectedFalse();
    internal static string get_ExpectedJsonTokens();
    internal static string get_ExpectedOneCompleteToken();
    internal static string get_ExpectedNextDigitEValueNotFound();
    internal static string get_ExpectedNull();
    internal static string get_ExpectedSeparatorAfterPropertyNameNotFound();
    internal static string get_ExpectedStartOfPropertyNotFound();
    internal static string get_ExpectedStartOfPropertyOrValueNotFound();
    internal static string get_ExpectedStartOfValueNotFound();
    internal static string get_ExpectedTrue();
    internal static string get_ExpectedValueAfterPropertyNameNotFound();
    internal static string get_FailedToGetLargerSpan();
    internal static string get_FoundInvalidCharacter();
    internal static string get_InvalidCast();
    internal static string get_InvalidCharacterAfterEscapeWithinString();
    internal static string get_InvalidCharacterWithinString();
    internal static string get_InvalidEnumTypeWithSpecialChar();
    internal static string get_InvalidEndOfJsonNonPrimitive();
    internal static string get_InvalidHexCharacterWithinString();
    internal static string get_JsonDocumentDoesNotSupportComments();
    internal static string get_JsonElementHasWrongType();
    internal static string get_DefaultTypeInfoResolverImmutable();
    internal static string get_TypeInfoResolverChainImmutable();
    internal static string get_TypeInfoImmutable();
    internal static string get_MaxDepthMustBePositive();
    internal static string get_CommentHandlingMustBeValid();
    internal static string get_MismatchedObjectArray();
    internal static string get_CannotWriteEndAfterProperty();
    internal static string get_ObjectDepthTooLarge();
    internal static string get_PropertyNameTooLarge();
    internal static string get_FormatDecimal();
    internal static string get_FormatDouble();
    internal static string get_FormatInt32();
    internal static string get_FormatInt64();
    internal static string get_FormatSingle();
    internal static string get_FormatUInt32();
    internal static string get_FormatUInt64();
    internal static string get_RequiredDigitNotFoundAfterDecimal();
    internal static string get_RequiredDigitNotFoundAfterSign();
    internal static string get_RequiredDigitNotFoundEndOfData();
    internal static string get_SpecialNumberValuesNotSupported();
    internal static string get_ValueTooLarge();
    internal static string get_ZeroDepthAtEnd();
    internal static string get_DeserializeUnableToConvertValue();
    internal static string get_DeserializeWrongType();
    internal static string get_SerializationInvalidBufferSize();
    internal static string get_BufferWriterAdvancedTooFar();
    internal static string get_InvalidComparison();
    internal static string get_UnsupportedFormat();
    internal static string get_ExpectedStartOfPropertyOrValueAfterComment();
    internal static string get_TrailingCommaNotAllowedBeforeArrayEnd();
    internal static string get_TrailingCommaNotAllowedBeforeObjectEnd();
    internal static string get_SerializerOptionsReadOnly();
    internal static string get_SerializerOptions_InvalidChainedResolver();
    internal static string get_StreamNotWritable();
    internal static string get_CannotWriteCommentWithEmbeddedDelimiter();
    internal static string get_SerializerPropertyNameConflict();
    internal static string get_SerializerPropertyNameNull();
    internal static string get_SerializationDataExtensionPropertyInvalid();
    internal static string get_SerializationDuplicateTypeAttribute();
    internal static string get_ExtensionDataConflictsWithUnmappedMemberHandling();
    internal static string get_SerializationNotSupportedType();
    internal static string get_TypeRequiresAsyncSerialization();
    internal static string get_InvalidCharacterAtStartOfComment();
    internal static string get_UnexpectedEndOfDataWhileReadingComment();
    internal static string get_CannotSkip();
    internal static string get_NotEnoughData();
    internal static string get_UnexpectedEndOfLineSeparator();
    internal static string get_JsonSerializerDoesNotSupportComments();
    internal static string get_DeserializeNoConstructor();
    internal static string get_DeserializePolymorphicInterface();
    internal static string get_SerializationConverterOnAttributeNotCompatible();
    internal static string get_SerializationConverterOnAttributeInvalid();
    internal static string get_SerializationConverterRead();
    internal static string get_SerializationConverterNotCompatible();
    internal static string get_ResolverTypeNotCompatible();
    internal static string get_ResolverTypeInfoOptionsNotCompatible();
    internal static string get_SerializationConverterWrite();
    internal static string get_NamingPolicyReturnNull();
    internal static string get_SerializationDuplicateAttribute();
    internal static string get_SerializeUnableToSerialize();
    internal static string get_FormatByte();
    internal static string get_FormatInt16();
    internal static string get_FormatSByte();
    internal static string get_FormatUInt16();
    internal static string get_SerializerCycleDetected();
    internal static string get_InvalidLeadingZeroInNumber();
    internal static string get_MetadataCannotParsePreservedObjectToImmutable();
    internal static string get_MetadataDuplicateIdFound();
    internal static string get_MetadataIdIsNotFirstProperty();
    internal static string get_MetadataInvalidReferenceToValueType();
    internal static string get_MetadataInvalidTokenAfterValues();
    internal static string get_MetadataPreservedArrayFailed();
    internal static string get_MetadataInvalidPropertyInArrayMetadata();
    internal static string get_MetadataStandaloneValuesProperty();
    internal static string get_MetadataReferenceCannotContainOtherProperties();
    internal static string get_MetadataReferenceNotFound();
    internal static string get_MetadataValueWasNotString();
    internal static string get_MetadataInvalidPropertyWithLeadingDollarSign();
    internal static string get_MetadataUnexpectedProperty();
    internal static string get_UnmappedJsonProperty();
    internal static string get_MetadataDuplicateTypeProperty();
    internal static string get_MultipleMembersBindWithConstructorParameter();
    internal static string get_ConstructorParamIncompleteBinding();
    internal static string get_ObjectWithParameterizedCtorRefMetadataNotSupported();
    internal static string get_SerializerConverterFactoryReturnsNull();
    internal static string get_SerializationNotSupportedParentType();
    internal static string get_ExtensionDataCannotBindToCtorParam();
    internal static string get_BufferMaximumSizeExceeded();
    internal static string get_CannotSerializeInvalidType();
    internal static string get_SerializeTypeInstanceNotSupported();
    internal static string get_JsonIncludeOnInaccessibleProperty();
    internal static string get_CannotSerializeInvalidMember();
    internal static string get_CannotPopulateCollection();
    internal static string get_ConstructorContainsNullParameterNames();
    internal static string get_DefaultIgnoreConditionAlreadySpecified();
    internal static string get_DefaultIgnoreConditionInvalid();
    internal static string get_DictionaryKeyTypeNotSupported();
    internal static string get_IgnoreConditionOnValueTypeInvalid();
    internal static string get_NumberHandlingOnPropertyInvalid();
    internal static string get_ConverterCanConvertMultipleTypes();
    internal static string get_MetadataReferenceOfTypeCannotBeAssignedToType();
    internal static string get_DeserializeUnableToAssignValue();
    internal static string get_DeserializeUnableToAssignNull();
    internal static string get_SerializerConverterFactoryReturnsJsonConverterFactory();
    internal static string get_SerializerConverterFactoryInvalidArgument();
    internal static string get_NodeElementWrongType();
    internal static string get_NodeElementCannotBeObjectOrArray();
    internal static string get_NodeAlreadyHasParent();
    internal static string get_NodeCycleDetected();
    internal static string get_NodeUnableToConvert();
    internal static string get_NodeUnableToConvertElement();
    internal static string get_NodeValueNotAllowed();
    internal static string get_NodeWrongType();
    internal static string get_NodeParentWrongType();
    internal static string get_NodeDuplicateKey();
    internal static string get_SerializerContextOptionsReadOnly();
    internal static string get_ConverterForPropertyMustBeValid();
    internal static string get_NoMetadataForType();
    internal static string get_AmbiguousMetadataForType();
    internal static string get_CollectionIsReadOnly();
    internal static string get_ArrayIndexNegative();
    internal static string get_ArrayTooSmall();
    internal static string get_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
    internal static string get_NoMetadataForTypeProperties();
    internal static string get_FieldCannotBeVirtual();
    internal static string get_MissingFSharpCoreMember();
    internal static string get_FSharpDiscriminatedUnionsNotSupported();
    internal static string get_Polymorphism_BaseConverterDoesNotSupportMetadata();
    internal static string get_Polymorphism_DerivedConverterDoesNotSupportMetadata();
    internal static string get_Polymorphism_TypeDoesNotSupportPolymorphism();
    internal static string get_Polymorphism_DerivedTypeIsNotSupported();
    internal static string get_Polymorphism_DerivedTypeIsAlreadySpecified();
    internal static string get_Polymorphism_TypeDicriminatorIdIsAlreadySpecified();
    internal static string get_Polymorphism_InvalidCustomTypeDiscriminatorPropertyName();
    internal static string get_Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes();
    internal static string get_Polymorphism_UnrecognizedTypeDiscriminator();
    internal static string get_Polymorphism_RuntimeTypeNotSupported();
    internal static string get_Polymorphism_RuntimeTypeDiamondAmbiguity();
    internal static string get_InvalidJsonTypeInfoOperationForKind();
    internal static string get_CreateObjectConverterNotCompatible();
    internal static string get_JsonPropertyInfoBoundToDifferentParent();
    internal static string get_JsonSerializerOptionsNoTypeInfoResolverSpecified();
    internal static string get_JsonSerializerIsReflectionDisabled();
    internal static string get_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo();
    internal static string get_JsonPropertyRequiredAndNotDeserializable();
    internal static string get_JsonPropertyRequiredAndExtensionData();
    internal static string get_JsonRequiredPropertiesMissing();
    internal static string get_ObjectCreationHandlingPopulateNotSupportedByConverter();
    internal static string get_ObjectCreationHandlingPropertyMustHaveAGetter();
    internal static string get_ObjectCreationHandlingPropertyValueTypeMustHaveASetter();
    internal static string get_ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization();
    internal static string get_ObjectCreationHandlingPropertyCannotAllowReadOnlyMember();
    internal static string get_ObjectCreationHandlingPropertyCannotAllowReferenceHandling();
    internal static string get_ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors();
    internal static string get_FormatInt128();
    internal static string get_FormatUInt128();
    internal static string get_FormatHalf();
}
internal static class System.Text.Json.AppContextSwitchHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsSourceGenReflectionFallbackEnabled>k__BackingField;
    public static bool IsSourceGenReflectionFallbackEnabled { get; }
    private static AppContextSwitchHelper();
    [CompilerGeneratedAttribute]
public static bool get_IsSourceGenReflectionFallbackEnabled();
}
internal class System.Text.Json.Arguments`4 : object {
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
}
internal class System.Text.Json.ArgumentState : object {
    public object Arguments;
    public ValueTuple`5[] FoundProperties;
    public ValueTuple`3[] FoundPropertiesAsync;
    public int FoundPropertyCount;
    public JsonParameterInfo JsonParameterInfo;
    public int ParameterIndex;
    public List`1<ParameterRef> ParameterRefCache;
}
internal class System.Text.Json.BitStack : ValueType {
    private static int AllocationFreeMaxDepth;
    private static int DefaultInitialArraySize;
    private Int32[] _array;
    private ulong _allocationFreeContainer;
    private int _currentDepth;
    public int CurrentDepth { get; }
    public int get_CurrentDepth();
    public void PushTrue();
    public void PushFalse();
    private void PushToArray(bool value);
    public bool Pop();
    private bool PopFromArray();
    private void DoubleArray(int minSize);
    public void SetFirstBit();
    public void ResetFirstBit();
    private static int Div32Rem(int number, Int32& remainder);
}
internal enum System.Text.Json.ConsumeNumberResult : Enum {
    public byte value__;
    public static ConsumeNumberResult Success;
    public static ConsumeNumberResult OperationIncomplete;
    public static ConsumeNumberResult NeedMoreData;
}
internal enum System.Text.Json.ConsumeTokenResult : Enum {
    public byte value__;
    public static ConsumeTokenResult Success;
    public static ConsumeTokenResult NotEnoughDataRollBackState;
    public static ConsumeTokenResult IncompleteNoRollBackNecessary;
}
internal enum System.Text.Json.ConverterStrategy : Enum {
    public byte value__;
    public static ConverterStrategy None;
    public static ConverterStrategy Object;
    public static ConverterStrategy Value;
    public static ConverterStrategy Enumerable;
    public static ConverterStrategy Dictionary;
}
internal enum System.Text.Json.DataType : Enum {
    public int value__;
    public static DataType Boolean;
    public static DataType DateOnly;
    public static DataType DateTime;
    public static DataType DateTimeOffset;
    public static DataType TimeOnly;
    public static DataType TimeSpan;
    public static DataType Base64String;
    public static DataType Guid;
    public static DataType Version;
}
internal enum System.Text.Json.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArrayDepthTooLarge;
    public static ExceptionResource EndOfCommentNotFound;
    public static ExceptionResource EndOfStringNotFound;
    public static ExceptionResource RequiredDigitNotFoundAfterDecimal;
    public static ExceptionResource RequiredDigitNotFoundAfterSign;
    public static ExceptionResource RequiredDigitNotFoundEndOfData;
    public static ExceptionResource ExpectedEndAfterSingleJson;
    public static ExceptionResource ExpectedEndOfDigitNotFound;
    public static ExceptionResource ExpectedFalse;
    public static ExceptionResource ExpectedNextDigitEValueNotFound;
    public static ExceptionResource ExpectedNull;
    public static ExceptionResource ExpectedSeparatorAfterPropertyNameNotFound;
    public static ExceptionResource ExpectedStartOfPropertyNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueAfterComment;
    public static ExceptionResource ExpectedStartOfValueNotFound;
    public static ExceptionResource ExpectedTrue;
    public static ExceptionResource ExpectedValueAfterPropertyNameNotFound;
    public static ExceptionResource FoundInvalidCharacter;
    public static ExceptionResource InvalidCharacterWithinString;
    public static ExceptionResource InvalidCharacterAfterEscapeWithinString;
    public static ExceptionResource InvalidHexCharacterWithinString;
    public static ExceptionResource InvalidEndOfJsonNonPrimitive;
    public static ExceptionResource MismatchedObjectArray;
    public static ExceptionResource ObjectDepthTooLarge;
    public static ExceptionResource ZeroDepthAtEnd;
    public static ExceptionResource DepthTooLarge;
    public static ExceptionResource CannotStartObjectArrayWithoutProperty;
    public static ExceptionResource CannotStartObjectArrayAfterPrimitiveOrClose;
    public static ExceptionResource CannotWriteValueWithinObject;
    public static ExceptionResource CannotWriteValueAfterPrimitiveOrClose;
    public static ExceptionResource CannotWritePropertyWithinArray;
    public static ExceptionResource ExpectedJsonTokens;
    public static ExceptionResource TrailingCommaNotAllowedBeforeArrayEnd;
    public static ExceptionResource TrailingCommaNotAllowedBeforeObjectEnd;
    public static ExceptionResource InvalidCharacterAtStartOfComment;
    public static ExceptionResource UnexpectedEndOfDataWhileReadingComment;
    public static ExceptionResource UnexpectedEndOfLineSeparator;
    public static ExceptionResource ExpectedOneCompleteToken;
    public static ExceptionResource NotEnoughData;
    public static ExceptionResource InvalidLeadingZeroInNumber;
}
internal class System.Text.Json.JsonCamelCaseNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
    private static void FixCasing(Span`1<char> chars);
}
public enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
internal static class System.Text.Json.JsonConstants : object {
    public static string DoubleFormatString;
    public static string SingleFormatString;
    public static int StackallocByteThreshold;
    public static int StackallocCharThreshold;
    public static byte OpenBrace;
    public static byte CloseBrace;
    public static byte OpenBracket;
    public static byte CloseBracket;
    public static byte Space;
    public static byte CarriageReturn;
    public static byte LineFeed;
    public static byte Tab;
    public static byte ListSeparator;
    public static byte KeyValueSeparator;
    public static byte Quote;
    public static byte BackSlash;
    public static byte Slash;
    public static byte BackSpace;
    public static byte FormFeed;
    public static byte Asterisk;
    public static byte Colon;
    public static byte Period;
    public static byte Plus;
    public static byte Hyphen;
    public static byte UtcOffsetToken;
    public static byte TimePrefix;
    public static byte StartingByteOfNonStandardSeparator;
    public static int SpacesPerIndent;
    public static int RemoveFlagsBitMask;
    public static int MaxExpansionFactorWhileEscaping;
    public static int MaxExpansionFactorWhileTranscoding;
    public static long ArrayPoolMaxSizeBeforeUsingNormalAlloc;
    public static int MaxUtf16RawValueLength;
    public static int MaxEscapedTokenSize;
    public static int MaxUnescapedTokenSize;
    public static int MaxCharacterTokenSize;
    public static int MaximumFormatBooleanLength;
    public static int MaximumFormatInt64Length;
    public static int MaximumFormatUInt64Length;
    public static int MaximumFormatDoubleLength;
    public static int MaximumFormatSingleLength;
    public static int MaximumFormatDecimalLength;
    public static int MaximumFormatGuidLength;
    public static int MaximumEscapedGuidLength;
    public static int MaximumFormatDateTimeLength;
    public static int MaximumFormatDateTimeOffsetLength;
    public static int MaxDateTimeUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static int DateTimeParseNumFractionDigits;
    public static int MaximumDateTimeOffsetParseLength;
    public static int MinimumDateTimeParseLength;
    public static int MaximumEscapedDateTimeOffsetParseLength;
    public static int MaximumLiteralLength;
    public static char HighSurrogateStart;
    public static char HighSurrogateEnd;
    public static char LowSurrogateStart;
    public static char LowSurrogateEnd;
    public static int UnicodePlane01StartValue;
    public static int HighSurrogateStartValue;
    public static int HighSurrogateEndValue;
    public static int LowSurrogateStartValue;
    public static int LowSurrogateEndValue;
    public static int BitShiftBy10;
    public static int UnboxedParameterCountThreshold;
    public static ReadOnlySpan`1<byte> Utf8Bom { get; }
    public static ReadOnlySpan`1<byte> TrueValue { get; }
    public static ReadOnlySpan`1<byte> FalseValue { get; }
    public static ReadOnlySpan`1<byte> NullValue { get; }
    public static ReadOnlySpan`1<byte> NaNValue { get; }
    public static ReadOnlySpan`1<byte> PositiveInfinityValue { get; }
    public static ReadOnlySpan`1<byte> NegativeInfinityValue { get; }
    public static ReadOnlySpan`1<byte> Delimiters { get; }
    public static ReadOnlySpan`1<byte> EscapableChars { get; }
    public static ReadOnlySpan`1<byte> get_Utf8Bom();
    public static ReadOnlySpan`1<byte> get_TrueValue();
    public static ReadOnlySpan`1<byte> get_FalseValue();
    public static ReadOnlySpan`1<byte> get_NullValue();
    public static ReadOnlySpan`1<byte> get_NaNValue();
    public static ReadOnlySpan`1<byte> get_PositiveInfinityValue();
    public static ReadOnlySpan`1<byte> get_NegativeInfinityValue();
    public static ReadOnlySpan`1<byte> get_Delimiters();
    public static ReadOnlySpan`1<byte> get_EscapableChars();
}
public class System.Text.Json.JsonDocument : object {
    private ReadOnlyMemory`1<byte> _utf8Json;
    private MetadataDb _parsedData;
    private Byte[] _extraRentedArrayPoolBytes;
    private PooledByteBufferWriter _extraPooledByteBufferWriter;
    [CompilerGeneratedAttribute]
private bool <IsDisposable>k__BackingField;
    private static JsonDocument s_nullLiteral;
    private static JsonDocument s_trueLiteral;
    private static JsonDocument s_falseLiteral;
    private static int UnseekableStreamInitialRentSize;
    internal bool IsDisposable { get; }
    public JsonElement RootElement { get; }
    private JsonDocument(ReadOnlyMemory`1<byte> utf8Json, MetadataDb parsedData, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter, bool isDisposable);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposable();
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    internal JsonTokenType GetJsonTokenType(int index);
    internal int GetArrayLength(int index);
    internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex);
    internal int GetEndIndex(int index, bool includeEndElement);
    internal ReadOnlyMemory`1<byte> GetRootRawValue();
    internal ReadOnlyMemory`1<byte> GetRawValue(int index, bool includeQuotes);
    private ReadOnlyMemory`1<byte> GetPropertyRawValue(int valueIndex);
    internal string GetString(int index, JsonTokenType expectedType);
    internal bool TextEquals(int index, ReadOnlySpan`1<char> otherText, bool isPropertyName);
    internal bool TextEquals(int index, ReadOnlySpan`1<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape);
    internal string GetNameOfPropertyValue(int index);
    internal bool TryGetValue(int index, Byte[]& value);
    internal bool TryGetValue(int index, SByte& value);
    internal bool TryGetValue(int index, Byte& value);
    internal bool TryGetValue(int index, Int16& value);
    internal bool TryGetValue(int index, UInt16& value);
    internal bool TryGetValue(int index, Int32& value);
    internal bool TryGetValue(int index, UInt32& value);
    internal bool TryGetValue(int index, Int64& value);
    internal bool TryGetValue(int index, UInt64& value);
    internal bool TryGetValue(int index, Double& value);
    internal bool TryGetValue(int index, Single& value);
    internal bool TryGetValue(int index, Decimal& value);
    internal bool TryGetValue(int index, DateTime& value);
    internal bool TryGetValue(int index, DateTimeOffset& value);
    internal bool TryGetValue(int index, Guid& value);
    internal string GetRawValueAsString(int index);
    internal string GetPropertyRawValueAsString(int valueIndex);
    internal JsonElement CloneElement(int index);
    internal void WriteElementTo(int index, Utf8JsonWriter writer);
    private void WriteComplexElement(int index, Utf8JsonWriter writer);
    private ReadOnlySpan`1<byte> UnescapeString(DbRow& row, ArraySegment`1& rented);
    private static void ClearAndReturn(ArraySegment`1<byte> rented);
    private void WritePropertyName(DbRow& row, Utf8JsonWriter writer);
    private void WriteString(DbRow& row, Utf8JsonWriter writer);
    private static void Parse(ReadOnlySpan`1<byte> utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack);
    private void CheckNotDisposed();
    private static void CheckExpectedType(JsonTokenType expected, JsonTokenType actual);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseRented(PooledByteBufferWriter utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(string json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCore>d__65")]
private static Task`1<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCoreUnrented>d__66")]
internal static Task`1<JsonDocument> ParseAsyncCoreUnrented(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(string json, JsonDocumentOptions options);
    [NullableContextAttribute("2")]
public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    [NullableContextAttribute("1")]
public static JsonDocument ParseValue(Utf8JsonReader& reader);
    internal static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document, bool shouldThrow, bool useArrayPools);
    private static JsonDocument CreateForLiteral(JsonTokenType tokenType);
    private static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter);
    private static JsonDocument ParseUnrented(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, JsonTokenType tokenType);
    private static ArraySegment`1<byte> ReadToEnd(Stream stream);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ReadToEndAsync>d__77")]
private static Task`1<ArraySegment`1<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<char> propertyName, JsonElement& value);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    [CompilerGeneratedAttribute]
internal static JsonDocument <CreateForLiteral>g__Create|73_0(Byte[] utf8Json, <>c__DisplayClass73_0& );
}
public class System.Text.Json.JsonDocumentOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    internal JsonReaderOptions GetReaderOptions();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonElement : ValueType {
    private JsonDocument _parent;
    private int _idx;
    [DebuggerBrowsableAttribute("0")]
private JsonTokenType TokenType { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement Item { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonElement(JsonDocument parent, int idx);
    private JsonTokenType get_TokenType();
    public JsonValueKind get_ValueKind();
    public JsonElement get_Item(int index);
    public int GetArrayLength();
    [NullableContextAttribute("1")]
public JsonElement GetProperty(string propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public bool TryGetProperty(string propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool GetBoolean();
    [NullableContextAttribute("2")]
public string GetString();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public bool TryGetByte(Byte& value);
    public byte GetByte();
    public bool TryGetInt16(Int16& value);
    public short GetInt16();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    public bool TryGetInt32(Int32& value);
    public int GetInt32();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    public bool TryGetInt64(Int64& value);
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool TryGetDouble(Double& value);
    public double GetDouble();
    public bool TryGetSingle(Single& value);
    public float GetSingle();
    public bool TryGetDecimal(Decimal& value);
    public decimal GetDecimal();
    public bool TryGetDateTime(DateTime& value);
    public DateTime GetDateTime();
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public DateTimeOffset GetDateTimeOffset();
    public bool TryGetGuid(Guid& value);
    public Guid GetGuid();
    internal string GetPropertyName();
    [NullableContextAttribute("1")]
public string GetRawText();
    internal ReadOnlyMemory`1<byte> GetRawValue();
    internal string GetPropertyRawText();
    [NullableContextAttribute("2")]
public bool ValueEquals(string text);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    internal bool TextEqualsHelper(ReadOnlySpan`1<byte> utf8Text, bool isPropertyName, bool shouldUnescape);
    internal bool TextEqualsHelper(ReadOnlySpan`1<char> text, bool isPropertyName);
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public JsonElement Clone();
    private void CheckValidInstance();
    private string get_DebuggerDisplay();
    public static JsonElement ParseValue(Utf8JsonReader& reader);
    internal static JsonElement ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(string json, JsonDocumentOptions options);
    public static bool TryParseValue(Utf8JsonReader& reader, Nullable`1& element);
    [CompilerGeneratedAttribute]
internal static bool <GetBoolean>g__ThrowJsonElementWrongTypeException|17_0(JsonTokenType actualType);
}
[IsReadOnlyAttribute]
public class System.Text.Json.JsonEncodedText : ValueType {
    internal Byte[] _utf8Value;
    internal string _value;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    [NullableAttribute("1")]
public string Value { get; }
    private JsonEncodedText(Byte[] utf8Value);
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    [NullableContextAttribute("1")]
public string get_Value();
    [NullableContextAttribute("1")]
public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static JsonEncodedText EncodeHelper(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public sealed virtual bool Equals(JsonEncodedText other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonException : Exception {
    internal string _message;
    [CompilerGeneratedAttribute]
private bool <AppendPathInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytePositionInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    internal bool AppendPathInformation { get; internal set; }
    public Nullable`1<long> LineNumber { get; internal set; }
    public Nullable`1<long> BytePositionInLine { get; internal set; }
    public string Path { get; internal set; }
    [NullableAttribute("1")]
public string Message { get; }
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, Exception innerException);
    public JsonException(string message);
    [NullableContextAttribute("1")]
protected JsonException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal bool get_AppendPathInformation();
    [CompilerGeneratedAttribute]
internal void set_AppendPathInformation(bool value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytePositionInLine();
    [CompilerGeneratedAttribute]
internal void set_BytePositionInLine(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    internal void SetMessage(string message);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonHelpers : object {
    private static ReadOnlySpan`1<int> DaysToMonth365 { get; }
    private static ReadOnlySpan`1<int> DaysToMonth366 { get; }
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool TryDequeue(Queue`1<T> queue, T& result);
    internal static bool RequiresSpecialNumberHandlingOnWrite(Nullable`1<JsonNumberHandling> handling);
    [ExtensionAttribute]
internal static void StableSortByKey(List`1<T> items, Func`2<T, TKey> keySelector);
    public static T[] TraverseGraphWithTopologicalSort(T entryNode, Func`2<T, ICollection`1<T>> getChildren, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> GetSpan(Utf8JsonReader& reader);
    public static bool IsValidUnicodeScalar(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound);
    public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound);
    public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound);
    public static bool IsDigit(byte value);
    [ExtensionAttribute]
public static void ReadWithVerify(Utf8JsonReader& reader);
    public static string Utf8GetString(ReadOnlySpan`1<byte> bytes);
    public static Dictionary`2<TKey, TValue> CreateDictionaryFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public static bool IsFinite(double value);
    public static bool IsFinite(float value);
    public static void ValidateInt32MaxArrayLength(UInt32 length);
    [ExtensionAttribute]
public static bool HasAllSet(BitArray bitArray);
    public static bool IsValidDateTimeOffsetParseLength(int length);
    public static bool IsValidUnescapedDateTimeOffsetParseLength(int length);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    private static bool TryParseDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeParseData& parseData);
    private static bool TryGetNextTwoDigits(ReadOnlySpan`1<byte> source, Int32& value);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, DateTimeOffset& value);
    private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, DateTime& value);
    private static ReadOnlySpan`1<int> get_DaysToMonth365();
    private static ReadOnlySpan`1<int> get_DaysToMonth366();
    public static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public static Byte[] EscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetPropertyNameSection(ReadOnlySpan`1<byte> utf8Value);
    [CompilerGeneratedAttribute]
internal static bool <TryParseDateTimeOffset>g__ParseOffset|24_0(DateTimeParseData& parseData, ReadOnlySpan`1<byte> offsetData);
}
internal class System.Text.Json.JsonKebabCaseLowerNamingPolicy : JsonSeparatorNamingPolicy {
}
internal class System.Text.Json.JsonKebabCaseUpperNamingPolicy : JsonSeparatorNamingPolicy {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.JsonNamingPolicy : object {
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <CamelCase>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <SnakeCaseLower>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <SnakeCaseUpper>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <KebabCaseLower>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <KebabCaseUpper>k__BackingField;
    public static JsonNamingPolicy CamelCase { get; }
    public static JsonNamingPolicy SnakeCaseLower { get; }
    public static JsonNamingPolicy SnakeCaseUpper { get; }
    public static JsonNamingPolicy KebabCaseLower { get; }
    public static JsonNamingPolicy KebabCaseUpper { get; }
    private static JsonNamingPolicy();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_CamelCase();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_SnakeCaseLower();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_SnakeCaseUpper();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_KebabCaseLower();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_KebabCaseUpper();
    public abstract virtual string ConvertName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonProperty : ValueType {
    [CompilerGeneratedAttribute]
private JsonElement <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <_name>k__BackingField;
    public JsonElement Value { get; }
    [NullableAttribute("2")]
private string _name { get; }
    public string Name { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonProperty(JsonElement value, string name);
    [CompilerGeneratedAttribute]
public JsonElement get_Value();
    [CompilerGeneratedAttribute]
private string get__name();
    public string get_Name();
    [NullableContextAttribute("2")]
public bool NameEquals(string text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<char> text);
    internal bool EscapedNameEquals(ReadOnlySpan`1<byte> utf8Text);
    public void WriteTo(Utf8JsonWriter writer);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.JsonPropertyDictionary`1 : object {
    private static int ListToDictionaryThreshold;
    private Dictionary`2<string, T> _propertyDictionary;
    private List`1<KeyValuePair`2<string, T>> _propertyList;
    private StringComparer _stringComparer;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private KeyCollection<T> _keyCollection;
    private ValueCollection<T> _valueCollection;
    public List`1<KeyValuePair`2<string, T>> List { get; }
    public int Count { get; }
    public IList`1<string> Keys { get; }
    public IList`1<T> Values { get; }
    public bool IsReadOnly { get; public set; }
    public T Item { get; public set; }
    public JsonPropertyDictionary`1(bool caseInsensitive);
    public JsonPropertyDictionary`1(bool caseInsensitive, int capacity);
    public List`1<KeyValuePair`2<string, T>> get_List();
    public void Add(string propertyName, T value);
    public void Add(KeyValuePair`2<string, T> property);
    public bool TryAdd(string propertyName, T value);
    public void Clear();
    public bool ContainsKey(string propertyName);
    public int get_Count();
    public bool Remove(string propertyName);
    public bool Contains(KeyValuePair`2<string, T> item);
    public void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<KeyValuePair`2<string, T>> GetEnumerator();
    public IList`1<string> get_Keys();
    public IList`1<T> get_Values();
    public bool TryGetValue(string propertyName, T& value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    public T get_Item(string propertyName);
    public void set_Item(string propertyName, T value);
    public T SetValue(string propertyName, T value, Boolean& valueAlreadyInDictionary);
    private void AddValue(string propertyName, T value);
    internal bool TryAddValue(string propertyName, T value);
    private void CreateDictionaryIfThresholdMet();
    internal bool ContainsValue(T value);
    public Nullable`1<KeyValuePair`2<string, T>> FindValue(T value);
    private bool ContainsProperty(string propertyName);
    private int FindValueIndex(string propertyName);
    public bool TryGetPropertyValue(string propertyName, T& value);
    public bool TryRemoveProperty(string propertyName, T& existing);
    public IList`1<string> GetKeyCollection();
    public IList`1<T> GetValueCollection();
}
internal class System.Text.Json.JsonReaderException : JsonException {
    public JsonReaderException(string message, long lineNumber, long bytePositionInLine);
    private JsonReaderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonReaderHelper : object {
    private static string SpecialCharacters;
    public static UTF8Encoding s_utf8Encoding;
    private static ulong XorPowerOfTwoToHighByte;
    private static JsonReaderHelper();
    [ExtensionAttribute]
public static bool ContainsSpecialCharacters(ReadOnlySpan`1<char> text);
    public static ValueTuple`2<int, int> CountNewLines(ReadOnlySpan`1<byte> data);
    [ExtensionAttribute]
internal static JsonValueKind ToValueKind(JsonTokenType tokenType);
    public static bool IsTokenTypePrimitive(JsonTokenType tokenType);
    public static bool IsHexDigit(byte nextByte);
    public static bool TryGetEscapedDateTime(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    public static bool TryGetEscapedGuid(ReadOnlySpan`1<byte> source, Guid& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Single& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Double& value);
    public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan`1<byte> utf8Source, Byte[]& bytes);
    public static string GetUnescapedString(ReadOnlySpan`1<byte> utf8Source);
    public static ReadOnlySpan`1<byte> GetUnescapedSpan(ReadOnlySpan`1<byte> utf8Source);
    public static bool UnescapeAndCompare(ReadOnlySpan`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool UnescapeAndCompare(ReadOnlySequence`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool TryDecodeBase64InPlace(Span`1<byte> utf8Unescaped, Byte[]& bytes);
    public static bool TryDecodeBase64(ReadOnlySpan`1<byte> utf8Unescaped, Byte[]& bytes);
    public static string TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped);
    public static int TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped, Span`1<char> destination);
    public static void ValidateUtf8(ReadOnlySpan`1<byte> utf8Buffer);
    internal static int GetUtf8ByteCount(ReadOnlySpan`1<char> text);
    internal static int GetUtf8FromText(ReadOnlySpan`1<char> text, Span`1<byte> dest);
    internal static string GetTextFromUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& written);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    internal static bool TryUnescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& written);
    private static bool TryUnescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    private static bool TryEncodeToUtf8Bytes(UInt32 scalar, Span`1<byte> utf8Destination, Int32& bytesWritten);
    [ExtensionAttribute]
public static int IndexOfQuoteOrAnyControlOrBackSlash(ReadOnlySpan`1<byte> span);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
}
public class System.Text.Json.JsonReaderOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
}
public class System.Text.Json.JsonReaderState : ValueType {
    internal long _lineNumber;
    internal long _bytePositionInLine;
    internal bool _inObject;
    internal bool _isNotPrimitive;
    internal bool _valueIsEscaped;
    internal bool _trailingCommaBeforeComment;
    internal JsonTokenType _tokenType;
    internal JsonTokenType _previousTokenType;
    internal JsonReaderOptions _readerOptions;
    internal BitStack _bitStack;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
internal abstract class System.Text.Json.JsonSeparatorNamingPolicy : JsonNamingPolicy {
    private bool _lowercase;
    private char _separator;
    internal JsonSeparatorNamingPolicy(bool lowercase, char separator);
    public sealed virtual string ConvertName(string name);
    private static string ConvertNameCore(char separator, bool lowercase, ReadOnlySpan`1<char> chars);
    [CompilerGeneratedAttribute]
internal static void <ConvertNameCore>g__WriteChar|4_0(char value, Span`1& destination, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertNameCore>g__ExpandBuffer|4_1(Span`1& destination, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Text.Json.JsonSerializer : object {
    internal static string SerializationUnreferencedCodeMessage;
    internal static string SerializationRequiresDynamicCodeMessage;
    [CompilerGeneratedAttribute]
private static bool <IsReflectionEnabledByDefault>k__BackingField;
    internal static string IdPropertyName;
    internal static string RefPropertyName;
    internal static string TypePropertyName;
    internal static string ValuesPropertyName;
    private static Byte[] s_idPropertyName;
    private static Byte[] s_refPropertyName;
    private static Byte[] s_typePropertyName;
    private static Byte[] s_valuesPropertyName;
    internal static JsonEncodedText s_metadataId;
    internal static JsonEncodedText s_metadataRef;
    internal static JsonEncodedText s_metadataType;
    internal static JsonEncodedText s_metadataValues;
    internal static float FlushThreshold;
    public static bool IsReflectionEnabledByDefault { get; }
    private static JsonSerializer();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonDocument document, JsonSerializerOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static TValue Deserialize(JsonDocument document, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonDocument document, JsonTypeInfo jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonElement element, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonElement element, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonElement element, JsonTypeInfo jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonNode node, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonNode node, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object Deserialize(JsonNode node, JsonTypeInfo jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerContext context);
    private static TValue ReadFromNode(JsonNode node, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static object ReadFromNodeAsObject(JsonNode node, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonDocument SerializeToDocument(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerOptions options);
    public static JsonDocument SerializeToDocument(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonDocument SerializeToDocument(object value, JsonTypeInfo jsonTypeInfo);
    public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerContext context);
    private static JsonDocument WriteDocument(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonDocument WriteDocumentAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonElement SerializeToElement(TValue value, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerOptions options);
    public static JsonElement SerializeToElement(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonElement SerializeToElement(object value, JsonTypeInfo jsonTypeInfo);
    public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerContext context);
    private static JsonElement WriteElement(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonElement WriteElementAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonNode SerializeToNode(TValue value, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerOptions options);
    public static JsonNode SerializeToNode(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
public static JsonNode SerializeToNode(object value, JsonTypeInfo jsonTypeInfo);
    public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerContext context);
    private static JsonNode WriteNode(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonNode WriteNodeAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [CompilerGeneratedAttribute]
public static bool get_IsReflectionEnabledByDefault();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo GetTypeInfo(JsonSerializerOptions options, Type inputType);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo`1<T> GetTypeInfo(JsonSerializerOptions options);
    private static JsonTypeInfo GetTypeInfo(JsonSerializerContext context, Type inputType);
    private static void ValidateInputType(object value, Type inputType);
    internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling);
    internal static bool IsValidCreationHandlingValue(JsonObjectCreationHandling handling);
    internal static bool IsValidUnmappedMemberHandlingValue(JsonUnmappedMemberHandling handling);
    internal static T UnboxOnRead(object value);
    internal static T UnboxOnWrite(object value);
    internal static bool TryReadMetadata(JsonConverter converter, JsonTypeInfo jsonTypeInfo, Utf8JsonReader& reader, ReadStack& state);
    internal static bool IsMetadataPropertyName(ReadOnlySpan`1<byte> propertyName, PolymorphicTypeResolver resolver);
    internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan`1<byte> propertyName, PolymorphicTypeResolver resolver);
    internal static bool TryHandleReferenceFromJsonElement(Utf8JsonReader& reader, ReadStack& state, JsonElement element, Object& referenceValue);
    internal static bool TryHandleReferenceFromJsonNode(Utf8JsonReader& reader, ReadStack& state, JsonNode jsonNode, Object& referenceValue);
    internal static void ValidateMetadataForObjectConverter(ReadStack& state);
    internal static void ValidateMetadataForArrayConverter(JsonConverter converter, Utf8JsonReader& reader, ReadStack& state);
    internal static T ResolveReferenceId(ReadStack& state);
    internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan`1<byte> unescapedPropertyName, ReadStack& state, JsonSerializerOptions options, Boolean& useExtensionProperty, bool createExtensionProperty);
    internal static ReadOnlySpan`1<byte> GetPropertyName(ReadStack& state, Utf8JsonReader& reader);
    internal static void CreateExtensionDataProperty(object obj, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("0")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo jsonTypeInfo);
    public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerContext context);
    private static TValue ReadFromSpan(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, Nullable`1<int> actualByteCount);
    private static object ReadFromSpanAsObject(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1<int> actualByteCount);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(Stream utf8Json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions options);
    public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    public static TValue Deserialize(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(Stream utf8Json, JsonTypeInfo jsonTypeInfo);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    private static IAsyncEnumerable`1<T> DeserializeAsyncEnumerableCore(Stream utf8Json, JsonTypeInfo`1<T> jsonTypeInfo, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(string json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerOptions options);
    public static TValue Deserialize(string json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(string json, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("0")]
public static object Deserialize(ReadOnlySpan`1<char> json, JsonTypeInfo jsonTypeInfo);
    public static object Deserialize(string json, Type returnType, JsonSerializerContext context);
    public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerContext context);
    private static TValue ReadFromSpan(ReadOnlySpan`1<char> json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static object ReadFromSpanAsObject(ReadOnlySpan`1<char> json, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo);
    public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerContext context);
    private static TValue Read(Utf8JsonReader& reader, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static object ReadAsObject(Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo);
    private static Utf8JsonReader GetReaderScopedToNextValue(Utf8JsonReader& reader, ReadStack& state);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Byte[] SerializeToUtf8Bytes(object value, JsonTypeInfo jsonTypeInfo);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerContext context);
    private static Byte[] WriteBytes(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static Byte[] WriteBytesAsObject(object value, JsonTypeInfo jsonTypeInfo);
    internal static MetadataPropertyName WriteMetadataForObject(JsonConverter jsonConverter, WriteStack& state, Utf8JsonWriter writer);
    internal static MetadataPropertyName WriteMetadataForCollection(JsonConverter jsonConverter, WriteStack& state, Utf8JsonWriter writer);
    internal static bool TryGetReferenceForValue(object currentValue, WriteStack& state, Utf8JsonWriter writer);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Stream utf8Json, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Task SerializeAsync(Stream utf8Json, object value, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, object value, JsonTypeInfo jsonTypeInfo);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerContext context);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static string Serialize(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    public static string Serialize(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static string Serialize(object value, JsonTypeInfo jsonTypeInfo);
    public static string Serialize(object value, Type inputType, JsonSerializerContext context);
    private static string WriteString(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static string WriteStringAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static void Serialize(Utf8JsonWriter writer, object value, JsonTypeInfo jsonTypeInfo);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerContext context);
    [CompilerGeneratedAttribute]
internal static void <UnboxOnRead>g__ThrowUnableToCastValue|50_0(object value);
    [CompilerGeneratedAttribute]
internal static string <TryHandleReferenceFromJsonNode>g__ReadAsStringMetadataValue|64_0(JsonNode jsonNode);
    [AsyncIteratorStateMachineAttribute("System.Text.Json.JsonSerializer/<<DeserializeAsyncEnumerableCore>g__CreateAsyncEnumerable|90_0>d`1")]
[CompilerGeneratedAttribute]
internal static IAsyncEnumerable`1<T> <DeserializeAsyncEnumerableCore>g__CreateAsyncEnumerable|90_0(Stream utf8Json, JsonTypeInfo`1<Queue`1<T>> queueTypeInfo, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static JsonTypeInfo`1<Queue`1<T>> <DeserializeAsyncEnumerableCore>g__CreateQueueTypeInfo|90_1(JsonTypeInfo`1<T> jsonTypeInfo);
}
public enum System.Text.Json.JsonSerializerDefaults : Enum {
    public int value__;
    public static JsonSerializerDefaults General;
    public static JsonSerializerDefaults Web;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonSerializerOptions : object {
    private CachingContext _cachingContext;
    private JsonTypeInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lastTypeInfo;
    private JsonTypeInfo _objectTypeInfo;
    internal static int BufferSizeDefault;
    internal static int DefaultMaxDepth;
    private static JsonSerializerOptions s_defaultOptions;
    private IJsonTypeInfoResolver _typeInfoResolver;
    private JsonNamingPolicy _dictionaryKeyPolicy;
    private JsonNamingPolicy _jsonPropertyNamingPolicy;
    private JsonCommentHandling _readCommentHandling;
    private ReferenceHandler _referenceHandler;
    private JavaScriptEncoder _encoder;
    private ConverterList _converters;
    private JsonIgnoreCondition _defaultIgnoreCondition;
    private JsonNumberHandling _numberHandling;
    private JsonObjectCreationHandling _preferredObjectCreationHandling;
    private JsonUnknownTypeHandling _unknownTypeHandling;
    private JsonUnmappedMemberHandling _unmappedMemberHandling;
    private int _defaultBufferSize;
    private int _maxDepth;
    private bool _allowTrailingCommas;
    private bool _ignoreNullValues;
    private bool _ignoreReadOnlyProperties;
    private bool _ignoreReadonlyFields;
    private bool _includeFields;
    private bool _propertyNameCaseInsensitive;
    private bool _writeIndented;
    private OptionsBoundJsonTypeInfoResolverChain _typeInfoResolverChain;
    [CompilerGeneratedAttribute]
private int <EffectiveMaxDepth>k__BackingField;
    private Nullable`1<bool> _canUseFastPathSerializationLogic;
    internal ReferenceHandlingStrategy ReferenceHandlingStrategy;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isReadOnly;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isConfiguredForJsonSerializer;
    private IJsonTypeInfoResolver _effectiveJsonTypeInfoResolver;
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
internal CachingContext CacheContext { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
internal JsonTypeInfo ObjectTypeInfo { get; }
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; }
    [NullableAttribute("1")]
public static JsonSerializerOptions Default { get; }
    public IJsonTypeInfoResolver TypeInfoResolver { get; public set; }
    [NullableAttribute("1")]
public IList`1<IJsonTypeInfoResolver> TypeInfoResolverChain { get; }
    public bool AllowTrailingCommas { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    [ObsoleteAttribute("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.")]
[EditorBrowsableAttribute("1")]
public bool IgnoreNullValues { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public JsonObjectCreationHandling PreferredObjectCreationHandling { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    internal int EffectiveMaxDepth { get; private set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public JsonUnknownTypeHandling UnknownTypeHandling { get; public set; }
    public JsonUnmappedMemberHandling UnmappedMemberHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public ReferenceHandler ReferenceHandler { get; public set; }
    [DebuggerBrowsableAttribute("0")]
internal bool CanUseFastPathSerializationLogic { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [NullableContextAttribute("1")]
public JsonSerializerOptions(JsonSerializerOptions options);
    public JsonSerializerOptions(JsonSerializerDefaults defaults);
    internal CachingContext get_CacheContext();
    [NullableContextAttribute("1")]
public JsonTypeInfo GetTypeInfo(Type type);
    [NullableContextAttribute("1")]
public bool TryGetTypeInfo(Type type, JsonTypeInfo& typeInfo);
    internal JsonTypeInfo GetTypeInfoInternal(Type type, bool ensureConfigured, Nullable`1<bool> ensureNotNull, bool resolveIfMutable, bool fallBackToNearestAncestorType);
    internal bool TryGetTypeInfoCached(Type type, JsonTypeInfo& typeInfo);
    internal JsonTypeInfo GetTypeInfoForRootType(Type type, bool fallBackToNearestAncestorType);
    internal bool TryGetPolymorphicTypeInfoForRootType(object rootValue, JsonTypeInfo& polymorphicTypeInfo);
    internal JsonTypeInfo get_ObjectTypeInfo();
    internal void ClearCaches();
    [NullableContextAttribute("1")]
public IList`1<JsonConverter> get_Converters();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Getting a converter for a type may require reflection which depends on unreferenced code.")]
[RequiresDynamicCodeAttribute("Getting a converter for a type may require reflection which depends on runtime code generation.")]
public JsonConverter GetConverter(Type typeToConvert);
    internal JsonConverter GetConverterInternal(Type typeToConvert);
    internal JsonConverter GetConverterFromList(Type typeToConvert);
    internal JsonConverter ExpandConverterFactory(JsonConverter converter, Type typeToConvert);
    internal static void CheckConverterNullabilityIsSameAsPropertyType(JsonConverter converter, Type propertyType);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonSerializerOptions get_Default();
    private static void TrackOptionsInstance(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("JsonSerializerOptions.AddContext is obsolete. To register a JsonSerializerContext, use either the TypeInfoResolver or TypeInfoResolverChain properties.")]
[EditorBrowsableAttribute("1")]
public void AddContext();
    public IJsonTypeInfoResolver get_TypeInfoResolver();
    public void set_TypeInfoResolver(IJsonTypeInfoResolver value);
    [NullableContextAttribute("1")]
public IList`1<IJsonTypeInfoResolver> get_TypeInfoResolverChain();
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonNumberHandling get_NumberHandling();
    public void set_NumberHandling(JsonNumberHandling value);
    public JsonObjectCreationHandling get_PreferredObjectCreationHandling();
    public void set_PreferredObjectCreationHandling(JsonObjectCreationHandling value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_EffectiveMaxDepth();
    [CompilerGeneratedAttribute]
private void set_EffectiveMaxDepth(int value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public JsonUnknownTypeHandling get_UnknownTypeHandling();
    public void set_UnknownTypeHandling(JsonUnknownTypeHandling value);
    public JsonUnmappedMemberHandling get_UnmappedMemberHandling();
    public void set_UnmappedMemberHandling(JsonUnmappedMemberHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    public ReferenceHandler get_ReferenceHandler();
    public void set_ReferenceHandler(ReferenceHandler value);
    internal bool get_CanUseFastPathSerializationLogic();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    [RequiresUnreferencedCodeAttribute("Populating unconfigured TypeInfoResolver properties with the reflection resolver requires unreferenced code.")]
[RequiresDynamicCodeAttribute("Populating unconfigured TypeInfoResolver properties with the reflection resolver requires runtime code generation.")]
public void MakeReadOnly(bool populateMissingResolver);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private void ConfigureForJsonSerializer();
    private JsonTypeInfo GetTypeInfoNoCaching(Type type);
    internal JsonDocumentOptions GetDocumentOptions();
    internal JsonNodeOptions GetNodeOptions();
    internal JsonReaderOptions GetReaderOptions();
    internal JsonWriterOptions GetWriterOptions();
    internal void VerifyMutable();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonSerializerOptions GetOrCreateDefaultOptionsInstance();
    private string get_DebuggerDisplay();
}
internal class System.Text.Json.JsonSnakeCaseLowerNamingPolicy : JsonSeparatorNamingPolicy {
}
internal class System.Text.Json.JsonSnakeCaseUpperNamingPolicy : JsonSeparatorNamingPolicy {
}
public enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
public enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
internal static class System.Text.Json.JsonWriterHelper : object {
    private static UTF8Encoding s_utf8Encoding;
    private static StandardFormat s_dateTimeStandardFormat;
    public static int LastAsciiCharacter;
    private static StandardFormat s_hexStandardFormat;
    private static ReadOnlySpan`1<byte> AllowList { get; }
    private static JsonWriterHelper();
    public static void WriteIndentation(Span`1<byte> buffer, int indent);
    public static void ValidateProperty(ReadOnlySpan`1<byte> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<byte> value);
    public static void ValidateDouble(double value);
    public static void ValidateSingle(float value);
    public static void ValidateProperty(ReadOnlySpan`1<char> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyNameLength(ReadOnlySpan`1<char> propertyName);
    public static void ValidatePropertyNameLength(ReadOnlySpan`1<byte> propertyName);
    internal static void ValidateNumber(ReadOnlySpan`1<byte> utf8FormattedNumber);
    public static bool IsValidUtf8String(ReadOnlySpan`1<byte> bytes);
    internal static OperationStatus ToUtf8(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& written);
    public static void WriteDateTimeTrimmed(Span`1<byte> buffer, DateTime value, Int32& bytesWritten);
    public static void WriteDateTimeOffsetTrimmed(Span`1<byte> buffer, DateTimeOffset value, Int32& bytesWritten);
    public static void TrimDateTimeOffset(Span`1<byte> buffer, Int32& bytesWritten);
    private static ReadOnlySpan`1<byte> get_AllowList();
    private static bool NeedsEscaping(byte value);
    private static bool NeedsEscapingNoBoundsCheck(char value);
    public static int NeedsEscaping(ReadOnlySpan`1<byte> value, JavaScriptEncoder encoder);
    public static int NeedsEscaping(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape);
    private static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextBytes(byte value, Span`1<byte> destination, Int32& written);
    private static bool IsAsciiValue(byte value);
    private static bool IsAsciiValue(char value);
    private static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextChars(char value, Span`1<char> destination, Int32& written);
    private static int WriteHex(int value, Span`1<char> destination, int written);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonWriterOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private int _optionsMask;
    [CompilerGeneratedAttribute]
private JavaScriptEncoder <Encoder>k__BackingField;
    private static int IndentBit;
    private static int SkipValidationBit;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public int MaxDepth { get; public set; }
    public bool SkipValidation { get; public set; }
    internal bool IndentedOrNotSkipValidation { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JavaScriptEncoder get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
    internal bool get_IndentedOrNotSkipValidation();
}
[FlagsAttribute]
internal enum System.Text.Json.MetadataPropertyName : Enum {
    public byte value__;
    public static MetadataPropertyName None;
    public static MetadataPropertyName Values;
    public static MetadataPropertyName Id;
    public static MetadataPropertyName Ref;
    public static MetadataPropertyName Type;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonArray[{List.Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonArray/DebugView")]
public class System.Text.Json.Nodes.JsonArray : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private List`1<JsonNode> _list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JsonNode> List { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.IsReadOnly { get; }
    public JsonArray(Nullable`1<JsonNodeOptions> options);
    public JsonArray(JsonNodeOptions options, JsonNode[] items);
    public JsonArray(JsonNode[] items);
    internal JsonArray(JsonElement element, Nullable`1<JsonNodeOptions> options);
    internal virtual JsonValueKind GetValueKindCore();
    internal virtual JsonNode DeepCloneCore();
    internal virtual bool DeepEqualsCore(JsonNode node);
    internal int GetElementIndex(JsonNode node);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.Text.Json.Nodes.JsonArray/<GetValues>d__9`1")]
public IEnumerable`1<T> GetValues();
    private void InitializeFromArray(JsonNode[] items);
    public static JsonArray Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
[RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
public void Add(T value);
    internal List`1<JsonNode> get_List();
    internal JsonNode GetItem(int index);
    internal void SetItem(int index, JsonNode value);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    [NullableContextAttribute("1")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    private List`1<JsonNode> InitializeList();
    private void GetUnderlyingRepresentation(List`1& list, Nullable`1& jsonElement);
    public sealed virtual int get_Count();
    public sealed virtual void Add(JsonNode item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonNode item);
    public sealed virtual int IndexOf(JsonNode item);
    public sealed virtual void Insert(int index, JsonNode item);
    public sealed virtual bool Remove(JsonNode item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.CopyTo(JsonNode[] array, int index);
    public sealed virtual IEnumerator`1<JsonNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.get_IsReadOnly();
    private static void DetachParent(JsonNode item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Text.Json.Nodes.JsonNode : object {
    private JsonNode _parent;
    private Nullable`1<JsonNodeOptions> _options;
    public Nullable`1<JsonNodeOptions> Options { get; }
    [NullableAttribute("2")]
public JsonNode Parent { get; internal set; }
    public JsonNode Root { get; }
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    internal JsonNode(Nullable`1<JsonNodeOptions> options);
    public Nullable`1<JsonNodeOptions> get_Options();
    public JsonArray AsArray();
    public JsonObject AsObject();
    public JsonValue AsValue();
    [NullableContextAttribute("2")]
public JsonNode get_Parent();
    internal void set_Parent(JsonNode value);
    public string GetPath();
    internal abstract virtual void GetPath(List`1<string> path, JsonNode child);
    public JsonNode get_Root();
    public virtual T GetValue();
    [NullableContextAttribute("2")]
public sealed virtual JsonNode get_Item(int index);
    [NullableContextAttribute("2")]
public sealed virtual void set_Item(int index, JsonNode value);
    public sealed virtual JsonNode get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JsonNode value);
    public JsonNode DeepClone();
    internal abstract virtual JsonNode DeepCloneCore();
    public JsonValueKind GetValueKind();
    internal abstract virtual JsonValueKind GetValueKindCore();
    public string GetPropertyName();
    public int GetElementIndex();
    [NullableContextAttribute("2")]
public static bool DeepEquals(JsonNode node1, JsonNode node2);
    internal abstract virtual bool DeepEqualsCore(JsonNode node);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
[RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
public void ReplaceWith(T value);
    internal void AssignParent(JsonNode parent);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static JsonNode ConvertFromValue(T value, Nullable`1<JsonNodeOptions> options);
    public static JsonNode op_Implicit(bool value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<bool> value);
    public static JsonNode op_Implicit(byte value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<byte> value);
    public static JsonNode op_Implicit(char value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<char> value);
    public static JsonNode op_Implicit(DateTime value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTime> value);
    public static JsonNode op_Implicit(DateTimeOffset value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JsonNode op_Implicit(decimal value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<decimal> value);
    public static JsonNode op_Implicit(double value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<double> value);
    public static JsonNode op_Implicit(Guid value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<Guid> value);
    public static JsonNode op_Implicit(short value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<short> value);
    public static JsonNode op_Implicit(int value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<int> value);
    public static JsonNode op_Implicit(long value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(sbyte value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<sbyte> value);
    public static JsonNode op_Implicit(float value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<float> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ushort value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(UInt32 value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ulong value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ulong> value);
    public static bool op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JsonNode value);
    public static byte op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JsonNode value);
    public static char op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JsonNode value);
    public static DateTime op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JsonNode value);
    public static DateTimeOffset op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JsonNode value);
    public static decimal op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JsonNode value);
    public static double op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JsonNode value);
    public static Guid op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JsonNode value);
    public static short op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JsonNode value);
    public static int op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JsonNode value);
    public static long op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JsonNode value);
    public static float op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static JsonNode Parse(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> nodeOptions);
    public static JsonNode Parse(string json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [NullableContextAttribute("0")]
public static JsonNode Parse(ReadOnlySpan`1<byte> utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public static JsonNode Parse(Stream utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [AsyncStateMachineAttribute("System.Text.Json.Nodes.JsonNode/<ParseAsync>d__103")]
public static Task`1<JsonNode> ParseAsync(Stream utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions, CancellationToken cancellationToken);
    public string ToJsonString(JsonSerializerOptions options);
    public virtual string ToString();
    public abstract virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal PooledByteBufferWriter WriteToPooledBuffer(JsonSerializerOptions options, JsonWriterOptions writerOptions, int bufferSize);
}
public class System.Text.Json.Nodes.JsonNodeOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PropertyNameCaseInsensitive>k__BackingField;
    public bool PropertyNameCaseInsensitive { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PropertyNameCaseInsensitive();
    [CompilerGeneratedAttribute]
public void set_PropertyNameCaseInsensitive(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonObject[{Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonObject/DebugView")]
public class System.Text.Json.Nodes.JsonObject : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private JsonPropertyDictionary`1<JsonNode> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonPropertyDictionary`1<JsonNode> Dictionary { get; }
    public int Count { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.IsReadOnly { get; }
    public JsonObject(Nullable`1<JsonNodeOptions> options);
    public JsonObject(IEnumerable`1<KeyValuePair`2<string, JsonNode>> properties, Nullable`1<JsonNodeOptions> options);
    internal JsonObject(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("2")]
public static JsonObject Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    internal JsonPropertyDictionary`1<JsonNode> get_Dictionary();
    internal virtual JsonNode DeepCloneCore();
    internal string GetPropertyName(JsonNode node);
    public bool TryGetPropertyValue(string propertyName, JsonNode& jsonNode);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal virtual JsonValueKind GetValueKindCore();
    internal virtual bool DeepEqualsCore(JsonNode node);
    internal JsonNode GetItem(string propertyName);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    internal void SetItem(string propertyName, JsonNode value);
    private void DetachParent(JsonNode item);
    public sealed virtual void Add(string propertyName, JsonNode value);
    public sealed virtual void Add(KeyValuePair`2<string, JsonNode> property);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string propertyName);
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string propertyName);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Contains(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonNode>> GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Remove(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Keys();
    private sealed virtual override ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Values();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(string propertyName, JsonNode& jsonNode);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private JsonPropertyDictionary`1<JsonNode> InitializeDictionary();
    private void GetUnderlyingRepresentation(JsonPropertyDictionary`1& dictionary, Nullable`1& jsonElement);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Nodes.JsonValue : JsonNode {
    internal static string CreateUnreferencedCodeMessage;
    internal static string CreateDynamicCodeMessage;
    private protected JsonValue(Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(bool value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<bool> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(byte value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<byte> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(char value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<char> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTime value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTime> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTimeOffset value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTimeOffset> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(decimal value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<decimal> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(double value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<double> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(Guid value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<Guid> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(short value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<short> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(int value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<int> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(long value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<long> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(sbyte value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<sbyte> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(float value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<float> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(string value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ushort value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ushort> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(UInt32 value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<UInt32> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ulong value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ulong> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(JsonElement value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<JsonElement> value, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
public static JsonValue Create(T value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(T value, JsonTypeInfo`1<T> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    public abstract virtual bool TryGetValue(T& value);
    private static void VerifyJsonElementIsNotArrayOrObject(JsonElement& element);
}
[DebuggerDisplayAttribute("{ToJsonString(),nq}")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonValue`1/DebugView")]
internal abstract class System.Text.Json.Nodes.JsonValue`1 : JsonValue {
    internal TValue Value;
    protected JsonValue`1(TValue value, Nullable`1<JsonNodeOptions> options);
    public virtual T GetValue();
    public virtual bool TryGetValue(T& value);
    internal sealed virtual JsonValueKind GetValueKindCore();
    internal sealed virtual bool DeepEqualsCore(JsonNode otherNode);
    internal TypeToConvert ConvertJsonElement();
    internal bool TryConvertJsonElement(TypeToConvert& result);
}
internal class System.Text.Json.Nodes.JsonValueCustomized`1 : JsonValue`1<TValue> {
    private JsonTypeInfo`1<TValue> _jsonTypeInfo;
    public JsonValueCustomized`1(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal virtual JsonNode DeepCloneCore();
}
internal class System.Text.Json.Nodes.JsonValuePrimitive`1 : JsonValue`1<TValue> {
    private static JsonSerializerOptions s_defaultOptions;
    private JsonConverter`1<TValue> _converter;
    public JsonValuePrimitive`1(TValue value, JsonConverter`1<TValue> converter, Nullable`1<JsonNodeOptions> options);
    private static JsonValuePrimitive`1();
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal virtual JsonNode DeepCloneCore();
}
internal enum System.Text.Json.NumericType : Enum {
    public int value__;
    public static NumericType Byte;
    public static NumericType SByte;
    public static NumericType Int16;
    public static NumericType Int32;
    public static NumericType Int64;
    public static NumericType Int128;
    public static NumericType UInt16;
    public static NumericType UInt32;
    public static NumericType UInt64;
    public static NumericType UInt128;
    public static NumericType Half;
    public static NumericType Single;
    public static NumericType Double;
    public static NumericType Decimal;
}
internal enum System.Text.Json.PolymorphicSerializationState : Enum {
    public byte value__;
    public static PolymorphicSerializationState None;
    public static PolymorphicSerializationState PolymorphicReEntryStarted;
    public static PolymorphicSerializationState PolymorphicReEntrySuspended;
    public static PolymorphicSerializationState PolymorphicReEntryNotFound;
}
internal class System.Text.Json.PooledByteBufferWriter : object {
    private Byte[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    public static int MaximumBufferSize;
    public ReadOnlyMemory`1<byte> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledByteBufferWriter(int initialCapacity);
    public ReadOnlyMemory`1<byte> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public void ClearAndReturnBuffers();
    private void ClearHelper();
    public sealed virtual void Dispose();
    public void InitializeEmptyInstance(int initialCapacity);
    public static PooledByteBufferWriter CreateEmptyInstanceForCaching();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken);
    internal void WriteToStream(Stream destination);
    private void CheckAndResizeBuffer(int sizeHint);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.ReadStack : ValueType {
    public ReadStackFrame Current;
    private ReadStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    public long BytesConsumed;
    public bool ReadAhead;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public string ReferenceId;
    public object PolymorphicTypeDiscriminator;
    public bool PreserveReferences;
    public ReadStackFrame& Parent { get; }
    public JsonPropertyInfo ParentProperty { get; }
    public bool IsContinuation { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [IsReadOnlyAttribute]
public ReadStackFrame& get_Parent();
    [IsReadOnlyAttribute]
public JsonPropertyInfo get_ParentProperty();
    public bool get_IsContinuation();
    private void EnsurePushCapacity();
    internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo);
    public JsonConverter ResumePolymorphicReEntry();
    public void ExitPolymorphicConverter(bool success);
    public string JsonPath();
    public JsonTypeInfo GetTopJsonTypeInfoWithParameterizedConstructor();
    private void SetConstructorArgumentState();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendStackFrame|24_0(StringBuilder sb, ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static int <JsonPath>g__GetCount|24_1(IEnumerable enumerable);
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendPropertyName|24_2(StringBuilder sb, string propertyName);
    [CompilerGeneratedAttribute]
internal static string <JsonPath>g__GetPropertyName|24_3(ReadStackFrame& frame);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.ReadStackFrame : ValueType {
    public JsonPropertyInfo JsonPropertyInfo;
    public StackFramePropertyState PropertyState;
    public bool UseExtensionProperty;
    public Byte[] JsonPropertyName;
    public string JsonPropertyNameAsString;
    public object DictionaryKey;
    public object ReturnValue;
    public JsonTypeInfo JsonTypeInfo;
    public StackFrameObjectState ObjectState;
    public bool CanContainMetadata;
    public MetadataPropertyName LatestMetadataPropertyName;
    public MetadataPropertyName MetadataPropertyNames;
    public PolymorphicSerializationState PolymorphicSerializationState;
    public JsonTypeInfo PolymorphicJsonTypeInfo;
    public int PropertyIndex;
    public List`1<PropertyRef> PropertyRefCache;
    public ArgumentState CtorArgumentState;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public BitArray RequiredPropertiesSet;
    public bool HasParentObject;
    public bool IsPopulating;
    public JsonTypeInfo BaseJsonTypeInfo { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public JsonTypeInfo get_BaseJsonTypeInfo();
    public void EndConstructorParameter();
    public void EndProperty();
    public void EndElement();
    public bool IsProcessingDictionary();
    public bool IsProcessingEnumerable();
    public void MarkRequiredPropertyAsRead(JsonPropertyInfo propertyInfo);
    internal void InitializeRequiredPropertiesValidationState(JsonTypeInfo typeInfo);
    internal void ValidateAllRequiredPropertiesAreRead(JsonTypeInfo typeInfo);
    private string get_DebuggerDisplay();
}
[ExtensionAttribute]
internal static class System.Text.Json.Reflection.ReflectionExtensions : object {
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    public static string CreateRangeMethodName;
    private static Type s_nullableType;
    private static ReflectionExtensions();
    [ExtensionAttribute]
public static Type GetCompatibleGenericBaseClass(Type type, Type baseType);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
public static Type GetCompatibleGenericInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool IsImmutableDictionaryType(Type type);
    [ExtensionAttribute]
public static bool IsImmutableEnumerableType(Type type);
    [ExtensionAttribute]
public static string GetImmutableDictionaryConstructingTypeName(Type type);
    [ExtensionAttribute]
public static string GetImmutableEnumerableConstructingTypeName(Type type);
    private static string GetBaseNameFromGenericType(Type genericType);
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsKeyValuePair(Type type);
    [ExtensionAttribute]
public static bool TryGetDeserializationConstructor(Type type, bool useDefaultCtorInAnnotatedStructs, ConstructorInfo& deserializationCtor);
    [ExtensionAttribute]
public static object GetDefaultValue(ParameterInfo parameterInfo);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Should only be used by the reflection-based serializer.")]
public static Type[] GetSortedTypeHierarchy(Type type);
    [ExtensionAttribute]
public static bool IsNullableOfT(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFromInternal(Type type, Type from);
    [ExtensionAttribute]
public static bool IsInSubtypeRelationshipWith(Type type, Type other);
    private static bool HasJsonConstructorAttribute(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static bool HasRequiredMemberAttribute(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool HasSetsRequiredMembersAttribute(MemberInfo memberInfo);
    [ExtensionAttribute]
private static bool HasCustomAttributeWithName(MemberInfo memberInfo, string fullName, bool inherit);
    [ExtensionAttribute]
public static TAttribute GetUniqueCustomAttribute(MemberInfo memberInfo, bool inherit);
    [ExtensionAttribute]
public static object CreateInstanceNoWrapExceptions(Type type, Type[] parameterTypes, Object[] parameters);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[DebuggerTypeProxyAttribute("System.Text.Json.Serialization.ConfigurationList`1/ConfigurationListDebugView")]
internal abstract class System.Text.Json.Serialization.ConfigurationList`1 : object {
    protected List`1<TItem> _list;
    public bool IsReadOnly { get; }
    public TItem Item { get; public set; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public ConfigurationList`1(IEnumerable`1<TItem> source);
    public abstract virtual bool get_IsReadOnly();
    protected abstract virtual void OnCollectionModifying();
    protected virtual void ValidateAddedValue(TItem item);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    public sealed virtual int get_Count();
    public sealed virtual void Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public Enumerator<TItem> GetEnumerator();
    public sealed virtual int IndexOf(TItem item);
    public sealed virtual void Insert(int index, TItem item);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string get_DebuggerDisplay();
}
internal class System.Text.Json.Serialization.Converters.ArrayConverter`2 : IEnumerableDefaultConverter`2<TElement[], TElement> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool get_CanHaveMetadata();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TElement[] array, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.BooleanConverter : JsonPrimitiveConverter`1<bool> {
    public virtual bool Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options);
    internal virtual bool ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ByteArrayConverter : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ByteConverter : JsonPrimitiveConverter`1<byte> {
    public virtual byte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options);
    internal virtual byte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual byte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.CastingConverter`1 : JsonConverter`1<T> {
    private JsonConverter _sourceConverter;
    [CompilerGeneratedAttribute]
private bool <HandleNull>k__BackingField;
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal JsonConverter SourceConverterForCastingConverter { get; }
    internal CastingConverter`1(JsonConverter sourceConverter);
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public virtual bool get_HandleNull();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual JsonConverter get_SourceConverterForCastingConverter();
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.CharConverter : JsonPrimitiveConverter`1<char> {
    private static int MaxEscapedCharacterLength;
    public virtual char Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options);
    internal virtual char ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, char value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentQueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentStackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.DateTimeConverter : JsonPrimitiveConverter`1<DateTime> {
    public virtual DateTime Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options);
    internal virtual DateTime ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DateTimeOffsetConverter : JsonPrimitiveConverter`1<DateTimeOffset> {
    public virtual DateTimeOffset Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options);
    internal virtual DateTimeOffset ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DecimalConverter : JsonPrimitiveConverter`1<decimal> {
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
    internal virtual decimal ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual decimal ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.DefaultObjectConverter : ObjectConverter {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
}
internal abstract class System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3 : JsonDictionaryConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveMetadata { get; }
    internal virtual bool get_CanHaveMetadata();
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DoubleConverter : JsonPrimitiveConverter`1<double> {
    public virtual double Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options);
    internal virtual double ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, double value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual double ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.EnumConverter`1 : JsonPrimitiveConverter`1<T> {
    private static TypeCode s_enumTypeCode;
    private static bool s_isSignedEnum;
    private static string ValueSeparator;
    private EnumConverterOptions _converterOptions;
    private JsonNamingPolicy _namingPolicy;
    private ConcurrentDictionary`2<ulong, JsonEncodedText> _nameCacheForWriting;
    private ConcurrentDictionary`2<string, T> _nameCacheForReading;
    private static int NameCacheSizeSoftLimit;
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions);
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions);
    private static EnumConverter`1();
    public virtual bool CanConvert(Type type);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    private static bool TryParseEnumCore(string enumString, JsonSerializerOptions _, T& value);
    private T ReadEnumUsingNamingPolicy(string enumString);
    private static ulong ConvertToUInt64(object value);
    private static bool IsValidIdentifier(string value);
    private static string FormatJsonName(string value, JsonNamingPolicy namingPolicy);
    private static String[] SplitFlagsEnum(string value);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.EnumConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
    internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static Type GetEnumConverterType(Type enumType);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.Converters.EnumConverterOptions : Enum {
    public int value__;
    public static EnumConverterOptions AllowStrings;
    public static EnumConverterOptions AllowNumbers;
}
internal class System.Text.Json.Serialization.Converters.FSharpListConverter`2 : IEnumerableDefaultConverter`2<TList, TElement> {
    private Func`2<IEnumerable`1<TElement>, TList> _listConstructor;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpMapConverter`3 : DictionaryDefaultConverter`3<TMap, TKey, TValue> {
    private Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TMap> _mapConstructor;
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpOptionConverter`2 : JsonConverter`1<TOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private Func`2<TOption, TElement> _optionValueGetter;
    private Func`2<TElement, TOption> _optionConstructor;
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options);
    public virtual TOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpSetConverter`2 : IEnumerableDefaultConverter`2<TSet, TElement> {
    private Func`2<IEnumerable`1<TElement>, TSet> _setConstructor;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
internal class System.Text.Json.Serialization.Converters.FSharpTypeConverterFactory : JsonConverterFactory {
    private ObjectConverterFactory _recordConverterFactory;
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:MakeGenericType")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpValueOptionConverter`2 : JsonConverter`1<TValueOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private StructGetter`2<TValueOption, TElement> _optionValueGetter;
    private Func`2<TElement, TValueOption> _optionConstructor;
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpValueOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TValueOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options);
    public virtual TValueOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.GuidConverter : JsonPrimitiveConverter`1<Guid> {
    public virtual Guid Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options);
    internal virtual Guid ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.IAsyncEnumerableOfTConverter`2 : JsonCollectionConverter`2<TAsyncEnumerable, TElement> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TAsyncEnumerable& value);
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ICollectionOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IDictionaryConverter`1 : JsonDictionaryConverter`3<TDictionary, string, object> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(string key, Object& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.IEnumerableConverterFactory : JsonConverterFactory {
    private static IDictionaryConverter`1<IDictionary> s_converterForIDictionary;
    private static IEnumerableConverter`1<IEnumerable> s_converterForIEnumerable;
    private static IListConverter`1<IList> s_converterForIList;
    private static IEnumerableConverterFactory();
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2 : JsonCollectionConverter`2<TCollection, TElement> {
    internal bool CanHaveMetadata { get; }
    internal virtual bool get_CanHaveMetadata();
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IListConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected sealed virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverterWithReflection`3 : ImmutableDictionaryOfTKeyTValueConverter`3<TCollection, TKey, TValue> {
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected sealed virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal sealed virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverterWithReflection`2 : ImmutableEnumerableOfTConverter`2<TCollection, TElement> {
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.Int16Converter : JsonPrimitiveConverter`1<short> {
    public virtual short Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options);
    internal virtual short ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, short value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual short ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int32Converter : JsonPrimitiveConverter`1<int> {
    public virtual int Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options);
    internal virtual int ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, int value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual int ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int64Converter : JsonPrimitiveConverter`1<long> {
    public virtual long Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options);
    internal virtual long ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, long value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual long ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.IReadOnlyDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.ISetOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonArrayConverter : JsonConverter`1<JsonArray> {
    public virtual void Write(Utf8JsonWriter writer, JsonArray value, JsonSerializerOptions options);
    public virtual JsonArray Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonArray ReadList(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonDocumentConverter : JsonConverter`1<JsonDocument> {
    public virtual JsonDocument Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonElementConverter : JsonConverter`1<JsonElement> {
    public virtual JsonElement Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1 : JsonResumableConverter`1<T> {
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNull>k__BackingField;
    internal JsonConverter`1<T> Converter { get; }
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool ConstructorIsParameterized { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal bool CanHaveMetadata { get; }
    internal bool CanPopulate { get; }
    public JsonMetadataServicesConverter`1(JsonConverter`1<T> converter);
    [CompilerGeneratedAttribute]
internal JsonConverter`1<T> get_Converter();
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public virtual bool get_HandleNull();
    internal virtual bool get_ConstructorIsParameterized();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool get_CanPopulate();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverter : JsonConverter`1<JsonNode> {
    private static JsonNodeConverter s_nodeConverter;
    private static JsonArrayConverter s_arrayConverter;
    private static JsonObjectConverter s_objectConverter;
    private static JsonValueConverter s_valueConverter;
    public static JsonNodeConverter Instance { get; }
    public static JsonArrayConverter ArrayConverter { get; }
    public static JsonObjectConverter ObjectConverter { get; }
    public static JsonValueConverter ValueConverter { get; }
    public static JsonNodeConverter get_Instance();
    public static JsonArrayConverter get_ArrayConverter();
    public static JsonObjectConverter get_ObjectConverter();
    public static JsonValueConverter get_ValueConverter();
    public virtual void Write(Utf8JsonWriter writer, JsonNode value, JsonSerializerOptions options);
    public virtual JsonNode Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonNode Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverterFactory : JsonConverterFactory {
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public virtual bool CanConvert(Type typeToConvert);
}
internal class System.Text.Json.Serialization.Converters.JsonObjectConverter : JsonConverter`1<JsonObject> {
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    public virtual void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options);
    public virtual JsonObject Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonObject ReadObject(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal abstract class System.Text.Json.Serialization.Converters.JsonPrimitiveConverter`1 : JsonConverter`1<T> {
    public sealed virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public sealed virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonValueConverter : JsonConverter`1<JsonValue> {
    public virtual void Write(Utf8JsonWriter writer, JsonValue value, JsonSerializerOptions options);
    public virtual JsonValue Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverter`1 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected sealed virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected sealed virtual object CreateObject(ReadStackFrame& frame);
    protected sealed virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverterWithReflection`1 : LargeObjectWithParameterizedConstructorConverter`1<T> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.MemoryByteConverter : JsonConverter`1<Memory`1<byte>> {
    public bool HandleNull { get; }
    public virtual bool get_HandleNull();
    public virtual Memory`1<byte> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Memory`1<byte> value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.MemoryConverter`1 : JsonCollectionConverter`2<Memory`1<T>, T> {
    internal bool CanHaveMetadata { get; }
    public bool HandleNull { get; }
    internal virtual bool get_CanHaveMetadata();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Memory`1& value);
    protected virtual void Add(T& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, Memory`1<T> value, JsonSerializerOptions options, WriteStack& state);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.MemoryConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.NullableConverter`1 : JsonConverter`1<Nullable`1<T>> {
    private JsonConverter`1<T> _elementConverter;
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool CanPopulate { get; }
    internal bool ConstructorIsParameterized { get; }
    public NullableConverter`1(JsonConverter`1<T> elementConverter);
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool get_CanPopulate();
    internal virtual bool get_ConstructorIsParameterized();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Nullable`1& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options, WriteStack& state);
    public virtual Nullable`1<T> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options);
    internal virtual Nullable`1<T> ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling numberHandling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, Nullable`1<T> value, JsonNumberHandling handling);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.NullableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static Type GetNullableConverterType(Type valueTypeToConvert);
}
internal abstract class System.Text.Json.Serialization.Converters.ObjectConverter : JsonConverter`1<object> {
    private protected virtual ConverterStrategy GetDefaultConverterStrategy();
    public sealed virtual object ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public sealed virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    public sealed virtual void WriteAsPropertyName(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal sealed virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.ObjectConverterFactory : JsonConverterFactory {
    private bool _useDefaultConstructorInUnannotatedStructs;
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public ObjectConverterFactory(bool useDefaultConstructorInUnannotatedStructs);
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1 : JsonObjectConverter`1<T> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal static void PopulatePropertiesFastPath(object obj, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    protected static void ReadPropertyValue(object obj, ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty);
    protected static bool ReadAheadPropertyValue(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
}
internal abstract class System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1 : ObjectDefaultConverter`1<T> {
    internal bool ConstructorIsParameterized { get; }
    internal sealed virtual bool get_ConstructorIsParameterized();
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    protected abstract virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
    protected abstract virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected abstract virtual object CreateObject(ReadStackFrame& frame);
    private void ReadConstructorArguments(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool ReadConstructorArgumentsWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool HandleConstructorArgumentWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private static bool HandlePropertyWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    private void BeginRead(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
}
internal class System.Text.Json.Serialization.Converters.QueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ReadOnlyMemoryByteConverter : JsonConverter`1<ReadOnlyMemory`1<byte>> {
    public bool HandleNull { get; }
    public virtual bool get_HandleNull();
    public virtual ReadOnlyMemory`1<byte> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ReadOnlyMemory`1<byte> value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ReadOnlyMemoryConverter`1 : JsonCollectionConverter`2<ReadOnlyMemory`1<T>, T> {
    internal bool CanHaveMetadata { get; }
    public bool HandleNull { get; }
    internal virtual bool get_CanHaveMetadata();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, ReadOnlyMemory`1& value);
    protected virtual void Add(T& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, ReadOnlyMemory`1<T> value, JsonSerializerOptions options, WriteStack& state);
    internal static bool OnWriteResume(Utf8JsonWriter writer, ReadOnlySpan`1<T> value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.SByteConverter : JsonPrimitiveConverter`1<sbyte> {
    public virtual sbyte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options);
    internal virtual sbyte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual sbyte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SingleConverter : JsonPrimitiveConverter`1<float> {
    public virtual float Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options);
    internal virtual float ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, float value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual float ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SlimObjectConverter : ObjectConverter {
    private IJsonTypeInfoResolver _originatingResolver;
    public SlimObjectConverter(IJsonTypeInfoResolver originatingResolver);
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected virtual object CreateObject(ReadStackFrame& frame);
    protected virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private static bool TryRead(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo, TArg& arg);
    protected virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    internal bool CanPopulate { get; }
    internal virtual bool get_CanPopulate();
    protected sealed virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverterWithReflection`1 : StackOrQueueConverter`1<TCollection> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StringConverter : JsonPrimitiveConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
    internal virtual string ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, string value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.TimeSpanConverter : JsonPrimitiveConverter`1<TimeSpan> {
    private static int MinimumTimeSpanFormatLength;
    private static int MaximumTimeSpanFormatLength;
    private static int MaximumEscapedTimeSpanFormatLength;
    public virtual TimeSpan Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual TimeSpan ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static TimeSpan ReadCore(Utf8JsonReader& reader);
    public virtual void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.UInt16Converter : JsonPrimitiveConverter`1<ushort> {
    public virtual ushort Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options);
    internal virtual ushort ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ushort ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt32Converter : JsonPrimitiveConverter`1<UInt32> {
    public virtual UInt32 Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options);
    internal virtual UInt32 ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual UInt32 ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, UInt32 value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt64Converter : JsonPrimitiveConverter`1<ulong> {
    public virtual ulong Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options);
    internal virtual ulong ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ulong ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverter`1 : JsonConverter`1<T> {
    private string _errorMessage;
    public string ErrorMessage { get; }
    public UnsupportedTypeConverter`1(string errorMessage);
    public string get_ErrorMessage();
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
    internal static JsonConverter CreateUnsupportedConverterForType(Type type, string errorMessage);
}
internal class System.Text.Json.Serialization.Converters.UriConverter : JsonPrimitiveConverter`1<Uri> {
    public virtual Uri Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options);
    internal virtual Uri ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static Uri ReadCore(Utf8JsonReader& reader);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.VersionConverter : JsonPrimitiveConverter`1<Version> {
    public virtual Version Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static Version ReadCore(Utf8JsonReader& reader);
    public virtual void Write(Utf8JsonWriter writer, Version value, JsonSerializerOptions options);
    internal virtual Version ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, Version value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.IAsyncEnumerableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private static Type GetAsyncEnumerableInterface(Type type);
}
[ExtensionAttribute]
internal static class System.Text.Json.Serialization.IEnumerableConverterFactoryHelpers : object {
    internal static string ImmutableConvertersUnreferencedCodeMessage;
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableEnumerableCreateRangeMethod(Type type, Type elementType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableDictionaryCreateRangeMethod(Type type, Type keyType, Type valueType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableEnumerableConstructingType(Type type);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableDictionaryConstructingType(Type type);
    [ExtensionAttribute]
public static bool IsNonGenericStackOrQueue(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2057:TypeGetType")]
private static Type GetTypeIfExists(string name);
}
internal class System.Text.Json.Serialization.IgnoreReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
}
internal class System.Text.Json.Serialization.IgnoreReferenceResolver : ReferenceResolver {
    private Stack`1<ReferenceEqualsWrapper> _stackForCycleDetection;
    internal virtual void PopReferenceForCycleDetection();
    internal virtual bool ContainsReferenceForCycleDetection(object value);
    internal virtual void PushReferenceForCycleDetection(object value);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
public interface System.Text.Json.Serialization.IJsonOnDeserialized {
    public abstract virtual void OnDeserialized();
}
public interface System.Text.Json.Serialization.IJsonOnDeserializing {
    public abstract virtual void OnDeserializing();
}
public interface System.Text.Json.Serialization.IJsonOnSerialized {
    public abstract virtual void OnSerialized();
}
public interface System.Text.Json.Serialization.IJsonOnSerializing {
    public abstract virtual void OnSerializing();
}
public abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
internal abstract class System.Text.Json.Serialization.JsonCollectionConverter`2 : JsonResumableConverter`1<TCollection> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal Type ElementType { get; }
    internal virtual bool get_SupportsCreateObjectDelegate();
    private protected sealed virtual ConverterStrategy GetDefaultConverterStrategy();
    internal virtual Type get_ElementType();
    protected abstract virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected static JsonConverter`1<TElement> GetElementConverter(JsonTypeInfo elementTypeInfo);
    protected static JsonConverter`1<TElement> GetElementConverter(WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    protected abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
[AttributeUsageAttribute("32")]
public class System.Text.Json.Serialization.JsonConstructorAttribute : JsonAttribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter : object {
    private ConverterStrategy _converterStrategy;
    [CompilerGeneratedAttribute]
private bool <CanUseDirectReadOrWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBePolymorphic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresReadAhead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesDefaultHandleNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNullOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNullOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalConverterForNumberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstructorIsParameterized>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    public Type Type { get; }
    internal ConverterStrategy ConverterStrategy { get; internal set; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal bool CanPopulate { get; }
    internal bool CanUseDirectReadOrWrite { get; internal set; }
    internal bool CanHaveMetadata { get; }
    internal bool CanBePolymorphic { get; internal set; }
    internal bool RequiresReadAhead { get; internal set; }
    internal bool UsesDefaultHandleNull { get; private protected set; }
    internal bool HandleNullOnRead { get; private protected set; }
    internal bool HandleNullOnWrite { get; private protected set; }
    internal JsonConverter SourceConverterForCastingConverter { get; }
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    internal bool IsValueType { get; internal set; }
    internal bool IsInternalConverter { get; internal set; }
    internal bool IsInternalConverterForNumberType { get; internal set; }
    internal bool ConstructorIsParameterized { get; }
    internal ConstructorInfo ConstructorInfo { get; internal set; }
    public abstract virtual Type get_Type();
    [NullableContextAttribute("1")]
public abstract virtual bool CanConvert(Type typeToConvert);
    internal ConverterStrategy get_ConverterStrategy();
    internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConverterStrategy(ConverterStrategy value);
    private protected abstract virtual ConverterStrategy GetDefaultConverterStrategy();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual bool get_CanPopulate();
    [CompilerGeneratedAttribute]
internal bool get_CanUseDirectReadOrWrite();
    [CompilerGeneratedAttribute]
internal void set_CanUseDirectReadOrWrite(bool value);
    internal virtual bool get_CanHaveMetadata();
    [CompilerGeneratedAttribute]
internal bool get_CanBePolymorphic();
    [CompilerGeneratedAttribute]
internal void set_CanBePolymorphic(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequiresReadAhead();
    [CompilerGeneratedAttribute]
internal void set_RequiresReadAhead(bool value);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal virtual JsonTypeInfo CreateJsonTypeInfo(JsonSerializerOptions options);
    internal JsonConverter`1<TTarget> CreateCastingConverter();
    [CompilerGeneratedAttribute]
internal bool get_UsesDefaultHandleNull();
    [CompilerGeneratedAttribute]
private protected void set_UsesDefaultHandleNull(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnRead();
    [CompilerGeneratedAttribute]
private protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HandleNullOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnWrite();
    [CompilerGeneratedAttribute]
private protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HandleNullOnWrite(bool value);
    internal virtual JsonConverter get_SourceConverterForCastingConverter();
    internal abstract virtual Type get_ElementType();
    internal abstract virtual Type get_KeyType();
    [CompilerGeneratedAttribute]
internal bool get_IsValueType();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInternalConverter();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInternalConverter(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInternalConverterForNumberType();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInternalConverterForNumberType(bool value);
    internal static bool ShouldFlush(Utf8JsonWriter writer, WriteStack& state);
    internal abstract virtual object ReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal abstract virtual bool OnTryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual bool TryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual object ReadAsPropertyNameAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal abstract virtual object ReadAsPropertyNameCoreAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal abstract virtual object ReadNumberWithCustomHandlingAsObject(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal abstract virtual void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal abstract virtual bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal abstract virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal abstract virtual void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling);
    [CompilerGeneratedAttribute]
internal virtual bool get_ConstructorIsParameterized();
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
internal void set_ConstructorInfo(ConstructorInfo value);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    internal JsonConverter ResolvePolymorphicConverter(JsonTypeInfo jsonTypeInfo, ReadStack& state);
    internal JsonConverter ResolvePolymorphicConverter(object value, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, WriteStack& state);
    internal bool TryHandleSerializedObjectReference(Utf8JsonWriter writer, object value, JsonSerializerOptions options, JsonConverter polymorphicConverter, WriteStack& state);
    internal static bool SingleValueReadWithReadAhead(bool requiresReadAhead, Utf8JsonReader& reader, ReadStack& state);
    internal static bool DoSingleValueReadWithReadAhead(Utf8JsonReader& reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    private JsonConverter`1<T> _fallbackConverterForPropertyNameSerialization;
    [NullableAttribute("2")]
internal Type KeyType { get; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    public bool HandleNull { get; }
    public Type Type { get; }
    internal T ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal bool WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    public virtual bool CanConvert(Type typeToConvert);
    private protected virtual ConverterStrategy GetDefaultConverterStrategy();
    internal sealed virtual JsonTypeInfo CreateJsonTypeInfo(JsonSerializerOptions options);
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal sealed virtual void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal sealed virtual bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal sealed virtual void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal bool TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value, Boolean& isPopulatedValue);
    internal sealed virtual bool OnTryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual object ReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadAsPropertyNameAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadAsPropertyNameCoreAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadNumberWithCustomHandlingAsObject(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    private static bool IsNull(T value);
    internal bool TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, Utf8JsonReader& reader);
    internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    private JsonConverter`1<T> GetFallbackConverterForPropertyNameSerialization(JsonSerializerOptions options);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1436")]
public class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [NullableAttribute("2")]
[DynamicallyAccessedMembersAttribute("1")]
public Type ConverterType { get; private set; }
    public JsonConverterAttribute(Type converterType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    public Type Type { get; }
    private protected virtual ConverterStrategy GetDefaultConverterStrategy();
    [NullableContextAttribute("1")]
public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual Type get_KeyType();
    internal sealed virtual Type get_ElementType();
    internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual bool OnTryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual object ReadAsPropertyNameAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadAsPropertyNameCoreAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadNumberWithCustomHandlingAsObject(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal sealed virtual void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal sealed virtual bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    public sealed virtual Type get_Type();
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal sealed virtual void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class System.Text.Json.Serialization.JsonDerivedTypeAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TypeDiscriminator>k__BackingField;
    public Type DerivedType { get; }
    [NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedTypeAttribute(Type derivedType);
    public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator);
    public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_TypeDiscriminator();
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`1 : JsonResumableConverter`1<TDictionary> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool get_SupportsCreateObjectDelegate();
    private protected sealed virtual ConverterStrategy GetDefaultConverterStrategy();
    protected internal abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`3 : JsonDictionaryConverter`1<TDictionary> {
    protected JsonConverter`1<TKey> _keyConverter;
    protected JsonConverter`1<TValue> _valueConverter;
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    protected abstract virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_ElementType();
    internal virtual Type get_KeyType();
    protected static JsonConverter`1<T> GetConverter(JsonTypeInfo typeInfo);
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TDictionary& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
    [CompilerGeneratedAttribute]
internal static TKey <OnTryRead>g__ReadDictionaryKey|10_0(JsonConverter`1<TKey> keyConverter, Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <Condition>k__BackingField;
    public JsonIgnoreCondition Condition { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(JsonIgnoreCondition value);
}
public enum System.Text.Json.Serialization.JsonIgnoreCondition : Enum {
    public int value__;
    public static JsonIgnoreCondition Never;
    public static JsonIgnoreCondition Always;
    public static JsonIgnoreCondition WhenWritingDefault;
    public static JsonIgnoreCondition WhenWritingNull;
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIncludeAttribute : JsonAttribute {
}
public enum System.Text.Json.Serialization.JsonKnownNamingPolicy : Enum {
    public int value__;
    public static JsonKnownNamingPolicy Unspecified;
    public static JsonKnownNamingPolicy CamelCase;
    public static JsonKnownNamingPolicy SnakeCaseLower;
    public static JsonKnownNamingPolicy SnakeCaseUpper;
    public static JsonKnownNamingPolicy KebabCaseLower;
    public static JsonKnownNamingPolicy KebabCaseUpper;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.JsonNumberEnumConverter`1 : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonNumberHandling : Enum {
    public int value__;
    public static JsonNumberHandling Strict;
    public static JsonNumberHandling AllowReadingFromString;
    public static JsonNumberHandling WriteAsString;
    public static JsonNumberHandling AllowNamedFloatingPointLiterals;
}
[AttributeUsageAttribute("396")]
public class System.Text.Json.Serialization.JsonNumberHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonNumberHandling <Handling>k__BackingField;
    public JsonNumberHandling Handling { get; }
    public JsonNumberHandlingAttribute(JsonNumberHandling handling);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_Handling();
}
internal abstract class System.Text.Json.Serialization.JsonObjectConverter`1 : JsonResumableConverter`1<T> {
    internal bool CanPopulate { get; }
    internal Type ElementType { get; }
    private protected sealed virtual ConverterStrategy GetDefaultConverterStrategy();
    internal virtual bool get_CanPopulate();
    internal sealed virtual Type get_ElementType();
}
public enum System.Text.Json.Serialization.JsonObjectCreationHandling : Enum {
    public int value__;
    public static JsonObjectCreationHandling Replace;
    public static JsonObjectCreationHandling Populate;
}
[AttributeUsageAttribute("1420")]
public class System.Text.Json.Serialization.JsonObjectCreationHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonObjectCreationHandling <Handling>k__BackingField;
    public JsonObjectCreationHandling Handling { get; }
    public JsonObjectCreationHandlingAttribute(JsonObjectCreationHandling handling);
    [CompilerGeneratedAttribute]
public JsonObjectCreationHandling get_Handling();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class System.Text.Json.Serialization.JsonPolymorphicAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <TypeDiscriminatorPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonUnknownDerivedTypeHandling <UnknownDerivedTypeHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnrecognizedTypeDiscriminators>k__BackingField;
    public string TypeDiscriminatorPropertyName { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TypeDiscriminatorPropertyName();
    [CompilerGeneratedAttribute]
public void set_TypeDiscriminatorPropertyName(string value);
    [CompilerGeneratedAttribute]
public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    [CompilerGeneratedAttribute]
public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnrecognizedTypeDiscriminators();
    [CompilerGeneratedAttribute]
public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyOrderAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; }
    public JsonPropertyOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonRequiredAttribute : JsonAttribute {
}
internal abstract class System.Text.Json.Serialization.JsonResumableConverter`1 : JsonConverter`1<T> {
    public bool HandleNull { get; }
    public virtual bool get_HandleNull();
    public sealed virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public sealed virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSerializableAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <TypeInfoPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    public string TypeInfoPropertyName { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    [NullableContextAttribute("1")]
public JsonSerializableAttribute(Type type);
    [CompilerGeneratedAttribute]
public string get_TypeInfoPropertyName();
    [CompilerGeneratedAttribute]
public void set_TypeInfoPropertyName(string value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
}
public abstract class System.Text.Json.Serialization.JsonSerializerContext : object {
    private JsonSerializerOptions _options;
    [NullableAttribute("1")]
public JsonSerializerOptions Options { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    [NullableContextAttribute("2")]
protected JsonSerializerContext(JsonSerializerOptions options);
    [NullableContextAttribute("1")]
public JsonSerializerOptions get_Options();
    internal void AssociateWithOptions(JsonSerializerOptions options);
    private sealed virtual override bool System.Text.Json.Serialization.Metadata.IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions options);
    [NullableContextAttribute("2")]
protected abstract virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    [NullableContextAttribute("1")]
public abstract virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonSourceGenerationMode : Enum {
    public int value__;
    public static JsonSourceGenerationMode Default;
    public static JsonSourceGenerationMode Metadata;
    public static JsonSourceGenerationMode Serialization;
}
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <DefaultIgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonKnownNamingPolicy <DictionaryKeyPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonObjectCreationHandling <PreferredObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropertyNameCaseInsensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonKnownNamingPolicy <PropertyNamingPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonCommentHandling <ReadCommentHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonUnknownTypeHandling <UnknownTypeHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonUnmappedMemberHandling <UnmappedMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteIndented>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStringEnumConverter>k__BackingField;
    public bool AllowTrailingCommas { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] Converters { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonKnownNamingPolicy DictionaryKeyPolicy { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public JsonObjectCreationHandling PreferredObjectCreationHandling { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonKnownNamingPolicy PropertyNamingPolicy { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public JsonUnknownTypeHandling UnknownTypeHandling { get; public set; }
    public JsonUnmappedMemberHandling UnmappedMemberHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    public bool UseStringEnumConverter { get; public set; }
    public JsonSourceGenerationOptionsAttribute(JsonSerializerDefaults defaults);
    [CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    [CompilerGeneratedAttribute]
public Type[] get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(Type[] value);
    [CompilerGeneratedAttribute]
public int get_DefaultBufferSize();
    [CompilerGeneratedAttribute]
public void set_DefaultBufferSize(int value);
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_DefaultIgnoreCondition();
    [CompilerGeneratedAttribute]
public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    [CompilerGeneratedAttribute]
public JsonKnownNamingPolicy get_DictionaryKeyPolicy();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyPolicy(JsonKnownNamingPolicy value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyFields();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyProperties();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeFields();
    [CompilerGeneratedAttribute]
public void set_IncludeFields(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public void set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public JsonObjectCreationHandling get_PreferredObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_PreferredObjectCreationHandling(JsonObjectCreationHandling value);
    [CompilerGeneratedAttribute]
public bool get_PropertyNameCaseInsensitive();
    [CompilerGeneratedAttribute]
public void set_PropertyNameCaseInsensitive(bool value);
    [CompilerGeneratedAttribute]
public JsonKnownNamingPolicy get_PropertyNamingPolicy();
    [CompilerGeneratedAttribute]
public void set_PropertyNamingPolicy(JsonKnownNamingPolicy value);
    [CompilerGeneratedAttribute]
public JsonCommentHandling get_ReadCommentHandling();
    [CompilerGeneratedAttribute]
public void set_ReadCommentHandling(JsonCommentHandling value);
    [CompilerGeneratedAttribute]
public JsonUnknownTypeHandling get_UnknownTypeHandling();
    [CompilerGeneratedAttribute]
public void set_UnknownTypeHandling(JsonUnknownTypeHandling value);
    [CompilerGeneratedAttribute]
public JsonUnmappedMemberHandling get_UnmappedMemberHandling();
    [CompilerGeneratedAttribute]
public void set_UnmappedMemberHandling(JsonUnmappedMemberHandling value);
    [CompilerGeneratedAttribute]
public bool get_WriteIndented();
    [CompilerGeneratedAttribute]
public void set_WriteIndented(bool value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
    [CompilerGeneratedAttribute]
public bool get_UseStringEnumConverter();
    [CompilerGeneratedAttribute]
public void set_UseStringEnumConverter(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresDynamicCodeAttribute("JsonStringEnumConverter cannot be statically analyzed and requires runtime code generation. Applications should use the generic JsonStringEnumConverter<TEnum> instead.")]
public class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    [NullableContextAttribute("2")]
public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public sealed virtual bool CanConvert(Type typeToConvert);
    public sealed virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.JsonStringEnumConverter`1 : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    [NullableContextAttribute("2")]
public JsonStringEnumConverter`1(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public sealed virtual bool CanConvert(Type typeToConvert);
    public sealed virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
public enum System.Text.Json.Serialization.JsonUnknownDerivedTypeHandling : Enum {
    public int value__;
    public static JsonUnknownDerivedTypeHandling FailSerialization;
    public static JsonUnknownDerivedTypeHandling FallBackToBaseType;
    public static JsonUnknownDerivedTypeHandling FallBackToNearestAncestor;
}
public enum System.Text.Json.Serialization.JsonUnknownTypeHandling : Enum {
    public int value__;
    public static JsonUnknownTypeHandling JsonElement;
    public static JsonUnknownTypeHandling JsonNode;
}
public enum System.Text.Json.Serialization.JsonUnmappedMemberHandling : Enum {
    public int value__;
    public static JsonUnmappedMemberHandling Skip;
    public static JsonUnmappedMemberHandling Disallow;
}
[AttributeUsageAttribute("1036")]
public class System.Text.Json.Serialization.JsonUnmappedMemberHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonUnmappedMemberHandling <UnmappedMemberHandling>k__BackingField;
    public JsonUnmappedMemberHandling UnmappedMemberHandling { get; }
    public JsonUnmappedMemberHandlingAttribute(JsonUnmappedMemberHandling unmappedMemberHandling);
    [CompilerGeneratedAttribute]
public JsonUnmappedMemberHandling get_UnmappedMemberHandling();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver : object {
    private static Dictionary`2<Type, JsonConverter> s_defaultSimpleConverters;
    private static JsonConverterFactory[] s_defaultFactoryConverters;
    private static MemberAccessor s_memberAccessor;
    private bool _mutable;
    private ModifierCollection _modifiers;
    private static DefaultJsonTypeInfoResolver s_defaultInstance;
    internal static MemberAccessor MemberAccessor { get; }
    public IList`1<Action`1<JsonTypeInfo>> Modifiers { get; }
    internal static bool IsDefaultInstanceRooted { get; }
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private DefaultJsonTypeInfoResolver(bool mutable);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonConverterFactory[] GetDefaultFactoryConverters();
    private static Dictionary`2<Type, JsonConverter> GetDefaultSimpleConverters();
    private static JsonConverter GetBuiltInConverter(Type typeToConvert);
    internal static bool TryGetDefaultSimpleConverter(Type typeToConvert, JsonConverter& converter);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonConverter GetCustomConverterForMember(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static JsonConverter GetConverterForType(Type typeToConvert, JsonSerializerOptions options, bool resolveJsonConverterAttribute);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static MemberAccessor get_MemberAccessor();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo CreateTypeInfoCore(Type type, JsonConverter converter, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static void PopulateProperties(JsonTypeInfo typeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static void AddMembersDeclaredBySuperType(JsonTypeInfo typeInfo, Type currentType, bool constructorHasSetsRequiredMembersAttribute, PropertyHierarchyResolutionState& state);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static void AddMember(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute, PropertyHierarchyResolutionState& state);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonPropertyInfo CreatePropertyInfo(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute);
    private static Nullable`1<JsonNumberHandling> GetNumberHandlingForType(Type type);
    private static Nullable`1<JsonObjectCreationHandling> GetObjectCreationHandlingForType(Type type);
    private static Nullable`1<JsonUnmappedMemberHandling> GetUnmappedMemberHandling(Type type);
    private static bool PropertyIsOverriddenAndIgnored(PropertyInfo propertyInfo, Dictionary`2<string, JsonPropertyInfo> ignoredMembers);
    private static void PopulateParameterInfoValues(JsonTypeInfo typeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static void PopulatePropertyInfo(JsonPropertyInfo jsonPropertyInfo, MemberInfo memberInfo, JsonConverter customConverter, Nullable`1<JsonIgnoreCondition> ignoreCondition, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute);
    private static void DeterminePropertyPolicies(JsonPropertyInfo propertyInfo, MemberInfo memberInfo);
    private static void DeterminePropertyName(JsonPropertyInfo propertyInfo, MemberInfo memberInfo);
    private static void DeterminePropertyIsRequired(JsonPropertyInfo propertyInfo, MemberInfo memberInfo, bool shouldCheckForRequiredKeyword);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static void DeterminePropertyAccessors(JsonPropertyInfo`1<T> jsonPropertyInfo, MemberInfo memberInfo, bool useNonPublicAccessors);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static Func`1<object> DetermineCreateObjectDelegate(Type type, JsonConverter converter);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options);
    public IList`1<Action`1<JsonTypeInfo>> get_Modifiers();
    private sealed virtual override bool System.Text.Json.Serialization.Metadata.IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions _);
    internal static bool get_IsDefaultInstanceRooted();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static DefaultJsonTypeInfoResolver RootDefaultInstance();
    [CompilerGeneratedAttribute]
internal static void <GetDefaultSimpleConverters>g__Add|3_0(JsonConverter converter, <>c__DisplayClass3_0& );
}
internal class System.Text.Json.Serialization.Metadata.EmptyJsonTypeInfoResolver : object {
    public sealed virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
    public sealed virtual bool IsCompatibleWithOptions(JsonSerializerOptions _);
}
internal class System.Text.Json.Serialization.Metadata.FSharpCoreReflectionProxy : object {
    public static string FSharpCoreUnreferencedCodeMessage;
    private static FSharpCoreReflectionProxy s_singletonInstance;
    private static string CompilationMappingAttributeTypeName;
    private Type _compilationMappingAttributeType;
    private MethodInfo _sourceConstructFlagsGetter;
    private Type _fsharpOptionType;
    private Type _fsharpValueOptionType;
    private Type _fsharpListType;
    private Type _fsharpSetType;
    private Type _fsharpMapType;
    private MethodInfo _fsharpListCtor;
    private MethodInfo _fsharpSetCtor;
    private MethodInfo _fsharpMapCtor;
    public static FSharpCoreReflectionProxy Instance { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public static bool IsFSharpType(Type type);
    public static FSharpCoreReflectionProxy get_Instance();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpKind DetectFSharpKind(Type type);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TFSharpOption, T> CreateFSharpOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public StructGetter`2<TFSharpValueOption, TElement> CreateFSharpValueOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpValueOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpList> CreateFSharpListConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpSet> CreateFSharpSetConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor();
    private Attribute GetFSharpCompilationMappingAttribute(Type type);
    private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute);
    private static Assembly GetFSharpCoreAssembly(Type type);
    private static TDelegate CreateDelegate(MethodInfo methodInfo);
    private static TMemberInfo EnsureMemberExists(TMemberInfo memberInfo, string memberName);
}
internal interface System.Text.Json.Serialization.Metadata.IBuiltInJsonTypeInfoResolver {
    public abstract virtual bool IsCompatibleWithOptions(JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
public interface System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver {
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<TCollection> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <KeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <ElementInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, TCollection> <SerializeHandler>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<TCollection> ObjectCreator { get; public set; }
    public JsonTypeInfo KeyInfo { get; public set; }
    [NullableAttribute("1")]
public JsonTypeInfo ElementInfo { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, TCollection> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<TCollection> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<TCollection> value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_KeyInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyInfo(JsonTypeInfo value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonTypeInfo get_ElementInfo();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ElementInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, TCollection> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, TCollection> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Text.Json.Serialization.Metadata.JsonDerivedType : ValueType {
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TypeDiscriminator>k__BackingField;
    public Type DerivedType { get; }
    [NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedType(Type derivedType);
    public JsonDerivedType(Type derivedType, int typeDiscriminator);
    public JsonDerivedType(Type derivedType, string typeDiscriminator);
    internal JsonDerivedType(Type derivedType, object typeDiscriminator);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_TypeDiscriminator();
    internal void Deconstruct(Type& derivedType, Object& typeDiscriminator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static class System.Text.Json.Serialization.Metadata.JsonMetadataServices : object {
    private static JsonConverter`1<bool> s_booleanConverter;
    private static JsonConverter`1<Byte[]> s_byteArrayConverter;
    private static JsonConverter`1<byte> s_byteConverter;
    private static JsonConverter`1<char> s_charConverter;
    private static JsonConverter`1<DateTime> s_dateTimeConverter;
    private static JsonConverter`1<DateTimeOffset> s_dateTimeOffsetConverter;
    private static JsonConverter`1<decimal> s_decimalConverter;
    private static JsonConverter`1<double> s_doubleConverter;
    private static JsonConverter`1<Guid> s_guidConverter;
    private static JsonConverter`1<short> s_int16Converter;
    private static JsonConverter`1<int> s_int32Converter;
    private static JsonConverter`1<long> s_int64Converter;
    private static JsonConverter`1<JsonArray> s_jsonArrayConverter;
    private static JsonConverter`1<JsonElement> s_jsonElementConverter;
    private static JsonConverter`1<JsonNode> s_jsonNodeConverter;
    private static JsonConverter`1<JsonObject> s_jsonObjectConverter;
    private static JsonConverter`1<JsonValue> s_jsonValueConverter;
    private static JsonConverter`1<JsonDocument> s_jsonDocumentConverter;
    private static JsonConverter`1<Memory`1<byte>> s_memoryByteConverter;
    private static JsonConverter`1<ReadOnlyMemory`1<byte>> s_readOnlyMemoryByteConverter;
    private static JsonConverter`1<object> s_objectConverter;
    private static JsonConverter`1<float> s_singleConverter;
    private static JsonConverter`1<sbyte> s_sbyteConverter;
    private static JsonConverter`1<string> s_stringConverter;
    private static JsonConverter`1<TimeSpan> s_timeSpanConverter;
    private static JsonConverter`1<ushort> s_uint16Converter;
    private static JsonConverter`1<UInt32> s_uint32Converter;
    private static JsonConverter`1<ulong> s_uint64Converter;
    private static JsonConverter`1<Uri> s_uriConverter;
    private static JsonConverter`1<Version> s_versionConverter;
    public static JsonConverter`1<bool> BooleanConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<Byte[]> ByteArrayConverter { get; }
    public static JsonConverter`1<byte> ByteConverter { get; }
    public static JsonConverter`1<char> CharConverter { get; }
    public static JsonConverter`1<DateTime> DateTimeConverter { get; }
    public static JsonConverter`1<DateTimeOffset> DateTimeOffsetConverter { get; }
    public static JsonConverter`1<decimal> DecimalConverter { get; }
    public static JsonConverter`1<double> DoubleConverter { get; }
    public static JsonConverter`1<Guid> GuidConverter { get; }
    public static JsonConverter`1<short> Int16Converter { get; }
    public static JsonConverter`1<int> Int32Converter { get; }
    public static JsonConverter`1<long> Int64Converter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<JsonArray> JsonArrayConverter { get; }
    public static JsonConverter`1<JsonElement> JsonElementConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<JsonNode> JsonNodeConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<JsonObject> JsonObjectConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<JsonValue> JsonValueConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<JsonDocument> JsonDocumentConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<Memory`1<byte>> MemoryByteConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<ReadOnlyMemory`1<byte>> ReadOnlyMemoryByteConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<object> ObjectConverter { get; }
    public static JsonConverter`1<float> SingleConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<sbyte> SByteConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<string> StringConverter { get; }
    public static JsonConverter`1<TimeSpan> TimeSpanConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ushort> UInt16Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<UInt32> UInt32Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ulong> UInt64Converter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<Uri> UriConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<Version> VersionConverter { get; }
    public static JsonTypeInfo`1<TElement[]> CreateArrayInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TElement[]> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIReadOnlyDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<TElement>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateISetInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateICollectionInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIAsyncEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    private static JsonTypeInfo`1<TCollection> CreateStackOrQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<Memory`1<TElement>> CreateMemoryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<Memory`1<TElement>> collectionInfo);
    public static JsonTypeInfo`1<ReadOnlyMemory`1<TElement>> CreateReadOnlyMemoryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<ReadOnlyMemory`1<TElement>> collectionInfo);
    public static JsonConverter`1<bool> get_BooleanConverter();
    public static JsonConverter`1<Byte[]> get_ByteArrayConverter();
    public static JsonConverter`1<byte> get_ByteConverter();
    public static JsonConverter`1<char> get_CharConverter();
    public static JsonConverter`1<DateTime> get_DateTimeConverter();
    public static JsonConverter`1<DateTimeOffset> get_DateTimeOffsetConverter();
    public static JsonConverter`1<decimal> get_DecimalConverter();
    public static JsonConverter`1<double> get_DoubleConverter();
    public static JsonConverter`1<Guid> get_GuidConverter();
    public static JsonConverter`1<short> get_Int16Converter();
    public static JsonConverter`1<int> get_Int32Converter();
    public static JsonConverter`1<long> get_Int64Converter();
    public static JsonConverter`1<JsonArray> get_JsonArrayConverter();
    public static JsonConverter`1<JsonElement> get_JsonElementConverter();
    public static JsonConverter`1<JsonNode> get_JsonNodeConverter();
    public static JsonConverter`1<JsonObject> get_JsonObjectConverter();
    public static JsonConverter`1<JsonValue> get_JsonValueConverter();
    public static JsonConverter`1<JsonDocument> get_JsonDocumentConverter();
    public static JsonConverter`1<Memory`1<byte>> get_MemoryByteConverter();
    public static JsonConverter`1<ReadOnlyMemory`1<byte>> get_ReadOnlyMemoryByteConverter();
    public static JsonConverter`1<object> get_ObjectConverter();
    public static JsonConverter`1<float> get_SingleConverter();
    public static JsonConverter`1<sbyte> get_SByteConverter();
    public static JsonConverter`1<string> get_StringConverter();
    public static JsonConverter`1<TimeSpan> get_TimeSpanConverter();
    public static JsonConverter`1<ushort> get_UInt16Converter();
    public static JsonConverter`1<UInt32> get_UInt32Converter();
    public static JsonConverter`1<ulong> get_UInt64Converter();
    public static JsonConverter`1<Uri> get_UriConverter();
    public static JsonConverter`1<Version> get_VersionConverter();
    public static JsonConverter`1<T> GetUnsupportedTypeConverter();
    public static JsonConverter`1<T> GetEnumConverter(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonTypeInfo`1<T> underlyingTypeInfo);
    [NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonSerializerOptions options);
    internal static JsonConverter`1<T> GetTypedConverter(JsonConverter converter);
    private static JsonTypeInfo`1<T> CreateCore(JsonConverter converter, JsonSerializerOptions options);
    private static JsonTypeInfo`1<T> CreateCore(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    private static JsonTypeInfo`1<T> CreateCore(JsonSerializerOptions options, JsonCollectionInfoValues`1<T> collectionInfo, JsonConverter`1<T> converter, object createObjectWithArgs, object addFunc);
    private static JsonConverter`1<T> GetConverter(JsonObjectInfoValues`1<T> objectInfo);
    private static void PopulateParameterInfoValues(JsonTypeInfo typeInfo, Func`1<JsonParameterInfoValues[]> paramFactory);
    internal static void PopulateProperties(JsonTypeInfo typeInfo, JsonPropertyInfoList propertyList, Func`2<JsonSerializerContext, JsonPropertyInfo[]> propInitFunc);
    private static JsonPropertyInfo`1<T> CreatePropertyInfoCore(JsonPropertyInfoValues`1<T> propertyInfoValues, JsonSerializerOptions options);
    private static void DeterminePropertyName(JsonPropertyInfo propertyInfo, string declaredPropertyName, string declaredJsonPropertyName);
    public static JsonPropertyInfo CreatePropertyInfo(JsonSerializerOptions options, JsonPropertyInfoValues`1<T> propertyInfo);
    public static JsonTypeInfo`1<T> CreateObjectInfo(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public static JsonTypeInfo`1<T> CreateValueInfo(JsonSerializerOptions options, JsonConverter converter);
}
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonObjectInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<T> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Object[], T> <ObjectWithParameterizedConstructorCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<JsonSerializerContext, JsonPropertyInfo[]> <PropertyMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<JsonParameterInfoValues[]> <ConstructorParameterMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, T> <SerializeHandler>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> ObjectCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], T> ObjectWithParameterizedConstructorCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropertyMetadataInitializer { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<JsonParameterInfoValues[]> ConstructorParameterMetadataInitializer { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<T> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<Object[], T> get_ObjectWithParameterizedConstructorCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectWithParameterizedConstructorCreator(Func`2<Object[], T> value);
    [CompilerGeneratedAttribute]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> get_PropertyMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyMetadataInitializer(Func`2<JsonSerializerContext, JsonPropertyInfo[]> value);
    [CompilerGeneratedAttribute]
public Func`1<JsonParameterInfoValues[]> get_ConstructorParameterMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConstructorParameterMetadataInitializer(Func`1<JsonParameterInfoValues[]> value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
}
internal abstract class System.Text.Json.Serialization.Metadata.JsonParameterInfo : object {
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNullTokensOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <MatchingProperty>k__BackingField;
    public JsonConverter EffectiveConverter { get; }
    public object DefaultValue { get; private protected set; }
    public bool IgnoreNullTokensOnRead { get; }
    public JsonSerializerOptions Options { get; }
    public Byte[] NameAsUtf8Bytes { get; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; }
    public int Position { get; }
    public JsonTypeInfo JsonTypeInfo { get; }
    public Type ParameterType { get; }
    public bool ShouldDeserialize { get; }
    public JsonPropertyInfo MatchingProperty { get; }
    public JsonParameterInfo(JsonParameterInfoValues parameterInfoValues, JsonPropertyInfo matchingProperty);
    public JsonConverter get_EffectiveConverter();
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreNullTokensOnRead();
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
public Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
public int get_Position();
    public JsonTypeInfo get_JsonTypeInfo();
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_MatchingProperty();
}
internal class System.Text.Json.Serialization.Metadata.JsonParameterInfo`1 : JsonParameterInfo {
    [CompilerGeneratedAttribute]
private JsonPropertyInfo`1<T> <MatchingProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    public JsonConverter`1<T> EffectiveConverter { get; }
    public JsonPropertyInfo`1<T> MatchingProperty { get; }
    public T DefaultValue { get; }
    public JsonParameterInfo`1(JsonParameterInfoValues parameterInfoValues, JsonPropertyInfo`1<T> matchingPropertyInfo);
    public JsonConverter`1<T> get_EffectiveConverter();
    [CompilerGeneratedAttribute]
public JsonPropertyInfo`1<T> get_MatchingProperty();
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonParameterInfoValues : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public int Position { get; public set; }
    public bool HasDefaultValue { get; public set; }
    [NullableAttribute("2")]
public object DefaultValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParameterType(Type value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Position(int value);
    [CompilerGeneratedAttribute]
public bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasDefaultValue(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DefaultValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.JsonPolymorphismOptions : object {
    private DerivedTypeList _derivedTypes;
    private bool _ignoreUnrecognizedTypeDiscriminators;
    private JsonUnknownDerivedTypeHandling _unknownDerivedTypeHandling;
    private string _typeDiscriminatorPropertyName;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <DeclaringTypeInfo>k__BackingField;
    public IList`1<JsonDerivedType> DerivedTypes { get; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public string TypeDiscriminatorPropertyName { get; public set; }
    [NullableAttribute("2")]
internal JsonTypeInfo DeclaringTypeInfo { get; internal set; }
    public IList`1<JsonDerivedType> get_DerivedTypes();
    public bool get_IgnoreUnrecognizedTypeDiscriminators();
    public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
    public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
    public string get_TypeDiscriminatorPropertyName();
    public void set_TypeDiscriminatorPropertyName(string value);
    private void VerifyMutable();
    [CompilerGeneratedAttribute]
internal JsonTypeInfo get_DeclaringTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_DeclaringTypeInfo(JsonTypeInfo value);
    internal static JsonPolymorphismOptions CreateFromAttributeDeclarations(Type baseType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class System.Text.Json.Serialization.Metadata.JsonPropertyInfo : object {
    internal static JsonPropertyInfo s_missingProperty;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <ParentTypeInfo>k__BackingField;
    private protected JsonConverter _effectiveConverter;
    private JsonConverter _customConverter;
    private protected Func`2<object, object> _untypedGet;
    private protected Action`2<object, object> _untypedSet;
    private bool _isUserSpecifiedSetter;
    private protected Func`3<object, object, bool> _shouldSerialize;
    private bool _isUserSpecifiedShouldSerialize;
    private Nullable`1<JsonIgnoreCondition> _ignoreCondition;
    private Nullable`1<JsonObjectCreationHandling> _objectCreationHandling;
    [CompilerGeneratedAttribute]
private JsonObjectCreationHandling <EffectiveObjectCreationHandling>k__BackingField;
    private ICustomAttributeProvider _attributeProvider;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    private bool _isExtensionDataProperty;
    private bool _isRequired;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfigured>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNullTokensOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForTypeInfo>k__BackingField;
    private string _name;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EscapedNameSection>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    private int _order;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    private JsonTypeInfo _jsonTypeInfo;
    [CompilerGeneratedAttribute]
private bool <CanSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserializeOrPopulate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_IsPublic>k__BackingField;
    private Nullable`1<JsonNumberHandling> _numberHandling;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <EffectiveNumberHandling>k__BackingField;
    private int _index;
    [NullableAttribute("2")]
internal JsonTypeInfo ParentTypeInfo { get; private set; }
    internal JsonConverter EffectiveConverter { get; }
    [NullableAttribute("2")]
public JsonConverter CustomConverter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Get { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Set { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<object, object, bool> ShouldSerialize { get; public set; }
    internal Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; internal set; }
    [NullableAttribute("2")]
public ICustomAttributeProvider AttributeProvider { get; public set; }
    internal JsonObjectCreationHandling EffectiveObjectCreationHandling { get; private set; }
    public Nullable`1<JsonObjectCreationHandling> ObjectCreationHandling { get; public set; }
    [NullableAttribute("2")]
internal string MemberName { get; internal set; }
    internal MemberTypes MemberType { get; internal set; }
    internal bool IsVirtual { get; internal set; }
    public bool IsExtensionData { get; public set; }
    public bool IsRequired { get; public set; }
    public Type PropertyType { get; }
    internal bool IsConfigured { get; private set; }
    internal bool HasGetter { get; }
    internal bool HasSetter { get; }
    internal bool IgnoreNullTokensOnRead { get; private protected set; }
    internal bool IgnoreDefaultValuesOnWrite { get; private protected set; }
    internal bool IgnoreReadOnlyMember { get; }
    internal bool IsForTypeInfo { get; internal set; }
    public string Name { get; public set; }
    internal Byte[] NameAsUtf8Bytes { get; internal set; }
    internal Byte[] EscapedNameSection { get; internal set; }
    public JsonSerializerOptions Options { get; }
    public int Order { get; public set; }
    internal Type DeclaringType { get; }
    internal JsonTypeInfo JsonTypeInfo { get; internal set; }
    internal bool IsPropertyTypeInfoConfigured { get; }
    internal bool IsIgnored { get; }
    internal bool CanSerialize { get; private set; }
    internal bool CanDeserialize { get; private set; }
    internal bool CanDeserializeOrPopulate { get; private set; }
    internal bool SrcGen_HasJsonInclude { get; internal set; }
    internal bool SrcGen_IsPublic { get; internal set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    internal Nullable`1<JsonNumberHandling> EffectiveNumberHandling { get; internal set; }
    internal bool PropertyTypeCanBeNull { get; }
    [NullableAttribute("2")]
internal object DefaultValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal int RequiredPropertyIndex { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonPropertyInfo(Type declaringType, Type propertyType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    private static JsonPropertyInfo();
    [CompilerGeneratedAttribute]
internal JsonTypeInfo get_ParentTypeInfo();
    [CompilerGeneratedAttribute]
private void set_ParentTypeInfo(JsonTypeInfo value);
    internal JsonConverter get_EffectiveConverter();
    [NullableContextAttribute("2")]
public JsonConverter get_CustomConverter();
    [NullableContextAttribute("2")]
public void set_CustomConverter(JsonConverter value);
    public Func`2<object, object> get_Get();
    public void set_Get(Func`2<object, object> value);
    public Action`2<object, object> get_Set();
    public void set_Set(Action`2<object, object> value);
    private protected abstract virtual void SetGetter(Delegate getter);
    private protected abstract virtual void SetSetter(Delegate setter);
    public Func`3<object, object, bool> get_ShouldSerialize();
    public void set_ShouldSerialize(Func`3<object, object, bool> value);
    private protected abstract virtual void SetShouldSerialize(Delegate predicate);
    internal Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    internal void set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    private protected abstract virtual void ConfigureIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    [NullableContextAttribute("2")]
public ICustomAttributeProvider get_AttributeProvider();
    [NullableContextAttribute("2")]
public void set_AttributeProvider(ICustomAttributeProvider value);
    [CompilerGeneratedAttribute]
internal JsonObjectCreationHandling get_EffectiveObjectCreationHandling();
    [CompilerGeneratedAttribute]
private void set_EffectiveObjectCreationHandling(JsonObjectCreationHandling value);
    public Nullable`1<JsonObjectCreationHandling> get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(Nullable`1<JsonObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
internal string get_MemberName();
    [CompilerGeneratedAttribute]
internal void set_MemberName(string value);
    [CompilerGeneratedAttribute]
internal MemberTypes get_MemberType();
    [CompilerGeneratedAttribute]
internal void set_MemberType(MemberTypes value);
    [CompilerGeneratedAttribute]
internal bool get_IsVirtual();
    [CompilerGeneratedAttribute]
internal void set_IsVirtual(bool value);
    public bool get_IsExtensionData();
    public void set_IsExtensionData(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    internal static JsonPropertyInfo GetPropertyPlaceholder();
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    private protected void VerifyMutable();
    [CompilerGeneratedAttribute]
internal bool get_IsConfigured();
    [CompilerGeneratedAttribute]
private void set_IsConfigured(bool value);
    internal void Configure();
    private protected abstract virtual void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal abstract virtual void DetermineReflectionPropertyAccessors(MemberInfo memberInfo, bool useNonPublicAccessors);
    private void CacheNameAsUtf8BytesAndEscapedNameSection();
    private void DetermineIgnoreCondition();
    private void DetermineSerializationCapabilities();
    private void DetermineNumberHandlingForTypeInfo();
    private void DetermineNumberHandlingForProperty();
    private void DetermineEffectiveObjectCreationHandlingForProperty();
    private bool NumberHandingIsApplicable();
    internal abstract virtual JsonParameterInfo CreateJsonParameterInfo(JsonParameterInfoValues parameterInfoValues);
    internal abstract virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual object GetValueAsObject(object obj);
    internal bool get_HasGetter();
    internal bool get_HasSetter();
    [CompilerGeneratedAttribute]
internal bool get_IgnoreNullTokensOnRead();
    [CompilerGeneratedAttribute]
private protected void set_IgnoreNullTokensOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreDefaultValuesOnWrite();
    [CompilerGeneratedAttribute]
private protected void set_IgnoreDefaultValuesOnWrite(bool value);
    internal bool get_IgnoreReadOnlyMember();
    [CompilerGeneratedAttribute]
internal bool get_IsForTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_IsForTypeInfo(bool value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
internal void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_EscapedNameSection();
    [CompilerGeneratedAttribute]
internal void set_EscapedNameSection(Byte[] value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    public int get_Order();
    public void set_Order(int value);
    internal bool ReadJsonAndAddExtensionProperty(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal bool ReadJsonExtensionDataValue(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal void EnsureChildOf(JsonTypeInfo parent);
    internal bool TryGetPrePopulatedValue(ReadStack& state);
    [CompilerGeneratedAttribute]
internal Type get_DeclaringType();
    internal JsonTypeInfo get_JsonTypeInfo();
    internal void set_JsonTypeInfo(JsonTypeInfo value);
    internal bool get_IsPropertyTypeInfoConfigured();
    internal bool get_IsIgnored();
    [CompilerGeneratedAttribute]
internal bool get_CanSerialize();
    [CompilerGeneratedAttribute]
private void set_CanSerialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserializeOrPopulate();
    [CompilerGeneratedAttribute]
private void set_CanDeserializeOrPopulate(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_HasJsonInclude();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_IsPublic();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_IsPublic(bool value);
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonNumberHandling> get_EffectiveNumberHandling();
    [CompilerGeneratedAttribute]
internal void set_EffectiveNumberHandling(Nullable`1<JsonNumberHandling> value);
    internal abstract virtual bool get_PropertyTypeCanBeNull();
    internal abstract virtual object get_DefaultValue();
    internal int get_RequiredPropertyIndex();
    internal void set_RequiredPropertyIndex(int value);
    internal bool IsOverriddenOrShadowedBy(JsonPropertyInfo other);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private JsonConverter`1<TValue> <ReadJsonAndAddExtensionProperty>g__GetDictionaryValueConverter|127_0();
}
internal class System.Text.Json.Serialization.Metadata.JsonPropertyInfo`1 : JsonPropertyInfo {
    private Func`2<object, T> _typedGet;
    private Action`2<object, T> _typedSet;
    private Func`3<object, T, bool> _shouldSerializeTyped;
    private JsonConverter`1<T> _typedEffectiveConverter;
    internal Func`2<object, T> Get { get; internal set; }
    internal Action`2<object, T> Set { get; internal set; }
    internal Func`3<object, T, bool> ShouldSerialize { get; internal set; }
    internal object DefaultValue { get; }
    internal bool PropertyTypeCanBeNull { get; }
    internal JsonConverter`1<T> EffectiveConverter { get; }
    internal JsonPropertyInfo`1(Type declaringType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    internal Func`2<object, T> get_Get();
    internal void set_Get(Func`2<object, T> value);
    internal Action`2<object, T> get_Set();
    internal void set_Set(Action`2<object, T> value);
    private protected virtual void SetGetter(Delegate getter);
    private protected virtual void SetSetter(Delegate setter);
    internal Func`3<object, T, bool> get_ShouldSerialize();
    internal void set_ShouldSerialize(Func`3<object, T, bool> value);
    private protected virtual void SetShouldSerialize(Delegate predicate);
    internal virtual object get_DefaultValue();
    internal virtual bool get_PropertyTypeCanBeNull();
    internal virtual JsonParameterInfo CreateJsonParameterInfo(JsonParameterInfoValues parameterInfoValues);
    internal JsonConverter`1<T> get_EffectiveConverter();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void DetermineReflectionPropertyAccessors(MemberInfo memberInfo, bool useNonPublicAccessors);
    private protected virtual void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);
    internal virtual object GetValueAsObject(object obj);
    internal virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    private protected virtual void ConfigureIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    private static bool IsDefaultValue(T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreConditionNever|31_0(object _, T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreConditionAlways|31_1(object _, T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreWhenWritingDefault|31_2(object _, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <PropertyTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, T> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, T> <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonIgnoreCondition> <IgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonPropertyName>k__BackingField;
    public bool IsProperty { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsVirtual { get; public set; }
    public Type DeclaringType { get; public set; }
    public JsonTypeInfo PropertyTypeInfo { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonConverter`1<T> Converter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, T> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, T> Setter { get; public set; }
    public Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; public set; }
    public bool HasJsonInclude { get; public set; }
    public bool IsExtensionData { get; public set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public string PropertyName { get; public set; }
    [NullableAttribute("2")]
public string JsonPropertyName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_PropertyTypeInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonConverter`1<T> get_Converter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Converter(JsonConverter`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<object, T> get_Getter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Getter(Func`2<object, T> value);
    [CompilerGeneratedAttribute]
public Action`2<object, T> get_Setter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Setter(Action`2<object, T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    [CompilerGeneratedAttribute]
public bool get_HasJsonInclude();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsExtensionData(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_JsonPropertyName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_JsonPropertyName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo : object {
    internal static Type ObjectType;
    private static int PropertyNameKeyLength;
    private static int ParameterNameCountCacheThreshold;
    private static int PropertyNameCountCacheThreshold;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyDictionary`1<JsonParameterInfo> <ParameterCache>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyDictionary`1<JsonPropertyInfo> <PropertyCache>k__BackingField;
    private ParameterRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _parameterRefsSorted;
    private PropertyRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _propertyRefsSorted;
    internal static string MetadataFactoryRequiresUnreferencedCode;
    internal static string JsonObjectTypeName;
    [CompilerGeneratedAttribute]
private int <NumberOfRequiredProperties>k__BackingField;
    private Action`1<object> _onSerializing;
    private Action`1<object> _onSerialized;
    private Action`1<object> _onDeserializing;
    private Action`1<object> _onDeserialized;
    private protected Func`1<object> _createObject;
    [CompilerGeneratedAttribute]
private Func`1<object> <CreateObjectForExtensionDataProperty>k__BackingField;
    private Func`2<JsonSerializerContext, JsonPropertyInfo[]> _sourceGenDelayedPropertyInitializer;
    private JsonPropertyInfoList _properties;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private protected JsonPolymorphismOptions _polymorphismOptions;
    [CompilerGeneratedAttribute]
private object <CreateObjectWithArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AddMethodDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <ExtensionDataProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphicTypeResolver <PolymorphicTypeResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSerializeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseSerializeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropertyMetadataSerializationNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <KeyType>k__BackingField;
    private JsonTypeInfo _elementTypeInfo;
    private JsonTypeInfo _keyTypeInfo;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfoKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <PropertyInfoForTypeInfo>k__BackingField;
    private Nullable`1<JsonNumberHandling> _numberHandling;
    private Nullable`1<JsonUnmappedMemberHandling> _unmappedMemberHandling;
    [CompilerGeneratedAttribute]
private JsonUnmappedMemberHandling <EffectiveUnmappedMemberHandling>k__BackingField;
    private Nullable`1<JsonObjectCreationHandling> _preferredPropertyObjectCreationHandling;
    private IJsonTypeInfoResolver _originatingResolver;
    [CompilerGeneratedAttribute]
private bool <IsCustomized>k__BackingField;
    private ConfigurationState modreq(System.Runtime.CompilerServices.IsVolatile) _configurationState;
    private ExceptionDispatchInfo _cachedConfigureError;
    private JsonTypeInfo _ancestorPolymorhicType;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isAncestorPolymorphicTypeResolved;
    [CompilerGeneratedAttribute]
private bool <IsCompatibleWithCurrentOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonParameterInfoValues[] <ParameterInfoValues>k__BackingField;
    internal int ParameterCount { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonPropertyDictionary`1<JsonParameterInfo> ParameterCache { get; private set; }
    internal bool UsesParameterizedConstructor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonPropertyDictionary`1<JsonPropertyInfo> PropertyCache { get; private set; }
    internal int NumberOfRequiredProperties { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> CreateObject { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`1<object> CreateObjectForExtensionDataProperty { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerializing { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerialized { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserializing { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserialized { get; public set; }
    [NullableAttribute("1")]
public IList`1<JsonPropertyInfo> Properties { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
internal JsonPropertyInfoList PropertyList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`2<JsonSerializerContext, JsonPropertyInfo[]> SourceGenDelayedPropertyInitializer { get; internal set; }
    public JsonPolymorphismOptions PolymorphismOptions { get; public set; }
    public bool IsReadOnly { get; private set; }
    internal object CreateObjectWithArgs { get; internal set; }
    internal object AddMethodDelegate { get; internal set; }
    internal JsonPropertyInfo ExtensionDataProperty { get; private set; }
    internal PolymorphicTypeResolver PolymorphicTypeResolver { get; private set; }
    internal bool HasSerializeHandler { get; private protected set; }
    internal bool CanUseSerializeHandler { get; private set; }
    internal bool PropertyMetadataSerializationNotSupported { get; internal set; }
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    [DebuggerBrowsableAttribute("0")]
internal JsonTypeInfo ElementTypeInfo { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal JsonTypeInfo KeyTypeInfo { get; internal set; }
    [NullableAttribute("1")]
public JsonSerializerOptions Options { get; }
    [NullableAttribute("1")]
public Type Type { get; }
    [NullableAttribute("1")]
public JsonConverter Converter { get; }
    public JsonTypeInfoKind Kind { get; private set; }
    [NullableAttribute("1")]
internal JsonPropertyInfo PropertyInfoForTypeInfo { get; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public Nullable`1<JsonUnmappedMemberHandling> UnmappedMemberHandling { get; public set; }
    internal JsonUnmappedMemberHandling EffectiveUnmappedMemberHandling { get; private set; }
    public Nullable`1<JsonObjectCreationHandling> PreferredPropertyObjectCreationHandling { get; public set; }
    [EditorBrowsableAttribute("1")]
public IJsonTypeInfoResolver OriginatingResolver { get; public set; }
    internal bool IsCustomized { get; internal set; }
    internal bool IsConfigured { get; }
    internal bool IsConfigurationStarted { get; }
    [DebuggerBrowsableAttribute("0")]
internal JsonTypeInfo AncestorPolymorphicType { get; }
    private bool IsCompatibleWithCurrentOptions { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonParameterInfoValues[] ParameterInfoValues { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal bool SupportsPolymorphicDeserialization { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options);
    private static JsonTypeInfo();
    [CompilerGeneratedAttribute]
internal int get_ParameterCount();
    [CompilerGeneratedAttribute]
private void set_ParameterCount(int value);
    [CompilerGeneratedAttribute]
internal JsonPropertyDictionary`1<JsonParameterInfo> get_ParameterCache();
    [CompilerGeneratedAttribute]
private void set_ParameterCache(JsonPropertyDictionary`1<JsonParameterInfo> value);
    internal bool get_UsesParameterizedConstructor();
    [CompilerGeneratedAttribute]
internal JsonPropertyDictionary`1<JsonPropertyInfo> get_PropertyCache();
    [CompilerGeneratedAttribute]
private void set_PropertyCache(JsonPropertyDictionary`1<JsonPropertyInfo> value);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal JsonPropertyInfo CreatePropertyUsingReflection(Type propertyType, Type declaringType);
    private protected abstract virtual JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, Type declaringType, JsonSerializerOptions options);
    internal JsonPropertyInfo GetProperty(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    internal JsonParameterInfo GetParameter(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    private static bool IsPropertyRefEqual(PropertyRef& propertyRef, ReadOnlySpan`1<byte> propertyName, ulong key);
    private static bool IsParameterRefEqual(ParameterRef& parameterRef, ReadOnlySpan`1<byte> parameterName, ulong key);
    internal static ulong GetKey(ReadOnlySpan`1<byte> name);
    internal void UpdateSortedPropertyCache(ReadStackFrame& frame);
    internal void UpdateSortedParameterCache(ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal int get_NumberOfRequiredProperties();
    [CompilerGeneratedAttribute]
private void set_NumberOfRequiredProperties(int value);
    public Func`1<object> get_CreateObject();
    public void set_CreateObject(Func`1<object> value);
    private protected abstract virtual void SetCreateObject(Delegate createObject);
    [CompilerGeneratedAttribute]
internal Func`1<object> get_CreateObjectForExtensionDataProperty();
    [CompilerGeneratedAttribute]
internal void set_CreateObjectForExtensionDataProperty(Func`1<object> value);
    public Action`1<object> get_OnSerializing();
    public void set_OnSerializing(Action`1<object> value);
    public Action`1<object> get_OnSerialized();
    public void set_OnSerialized(Action`1<object> value);
    public Action`1<object> get_OnDeserializing();
    public void set_OnDeserializing(Action`1<object> value);
    public Action`1<object> get_OnDeserialized();
    public void set_OnDeserialized(Action`1<object> value);
    [NullableContextAttribute("1")]
public IList`1<JsonPropertyInfo> get_Properties();
    internal JsonPropertyInfoList get_PropertyList();
    internal Func`2<JsonSerializerContext, JsonPropertyInfo[]> get_SourceGenDelayedPropertyInitializer();
    internal void set_SourceGenDelayedPropertyInitializer(Func`2<JsonSerializerContext, JsonPropertyInfo[]> value);
    public JsonPolymorphismOptions get_PolymorphismOptions();
    public void set_PolymorphismOptions(JsonPolymorphismOptions value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public void MakeReadOnly();
    [CompilerGeneratedAttribute]
internal object get_CreateObjectWithArgs();
    [CompilerGeneratedAttribute]
internal void set_CreateObjectWithArgs(object value);
    [CompilerGeneratedAttribute]
internal object get_AddMethodDelegate();
    [CompilerGeneratedAttribute]
internal void set_AddMethodDelegate(object value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_ExtensionDataProperty();
    [CompilerGeneratedAttribute]
private void set_ExtensionDataProperty(JsonPropertyInfo value);
    [CompilerGeneratedAttribute]
internal PolymorphicTypeResolver get_PolymorphicTypeResolver();
    [CompilerGeneratedAttribute]
private void set_PolymorphicTypeResolver(PolymorphicTypeResolver value);
    [CompilerGeneratedAttribute]
internal bool get_HasSerializeHandler();
    [CompilerGeneratedAttribute]
private protected void set_HasSerializeHandler(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanUseSerializeHandler();
    [CompilerGeneratedAttribute]
private void set_CanUseSerializeHandler(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PropertyMetadataSerializationNotSupported();
    [CompilerGeneratedAttribute]
internal void set_PropertyMetadataSerializationNotSupported(bool value);
    internal void ValidateCanBeUsedForPropertyMetadataSerialization();
    [CompilerGeneratedAttribute]
internal Type get_ElementType();
    [CompilerGeneratedAttribute]
internal Type get_KeyType();
    internal JsonTypeInfo get_ElementTypeInfo();
    internal void set_ElementTypeInfo(JsonTypeInfo value);
    internal JsonTypeInfo get_KeyTypeInfo();
    internal void set_KeyTypeInfo(JsonTypeInfo value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_Type();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public JsonTypeInfoKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(JsonTypeInfoKind value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_PropertyInfoForTypeInfo();
    private protected abstract virtual JsonPropertyInfo CreatePropertyInfoForTypeInfo();
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public Nullable`1<JsonUnmappedMemberHandling> get_UnmappedMemberHandling();
    public void set_UnmappedMemberHandling(Nullable`1<JsonUnmappedMemberHandling> value);
    [CompilerGeneratedAttribute]
internal JsonUnmappedMemberHandling get_EffectiveUnmappedMemberHandling();
    [CompilerGeneratedAttribute]
private void set_EffectiveUnmappedMemberHandling(JsonUnmappedMemberHandling value);
    public Nullable`1<JsonObjectCreationHandling> get_PreferredPropertyObjectCreationHandling();
    public void set_PreferredPropertyObjectCreationHandling(Nullable`1<JsonObjectCreationHandling> value);
    public IJsonTypeInfoResolver get_OriginatingResolver();
    public void set_OriginatingResolver(IJsonTypeInfoResolver value);
    internal void VerifyMutable();
    [CompilerGeneratedAttribute]
internal bool get_IsCustomized();
    [CompilerGeneratedAttribute]
internal void set_IsCustomized(bool value);
    internal bool get_IsConfigured();
    internal bool get_IsConfigurationStarted();
    internal void EnsureConfigured();
    private void Configure();
    internal JsonTypeInfo get_AncestorPolymorphicType();
    private void DetermineIsCompatibleWithCurrentOptions();
    [CompilerGeneratedAttribute]
private bool get_IsCompatibleWithCurrentOptions();
    [CompilerGeneratedAttribute]
private void set_IsCompatibleWithCurrentOptions(bool value);
    internal bool DetermineUsesParameterizedConstructor();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo`1<T> CreateJsonTypeInfo(JsonSerializerOptions options);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name);
    [CompilerGeneratedAttribute]
internal JsonParameterInfoValues[] get_ParameterInfoValues();
    [CompilerGeneratedAttribute]
internal void set_ParameterInfoValues(JsonParameterInfoValues[] value);
    internal abstract virtual void SerializeAsObject(Utf8JsonWriter writer, object rootValue);
    internal abstract virtual Task SerializeAsObjectAsync(Stream utf8Json, object rootValue, CancellationToken cancellationToken);
    internal abstract virtual void SerializeAsObject(Stream utf8Json, object rootValue);
    internal abstract virtual object DeserializeAsObject(Utf8JsonReader& reader, ReadStack& state);
    internal abstract virtual ValueTask`1<object> DeserializeAsObjectAsync(Stream utf8Json, CancellationToken cancellationToken);
    internal abstract virtual object DeserializeAsObject(Stream utf8Json);
    internal void ConfigureProperties();
    internal void ConfigureConstructorParameters();
    internal static void ValidateType(Type type);
    internal static bool IsInvalidForSerialization(Type type);
    internal void PopulatePolymorphismMetadata();
    internal void MapInterfaceTypesToCallbacks();
    internal void SetCreateObjectIfCompatible(Delegate createObject);
    private static bool IsByRefLike(Type type);
    internal bool get_SupportsPolymorphicDeserialization();
    internal static bool IsValidExtensionDataProperty(Type propertyType);
    internal JsonPropertyDictionary`1<JsonPropertyInfo> CreatePropertyCache(int capacity);
    private static JsonTypeInfoKind GetTypeInfoKind(Type type, JsonConverter converter);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private JsonPropertyInfoList <get_PropertyList>g__CreatePropertyList|65_0();
    [CompilerGeneratedAttribute]
private void <EnsureConfigured>g__ConfigureSynchronized|172_0();
    [CompilerGeneratedAttribute]
private bool <DetermineIsCompatibleWithCurrentOptions>g__IsCurrentNodeCompatible|178_0();
}
public class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1 : JsonTypeInfo {
    internal JsonTypeInfo _asyncEnumerableQueueTypeInfo;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _canUseSerializeHandlerInStreamingState;
    private static int MinSerializationsSampleSize;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _serializationCount;
    private Action`2<Utf8JsonWriter, T> _serialize;
    private Func`1<T> _typedCreateObject;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <EffectiveConverter>k__BackingField;
    private bool CanUseSerializeHandlerInStreaming { get; }
    [NullableAttribute("1")]
internal JsonConverter`1<T> EffectiveConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> CreateObject { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[EditorBrowsableAttribute("1")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; internal set; }
    internal JsonTypeInfo`1(JsonConverter converter, JsonSerializerOptions options);
    internal T Deserialize(Utf8JsonReader& reader, ReadStack& state);
    [AsyncStateMachineAttribute("System.Text.Json.Serialization.Metadata.JsonTypeInfo`1/<DeserializeAsync>d__1")]
internal ValueTask`1<T> DeserializeAsync(Stream utf8Json, CancellationToken cancellationToken);
    internal T Deserialize(Stream utf8Json);
    internal sealed virtual object DeserializeAsObject(Utf8JsonReader& reader, ReadStack& state);
    [AsyncStateMachineAttribute("System.Text.Json.Serialization.Metadata.JsonTypeInfo`1/<DeserializeAsObjectAsync>d__5")]
internal sealed virtual ValueTask`1<object> DeserializeAsObjectAsync(Stream utf8Json, CancellationToken cancellationToken);
    internal sealed virtual object DeserializeAsObject(Stream utf8Json);
    internal T ContinueDeserialize(ReadBufferState& bufferState, JsonReaderState& jsonReaderState, ReadStack& readStack);
    internal void Serialize(Utf8JsonWriter writer, T& rootValue, object rootValueBoxed);
    [AsyncStateMachineAttribute("System.Text.Json.Serialization.Metadata.JsonTypeInfo`1/<SerializeAsync>d__9")]
internal Task SerializeAsync(Stream utf8Json, T rootValue, CancellationToken cancellationToken, object rootValueBoxed);
    internal void Serialize(Stream utf8Json, T& rootValue, object rootValueBoxed);
    internal sealed virtual void SerializeAsObject(Utf8JsonWriter writer, object rootValue);
    internal sealed virtual Task SerializeAsObjectAsync(Stream utf8Json, object rootValue, CancellationToken cancellationToken);
    internal sealed virtual void SerializeAsObject(Stream utf8Json, object rootValue);
    private bool get_CanUseSerializeHandlerInStreaming();
    private void OnRootLevelAsyncSerializationCompleted(long serializationSize);
    [CompilerGeneratedAttribute]
internal JsonConverter`1<T> get_EffectiveConverter();
    public Func`1<T> get_CreateObject();
    public void set_CreateObject(Func`1<T> value);
    private protected virtual void SetCreateObject(Delegate createObject);
    public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    internal void set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
    private protected virtual JsonPropertyInfo CreatePropertyInfoForTypeInfo();
    private protected virtual JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, Type declaringType, JsonSerializerOptions options);
}
public enum System.Text.Json.Serialization.Metadata.JsonTypeInfoKind : Enum {
    public int value__;
    public static JsonTypeInfoKind None;
    public static JsonTypeInfoKind Object;
    public static JsonTypeInfoKind Enumerable;
    public static JsonTypeInfoKind Dictionary;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Text.Json.Serialization.Metadata.JsonTypeInfoResolver : object {
    [CompilerGeneratedAttribute]
private static IJsonTypeInfoResolver <Empty>k__BackingField;
    internal static IJsonTypeInfoResolver Empty { get; }
    private static JsonTypeInfoResolver();
    public static IJsonTypeInfoResolver Combine(IJsonTypeInfoResolver[] resolvers);
    [ExtensionAttribute]
public static IJsonTypeInfoResolver WithAddedModifier(IJsonTypeInfoResolver resolver, Action`1<JsonTypeInfo> modifier);
    [CompilerGeneratedAttribute]
internal static IJsonTypeInfoResolver get_Empty();
    [ExtensionAttribute]
internal static bool IsCompatibleWithOptions(IJsonTypeInfoResolver resolver, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Metadata.JsonTypeInfoResolverChain : ConfigurationList`1<IJsonTypeInfoResolver> {
    public bool IsReadOnly { get; }
    public virtual bool get_IsReadOnly();
    protected virtual void OnCollectionModifying();
    public sealed virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
    internal void AddFlattened(IJsonTypeInfoResolver resolver);
    private sealed virtual override bool System.Text.Json.Serialization.Metadata.IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions options);
    public virtual string ToString();
}
internal class System.Text.Json.Serialization.Metadata.JsonTypeInfoResolverWithAddedModifiers : object {
    private IJsonTypeInfoResolver _source;
    private Action`1[] _modifiers;
    public JsonTypeInfoResolverWithAddedModifiers(IJsonTypeInfoResolver source, Action`1[] modifiers);
    public JsonTypeInfoResolverWithAddedModifiers WithAddedModifier(Action`1<JsonTypeInfo> modifier);
    public sealed virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Metadata.MemberAccessor : object {
    public abstract virtual Func`1<object> CreateParameterlessConstructor(Type type, ConstructorInfo constructorInfo);
    public abstract virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public abstract virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public abstract virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public abstract virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public abstract virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.ParameterRef : ValueType {
    public ulong Key;
    public JsonParameterInfo Info;
    public Byte[] NameFromJson;
    public ParameterRef(ulong key, JsonParameterInfo info, Byte[] nameFromJson);
}
internal class System.Text.Json.Serialization.Metadata.PolymorphicTypeResolver : object {
    private ConcurrentDictionary`2<Type, DerivedJsonTypeInfo> _typeToDiscriminatorId;
    private Dictionary`2<object, DerivedJsonTypeInfo> _discriminatorIdtoType;
    private JsonSerializerOptions _options;
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonUnknownDerivedTypeHandling <UnknownDerivedTypeHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesTypeDiscriminators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnrecognizedTypeDiscriminators>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeDiscriminatorPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <TypeDiscriminatorPropertyNameUtf8>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonEncodedText> <CustomTypeDiscriminatorPropertyNameJsonEncoded>k__BackingField;
    public Type BaseType { get; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; }
    public bool UsesTypeDiscriminators { get; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; }
    public string TypeDiscriminatorPropertyName { get; }
    public Byte[] TypeDiscriminatorPropertyNameUtf8 { get; }
    public Nullable`1<JsonEncodedText> CustomTypeDiscriminatorPropertyNameJsonEncoded { get; }
    public PolymorphicTypeResolver(JsonSerializerOptions options, JsonPolymorphismOptions polymorphismOptions, Type baseType, bool converterCanHaveMetadata);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    [CompilerGeneratedAttribute]
public bool get_UsesTypeDiscriminators();
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnrecognizedTypeDiscriminators();
    [CompilerGeneratedAttribute]
public string get_TypeDiscriminatorPropertyName();
    [CompilerGeneratedAttribute]
public Byte[] get_TypeDiscriminatorPropertyNameUtf8();
    [CompilerGeneratedAttribute]
public Nullable`1<JsonEncodedText> get_CustomTypeDiscriminatorPropertyNameJsonEncoded();
    public bool TryGetDerivedJsonTypeInfo(Type runtimeType, JsonTypeInfo& jsonTypeInfo, Object& typeDiscriminator);
    public bool TryGetDerivedJsonTypeInfo(object typeDiscriminator, JsonTypeInfo& jsonTypeInfo);
    public static bool IsSupportedPolymorphicBaseType(Type type);
    public static bool IsSupportedDerivedType(Type baseType, Type derivedType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private DerivedJsonTypeInfo CalculateNearestAncestor(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
internal static JsonTypeInfo FindNearestPolymorphicBaseType(JsonTypeInfo typeInfo);
    [CompilerGeneratedAttribute]
internal static JsonTypeInfo <FindNearestPolymorphicBaseType>g__ResolveAncestorTypeInfo|30_0(Type type, JsonSerializerOptions options);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.PropertyRef : ValueType {
    public ulong Key;
    public JsonPropertyInfo Info;
    public Byte[] NameFromJson;
    public PropertyRef(ulong key, JsonPropertyInfo info, Byte[] nameFromJson);
}
internal class System.Text.Json.Serialization.Metadata.ReflectionMemberAccessor : MemberAccessor {
    public virtual Func`1<object> CreateParameterlessConstructor(Type type, ConstructorInfo ctorInfo);
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
internal class System.Text.Json.Serialization.PreserveReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
internal class System.Text.Json.Serialization.PreserveReferenceResolver : ReferenceResolver {
    private UInt32 _referenceCount;
    private Dictionary`2<string, object> _referenceIdToObjectMap;
    private Dictionary`2<object, string> _objectToReferenceIdMap;
    public PreserveReferenceResolver(bool writing);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
internal class System.Text.Json.Serialization.ReadBufferState : ValueType {
    private Byte[] _buffer;
    private byte _offset;
    private int _count;
    private int _maxCount;
    private bool _isFirstBlock;
    private bool _isFinalBlock;
    private static int UnsuccessfulReadCountThreshold;
    private int _unsuccessfulReadCount;
    public bool IsFinalBlock { get; }
    public ReadOnlySpan`1<byte> Bytes { get; }
    public ReadBufferState(int initialBufferSize);
    public bool get_IsFinalBlock();
    public ReadOnlySpan`1<byte> get_Bytes();
    [IsReadOnlyAttribute]
[AsyncStateMachineAttribute("System.Text.Json.Serialization.ReadBufferState/<ReadFromStreamAsync>d__13")]
public ValueTask`1<ReadBufferState> ReadFromStreamAsync(Stream utf8Json, CancellationToken cancellationToken, bool fillBuffer);
    public void ReadFromStream(Stream utf8Json);
    public void AdvanceBuffer(int bytesConsumed);
    private void ProcessReadBytes();
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.ReferenceEqualsWrapper : ValueType {
    private object _object;
    public ReferenceEqualsWrapper(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceEqualsWrapper obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceHandler : object {
    internal ReferenceHandlingStrategy HandlingStrategy;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <Preserve>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <IgnoreCycles>k__BackingField;
    public static ReferenceHandler Preserve { get; }
    public static ReferenceHandler IgnoreCycles { get; }
    private static ReferenceHandler();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_Preserve();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_IgnoreCycles();
    public abstract virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
public class System.Text.Json.Serialization.ReferenceHandler`1 : ReferenceHandler {
    [NullableContextAttribute("1")]
public virtual ReferenceResolver CreateResolver();
}
internal enum System.Text.Json.Serialization.ReferenceHandlingStrategy : Enum {
    public int value__;
    public static ReferenceHandlingStrategy None;
    public static ReferenceHandlingStrategy Preserve;
    public static ReferenceHandlingStrategy IgnoreCycles;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceResolver : object {
    public abstract virtual void AddReference(string referenceId, object value);
    public abstract virtual string GetReference(object value, Boolean& alreadyExists);
    public abstract virtual object ResolveReference(string referenceId);
    internal virtual void PopReferenceForCycleDetection();
    internal virtual void PushReferenceForCycleDetection(object value);
    internal virtual bool ContainsReferenceForCycleDetection(object value);
}
internal enum System.Text.Json.StackFrameObjectState : Enum {
    public byte value__;
    public static StackFrameObjectState None;
    public static StackFrameObjectState StartToken;
    public static StackFrameObjectState ReadMetadata;
    public static StackFrameObjectState ConstructorArguments;
    public static StackFrameObjectState CreatedObject;
    public static StackFrameObjectState ReadElements;
    public static StackFrameObjectState EndToken;
    public static StackFrameObjectState EndTokenValidation;
}
internal enum System.Text.Json.StackFramePropertyState : Enum {
    public byte value__;
    public static StackFramePropertyState None;
    public static StackFramePropertyState ReadName;
    public static StackFramePropertyState Name;
    public static StackFramePropertyState ReadValue;
    public static StackFramePropertyState ReadValueIsEnd;
    public static StackFramePropertyState TryRead;
}
internal static class System.Text.Json.ThrowHelper : object {
    public static string ExceptionSourceValueToRethrowAsJsonException;
    [DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(UInt32 capacity);
    [DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string parameterName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_ArrayIndexNegative(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_JsonConverterFactory_TypeNotSupported(Type typeToConvert);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ArrayTooSmall(string paramName);
    private static ArgumentException GetArgumentException(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message);
    public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DestinationTooShort();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueTooLarge(long tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueNotSupported();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NeedLargerSpan();
    [DoesNotReturnAttribute]
public static void ThrowPropertyNameTooLargeArgumentException(int length);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<byte> propertyName, int currentDepth, int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(int currentDepth, int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(string message);
    private static InvalidOperationException GetInvalidOperationException(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth);
    private static InvalidOperationException GetInvalidOperationException(int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<char> propertyName, int currentDepth, int maxDepth);
    public static InvalidOperationException GetInvalidOperationException_ExpectedArray(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedObject(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedNumber(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedString(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedPropertyName(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedComment(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSkipOnPartial();
    private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType);
    private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
internal static void ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType);
    [DoesNotReturnAttribute]
public static void ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    public static JsonException GetJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    private static bool IsPrintable(byte value);
    internal static string GetPrintableString(byte value);
    private static string GetResourceString(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, string characters);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidCommentValue();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadIncompleteUTF16();
    public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException);
    public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException);
    public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException);
    public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException(UInt32 capacity);
    private static string GetResourceString(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowFormatException();
    public static void ThrowFormatException(NumericType numericType);
    [DoesNotReturnAttribute]
public static void ThrowFormatException(DataType dataType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedChar(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowObjectDisposedException_Utf8JsonWriter();
    [DoesNotReturnAttribute]
public static void ThrowObjectDisposedException_JsonDocument();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_NodeValueNotAllowed(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DuplicateKey(string paramName, string propertyName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeAlreadyHasParent();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeCycleDetected();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray();
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CollectionIsReadOnly();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeWrongType(string typeName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeParentWrongType(string typeName);
    public static NotSupportedException GetNotSupportedException_CollectionIsReadOnly();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DeserializeWrongType(Type type, object value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_SerializerDoesNotSupportComments(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType, JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPopulateNotSupportedByConverter(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyMustHaveAGetter(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyValueTypeMustHaveASetter(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReadOnlyMember(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReferenceHandling();
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors();
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializerCycleDetected(int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowJsonException(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_CannotSerializeInvalidType(string paramName, Type typeToConvert, Type declaringType, string propertyName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ResolverTypeNotCompatible(Type requestedType, Type actualType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonSerializerOptionsNoTypeInfoResolverSpecified();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonSerializerIsReflectionDisabled();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerOptionsReadOnly(JsonSerializerContext context);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DefaultTypeInfoResolverImmutable();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeInfoResolverChainImmutable();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeInfoImmutable();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidChainedResolver();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, string propertyName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameNull(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_JsonRequiredPropertyMissing(JsonTypeInfo parent, BitArray requiredPropertiesSet);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(Type converterType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type parentType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(string propertyName, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonIncludeOnInaccessibleProperty(string memberName, Type declaringType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(string clrPropertyName, Type propertyDeclaringType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(Type runtimePropertyType, JsonConverter jsonConverter);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(JsonTypeInfoKind kind);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CreateObjectConverterNotCompatible(Type type);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, JsonReaderException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, Utf8JsonReader& reader, Exception ex);
    public static void AddJsonExceptionInformation(ReadStack& state, Utf8JsonReader& reader, JsonException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(WriteStack& state, Exception ex);
    public static void AddJsonExceptionInformation(WriteStack& state, JsonException ex);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExtensionDataConflictsWithUnmappedMemberHandling(Type classType, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(WriteStack& state, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceNotFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataUnexpectedProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_UnmappedJsonProperty(Type type, string unmappedPropertyName);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataStandaloneValuesProperty(ReadStack& state, ReadOnlySpan`1<byte> propertyName);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan`1<byte> propertyName, ReadStack& state, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateIdFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateTypeProperty();
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ReadStack& state, Type propertyType, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(ReadStack& state, Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(JsonPropertyInfo propertyInfo);
    [DoesNotReturnAttribute]
internal static void ThrowUnexpectedMetadataException(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver);
    public static NotSupportedException GetNotSupportedException_AmbiguousMetadataForType(Type type, Type match1, Type match2);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ConstructorContainsNullParameterNames(Type declaringType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver);
    public static Exception GetInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type);
    [DoesNotReturnAttribute]
public static void ThrowMissingMemberException_MissingFSharpCoreMember(string missingFsharpCoreMember);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(Type derivedType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(Type derivedType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_RuntimeTypeNotSupported(Type baseType, Type runtimeType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(Type baseType, Type runtimeType, Type derivedType1, Type derivedType2);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(Type baseType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DerivedTypeNotSupported(Type baseType, Type derivedType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(Type baseType, Type derivedType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(Type baseType, object typeDiscriminator);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(Type baseType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidEnumTypeWithSpecialChar(Type enumType, string enumName);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_UnrecognizedTypeDiscriminator(object typeDiscriminator);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo(string parameterName);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonReader : ValueType {
    private ReadOnlySpan`1<byte> _buffer;
    private bool _isFinalBlock;
    private bool _isInputSequence;
    private long _lineNumber;
    private long _bytePositionInLine;
    private int _consumed;
    private bool _inObject;
    private bool _isNotPrimitive;
    private JsonTokenType _tokenType;
    private JsonTokenType _previousTokenType;
    private JsonReaderOptions _readerOptions;
    private BitStack _bitStack;
    private long _totalConsumed;
    private bool _isLastSegment;
    private bool _isMultiSegment;
    private bool _trailingCommaBeforeComment;
    private SequencePosition _nextPosition;
    private SequencePosition _currentPosition;
    private ReadOnlySequence`1<byte> _sequence;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<byte> <ValueSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TokenStartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueIsEscaped>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <ValueSequence>k__BackingField;
    private bool IsLastSpan { get; }
    internal ReadOnlySequence`1<byte> OriginalSequence { get; }
    internal ReadOnlySpan`1<byte> OriginalSpan { get; }
    internal int ValueLength { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; private set; }
    public long BytesConsumed { get; }
    public long TokenStartIndex { get; private set; }
    public int CurrentDepth { get; }
    internal bool IsInArray { get; }
    public JsonTokenType TokenType { get; }
    public bool HasValueSequence { get; private set; }
    public bool ValueIsEscaped { get; private set; }
    public bool IsFinalBlock { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; private set; }
    public SequencePosition Position { get; }
    public JsonReaderState CurrentState { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [NullableAttribute("1")]
private string DebugTokenType { get; }
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    private bool get_IsLastSpan();
    internal ReadOnlySequence`1<byte> get_OriginalSequence();
    internal ReadOnlySpan`1<byte> get_OriginalSpan();
    [IsReadOnlyAttribute]
internal int get_ValueLength();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [CompilerGeneratedAttribute]
private void set_ValueSpan(ReadOnlySpan`1<byte> value);
    [IsReadOnlyAttribute]
public long get_BytesConsumed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TokenStartIndex();
    [CompilerGeneratedAttribute]
private void set_TokenStartIndex(long value);
    [IsReadOnlyAttribute]
public int get_CurrentDepth();
    internal bool get_IsInArray();
    [IsReadOnlyAttribute]
public JsonTokenType get_TokenType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValueSequence();
    [CompilerGeneratedAttribute]
private void set_HasValueSequence(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ValueIsEscaped();
    [CompilerGeneratedAttribute]
private void set_ValueIsEscaped(bool value);
    [IsReadOnlyAttribute]
public bool get_IsFinalBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [CompilerGeneratedAttribute]
private void set_ValueSequence(ReadOnlySequence`1<byte> value);
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [IsReadOnlyAttribute]
public JsonReaderState get_CurrentState();
    public bool Read();
    public void Skip();
    private void SkipHelper();
    public bool TrySkip();
    private bool TrySkipHelper();
    [IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public bool ValueTextEquals(string text);
    [IsReadOnlyAttribute]
private bool TextEqualsHelper(ReadOnlySpan`1<byte> otherUtf8Text);
    [IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    [IsReadOnlyAttribute]
private bool CompareToSequence(ReadOnlySpan`1<byte> other);
    [IsReadOnlyAttribute]
private bool UnescapeAndCompare(ReadOnlySpan`1<byte> other);
    [IsReadOnlyAttribute]
private bool UnescapeSequenceAndCompare(ReadOnlySpan`1<byte> other);
    private static bool IsTokenTypeString(JsonTokenType tokenType);
    [IsReadOnlyAttribute]
private bool MatchNotPossible(int charTextLength);
    [IsReadOnlyAttribute]
private bool MatchNotPossibleSequence(int charTextLength);
    private void StartObject();
    private void EndObject();
    private void StartArray();
    private void EndArray();
    private void UpdateBitStackOnEndToken();
    private bool ReadSingleSegment();
    private bool HasMoreData();
    private bool HasMoreData(ExceptionResource resource);
    private bool ReadFirstToken(byte first);
    private void SkipWhiteSpace();
    private bool ConsumeValue(byte marker);
    private bool ConsumeLiteral(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteral(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private void ThrowInvalidLiteral(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumber();
    private bool ConsumePropertyName();
    private bool ConsumeString();
    private bool ConsumeStringAndValidate(ReadOnlySpan`1<byte> data, int idx);
    private bool ValidateHexDigits(ReadOnlySpan`1<byte> data, int idx);
    private bool TryGetNumber(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSign(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeZero(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeIntegerDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeSign(ReadOnlySpan`1& data, Int32& i);
    private bool ConsumeNextTokenOrRollback(byte marker);
    private ConsumeTokenResult ConsumeNextToken(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken();
    private bool SkipAllComments(Byte& marker);
    private bool SkipAllComments(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker);
    private bool SkipComment();
    private bool SkipSingleLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private int FindLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private void ThrowOnDangerousLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private bool SkipMultiLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private bool ConsumeComment();
    private bool ConsumeSingleLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private bool ConsumeMultiLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private string get_DebuggerDisplay();
    private string get_DebugTokenType();
    private ReadOnlySpan`1<byte> GetUnescapedSpan();
    private bool ReadMultiSegment();
    private bool ValidateStateAtEndOfData();
    private bool HasMoreDataMultiSegment();
    private bool HasMoreDataMultiSegment(ExceptionResource resource);
    private bool GetNextSpan();
    private bool ReadFirstTokenMultiSegment(byte first);
    private void SkipWhiteSpaceMultiSegment();
    private bool ConsumeValueMultiSegment(byte marker);
    private bool ConsumeLiteralMultiSegment(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteralMultiSegment(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal, Int32& consumed);
    private static int FindMismatch(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumberMultiSegment();
    private bool ConsumePropertyNameMultiSegment();
    private bool ConsumeStringMultiSegment();
    private bool ConsumeStringNextSegment();
    private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan`1<byte> data, int idx);
    private void RollBackState(PartialStateForRollback& state, bool isError);
    private bool TryGetNumberMultiSegment(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeZeroMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
    private bool SkipAllCommentsMultiSegment(Byte& marker);
    private bool SkipAllCommentsMultiSegment(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker);
    private bool SkipOrConsumeCommentMultiSegmentWithRollback();
    private bool SkipCommentMultiSegment(Int32& tailBytesToIgnore);
    private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& tailBytesToSkip);
    private int FindLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer);
    private PartialStateForRollback CaptureState();
    [NullableContextAttribute("2")]
public string GetString();
    [IsReadOnlyAttribute]
public int CopyString(Span`1<byte> utf8Destination);
    [IsReadOnlyAttribute]
internal int CopyValue(Span`1<byte> utf8Destination);
    [IsReadOnlyAttribute]
public int CopyString(Span`1<char> destination);
    [IsReadOnlyAttribute]
internal int CopyValue(Span`1<char> destination);
    [IsReadOnlyAttribute]
private bool TryCopyEscapedString(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public string GetComment();
    public bool GetBoolean();
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    public byte GetByte();
    internal byte GetByteWithQuotes();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    internal sbyte GetSByteWithQuotes();
    public short GetInt16();
    internal short GetInt16WithQuotes();
    public int GetInt32();
    internal int GetInt32WithQuotes();
    public long GetInt64();
    internal long GetInt64WithQuotes();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    internal ushort GetUInt16WithQuotes();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    internal UInt32 GetUInt32WithQuotes();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    internal ulong GetUInt64WithQuotes();
    public float GetSingle();
    internal float GetSingleWithQuotes();
    internal float GetSingleFloatingPointConstant();
    public double GetDouble();
    internal double GetDoubleWithQuotes();
    internal double GetDoubleFloatingPointConstant();
    public decimal GetDecimal();
    internal decimal GetDecimalWithQuotes();
    public DateTime GetDateTime();
    internal DateTime GetDateTimeNoValidation();
    public DateTimeOffset GetDateTimeOffset();
    internal DateTimeOffset GetDateTimeOffsetNoValidation();
    public Guid GetGuid();
    internal Guid GetGuidNoValidation();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetByte(Byte& value);
    internal static bool TryGetByteCore(Byte& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    internal static bool TryGetSByteCore(SByte& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt16(Int16& value);
    internal static bool TryGetInt16Core(Int16& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt32(Int32& value);
    internal static bool TryGetInt32Core(Int32& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt64(Int64& value);
    internal static bool TryGetInt64Core(Int64& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    internal static bool TryGetUInt16Core(UInt16& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    internal static bool TryGetUInt32Core(UInt32& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    internal static bool TryGetUInt64Core(UInt64& value, ReadOnlySpan`1<byte> span);
    public bool TryGetSingle(Single& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetDecimal(Decimal& value);
    internal static bool TryGetDecimalCore(Decimal& value, ReadOnlySpan`1<byte> span);
    public bool TryGetDateTime(DateTime& value);
    internal bool TryGetDateTimeCore(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    internal bool TryGetDateTimeOffsetCore(DateTimeOffset& value);
    public bool TryGetGuid(Guid& value);
    internal bool TryGetGuidCore(Guid& value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonWriter : object {
    private static int s_newLineLength;
    private static int DefaultGrowthSize;
    private static int InitialGrowthSize;
    private IBufferWriter`1<byte> _output;
    private Stream _stream;
    private ArrayBufferWriter`1<byte> _arrayBufferWriter;
    private Memory`1<byte> _memory;
    private bool _inObject;
    private bool _commentAfterNoneOrPropertyName;
    private JsonTokenType _tokenType;
    private BitStack _bitStack;
    private int _currentDepth;
    private JsonWriterOptions _options;
    [CompilerGeneratedAttribute]
private int <BytesPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCommitted>k__BackingField;
    private static Char[] s_singleLineCommentDelimiter;
    public int BytesPending { get; private set; }
    public long BytesCommitted { get; private set; }
    public JsonWriterOptions Options { get; }
    private int Indentation { get; }
    internal JsonTokenType TokenType { get; }
    public int CurrentDepth { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadOnlySpan`1<byte> SingleLineCommentDelimiterUtf8 { get; }
    [NullableContextAttribute("1")]
public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    [NullableContextAttribute("1")]
public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    private static Utf8JsonWriter();
    [CompilerGeneratedAttribute]
public int get_BytesPending();
    [CompilerGeneratedAttribute]
private void set_BytesPending(int value);
    [CompilerGeneratedAttribute]
public long get_BytesCommitted();
    [CompilerGeneratedAttribute]
private void set_BytesCommitted(long value);
    public JsonWriterOptions get_Options();
    private int get_Indentation();
    internal JsonTokenType get_TokenType();
    public int get_CurrentDepth();
    public void Reset();
    [NullableContextAttribute("1")]
public void Reset(Stream utf8Json);
    [NullableContextAttribute("1")]
public void Reset(IBufferWriter`1<byte> bufferWriter);
    internal void ResetAllStateForCacheReuse();
    internal void Reset(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    internal static Utf8JsonWriter CreateEmptyInstanceForCaching();
    private void ResetHelper();
    private void CheckNotDisposed();
    public void Flush();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<DisposeAsync>d__42")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<FlushAsync>d__43")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void WriteStartArray();
    public void WriteStartObject();
    private void WriteStart(byte token);
    private void WriteStartMinimized(byte token);
    private void WriteStartSlow(byte token);
    private void ValidateStart();
    private void WriteStartIndented(byte token);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    private void WriteStartHelper(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStartEscape(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, byte token, int firstEscapeIndexProp);
    [NullableContextAttribute("1")]
public void WriteStartArray(string propertyName);
    [NullableContextAttribute("1")]
public void WriteStartObject(string propertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    private void WriteStartEscape(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<char> propertyName, byte token, int firstEscapeIndexProp);
    public void WriteEndArray();
    public void WriteEndObject();
    private void WriteEnd(byte token);
    private void WriteEndMinimized(byte token);
    private void WriteEndSlow(byte token);
    private void ValidateEnd(byte token);
    private void WriteEndIndented(byte token);
    private void WriteNewLine(Span`1<byte> output);
    private void UpdateBitStackOnStart(byte token);
    private void Grow(int requiredSize);
    private void FirstCallToGetMemory(int requiredSize);
    private void SetFlagToAddListSeparatorBeforeNextItem();
    private string get_DebuggerDisplay();
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64ByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    internal void WritePropertyName(DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    internal void WritePropertyName(DateTimeOffset value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    internal void WritePropertyName(decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    internal void WritePropertyName(double value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    internal void WritePropertyName(float value);
    internal void WriteNumber(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    internal void WritePropertyName(Guid value);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<char> propertyName);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<byte> utf8PropertyName);
    private void ValidateDepth();
    private void ValidateWritingProperty();
    private void ValidateWritingProperty(byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void TranscodeAndWrite(ReadOnlySpan`1<char> escapedPropertyName, Span`1<byte> output);
    public void WriteNull(JsonEncodedText propertyName);
    internal void WriteNullSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteLiteralHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("1")]
public void WriteNull(string propertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    [NullableContextAttribute("1")]
public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    private void WriteLiteralEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralSection(ReadOnlySpan`1<byte> escapedPropertyNameSection, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    internal void WritePropertyName(bool value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    internal void WritePropertyName(int value);
    internal void WritePropertyName(long value);
    public void WritePropertyName(JsonEncodedText propertyName);
    internal void WritePropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WritePropertyNameHelper(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public void WritePropertyName(string propertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WritePropertyNameUnescaped(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    private void WriteStringPropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, JsonEncodedText value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("2")]
public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndex);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    internal void WritePropertyName(UInt32 value);
    internal void WritePropertyName(ulong value);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> get_SingleLineCommentDelimiterUtf8();
    [NullableContextAttribute("1")]
public void WriteCommentValue(string value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    private void WriteCommentByOptions(ReadOnlySpan`1<char> value);
    private void WriteCommentMinimized(ReadOnlySpan`1<char> value);
    private void WriteCommentIndented(ReadOnlySpan`1<char> value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(DateTime value);
    private void WriteStringValueMinimized(DateTime value);
    private void WriteStringValueIndented(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    private void WriteStringValueMinimized(DateTimeOffset value);
    private void WriteStringValueIndented(DateTimeOffset value);
    public void WriteNumberValue(decimal value);
    private void WriteNumberValueMinimized(decimal value);
    private void WriteNumberValueIndented(decimal value);
    internal void WriteNumberValueAsString(decimal value);
    public void WriteNumberValue(double value);
    private void WriteNumberValueMinimized(double value);
    private void WriteNumberValueIndented(double value);
    private static bool TryFormatDouble(double value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(double value);
    internal void WriteFloatingPointConstant(double value);
    public void WriteNumberValue(float value);
    private void WriteNumberValueMinimized(float value);
    private void WriteNumberValueIndented(float value);
    private static bool TryFormatSingle(float value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(float value);
    internal void WriteFloatingPointConstant(float value);
    internal void WriteNumberValue(ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberValueMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteNumberValueIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(Guid value);
    private void WriteStringValueMinimized(Guid value);
    private void WriteStringValueIndented(Guid value);
    private void ValidateWritingValue();
    private void Base64EncodeAndWrite(ReadOnlySpan`1<byte> bytes, Span`1<byte> output, int encodingLength);
    public void WriteNullValue();
    public void WriteBooleanValue(bool value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("1")]
public void WriteRawValue(string json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySequence`1<byte> utf8Json, bool skipInputValidation);
    private void TranscodeAndWriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    private void WriteRawValueCore(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    private void WriteNumberValueMinimized(long value);
    private void WriteNumberValueIndented(long value);
    internal void WriteNumberValueAsString(long value);
    public void WriteStringValue(JsonEncodedText value);
    [NullableContextAttribute("2")]
public void WriteStringValue(string value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<char> value, int firstEscapeIndexVal);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal);
    internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan`1<byte> utf8Value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    private void WriteNumberValueMinimized(ulong value);
    private void WriteNumberValueIndented(ulong value);
    internal void WriteNumberValueAsString(ulong value);
}
internal static class System.Text.Json.Utf8JsonWriterCache : object {
    [ThreadStaticAttribute]
private static ThreadLocalState t_threadLocalState;
    public static Utf8JsonWriter RentWriterAndBuffer(JsonSerializerOptions options, PooledByteBufferWriter& bufferWriter);
    public static Utf8JsonWriter RentWriter(JsonSerializerOptions options, PooledByteBufferWriter bufferWriter);
    public static void ReturnWriterAndBuffer(Utf8JsonWriter writer, PooledByteBufferWriter bufferWriter);
    public static void ReturnWriter(Utf8JsonWriter writer);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.WriteStack : ValueType {
    public WriteStackFrame Current;
    private WriteStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    private byte _indexOffset;
    public CancellationToken CancellationToken;
    public bool SuppressFlush;
    public Task PendingTask;
    public List`1<IAsyncDisposable> CompletedAsyncDisposables;
    public int FlushThreshold;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public bool SupportAsync;
    public string NewReferenceId;
    public object PolymorphicTypeDiscriminator;
    public PolymorphicTypeResolver PolymorphicTypeResolver;
    public int CurrentDepth { get; }
    public WriteStackFrame& Parent { get; }
    public bool IsContinuation { get; }
    public bool CurrentContainsMetadata { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [IsReadOnlyAttribute]
public int get_CurrentDepth();
    [IsReadOnlyAttribute]
public WriteStackFrame& get_Parent();
    [IsReadOnlyAttribute]
public bool get_IsContinuation();
    [IsReadOnlyAttribute]
public bool get_CurrentContainsMetadata();
    private void EnsurePushCapacity();
    internal void Initialize(JsonTypeInfo jsonTypeInfo, object rootValueBoxed, bool supportContinuation, bool supportAsync);
    [IsReadOnlyAttribute]
public JsonTypeInfo PeekNestedJsonTypeInfo();
    public void Push();
    public void Pop(bool success);
    public void AddCompletedAsyncDisposable(IAsyncDisposable asyncDisposable);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposeCompletedAsyncDisposables>d__30")]
public ValueTask DisposeCompletedAsyncDisposables();
    public void DisposePendingDisposablesOnException();
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposePendingDisposablesOnExceptionAsync>d__32")]
public ValueTask DisposePendingDisposablesOnExceptionAsync();
    public string PropertyPath();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
internal static void <DisposePendingDisposablesOnException>g__DisposeFrame|31_0(IEnumerator collectionEnumerator, Exception& exception);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<<DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|32_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Exception> <DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|32_0(IEnumerator collectionEnumerator, IAsyncDisposable asyncDisposable, Exception exception);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendStackFrame|33_0(StringBuilder sb, WriteStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendPropertyName|33_1(StringBuilder sb, string propertyName);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.WriteStackFrame : ValueType {
    public IEnumerator CollectionEnumerator;
    public IAsyncDisposable AsyncDisposable;
    public bool AsyncEnumeratorIsPendingCompletion;
    public JsonPropertyInfo JsonPropertyInfo;
    public bool IsWritingExtensionDataProperty;
    public JsonTypeInfo JsonTypeInfo;
    public int OriginalDepth;
    public bool ProcessedStartToken;
    public bool ProcessedEndToken;
    public StackFramePropertyState PropertyState;
    public int EnumeratorIndex;
    public string JsonPropertyNameAsString;
    public MetadataPropertyName MetadataPropertyName;
    public PolymorphicSerializationState PolymorphicSerializationState;
    public JsonTypeInfo PolymorphicTypeInfo;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public bool IsPushedReferenceForCycleDetection;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public void EndCollectionElement();
    public void EndDictionaryEntry();
    public void EndProperty();
    [IsReadOnlyAttribute]
public JsonTypeInfo GetNestedJsonTypeInfo();
    public JsonTypeInfo InitializePolymorphicReEntry(Type runtimeType, JsonSerializerOptions options);
    public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo);
    public JsonConverter ResumePolymorphicReEntry();
    public void ExitPolymorphicConverter(bool success);
    [IsReadOnlyAttribute]
private string get_DebuggerDisplay();
}
