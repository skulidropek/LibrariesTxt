public class Kusto.Cloud.Platform.CodeGeneration.EnumGenerator : object {
    private static Action s_emptyAction;
    private IEnumerable`1<string> m_usings;
    private IEnumerable`1<GeneratedEnum> m_enums;
    private CodeGenerator m_generator;
    private Dictionary`2<string, GeneratedEnum> m_mapEnums;
    private EnumGenerator(string namespace, IEnumerable`1<string> usings, IEnumerable`1<GeneratedEnum> enums);
    private static EnumGenerator();
    public static string Generate(string namespace, IEnumerable`1<string> usings, IEnumerable`1<GeneratedEnum> enums);
    private void Prepare();
    private void WriteFileStart();
    private void WriteFileEnd();
    private string GetText();
    private void WriteEnums(IEnumerable`1<GeneratedEnum> enums);
    private void WriteEnum(GeneratedEnum e);
    private void WriteEnumImpl(GeneratedEnum e);
    private void WriteEnumImpl2(GeneratedEnum e);
    private bool IsFieldValueSpecified(GeneratedEnumField field);
    private string GetFieldValueAsStringLiteral(GeneratedEnumField field, Type underlyingType);
    private void WriteFastToString(GeneratedEnum e);
    private void ForEachFieldSkippingDuplicateValues(GeneratedEnum e, Action`2<GeneratedEnum, GeneratedEnumField> action);
    private void WriteToAlternativeString(GeneratedEnum e);
    private void WriteFastGetHashCode(GeneratedEnum e);
    private void WriteFastIsDefined(GeneratedEnum e);
    private void WriteFastHasFlag(GeneratedEnum e);
    private void WriteFastParse(GeneratedEnum e);
    private void WriteFastTryParse(GeneratedEnum e);
    private static string GenerateAlternativeParseCases(GeneratedEnum e, GeneratedEnumField field, bool toLower);
    private void WriteFastGetDescription(GeneratedEnum e);
    private void WriteFastGetFlags(GeneratedEnum e);
    private int CountBits(long n);
}
public class Kusto.Cloud.Platform.CodeGeneration.ExceptionClass : object {
    public string Name;
    public string BaseClass;
    public string Doc;
    public string Message;
    public ExceptionField[] Fields;
    public ExceptionField[] BaseFields;
    public ExceptionField[] CloudPlatformExceptionFields;
    public ExceptionClassOptions Options;
    public Nullable`1<int> FailureCode;
    public string FailureSubCode;
    public Nullable`1<bool> IsPermanent;
    public Nullable`1<int> HResult;
    public string CallStackMarker;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.CodeGeneration.ExceptionClassOptions : Enum {
    public int value__;
    public static ExceptionClassOptions OmitToString;
    public static ExceptionClassOptions OmitConstruct_Debugger;
    public static ExceptionClassOptions OmitConstruct_Trace;
    public static ExceptionClassOptions BaseNotGeneratedByTemplate;
    public static ExceptionClassOptions Abstract;
    public static ExceptionClassOptions OmitExceptionCreationContext;
    public static ExceptionClassOptions BaseConstructorMandatesBaseFields;
    public static ExceptionClassOptions OmitConstructorWithBaseFieldsAndInnerException;
    public static ExceptionClassOptions OmitConstructorWithAllFieldsAndInnerException;
    public static ExceptionClassOptions OmitConstructorWithSerializationInfo;
    public static ExceptionClassOptions OmitAllConstructorsWithBaseFields;
    public static ExceptionClassOptions InvokeConstructFinal;
    public static ExceptionClassOptions OmitMessage;
    public static ExceptionClassOptions TraceExceptionFromConstruct;
    public static ExceptionClassOptions OmitConstruct_IsPermanent;
    public static ExceptionClassOptions OmitAllConstructors;
}
public class Kusto.Cloud.Platform.CodeGeneration.ExceptionField : object {
    public string Name;
    public string Type;
    public string Doc;
    public ExceptionFieldOptions Options;
    public string DefaultValue;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.CodeGeneration.ExceptionFieldOptions : Enum {
    public int value__;
    public static ExceptionFieldOptions None;
    public static ExceptionFieldOptions NonSerialized;
    public static ExceptionFieldOptions OmitFromToString;
    public static ExceptionFieldOptions CollectionField;
    public static ExceptionFieldOptions ToStringX;
    public static ExceptionFieldOptions Obfuscate;
    public static ExceptionFieldOptions AddToExceptionData;
}
public class Kusto.Cloud.Platform.CodeGeneration.ExceptionGenerator : object {
    private static Action s_emptyAction;
    private ListString m_usingNamespaces;
    private string m_namespace;
    private string m_traceSource;
    private string m_obfuscator;
    private ListExceptionClass m_exceptionClasses;
    private CodeGenerator m_writer;
    private static ExceptionGenerator();
    public static string Generate(IEnumerable`1<string> usingNamespaces, string namespace, string traceSource, string obfuscator, IEnumerable`1<ExceptionClass> exceptionClasses);
    private void WriteFileStart();
    private void WriteFileEnd();
    private string GetText();
    private void WriteClasses();
    private void WriteClass(ExceptionClass ec);
    private void WriteFields(ExceptionClass ec);
    private void WriteImplementationFields(ExceptionClass ec);
    private void WriteTypeProperties(ExceptionClass ec);
    private void WriteConstructors(ExceptionClass ec);
    private void WriteMessage(ExceptionClass ec);
    private void WriteToString(ExceptionClass ec);
    private void WriteGetObjectData(ExceptionClass ec);
    private bool BaseGeneratedByTemplate(ExceptionClass ec);
    private string VirtualOrOverride(ExceptionClass ec);
    private void WriteAlreadyTracedProperty(ExceptionClass ec);
    private void WriteWritePropetiesTo(ExceptionClass ec);
    private void WriteText(string text);
    private void WriteParamDocString(string name, string doc);
    private void WriteFieldsDocStrings(IEnumerable`1<ExceptionField> ef);
    private string GetFieldsParamsList(IEnumerable`1<ExceptionField> ef);
    private string GetFieldsParamsListNoType(IEnumerable`1<ExceptionField> ef);
    private string GetFieldsParamsNamedList(IEnumerable`1<ExceptionField> ef);
    private void WriteFieldsAssignmentList(IEnumerable`1<ExceptionField> ef);
    private static string LowerFirst(string name);
    private static string UpperFirst(string name);
    private static bool IsInteger(string fieldType);
    private static bool IsString(string fieldType);
    public static Nullable`1<bool> IsValueType(string type, bool requireFullyQualifiedTypeName);
    private static bool IsDateTime(string fieldType);
    private static bool TryFindField(ExceptionClass ec, string fieldName, ExceptionField& exceptionField);
    private static bool TryFindField(string fieldName, ExceptionField[] fields, ExceptionField& exceptionField);
    private static string RemovePrefixIfExists(string prefix, string input);
    private string CreateFieldToStringString(ExceptionClass ec, string fieldName);
    private string FormatError(string text);
    private bool IsWellKnownFieldReference(string fieldName, String& fieldToStringExpression);
    private string CreateFieldToStringString(ExceptionField field);
}
public class Kusto.Cloud.Platform.CodeGeneration.ExceptionReferenceField : ExceptionField {
}
public class Kusto.Cloud.Platform.CodeGeneration.ExceptionValueField : ExceptionField {
}
[DebuggerDisplayAttribute("GeneratedEnum: {Name} ({Namespace})")]
public class Kusto.Cloud.Platform.CodeGeneration.GeneratedEnum : object {
    public string Name;
    public string ExtendedName;
    public string Namespace;
    public string Doc;
    public IEnumerable`1<GeneratedEnumField> Fields;
    public GeneratedEnumOptions Options;
    public Type UnderlyingType;
    public string AlternativeFieldNameFormat;
    public bool GenerateAlternativeFieldNames { get; }
    public bool get_GenerateAlternativeFieldNames();
    public string GetAlternativeFieldName(GeneratedEnumField field);
}
public class Kusto.Cloud.Platform.CodeGeneration.GeneratedEnumField : object {
    public string Name;
    public string AlternativeName;
    public string Doc;
    public string ValueAsString;
    public Nullable`1<long> Value;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.CodeGeneration.GeneratedEnumOptions : Enum {
    public int value__;
    public static GeneratedEnumOptions None;
    public static GeneratedEnumOptions IsFlags;
    public static GeneratedEnumOptions IsInternal;
    public static GeneratedEnumOptions OmitEnumType;
    public static GeneratedEnumOptions IsDataContract;
    public static GeneratedEnumOptions AddJsonConverterAttribute;
}
public abstract class Kusto.Cloud.Platform.Collections.BinaryHeap`2 : object {
    protected List`1<Tuple`2<TPriority, TValue>> m_items;
    protected IComparer`1<TPriority> m_comparer;
    public int Count { get; }
    public BinaryHeap`2(IComparer`1<TPriority> comparer);
    public BinaryHeap`2(BinaryHeap`2<TPriority, TValue> heapToCopy);
    protected abstract virtual int Compare(TPriority p1, TPriority p2);
    public int get_Count();
    public abstract virtual BinaryHeap`2<TPriority, TValue> Clone();
    public IEnumerable`1<Tuple`2<TPriority, TValue>> Clear();
    public void Insert(TPriority key, TValue value);
    public void Insert(Tuple`2<TPriority, TValue> entry);
    public Tuple`2<TPriority, TValue> Peek();
    public Tuple`2<TPriority, TValue> Pop();
    public Tuple`2<TPriority, TValue> Update(TValue value, TPriority newPriority);
    public Tuple`2<TPriority, TValue> Update(Func`2<TValue, bool> predicate, TPriority newPriority);
    public Tuple`2<TPriority, TValue> Remove(TValue value);
    public Tuple`2<TPriority, TValue> Remove(Func`2<TValue, bool> predicate);
    public sealed virtual IEnumerator`1<Tuple`2<TPriority, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    private int GetIndex(Func`2<TValue, bool> predicate);
    private void HeapifyDown(int startIndex);
    private void HeapifyUp(int startIndex);
}
public class Kusto.Cloud.Platform.Collections.ConcurrentPriorityQueue`1 : ConcurrentPriorityQueue`2<TValue, TValue> {
    public ConcurrentPriorityQueue`1(ConcurrentQueueType priorityType, IComparer`1<TValue> comparer);
    public virtual void Enqueue(TValue item);
    public virtual bool TryDequeue(TValue& item);
    public virtual TValue Dequeue();
    public virtual bool TryPeek(TValue& item);
    public void Enqueue(Tuple`2<TValue, TValue> item);
    public void Enqueue(TValue priority, TValue value);
}
[DebuggerDisplayAttribute("Count={Count}")]
public class Kusto.Cloud.Platform.Collections.ConcurrentPriorityQueue`2 : object {
    private object m_syncLock;
    private BinaryHeap`2<TPriority, TValue> m_heap;
    private bool m_isEnqueueAllowed;
    public bool EnqueueAllowed { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentPriorityQueue`2(ConcurrentQueueType priorityType, IComparer`1<TPriority> comparer);
    public ConcurrentPriorityQueue`2(IEnumerable`1<Tuple`2<TPriority, TValue>> collection);
    public bool get_EnqueueAllowed();
    public virtual void Enqueue(TPriority priority, TValue value);
    public virtual void Enqueue(Tuple`2<TPriority, TValue> item);
    public void CloseForEnqueuing();
    public virtual bool TryDequeue(Tuple`2& result);
    public virtual Tuple`2<TPriority, TValue> Dequeue();
    public bool TryPeek(Tuple`2& result);
    public void Clear();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Tuple`2[] array, int index);
    public sealed virtual Tuple`2[] ToArray();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<System.Tuple<TPriority,TValue>>.TryAdd(Tuple`2<TPriority, TValue> item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<System.Tuple<TPriority,TValue>>.TryTake(Tuple`2& item);
    public sealed virtual IEnumerator`1<Tuple`2<TPriority, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public enum Kusto.Cloud.Platform.Collections.ConcurrentQueueChangedAction : Enum {
    public int value__;
    public static ConcurrentQueueChangedAction Enqueue;
    public static ConcurrentQueueChangedAction Dequeue;
    public static ConcurrentQueueChangedAction Peek;
    public static ConcurrentQueueChangedAction Empty;
}
public class Kusto.Cloud.Platform.Collections.ConcurrentQueueChangedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private ConcurrentQueueChangedAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private T <ChangedItem>k__BackingField;
    public ConcurrentQueueChangedAction Action { get; private set; }
    public T ChangedItem { get; private set; }
    public ConcurrentQueueChangedEventArgs`1(ConcurrentQueueChangedAction action, T changedItem);
    public ConcurrentQueueChangedEventArgs`1(ConcurrentQueueChangedAction action);
    [CompilerGeneratedAttribute]
public ConcurrentQueueChangedAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(ConcurrentQueueChangedAction value);
    [CompilerGeneratedAttribute]
public T get_ChangedItem();
    [CompilerGeneratedAttribute]
private void set_ChangedItem(T value);
}
public class Kusto.Cloud.Platform.Collections.ConcurrentQueueChangedEventHandler`1 : MulticastDelegate {
    public ConcurrentQueueChangedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, ConcurrentQueueChangedEventArgs`1<T> args);
    public virtual IAsyncResult BeginInvoke(object sender, ConcurrentQueueChangedEventArgs`1<T> args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Kusto.Cloud.Platform.Collections.ConcurrentQueueType : Enum {
    public int value__;
    public static ConcurrentQueueType MinQueue;
    public static ConcurrentQueueType MaxQueue;
}
public class Kusto.Cloud.Platform.Collections.MaxBinaryHeap`2 : BinaryHeap`2<TPriority, TValue> {
    public MaxBinaryHeap`2(IComparer`1<TPriority> comparer);
    public MaxBinaryHeap`2(MaxBinaryHeap`2<TPriority, TValue> heapToCopy);
    protected virtual int Compare(TPriority p1, TPriority p2);
    public virtual BinaryHeap`2<TPriority, TValue> Clone();
}
public class Kusto.Cloud.Platform.Collections.MinBinaryHeap`2 : BinaryHeap`2<TPriority, TValue> {
    public MinBinaryHeap`2(IComparer`1<TPriority> comparer);
    public MinBinaryHeap`2(MinBinaryHeap`2<TPriority, TValue> heapToCopy);
    protected virtual int Compare(TPriority p1, TPriority p2);
    public virtual BinaryHeap`2<TPriority, TValue> Clone();
}
public class Kusto.Cloud.Platform.Collections.ObservableConcurrentQueue`1 : ConcurrentQueue`1<T> {
    [CompilerGeneratedAttribute]
private ConcurrentQueueChangedEventHandler`1<T> ContentChanged;
    [CompilerGeneratedAttribute]
public void add_ContentChanged(ConcurrentQueueChangedEventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ContentChanged(ConcurrentQueueChangedEventHandler`1<T> value);
    public void Enqueue(T item);
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
    private void OnContentChanged(ConcurrentQueueChangedEventArgs`1<T> args);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Collections.ThreadSafeDictionaryWithEviction`2 : object {
    private ReaderWriterLockSlim m_lock;
    private PeriodicNonoverlappingTimer m_evictionTimer;
    private Dictionary`2<TKey, EvictableEntry<TKey, TValue>> m_dictionary;
    private EvictionTimerActivityType<TKey, TValue> m_evictionTimerActivityType;
    private EvictionPolicy<TKey, TValue> m_evictionPolicy;
    private bool m_disposed;
    public TValue Item { get; public set; }
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public ThreadSafeDictionaryWithEviction`2(string name, EvictionPolicy<TKey, TValue> evictionPolicy, TimeSpan evictionTimerInterval);
    public sealed virtual void Dispose();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void OnEvictionTimerForTests();
    private void OnEvictionTimer(PeriodicNonoverlappingTimer timer, object context);
    protected virtual void Dispose(bool disposing);
}
public class Kusto.Cloud.Platform.Communication.BaseCommunicationParameters : object {
    [CompilerGeneratedAttribute]
private Type <ServiceContract>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServicePort>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateCallContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateClientRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateUser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateApp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceOperationBehaviorOptions <ServiceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    public Type ServiceContract { get; public set; }
    public int ServicePort { get; public set; }
    public bool PropagateCallContext { get; public set; }
    public bool PropagateClientRequestId { get; public set; }
    public bool PropagateUser { get; public set; }
    public bool PropagateApp { get; public set; }
    public bool PropagateClientVersion { get; public set; }
    public ServiceOperationBehaviorOptions ServiceOptions { get; public set; }
    public string RelativePath { get; public set; }
    public string Scheme { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceContract();
    [CompilerGeneratedAttribute]
public void set_ServiceContract(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ServicePort();
    [CompilerGeneratedAttribute]
public void set_ServicePort(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PropagateCallContext();
    [CompilerGeneratedAttribute]
public void set_PropagateCallContext(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PropagateClientRequestId();
    [CompilerGeneratedAttribute]
public void set_PropagateClientRequestId(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PropagateUser();
    [CompilerGeneratedAttribute]
public void set_PropagateUser(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PropagateApp();
    [CompilerGeneratedAttribute]
public void set_PropagateApp(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PropagateClientVersion();
    [CompilerGeneratedAttribute]
public void set_PropagateClientVersion(bool value);
    [CompilerGeneratedAttribute]
public ServiceOperationBehaviorOptions get_ServiceOptions();
    [CompilerGeneratedAttribute]
public void set_ServiceOptions(ServiceOperationBehaviorOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RelativePath();
    [CompilerGeneratedAttribute]
public void set_RelativePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Scheme();
    [CompilerGeneratedAttribute]
public void set_Scheme(string value);
}
public class Kusto.Cloud.Platform.Communication.BindingKind : object {
    public static BindingKind NetTcpBindingScheme;
    public static BindingKind NamedPipeBindingScheme;
    public static BindingKind HttpBindingScheme;
    private static Dictionary`2<string, BindingKind> s_uriSchemeToBindingKind;
    private string m_id;
    private static BindingKind();
    private BindingKind(string id, String[] schemes);
    public static BindingKind GetBindingKind(string uriScheme);
}
public class Kusto.Cloud.Platform.Communication.CallContextCustomHeader : object {
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SubActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceVerbosity <SuppressedTraceVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceVerbosity <ForcedTraceVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalTraceDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalTraceDestinationPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AdditionalTraceAsyncUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldTrackConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <KuiperJobId>k__BackingField;
    public Guid ActivityId { get; private set; }
    public Guid SubActivityId { get; private set; }
    public Guid ParentActivityId { get; private set; }
    public string ClientRequestId { get; private set; }
    public string ActivityType { get; private set; }
    public string User { get; private set; }
    public string Application { get; private set; }
    public string ClientVersion { get; private set; }
    public TraceVerbosity SuppressedTraceVerbosity { get; private set; }
    public TraceVerbosity ForcedTraceVerbosity { get; private set; }
    public string AdditionalTraceDestination { get; private set; }
    public string AdditionalTraceDestinationPrefix { get; private set; }
    public bool AdditionalTraceAsyncUpload { get; private set; }
    public bool ShouldTrackConnection { get; private set; }
    public Guid KuiperJobId { get; private set; }
    public CallContextCustomHeader(Guid activityId, Guid subActivityId, Guid parentActivityId, string clientRequestId, string activityType, string user, string application, string clientVersion, TraceVerbosity suppressedTraceVerbosity, TraceVerbosity forcedTraceVerbosity, string additionalTraceDestination, string additionalTraceDestinationPrefix, bool additionalTraceAsyncUpload, bool shouldTrackConnection, Guid kuiperJobId);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_SubActivityId();
    [CompilerGeneratedAttribute]
private void set_SubActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_ParentActivityId();
    [CompilerGeneratedAttribute]
private void set_ParentActivityId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ClientRequestId();
    [CompilerGeneratedAttribute]
private void set_ClientRequestId(string value);
    [CompilerGeneratedAttribute]
public string get_ActivityType();
    [CompilerGeneratedAttribute]
private void set_ActivityType(string value);
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
private void set_User(string value);
    [CompilerGeneratedAttribute]
public string get_Application();
    [CompilerGeneratedAttribute]
private void set_Application(string value);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
private void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public TraceVerbosity get_SuppressedTraceVerbosity();
    [CompilerGeneratedAttribute]
private void set_SuppressedTraceVerbosity(TraceVerbosity value);
    [CompilerGeneratedAttribute]
public TraceVerbosity get_ForcedTraceVerbosity();
    [CompilerGeneratedAttribute]
private void set_ForcedTraceVerbosity(TraceVerbosity value);
    [CompilerGeneratedAttribute]
public string get_AdditionalTraceDestination();
    [CompilerGeneratedAttribute]
private void set_AdditionalTraceDestination(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalTraceDestinationPrefix();
    [CompilerGeneratedAttribute]
private void set_AdditionalTraceDestinationPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_AdditionalTraceAsyncUpload();
    [CompilerGeneratedAttribute]
private void set_AdditionalTraceAsyncUpload(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldTrackConnection();
    [CompilerGeneratedAttribute]
private void set_ShouldTrackConnection(bool value);
    [CompilerGeneratedAttribute]
public Guid get_KuiperJobId();
    [CompilerGeneratedAttribute]
private void set_KuiperJobId(Guid value);
    public static void Serialize(Stream stream, CallContextCustomHeader value);
    public static void Serialize(RpcSerializer writer, CallContextCustomHeader value);
    public static Byte[] SerializeTo(CallContextCustomHeader value);
    public static CallContextCustomHeader Deserialize(Stream stream);
    public static CallContextCustomHeader Deserialize(RpcSerializer reader);
    public static CallContextCustomHeader Deserialize(Byte[] buffer);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Communication.CallContextOptions : Enum {
    public int value__;
    public static CallContextOptions None;
    public static CallContextOptions AddActivityContextIfAvailable;
    public static CallContextOptions AddUserContext;
    public static CallContextOptions AddAppContext;
    public static CallContextOptions AddClientContext;
    public static CallContextOptions AddClientRequestId;
    public static CallContextOptions AddTracingContextIfAvailable;
    public static CallContextOptions All;
}
[AttributeUsageAttribute("64")]
public class Kusto.Cloud.Platform.Communication.CallContextServiceSideAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <MonitoredActivityCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MonitoredActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MonitoredActivityDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceVerbosity <MonitoredActivityCreateVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceVerbosity <MonitoredActivitySucceededVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceVerbosity <MonitoredActivityFailedVerbosity>k__BackingField;
    public bool MonitoredActivityCreate { get; public set; }
    public string MonitoredActivityName { get; public set; }
    public string MonitoredActivityDescription { get; public set; }
    public TraceVerbosity MonitoredActivityCreateVerbosity { get; public set; }
    public TraceVerbosity MonitoredActivitySucceededVerbosity { get; public set; }
    public TraceVerbosity MonitoredActivityFailedVerbosity { get; public set; }
    public CallContextServiceSideAttribute(bool create);
    [CompilerGeneratedAttribute]
public bool get_MonitoredActivityCreate();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivityCreate(bool value);
    [CompilerGeneratedAttribute]
public string get_MonitoredActivityName();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivityName(string value);
    [CompilerGeneratedAttribute]
public string get_MonitoredActivityDescription();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivityDescription(string value);
    [CompilerGeneratedAttribute]
public TraceVerbosity get_MonitoredActivityCreateVerbosity();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivityCreateVerbosity(TraceVerbosity value);
    [CompilerGeneratedAttribute]
public TraceVerbosity get_MonitoredActivitySucceededVerbosity();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivitySucceededVerbosity(TraceVerbosity value);
    [CompilerGeneratedAttribute]
public TraceVerbosity get_MonitoredActivityFailedVerbosity();
    [CompilerGeneratedAttribute]
public void set_MonitoredActivityFailedVerbosity(TraceVerbosity value);
}
public static class Kusto.Cloud.Platform.Communication.CallContextUtils : object {
    private static object s_traceListenerProviderLock;
    private static ITraceListenerProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_traceListenerProvider;
    private static CallContextUtils();
    public static void SetTraceListenerProvider(ITraceListenerProvider traceListenerProvider);
    public static TraceListener CreateTraceListener(string dest, string destPrefix, bool asyncUpload);
    public static string GetCallContextAsString(CallContextOptions options, ClientDetails clientDetails, string clientRequestIdPrefix);
    private static void AddToDisposer(Disposer& disposer, IDisposable disposable);
    public static IDisposable RestoreCallContextFromString(string headerValue, bool headerExists, bool importIncomingCallContext, bool createMonitoredActivity, ActivityType activityType);
    public static CallContextOptions CalCulateClientBehaviorOptions(BaseCommunicationParameters communicationParameters);
}
public class Kusto.Cloud.Platform.Communication.ChannelHolder`1 : object {
    private ICommunicationChannel`1<TChannel> m_communicationChannel;
    private Guid m_channelId;
    public Guid ChannelId { get; }
    public Type Contract { get; }
    public ChannelHolder`1(ICommunicationChannel`1<TChannel> channel, Guid channelId);
    public sealed virtual Guid get_ChannelId();
    public sealed virtual Type get_Contract();
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Communication.ChannelManager : object {
    private object m_lock;
    private static int c_maxParallelism;
    private Dictionary`2<string, Dictionary`2<Guid, IChannelHolder>> m_channelsPerTargetHostMapper;
    public sealed virtual void AddChannel(string targetHost, IChannelHolder channelHolder);
    public sealed virtual void RemoveChannel(string targetHost, Guid channelId, Type contract);
    public sealed virtual int ReleaseAllChannelsToTargetHost(string targetHost);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Communication.Chunk : object {
    private static int c_maxPoolCount;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private static ConcurrentQueue`1<Chunk> s_Pool;
    private static long s_ObjectCount;
    [DataMemberAttribute]
public Byte[] Content { get; private set; }
    [DataMemberAttribute]
public int Count { get; private set; }
    public static long ObjectCount { get; }
    private static Chunk();
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public static long get_ObjectCount();
    public static Chunk Get(Byte[] value);
    public static Chunk Get(Byte[] value, int count);
    public static Chunk Rent();
    public void Recycle();
}
public class Kusto.Cloud.Platform.Communication.ClientCommunicationInitializationCapsule : object {
    [CompilerGeneratedAttribute]
private ClientDetails <ClientDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostAdress>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Properties>k__BackingField;
    public ClientDetails ClientDetails { get; public set; }
    public string HostAdress { get; public set; }
    public Dictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public ClientDetails get_ClientDetails();
    [CompilerGeneratedAttribute]
public void set_ClientDetails(ClientDetails value);
    [CompilerGeneratedAttribute]
public string get_HostAdress();
    [CompilerGeneratedAttribute]
public void set_HostAdress(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, object> value);
}
public abstract class Kusto.Cloud.Platform.Communication.CommunicationChannelPoolBase : object {
    private string m_poolName;
    private string m_identity;
    protected string PoolName { get; }
    protected CommunicationChannelPoolBase(string poolName);
    public virtual void Dispose();
    public static IEnumerable`1<CommunicationChannelPoolBase> Enumerate();
    public abstract virtual IEnumerable`1<PooledCommunicationChannelStatus> GetPooledCommunicationChannelStatus();
    protected string get_PoolName();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__3_0();
}
public class Kusto.Cloud.Platform.Communication.CommunicationLocalChannel`1 : object {
    private TChannel m_channel;
    private long m_lastUsed;
    private long m_numUsed;
    private int m_numConcurrent;
    private object m_lock;
    private Guid m_proxyId;
    public DateTime LastUsed { get; }
    public long NumUsed { get; }
    public int NumConcurrent { get; }
    public Guid ProxyId { get; }
    public CommunicationLocalChannel`1(TChannel channel);
    public sealed virtual void Dispose();
    public sealed virtual bool IsHealthyAndFresh(DateTime now);
    public sealed virtual DateTime get_LastUsed();
    public sealed virtual long get_NumUsed();
    public sealed virtual int get_NumConcurrent();
    public Guid get_ProxyId();
    public void IncreaseNumConcurrent();
    public void DecreaseNumConcurrent();
    public sealed virtual void InvokeWithAutomaticChannelRevival(string activity, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.CommunicationLocalChannel`1/<InvokeAsyncWithAutomaticChannelRevival>d__20")]
public sealed virtual Task InvokeAsyncWithAutomaticChannelRevival(string activity, Func`2<TChannel, Task> action, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.CommunicationLocalChannel`1/<InvokeAsyncWithAutomaticChannelRevival>d__21`1")]
public sealed virtual Task`1<TResult> InvokeAsyncWithAutomaticChannelRevival(string activity, Func`2<TChannel, Task`1<TResult>> action, Nullable`1<TimeSpan> timeout);
    public sealed virtual TResult InvokeWithAutomaticChannelRevival(string activity, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    private void UpdateLastUsed();
}
public static class Kusto.Cloud.Platform.Communication.CommunicationModelUtils : object {
    public static string EnableWcfMultipleChannelFactoriesTweakName;
    public static Tweak`1<bool> s_enableWcfMultipleChannelFactoriesTweak;
    public static string DisableWcfChannelsReuse;
    public static Tweak`1<bool> s_disableWcfChannelsReuse;
    public static string EnableWcfEvictionTimerTweakName;
    public static Tweak`1<bool> s_enableWcfEvictionTimerTweak;
    public static string EnableWcfLargeBufferPoolSizeTweakName;
    public static Tweak`1<bool> s_enableWcfLargeBufferPoolSize;
    public static string EnableWcfSocketTracesTweakName;
    public static Tweak`1<bool> s_enableWcfSocketTracesTweak;
    public static string DisableExceptionFiltersInOperationInvokerTweakName;
    public static Tweak`1<bool> s_disableExceptionFiltersInOperationInvokerTweak;
    public static string MaxConcurrentRequestsOnGrpcChannel;
    public static Tweak`1<int> s_maxRequestsOnGrpcChannel;
    public static string EnableGrpcHttpHandlerParameters;
    public static Tweak`1<bool> s_enableGrpcHttpHandlerParameters;
    public static string s_protoInclude;
    public static string s_protoSurrogate;
    private static CommunicationModelUtils();
    public static string CreateAddressString(string uriScheme, string host, int port, string path);
    public static Uri UpdateEndpointSchemeAndPortToHttpIfNeeded(Uri ea, int httpPort);
    public static bool IsLocalAddress(string host);
    public static IPAddress LoopbackIPAddress();
    public static IPAddress LocalIPAddress();
}
public abstract class Kusto.Cloud.Platform.Communication.CommunicationMultiClientBase`1 : object {
    public string DefaultRemoteAddress { get; }
    public ICommunicationParameters CommunicationParameters { get; }
    public virtual string get_DefaultRemoteAddress();
    public virtual ICommunicationParameters get_CommunicationParameters();
    public abstract virtual void BroadcastWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public abstract virtual void BroadcastWithAutomaticChannelRevivalAsync(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public abstract virtual Task InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<TResult> InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task`1<TResult>> action, Nullable`1<TimeSpan> timeout);
    public virtual IEnumerable`1<Tuple`3<string, Stream, Exception>> InvokeManyWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Func`2<TChannel, Stream> action, Nullable`1<TimeSpan> timeout);
    public virtual IEnumerable`1<Tuple`3<string, TResult, Exception>> InvokeManyWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual void InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Stream InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Stream> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual TResult InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual void SetLocalChannel(string localEndpointAddress, TChannel localChannel);
    public abstract virtual void Dispose();
}
public static class Kusto.Cloud.Platform.Communication.CommunicationParameterConsts : object {
    public static string AdditionalBehaviors;
}
public class Kusto.Cloud.Platform.Communication.CommunicationParametersDescriptor : object {
    [CompilerGeneratedAttribute]
private Type <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, ICommunicationParameters> <CommunicationParametersResolver>k__BackingField;
    public Type Contract { get; public set; }
    public Func`2<string, ICommunicationParameters> CommunicationParametersResolver { get; public set; }
    public CommunicationParametersDescriptor(Type contract, Func`2<string, ICommunicationParameters> communicationParametersResolver);
    [CompilerGeneratedAttribute]
public Type get_Contract();
    [CompilerGeneratedAttribute]
public void set_Contract(Type value);
    [CompilerGeneratedAttribute]
public Func`2<string, ICommunicationParameters> get_CommunicationParametersResolver();
    [CompilerGeneratedAttribute]
public void set_CommunicationParametersResolver(Func`2<string, ICommunicationParameters> value);
    public sealed virtual bool Equals(CommunicationParametersDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class Kusto.Cloud.Platform.Communication.CommunicationParametersResolver : object {
    private static Dictionary`2<Type, Func`2<string, ICommunicationParameters>> m_communicationParametersResolver;
    private static object m_lock;
    private static CommunicationParametersResolver();
    internal static void Clear();
    public static void AddOrUpdateCommunicationParameters(Type type, Func`2<string, ICommunicationParameters> communicationParameterResolver);
    private static ICommunicationParameters GetCommunicationParametersResolver(Type type, string name);
    public static ICommunicationParameters ResolveCommunicationParameters(Type type, string name);
}
internal class Kusto.Cloud.Platform.Communication.CommunicationTracer : TraceSourceBase`1<CommunicationTracer> {
    public static string IdentifierString;
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
}
public static class Kusto.Cloud.Platform.Communication.ECF : object {
    private static ICommunicationFactory s_defaultCommunicationFactory;
    private static IChannelManager s_channelManager;
    [CompilerGeneratedAttribute]
private static ICommunicationServiceHost <RuntimeServiceHost>k__BackingField;
    public static IChannelManager ChannelManager { get; }
    public static ICommunicationServiceHost RuntimeServiceHost { get; private set; }
    private static ECF();
    public static IChannelManager get_ChannelManager();
    public static void Init(ICommunicationFactory factory, IEnumerable`1<CommunicationParametersDescriptor> communicationParameters);
    public static bool IsVoidCommunicationFramework();
    public static ICommunicationMultiClient`1<T> CreateMultiClient(string name, ClientCommunicationInitializationCapsule capsule);
    internal static bool TryResolvePlatformExceptionDetailFromFrameworkException(Exception ex, PlatformExceptionDetail& platformExceptionDetail);
    public static bool IsFrameworkException(Exception ex);
    public static bool IsRemoteEndpointNotReachableException(Exception ex);
    public static void Reset();
    [CompilerGeneratedAttribute]
public static ICommunicationServiceHost get_RuntimeServiceHost();
    [CompilerGeneratedAttribute]
private static void set_RuntimeServiceHost(ICommunicationServiceHost value);
    public static ICommunicationServiceHost CreateServerHost(Type contract, string name, object singletonInstance, ServerCommunicationInitializationCapsule capsule);
    public static IEnumerable`1<Uri> GetListeningUris(Type contract, ICommunicationServiceHost serverHost);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Communication.ExtendedCallContextOptions : object {
    [ExtensionAttribute]
public static string FastToString(CallContextOptions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CallContextOptions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CallContextOptions that, CallContextOptions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(CallContextOptions that, CallContextOptions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(CallContextOptions that, CallContextOptions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(CallContextOptions that, CallContextOptions flags);
    public static CallContextOptions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CallContextOptions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CallContextOptions that);
    [ExtensionAttribute]
public static string FastGetDescription(CallContextOptions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Communication.ExtendedCallContextOptions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<CallContextOptions> FastGetFlags(CallContextOptions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Communication.ExtendedServiceOperationBehaviorOptions : object {
    [ExtensionAttribute]
public static string FastToString(ServiceOperationBehaviorOptions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(ServiceOperationBehaviorOptions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(ServiceOperationBehaviorOptions that, ServiceOperationBehaviorOptions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(ServiceOperationBehaviorOptions that, ServiceOperationBehaviorOptions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(ServiceOperationBehaviorOptions that, ServiceOperationBehaviorOptions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(ServiceOperationBehaviorOptions that, ServiceOperationBehaviorOptions flags);
    public static ServiceOperationBehaviorOptions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, ServiceOperationBehaviorOptions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(ServiceOperationBehaviorOptions that);
    [ExtensionAttribute]
public static string FastGetDescription(ServiceOperationBehaviorOptions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Communication.ExtendedServiceOperationBehaviorOptions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<ServiceOperationBehaviorOptions> FastGetFlags(ServiceOperationBehaviorOptions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Communication.ExtendedWcfTransferMode : object {
    [ExtensionAttribute]
public static string FastToString(WcfTransferMode that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(WcfTransferMode that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(WcfTransferMode that, WcfTransferMode flag);
    public static WcfTransferMode FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, WcfTransferMode& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(WcfTransferMode that);
    [ExtensionAttribute]
public static string FastGetDescription(WcfTransferMode that);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Communication.FailedInitializingServerException : Exception {
    public string FailureReason;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected FailedInitializingServerException(SerializationInfo info, StreamingContext context);
    public FailedInitializingServerException(string failureReason, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public FailedInitializingServerException(string failureReason, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Communication.FailedLocatingClusterNodeException : Exception {
    public string NodeId;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected FailedLocatingClusterNodeException(SerializationInfo info, StreamingContext context);
    public FailedLocatingClusterNodeException(string nodeId, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public FailedLocatingClusterNodeException(string nodeId, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Communication.FailedResolvingCommunicationParametersException : Exception {
    public string Contract;
    public string Name;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public FailedResolvingCommunicationParametersException(string message, Exception innerException);
    protected FailedResolvingCommunicationParametersException(SerializationInfo info, StreamingContext context);
    public FailedResolvingCommunicationParametersException(string contract, string name, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public FailedResolvingCommunicationParametersException(string contract, string name, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface Kusto.Cloud.Platform.Communication.IChannelHolder {
    public Guid ChannelId { get; }
    public Type Contract { get; }
    public abstract virtual Guid get_ChannelId();
    public abstract virtual Type get_Contract();
}
public interface Kusto.Cloud.Platform.Communication.IChannelManager {
    public abstract virtual void AddChannel(string targetHost, IChannelHolder channelHolder);
    public abstract virtual void RemoveChannel(string targetHost, Guid channelId, Type contract);
    public abstract virtual int ReleaseAllChannelsToTargetHost(string targetHost);
}
public interface Kusto.Cloud.Platform.Communication.ICommunicationChannel`1 {
    public DateTime LastUsed { get; }
    public long NumUsed { get; }
    public int NumConcurrent { get; }
    public abstract virtual bool IsHealthyAndFresh(DateTime now);
    public abstract virtual DateTime get_LastUsed();
    public abstract virtual long get_NumUsed();
    public abstract virtual int get_NumConcurrent();
    public abstract virtual void InvokeWithAutomaticChannelRevival(string activity, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual TResult InvokeWithAutomaticChannelRevival(string activity, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task InvokeAsyncWithAutomaticChannelRevival(string activity, Func`2<TChannel, Task> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<TResult> InvokeAsyncWithAutomaticChannelRevival(string activity, Func`2<TChannel, Task`1<TResult>> action, Nullable`1<TimeSpan> timeout);
}
public interface Kusto.Cloud.Platform.Communication.ICommunicationFactory {
    public bool Disposed { get; }
    public abstract virtual ICommunicationMultiClient`1<T> CreateMultiClient(string name, ICommunicationParameters parameters, ClientCommunicationInitializationCapsule capsule, IChannelManager connectionManager);
    public abstract virtual ICommunicationServiceHost CreateServerHost(string name, object singletonInstance, IEnumerable`1<ICommunicationParameters> parameters, ServerCommunicationInitializationCapsule capsule, Type contract);
    public abstract virtual IEnumerable`1<Uri> GetListeningUris(Type contract, ICommunicationServiceHost serverHost);
    public abstract virtual bool TryResolvePlatformExceptionDetailFromFrameworkException(Exception ex, PlatformExceptionDetail& platformExceptionDetail);
    public abstract virtual bool IsFrameworkException(Exception ex);
    public abstract virtual bool IsRemoteEndpointNotReachableException(Exception ex);
    public abstract virtual bool get_Disposed();
}
public interface Kusto.Cloud.Platform.Communication.ICommunicationMultiClient`1 {
    public string DefaultRemoteAddress { get; }
    public ICommunicationParameters CommunicationParameters { get; }
    public abstract virtual Task InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Task`1<TResult> InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task`1<TResult>> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual void InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual Stream InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Stream> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual TResult InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual IEnumerable`1<Tuple`3<string, Stream, Exception>> InvokeManyWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Func`2<TChannel, Stream> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual IEnumerable`1<Tuple`3<string, TResult, Exception>> InvokeManyWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public abstract virtual void BroadcastWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public abstract virtual void BroadcastWithAutomaticChannelRevivalAsync(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public abstract virtual string get_DefaultRemoteAddress();
    public abstract virtual void SetLocalChannel(string localEndpointAddress, TChannel localChannel);
    public abstract virtual ICommunicationParameters get_CommunicationParameters();
}
public interface Kusto.Cloud.Platform.Communication.ICommunicationParameters {
    public Type ServiceContract { get; }
    public int ServicePort { get; }
    public bool PropagateCallContext { get; }
    public bool PropagateClientRequestId { get; }
    public bool PropagateUser { get; }
    public bool PropagateApp { get; }
    public bool PropagateClientVersion { get; }
    public string RelativePath { get; }
    public string Scheme { get; }
    public abstract virtual Type get_ServiceContract();
    public abstract virtual int get_ServicePort();
    public abstract virtual bool get_PropagateCallContext();
    public abstract virtual bool get_PropagateClientRequestId();
    public abstract virtual bool get_PropagateUser();
    public abstract virtual bool get_PropagateApp();
    public abstract virtual bool get_PropagateClientVersion();
    public abstract virtual string get_RelativePath();
    public abstract virtual string get_Scheme();
}
public interface Kusto.Cloud.Platform.Communication.ICommunicationServiceHost {
    public object SingletonInstance { get; }
    public abstract virtual object get_SingletonInstance();
    public abstract virtual void Open();
    public abstract virtual List`1<ServiceConcurrencyStatus> GetConcurrencyStatus();
}
public interface Kusto.Cloud.Platform.Communication.IRequestRetryOperation {
    public abstract virtual Task`1<TReturn> RetryAsync(Func`1<TReturn> func, string serviceId, Nullable`1<TimeSpan> requestTimeout, string description);
}
public interface Kusto.Cloud.Platform.Communication.IServiceModelRequestProcessor {
    public TimeSpan RequestTimeout { get; }
    public abstract virtual TimeSpan get_RequestTimeout();
    public abstract virtual TResult ProcessRequest(Func`1<TResult> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options);
    public abstract virtual Task`1<TResult> ProcessRequestAsync(Func`1<TResult> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options, IRequestRetryOperation retryOperation, string serviceId);
    public abstract virtual Task`1<TResult> ProcessAsyncRequestAsync(Func`1<Task`1<TResult>> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options);
}
public interface Kusto.Cloud.Platform.Communication.ITraceListenerProvider {
    public abstract virtual TraceListener TryCreateTraceListener(string dest, string destPrefix, bool asyncUpload);
}
internal interface Kusto.Cloud.Platform.Communication.IVoidServerHostSetter {
    public abstract virtual void SetServerHost(object serverHost);
}
public static class Kusto.Cloud.Platform.Communication.MetadataHeadersConsts : object {
    public static string PlatformExceptionDetails_PedHeader;
    public static string PlatformExceptionDetails_CreationContextHeader;
    public static string PlatformExceptionDetails_StackTraceHeader;
    public static string PlatformExceptionDetails_MessageHeader;
    public static string PlatformExceptionDetails_InnerPedHeader;
    public static string PlatformExceptionDetails_InnerCreationContextHeader;
    public static string PlatformExceptionDetails_InnerStackTraceHeader;
    public static string PlatformExceptionDetails_InnerMessageHeader;
}
public class Kusto.Cloud.Platform.Communication.PooledCommunicationChannelStatus : object {
    public string NodeId;
    public string PoolName;
    public string ChannelId;
    public string RemoteAddress;
    public string CommunicationState;
    public DateTime ProxyLastUsed;
    public long NumUsed;
}
public class Kusto.Cloud.Platform.Communication.ProtoIncludeType : object {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Tag>k__BackingField;
    public Type BaseType { get; public set; }
    public Type DerivedType { get; public set; }
    public int Tag { get; public set; }
    public ProtoIncludeType(Type baseType, Type derivedType, int tag);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
public void set_BaseType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [CompilerGeneratedAttribute]
public void set_DerivedType(Type value);
    [CompilerGeneratedAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(int value);
    public virtual string ToString();
    public sealed virtual bool Equals(ProtoIncludeType other);
}
public class Kusto.Cloud.Platform.Communication.ProtoSurrogate : object {
    [CompilerGeneratedAttribute]
private Type <ComplexType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SurrogateType>k__BackingField;
    public Type ComplexType { get; public set; }
    public Type SurrogateType { get; public set; }
    public ProtoSurrogate(Type complexType, Type surrogateType);
    [CompilerGeneratedAttribute]
public Type get_ComplexType();
    [CompilerGeneratedAttribute]
public void set_ComplexType(Type value);
    [CompilerGeneratedAttribute]
public Type get_SurrogateType();
    [CompilerGeneratedAttribute]
public void set_SurrogateType(Type value);
    public sealed virtual bool Equals(ProtoSurrogate other);
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Communication.RpcExceptionUtils : object {
    public static IDictionary`2<string, string> ExtractRpcExceptionMetadata(Exception ex);
    private static string ConvertToBase64String(string headerValue);
    public static bool TryResolvePlatformExceptionDetailFromHeaders(TryGetHeader headers, PlatformExceptionDetail& platformExceptionDetail);
    private static string ConvertFromBase64String(string base64StringHeader);
}
public class Kusto.Cloud.Platform.Communication.ServerCommunicationInitializationCapsule : object {
    [CompilerGeneratedAttribute]
private bool <EnableWorkerThreadPoolBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDispatcherSynchronizationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri[] <BaseAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Properties>k__BackingField;
    public bool EnableWorkerThreadPoolBehavior { get; public set; }
    public bool EnableDispatcherSynchronizationBehavior { get; public set; }
    public Uri[] BaseAddresses { get; public set; }
    public Dictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableWorkerThreadPoolBehavior();
    [CompilerGeneratedAttribute]
public void set_EnableWorkerThreadPoolBehavior(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDispatcherSynchronizationBehavior();
    [CompilerGeneratedAttribute]
public void set_EnableDispatcherSynchronizationBehavior(bool value);
    [CompilerGeneratedAttribute]
public Uri[] get_BaseAddresses();
    [CompilerGeneratedAttribute]
public void set_BaseAddresses(Uri[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, object> value);
}
public class Kusto.Cloud.Platform.Communication.ServiceConcurrencyStatus : object {
    public string NodeId;
    public string Contract;
    public string Method;
    public long CallsStarted;
    public long CallsOngoing;
}
public class Kusto.Cloud.Platform.Communication.ServiceModelCommunicationParameters : BaseCommunicationParameters {
    [CompilerGeneratedAttribute]
private BindingKind <BindingKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceListeningHostAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private WcfTransferMode <TransferMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReliableSession>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxReceivedMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableJsonBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNetDataContractSerializerBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransportKeepalive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoMex>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ReceiveTimeout>k__BackingField;
    public BindingKind BindingKind { get; public set; }
    public string ServiceListeningHostAddress { get; public set; }
    public WcfTransferMode TransferMode { get; public set; }
    public bool ReliableSession { get; public set; }
    public long MaxReceivedMessageSize { get; public set; }
    public bool EnableJsonBehavior { get; public set; }
    public bool EnableNetDataContractSerializerBehavior { get; public set; }
    public bool TransportKeepalive { get; public set; }
    public bool AutoMex { get; public set; }
    public TimeSpan OperationTimeout { get; public set; }
    public TimeSpan ReceiveTimeout { get; public set; }
    public ServiceModelCommunicationParameters(Type serviceContract);
    [CompilerGeneratedAttribute]
public BindingKind get_BindingKind();
    [CompilerGeneratedAttribute]
public void set_BindingKind(BindingKind value);
    [CompilerGeneratedAttribute]
public string get_ServiceListeningHostAddress();
    [CompilerGeneratedAttribute]
public void set_ServiceListeningHostAddress(string value);
    [CompilerGeneratedAttribute]
public WcfTransferMode get_TransferMode();
    [CompilerGeneratedAttribute]
public void set_TransferMode(WcfTransferMode value);
    [CompilerGeneratedAttribute]
public bool get_ReliableSession();
    [CompilerGeneratedAttribute]
public void set_ReliableSession(bool value);
    [CompilerGeneratedAttribute]
public long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxReceivedMessageSize(long value);
    [CompilerGeneratedAttribute]
public bool get_EnableJsonBehavior();
    [CompilerGeneratedAttribute]
public void set_EnableJsonBehavior(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableNetDataContractSerializerBehavior();
    [CompilerGeneratedAttribute]
public void set_EnableNetDataContractSerializerBehavior(bool value);
    [CompilerGeneratedAttribute]
public bool get_TransportKeepalive();
    [CompilerGeneratedAttribute]
public void set_TransportKeepalive(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoMex();
    [CompilerGeneratedAttribute]
public void set_AutoMex(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ReceiveTimeout();
    [CompilerGeneratedAttribute]
public void set_ReceiveTimeout(TimeSpan value);
}
public static class Kusto.Cloud.Platform.Communication.ServiceModelHeaders : object {
    public static string Namespace;
    public static string WcfCustomContextHeaderName;
    public static string ContextHeaderName;
    public static string ClientRequestIdHeaderName;
    public static string ActivityIdHeaderName;
    public static string UserHeaderName;
    public static string UserIdHeaderName;
    public static string AppHeaderName;
    public static string ClientVersionHeaderName;
    public static string ReadonlyHeaderName;
    public static string VersionHeaderName;
    public static string RequestSupportHeaderName;
    public static string IngestionDataConnectionSourceHeaderName;
    public static string S2SAuthorizationHeaderName;
}
public class Kusto.Cloud.Platform.Communication.ServiceModelRequestContext : MarshalByRefObject {
    private string m_unauthenticatedUser;
    private string m_unauthenticatedApp;
    private string m_unauthenticatedClient;
    private string m_remoteAddress;
    public string UnauthenticatedUser { get; }
    public string UnauthenticatedApp { get; }
    public string UnauthenticatedClient { get; }
    public string RemoteAddress { get; }
    public ServiceModelRequestContext(string unauthenticatedUser, string unauthenticatedApp, string unauthenticatedClient, string remoteAddress);
    public string get_UnauthenticatedUser();
    public string get_UnauthenticatedApp();
    public string get_UnauthenticatedClient();
    public string get_RemoteAddress();
}
public class Kusto.Cloud.Platform.Communication.ServiceModelRequestProcessor : object {
    private static ServiceModelRequestProcessorActivityType s_serviceModelRequestProcessorActivityType;
    private ActivityType m_activityType;
    private TimeSpan m_requestTimeout;
    public TimeSpan RequestTimeout { get; }
    public ServiceModelRequestProcessor(ActivityType activityType, TimeSpan requestTimeout);
    private static ServiceModelRequestProcessor();
    public sealed virtual TimeSpan get_RequestTimeout();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.ServiceModelRequestProcessor/<ProcessRequestAsync>d__6`1")]
public sealed virtual Task`1<TResult> ProcessRequestAsync(Func`1<TResult> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options, IRequestRetryOperation retryOperation, string serviceId);
    public sealed virtual TResult ProcessRequest(Func`1<TResult> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.ServiceModelRequestProcessor/<ProcessAsyncRequestAsync>d__8`1")]
public sealed virtual Task`1<TResult> ProcessAsyncRequestAsync(Func`1<Task`1<TResult>> processor, string processorDescription, Nullable`1<TimeSpan> requestTimeout, Action`1<TResult> onResultAbandoned, ServiceModelRequestProcessorOptions options);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Communication.ServiceModelRequestProcessorOptions : Enum {
    public int value__;
    public static ServiceModelRequestProcessorOptions Default;
    public static ServiceModelRequestProcessorOptions NoRequestTimeout;
}
public static class Kusto.Cloud.Platform.Communication.ServiceModelRequestTimeout : object {
    private static TimeSpan c_allowedClientServerDelta;
    private static TimeSpan c_maxTimeSpanAdjusted;
    private static object m_lock;
    private static TimeSpan m_timeoutShortKind;
    private static TimeSpan m_timeoutLongKind;
    private static TimeSpan m_timeoutAsyncKind;
    private static TimeSpan m_defaultMaxTimeout;
    private static TimeSpan m_maxTimeout;
    private static ServiceModelRequestTimeout();
    public static TimeSpan GetClientTimeout(ServiceModelTimeoutKind timeoutKind, Nullable`1<bool> noTimeout, Nullable`1<TimeSpan> serverTimeout);
    public static TimeSpan GetClientTimeout(ServiceModelTimeoutKind timeoutKind);
    public static TimeSpan GetServerTimeout(ServiceModelTimeoutKind timeoutKind);
    public static TimeSpan GetDefaultMaxTimeout();
    public static void SetMaxRequestTimeout(Nullable`1<TimeSpan> timeout);
    public static TimeSpan ApplyMaxTimeoutPolicy();
    public static TimeSpan ApplyMaxTimeoutPolicy(TimeSpan timeout);
    public static void SetServerTimeOuts(TimeSpan shortKind, TimeSpan longKind, TimeSpan asyncKind, TimeSpan maxTimeout);
    private static TimeSpan AdjustServerTimeoutToClientTimeout(TimeSpan serverTimeout);
}
public enum Kusto.Cloud.Platform.Communication.ServiceModelTimeoutKind : Enum {
    public int value__;
    public static ServiceModelTimeoutKind Short;
    public static ServiceModelTimeoutKind Long;
    public static ServiceModelTimeoutKind Async;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Communication.ServiceOperationBehaviorOptions : Enum {
    public int value__;
    public static ServiceOperationBehaviorOptions None;
    public static ServiceOperationBehaviorOptions ImportIncomingCallContext;
    public static ServiceOperationBehaviorOptions CreateMonitoredActivity;
    public static ServiceOperationBehaviorOptions TrackConcurrency;
    public static ServiceOperationBehaviorOptions EmitDiagnostics;
    public static ServiceOperationBehaviorOptions All;
}
public class Kusto.Cloud.Platform.Communication.TextFileTraceListenerProvider : object {
    public sealed virtual TraceListener TryCreateTraceListener(string dest, string destPrefix, bool asyncUpload);
}
internal class Kusto.Cloud.Platform.Communication.VoidCommunicationClient`1 : CommunicationMultiClientBase`1<TChannel> {
    private TChannel m_serverInstance;
    private ICommunicationParameters m_communicationParameters;
    public string DefaultRemoteAddress { get; }
    public ICommunicationParameters CommunicationParameters { get; }
    public VoidCommunicationClient`1(VoidServiceHost serverInstance, ICommunicationParameters parameters);
    public virtual string get_DefaultRemoteAddress();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.VoidCommunicationClient`1/<InvokeAsyncWithAutomaticChannelRevival>d__5")]
public virtual Task InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task> action, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Communication.VoidCommunicationClient`1/<InvokeAsyncWithAutomaticChannelRevival>d__6`1")]
public virtual Task`1<TResult> InvokeAsyncWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Task`1<TResult>> action, Nullable`1<TimeSpan> timeout);
    public virtual void InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout);
    public virtual Stream InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, Stream> action, Nullable`1<TimeSpan> timeout);
    public virtual TResult InvokeWithAutomaticChannelRevival(string activity, Uri remoteAddress, Func`2<TChannel, TResult> action, Nullable`1<TimeSpan> timeout);
    public virtual void BroadcastWithAutomaticChannelRevival(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public virtual void BroadcastWithAutomaticChannelRevivalAsync(string activity, IEnumerable`1<Uri> remoteAddresses, Action`1<TChannel> action, Nullable`1<TimeSpan> timeout, int maxParallelism);
    public virtual void SetLocalChannel(string localEndpointAddress, TChannel localChannel);
    public virtual void Dispose();
    public virtual ICommunicationParameters get_CommunicationParameters();
    public sealed virtual void SetServerHost(object serverHost);
}
public class Kusto.Cloud.Platform.Communication.VoidCommunicationFactory : object {
    private DisposableDictionary`2<ServerDescription, VoidServiceHost> m_serverInstances;
    private DisposableDictionary`2<ClientDescription, IVoidServerHostSetter> m_clients;
    private VoidCommunicationFactoryType m_type;
    private bool m_disposed;
    private object m_lock;
    public bool Disposed { get; }
    public VoidCommunicationFactory(VoidCommunicationFactoryType type);
    public sealed virtual bool get_Disposed();
    public sealed virtual ICommunicationMultiClient`1<T> CreateMultiClient(string name, ICommunicationParameters parameters, ClientCommunicationInitializationCapsule capsule, IChannelManager channelManager);
    private VoidServiceHost ResolveServiceInstance(string name, Type serviceType);
    public sealed virtual ICommunicationServiceHost CreateServerHost(string name, object singletonInstance, IEnumerable`1<ICommunicationParameters> parameters, ServerCommunicationInitializationCapsule capsule, Type contract);
    private IEnumerable`1<IVoidServerHostSetter> ResolveClients(ClientDescription description);
    public sealed virtual IEnumerable`1<Uri> GetListeningUris(Type contract, ICommunicationServiceHost serverHost);
    public sealed virtual bool IsFrameworkException(Exception ex);
    public sealed virtual bool IsRemoteEndpointNotReachableException(Exception ex);
    public sealed virtual bool TryResolvePlatformExceptionDetailFromFrameworkException(Exception ex, PlatformExceptionDetail& platformExceptionDetail);
    public void Clear();
    public sealed virtual void Dispose();
}
public enum Kusto.Cloud.Platform.Communication.VoidCommunicationFactoryType : Enum {
    public int value__;
    public static VoidCommunicationFactoryType InterNode;
    public static VoidCommunicationFactoryType Void;
}
public class Kusto.Cloud.Platform.Communication.VoidServiceHost : object {
    private object m_singletonInstance;
    private List`1<Uri> m_serviceEndpoints;
    [CompilerGeneratedAttribute]
private bool <ServiceDebugBehavior>k__BackingField;
    public object SingletonInstance { get; }
    public bool ServiceDebugBehavior { get; public set; }
    public VoidServiceHost(string name, object service, ICommunicationParameters parameters);
    public sealed virtual object get_SingletonInstance();
    [CompilerGeneratedAttribute]
public bool get_ServiceDebugBehavior();
    [CompilerGeneratedAttribute]
public void set_ServiceDebugBehavior(bool value);
    public sealed virtual void Open();
    public IEnumerable`1<Uri> GetListeningUris();
    public sealed virtual void Dispose();
    public sealed virtual List`1<ServiceConcurrencyStatus> GetConcurrencyStatus();
}
public enum Kusto.Cloud.Platform.Communication.WcfTransferMode : Enum {
    public int value__;
    public static WcfTransferMode Buffered;
    public static WcfTransferMode Streamed;
    public static WcfTransferMode StreamedRequest;
    public static WcfTransferMode StreamedResponse;
}
[AttributeUsageAttribute("384")]
public class Kusto.Cloud.Platform.Data.Attributes.ColumnAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DbType>k__BackingField;
    public string Storage { get; public set; }
    public string DbType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(string value);
    [CompilerGeneratedAttribute]
public string get_DbType();
    [CompilerGeneratedAttribute]
public void set_DbType(string value);
}
[AttributeUsageAttribute("4")]
public class Kusto.Cloud.Platform.Data.Attributes.TableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Data.CsvWriterException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public CsvWriterException(string message, Exception innerException);
    protected CsvWriterException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Data.DataReaderAdapter : object {
    private IDataReader m_inner;
    private DataTable[] m_schemaTables;
    private FakeSqlDataReader m_innerAsSqlDataReader;
    private Func`1[] m_columnReaders;
    [CompilerGeneratedAttribute]
private Action`2<object, DataReaderEventArgs> OnEvent;
    private int m_counterRead;
    private int m_counterResult;
    private int m_counterDisposed;
    public int Depth { get; }
    public int FieldCount { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    public DataReaderAdapter(IDataReader inner, DataTable[] schemaTables);
    [CompilerGeneratedAttribute]
public void add_OnEvent(Action`2<object, DataReaderEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnEvent(Action`2<object, DataReaderEventArgs> value);
    public sealed virtual int get_Depth();
    public sealed virtual int get_FieldCount();
    public sealed virtual bool get_IsClosed();
    public sealed virtual object get_Item(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual int get_RecordsAffected();
    private void PrepareSqlDecimalConverter();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public sealed virtual string GetTableName();
    public sealed virtual Guid GetTableId();
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual char GetChar(int i);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual string GetString(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool IsDBNull(int i);
    public sealed virtual bool NextResult();
    public sealed virtual bool Read();
    public void Notify(DataReaderEventKind eventKind, int counter);
}
[DefaultMemberAttribute("Item")]
public abstract class Kusto.Cloud.Platform.Data.DataReaderBase : object {
    public object Item { get; }
    public object Item { get; }
    public int FieldCount { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public abstract virtual void Dispose();
    public virtual object get_Item(int i);
    public virtual object get_Item(string name);
    public abstract virtual int get_FieldCount();
    public virtual bool GetBoolean(int i);
    public virtual byte GetByte(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual char GetChar(int i);
    public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual IDataReader GetData(int i);
    public virtual string GetDataTypeName(int i);
    public virtual DateTime GetDateTime(int i);
    public virtual decimal GetDecimal(int i);
    public virtual double GetDouble(int i);
    public abstract virtual Type GetFieldType(int i);
    public virtual float GetFloat(int i);
    public virtual Guid GetGuid(int i);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public abstract virtual string GetName(int i);
    public abstract virtual int GetOrdinal(string name);
    public virtual string GetString(int i);
    public abstract virtual object GetValue(int i);
    public abstract virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int i);
    public virtual int get_Depth();
    public abstract virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
    public abstract virtual void Close();
    public abstract virtual DataTable GetSchemaTable();
    public abstract virtual bool NextResult();
    public abstract virtual bool Read();
}
public class Kusto.Cloud.Platform.Data.DataReaderEventArgs : object {
    public DataReaderEventKind EventKind;
    public int Counter;
}
public enum Kusto.Cloud.Platform.Data.DataReaderEventKind : Enum {
    public int value__;
    public static DataReaderEventKind ReadFalse;
    public static DataReaderEventKind NextResultTrue;
    public static DataReaderEventKind NextResultFalse;
    public static DataReaderEventKind Closing;
    public static DataReaderEventKind Disposing;
}
public static class Kusto.Cloud.Platform.Data.DataReaderSerializer : object {
    private static JsonDataStreamSettings s_defaultSettings;
    private static DataReaderSerializer();
    public static Byte[] ToBuffer(IDataReader reader);
    public static DataSet ToDataSet(Byte[] buffer);
    public static Stream WriteToStream(IDataReader reader, Stream stream);
    public static DataSet ToDataSet(Stream stream);
    private static Stream ToStream(IDataReader reader);
    private static JsonDataStreamSettings GetValidatedSettings();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Data.DataSetContainsNoDataException : ArgumentException {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public DataSetContainsNoDataException(string message, Exception innerException);
    protected DataSetContainsNoDataException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Data.DataTableIncompleteDataStreamException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public DataTableIncompleteDataStreamException(string message, Exception innerException);
    protected DataTableIncompleteDataStreamException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Data.EnumerableDataReader`1 : object {
    private IEnumerator`1<T> m_enumerator;
    private T m_current;
    private bool m_enumeratorState;
    private List`1<BaseField<T>> m_fields;
    private bool m_closed;
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public EnumerableDataReader`1(IEnumerable`1<T> collection, String[] fields);
    private void SetFields(ICollection`1<string> fields);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual int get_Depth();
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual bool get_IsClosed();
    public sealed virtual bool NextResult();
    public sealed virtual bool Read();
    public sealed virtual int get_RecordsAffected();
    public sealed virtual int get_FieldCount();
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual bool IsDBNull(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual object get_Item(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual char GetChar(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetString(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Data.ErrorDataReader : object {
    private bool m_closed;
    private PlatformExceptionDetail m_ped;
    [CompilerGeneratedAttribute]
private Action OnDone;
    public PlatformExceptionDetail PlatformExceptionDetail { get; }
    public object Item { get; }
    public object Item { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public ErrorDataReader(Exception ex);
    public ErrorDataReader(PlatformExceptionDetail ped);
    public sealed virtual PlatformExceptionDetail get_PlatformExceptionDetail();
    [CompilerGeneratedAttribute]
public void add_OnDone(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnDone(Action value);
    private Exception CreateException();
    public sealed virtual object get_Item(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual int get_Depth();
    public sealed virtual bool get_IsClosed();
    public sealed virtual int get_RecordsAffected();
    public sealed virtual int get_FieldCount();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual char GetChar(int i);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual string GetString(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool IsDBNull(int i);
    public sealed virtual bool NextResult();
    public sealed virtual bool Read();
}
public class Kusto.Cloud.Platform.Data.ExtendedCultureInfo : object {
    private static CultureInfo s_invariantCulture;
    public static CultureInfo InvariantCulture { get; }
    private static ExtendedCultureInfo();
    public static CultureInfo get_InvariantCulture();
    public static CultureInfo CreateInvariantCulture();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedDataColumnCollection : object {
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Data.ExtendedDataColumnCollection/<AsEnumerable>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<DataColumn> AsEnumerable(DataColumnCollection collection);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedDataReader : object {
    private static int s_defaultColumnWidth;
    private static PropertyInfo s_DataTableReader_CurrentDataTable;
    private static PropertyInfo s_DataTableReader_CurrentDataTable2;
    public static int DefaultColumnWidth { get; public set; }
    private static string DefaultColumnFormatString { get; }
    private static ExtendedDataReader();
    private static PropertyInfo GetDataTableReader_Property_CurrentDataTable();
    private static PropertyInfo GetDataTableReader_Property_CurrentDataTable2();
    [ExtensionAttribute]
public static string GetTableName(IDataReader reader);
    [ExtensionAttribute]
public static string GetTableName(IDataReaderEx reader);
    [ExtensionAttribute]
public static Guid GetTableId(IDataReader reader);
    [ExtensionAttribute]
public static Guid GetTableId(IDataReaderEx reader);
    public static int get_DefaultColumnWidth();
    public static void set_DefaultColumnWidth(int value);
    private static string get_DefaultColumnFormatString();
    [ExtensionAttribute]
public static DataSet ToDataSet(IDataReader reader);
    [ExtensionAttribute]
public static string ToJsonString(IDataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<Object[]> ToEnumerableObjectArray(IDataReader reader);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Data.ExtendedDataReader/<ToEnumerableObjectArray>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<Object[]> ToEnumerableObjectArray(IDataReader reader, bool disposeReader);
    [ExtensionAttribute]
public static IEnumerable`1<TRow> ToEnumerable(IDataReader reader, TRow result);
    [ExtensionAttribute]
public static IEnumerable`1<TRow> ToEnumerable(IDataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<TRow> ToEnumerable(IDataReader reader, bool disposeReader);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Data.ExtendedDataReader/<ToJObjects>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<JObject> ToJObjects(IDataReader reader);
    [ExtensionAttribute]
public static string ToText(IDataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<string> ToStringColumn(IDataReader reader, string columnName);
    [ExtensionAttribute]
public static IList`1<String[]> ToStringColumns(IDataReader reader, bool includeHeaderAsFirstRow);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Data.ExtendedDataReader/<ToStringColumns>d__25")]
[ExtensionAttribute]
public static IEnumerable`1<String[]> ToStringColumns(IDataReader reader, IEnumerable`1<string> columnNames);
    [ExtensionAttribute]
public static IDataReader ToLimitedLengthDataReader(IDataReader reader, long remainingAllowedRows);
    [ExtensionAttribute]
public static long WriteAsCsv(IDataReader reader, bool includeHeaderAsFirstRow, TextWriter textWriter);
    [ExtensionAttribute]
public static long WriteAsCsv(IDataReader reader, bool includeHeaderAsFirstRow, TextWriter textWriter, long maxFileSize);
    [ExtensionAttribute]
public static long WriteAsCsv(IDataReader reader, TextWriter textWriter, WriteAsOptions options, Int64& bytesWritten);
    [ExtensionAttribute]
public static long WriteAsCsv(IDataReader reader, IXsvWriter csvWriter, WriteAsOptions writeAsOptions);
    [ExtensionAttribute]
public static IList`1<WriteResults> WriteAsPartitionedCsv(IDataReader reader, ITextWriterCreator textWriterCreator, WriteAsOptions options);
    [ExtensionAttribute]
public static IList`1<WriteResults> WriteAsPartitionedTsv(IDataReader reader, ITextWriterCreator textWriterCreator, WriteAsOptions options);
    private static IList`1<WriteResults> WriteAsSeparatedValue(IDataReader reader, Func`2<TextWriter, IXsvWriter> createXsvWriter, ITextWriterCreator textWriterCreator, WriteAsOptions options);
    [ExtensionAttribute]
public static IList`1<WriteResults> WriteAsPartitionedJson(IDataReader reader, ITextWriterCreator textWriterCreator, long maxFileSize);
    private static long WriteAsSeparatedValue(IDataReader reader, IXsvWriter writer, WriteAsOptions options);
    [ExtensionAttribute]
public static long WriteAsJson(IDataReader reader, TextWriter textWriter, Int64& bytesWritten);
    [ExtensionAttribute]
public static long WriteAsJson(IDataReader reader, TextWriter textWriter, long maxFileSize, Int64& bytesWritten);
    [ExtensionAttribute]
public static void WriteAsHtml(IDataReader reader, string title, TextWriter writer);
    [ExtensionAttribute]
public static void WriteAsText(IDataReader reader, string title, bool tabify, bool firstOnly);
    [ExtensionAttribute]
public static void WriteAsText(IDataReader reader, string title, bool tabify, TextWriter writer, bool firstOnly, bool markdown, bool trim, int bufferedRowCount, string includeWithHeader, bool includeHeader, bool abortOnWriteFailures, bool hideResultSetBanner);
    [ExtensionAttribute]
public static long WriteAsTsv(IDataReader reader, bool includeHeaderAsFirstRow, TextWriter textWriter);
    [ExtensionAttribute]
public static long WriteAsTsv(IDataReader reader, TextWriter textWriter, WriteAsOptions writeAsOptions, Int64& bytesWritten);
    [ExtensionAttribute]
public static long WriteAsTsv(IDataReader reader, bool includeHeaderAsFirstRow, TextWriter textWriter, long maxFileSize, Int64& bytesWritten);
    [ExtensionAttribute]
public static IDataReader Materialize(IDataReader reader);
    [ExtensionAttribute]
public static long Consume(IDataReader reader);
    [ExtensionAttribute]
public static PlatformExceptionDetail AsPlatformExceptionDetail(IDataReader reader);
    public static string ValueToDisplayString(object val, bool isDynamic, string staticType);
    public static string ValueToString(object val);
    private static String[] GetFieldNames(IDataReader reader);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedDataRow : object {
    [ExtensionAttribute]
public static TResult GetValueAsTypeOrDefault(DataRow row, DataColumn column, TResult default);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedDataSet : object {
    private static TrustedTypesSerializationBinder m_trustedTypesSerializationBinder;
    private static ExtendedDataSet();
    [ExtensionAttribute]
public static IDataReader CreateDataReaderEx(DataSet dataSet);
    private static void CopySchemaTableToDataTable(DataTable schemaTable, DataTable target);
    [ExtensionAttribute]
public static DataSet FromDataReader(IDataReader reader, string name);
    public static DataSet FromJsonString(string jsonString);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedDataTable : object {
    private static Func`2<Type, string> s_defaultColumnTypeFromClrType;
    public static Func`2<Type, string> SetDefaultColumnTypeFromClrType(Func`2<Type, string> defaultColumnTypeFromClrType);
    public static DataTable Create(string tableName);
    public static DataTable Create(string tableName, Func`2<Type, string> columnTypeFromClrType);
    public static DataTable Create(string tableName, Type schema, Func`2<Type, string> columnTypeFromClrType);
    public static DataTable CreateFromString(string tableName, string columnName, string columnValue);
    public static DataTable CreateFromStrings(string tableName, string columnName, IEnumerable`1<string> columnValues);
    public static DataTable CreateFromRows(string tableName, IEnumerable`1<TRow> data);
    public static DataTable CreateFromRows(IEnumerable`1<DataRow> rows);
    public static DataTable FromDataReader(IDataReader reader, Boolean& moreData);
    public static DataTable FromDataReader(IDataReader reader, bool disposeReader);
    [ExtensionAttribute]
public static IDataReader CreateDataReaderEx(DataTable dataTable, ITraceSource tracer);
    [ExtensionAttribute]
public static DataTable GetSchemaTableFromDataTable(DataTable table);
    [ExtensionAttribute]
public static Guid GetTableId(DataTable table);
    [ExtensionAttribute]
public static void SetTableId(DataTable table, Guid tableId);
    [ExtensionAttribute]
public static string ToStringEx(DataTable table, string title, bool tabify, bool firstOnly);
    [ExtensionAttribute]
public static IEnumerable`1<TRow> ToEnumerable(DataTable table);
    [ExtensionAttribute]
public static IEnumerable`1<DataColumn> GetColumnsEx(DataTable table);
    private static void Columns_CollectionChanged(object sender, CollectionChangeEventArgs e);
    [ExtensionAttribute]
public static DataTable AppendFormattedTemplateColumn(DataTable dataTable, string appendColumnName, string formatTemplateColumnName, string propertiesColumnName);
    [ExtensionAttribute]
public static DataColumn AppendColumn(DataTable dataTable, string columnName, Type clrColumnType);
    [ExtensionAttribute]
public static DataTable AppendCalculatedColumn(DataTable dataTable, string columnName, Func`2<DataRow, T> columnCalculator);
    public static bool DeduplicateColumnNames(String[] columnNameArray, bool caseSensitive);
    private static int GenerateUniqueName(Dictionary`2<string, int> hash, String& columnName, int index, int uniqueIndex, bool caseSensitive);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Data.ExtendedSqlDecimal : object {
    public static string SqlDecimalIgnoreOverflowFeatureFlag;
    private static Tweak`1<bool> s_ignoreOverflowTweak;
    private static Int64[] s_exponents;
    public static SqlDecimal SqlDecimalZero;
    private static ExtendedSqlDecimal();
    public static Nullable`1<SqlDecimal> Convert(object value);
    public static bool TryParse(string value, Nullable`1& result);
    [ExtensionAttribute]
public static decimal ToDecimal(SqlDecimal value);
    public static Nullable`1<SqlDecimal> Parse(string value);
    private static ValueTuple`2<int, int> GetMinimumPrecisionAndScale(string decimalStr);
}
internal class Kusto.Cloud.Platform.Data.FakeSqlDataReader : object {
    private IDataReader m_instance;
    private MethodInfo m_getSqlValue;
    private FakeSqlDataReader(IDataReader instance, MethodInfo getSqlValue);
    public static FakeSqlDataReader FromDataReaderOrNull(IDataReader candidate);
    public Func`1<object> CreateColumnReader(int ordinal);
}
internal class Kusto.Cloud.Platform.Data.FieldSetter : object {
    private FieldInfo m_fieldInfo;
    private HowToSet m_howToSet;
    private FieldSetter[] m_setters;
    private Object[] m_constructorArgs;
    private ConstructorInfo m_constructorInfo;
    public FieldSetter(FieldInfo fieldInfo);
    public int Set(object obj, IDataReader reader, int readerDataIndex);
}
public interface Kusto.Cloud.Platform.Data.IDataReaderEx {
    public abstract virtual string GetTableName();
    public abstract virtual Guid GetTableId();
}
public interface Kusto.Cloud.Platform.Data.IDataReaderProvider {
    public abstract virtual IDataReader ToDataReader(object context, IReadOnlyDictionary`2<string, object> namedArgs);
}
public interface Kusto.Cloud.Platform.Data.IExtendedDataReaderArtifactCreator`1 {
    public abstract virtual ValueAndPath`1<TValue> GetOrCreateArtifact(Object[] values);
    public abstract virtual void InvalidateArtifact(ValueAndPath`1<TValue> writer);
}
internal interface Kusto.Cloud.Platform.Data.ILimitedLengthDataReader {
    public long RemainingAllowedRows { get; public set; }
    public abstract virtual long get_RemainingAllowedRows();
    public abstract virtual void set_RemainingAllowedRows(long value);
}
public interface Kusto.Cloud.Platform.Data.ITextWriterCreator {
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Data.KustoSqlException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public KustoSqlException(string message, Exception innerException);
    protected KustoSqlException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Data.LimitedLengthDataReader : object {
    protected IDataReader m_inner;
    [CompilerGeneratedAttribute]
private long <RemainingAllowedRows>k__BackingField;
    public long RemainingAllowedRows { get; public set; }
    public int Depth { get; }
    public int FieldCount { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    public LimitedLengthDataReader(IDataReader inner, long maximumAllowedRows);
    [CompilerGeneratedAttribute]
public sealed virtual long get_RemainingAllowedRows();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemainingAllowedRows(long value);
    public void SetRemainingRows(long remainingAllowedRows);
    public sealed virtual bool Read();
    public sealed virtual bool NextResult();
    public sealed virtual int get_Depth();
    public sealed virtual int get_FieldCount();
    public sealed virtual bool get_IsClosed();
    public sealed virtual object get_Item(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual int get_RecordsAffected();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public string GetTableName();
    public Guid GetTableId();
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual char GetChar(int i);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual string GetString(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool IsDBNull(int i);
}
public class Kusto.Cloud.Platform.Data.MaterializedDataReader : DataReaderBase {
    private List`1<MaterializedDataReaderResult> m_tables;
    private bool m_closed;
    private int m_currentTableIndex;
    private MaterializedDataReaderResult m_currentTable;
    private int m_currentRowIndex;
    private MaterializedDataReaderResult CurrentTable { get; }
    private int CurrentRowIndex { get; }
    public int FieldCount { get; }
    public bool IsClosed { get; }
    public MaterializedDataReader(IDataReader inner);
    private MaterializedDataReaderResult get_CurrentTable();
    private int get_CurrentRowIndex();
    public virtual void Close();
    public virtual void Dispose();
    public virtual int get_FieldCount();
    public virtual Type GetFieldType(int i);
    public virtual int GetOrdinal(string name);
    public virtual string GetName(int i);
    public virtual DataTable GetSchemaTable();
    public sealed virtual Guid GetTableId();
    public sealed virtual string GetTableName();
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public virtual bool get_IsClosed();
    public virtual bool NextResult();
    public virtual bool Read();
}
public class Kusto.Cloud.Platform.Data.ObjectReader`1 : object {
    private IDataReader m_reader;
    private bool m_disposeReader;
    private TypeMaker`1<T> m_typeMaker;
    private bool m_nameBasedColumnMapping;
    private bool m_enumerated;
    public ObjectReader`1(IDataReader reader);
    public ObjectReader`1(IDataReader reader, bool disposeReader);
    public ObjectReader`1(IDataReader reader, bool disposeReader, bool nameBasedColumnMapping);
    internal ObjectReader`1(IDataReader reader, bool disposeReader, TypeMaker`1<T> typeMaker, bool nameBasedColumnMapping);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Kusto.Cloud.Platform.Data.ObjectReaderFactory`1 : object {
    private TypeMaker`1<T> m_typeMaker;
    public ObjectReaderFactory`1(bool nameBasedColumnMapping);
    public ObjectReader`1<T> Create(IDataReader reader, bool disposeReader);
}
public class Kusto.Cloud.Platform.Data.SequencingDataReader : SequencingDataReaderBase {
    public SequencingDataReader(IDataReader[] readers);
    public virtual bool NextResult();
    public virtual bool Read();
}
[DefaultMemberAttribute("Item")]
public abstract class Kusto.Cloud.Platform.Data.SequencingDataReaderBase : object {
    protected Queue`1<IDataReader> m_readers;
    public int Depth { get; }
    public int FieldCount { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    protected SequencingDataReaderBase(IEnumerable`1<IDataReader> readers);
    protected SequencingDataReaderBase(IDataReader[] readers);
    public void Add(IDataReader reader);
    public void AddRange(IDataReader[] readers);
    public void AddRange(IEnumerable`1<IDataReader> readers);
    protected IDataReader Current();
    private void TransferOwnershipTo(SequencingDataReaderBase target);
    public sealed virtual int get_Depth();
    public sealed virtual int get_FieldCount();
    public sealed virtual bool get_IsClosed();
    public sealed virtual object get_Item(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual int get_RecordsAffected();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual char GetChar(int i);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual string GetString(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool IsDBNull(int i);
    public abstract virtual bool NextResult();
    public abstract virtual bool Read();
}
public class Kusto.Cloud.Platform.Data.SingleTableSequencingDataReader : SequencingDataReaderBase {
    public SingleTableSequencingDataReader(IDataReader[] readers);
    public virtual bool Read();
    public virtual bool NextResult();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Data.TsvWriterException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public TsvWriterException(string message, Exception innerException);
    protected TsvWriterException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Kusto.Cloud.Platform.Data.TypeMaker`1 : object {
    private FieldSetter[] m_setters;
    private FieldInfo[] m_fields;
    private Type m_type;
    private Int32[] m_fieldLookup;
    private bool m_initialized;
    private bool m_nameBasedColumnMapping;
    private bool m_hasParameterlessConstructor;
    private bool m_typeIsScalar;
    private bool m_isAnonymous;
    private bool m_JTokenIsAssignableFromThisType;
    private Object[] m_parameterlessConstructorDefaultArgs;
    public TypeMaker`1(bool nameBasedColumnMapping);
    private void Initialize(IDataReader reader);
    public T Create(IDataReader reader);
    private T CreateUninitializedInstance();
}
public class Kusto.Cloud.Platform.Data.ValueAndPath`1 : object {
    [CompilerGeneratedAttribute]
private TValue <Writer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public TValue Writer { get; private set; }
    public string Path { get; private set; }
    public ValueAndPath`1(string path, TValue writer);
    [CompilerGeneratedAttribute]
public TValue get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(TValue value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public class Kusto.Cloud.Platform.Data.WriteResults : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeInBytes>k__BackingField;
    public string Path { get; private set; }
    public long NumLines { get; private set; }
    public long SizeInBytes { get; private set; }
    public WriteResults(string path, long numLines, long sizeInBytes);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public long get_NumLines();
    [CompilerGeneratedAttribute]
private void set_NumLines(long value);
    [CompilerGeneratedAttribute]
public long get_SizeInBytes();
    [CompilerGeneratedAttribute]
private void set_SizeInBytes(long value);
}
public static class Kusto.Cloud.Platform.Debugging : object {
    public static Dictionary`2<string, CommunicationChannelPoolBase> CommunicationChannelPools;
    private static object s_lock;
    private static Dictionary`2<string, WeakReference> s_weakReferences;
    private static Dictionary`2<string, Dictionary`2<string, WeakReference>> s_weakReferences2;
    private static Debugging();
    public static void InvokeUnderLock(Action action);
    public static T InvokeUnderLock(Func`1<T> func);
    public static void RegisterWeakReference(string name, object value);
    public static void UnRegisterWeakReference(string name);
    public static object GetWeakReferenceOrNull(string name);
    public static bool RegisterWeakReferenceOfType(string type, string name, object value);
    public static void UnRegisterWeakReferenceOfType(string type, string name);
    public static List`1<Tuple`2<string, object>> GetAllWeakReferencesOfTypeOrNull(string type);
    public static void CleanupWeakReferencesOfType();
}
[AttributeUsageAttribute("24516")]
[ConditionalAttribute("DEVTOOLS_ANNOTATIONS")]
internal class Kusto.Cloud.Platform.DevTools.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("24516")]
[ConditionalAttribute("DEVTOOLS_ANNOTATIONS")]
internal class Kusto.Cloud.Platform.DevTools.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
[ConditionalAttribute("DEVTOOLS_ANNOTATIONS")]
internal class Kusto.Cloud.Platform.DevTools.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
}
public abstract class Kusto.Cloud.Platform.Distributed.DistributedLockOwnerBase : object {
    private static AcquireLockAndInvokeCallbackActivityType s_acquireLockAndInvokeCallbackActivityType;
    private IDistributedLockFactory m_distributedLockFactory;
    private string m_lockName;
    private string m_typeName;
    private ILockRulesManager m_lockRulesManager;
    protected object m_lock;
    private IDistributedLock m_distributedLock;
    protected int m_pendingOperations;
    protected ManualResetEvent m_stopEvent;
    private bool m_disposed;
    private PrivateTracer m_tracer;
    protected DistributedLockOwnerBase(string ownerName, IDistributedLockFactory distributedLockFactory, string lockName, TimeSpan leaseDuration, TimeSpan renewInterval, TimeSpan pollInterval, ILockRulesManager lockRulesManager);
    private static DistributedLockOwnerBase();
    public virtual void Dispose();
    protected bool LockIsAcquired();
    protected TriState LockGetState(bool onlyIfCurrentlyAcquired, ImmutableDictionary`2& state);
    protected TriState LockSetState(ImmutableDictionary`2<string, string> state, bool shouldRetry);
    protected TriState LockRelease();
    protected void Start(bool blockUntilFirstAttempt);
    protected abstract virtual void OnLockAcquired(ManualResetEventSlim ev);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Distributed.DistributedLockOwnerBase/<AcquireLockAndInvokeCallback>d__19")]
private Task AcquireLockAndInvokeCallback(ManualResetEventSlim ev);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Distributed.DistributedLockOwnerBase/<AcquireLockAndInvokeCallbackLoop>d__20")]
private Task AcquireLockAndInvokeCallbackLoop(ManualResetEventSlim ev);
}
public class Kusto.Cloud.Platform.Distributed.DistributedLockState : object {
    public bool IsAcquired;
    public DateTime LastUpdateTimeService;
    public DateTime LastUpdateTimeUser;
    public ImmutableDictionary`2<string, string> UserState;
}
public static class Kusto.Cloud.Platform.Distributed.ExtendedDistributedLock : object {
    public static string Timestamp;
    public static string UserState;
    public static ImmutableDictionary`2<string, string> EmptyUserState;
    private static ExtendedDistributedLock();
    public static string Pack(Nullable`1<DateTime> timestamp, ImmutableDictionary`2<string, string> userState);
    public static ImmutableDictionary`2<string, string> Unpack(string content, DateTime& timestamp);
    public static ImmutableDictionary`2<string, string> Unpack(string content);
}
public class Kusto.Cloud.Platform.Distributed.FileSystemDistributedLock : object {
    private static int ERROR_SHARING_VIOLATION;
    private object m_lock;
    private bool m_disposeInvoked;
    private int m_runningOperations;
    private CancellationTokenSource m_cts;
    private string m_filename;
    private DateTime m_lastTimestamp;
    private ImmutableDictionary`2<string, string> m_lastState;
    private FileStream m_writeStream;
    private TimeSpan m_pollingInterval;
    public string FullName { get; }
    internal FileSystemDistributedLock(string baseDir, string name, TimeSpan pollingInterval);
    public sealed virtual void Dispose();
    public sealed virtual string get_FullName();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Distributed.FileSystemDistributedLock/<AcquireAsync>d__14")]
public sealed virtual Task`1<IDisposable> AcquireAsync(ManualResetEventSlim ev);
    private void ThrowIfDisposedUnderLock(string methodName);
    public sealed virtual Task`1<DistributedLockState> GetCurrentStateAsync(bool checkIfAcquiredByAnyone);
    public sealed virtual Task`1<DistributedLockState> GetCurrentStateAsync();
    public sealed virtual Task`1<bool> DoesLockExistAsync();
    public sealed virtual Task`1<bool> SetCurrentStateAsync(ImmutableDictionary`2<string, string> state, bool shouldRetry);
    public sealed virtual Task ReleaseAsync();
    public sealed virtual bool IsAcquired();
    private void IncrementRunningOperationsUnderLock();
    private void DecrementRunningOperationsUnderLock();
    private ImmutableDictionary`2<string, string> Read(string filename);
    private ImmutableDictionary`2<string, string> TryRead(string filename);
    private static FileStream TryAcquireUnderLock(FileStream writeStream, string filename, Boolean& alreadyOwned);
    private void Write(ImmutableDictionary`2<string, string> state);
    private FileStream TryAcquireAndWriteUnderLock(ImmutableDictionary`2<string, string> state);
    [CompilerGeneratedAttribute]
private void <AcquireAsync>b__14_0();
    [CompilerGeneratedAttribute]
private void <ReleaseAsync>b__20_0();
}
public class Kusto.Cloud.Platform.Distributed.FileSystemDistributedLockFactory : object {
    private static string c_lockExtension;
    private static int ERROR_SHARING_VIOLATION;
    private string m_baseDir;
    private string m_name;
    private TimeSpan m_pollingInterval;
    public string Name { get; }
    public FileSystemDistributedLockFactory(string baseDir, int pollingInvervalInMilliseconds);
    internal static void EnsureAppropriateFileSystem();
    public sealed virtual string get_Name();
    public sealed virtual IDistributedLock CreateLock(string name, TimeSpan leaseDuration, TimeSpan renewIntervalIn, TimeSpan pollingInterval, ManualResetEvent stopEvent);
    public sealed virtual IDistributedLockReader CreateLockReader(string name);
    public sealed virtual IEnumerable`1<string> EnumerateLocks(bool acquiredOnly);
    public sealed virtual IEnumerable`1<string> EnumerateLocks(string prefix, bool acquiredOnly);
    public sealed virtual void ClearLocks(string prefix);
    private bool IsAcquired(string filename);
}
public interface Kusto.Cloud.Platform.Distributed.IDistributedLock {
    public string FullName { get; }
    public abstract virtual string get_FullName();
    public abstract virtual Task`1<IDisposable> AcquireAsync(ManualResetEventSlim ev);
    public abstract virtual Task`1<DistributedLockState> GetCurrentStateAsync(bool checkIfAcquiredByAnyone);
    public abstract virtual Task`1<bool> SetCurrentStateAsync(ImmutableDictionary`2<string, string> state, bool shouldRetry);
    public abstract virtual Task ReleaseAsync();
    public abstract virtual bool IsAcquired();
}
public interface Kusto.Cloud.Platform.Distributed.IDistributedLockFactory {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IDistributedLock CreateLock(string name, TimeSpan leaseDuration, TimeSpan renewInterval, TimeSpan pollingInterval, ManualResetEvent stopEvent);
    public abstract virtual IDistributedLockReader CreateLockReader(string name);
    public abstract virtual IEnumerable`1<string> EnumerateLocks(bool acquiredOnly);
    public abstract virtual IEnumerable`1<string> EnumerateLocks(string prefix, bool acquiredOnly);
    public abstract virtual void ClearLocks(string prefix);
}
public interface Kusto.Cloud.Platform.Distributed.IDistributedLockReader {
    public string FullName { get; }
    public abstract virtual string get_FullName();
    public abstract virtual Task`1<DistributedLockState> GetCurrentStateAsync();
    public abstract virtual Task`1<bool> DoesLockExistAsync();
}
public interface Kusto.Cloud.Platform.Distributed.ILockRulesManager {
    public abstract virtual bool IsMarkLockedStateAllowed(string lockName);
    public abstract virtual bool MarkLockedStateIfAllowed(string lockName);
    public abstract virtual void MarkFreeState(string lockName);
}
public class Kusto.Cloud.Platform.Distributed.VoidDistributedLockFactory : object {
    private object m_locker;
    private Dictionary`2<string, VoidDistributedLock> m_locks;
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual void ClearLocks(string prefix);
    public sealed virtual IDistributedLock CreateLock(string name, TimeSpan leaseDuration, TimeSpan renewInterval, TimeSpan pollingInterval, ManualResetEvent stopEvent);
    public sealed virtual IDistributedLockReader CreateLockReader(string name);
    private VoidDistributedLock GetOrCreateNew(string name, string operation);
    public sealed virtual IEnumerable`1<string> EnumerateLocks(bool acquiredOnly);
    public sealed virtual IEnumerable`1<string> EnumerateLocks(string prefix, bool acquiredOnly);
}
public class Kusto.Cloud.Platform.Distributed.VoidLockRulesManager : object {
    public sealed virtual bool IsMarkLockedStateAllowed(string lockName);
    public sealed virtual bool MarkLockedStateIfAllowed(string lockName);
    public sealed virtual void MarkFreeState(string lockName);
}
public static class Kusto.Cloud.Platform.Http.Authentication : object {
    public static string AuthorizationHeaderName;
    public static string WwwAuthenticateHeaderName;
    public static string BasicScheme;
    public static string BearerScheme;
    public static string RealmParameter;
    public static string CharsetParameter;
    public static string ScopeParameter;
    public static string AccessTokenParameter;
    public static string UserImpersonationScope;
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Http.ExtendedHttpRequestHeaders : object {
    [ThreadStaticAttribute]
private static StringBuilder s_stringBuilderCache;
    [ExtensionAttribute]
public static string GetFirstHeaderValueOrNull(HttpRequestHeaders headers, string name);
    [ExtensionAttribute]
public static void AddNormalizedRequestHeader(HttpRequestHeaders headers, string name, string value);
    private static string NormalizeRequestHeaderValue(string value);
}
public interface Kusto.Cloud.Platform.Http.IKustoHttpClientFactory {
    public string DumpRequestResponseHeaderName { get; }
    public abstract virtual HttpClient GetOrCreateHttpClient(Uri uri);
    public abstract virtual HttpClient CreateNewHttpClient(Uri uri);
    public abstract virtual string get_DumpRequestResponseHeaderName();
}
public class Kusto.Cloud.Platform.Http.KustoHttpClient : object {
    protected ITraceSource m_tracer;
    protected string m_tracePrefixShort;
    protected string m_tracePrefixLong;
    protected KustoHttpClient(ITraceSource tracer, string tracePrefixShort, string tracePrefixLong);
    protected IDumper DumpRequest(IKustoHttpClientFactory httpClientFactory, HttpRequestMessage requestMessage, string dumperType);
    protected void DumpResponse(HttpResponseMessage responseMessage, IDumper dumper);
    protected string GetStatusCodeString(HttpStatusCodeEx statusCode);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Http.KustoHttpClient/<GetResponseStreamAsync>d__8")]
protected Task`1<StreamAndItsEncoding> GetResponseStreamAsync(HttpContent responseContent, string contentId, bool shouldBuffer, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Http.KustoHttpClient/<GetDecompressedResponseStreamAsync>d__9")]
protected Task`1<Stream> GetDecompressedResponseStreamAsync(HttpContent responseContent, string contentId, bool shouldBuffer, Nullable`1<TimeSpan> timeout);
    public static string GetFirstHeaderOrNull(HttpHeaders headers, string headerName);
}
public class Kusto.Cloud.Platform.Http.KustoHttpClientFactory : object {
    public static string WebProxyTweakName;
    private static Tweak`1<string> s_webProxyTweak;
    private string m_id;
    private TimeSpan m_lifetime;
    private HttpMessageHandler m_handler;
    private ITraceSource m_tracer;
    private object m_lock;
    private Timer m_timer;
    private HttpMessageHandler m_httpMessageHandler;
    private string m_dumpRequestResponseHeaderName;
    private HttpClient m_client;
    public string DumpRequestResponseHeaderName { get; }
    public KustoHttpClientFactory(string id, Nullable`1<TimeSpan> lifetime, Nullable`1<bool> automaticDecompression, HttpMessageHandler handler, ITraceSource tracer);
    private static KustoHttpClientFactory();
    public sealed virtual void Dispose();
    public sealed virtual HttpClient CreateNewHttpClient(Uri uri);
    public sealed virtual HttpClient GetOrCreateHttpClient(Uri uri);
    public sealed virtual string get_DumpRequestResponseHeaderName();
    private void SetWebProxy(HttpClientHandler httpMessageHandler, string webProxy);
    private void OnTimer_ReleaseHttpClient(object state);
    private HttpMessageHandler CreateHttpMessageHandler(Nullable`1<bool> automaticDecompression);
}
public class Kusto.Cloud.Platform.Http.RequestDumperHttpMessageHandler : DelegatingHandler {
    public static string OptionClientDumpHttpRequestResponse;
    public static string OptionClientDumpHttpRequestResponse_Console;
    public static string OptionClientDumpHttpRequestResponse_ConsoleHeaders;
    public static string OptionClientDumpHttpRequestResponse_ConsoleImmediate;
    public static string OptionClientDumpHttpRequestResponse_ConsoleJson;
    public static string OptionClientDumpHttpRequestResponse_Default;
    public static string OptionClientDumpHttpRequestResponse_File;
    public static string OptionClientDumpHttpRequestResponse_None;
    public static string OptionClientDumpHttpRequestResponse_Trace;
    private static long s_counter;
    private string m_dumpRequestResponseHeaderName;
    public RequestDumperHttpMessageHandler(HttpMessageHandler innerHandler, string dumpRequestResponseHeaderName);
    public static IDumper CreateDumperOrNull(string dumperType);
    protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Http.RequestDumperHttpMessageHandler/<DumpAndSendAsync>d__14")]
private Task`1<HttpResponseMessage> DumpAndSendAsync(IDumper dumper, HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Kusto.Cloud.Platform.Instrumentation.AuditEvent : object {
    public static string PropertyName_ErrorMessage;
    public static string PropertyName_HttpRequestHeaders;
    public static string PropertyName_HttpAuthorizationHeader;
    public static string PropertyName_TokenClaims;
    public static string PropertyName_ClientRequestProperties;
    [CompilerGeneratedAttribute]
private OperationTypeForAudit <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationScopeForAudit <OperationScope>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <OperationTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationText>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationResultForAudit <OperationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsIdentity <PrincipalIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsIdentity <OnBehalfOfIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetResourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalProperties>k__BackingField;
    public OperationTypeForAudit OperationType { get; public set; }
    public OperationScopeForAudit OperationScope { get; public set; }
    public DateTime OperationTimestamp { get; public set; }
    public string OperationText { get; public set; }
    public OperationResultForAudit OperationResult { get; public set; }
    public ClaimsIdentity PrincipalIdentity { get; public set; }
    public ClaimsIdentity OnBehalfOfIdentity { get; public set; }
    public string TargetResourceIdentifier { get; public set; }
    public string ClientRequestId { get; public set; }
    public string ClientAddress { get; public set; }
    public string CallerAgent { get; public set; }
    public Dictionary`2<string, string> AdditionalProperties { get; private set; }
    private static AuditEvent();
    [CompilerGeneratedAttribute]
public OperationTypeForAudit get_OperationType();
    [CompilerGeneratedAttribute]
public void set_OperationType(OperationTypeForAudit value);
    [CompilerGeneratedAttribute]
public OperationScopeForAudit get_OperationScope();
    [CompilerGeneratedAttribute]
public void set_OperationScope(OperationScopeForAudit value);
    [CompilerGeneratedAttribute]
public DateTime get_OperationTimestamp();
    [CompilerGeneratedAttribute]
public void set_OperationTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_OperationText();
    [CompilerGeneratedAttribute]
public void set_OperationText(string value);
    [CompilerGeneratedAttribute]
public OperationResultForAudit get_OperationResult();
    [CompilerGeneratedAttribute]
public void set_OperationResult(OperationResultForAudit value);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_PrincipalIdentity();
    [CompilerGeneratedAttribute]
public void set_PrincipalIdentity(ClaimsIdentity value);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_OnBehalfOfIdentity();
    [CompilerGeneratedAttribute]
public void set_OnBehalfOfIdentity(ClaimsIdentity value);
    [CompilerGeneratedAttribute]
public string get_TargetResourceIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetResourceIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_ClientRequestId();
    [CompilerGeneratedAttribute]
public void set_ClientRequestId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientAddress();
    [CompilerGeneratedAttribute]
public void set_ClientAddress(string value);
    [CompilerGeneratedAttribute]
public string get_CallerAgent();
    [CompilerGeneratedAttribute]
public void set_CallerAgent(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
private void set_AdditionalProperties(Dictionary`2<string, string> value);
    public void AddAdditionalProperty(string key, string value);
    public virtual string ToString();
    public string ToUnsafeString();
}
public class Kusto.Cloud.Platform.Instrumentation.CustomNamespacedMonitoringClient : object {
    private IMonitoringClient m_monitoringClient;
    private string m_metricNamespace;
    private string m_nodeId;
    public string GenevaMonitoringAccount { get; }
    public string KustoAccount { get; }
    public string ClusterAlias { get; }
    public string DataCenter { get; }
    public string CloudName { get; }
    public string DeploymentRing { get; }
    public string ResourceId { get; }
    public string VirtualClusterName { get; }
    public CustomNamespacedMonitoringClient(IMonitoringClient monitoringClient, string metricNamespace, string nodeId);
    public sealed virtual ICustomMetric CreateCustomMetric(string metricName);
    public sealed virtual void Initialize(IEnumerable`1<MetricDefinition> metrics);
    public sealed virtual ICustomMetric CreateCustomMetric(string metricName, string metricNamespace);
    public sealed virtual void SendArbitraryMetric(MetricDefinition definition, long rawData, String[] dimensionValues);
    public sealed virtual void SendMetric(string metricName, long rawData, string mdmNamespace);
    public sealed virtual void SendMetric(string metricName, double rawData, string mdmNamespace);
    public sealed virtual void SendMetric(ICustomMetric metric, long rawData);
    public sealed virtual void SendMetric(ICustomMetric metric, double rawData);
    public sealed virtual void SendMetricWithNodeIdDimension(ICustomMetric metric, long rawData);
    public sealed virtual string get_GenevaMonitoringAccount();
    public sealed virtual string get_KustoAccount();
    public sealed virtual string get_ClusterAlias();
    public sealed virtual string get_DataCenter();
    public sealed virtual string get_CloudName();
    public sealed virtual string get_DeploymentRing();
    public sealed virtual string get_ResourceId();
    public sealed virtual string get_VirtualClusterName();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Instrumentation.ExtendedOperationResultForAudit : object {
    [ExtensionAttribute]
public static string FastToString(OperationResultForAudit that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationResultForAudit that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationResultForAudit that, OperationResultForAudit flag);
    public static OperationResultForAudit FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, OperationResultForAudit& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(OperationResultForAudit that);
    [ExtensionAttribute]
public static string FastGetDescription(OperationResultForAudit that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Instrumentation.ExtendedOperationScopeForAudit : object {
    [ExtensionAttribute]
public static string FastToString(OperationScopeForAudit that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationScopeForAudit that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationScopeForAudit that, OperationScopeForAudit flag);
    public static OperationScopeForAudit FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, OperationScopeForAudit& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(OperationScopeForAudit that);
    [ExtensionAttribute]
public static string FastGetDescription(OperationScopeForAudit that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Instrumentation.ExtendedOperationTypeForAudit : object {
    [ExtensionAttribute]
public static string FastToString(OperationTypeForAudit that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationTypeForAudit that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(OperationTypeForAudit that, OperationTypeForAudit flag);
    public static OperationTypeForAudit FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, OperationTypeForAudit& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(OperationTypeForAudit that);
    [ExtensionAttribute]
public static string FastGetDescription(OperationTypeForAudit that);
}
public interface Kusto.Cloud.Platform.Instrumentation.IAuditClient2 {
    public abstract virtual bool LogOperation(AuditEvent context);
}
public interface Kusto.Cloud.Platform.Instrumentation.IAuditLogClient {
    public abstract virtual bool WriteGeneralEventOperation(string operationName, ClaimsIdentity identity, string clientIp, TargetResourceScope targetResourceScope, string targetResourceName, string fullOperation, bool operationSuccess);
    public abstract virtual bool WriteAuthenticationEventOperation(string identityString, string clientIp, bool operationSuccess);
    public abstract virtual bool WriteAuthorizationEventOperation(ClaimsIdentity identity, string clientIp, bool operationSuccess);
    public abstract virtual bool WriteKeyManagementEventOperation(string operationName, string userName, string clientIp, TargetResourceScope targetResourceScope, string targetResourceName, bool operationSuccess);
    public abstract virtual bool WriteRoleManagementEventOperation(string operationName, string userName, string clientIp, TargetResourceScope targetResourceScope, string targetResourceName, bool operationSuccess);
    public abstract virtual bool WriteResourceManagementEventOperation(string operationName, string userName, string clientIp, TargetResourceScope targetResourceScope, string targetResourceName, bool operationSuccess);
}
public interface Kusto.Cloud.Platform.Instrumentation.ICustomMetric {
    public MetricDefinition Definition { get; }
    public String[] DimensionValues { get; }
    public abstract virtual MetricDefinition get_Definition();
    public abstract virtual String[] get_DimensionValues();
    public abstract virtual void AddDimension(string name, string value);
}
public interface Kusto.Cloud.Platform.Instrumentation.ICustomNamespacedMonitoringClient {
    public abstract virtual ICustomMetric CreateCustomMetric(string metricName);
    public abstract virtual void SendMetricWithNodeIdDimension(ICustomMetric metric, long rawData);
}
public interface Kusto.Cloud.Platform.Instrumentation.IMonitoringClient {
    public string GenevaMonitoringAccount { get; }
    public string KustoAccount { get; }
    public string ClusterAlias { get; }
    public string DataCenter { get; }
    public string CloudName { get; }
    public string DeploymentRing { get; }
    public string ResourceId { get; }
    public string VirtualClusterName { get; }
    public abstract virtual void Initialize(IEnumerable`1<MetricDefinition> metrics);
    public abstract virtual ICustomMetric CreateCustomMetric(string metricName, string metricNamespace);
    public abstract virtual void SendArbitraryMetric(MetricDefinition definition, long rawData, String[] dimensionValues);
    public abstract virtual void SendMetric(string metricName, long rawData, string mdmNamespace);
    public abstract virtual void SendMetric(string metricName, double rawData, string mdmNamespace);
    public abstract virtual void SendMetric(ICustomMetric metric, long rawData);
    public abstract virtual void SendMetric(ICustomMetric metric, double rawData);
    public abstract virtual string get_GenevaMonitoringAccount();
    public abstract virtual string get_KustoAccount();
    public abstract virtual string get_ClusterAlias();
    public abstract virtual string get_DataCenter();
    public abstract virtual string get_CloudName();
    public abstract virtual string get_DeploymentRing();
    public abstract virtual string get_ResourceId();
    public abstract virtual string get_VirtualClusterName();
}
public class Kusto.Cloud.Platform.Instrumentation.MetricDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DimensionNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldTraceSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSendToGenevaMetricStore>k__BackingField;
    public string Name { get; }
    public string Namespace { get; }
    public String[] DimensionNames { get; }
    public bool ShouldTraceSuccess { get; }
    public bool ShouldSendToGenevaMetricStore { get; }
    public MetricDefinition(string name, string ns, bool shouldTraceSuccess, bool shouldSendToGenevaMetricStore);
    public MetricDefinition(string name, string ns, String[] dimensionNames, bool shouldTraceSuccess, bool shouldSendToGenevaMetricStore);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public String[] get_DimensionNames();
    [CompilerGeneratedAttribute]
public bool get_ShouldTraceSuccess();
    [CompilerGeneratedAttribute]
public bool get_ShouldSendToGenevaMetricStore();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Instrumentation.MonitoringClientExtension : object {
    [ExtensionAttribute]
public static void SendMetrics(IMonitoringClient mdmClient, string metricName, long rawData, IReadOnlyDictionary`2<string, string> dimensions, string metricNamespace, ITraceSource tracer, string operationType, string statusCode, string operationName);
}
public static class Kusto.Cloud.Platform.Instrumentation.MonitoringConsts : object {
    public static string OperationLatency;
    public static string StatusCode;
    public static string OperationType;
    public static string OperationName;
}
public enum Kusto.Cloud.Platform.Instrumentation.OperationResultForAudit : Enum {
    public int value__;
    public static OperationResultForAudit Failure;
    public static OperationResultForAudit Success;
}
public enum Kusto.Cloud.Platform.Instrumentation.OperationScopeForAudit : Enum {
    public int value__;
    public static OperationScopeForAudit Undefined;
    public static OperationScopeForAudit Cluster;
    public static OperationScopeForAudit Database;
}
public enum Kusto.Cloud.Platform.Instrumentation.OperationTypeForAudit : Enum {
    public int value__;
    public static OperationTypeForAudit Undefined;
    public static OperationTypeForAudit Query;
    public static OperationTypeForAudit TdsQuery;
    public static OperationTypeForAudit ControlCommand;
    public static OperationTypeForAudit Authentication;
    public static OperationTypeForAudit Authorization;
    public static OperationTypeForAudit RoleManagementCommand;
    public static OperationTypeForAudit KeyManagementCommand;
    public static OperationTypeForAudit ResourceManagementCommand;
}
public enum Kusto.Cloud.Platform.Instrumentation.TargetResourceScope : Enum {
    public int value__;
    public static TargetResourceScope Cluster;
    public static TargetResourceScope Database;
}
public class Kusto.Cloud.Platform.IO.BlockWriteStream : Stream {
    private static char c_blockIdSeparator;
    private IBlockWriter m_blockWriter;
    private IBufferManager m_bufferManager;
    private string m_blockIdPrefix;
    private int m_blockBufferSize;
    private int m_blockBufferPosition;
    private long m_totalLength;
    private Byte[] m_blockBuffer;
    private int m_blockCounter;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BlockWriteStream(IBlockWriter blockWriter, IBufferManager bufferManager, int blockSizeInBytes);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.IO.BlockWriteStream/<FlushAsync>d__24")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.IO.BlockWriteStream/<CopyFromAsync>d__32")]
public Task CopyFromAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTuple`2<string, string> DecodeBlockId(string blockId);
    private void EnsureNotClosed(string methodName);
    private void EnsureBlockBufferAllocated();
    private void WriteToBuffer(Byte[] buffer, Int32& offset, int count);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.IO.BlockWriteStream/<FlushBufferAsync>d__37")]
private Task FlushBufferAsync(CancellationToken cancellationToken);
    private void FlushBuffer();
    private string GetNextBlockId();
}
public class Kusto.Cloud.Platform.IO.BufferedWriteStream : Stream {
    private static int c_defaultBufferSize;
    private static int c_maxShadowBufferSize;
    private static IBufferManager s_defaultBufferManager;
    private Stream m_stream;
    private Byte[] m_buffer;
    private int m_bufferSize;
    private bool m_leaveOpen;
    private int m_writePos;
    private bool m_asyncWarningIssued;
    private IBufferManager m_bufferManager;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedWriteStream(IBufferManager bufferManager, Stream stream);
    public BufferedWriteStream(IBufferManager bufferManager, Stream stream, int bufferSize);
    public BufferedWriteStream(IBufferManager bufferManager, Stream stream, int bufferSize, bool leaveOpen, bool perfAlert);
    private static BufferedWriteStream();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed(string method);
    private void ErrorNotClosed(string method);
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private void FlushWrite();
}
public class Kusto.Cloud.Platform.IO.BufferedWriteStreamFactory : object {
    private int m_bufferSize;
    private ConcurrentStack`1<Byte[]> m_buffers;
    public BufferedWriteStreamFactory(int bufferSize);
    public BufferedWriteStream CreateBufferedWriteStream(Stream stream, bool leaveOpen, bool perfAlert);
    public sealed virtual Byte[] GetBuffer(int bufferSize);
    public sealed virtual void ReturnBuffer(Byte[] buffer);
}
public interface Kusto.Cloud.Platform.IO.IBlockWriter {
    public abstract virtual void StageBlock(string blockId, Byte[] buffer, int offset, int count);
    public abstract virtual Task StageBlockAsync(string blockId, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual void CommitStagedBlocks();
}
public interface Kusto.Cloud.Platform.IO.IBufferManager {
    public abstract virtual Byte[] GetBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
}
public class Kusto.Cloud.Platform.IO.LiveStreamWrapper : Stream {
    private Stream m_stream;
    private bool m_leaveOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LiveStreamWrapper(Stream stream, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class Kusto.Cloud.Platform.IO.MidStringReaderStream : Stream {
    private string m_id;
    private MidStringReader m_input;
    private Encoder m_encoder;
    private Byte[] m_readByteBuffer;
    private int m_inputPos;
    private long m_bytesWritten;
    public string Id { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MidStringReaderStream(MidStringReader value, Encoding encoding);
    public MidStringReaderStream(string id, MidStringReader value, Encoding encoding);
    public string get_Id();
    public void set_Id(string value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int ReadImpl(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.IO.NetworkDriveMapper : object {
    private static int s_resultCodeForRecreate;
    private static NetworkDriveMapper();
    public static void MapDriveIfNotExists(string driveName, string networkPath, string userName, string password);
    public static void UnmapDrive(string driveName);
    private static int MapDriveImpl(string driveName, string networkPath, string userName, string password, bool saveCredentials, bool persistent, bool forceRemap);
    private static int UnmapDriveImpl(string driveName, bool persistent, bool force);
    private static string GetErrorMsg(bool isMapping, int result, string driveName, string networkPath);
    private static int WNetAddConnection2(NetResource netResource, string password, string username, int flags);
    private static int WNetCancelConnection2(string name, int flags, bool force);
}
public class Kusto.Cloud.Platform.IO.StreamHeader : Stream {
    private Stream m_header;
    private Stream m_source;
    public static Byte[] Yes;
    public static Byte[] No;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public StreamHeader(Byte[] header, Stream source);
    private static StreamHeader();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
public class Kusto.Cloud.Platform.IO.StreamPipe : object {
    private static int c_maxDataInTransit;
    private object m_lock;
    private Action`1<string> m_debug;
    private ReadStreamImpl m_readStream;
    private WriteStreamImpl m_writeStream;
    private bool m_writerIsDone;
    private Byte[] m_buffer;
    private int m_bufferLength;
    private int m_firstValidIndex;
    private int m_numValid;
    public Stream ReadStream { get; }
    public Stream WriteStream { get; }
    public StreamPipe(int maxDataInTransit, Action`1<string> debug);
    public Stream get_ReadStream();
    public Stream get_WriteStream();
    private void WriterIsDone();
    private int Read(Byte[] buffer, int offset, int count);
    private void Write(Byte[] buffer, int offset, int count);
    public static int CyclicCopyFromTo(T[] src, int srcOffset, int srcCount, T[] dst, int dstOffset, int dstCount);
}
public class Kusto.Cloud.Platform.IO.StringStream : Stream {
    private string m_id;
    private string m_input;
    private Encoder m_encoder;
    private Byte[] m_readByteBuffer;
    private int m_inputPos;
    private long m_bytesWritten;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public StringStream(string value, Encoding encoding);
    public StringStream(string id, string value, Encoding encoding);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int ReadImpl(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Json.ClaimConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanWrite();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.ClaimsIdentityConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanWrite();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.DataReaderConverter : JsonConverter {
    private static Thinner s_convertThinner;
    private static Thinner s_writeThinner;
    private static DataReaderConverter();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, object value, JsonSerializer serializer);
    public static IJitStreamSource CreateWriter(IDataReader reader, JsonSerializer serializer);
    internal static void AlertIfNeeded(string scenario, Thinner thinner);
}
public class Kusto.Cloud.Platform.Json.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadJsonImpl(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.DataTableConverter : JsonConverter {
    private Func`2<string, Exception> m_incompleteDataStreamExceptionFactory;
    public DataTableConverter(Func`2<string, Exception> incompleteDataStreamExceptionFactory);
    public virtual bool CanConvert(Type objectType);
    public object ReadJson(JObject jObject, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadJsonImpl(JObject jObject, Type objectType, object existingValue, JsonSerializer serializer);
    private string DeserializeJsonArrayElementAsRawString(JArray jRow, int i);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadJsonImpl(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.DataTableSchema : object {
    private Func`2<string, Type> m_columnTypeToDataTypeMapper;
    public List`1<Type> ColumnTargetTypeList;
    private List`1<string> m_columnNames;
    public DataTableSchema(JToken jColumns, DataColumnCollection columns, Func`2<string, Type> columnTypeToDataTypeMapper);
    private void PopulateDataColumnCollection(JToken jColumns, DataColumnCollection columns);
    private void PopulateDataColumn_AllowDBNull(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_AutoIncrement(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_AutoIncrementSeed(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_AutoIncrementStep(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_Caption(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_DataTimeMode(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_MaxLength(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_ReadOnly(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_Unique(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_ColumnName(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_DataType(JObject jColumn, DataColumn column);
    private void PopulateDataColumn_DefaultValue(JObject jColumn, DataColumn column);
    private void PopulateDataColumn(JObject jColumn, DataColumn column);
}
public class Kusto.Cloud.Platform.Json.DecimalToStringConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.DumpingJsonTextReader : JsonTextReader {
    private static long s_instance;
    private bool m_dumpingEnabled;
    private string m_dumpPrefix;
    private bool m_first;
    public bool DumpingEnabled { get; }
    public DumpingJsonTextReader(TextReader reader);
    public DumpingJsonTextReader(TextReader reader, bool enableDumping);
    public bool get_DumpingEnabled();
    public virtual bool Read();
    public void Dump(string text);
    private void DumpImpl(string text);
    public void Dump(string format, Object[] args);
    private void DumpImpl(string format, Object[] args);
    private bool DumpReadResult(bool ret);
}
public class Kusto.Cloud.Platform.Json.ErrorDataReaderConverter : JsonConverter {
    private static Thinner s_convertThinner;
    private static Thinner s_readThinner;
    private static Thinner s_writeThinner;
    private static ErrorDataReaderConverter();
    public virtual bool CanConvert(Type objectType);
    public object ReadJson(JObject jObject, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadJsonImpl(JObject jObject, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadJsonImpl(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public static void WriteJson(JsonWriter writer, PlatformExceptionDetail ped, JsonSerializer serializer);
}
public static class Kusto.Cloud.Platform.Json.ExtendedJson : object {
    public static JsonLoadSettings LoadSettingsNoLineInfoNoComments;
    private static ExtendedJson();
    public static string WriteAsJsonString(string value);
    public static string WriteAsJsonArray(IEnumerable`1<string> collection);
    public static void SerializeObjectToStream(Stream stream, object value, JsonSerializerSettings settings, Encoding encoding, bool leaveOpen);
    public static void SerializeObjectToStreamAndDispose(Stream stream, object value, Func`2<Exception, Exception> exTranslator, JsonSerializerSettings settings, Encoding encoding);
    public static T DeserializeObjectFromString(string str, JsonSerializerSettings settings);
    public static T DeserializeObjectFromStream(Stream stream, JsonSerializerSettings settings, Encoding encoding);
    public static T DeserializeObjectFromBuffer(Byte[] buffer, JsonSerializerSettings settings, Encoding encoding);
    public static object DeserializeObjectFromStream(Stream stream, Type type, JsonSerializerSettings settings, Encoding encoding);
    public static bool TryDeserializeObjectFromString(string str, T& result);
    public static string SerializeObjectNoFormatting(object obj);
    public static string SerializeObjectWithDefaultSettings(object obj);
    public static string SerializeObjectNoFormattingNoNullValues(object obj);
    public static string SerializeObject(object obj, JsonSerializerSettings settings);
    public static JObject ParsNoLineInfoAndComments(string json);
    public static JObject LoadNoLineInfoAndComments(JsonReader reader);
}
public static class Kusto.Cloud.Platform.Json.ExtendedJsonConverter : object {
    private static HashSet`1<char> s_validJsonStarterCharacters;
    private static ExtendedJsonConverter();
    public static bool TryParseJson(string str, Object& parsed);
    public static T InvokeWithExceptionTranslation(Func`1<T> func);
    public static T SafeFastJsonDeserialize(string input);
}
public static class Kusto.Cloud.Platform.Json.ExtendedJsonSerializer : object {
    private static JsonSerializer s_defaultSerializer;
    public static JsonSerializer GlobalSerializer { get; }
    private static ExtendedJsonSerializer();
    public static JsonSerializer CreateDefaultSerializer();
    public static JsonSerializer CreateSerializer(TraceSourceBase`1<T> traceSource);
    public static JsonSerializer CreateSerializer(Func`2<string, Exception> incompleteDataStreamExceptionFactory);
    public static JsonSerializer CreateSerializer(Func`2<string, Exception> incompleteDataStreamExceptionFactory, TraceSourceBase`1<T> traceSource);
    public static JsonSerializerSettings CreateDefaultSerializerSetting();
    public static JsonSerializerSettings CreateDefaultSerializerSetting(Func`2<string, Exception> incompleteDataStreamExceptionFactory);
    public static JsonSerializer get_GlobalSerializer();
}
public static class Kusto.Cloud.Platform.Json.ExtendedJsonSerializerSettings : object {
    private static JsonSerializerSettings s_defaultSerializerSettings;
    private static JsonSerializerSettings s_defaultSerializerSettingsNoFormatting;
    private static JsonSerializerSettings s_defaultSerializerSettingsCompact;
    private static JsonSerializerSettings s_defaultSerializerSettingsNoFormattingNoNullValues;
    private static DefaultContractResolver s_customJsonResolver;
    public static JsonSerializerSettings GlobalSerializerSettings { get; }
    public static JsonSerializerSettings GlobalSerializerSettingsNoConvertersNoFormatting { get; }
    public static JsonSerializerSettings GlobalSerializerSettingsCompact { get; }
    public static JsonSerializerSettings GlobalSerializerSettingsNoConvertersNoFormattingNoNullValues { get; }
    private static ExtendedJsonSerializerSettings();
    public static JsonSerializerSettings CreateDefaultSerializerSettings(bool ignoreSerializableAttribute, bool autoConvertDateTime, bool convertEnums);
    public static JsonSerializerSettings CreateDefaultSerializerSettings(JsonConverterCollection converters, bool ignoreSerializableAttribute, bool autoConvertDateTime, bool convertEnums);
    private static JsonSerializerSettings CreateDefaultSerializerSettingsWithoutFormatting();
    private static JsonSerializerSettings CreateDefaultSerializerSettingsCompact();
    private static JsonSerializerSettings CreateDefaultSerializerSettingsWithoutFormattingAndNullValues();
    public static JsonSerializerSettings get_GlobalSerializerSettings();
    public static JsonSerializerSettings get_GlobalSerializerSettingsNoConvertersNoFormatting();
    public static JsonSerializerSettings get_GlobalSerializerSettingsCompact();
    public static JsonSerializerSettings get_GlobalSerializerSettingsNoConvertersNoFormattingNoNullValues();
}
public static class Kusto.Cloud.Platform.Json.ExtendedJsonTextReader : object {
    public static JsonTextReader Create(TextReader reader);
    public static JsonTextReader CreateWithJsonSerializer(TextReader reader, JsonSerializer serializer, Nullable`1<int> jsonReaderMaxDepth);
    public static DumpingJsonTextReader CreateDumpingWithJsonSerializer(TextReader reader, JsonSerializer serializer, bool enableDumping, Nullable`1<int> jsonReaderMaxDepth);
}
public static class Kusto.Cloud.Platform.Json.ExtendedJToken : object {
    public static JToken ParseNoDateTimeHandling(string json, JsonLoadSettings loadSettings);
    public static JToken ReadFrom(Byte[] json, JsonLoadSettings loadSettings, Nullable`1<int> jsonReaderMaxDepth);
    public static bool TraverseAndValidate(JToken token, Func`2<JToken, bool> validate, int depthLimit);
}
public class Kusto.Cloud.Platform.Json.OverrideIgnoredColumnContractResolver : DefaultContractResolver {
    private Dictionary`2<Type, HashSet`1<string>> m_typeToColumnsToOverrideIgnore;
    public OverrideIgnoredColumnContractResolver(Dictionary`2<Type, HashSet`1<string>> typeToColumnsToOverrideIgnore);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
}
public class Kusto.Cloud.Platform.Json.PrivateSetterJsonContractResolver : DefaultContractResolver {
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
}
public class Kusto.Cloud.Platform.Json.SecureDictionaryConverter : JsonConverter {
    private HashSet`1<string> m_keysToHide;
    private JsonSerializer m_innerSerializer;
    public SecureDictionaryConverter(IEnumerable`1<string> keysToHide);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter jsonWriter, object value, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.SqlDecimalToStringConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.TimeSpanToTicksConverter : JsonConverter`1<Nullable`1<TimeSpan>> {
    public virtual void WriteJson(JsonWriter writer, Nullable`1<TimeSpan> value, JsonSerializer serializer);
    public virtual Nullable`1<TimeSpan> ReadJson(JsonReader reader, Type objectType, Nullable`1<TimeSpan> existingValue, bool hasExistingValue, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Json.TraceWriterToTraceSourceAdapter`1 : object {
    private TraceSourceBase`1<T> m_traceSource;
    public TraceLevel LevelFilter { get; }
    public TraceWriterToTraceSourceAdapter`1(TraceSourceBase`1<T> traceSource);
    public sealed virtual TraceLevel get_LevelFilter();
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    private static TraceVerbosity ToTraceVerbosity(TraceLevel level);
}
public class Kusto.Cloud.Platform.Json.TrustedTypesSerializationBinder : DefaultSerializationBinder {
    private HashSet`1<string> m_trustedTypeNames;
    public TrustedTypesSerializationBinder(HashSet`1<string> trustedTypeNames);
    public TrustedTypesSerializationBinder(string trustedTypeName);
    public virtual Type BindToType(string assemblyName, string typeName);
}
public class Kusto.Cloud.Platform.Kql.QueryEncoderDecoder : object {
    public static string EncodeQueryAsBase64Url(string query);
    public static string DecodeQueryFromBase64Url(string encodedQuery);
    public static string DecodeQueryFromBase64(string query64Base);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Modularization.ExtendedFeatureFlags : object {
    [ExtensionAttribute]
public static TriState SafeGetOrDontKnow(IFeatureFlags featureFlags, string name);
    [ExtensionAttribute]
public static TriState SafeGetOrDefault(IFeatureFlags featureFlags, string name, TriState valueIfDontKnow);
    [ExtensionAttribute]
public static TriState SafeGetOrTrue(IFeatureFlags featureFlags, string name);
    [ExtensionAttribute]
public static TriState SafeGetOrFalse(IFeatureFlags featureFlags, string name);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[DebuggerTypeProxyAttribute("Kusto.Cloud.Platform.Modularization.FeatureFlags/FeatureFlagsDebuggerProxy")]
public class Kusto.Cloud.Platform.Modularization.FeatureFlags : object {
    private static JsonSerializerSettings s_jsonSerializerSettings;
    private ImmutableDictionary`2<string, TriState> m_flags;
    private string DebuggerDisplay { get; }
    public TriState Item { get; }
    private FeatureFlags(IDictionary`2<string, TriState> dict);
    private FeatureFlags(FeatureFlags featureFlags);
    private static FeatureFlags();
    public static void TraceFeatureFlag(IFeatureFlags featureFlags, ITraceSource tracer, TraceVerbosity verbosity, string tracePrefix, string flagName);
    public sealed virtual void ToDumpString(ExtendedStringBuilder esb, object context);
    private string get_DebuggerDisplay();
    public static FeatureFlags Empty();
    public static FeatureFlags FromFeatureFlags(FeatureFlags featureFlags);
    public static FeatureFlags FromDictionary(IDictionary`2<string, TriState> dict);
    public static FeatureFlags FromJsonString(string serialized, ITraceSource tracer);
    public static FeatureFlags FromJsonString(string serialized, IDictionary`2<string, TriState> additionalFeatureFlags, ITraceSource tracer);
    public static FeatureFlags FromJsonStringWithRemoval(string serialized, HashSet`1<string> featureFlagsToRemove, ITraceSource tracer);
    public static FeatureFlags FromJsonStrings(IEnumerable`1<string> serialized, ITraceSource tracer);
    public static FeatureFlags FromJsonStrings(IEnumerable`1<string> serialized, IDictionary`2<string, TriState> additionalFeatureFlags, ITraceSource tracer);
    public static FeatureFlags FromJsonStringsWithRemoval(IEnumerable`1<string> serialized, HashSet`1<string> featureFlagsToRemove, ITraceSource tracer);
    public static FeatureFlags FromIFeatureFlags(IFeatureFlags featureFlags, IDictionary`2<string, TriState> additionalFeatureFlags);
    public static FeatureFlags Merge(IEnumerable`1<FeatureFlags> collection);
    public string ToJsonString();
    public sealed virtual TriState get_Item(string name);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, TriState>> Enumerate();
    public TriState Get(string name);
    public TriState Set(string name, TriState value);
    public void Remove(string name);
    private void SetTweakIfNeeded(string name, TriState value);
    private static JsonSerializerSettings CreateJsonSerializerSettings();
    public virtual bool Equals(object obj);
    public bool Equals(FeatureFlags other);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public interface Kusto.Cloud.Platform.Modularization.IFeatureFlags {
    public TriState Item { get; }
    public abstract virtual TriState get_Item(string name);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, TriState>> Enumerate();
}
public interface Kusto.Cloud.Platform.Modularization.IServiceLocator {
    public abstract virtual void Register(T provider, string identity, object context, Disposer disposer);
    public abstract virtual void RegisterIfNotExists(Func`2<string, T> providerFactory, string identity, object context, Disposer disposer);
    public abstract virtual ServiceProvider`1<T> Locate(string identity);
    public abstract virtual T TryLocateAndUnwrap(string identity);
    public abstract virtual bool TryLocate(string identity, ServiceProvider`1& provider);
    public abstract virtual IEnumerable`1<ServiceProvider`1<T>> LocateAll();
    public abstract virtual void RegisterForRegistrationNotification(Action`1<ServiceProvider`1<T>> onRegistration);
}
public class Kusto.Cloud.Platform.Modularization.ServiceLocator : object {
    protected QuasistaticConcurrentDictionary`2<Tuple`2<Type, string>, Tuple`3<object, string, object>> m_db;
    private Dictionary`2<Type, List`1<object>> m_callbacks;
    public string ToDumpString();
    public sealed virtual void Register(T provider, string identity, object context, Disposer disposer);
    public sealed virtual void RegisterIfNotExists(Func`2<string, T> providerFactory, string identity, object context, Disposer disposer);
    public sealed virtual bool TryLocate(string identity, ServiceProvider`1& provider);
    public sealed virtual ServiceProvider`1<T> Locate(string identity);
    public sealed virtual T TryLocateAndUnwrap(string identity);
    public sealed virtual IEnumerable`1<ServiceProvider`1<T>> LocateAll();
    public sealed virtual void RegisterForRegistrationNotification(Action`1<ServiceProvider`1<T>> onRegistration);
    private void InvokeCallbacks(ServiceProvider`1<T> provider);
}
public class Kusto.Cloud.Platform.Modularization.ServiceProvider`1 : object {
    public T Provider;
    public string Identity;
    public object Context;
}
public enum Kusto.Cloud.Platform.Net.CompressionScheme : Enum {
    public int value__;
    public static CompressionScheme None;
    public static CompressionScheme gzip;
    public static CompressionScheme deflate;
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Net.ExtendedCompressionScheme : object {
    [ExtensionAttribute]
public static string FastToString(CompressionScheme that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CompressionScheme that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CompressionScheme that, CompressionScheme flag);
    public static CompressionScheme FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CompressionScheme& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CompressionScheme that);
    [ExtensionAttribute]
public static string FastGetDescription(CompressionScheme that);
}
public static class Kusto.Cloud.Platform.Net.ExtendedServicePointManager : object {
    public static TimeSpan KeepAliveTime;
    public static TimeSpan KeepAliveInterval;
    public static TimeSpan ConnectionLeaseTimeout;
    public static int KeepAliveTimeMsec;
    public static int KeepAliveIntervalMsec;
    public static int KeepAliveRetryCount;
    public static int ConnectionLeaseTimeoutMsec;
    [CompilerGeneratedAttribute]
private static bool <ServicePointCloudificationDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <ServicePointCloudificationDefaultConnectionLimit>k__BackingField;
    private static Hashtable s_ServicePointTable;
    public static bool ServicePointCloudificationDisabled { get; public set; }
    public static int ServicePointCloudificationDefaultConnectionLimit { get; public set; }
    private static ExtendedServicePointManager();
    public static void InitHostEnvironment(ClientServerProfile profile);
    private static void ConfigureDefaultSecurity();
    [CompilerGeneratedAttribute]
public static bool get_ServicePointCloudificationDisabled();
    [CompilerGeneratedAttribute]
public static void set_ServicePointCloudificationDisabled(bool value);
    [CompilerGeneratedAttribute]
public static int get_ServicePointCloudificationDefaultConnectionLimit();
    [CompilerGeneratedAttribute]
public static void set_ServicePointCloudificationDefaultConnectionLimit(int value);
    public static void SafeCloudifyServicePointUri(string uri);
    public static void SafeCloudifyServicePointUri(Uri uri);
    private static Hashtable InitializeServicePointTable();
    public static int GetCurrentServicePointsCount();
    public static int GetCurrentServicePointConnectionsCount();
    public static IEnumerable`1<ServicePointStatus> GetCurrentServicePoints();
    private static bool ForEachServicePoint(Action`2<object, ServicePoint> action);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Net.ExtendedSystemNetTraceSources : object {
    [ExtensionAttribute]
public static string FastToString(SystemNetTraceSources that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(SystemNetTraceSources that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(SystemNetTraceSources that, SystemNetTraceSources flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(SystemNetTraceSources that, SystemNetTraceSources flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(SystemNetTraceSources that, SystemNetTraceSources flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(SystemNetTraceSources that, SystemNetTraceSources flags);
    public static SystemNetTraceSources FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, SystemNetTraceSources& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(SystemNetTraceSources that);
    [ExtensionAttribute]
public static string FastGetDescription(SystemNetTraceSources that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Net.ExtendedSystemNetTraceSources/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<SystemNetTraceSources> FastGetFlags(SystemNetTraceSources that);
}
public static class Kusto.Cloud.Platform.Net.ExtendedTcp : object {
    private static QuasistaticConcurrentDictionary`2<ValueTuple`2<SocketOptionLevel, SocketOptionName>, bool> s_unsupportedSocketOptions;
    private static ExtendedTcp();
    public static void SetReuseUnicastPort(Socket socket);
    private static void SetSocketOption(Socket socket, SocketOptionLevel socketOptionLevel, SocketOptionName socketOptionName, object socketOptionValue);
    public static void GetActiveTcpConnections();
}
public class Kusto.Cloud.Platform.Net.LoopbackIPAddressSupplier : object {
    private Byte[] m_currentIPAddress;
    private object m_lock;
    public LoopbackIPAddressSupplier(byte startOctet);
    public IPAddress GetNextIPAddress();
}
public class Kusto.Cloud.Platform.Net.ServicePointStatus : object {
    public string NodeId;
    public string RemoteAddress;
    public int ConnectionLimit;
    public int NumConnections;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Net.SystemNetTraceSources : Enum {
    public int value__;
    public static SystemNetTraceSources None;
    public static SystemNetTraceSources Web;
    public static SystemNetTraceSources HttpListener;
    public static SystemNetTraceSources Sockets;
    public static SystemNetTraceSources WebSockets;
    public static SystemNetTraceSources Cache;
    public static SystemNetTraceSources Http;
}
public static class Kusto.Cloud.Platform.Net.SystemNetTracing : object {
    private static BindingFlags s_staticNonPublic;
    public static bool TryEnableSystemNetTracing(SystemNetTraceSources sources, SourceLevels sourceLevel, IEnumerable`1<TraceListener> traceListeners);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Rpc.RpcBaseMessage : object {
}
public static class Kusto.Cloud.Platform.Rpc.RpcMessageSerializer : object {
    public static RpcRequestMessage CreateRpcRequestMessage(string addressString, string serviceType, int serviceMajorVersion, int serviceMinorVersion, string operationType, T payload, Action`2<Stream, T> payloadSerializer);
    public static RpcRequestMessage CreateRpcRequestMessage(string addressString, string serviceType, int serviceMajorVersion, int serviceMinorVersion, string operationType, T payload, Func`2<T, Byte[]> payloadSerializer);
    public static RpcResponseMessage CreateRpcResponseMessage(T payload, Action`2<Stream, T> payloadSerializer);
    public static RpcResponseMessage CreateRpcResponseMessage(T payload, Func`2<T, Byte[]> payloadSerializer);
    public static RpcResponseMessage CreateRpcResponseMessage(Exception ex);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Rpc.RpcRequestMessage : RpcBaseMessage {
    [DataMemberAttribute]
public string ServiceType;
    [DataMemberAttribute]
public int ServiceMajorVersion;
    [DataMemberAttribute]
public int ServiceMinorVersion;
    [DataMemberAttribute]
public string OperationType;
    [DataMemberAttribute]
public string PayloadType;
    [DataMemberAttribute]
public Byte[] Payload;
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Rpc.RpcResponseMessage : RpcBaseMessage {
    [DataMemberAttribute]
public string PayloadType;
    [DataMemberAttribute]
public Byte[] Payload;
    [DataMemberAttribute]
public PlatformExceptionDetail Exception;
}
public class Kusto.Cloud.Platform.Rpc.RpcSerializer : object {
    private BinaryWriter m_writer;
    private BinaryReader m_reader;
    private static Action`2<RpcSerializer, byte> StaticWriteByte;
    private static Func`2<RpcSerializer, byte> StaticReadByte;
    public bool IsEndOfStream { get; }
    private static RpcSerializer();
    public static RpcSerializer CreateWriter(Stream output, bool leaveOpen);
    public static RpcSerializer CreateReader(Stream input, bool leaveOpen);
    public sealed virtual void Dispose();
    public void Write(int value);
    public void Write(long value);
    public void Write(string value);
    public void Write(DateTime value);
    public void Write(TimeSpan value);
    public void Write(bool value);
    public void Write(byte value);
    public void Write(Guid value);
    public void Write(RpcRequestMessage value);
    public void Write(RpcResponseMessage value);
    public void WriteArray(TElement[] value, Action`2<RpcSerializer, TElement> elementWriter);
    public void WriteCollection(IReadOnlyCollection`1<TElement> value, Action`2<RpcSerializer, TElement> elementWriter);
    public bool get_IsEndOfStream();
    public int ReadInt32();
    public long ReadInt64();
    public string ReadString();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public bool ReadBoolean();
    public byte ReadByte();
    public Guid ReadGuid();
    public RpcRequestMessage ReadRpcRequestMessage();
    public RpcResponseMessage ReadRpcResponseMessage();
    public TElement[] ReadArray(Func`2<RpcSerializer, TElement> elementReader);
}
public class Kusto.Cloud.Platform.Security.AllowAllServiceCalloutValidator : ServiceCalloutValidatorBase {
    protected internal virtual bool IsHostnameTrustedImpl(string hostname);
}
public class Kusto.Cloud.Platform.Security.AllowAllServiceCalloutValidatorFactory : object {
    [CompilerGeneratedAttribute]
private static IServiceCalloutValidator <SharedValidator>k__BackingField;
    public static IServiceCalloutValidator SharedValidator { get; }
    private static AllowAllServiceCalloutValidatorFactory();
    [CompilerGeneratedAttribute]
public static IServiceCalloutValidator get_SharedValidator();
    public sealed virtual IServiceCalloutValidator GetValidator(string serviceCalloutType);
    public sealed virtual bool TryGetValidator(string serviceCalloutType, IServiceCalloutValidator& serviceCalloutValidator);
}
public abstract class Kusto.Cloud.Platform.Security.AppCertificateTokenCredentialProviderWithAutoRefreshBase : object {
    private string m_subjectName;
    private TimeSpan m_refreshInterval;
    private object m_lock;
    private IKustoTokenCredentialsProvider m_appCertificateTokenCredentialsProvider;
    private X509Certificate2 m_currentCertificate;
    private DateTime m_nextRefreshTime;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public AppCertificateTokenCredentialProviderWithAutoRefreshBase(string name, string subjectName, Nullable`1<TimeSpan> refreshInterval);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    protected abstract virtual IKustoTokenCredentialsProvider CreateTokenCredentialProvider(X509Certificate2 certificate);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, string tenantId);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, int retries, string tenantId);
    public sealed virtual string ToTraceString();
    protected void LoadRefreshCertificate();
    private bool ShouldRefresh();
}
internal class Kusto.Cloud.Platform.Security.AuthenticationExceptionDefaultTracer : TraceSourceBase`1<AuthenticationExceptionDefaultTracer> {
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
}
public class Kusto.Cloud.Platform.Security.AzCliAcrTokenProvider : AzCliTokenProvider {
    public string Name { get; }
    public AzCliAcrTokenProvider(bool interactive);
    public virtual string get_Name();
    protected virtual string GetTokenCommand(string resource);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Security.AzCliAuthException : KustoAuthenticationException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public AzCliAuthException(string message, Exception innerException);
    protected AzCliAuthException(SerializationInfo info, StreamingContext context);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Security.AzCliTokenProvider : object {
    private static string s_azCliPath;
    private static TimeSpan s_minTokenValidTime;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ValueTuple`2<string, DateTime>> s_cache;
    private static TimeSpan s_nonInteractiveWait;
    private static TimeSpan s_interactiveWait;
    private bool m_interactive;
    public string Name { get; }
    public AzCliTokenProvider(bool interactive);
    private static AzCliTokenProvider();
    public virtual string get_Name();
    public static void ClearCachedTokens();
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, string tenantId);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, int retries, string tenantId);
    public sealed virtual string ToTraceString();
    protected virtual string GetTokenCommand(string resource);
    private string GetTokenFromAzCli(string resource, bool interactive);
    private static void LocateAzCli();
    private static bool RunCommand(string programPath, string command, TimeSpan timeout);
    private static bool RunCommand(string programPath, string command, TimeSpan timeout, String& output);
}
public static class Kusto.Cloud.Platform.Security.Callouts : object {
    private static object s_updateLock;
    private static long s_suppressCount;
    private static HashSet`1<Byte[]> s_immutableForbiddenIpv4Addresses;
    private static HashSet`1<Byte[]> s_immutableForbiddenIpv6Addresses;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HashSet`1<ValueTuple`2<Byte[], int>> s_immutableForbiddenIpv4Subnets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HashSet`1<ValueTuple`2<Byte[], int>> s_immutableForbiddenIpv6Subnets;
    private static Callouts();
    public static void AddImmutableForbiddenSubnets(List`1<ValueTuple`2<Byte[], int>> ipv4Subnets, List`1<ValueTuple`2<Byte[], int>> ipv6Subnets);
    public static void AddImmutableFobiddenIps(List`1<Byte[]> ipv4Addresses, List`1<Byte[]> ipv6Addresses);
    public static IDisposable SuppressNonLoopbackNorLinkLocalCheck();
    public static JustifiedResult`1<IpCalloutFailType> GoodIfNonLoopbackNorLinkLocal(Uri uri, string calloutType, ITraceSource tracer, bool enforceSubnets);
    private static JustifiedResult`1<IpCalloutFailType> GoodIfNonLoopbackNorLinkLocal(IPAddress address, string uriHost, string calloutType, ITraceSource tracer, bool enforceSubnets);
    private static string ByteArrayToString(Byte[] arr);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Security.CalloutValidationType : Enum {
    public int value__;
    public static CalloutValidationType None;
    public static CalloutValidationType HostnameTrusted;
    public static CalloutValidationType NotLoopbackLinkLocal;
    public static CalloutValidationType TlsRequired;
    public static CalloutValidationType AuthMethodAllowed;
    public static CalloutValidationType All;
}
public class Kusto.Cloud.Platform.Security.CertificateDecryptor : object {
    private X509Certificate2 m_certificate;
    public CertificateDecryptor(X509Certificate2 certificate);
    public CertificateDecryptor(X509FindType type, string property);
    public CertificateDecryptor(string certificateThumbprint);
    public sealed virtual string Decrypt(string encrypted);
    public sealed virtual string DecryptByPattern(string encrypted);
}
public class Kusto.Cloud.Platform.Security.CertificateStatus : object {
    public string NodeId;
    public string Store;
    public string EnhancedKeyUsages;
    public string FriendlyName;
    public bool HasPrivateKey;
    public string Issuer;
    public string IssuerName;
    public DateTime NotAfter;
    public DateTime NotBefore;
    public string PublicKey;
    public string SerialNumber;
    public string Subject;
    public string SubjectAlternativeName;
    public string SubjectName;
    public string Thumbprint;
    public int Version;
}
public class Kusto.Cloud.Platform.Security.CertificateSubjectNameComparer : object {
    public sealed virtual bool Equals(X509Certificate2 x, X509Certificate2 y);
    public sealed virtual int GetHashCode(X509Certificate2 obj);
}
public class Kusto.Cloud.Platform.Security.CertificateThumbprintComparer : object {
    public sealed virtual bool Equals(X509Certificate2 x, X509Certificate2 y);
    public sealed virtual int GetHashCode(X509Certificate2 obj);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.CertificateUtilities : object {
    private static StoreLocation[] s_personalCertificateStoreLocations;
    private static StoreName[] s_storeNames;
    private static X509Certificate2Collection s_loadedCertificatesByThumbprintCache;
    private static ReaderWriterLockSlim s_lock;
    private static CertificateUtilities();
    public static IEnumerable`1<CertificateStatus> EnumCertificates();
    [ExtensionAttribute]
public static void DumpTo(X509Certificate2 cert, ExtendedStringBuilder esb);
    public static X509Certificate2 TryLoadPersonalCertificate(X509FindType findType, string property, bool validOnly);
    public static X509Certificate2Collection TryLoadPersonalCertificates(X509FindType findType, string property, bool validOnly);
    public static X509Certificate2 TryLoadPersonalLatestCertificateBySubjectDistinguishedName(string subjectName, bool validOnly);
    public static X509Certificate2 TryLoadPersonalLatestCertificateBySubjectAndIssuerDistinguishedName(string subjectName, string issuerName, bool validOnly);
    public static X509Certificate2Collection TryLoadPersonalCertificatesBySubjectAndIssuerDistinguishedName(string subjectName, string issuerName, bool validOnly, bool filterValidTime);
    public static X509Certificate2 TryLoadCertificate(IEnumerable`1<StoreLocation> storeLocations, IEnumerable`1<StoreName> storeNames, X509FindType findType, string certificateProperty, bool validOnly);
    public static X509Certificate2Collection TryLoadCertificates(IEnumerable`1<StoreLocation> storeLocations, IEnumerable`1<StoreName> storeNames, X509FindType findType, string certificateProperty, bool validOnly);
    public static X509Certificate2 TryLoadCertificate(StoreLocation certificateStoreLocation, StoreName certificateStoreName, X509FindType findType, string certificateProperty, bool validOnly);
    public static IEnumerable`1<X509Certificate2> TryLoadCertificates_ForServerAuthentication(StoreLocation certificateStoreLocation, StoreName certificateStoreName, X509FindType findType, string certificateProperty, bool verifyAccessToPrivateKey);
    public static X509Certificate2 TryLoadLatestCertificate_ForServerAuthentication(X509FindType findType, string certificateProperty, bool verifyAccessToPrivateKey);
    [ExtensionAttribute]
public static bool HasEnhancedKeyUsages(X509Certificate2 cert, string friendlyName, string oid);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Security.CertificateUtilities/<GetEnhancedKeyUsages>d__18")]
[ExtensionAttribute]
public static IEnumerable`1<string> GetEnhancedKeyUsages(X509Certificate2 cert, string friendlyName, string oid);
    public static X509Certificate2Collection TryLoadCertificates(StoreLocation certificateStoreLocation, StoreName certificateStoreName, X509FindType findType, string certificateProperty, bool validOnly);
    public static void ImportCertificate(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation, bool forceWithPrivateKey);
    public static void RemoveCertificate(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation);
    public static X509Certificate2 GetCertificateFromBase64(string contentAsBase64);
    public static IList`1<X509Certificate2> GetChain(X509Certificate2 certificate);
    private static void WarnOnLackOfCNIfNeeded(X509FindType findType, string findValue);
    private static X509Certificate2 TryLoadCertificateFromCache(X509FindType findType, string certificateProperty, bool validOnly);
    private static X509Certificate2 GetLatestIssuedCertificateFromCertificateCollection(IEnumerable`1<X509Certificate2> certificateCollection);
}
public class Kusto.Cloud.Platform.Security.ConnectionStringPair : ValueType {
    public string Primary;
    public string Secondary;
    public ConnectionStringPair(string primary, string secondary);
}
public class Kusto.Cloud.Platform.Security.CryptoCertificatePair : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Primary>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Secondary>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<X509Certificate2> <AllCertificates>k__BackingField;
    private TimeSpan m_certificateUsageDelay;
    public X509Certificate2 Primary { get; private set; }
    public X509Certificate2 Secondary { get; private set; }
    public IList`1<X509Certificate2> AllCertificates { get; private set; }
    public CryptoCertificatePair(X509Certificate2 primary, X509Certificate2 secondary, IEnumerable`1<X509Certificate2> certificateList, TimeSpan certificateUsageDelay);
    public CryptoCertificatePair(CryptoCertificatePair other);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Primary();
    [CompilerGeneratedAttribute]
private void set_Primary(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Secondary();
    [CompilerGeneratedAttribute]
private void set_Secondary(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public IList`1<X509Certificate2> get_AllCertificates();
    [CompilerGeneratedAttribute]
private void set_AllCertificates(IList`1<X509Certificate2> value);
    public X509Certificate2 GetCertificateWithDelayForSigning();
    public string DecryptString(string encryptedString, ITraceSource tracer, string certThumbprint);
}
public static class Kusto.Cloud.Platform.Security.Cryptography : object {
    public static string GetSHA256Hash(string input, string salt);
}
public class Kusto.Cloud.Platform.Security.DecryptionCommandLineArgs : object {
    [CommandLineArgAttribute("ArgumentsDecryptionCertificateThumbprint", "If set, attempts to decrypt other command line args, marked with 'SupportsEncryption', using the specified certificate")]
public string ArgumentsDecryptionCertificateThumbprint;
    [CommandLineArgAttribute("JWTEncrypted", "The encryption method used for secret section inside args file")]
public bool JWTEncrypted;
    public DecryptionCommandLineArgs ShallowClone();
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public class Kusto.Cloud.Platform.Security.DualAuthKustoTokenCredentialsProvider : object {
    public static TimeSpan SecondaryUseDuration;
    private object m_lock;
    private bool m_usingPrimary;
    private DateTime m_revertToPrimaryTime;
    private IKustoTokenCredentialsProvider m_primaryProvider;
    private IKustoTokenCredentialsProvider m_secondaryProvider;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public bool UsingPrimaryForTests { get; }
    public DualAuthKustoTokenCredentialsProvider(string name, IKustoTokenCredentialsProvider primaryProvider, IKustoTokenCredentialsProvider secondaryProvider);
    private static DualAuthKustoTokenCredentialsProvider();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public bool get_UsingPrimaryForTests();
    public static bool TryCreate(string dualAuthProviderName, string primaryProviderName, IKustoTokenCredentialsProvider primaryProvider, string secondaryProviderName, IKustoTokenCredentialsProvider secondaryProvider, IKustoTokenCredentialsProvider& provider);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Security.DualAuthKustoTokenCredentialsProvider/<GetCredentialsAsync>d__14")]
public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Security.DualAuthKustoTokenCredentialsProvider/<GetCredentialsAsync>d__15")]
public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, string tenantId);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Security.DualAuthKustoTokenCredentialsProvider/<GetCredentialsAsync>d__16")]
public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, int retries, string tenantId);
    public sealed virtual string ToTraceString();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Security.DualAuthKustoTokenCredentialsProvider/<DualGetCredentialImpl>d__18")]
private Task`1<KustoTokenCredentials> DualGetCredentialImpl(string targetResource, int retries, string tenantId, bool usePrimary, bool firstAttempt);
    private bool ShouldUsePrimaryProvider();
    private void SwitchProviders(bool localUsingPrimary);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Security.DualAuthTokenProviderAuthenticationException : KustoAuthenticationException {
    public string PrimaryAuthenticationMethodName;
    public Exception PrimaryException;
    public string SecondaryAuthenticationMethodName;
    public Exception SecondaryException;
    private string m_message;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public DualAuthTokenProviderAuthenticationException(string message, Exception innerException);
    protected DualAuthTokenProviderAuthenticationException(SerializationInfo info, StreamingContext context);
    public DualAuthTokenProviderAuthenticationException(string primaryAuthenticationMethodName, Exception primaryException, string secondaryAuthenticationMethodName, Exception secondaryException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public DualAuthTokenProviderAuthenticationException(string primaryAuthenticationMethodName, Exception primaryException, string secondaryAuthenticationMethodName, Exception secondaryException, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    private string CreateMessageFromTemplate();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string ToString();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
}
public class Kusto.Cloud.Platform.Security.EncryptDecryptService : object {
    private X509Certificate2 m_encryptDecryptCert;
    private RSAEncryptDecrypt m_rsaEncryptDecrypt;
    public EncryptDecryptService(X509Certificate2 encryptDecryptCert);
    public sealed virtual void Dispose();
    public sealed virtual string DecryptString(string content);
    public sealed virtual string EncryptString(string content);
}
public enum Kusto.Cloud.Platform.Security.EncryptionMethod : Enum {
    public int value__;
    public static EncryptionMethod FullAsymmetricEncryption;
    public static EncryptionMethod KeysJWEEncryption;
}
public class Kusto.Cloud.Platform.Security.EncryptionResult : object {
    [CompilerGeneratedAttribute]
private string <EncryptedContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionIv>k__BackingField;
    public string EncryptedContent { get; private set; }
    public string EncryptionKey { get; private set; }
    public string EncryptionIv { get; private set; }
    public EncryptionResult(string encryptedContent, string encryptionKey, string encryptionIv);
    [CompilerGeneratedAttribute]
public string get_EncryptedContent();
    [CompilerGeneratedAttribute]
private void set_EncryptedContent(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionKey();
    [CompilerGeneratedAttribute]
private void set_EncryptionKey(string value);
    [CompilerGeneratedAttribute]
public string get_EncryptionIv();
    [CompilerGeneratedAttribute]
private void set_EncryptionIv(string value);
}
public class Kusto.Cloud.Platform.Security.EncryptionUtils : object {
    private static Char[] s_zero;
    private static string c_encryptionStartTag;
    private static string c_encryptionEndTag;
    private static ConcurrentDictionary`2<EncryptionCacheKey, string> s_encryptionCache;
    private static ConcurrentDictionary`2<EncryptionCacheKey, string> s_encryptionWithTagsCache;
    private static ConcurrentDictionary`2<EncryptionCacheKey, string> s_decryptionCache;
    private static ConcurrentDictionary`2<EncryptionCacheKey, Byte[]> s_signatureCache;
    private static ConcurrentDictionary`2<string, RSA> m_privateKeyCache;
    private static ConcurrentDictionary`2<HashSignatureCacheKey, bool> s_signatureVerificationCache;
    private static Regex[] s_encryptedSecretRegex;
    private static Regex[] s_secretKeysRegex;
    private static SHA256 c_sha256CryptoServiceProvider;
    public static string DefaultHashingAlgorithm { get; }
    private static EncryptionUtils();
    public static string get_DefaultHashingAlgorithm();
    public static string EncryptStringByPattern(X509Certificate2 certificate, string content, bool useKnownSecretsPattern);
    public static string FastEncryptStringByPattern(X509Certificate2 certificate, string content);
    public static string EncryptStringByPattern(IEncryptDecryptService encryptService, string content);
    public static IEnumerable`1<string> GetSecretiveSubstrings(string content);
    private static string FastEncryptStringByPattern(string content, Func`2<string, string> encrypt);
    private static string EncryptStringByPattern(string content, Func`2<string, string> encryptAndTag);
    public static string EncryptStorageString(X509Certificate2 certificate, string contentWithSecret, string substringToEncrypt);
    public static string DecryptStringByPattern(X509Certificate2 certificate, string content);
    public static string FastDecryptStringByPattern(X509Certificate2 certificate, string content);
    public static string DecryptStringByPattern(IEncryptDecryptService decryptService, string content);
    private static string DecryptStringByPattern(string content, Func`2<string, string> decryptor);
    private static string FastDecryptStringByPattern(string content, Func`2<string, string> decryptor);
    public static string DecryptStorageString(X509Certificate2 certificate, string content);
    public static bool IsEncrypted(string content);
    public static string ComputeSha256HashAsString(string content);
    public static Byte[] ComputeSha256Hash(Byte[] content);
    public static string ComputeCryptoHashAsString(HashAlgorithm hash, string content);
    public static Byte[] ComputeCryptoHash(HashAlgorithm hash, Byte[] content);
    public static Byte[] SignData(X509Certificate2 certificate, string content);
    public static bool VerifyData(X509Certificate2 certificate, string content, Byte[] signature);
    public static string EncryptString(X509Certificate2 certificate, string content);
    public static string EncryptAndTagString(X509Certificate2 certificate, string content);
    private static string GenerateEncryptedString(X509Certificate2 certificate, string content);
    private static Byte[] EncryptByteArray(X509Certificate2 certificate, Byte[] content);
    private static Byte[] HashAndSignBytes(X509Certificate2 certificate, Byte[] content);
    private static bool VerifyDataBytes(X509Certificate2 certificate, Byte[] content, Byte[] signature);
    public static string DecryptString(X509Certificate2 certificate, string encryptedContent);
    private static Byte[] DecryptByteArray(X509Certificate2 certificate, Byte[] encryptedContent);
    private static IEnumerable`1<string> GetRegexMatchList(string content, IEnumerable`1<Regex> pattern);
    private static string TagEncryptedContent(string content);
    public static string GetKeyFromConnectionString(string storageAccountConnectionString);
    public static string GenerateHMACSignature(Byte[] key, string message);
    public static bool VerifyHMACSignature(Byte[] key, string message, string signature);
    public static Byte[] GenerateSymmetricKey();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedCalloutValidationType : object {
    [ExtensionAttribute]
public static string FastToString(CalloutValidationType that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CalloutValidationType that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CalloutValidationType that, CalloutValidationType flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(CalloutValidationType that, CalloutValidationType flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(CalloutValidationType that, CalloutValidationType flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(CalloutValidationType that, CalloutValidationType flags);
    public static CalloutValidationType FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CalloutValidationType& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CalloutValidationType that);
    [ExtensionAttribute]
public static string FastGetDescription(CalloutValidationType that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Security.ExtendedCalloutValidationType/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<CalloutValidationType> FastGetFlags(CalloutValidationType that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedClaimsIdentity : object {
    public static string AuthenticationClaimName;
    public static string SigningCertNotBeforeKustoClaimName;
    public static string NameClaimType;
    public static string RoleClaimType;
    public static string FederatedAuthenticationTypeName;
    public static string FederatedObjectIdClaimName;
    public static string FederatedTenantIdClaimName;
    public static string FederatedScopeClaimName;
    public static string FederatedIssuerClaimName;
    public static string FederatedActualIssuerClaimName;
    public static string FederatedAudienceClaimName;
    public static string FederatedIssuedAtTimeClaimName;
    public static string FederatedNotBeforeTimeClaimName;
    public static string FederatedExpirationTimeClaimName;
    public static string FederatedAuthenticationContextClassReferenceClaimName;
    public static string FederatedAccountIdentifierObjectClaimName;
    public static string FederatedPublicUserIdClaimName;
    public static string AadFederatedUpnClaimName;
    public static string AadFederatedObjectIdClaimName;
    public static string AadFederatedTenantIdClaimName;
    public static string AadFederatedApplicationIdClaimName;
    public static string AadFederatedApplicationIdAcrClaimName;
    public static string AadFederatedUniqueNameClaimName;
    public static string AadFederatedScopeClaimName;
    public static string AadFederatedTokenVersionClaimName;
    public static string AadFederatedEmailClaimName;
    public static string AadFederatedSubjectClaimName;
    public static string AadFederatedIdentityTypeClaimName;
    public static string AadFederatedJwtIdClaimName;
    public static string AadFederatedCustomClaimsClaimName;
    public static string AadFederatedManagedIdentityResourceIdClaimName;
    public static string AzureTrustedServiceClaimName;
    public static string AzureTrustedServiceClaimValue;
    public static string AadFederatedFirstPartyAppTokenClaimName;
    public static string AadFederatedX5cClaimName;
    public static string AadFederatedUniqueTokenIdentifierClaimName;
    public static string MsaFederatedAltSecIdClaimName;
    public static string AuthenticationMethodReferencesClaimTypeName;
    public static string MfaAuthenticationMethodReferencesClaimValue;
    public static string UserImpersonationScopeValue;
    public static string AppImpersonationScopeValue;
    public static string TypeNameDelimiter;
    public static char TypeNameDelimiterChar;
    public static string NameAuthorityDelimiter;
    public static char NameAuthorityDelimiterChar;
    public static char AadOauthTokenDelimiter;
    public static string KustoServicePrincipalPrefix;
    public static string AadUserPrincipalPrefix;
    public static string AadApplicationPrincipalPrefix;
    public static string MsaUserPrincipalPrefix;
    public static string DstsUserPrincipalPrefix;
    public static string DstsApplicationPrincipalPrefix;
    public static string DstsApplicationClaimType;
    public static string AadGroupPrincipalPrefix;
    public static string AadObjectPrincipalPrefix;
    public static string DstsGroupPrincipalPrefix;
    public static string TridentGroupPrincipalPrefix;
    public static string KustoAuthenticationTypeName;
    public static string BasicAuthenticationTypeName;
    public static string DstsAuthenticationTypeName;
    public static string DstsPassiveAuthenticationTypeName;
    public static string NullIdentityName;
    public static string IllFormedIdentityName;
    public static string DummyObjectId;
    public static HashSet`1<string> s_claimsForAuditLog;
    public static HashSet`1<string> s_traceableClaims;
    private static ExtendedClaimsIdentity();
    [ExtensionAttribute]
public static string ToStringEx(ClaimsIdentity claimsIdentity);
    [ExtensionAttribute]
public static string DumpClaims(ClaimsIdentity claimsIdentity);
    [ExtensionAttribute]
public static string SafeToTraceString(ClaimsIdentity claimsIdentity, bool includeConfidentialInformation, int maxClaims);
    public static ClaimsIdentity AadClaimsIdentityFromUserPrincipalName(string username);
    public static ClaimsIdentity TryCreate(IPrincipal principal);
    public static ClaimsIdentity FromClaims(IEnumerable`1<Claim> claims);
    [ExtensionAttribute]
public static string GetObjectIdentifier(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string GetApplicationPrincipalIdentifier(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static void FixClaimsIdentityForApplicationOBOFlowIfNeeded(ClaimsIdentity claimsId, Func`2<string, string> getAppIdByObjectIdCallback, ITraceSource tracer);
    [ExtensionAttribute]
public static void FixClaimsIdentityForApplicationUserImpersonationFlowIfNeeded(ClaimsIdentity claimsId, Func`2<string, string> getAppIdByOidFunc, ITraceSource tracer);
    [ExtensionAttribute]
public static string GetPrincipalAadTenantId(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string GetPrincipalUniqueName(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string GetPrincipalAadIssuer(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string GetPrincipalSubject(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string GetClaimValue(ClaimsIdentity claimsId, string objectIdClaimType);
    [ExtensionAttribute]
public static IList`1<string> GetClaimValues(ClaimsIdentity claimsId, string objectIdClaimType);
    [ExtensionAttribute]
public static string SafeName(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static string TrySafeNameForTracing(ClaimsIdentity claimsIdentity, ITraceSource tracer);
    [ExtensionAttribute]
public static string TrySafeFullyQualifiedPrincipalName(ClaimsIdentity claimsIdentity, ITraceSource tracer);
    [ExtensionAttribute]
private static string TrySafeName(ClaimsIdentity claimsIdentity, bool includeConfidentialInformation, ITraceSource tracer);
    [ExtensionAttribute]
public static bool SafeIsMsaUser(ClaimsIdentity claimsId);
    [ExtensionAttribute]
public static void AddObjectIdentifierClaim(ClaimsIdentity claimsId, string objectId);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedKustoCalloutAuthorizationClass : object {
    [ExtensionAttribute]
public static string FastToString(KustoCalloutAuthorizationClass that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoCalloutAuthorizationClass that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoCalloutAuthorizationClass that, KustoCalloutAuthorizationClass flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(KustoCalloutAuthorizationClass that, KustoCalloutAuthorizationClass flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(KustoCalloutAuthorizationClass that, KustoCalloutAuthorizationClass flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(KustoCalloutAuthorizationClass that, KustoCalloutAuthorizationClass flags);
    public static KustoCalloutAuthorizationClass FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, KustoCalloutAuthorizationClass& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(KustoCalloutAuthorizationClass that);
    [ExtensionAttribute]
public static string FastGetDescription(KustoCalloutAuthorizationClass that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Security.ExtendedKustoCalloutAuthorizationClass/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<KustoCalloutAuthorizationClass> FastGetFlags(KustoCalloutAuthorizationClass that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedKustoHttpAuthenticationMethod : object {
    [ExtensionAttribute]
public static string FastToString(KustoHttpAuthenticationMethod that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoHttpAuthenticationMethod that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoHttpAuthenticationMethod that, KustoHttpAuthenticationMethod flag);
    public static KustoHttpAuthenticationMethod FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, KustoHttpAuthenticationMethod& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(KustoHttpAuthenticationMethod that);
    [ExtensionAttribute]
public static string FastGetDescription(KustoHttpAuthenticationMethod that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedKustoSqlAuthenticationMethod : object {
    [ExtensionAttribute]
public static string FastToString(KustoSqlAuthenticationMethod that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoSqlAuthenticationMethod that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(KustoSqlAuthenticationMethod that, KustoSqlAuthenticationMethod flag);
    public static KustoSqlAuthenticationMethod FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, KustoSqlAuthenticationMethod& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(KustoSqlAuthenticationMethod that);
    [ExtensionAttribute]
public static string FastGetDescription(KustoSqlAuthenticationMethod that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedObfuscationKind : object {
    [ExtensionAttribute]
public static string FastToString(ObfuscationKind that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(ObfuscationKind that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(ObfuscationKind that, ObfuscationKind flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(ObfuscationKind that, ObfuscationKind flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(ObfuscationKind that, ObfuscationKind flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(ObfuscationKind that, ObfuscationKind flags);
    public static ObfuscationKind FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, ObfuscationKind& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(ObfuscationKind that);
    [ExtensionAttribute]
public static string FastGetDescription(ObfuscationKind that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Security.ExtendedObfuscationKind/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<ObfuscationKind> FastGetFlags(ObfuscationKind that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Security.ExtendedSecureString : object {
    private static SecureString s_emptySecureString;
    private static ExtendedSecureString();
    [ExtensionAttribute]
public static SecureString ConvertToSecureString(string secret);
}
public static class Kusto.Cloud.Platform.Security.ExtendedSecurity : object {
    private static JwtSecurityTokenHandler s_jwtHandler;
    private static ExtendedSecurity();
    public static bool IsHttpSecurityHeader(string name);
    public static string SecureDumpBearerToken(string parameter, bool appendCurrentTime, bool includeConfidentialInformation);
}
public class Kusto.Cloud.Platform.Security.FailAllServiceCalloutValidator : ServiceCalloutValidatorBase {
    protected internal virtual bool IsHostnameTrustedImpl(string hostname);
}
public class Kusto.Cloud.Platform.Security.FailAllServiceCalloutValidatorFactory : object {
    [CompilerGeneratedAttribute]
private static IServiceCalloutValidator <SharedValidator>k__BackingField;
    public static IServiceCalloutValidator SharedValidator { get; }
    private static FailAllServiceCalloutValidatorFactory();
    [CompilerGeneratedAttribute]
public static IServiceCalloutValidator get_SharedValidator();
    public sealed virtual IServiceCalloutValidator GetValidator(string serviceCalloutType);
    public sealed virtual bool TryGetValidator(string serviceCalloutType, IServiceCalloutValidator& serviceCalloutValidator);
}
public class Kusto.Cloud.Platform.Security.HashCache : object {
    private string m_salt;
    public HashCache(string salt);
    public string GetHash(string input);
}
public interface Kusto.Cloud.Platform.Security.IDecryptor {
    public abstract virtual string Decrypt(string encrypted);
    public abstract virtual string DecryptByPattern(string encrypted);
}
public interface Kusto.Cloud.Platform.Security.IEncryptDecryptService {
    public abstract virtual string EncryptString(string content);
    public abstract virtual string DecryptString(string content);
}
public interface Kusto.Cloud.Platform.Security.IKustoTokenCredentialsProvider {
    public abstract virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource);
    public abstract virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, string tenantId);
    public abstract virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, int retries, string tenantId);
    public abstract virtual string ToTraceString();
}
public interface Kusto.Cloud.Platform.Security.IServiceCalloutValidator {
    public string ResourceType { get; }
    public abstract virtual string get_ResourceType();
    public abstract virtual JustifiedResult`1<CalloutValidationType> IsCalloutTrusted(Uri uri, KustoCalloutAuthorizationClass authClass, bool tlsIsOn, bool impersonationAllowed, CalloutValidationType alertOnlyValidations, CalloutValidationType suppressValidations);
    public abstract virtual JustifiedResult`1<CalloutValidationType> IsCalloutTrusted(string hostname, KustoCalloutAuthorizationClass authClass, bool tlsIsOn, bool impersonationAllowed, CalloutValidationType alertOnlyValidations, CalloutValidationType suppressValidations);
}
public interface Kusto.Cloud.Platform.Security.IServiceCalloutValidatorFactory {
    public abstract virtual IServiceCalloutValidator GetValidator(string serviceCalloutType);
    public abstract virtual bool TryGetValidator(string serviceCalloutType, IServiceCalloutValidator& serviceCalloutValidator);
}
public class Kusto.Cloud.Platform.Security.JsonWebToken : object {
    public static string SecureToString(string accessToken);
    public static JToken CreateJTokenFromAadAccessToken(string accessToken);
    public static JToken CreateJTokenFromBase64EncodedString(string str);
    public static DateTime GetExpirationTimeUtc(string token);
    public static string RemoveJwtSignature(string jwtToken);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Security.KustoAuthenticationException : AuthenticationException {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public KustoAuthenticationException(string message, Exception innerException);
    protected KustoAuthenticationException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Security.KustoCalloutAuthorizationClass : Enum {
    public int value__;
    public static KustoCalloutAuthorizationClass NoAuth;
    public static KustoCalloutAuthorizationClass Unknown;
    public static KustoCalloutAuthorizationClass AzureIdentity;
    public static KustoCalloutAuthorizationClass AzureIdentityDelegatedPermissions;
    public static KustoCalloutAuthorizationClass FabricIdenity;
    public static KustoCalloutAuthorizationClass UsernamePassword;
    public static KustoCalloutAuthorizationClass AzureAccessKeys;
    public static KustoCalloutAuthorizationClass AwsAccessKeys;
    public static KustoCalloutAuthorizationClass All;
}
public enum Kusto.Cloud.Platform.Security.KustoHttpAuthenticationMethod : Enum {
    public int value__;
    public static KustoHttpAuthenticationMethod Invalid;
    public static KustoHttpAuthenticationMethod Token;
    public static KustoHttpAuthenticationMethod SharedKey;
    public static KustoHttpAuthenticationMethod Impersonate;
    public static KustoHttpAuthenticationMethod Impersonation_Disabled;
    public static KustoHttpAuthenticationMethod Prompt;
    public static KustoHttpAuthenticationMethod Managed_Identity;
    public static KustoHttpAuthenticationMethod SharedAccess;
    public static KustoHttpAuthenticationMethod AwsCredentials;
    public static KustoHttpAuthenticationMethod Mwc;
}
public static class Kusto.Cloud.Platform.Security.KustoHttpClientCredentials : object {
    public static bool ParseSecretiveUri(SecretiveUri secretiveUri, KustoHttpAuthenticationMethod& authenticationMethod, String& authenticationArg, String& error);
    public static bool ExtractAuthArgIfAuthMethodMatches(SecretiveUri secretiveUri, KustoHttpAuthenticationMethod authMethod, String& authenticationArg);
    public static bool ExtractAuthArgIfAuthMethodMatches(string uri, KustoHttpAuthenticationMethod authMethod, String& authenticationArg);
    public static bool IsSecretiveAuthenticationMethod(KustoHttpAuthenticationMethod authenticationMethod);
    private static bool AuthenticationMethodNameExpectedInUri(KustoHttpAuthenticationMethod authenticationMethod);
    public static KustoHttpAuthenticationMethod GetAuthenticationMethod(string resourceUri);
    private static bool IsQueryStringAValidSas(string queryString, String& sasKey, String& error);
    private static bool IsQueryStringAValidS3Sas(string queryString, String& s3Key, String& error);
    private static bool TryParseAwsCredentialsString(string awsCredentials, KustoHttpAuthenticationMethod& authenticationMethod, String& error, String& authenticationArg);
}
public enum Kusto.Cloud.Platform.Security.KustoSqlAuthenticationMethod : Enum {
    public int value__;
    public static KustoSqlAuthenticationMethod Unknown;
    public static KustoSqlAuthenticationMethod Invalid;
    public static KustoSqlAuthenticationMethod Token;
    public static KustoSqlAuthenticationMethod Impersonate;
    public static KustoSqlAuthenticationMethod UsernamePassword;
    public static KustoSqlAuthenticationMethod ManagedIdentity;
    public static KustoSqlAuthenticationMethod AccountKey;
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Security.KustoTokenCredentials : object {
    [DataMemberAttribute]
private string m_tokenScheme;
    [DataMemberAttribute]
private string m_tokenValue;
    [DataMemberAttribute]
private Nullable`1<DateTime> m_expiresOn;
    public string TokenScheme { get; }
    public string TokenValue { get; }
    public Nullable`1<DateTime> ExpiresOn { get; }
    public KustoTokenCredentials(string tokenScheme, string tokenValue);
    public KustoTokenCredentials(string tokenScheme, string tokenValue, Nullable`1<DateTime> expiresOn);
    public string get_TokenScheme();
    public string get_TokenValue();
    public Nullable`1<DateTime> get_ExpiresOn();
    public sealed virtual bool Equals(KustoTokenCredentials other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string ToSecureString();
    public virtual string ToString();
}
public static class Kusto.Cloud.Platform.Security.LargeObjectEncryptDecrypt : object {
    public static EncryptionResult Encrypt(string content, X509Certificate2 encryptionCertificate);
    public static string Decrypt(string certificateThumbprint, string encryptedEncryptionKey, string encryptionIV, string encryptedContent, StoreLocation storeLocation, string encryptedType);
}
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public class Kusto.Cloud.Platform.Security.MultiTenantDualAuthKustoTokenCredentialsProvider : object {
    public static string AnyTenant;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private ConcurrentDictionary`2<string, IKustoTokenCredentialsProvider> m_providersByTenant;
    private IKustoTokenCredentialsProvider m_primaryCredentialsProvider;
    private IKustoTokenCredentialsProvider m_secondaryCredentialsProvider;
    private HashSet`1<string> m_primaryProviderTenants;
    private HashSet`1<string> m_secondaryProviderTenants;
    private bool m_isPrimaryProviderAnyTenant;
    private bool m_isSecondaryProviderAnyTenant;
    private string m_defaultTenant;
    public string Name { get; private set; }
    public MultiTenantDualAuthKustoTokenCredentialsProvider(string name, IKustoTokenCredentialsProvider primaryProvider, IEnumerable`1<string> primaryProviderTenants, IKustoTokenCredentialsProvider secondaryProvider, IEnumerable`1<string> secondaryProviderTenants, string defaultTenant);
    private static MultiTenantDualAuthKustoTokenCredentialsProvider();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public static bool TryCreate(string dualAuthProviderName, string primaryProviderName, IKustoTokenCredentialsProvider primaryProvider, IEnumerable`1<string> primaryProviderTenants, string secondaryProviderName, IKustoTokenCredentialsProvider secondaryProvider, IEnumerable`1<string> secondaryProviderTenants, string defaultTenant, IKustoTokenCredentialsProvider& provider);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, string tenantId);
    public sealed virtual Task`1<KustoTokenCredentials> GetCredentialsAsync(string targetResource, int retries, string tenantId);
    public sealed virtual string ToTraceString();
    public void GetProviderNameAndTypeByTenantForTests(string tenantId, String& name, Type& type);
    private IKustoTokenCredentialsProvider GetCreateProviderForTenant(string tenantId);
    private IKustoTokenCredentialsProvider CreateProviderForTenant(string tenantId);
    [CompilerGeneratedAttribute]
private IKustoTokenCredentialsProvider <GetProviderNameAndTypeByTenantForTests>b__19_0(string id);
    [CompilerGeneratedAttribute]
private IKustoTokenCredentialsProvider <GetCreateProviderForTenant>b__20_0(string id);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Security.ObfuscationKind : Enum {
    public int value__;
    public static ObfuscationKind None;
    public static ObfuscationKind UrlSecrets;
    public static ObfuscationKind LoginSecrets;
    public static ObfuscationKind Passwords;
    public static ObfuscationKind StringLiterals;
    public static ObfuscationKind All;
    public static ObfuscationKind AllExceptStringLiterals;
}
public static class Kusto.Cloud.Platform.Security.Obfuscator : object {
    public static string ObfuscatedReplacement;
    public static string ObfuscatedReplacementWithQuotes;
    public static string Redacted;
    public static string RedactedButInConfidentialDb;
    public static int DefaultMaximumInputStringLength;
    public static int MaxPropsTextLength;
    public static int MaxCommandLengthForTrace;
    public static string RemoveHiddenSubstringsAndTruncate(string value, int maxLen, ChopOptions chopOptions);
    public static string RemoveSecretsAndTruncate(string value, int maxLen, ObfuscationKind options);
    public static string RemoveKnownSecrets(string value, ObfuscationKind options);
    public static string ObfuscateEntireText(string text);
    public static bool Matches(string value, ObfuscationKind obfuscationKinds);
    public static string ObfuscateSecretiveUri(SecretiveUri secretiveUri);
    private static bool IsAsciiLetterOrDigit(char ch);
    private static bool IsQuote(char ch);
    private static bool IsNewLine(char ch);
    private static bool IsHiddenStringModifier(char ch);
    private static IEnumerable`1<ObfuscatorMatch> FindHiddenStringMatches(string value);
    private static IEnumerable`1<ObfuscatorMatch> FindSignatureMatches(string value);
    private static IEnumerable`1<ObfuscatorMatch> FindKeys(string value);
    private static IEnumerable`1<ObfuscatorMatch> FindLoginKeys(string value);
    private static IEnumerable`1<ObfuscatorMatch> FindPasswords(string value);
    private static string ReplaceAll(string value, IEnumerable`1<ObfuscatorMatch> matches);
    [CompilerGeneratedAttribute]
internal static void <FindHiddenStringMatches>g__TryAddMatch|18_0(int offset, <>c__DisplayClass18_0& );
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Security.OneLakeCredentialsProviderAuthenticationException : KustoAuthenticationException {
    public string ArtifactId;
    public string TenantId;
    public string StatusCode;
    public string Reason;
    public string Response;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public OneLakeCredentialsProviderAuthenticationException(string message, Exception innerException);
    protected OneLakeCredentialsProviderAuthenticationException(SerializationInfo info, StreamingContext context);
    public OneLakeCredentialsProviderAuthenticationException(string artifactId, string tenantId, string statusCode, string reason, string response, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public OneLakeCredentialsProviderAuthenticationException(string artifactId, string tenantId, string statusCode, string reason, string response, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Security.RSAEncryptDecrypt : object {
    private X509Certificate2 m_certificate;
    private bool m_canEncrypt;
    private bool m_canDecrypt;
    private ICryptoTransform m_aesEncryptor;
    private string m_encryptPrefix;
    private RSA m_rsaDecryptor;
    public RSAEncryptDecrypt(X509Certificate2 certificate, bool canEncrypt, bool canDecrypt);
    public sealed virtual void Dispose();
    public string Encrypt(string content);
    public string Decrypt(string content);
}
public abstract class Kusto.Cloud.Platform.Security.ServiceCalloutValidatorBase : object {
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    protected bool m_tlsRequired;
    protected KustoCalloutAuthorizationClass m_allowedAuthorizationClasses;
    protected CalloutValidationType m_defaultAlertOnlyValidations;
    protected CalloutValidationType m_defaultSuppressedValidations;
    protected static CalloutValidationType s_suppressValidationsForTests;
    public string ResourceType { get; private set; }
    public ServiceCalloutValidatorBase(string resourceType, KustoCalloutAuthorizationClass allowedAuthorizationClasses, bool forceTls, CalloutValidationType defaultAlertOnlyValidations, CalloutValidationType defaultSuppressValidations);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceType();
    [CompilerGeneratedAttribute]
private void set_ResourceType(string value);
    public static ActionBasedIDisposable EnterTestScope(CalloutValidationType validationsToSuppress);
    public sealed virtual JustifiedResult`1<CalloutValidationType> IsCalloutTrusted(Uri uri, KustoCalloutAuthorizationClass authClass, bool tlsIsOn, bool impersonationAllowed, CalloutValidationType alertOnlyValidations, CalloutValidationType suppressValidations);
    public virtual JustifiedResult`1<CalloutValidationType> IsCalloutTrusted(string hostname, KustoCalloutAuthorizationClass authClass, bool tlsIsOn, bool impersonationAllowed, CalloutValidationType alertOnlyValidations, CalloutValidationType suppressValidations);
    protected static string TrimAndRemoveTrailingSlash(string hostname);
    protected internal abstract virtual bool IsHostnameTrustedImpl(string hostname);
    private TriState IsNotLoopbackNorLinkLocal(string hostname, String& reason);
    private bool IsTlsStateAllowed(bool isTlsOn);
    private bool IsAuthMethodAllowed(string hostname, KustoCalloutAuthorizationClass authMethod, bool impersonationAllowed, bool isTlsOn, String& reason);
}
public class Kusto.Cloud.Platform.Security.ServiceCalloutValidatorCollection : ServiceCalloutValidatorBase {
    private List`1<ServiceCalloutValidatorBase> m_serviceValidatorList;
    public ServiceCalloutValidatorCollection(string resourceType, IEnumerable`1<IServiceCalloutValidator> serviceValidators, CalloutValidationType defaultAlertOnlyValidations, CalloutValidationType defaultSuppressValidations);
    public virtual JustifiedResult`1<CalloutValidationType> IsCalloutTrusted(string hostname, KustoCalloutAuthorizationClass authClass, bool tlsIsOn, bool impersonationAllowed, CalloutValidationType alertOnlyValidations, CalloutValidationType suppressValidations);
    protected internal virtual bool IsHostnameTrustedImpl(string hostname);
}
public interface Kusto.Cloud.Platform.Security.UserDelegationSas.IUserDelegationSasGenerator {
    public abstract virtual string GenerateSas(string containerName, SasPermissions sasPermissions);
}
public interface Kusto.Cloud.Platform.Security.UserDelegationSas.IUserDelegationSasGeneratorFactory {
    public abstract virtual bool CanHandle(string accountUri);
    public abstract virtual ValueTuple`2<string, string> ExtractStorageDetails(string blobPath);
    public abstract virtual Task`1<IUserDelegationSasGenerator> TryCreateUserDelegationSasGeneratorAsync(string accountUri, IKustoTokenCredentialsProvider tokenCredentials, DateTimeOffset startTime, DateTimeOffset endTime);
}
public interface Kusto.Cloud.Platform.Security.UserDelegationSas.IUserDelegationSasProvider {
    public abstract virtual Task`1<string> TryGetContainerSasAsync(string blobPath, SasPermissions sasPermissions);
}
public class Kusto.Cloud.Platform.Security.UserDelegationSas.UserDelagetionSasGeneratorFactory : object {
    private static int c_KeyLifeTimeInDays;
    private IKustoTokenCredentialsProvider m_tokenCredentials;
    private IUserDelegationSasGeneratorFactory[] m_userDelegationSasGeneratorFactories;
    [CompilerGeneratedAttribute]
private TimeSpan <LifeTimePolicy>k__BackingField;
    public TimeSpan LifeTimePolicy { get; public set; }
    public bool IsBatchCreationSupported { get; }
    public UserDelagetionSasGeneratorFactory(IUserDelegationSasGeneratorFactory[] userDelegationSasGeneratorFactories, IKustoTokenCredentialsProvider tokenCredential);
    [CompilerGeneratedAttribute]
public TimeSpan get_LifeTimePolicy();
    [CompilerGeneratedAttribute]
public void set_LifeTimePolicy(TimeSpan value);
    public sealed virtual bool get_IsBatchCreationSupported();
    public sealed virtual Task`1<IEnumerable`1<KeyValuePair`2<string, UserDelegationSasGeneratorCacheEntry>>> CreateCacheEntriesValuesAsync(IEnumerable`1<string> keys, object context, Dictionary`2<string, NetworkCacheEntry`3<string, object, UserDelegationSasGeneratorCacheEntry>> previous);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Security.UserDelegationSas.UserDelagetionSasGeneratorFactory/<CreateCacheEntryValueAsync>d__11")]
public sealed virtual Task`1<UserDelegationSasGeneratorCacheEntry> CreateCacheEntryValueAsync(string acountUri, object context, NetworkCacheEntry`3<string, object, UserDelegationSasGeneratorCacheEntry> previous);
    public sealed virtual bool IsApplicableCacheEntryValue(NetworkCacheEntry`3<string, object, UserDelegationSasGeneratorCacheEntry> current, DateTime now);
}
public class Kusto.Cloud.Platform.Security.UserDelegationSas.UserDelegationSasGeneratorCacheEntry : object {
    [CompilerGeneratedAttribute]
private bool <HasPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private IUserDelegationSasGenerator <UserDelegationSasGenerator>k__BackingField;
    public bool HasPermissions { get; public set; }
    public IUserDelegationSasGenerator UserDelegationSasGenerator { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasPermissions();
    [CompilerGeneratedAttribute]
public void set_HasPermissions(bool value);
    [CompilerGeneratedAttribute]
public IUserDelegationSasGenerator get_UserDelegationSasGenerator();
    [CompilerGeneratedAttribute]
public void set_UserDelegationSasGenerator(IUserDelegationSasGenerator value);
}
public class Kusto.Cloud.Platform.Security.WinTrust : object {
    public static bool CanCallerTrustCallee(string callerFileName, string calleeFileName);
    public static bool VerifyEmbeddedSignature(string fileName);
    private static X509Certificate2 LoadFromSignedFileOrNull(string fileName);
}
public class Kusto.Cloud.Platform.Storage.DownloadItemRequest : object {
    private string m_resourceUri;
    private string m_downloadLocalPath;
    private bool m_overwriteIfExists;
    private IKustoTokenCredentialsProvider m_credentialsProvider;
    private SecretiveUri m_secretiveUri;
    private string m_secureString;
    private Exception m_ex;
    [CompilerGeneratedAttribute]
private bool <VerifySize>k__BackingField;
    public string ResourceUri { get; }
    public bool VerifySize { get; private set; }
    public string DownloadLocalPath { get; }
    public bool OverwriteIfExists { get; }
    public IKustoTokenCredentialsProvider CredentialsProvider { get; }
    public DownloadItemRequest(string resourceUri, IKustoTokenCredentialsProvider credentialsProvider);
    public DownloadItemRequest(string resourceUri, string downloadLocalPath, bool overwriteIfExists, IKustoTokenCredentialsProvider credentialsProvider);
    public string get_ResourceUri();
    [CompilerGeneratedAttribute]
public bool get_VerifySize();
    [CompilerGeneratedAttribute]
private void set_VerifySize(bool value);
    public string get_DownloadLocalPath();
    public bool get_OverwriteIfExists();
    public IKustoTokenCredentialsProvider get_CredentialsProvider();
    public SecretiveUri SecretiveUriOrException(Exception& ex);
    public string ToSecureString();
}
public class Kusto.Cloud.Platform.Storage.DownloadItemResult : object {
    [CompilerGeneratedAttribute]
private DownloadItemRequest <DownloadItemRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Downloaded>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Failure>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public DownloadItemRequest DownloadItemRequest { get; private set; }
    public string LocalPath { get; private set; }
    public bool Downloaded { get; private set; }
    public Exception Failure { get; private set; }
    public TimeSpan DownloadTime { get; private set; }
    public long Size { get; private set; }
    private DownloadItemResult(DownloadItemRequest request, string localPath, bool downloaded, TimeSpan downloadTime, long size, Exception failure);
    public static DownloadItemResult FromSuccess(DownloadItemRequest request, string localPath, TimeSpan downloadTime, long size, bool downloaded);
    public static DownloadItemResult FromFailure(DownloadItemRequest request, Exception failure, string localPath);
    [CompilerGeneratedAttribute]
public DownloadItemRequest get_DownloadItemRequest();
    [CompilerGeneratedAttribute]
private void set_DownloadItemRequest(DownloadItemRequest value);
    [CompilerGeneratedAttribute]
public string get_LocalPath();
    [CompilerGeneratedAttribute]
private void set_LocalPath(string value);
    [CompilerGeneratedAttribute]
public bool get_Downloaded();
    [CompilerGeneratedAttribute]
private void set_Downloaded(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Failure();
    [CompilerGeneratedAttribute]
private void set_Failure(Exception value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTime();
    [CompilerGeneratedAttribute]
private void set_DownloadTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(long value);
}
public class Kusto.Cloud.Platform.Storage.DownloadJobResult : object {
    private ITraceSource m_tracer;
    public List`1<DownloadItemResult> Items;
    public DownloadJobResult(ITraceSource tracer);
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Storage.DownloadManager3 : object {
    private static DownloadDataActivityType s_downloadDataActivityType;
    private static ProcessPendingAsyncRequestsActivityType s_processPendingRequestsActivityType;
    private string m_name;
    private IPersistentStorageFactory m_persistentStorageFactory;
    private int m_maxConcurrency;
    private WorkTicketFactory m_workTicketFactory;
    private ConcurrentQueue`1<DownloadItemPendindRequest> m_pendingRequests;
    private bool m_hideUnresolvedRemoteNamesFailures;
    private static string IntroduceDataLossOnDownloadFailureWithUnresolvedRemoteNames_FeatureFlagName;
    public static string DownloadSourcesTraceFormatting;
    public string Name { get; }
    public int MaxConcurrency { get; public set; }
    public long NumCurrentIncompleteDownloads { get; }
    public bool HideUnresolvedRemoteNamesFailures { get; }
    public DownloadManager3(string name, IPersistentStorageFactory persistentStorageFactory, IFeatureFlags featureFlags);
    private static DownloadManager3();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual int get_MaxConcurrency();
    public sealed virtual void set_MaxConcurrency(int value);
    public sealed virtual long get_NumCurrentIncompleteDownloads();
    public sealed virtual bool get_HideUnresolvedRemoteNamesFailures();
    public sealed virtual DownloadJobResult DownloadMany(IEnumerable`1<DownloadItemRequest> requests, DownloadPolicy policy, ITraceSource tracer);
    public sealed virtual void DownloadManyNotifyEach(IEnumerable`1<DownloadItemRequest> requests, ITraceSource tracer, Action`1<DownloadItemResult> onRequestCompleted);
    public sealed virtual DownloadJobResult DownloadSingle(DownloadItemRequest request, ITraceSource tracer);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.DownloadManager3/<DownloadSingleAsync>d__24")]
public sealed virtual Task`1<DownloadJobResult> DownloadSingleAsync(DownloadItemRequest request, ITraceSource tracer);
    private void ProcessPendingAsyncRequestsLoop(WorkTicket workTicket);
    private void ProcessPendingAsyncRequests();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.DownloadManager3/<MonitoredDownloadAsync>d__27")]
private Task MonitoredDownloadAsync(WorkTicket workTicket, DownloadItemPendindRequest request, ITraceSource tracer);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.DownloadManager3/<DownloadAsync>d__28")]
private Task`1<DownloadItemResult> DownloadAsync(ExtendedDownloadItemRequest exRequest);
    private void NotifyDownloadItemCompleted(ITraceSource tracer, Action`1<DownloadItemResult> onRequestCompleted, DownloadItemResult result);
    private static void TraceDownloadRequest(string kind, IEnumerable`1<DownloadItemRequest> requests, long count, ITraceSource tracer);
    private static string GetTempDownloadPath(IPersistentStorageFile fileRef);
    private static void TraceDownloadOperationCompleted(List`1<DownloadItemResult> downloadResults, ITraceSource tracer, string operation);
    [CompilerGeneratedAttribute]
private void <ProcessPendingAsyncRequests>b__26_0();
}
public enum Kusto.Cloud.Platform.Storage.DownloadPolicy : Enum {
    public int value__;
    public static DownloadPolicy DownloadAll;
    public static DownloadPolicy StopOnFailure;
}
public interface Kusto.Cloud.Platform.Storage.IAzureStorageBlob {
    public abstract virtual Task CoalesceAppendBlobIfNeededAsync(IPersistentStorageFile source, int targetBlockSize, double blobCountRatioThreshold, CancellationToken ct);
    public abstract virtual Stream OpenStagedWrite();
    public abstract virtual Task UploadStagedFromFileAsync(string file);
    public abstract virtual bool CommitStaged();
}
public interface Kusto.Cloud.Platform.Storage.IDownloadManager {
    public int MaxConcurrency { get; public set; }
    public long NumCurrentIncompleteDownloads { get; }
    public bool HideUnresolvedRemoteNamesFailures { get; }
    public abstract virtual int get_MaxConcurrency();
    public abstract virtual void set_MaxConcurrency(int value);
    public abstract virtual DownloadJobResult DownloadMany(IEnumerable`1<DownloadItemRequest> requests, DownloadPolicy policy, ITraceSource tracer);
    public abstract virtual void DownloadManyNotifyEach(IEnumerable`1<DownloadItemRequest> requests, ITraceSource tracer, Action`1<DownloadItemResult> onRequestCompleted);
    public abstract virtual DownloadJobResult DownloadSingle(DownloadItemRequest request, ITraceSource tracer);
    public abstract virtual Task`1<DownloadJobResult> DownloadSingleAsync(DownloadItemRequest request, ITraceSource tracer);
    public abstract virtual long get_NumCurrentIncompleteDownloads();
    public abstract virtual bool get_HideUnresolvedRemoteNamesFailures();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.CorruptedMetadataArtifactException : Exception {
    public string StreamName;
    public string DatabaseName;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public CorruptedMetadataArtifactException(string message, Exception innerException);
    protected CorruptedMetadataArtifactException(SerializationInfo info, StreamingContext context);
    public CorruptedMetadataArtifactException(string streamName, string databaseName, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CorruptedMetadataArtifactException(string streamName, string databaseName, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.CreatingEncryptDecryptServiceFailedException : Exception {
    public string CertificateThumbprint;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected CreatingEncryptDecryptServiceFailedException(SerializationInfo info, StreamingContext context);
    public CreatingEncryptDecryptServiceFailedException(string certificateThumbprint, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CreatingEncryptDecryptServiceFailedException(string certificateThumbprint, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.DownloadFailedException : Exception {
    public string Path;
    public string Reason;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public DownloadFailedException(string message, Exception innerException);
    protected DownloadFailedException(SerializationInfo info, StreamingContext context);
    public DownloadFailedException(string path, string reason, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public DownloadFailedException(string path, string reason, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageContainer : object {
    [ExtensionAttribute]
public static Stream ReadStream(IPersistentStorageContainer container, string name, string compressionType);
    [ExtensionAttribute]
public static void WriteStream(IPersistentStorageContainer container, string name, Stream source, SerializationAccessMode serializationAccessMode, string compressionType);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageContainer/<WriteStreamAsync>d__2")]
[ExtensionAttribute]
public static Task WriteStreamAsync(IPersistentStorageContainer container, string name, Stream source, SerializationAccessMode serializationAccessMode, string compressionType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string ReadString(IPersistentStorageContainer container, string name, string compressionType);
    [ExtensionAttribute]
public static void WriteString(IPersistentStorageContainer container, string name, string contents, SerializationAccessMode serializationAccessMode, string compressionType);
    [ExtensionAttribute]
public static T ReadJsonStream(IPersistentStorageContainer container, string name, string compressionType, JsonSerializerSettings settings, CancellationToken cancellationToken, bool enableMetadataDownloadHotfix, IPersistentStorageFactory persistentStorageFactory);
    [ExtensionAttribute]
public static JsonStreamWithFileProperties`1<T> ReadJsonStreamWithProperties(IPersistentStorageContainer container, string name, string compressionType, JsonSerializerSettings settings, bool enableMetadataDownloadHotfix, IPersistentStorageFactory persistentStorageFactory);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageContainer/<ReadJsonStreamAsync>d__7`1")]
[ExtensionAttribute]
public static Task`1<T> ReadJsonStreamAsync(IPersistentStorageContainer container, string name, string compressionType, JsonSerializerSettings settings, CancellationToken cancellationToken, bool enableMetadataDownloadHotfix, IPersistentStorageFactory persistentStorageFactory);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageContainer/<ReadJsonStreamWithPropertiesAsync>d__8`1")]
[ExtensionAttribute]
private static Task`1<JsonStreamWithFileProperties`1<T>> ReadJsonStreamWithPropertiesAsync(IPersistentStorageContainer container, string name, string compressionType, JsonSerializerSettings settings, CancellationToken cancellationToken, bool enableMetadataDownloadHotfix, IPersistentStorageFactory persistentStorageFactory, bool setStreamProperties);
    [ExtensionAttribute]
public static void WriteJsonStream(IPersistentStorageContainer container, string name, object contents, SerializationAccessMode serializationAccessMode, string compressionType, JsonSerializerSettings settings, PersistentStorageWriteImplementation storageUploadMethod);
    [ExtensionAttribute]
public static FileProperties WriteJsonStream(IPersistentStorageContainer container, string name, object contents, Func`2<string, string> fileETagGetter, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static bool DeleteIfExists(IPersistentStorageContainer container, string name, string compressionType);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageContainer/<RenameFileAsync>d__12")]
public static Task RenameFileAsync(IPersistentStorageContainer container, string source, string target, bool overwrite, string compressionType);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPersistentStorageFile : object {
    private static string c_uploadFromStreamOperationType;
    public static void ThrowIfNotExists(bool exists, string path, string operation);
    [ExtensionAttribute]
public static string ReadAsStringStream(IPersistentStorageFile file);
    [ExtensionAttribute]
public static T ReadAsJsonStream(IPersistentStorageFile file, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static void WriteAsStringStream(IPersistentStorageFile file, string contents, SerializationAccessMode serializationAccessMode);
    [ExtensionAttribute]
public static void WriteAsJsonStream(IPersistentStorageFile file, object obj, SerializationAccessMode serializationAccessMode, JsonSerializerSettings settings, PersistentStorageWriteImplementation storageUploadMethod);
    [ExtensionAttribute]
public static void WriteAsJsonStream(IPersistentStorageFile file, object obj, string expectedETag, JsonSerializerSettings settings);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPreConditions : object {
    [ExtensionAttribute]
public static string FastToString(PreConditions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(PreConditions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(PreConditions that, PreConditions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(PreConditions that, PreConditions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(PreConditions that, PreConditions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(PreConditions that, PreConditions flags);
    public static PreConditions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, PreConditions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(PreConditions that);
    [ExtensionAttribute]
public static string FastGetDescription(PreConditions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedPreConditions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<PreConditions> FastGetFlags(PreConditions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedRenameFileState : object {
    [ExtensionAttribute]
public static string FastToString(RenameFileState that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(RenameFileState that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(RenameFileState that, RenameFileState flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(RenameFileState that, RenameFileState flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(RenameFileState that, RenameFileState flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(RenameFileState that, RenameFileState flags);
    public static RenameFileState FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, RenameFileState& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(RenameFileState that);
    [ExtensionAttribute]
public static string FastGetDescription(RenameFileState that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedRenameFileState/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<RenameFileState> FastGetFlags(RenameFileState that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedSasPermissions : object {
    [ExtensionAttribute]
public static string FastToString(SasPermissions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(SasPermissions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(SasPermissions that, SasPermissions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(SasPermissions that, SasPermissions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(SasPermissions that, SasPermissions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(SasPermissions that, SasPermissions flags);
    public static SasPermissions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, SasPermissions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(SasPermissions that);
    [ExtensionAttribute]
public static string FastGetDescription(SasPermissions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedSasPermissions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<SasPermissions> FastGetFlags(SasPermissions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedSerializationAccessMode : object {
    [ExtensionAttribute]
public static string FastToString(SerializationAccessMode that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(SerializationAccessMode that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(SerializationAccessMode that, SerializationAccessMode flag);
    public static SerializationAccessMode FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, SerializationAccessMode& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(SerializationAccessMode that);
    [ExtensionAttribute]
public static string FastGetDescription(SerializationAccessMode that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedStorageFileUsageCriteria : object {
    [ExtensionAttribute]
public static string FastToString(StorageFileUsageCriteria that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageFileUsageCriteria that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageFileUsageCriteria that, StorageFileUsageCriteria flag);
    public static StorageFileUsageCriteria FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StorageFileUsageCriteria& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StorageFileUsageCriteria that);
    [ExtensionAttribute]
public static string FastGetDescription(StorageFileUsageCriteria that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedStorageItemLocation : object {
    [ExtensionAttribute]
public static string FastToString(StorageItemLocation that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemLocation that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemLocation that, StorageItemLocation flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(StorageItemLocation that, StorageItemLocation flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(StorageItemLocation that, StorageItemLocation flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(StorageItemLocation that, StorageItemLocation flags);
    public static StorageItemLocation FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StorageItemLocation& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StorageItemLocation that);
    [ExtensionAttribute]
public static string FastGetDescription(StorageItemLocation that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedStorageItemLocation/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<StorageItemLocation> FastGetFlags(StorageItemLocation that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedStorageItemLocationMode : object {
    [ExtensionAttribute]
public static string FastToString(StorageItemLocationMode that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemLocationMode that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemLocationMode that, StorageItemLocationMode flag);
    public static StorageItemLocationMode FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StorageItemLocationMode& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StorageItemLocationMode that);
    [ExtensionAttribute]
public static string FastGetDescription(StorageItemLocationMode that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.ExtendedStorageItemOpenMode : object {
    [ExtensionAttribute]
public static string FastToString(StorageItemOpenMode that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemOpenMode that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StorageItemOpenMode that, StorageItemOpenMode flag);
    public static StorageItemOpenMode FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StorageItemOpenMode& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StorageItemOpenMode that);
    [ExtensionAttribute]
public static string FastGetDescription(StorageItemOpenMode that);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileKnownMetadata : ValueType {
    [DataMemberAttribute]
public Nullable`1<long> Length;
    [DataMemberAttribute]
public Nullable`1<DateTime> LastModified;
    public FileKnownMetadata(Nullable`1<long> length, Nullable`1<DateTime> lastModified);
    public sealed virtual bool Equals(FileKnownMetadata other);
    public bool IsInitialized();
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileProperties : object {
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    public string ETag { get; public set; }
    public string Uri { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ETag();
    [CompilerGeneratedAttribute]
public void set_ETag(string value);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(string value);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("Folder={m_folderPath}")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageContainer : object {
    private string m_folderPath;
    private IPersistentStorageFileCompressorFactory m_persistentStorageFileCompressorFactory;
    private IPersistentStorageNameValidator m_nameValidator;
    private bool m_testMode;
    public FileSystemPersistentStorageContainer(string path, bool disableLocalFilesystemForPersistentData, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, IPersistentStorageNameValidator nameValidator, bool createForTests);
    public sealed virtual string GetContainerName();
    public sealed virtual string GetContainerUri();
    public sealed virtual string GetContainerSibling(string sibling);
    public sealed virtual bool IsETagSupported();
    public sealed virtual bool Exists(string streamName, string compressionType);
    public sealed virtual long GetStreamSizeBytes(string streamName, string compressionType);
    public sealed virtual bool IsEmpty();
    public sealed virtual void DeleteIfExists();
    public sealed virtual Task DeleteIfExistsAsync();
    public sealed virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public sealed virtual void Open(StorageItemOpenMode openMode, string encryptionScope);
    public sealed virtual Task OpenAsync(StorageItemOpenMode openMode, string encryptionScope);
    public sealed virtual TriState ExistsOrDontKnow();
    public sealed virtual IPersistentStorageFile CreateFileRef(string name, string compressionType);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageContainer/<EnumerateFiles>d__19")]
public sealed virtual IEnumerable`1<IPersistentStorageFile> EnumerateFiles(string pattern, string compressionType, bool withMetadata, CancellationToken cancellationToken);
    public sealed virtual bool IsContainerNameValid(string containerName);
    public sealed virtual bool IsFileNameValid(string fileName);
    public sealed virtual void SetDefaultFolderSeparatorIfSupported(string folderSeparator);
    public sealed virtual void CopyFrom(IPersistentStorageContainer from, bool overwrite);
    public sealed virtual string GetEncryptionScope();
    public sealed virtual Task RenameFileAsync(string source, string target, bool overwrite, string compressionType);
    private string GetStreamFullFileName(string streamName, IPersistentStorageFileCompressor persistentStorageFileCompressor);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFactory : object {
    public static string DisableLocalFileSystemFeatureFlag;
    public static string EnableTreatingAllPathsAsRemoteFeatureFlag;
    private IPersistentStorageNameValidator m_nameValidator;
    private bool m_disableLocalFilesystemForPersistentData;
    private bool m_testMode;
    public FileSystemPersistentStorageFactory(IFeatureFlags featureFlags, bool createForTests);
    public sealed virtual IServiceCalloutValidator GetServiceCalloutValidator(string uri);
    public sealed virtual IPersistentStorageContainer GetContainer(string containerUri, StorageItemOpenMode openMode, IKustoTokenCredentialsProvider credentialsProvider, StorageItemLocationMode locationMode, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, string encryptionScope, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IEnumerable`1<IPersistentStorageContainer> EnumerateTopLevelContainers(string storageUri, string searchPattern, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageUri ParseUri(string resourceUri);
    public sealed virtual IPersistentStorageContainer CreateContainerRef(string containerUri, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, bool callerIsTrusted, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageFile CreateFileRef(string uri, IKustoTokenCredentialsProvider credentialsProvider, string compressionType, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, StorageItemLocationMode locationMode, FileKnownMetadata knownMetadata, StorageFileUsageCriteria storageFileUsageCriteria, IEnumerable`1<string> allowedAuthMethods);
    public static void EnsureLocalFileSystem(string path, bool disableLocalFilesystemForPersistentData, string action);
    [CompilerGeneratedAttribute]
internal static string <EnumerateTopLevelContainers>g__AppendPathIfNeeded|8_3(string storageUri, string d);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFile : object {
    private static Tweak`1<bool> s_enableTreatingAllPathsAsRemote;
    private string m_filePath;
    private IPersistentStorageFileCompressor m_persistentStorageFileCompressor;
    private static string c_openWriteOperationType;
    private static string c_openReadOperationType;
    private static string c_openDownloadToStreamOperationType;
    public IPersistentStorageFileCompressor PersistentStorageFileCompressor { get; }
    public StorageItemLocation StorageItemLocation { get; }
    public bool IsMetadataAvailableLocally { get; }
    public FileSystemPersistentStorageFile(string filePath, IPersistentStorageFileCompressor persistentStorageFileCompressor);
    private static FileSystemPersistentStorageFile();
    public sealed virtual IPersistentStorageFileCompressor get_PersistentStorageFileCompressor();
    public sealed virtual StorageItemLocation get_StorageItemLocation();
    public sealed virtual bool get_IsMetadataAvailableLocally();
    public sealed virtual string GetFileUri();
    public sealed virtual string GetUnsecureUri();
    public sealed virtual string ToSecureString();
    public sealed virtual string GetFileName();
    public sealed virtual string GetFileETag();
    public sealed virtual bool Exists();
    public sealed virtual Task`1<bool> ExistsAsync();
    public sealed virtual Task`1<bool> DeleteIfExistsAsync();
    public sealed virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public sealed virtual IPersistentStorageFile DuplicateReferenceWithNoCache();
    public sealed virtual long GetLength();
    public sealed virtual Task`1<long> GetLengthAsync();
    public sealed virtual DateTime GetLastModified();
    public sealed virtual Stream OpenRead(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual StreamOrLocalFile OpenAsSeekableStream(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual Stream OpenWrite(SerializationAccessMode serializationAccessMode);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFile/<DownloadToFileAsync>d__29")]
public sealed virtual Task DownloadToFileAsync(string localPath, FileMode fileMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFile/<DownloadToStreamAsync>d__30")]
public sealed virtual Task DownloadToStreamAsync(Stream target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFile/<UploadFromStreamAsync>d__31")]
public sealed virtual Task UploadFromStreamAsync(Stream source, SerializationAccessMode serializationAccessMode);
    public sealed virtual Task UploadFromStreamIfSupportedAsync(Stream source, string expectedETag);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFile/<UploadFromFileAsync>d__33")]
public sealed virtual Task UploadFromFileAsync(string file, bool isBinary, SerializationAccessMode serializationAccessMode);
    public sealed virtual string GetExceptionMessage(Exception ex);
    public sealed virtual PersistentStorageException TranslateToPersistentStorageExceptionOrNull(string operation, Exception ex);
    public sealed virtual Task CopyFromAsync(IPersistentStorageFile source, bool overwrite);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests : object {
    private static ConcurrentDictionary`2<string, string> s_fileETags;
    private FileSystemPersistentStorageFile m_storageFile;
    public IPersistentStorageFileCompressor PersistentStorageFileCompressor { get; }
    public StorageItemLocation StorageItemLocation { get; }
    public bool IsMetadataAvailableLocally { get; }
    public FileSystemPersistentStorageFileForTests(string filePath, IPersistentStorageFileCompressor persistentStorageFileCompressor);
    private static FileSystemPersistentStorageFileForTests();
    public sealed virtual IPersistentStorageFileCompressor get_PersistentStorageFileCompressor();
    public sealed virtual StorageItemLocation get_StorageItemLocation();
    public sealed virtual bool get_IsMetadataAvailableLocally();
    public sealed virtual string GetFileUri();
    public sealed virtual string GetUnsecureUri();
    public sealed virtual string ToSecureString();
    public sealed virtual string GetFileName();
    public sealed virtual string GetFileETag();
    public sealed virtual bool Exists();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<ExistsAsync>d__15")]
public sealed virtual Task`1<bool> ExistsAsync();
    public sealed virtual Task`1<bool> DeleteIfExistsAsync();
    public sealed virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public sealed virtual IPersistentStorageFile DuplicateReferenceWithNoCache();
    public sealed virtual long GetLength();
    public sealed virtual Task`1<long> GetLengthAsync();
    public sealed virtual DateTime GetLastModified();
    public sealed virtual Stream OpenRead(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual StreamOrLocalFile OpenAsSeekableStream(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual Stream OpenWrite(SerializationAccessMode serializationAccessMode);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<DownloadToFileAsync>d__25")]
public sealed virtual Task DownloadToFileAsync(string localPath, FileMode fileMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<DownloadToStreamAsync>d__26")]
public sealed virtual Task DownloadToStreamAsync(Stream target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<UploadFromStreamAsync>d__27")]
public sealed virtual Task UploadFromStreamAsync(Stream source, SerializationAccessMode serializationAccessMode);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<UploadFromStreamIfSupportedAsync>d__28")]
public sealed virtual Task UploadFromStreamIfSupportedAsync(Stream source, string expectedETag);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageFileForTests/<UploadFromFileAsync>d__29")]
public sealed virtual Task UploadFromFileAsync(string file, bool isBinary, SerializationAccessMode serializationAccessMode);
    public sealed virtual string GetExceptionMessage(Exception ex);
    public sealed virtual PersistentStorageException TranslateToPersistentStorageExceptionOrNull(string operation, Exception ex);
    public sealed virtual Task CopyFromAsync(IPersistentStorageFile source, bool overwrite);
    private void SetFileETag(bool onlyIfAbcent);
    private void ThrowIfETagMismatchOrFileAlreadyExists(string expectedETag, string operation);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageNameValidator : object {
    private static HashSet`1<char> s_invalidPathChars;
    private static HashSet`1<char> s_invalidFileChars;
    private static IPersistentStorageNameValidator s_instance;
    private static FileSystemPersistentStorageNameValidator();
    public static IPersistentStorageNameValidator GetOrCreate();
    public sealed virtual bool IsContainerNameValid(string containerName);
    public sealed virtual bool IsFileNameValid(string fileName);
    public sealed virtual void ValidateContainerName(string containerName);
    public sealed virtual void ValidateFileName(string fileName);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.FileSystemPersistentStorageUri : object {
    private string m_uriString;
    public FileSystemPersistentStorageUri(string resourceUri, bool disableLocalFilesystemForPersistentData, string operation);
    public sealed virtual string ToSecureString();
    public sealed virtual string ToUnsecureString();
}
internal class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageClient : KustoHttpClient {
    private IKustoHttpClientFactory m_httpClientFactory;
    private ProductInfoHeaderValue m_headerUserAgentProductInfo;
    private bool m_allowLocalTargets;
    public HttpPersistentStorageClient(IKustoHttpClientFactory httpClientFactory, bool allowLocalTargets);
    public sealed virtual void Dispose();
    private ValueTuple`3<HttpResponseMessage, Stream, IDumper> Invoke(SecretiveUri secretiveUri, HttpRequestMessage request, TimeSpan timeout, string acceptHeader, bool acceptCompressedResponse, string dumperType);
    public Stream GetStream(SecretiveUri secretiveUri, TimeSpan timeout, bool shouldBuffer, int maxRedirects);
}
internal class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageContainer : object {
    private static string DefaultFolderSeparator;
    private HttpPersistentStorageClient m_client;
    private string m_containerName;
    private Uri m_uri;
    private IPersistentStorageFileCompressorFactory m_persistentStorageFileCompressorFactory;
    private IPersistentStorageNameValidator m_nameValidator;
    internal HttpPersistentStorageContainer(HttpPersistentStorageClient client, string containerName, Uri uri, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, IPersistentStorageNameValidator nameValidator);
    public sealed virtual bool IsETagSupported();
    public sealed virtual bool Exists(string streamName, string compressionType);
    public sealed virtual long GetStreamSizeBytes(string streamName, string compressionType);
    public sealed virtual string GetContainerName();
    public sealed virtual string GetContainerUri();
    public sealed virtual string GetContainerSibling(string sibling);
    public sealed virtual bool IsEmpty();
    public sealed virtual void DeleteIfExists();
    public sealed virtual Task DeleteIfExistsAsync();
    public sealed virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public sealed virtual void Open(StorageItemOpenMode openMode, string encryptionScope);
    public sealed virtual Task OpenAsync(StorageItemOpenMode openMode, string encryptionScope);
    public sealed virtual TriState ExistsOrDontKnow();
    public sealed virtual IPersistentStorageFile CreateFileRef(string name, string compressionType);
    public sealed virtual IEnumerable`1<IPersistentStorageFile> EnumerateFiles(string pattern, string compressionType, bool withMetadata, CancellationToken cancellationToken);
    public sealed virtual bool IsContainerNameValid(string containerName);
    public sealed virtual bool IsFileNameValid(string fileName);
    public sealed virtual void SetDefaultFolderSeparatorIfSupported(string folderSeparator);
    public sealed virtual void CopyFrom(IPersistentStorageContainer from, bool overwrite);
    public sealed virtual string GetEncryptionScope();
    public sealed virtual Task RenameFileAsync(string source, string target, bool overwrite, string compressionType);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageFactory : object {
    private Disposer m_disposer;
    private HttpPersistentStorageClient m_client;
    private IServiceCalloutValidator m_calloutValidator;
    private bool m_throwWhenUriHasSecrets;
    public HttpPersistentStorageFactory(IServiceCalloutValidator calloutValidator, bool throwWhenUriHasSecrets);
    public sealed virtual void Dispose();
    public sealed virtual IPersistentStorageContainer CreateContainerRef(string containerUri, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, bool callerIsTrusted, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageFile CreateFileRef(string uri, IKustoTokenCredentialsProvider credentialsProvider, string compressionType, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, StorageItemLocationMode locationMode, FileKnownMetadata knownMetadata, StorageFileUsageCriteria storageFileUsageCriteria, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IEnumerable`1<IPersistentStorageContainer> EnumerateTopLevelContainers(string storageUri, string searchPattern, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageContainer GetContainer(string containerUri, StorageItemOpenMode openMode, IKustoTokenCredentialsProvider credentialsProvider, StorageItemLocationMode locationMode, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, string encryptionScope, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IServiceCalloutValidator GetServiceCalloutValidator(string uri);
    public sealed virtual IPersistentStorageUri ParseUri(string resourceUri);
}
internal class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageFile : object {
    private HttpPersistentStorageClient m_client;
    private HttpPersistentStorageUri m_uri;
    private IPersistentStorageFileCompressor m_persistentStorageFileCompressor;
    public IPersistentStorageFileCompressor PersistentStorageFileCompressor { get; }
    public StorageItemLocation StorageItemLocation { get; }
    public bool IsMetadataAvailableLocally { get; }
    public HttpPersistentStorageFile(HttpPersistentStorageClient client, HttpPersistentStorageUri uri, IPersistentStorageFileCompressor persistentStorageFileCompressor);
    public sealed virtual IPersistentStorageFileCompressor get_PersistentStorageFileCompressor();
    public sealed virtual StorageItemLocation get_StorageItemLocation();
    public sealed virtual bool get_IsMetadataAvailableLocally();
    public sealed virtual Task CopyFromAsync(IPersistentStorageFile source, bool overwrite);
    public sealed virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public sealed virtual Task`1<bool> DeleteIfExistsAsync();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageFile/<DownloadToFileAsync>d__13")]
public sealed virtual Task DownloadToFileAsync(string localPath, FileMode fileMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageFile/<DownloadToStreamAsync>d__14")]
public sealed virtual Task DownloadToStreamAsync(Stream target, CancellationToken cancellationToken);
    public sealed virtual IPersistentStorageFile DuplicateReferenceWithNoCache();
    public sealed virtual bool Exists();
    public sealed virtual Task`1<bool> ExistsAsync();
    public sealed virtual string GetExceptionMessage(Exception ex);
    public sealed virtual string GetFileETag();
    public sealed virtual string GetFileName();
    public sealed virtual string GetFileUri();
    public sealed virtual DateTime GetLastModified();
    public sealed virtual long GetLength();
    public sealed virtual Task`1<long> GetLengthAsync();
    public sealed virtual string GetUnsecureUri();
    public sealed virtual StreamOrLocalFile OpenAsSeekableStream(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual Stream OpenRead(OnStreamRead onRead, bool preferStreaming);
    public sealed virtual Stream OpenWrite(SerializationAccessMode serializationAccessMode);
    public sealed virtual string ToSecureString();
    public sealed virtual PersistentStorageException TranslateToPersistentStorageExceptionOrNull(string operation, Exception ex);
    public sealed virtual Task UploadFromFileAsync(string file, bool isBinary, SerializationAccessMode serializationAccessMode);
    public sealed virtual Task UploadFromStreamAsync(Stream source, SerializationAccessMode serializationAccessMode);
    public sealed virtual Task UploadFromStreamIfSupportedAsync(Stream source, string expectedETag);
}
internal class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageTracer : TraceSourceBase`1<HttpPersistentStorageTracer> {
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.HttpPersistentStorageUri : object {
    private SecretiveUri m_uri;
    public HttpPersistentStorageUri(string resourceUri, bool throwWhenUriHasSecrets);
    private static bool IsValidUri(SecretiveUri secretiveResourceUri, bool throwWhenUriHasSecrets);
    public sealed virtual string ToSecureString();
    public sealed virtual string ToUnsecureString();
    public Uri GetUri();
    public SecretiveUri GetSecretiveUri();
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IFileWithMetadata {
    public abstract virtual Task SetFileMetaDataAsync(IDictionary`2<string, string> metadata);
    public abstract virtual Task`1<IReadOnlyDictionary`2<string, string>> GetFileMetaDataAsync();
    public abstract virtual IFileWithMetadata DuplicateFileWithMetadataReferenceWithNoCache();
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IInprocPersistentStorageFactory {
    public string Scheme { get; }
    public abstract virtual string get_Scheme();
    public abstract virtual void Add(string uri, Stream stream);
    public abstract virtual Stream TryRemove(string uri);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.InprocPersistentStorageFactory : object {
    public static string SCHEME;
    public static string SCHEME_INFINITE;
    public static string SCHEME_INLINE;
    public static string URI_EMPTY_STREAM;
    private object m_lock;
    private Dictionary`2<string, Stream> m_streams;
    public string Scheme { get; }
    private static InprocPersistentStorageFactory();
    public sealed virtual IServiceCalloutValidator GetServiceCalloutValidator(string uri);
    public sealed virtual IPersistentStorageContainer GetContainer(string containerUri, StorageItemOpenMode openMode, IKustoTokenCredentialsProvider credentialsProvider, StorageItemLocationMode locationMode, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, string encryptionScope, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IEnumerable`1<IPersistentStorageContainer> EnumerateTopLevelContainers(string storageUri, string searchPattern, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageUri ParseUri(string resourceUri);
    public sealed virtual IPersistentStorageContainer CreateContainerRef(string containerUri, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, bool callerIsTrusted, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageFile CreateFileRef(string uri, IKustoTokenCredentialsProvider credentialsProvider, string compressionType, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, StorageItemLocationMode locationMode, FileKnownMetadata knownMetadata, StorageFileUsageCriteria storageFileUsageCriteria, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual string get_Scheme();
    public sealed virtual void Add(string uri, Stream stream);
    public sealed virtual Stream TryRemove(string uri);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageContainer {
    public abstract virtual string GetContainerName();
    public abstract virtual string GetContainerUri();
    public abstract virtual string GetContainerSibling(string sibling);
    public abstract virtual bool IsETagSupported();
    public abstract virtual bool Exists(string streamName, string compressionType);
    public abstract virtual long GetStreamSizeBytes(string streamName, string compressionType);
    public abstract virtual bool IsEmpty();
    public abstract virtual void DeleteIfExists();
    public abstract virtual Task DeleteIfExistsAsync();
    public abstract virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public abstract virtual void Open(StorageItemOpenMode openMode, string encryptionScope);
    public abstract virtual Task OpenAsync(StorageItemOpenMode openMode, string encryptionScope);
    public abstract virtual TriState ExistsOrDontKnow();
    public abstract virtual IPersistentStorageFile CreateFileRef(string name, string compressionType);
    public abstract virtual IEnumerable`1<IPersistentStorageFile> EnumerateFiles(string pattern, string compressionType, bool withMetadata, CancellationToken cancellationToken);
    public abstract virtual bool IsContainerNameValid(string containerName);
    public abstract virtual bool IsFileNameValid(string fileName);
    public abstract virtual void SetDefaultFolderSeparatorIfSupported(string folderSeparator);
    public abstract virtual void CopyFrom(IPersistentStorageContainer from, bool overwrite);
    public abstract virtual string GetEncryptionScope();
    public abstract virtual Task RenameFileAsync(string source, string target, bool overwrite, string compressionType);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageContainerAsyncEnumerator {
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageFactory {
    public abstract virtual IPersistentStorageContainer GetContainer(string containerUri, StorageItemOpenMode openMode, IKustoTokenCredentialsProvider credentialsProvider, StorageItemLocationMode locationMode, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, string encryptionScope, IEnumerable`1<string> allowedAuthMethods);
    public abstract virtual IEnumerable`1<IPersistentStorageContainer> EnumerateTopLevelContainers(string storageUri, string searchPattern, IEnumerable`1<string> allowedAuthMethods);
    public abstract virtual IPersistentStorageUri ParseUri(string resourceUri);
    public abstract virtual IPersistentStorageContainer CreateContainerRef(string containerUri, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, bool callerIsTrusted, IEnumerable`1<string> allowedAuthMethods);
    public abstract virtual IPersistentStorageFile CreateFileRef(string uri, IKustoTokenCredentialsProvider credentialsProvider, string compressionType, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, StorageItemLocationMode locationMode, FileKnownMetadata knownMetadata, StorageFileUsageCriteria storageFileUsageCriteria, IEnumerable`1<string> allowedAuthMethods);
    public abstract virtual IServiceCalloutValidator GetServiceCalloutValidator(string uri);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageFile {
    public IPersistentStorageFileCompressor PersistentStorageFileCompressor { get; }
    public StorageItemLocation StorageItemLocation { get; }
    public bool IsMetadataAvailableLocally { get; }
    public abstract virtual IPersistentStorageFileCompressor get_PersistentStorageFileCompressor();
    public abstract virtual StorageItemLocation get_StorageItemLocation();
    public abstract virtual bool get_IsMetadataAvailableLocally();
    public abstract virtual string GetFileUri();
    public abstract virtual string GetUnsecureUri();
    public abstract virtual string ToSecureString();
    public abstract virtual string GetFileName();
    public abstract virtual string GetFileETag();
    public abstract virtual bool Exists();
    public abstract virtual Task`1<bool> ExistsAsync();
    public abstract virtual long GetLength();
    public abstract virtual Task`1<long> GetLengthAsync();
    public abstract virtual DateTime GetLastModified();
    public abstract virtual Stream OpenRead(OnStreamRead onRead, bool preferStreaming);
    public abstract virtual StreamOrLocalFile OpenAsSeekableStream(OnStreamRead onRead, bool preferStreaming);
    public abstract virtual Stream OpenWrite(SerializationAccessMode serializationAccessMode);
    public abstract virtual Task DownloadToFileAsync(string localPath, FileMode fileMode, CancellationToken cancellationToken);
    public abstract virtual Task DownloadToStreamAsync(Stream target, CancellationToken cancellationToken);
    public abstract virtual Task UploadFromStreamAsync(Stream source, SerializationAccessMode serializationAccessMode);
    public abstract virtual Task UploadFromStreamIfSupportedAsync(Stream source, string expectedETag);
    public abstract virtual Task UploadFromFileAsync(string file, bool isBinary, SerializationAccessMode serializationAccessMode);
    public abstract virtual Task`1<bool> DeleteIfExistsAsync();
    public abstract virtual string CreateShareablePath(SasPermissions permissions, DateTimeOffset startTime, DateTimeOffset expiryTime);
    public abstract virtual IPersistentStorageFile DuplicateReferenceWithNoCache();
    public abstract virtual string GetExceptionMessage(Exception ex);
    public abstract virtual PersistentStorageException TranslateToPersistentStorageExceptionOrNull(string operation, Exception ex);
    public abstract virtual Task CopyFromAsync(IPersistentStorageFile source, bool overwrite);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageFileCompressor {
    public string Name { get; }
    public abstract virtual Stream OpenForRead(Stream innerStream, string streamId, bool leaveOpen, OnStreamRead onRead);
    public abstract virtual Stream OpenForWrite(Stream innerStream, string entryName, string streamId, bool leaveOpen);
    public abstract virtual string GetStreamFullFileName(string streamName);
    public abstract virtual string get_Name();
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageFileCompressorFactory {
    public abstract virtual IPersistentStorageFileCompressor CreateCompressor(string compressionType);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageNameValidator {
    public abstract virtual bool IsContainerNameValid(string containerName);
    public abstract virtual bool IsFileNameValid(string fileName);
    public abstract virtual void ValidateContainerName(string containerName);
    public abstract virtual void ValidateFileName(string fileName);
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageUri {
    public abstract virtual string ToSecureString();
    public abstract virtual string ToUnsecureString();
}
public interface Kusto.Cloud.Platform.Storage.PersistentStorage.IPersistentStorageUriMapper {
    public abstract virtual string Map(string resourceUri);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.JsonStreamWithFileProperties`1 : FileProperties {
    [CompilerGeneratedAttribute]
private T <Stream>k__BackingField;
    public T Stream { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(T value);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.MetadataCannotBeCommittedDueToAdminStateChangeException : Exception {
    public string DatabaseName;
    public DateTime CurrentEpoch;
    public DateTime DatabaseEpoch;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public MetadataCannotBeCommittedDueToAdminStateChangeException(string message, Exception innerException);
    protected MetadataCannotBeCommittedDueToAdminStateChangeException(SerializationInfo info, StreamingContext context);
    public MetadataCannotBeCommittedDueToAdminStateChangeException(string databaseName, DateTime currentEpoch, DateTime databaseEpoch, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MetadataCannotBeCommittedDueToAdminStateChangeException(string databaseName, DateTime currentEpoch, DateTime databaseEpoch, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageConnectionStringAuthenticationAdapter : object {
    private static string s_tokenAuthMethod;
    private static PersistentStorageConnectionStringAuthenticationAdapter();
    public static string ValidateUriAndNormalizeCredentials(string uri, IKustoTokenCredentialsProvider credentialsProvider, string targetResource, IServiceCalloutValidator calloutValidator);
    public static void EnsureValidCallout(Uri url, IServiceCalloutValidator calloutValidator, KustoCalloutAuthorizationClass authMethod, bool tlsIsOn);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageCopyFailedException : Exception {
    public string SourceUri;
    public string TargetUri;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageCopyFailedException(string message, Exception innerException);
    protected PersistentStorageCopyFailedException(SerializationInfo info, StreamingContext context);
    public PersistentStorageCopyFailedException(string sourceUri, string targetUri, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageCopyFailedException(string sourceUri, string targetUri, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageEncryptionScopeNotAvailableException : PersistentStorageFileConditionViolationException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageEncryptionScopeNotAvailableException(string message, Exception innerException);
    protected PersistentStorageEncryptionScopeNotAvailableException(SerializationInfo info, StreamingContext context);
    public PersistentStorageEncryptionScopeNotAvailableException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageEncryptionScopeNotAvailableException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageErrorCodes : object {
    public static int STG_E_UNKNOWN;
    public static int STG_E_PATHNOTFOUND;
    public static int STG_E_ACCESSDENIED;
    public static int RPC_E_TIMEOUT;
    private static PersistentStorageErrorCodes();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public abstract class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageException(string message, Exception innerException);
    protected PersistentStorageException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageFactoryFactory : object {
    private IServiceLocator m_locator;
    private PersistentStorageFileCompressorFactory m_persistentStorageFileCompressorFactory;
    private IPersistentStorageUriMapper m_uriMapper;
    private QuasistaticConcurrentDictionary`2<string, ServiceProvider`1<IPersistentStorageFactory>> m_providers;
    private QuasistaticConcurrentDictionary`2<string, bool> m_missingProviders;
    public PersistentStorageFactoryFactory(IServiceLocator locator, Disposer disposer, IPersistentStorageUriMapper uriMapper);
    public sealed virtual string Map(string resourceUri);
    public sealed virtual IServiceCalloutValidator GetServiceCalloutValidator(string uri);
    public sealed virtual IPersistentStorageContainer GetContainer(string containerUri, StorageItemOpenMode openMode, IKustoTokenCredentialsProvider credentialsProvider, StorageItemLocationMode locationMode, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, string encryptionScope, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IEnumerable`1<IPersistentStorageContainer> EnumerateTopLevelContainers(string storageUri, string searchPattern, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageUri ParseUri(string resourceUri);
    public sealed virtual IPersistentStorageContainer CreateContainerRef(string containerUri, StorageItemLocationMode locationMode, IKustoTokenCredentialsProvider credentialsProvider, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, bool callerIsTrusted, IEnumerable`1<string> allowedAuthMethods);
    public sealed virtual IPersistentStorageFile CreateFileRef(string uri, IKustoTokenCredentialsProvider credentialsProvider, string compressionType, IPersistentStorageFileCompressorFactory persistentStorageFileCompressorFactory, StorageItemLocationMode locationMode, FileKnownMetadata knownMetadata, StorageFileUsageCriteria storageFileUsageCriteria, IEnumerable`1<string> allowedAuthMethods);
    public IPersistentStorageFileCompressorFactory GetPersistentStorageFileCompressorFactory();
    private ServiceProvider`1<IPersistentStorageFactory> GetServiceProvider(string specification);
    private void OnPersistentStorageUriMapperRegistration(ServiceProvider`1<IPersistentStorageUriMapper> serviceProvider);
    private void OnPersistentStorageFactoryRegistration(ServiceProvider`1<IPersistentStorageFactory> serviceProvider);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageFileConditionViolationException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageFileConditionViolationException(string message, Exception innerException);
    protected PersistentStorageFileConditionViolationException(SerializationInfo info, StreamingContext context);
    public PersistentStorageFileConditionViolationException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageFileConditionViolationException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageFileRenameFailedException : PersistentStoragePathException {
    public string SourcePath;
    public string TargetPath;
    public Nullable`1<RenameFileState> RenameState;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageFileRenameFailedException(string message, Exception innerException);
    protected PersistentStorageFileRenameFailedException(SerializationInfo info, StreamingContext context);
    public PersistentStorageFileRenameFailedException(string sourcePath, string targetPath, Nullable`1<RenameFileState> renameState, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageFileRenameFailedException(string sourcePath, string targetPath, Nullable`1<RenameFileState> renameState, string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageFileRenameFailedException(string sourcePath, string targetPath, Nullable`1<RenameFileState> renameState, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageFileRenameFailedException(string sourcePath, string targetPath, Nullable`1<RenameFileState> renameState, string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageGZipCompressor : object {
    public static string CompressionType;
    public static string FileExtension;
    public string Name { get; }
    public sealed virtual Stream OpenForRead(Stream innerStream, string streamId, bool leaveOpen, OnStreamRead onRead);
    public sealed virtual Stream OpenForWrite(Stream innerStream, string entryName, string streamId, bool leaveOpen);
    public sealed virtual string GetStreamFullFileName(string streamName);
    public sealed virtual string get_Name();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageInvalidConnectionStringAuthenticationMethodException : PersistentStoragePathException {
    public string SupportedAuthMethod;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected PersistentStorageInvalidConnectionStringAuthenticationMethodException(SerializationInfo info, StreamingContext context);
    public PersistentStorageInvalidConnectionStringAuthenticationMethodException(string supportedAuthMethod, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageInvalidConnectionStringAuthenticationMethodException(string supportedAuthMethod, string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageInvalidConnectionStringAuthenticationMethodException(string supportedAuthMethod, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageInvalidConnectionStringAuthenticationMethodException(string supportedAuthMethod, string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageInvalidCredentialsException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageInvalidCredentialsException(string message, Exception innerException);
    protected PersistentStorageInvalidCredentialsException(SerializationInfo info, StreamingContext context);
    public PersistentStorageInvalidCredentialsException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageInvalidCredentialsException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageNameResolutionFailedException : PersistentStoragePathDoesNotExistException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageNameResolutionFailedException(string message, Exception innerException);
    protected PersistentStorageNameResolutionFailedException(SerializationInfo info, StreamingContext context);
    public PersistentStorageNameResolutionFailedException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageNameResolutionFailedException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageNoCompressor : object {
    public string Name { get; }
    public sealed virtual Stream OpenForRead(Stream innerStream, string streamId, bool leaveOpen, OnStreamRead onRead);
    public sealed virtual Stream OpenForWrite(Stream innerStream, string entryName, string streamId, bool leaveOpen);
    public sealed virtual string GetStreamFullFileName(string streamName);
    public sealed virtual string get_Name();
}
public static class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageNoCompressorFactoryFactory : object {
    private static IPersistentStorageFileCompressorFactory m_persistentStorageFileCompressorFactory;
    private static PersistentStorageNoCompressorFactoryFactory();
    public static IPersistentStorageFileCompressorFactory GetPersistentStorageNoCompressorFactory();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathAccessDeniedException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathAccessDeniedException(string message, Exception innerException);
    protected PersistentStoragePathAccessDeniedException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathAccessDeniedException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathAccessDeniedException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathAlreadyExistsException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathAlreadyExistsException(string message, Exception innerException);
    protected PersistentStoragePathAlreadyExistsException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathAlreadyExistsException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathAlreadyExistsException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathDoesNotExistException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathDoesNotExistException(string message, Exception innerException);
    protected PersistentStoragePathDoesNotExistException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathDoesNotExistException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathDoesNotExistException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathException : PersistentStorageException {
    public string Path;
    public string Operation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathException(string message, Exception innerException);
    protected PersistentStoragePathException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathGeneralException : PersistentStoragePathException {
    public string ExtendedErrorInformation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected PersistentStoragePathGeneralException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathGeneralException(string extendedErrorInformation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathGeneralException(string extendedErrorInformation, string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathGeneralException(string extendedErrorInformation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathGeneralException(string extendedErrorInformation, string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathInvalidHostnameException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathInvalidHostnameException(string message, Exception innerException);
    protected PersistentStoragePathInvalidHostnameException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathInvalidHostnameException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathInvalidHostnameException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStoragePathKeyVaultAccessDeniedException : PersistentStoragePathAccessDeniedException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStoragePathKeyVaultAccessDeniedException(string message, Exception innerException);
    protected PersistentStoragePathKeyVaultAccessDeniedException(SerializationInfo info, StreamingContext context);
    public PersistentStoragePathKeyVaultAccessDeniedException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStoragePathKeyVaultAccessDeniedException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageRedirectionForbiddenException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageRedirectionForbiddenException(string message, Exception innerException);
    protected PersistentStorageRedirectionForbiddenException(SerializationInfo info, StreamingContext context);
    public PersistentStorageRedirectionForbiddenException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageRedirectionForbiddenException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageServiceException : PersistentStorageException {
    public string Path;
    public string Operation;
    public string ExtendedErrorInformation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageServiceException(string message, Exception innerException);
    protected PersistentStorageServiceException(SerializationInfo info, StreamingContext context);
    public PersistentStorageServiceException(string path, string operation, string extendedErrorInformation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageServiceException(string path, string operation, string extendedErrorInformation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageThrottlingException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageThrottlingException(string message, Exception innerException);
    protected PersistentStorageThrottlingException(SerializationInfo info, StreamingContext context);
    public PersistentStorageThrottlingException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageThrottlingException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageTimeoutException : PersistentStoragePathException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageTimeoutException(string message, Exception innerException);
    protected PersistentStorageTimeoutException(SerializationInfo info, StreamingContext context);
    public PersistentStorageTimeoutException(string path, string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageTimeoutException(string path, string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    private void Construct_HResult(int hresult);
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageTrace : TraceSourceBase`1<PersistentStorageTrace> {
    public static string IdentifierString;
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageTransientDnsException : PersistentStorageServiceException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public PersistentStorageTransientDnsException(string message, Exception innerException);
    protected PersistentStorageTransientDnsException(SerializationInfo info, StreamingContext context);
    public PersistentStorageTransientDnsException(string path, string operation, string extendedErrorInformation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageTransientDnsException(string path, string operation, string extendedErrorInformation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageUnsupportedCompressionTypeException : Exception {
    public string CompressionType;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected PersistentStorageUnsupportedCompressionTypeException(SerializationInfo info, StreamingContext context);
    public PersistentStorageUnsupportedCompressionTypeException(string compressionType, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public PersistentStorageUnsupportedCompressionTypeException(string compressionType, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageWriteImplementation : Enum {
    public int value__;
    public static PersistentStorageWriteImplementation OpenWrite;
    public static PersistentStorageWriteImplementation UploadFromStream;
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.PersistentStorageZipCompressor : object {
    public static string CompressionType;
    public static string FileExtension;
    public string Name { get; }
    public sealed virtual Stream OpenForRead(Stream innerStream, string streamId, bool leaveOpen, OnStreamRead onRead);
    public sealed virtual Stream OpenForWrite(Stream innerStream, string entryName, string streamId, bool leaveOpen);
    public sealed virtual string GetStreamFullFileName(string streamName);
    public sealed virtual string get_Name();
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.PreConditions : Enum {
    public int value__;
    public static PreConditions None;
    public static PreConditions OverwriteForbidden;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.RenameFileState : Enum {
    public int value__;
    public static RenameFileState NotStarted;
    public static RenameFileState SourceFileCopied;
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.ResolvingIdentifierFromStreamNameException : Exception {
    public string Prefix;
    public string StreamName;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public ResolvingIdentifierFromStreamNameException(string message, Exception innerException);
    protected ResolvingIdentifierFromStreamNameException(SerializationInfo info, StreamingContext context);
    public ResolvingIdentifierFromStreamNameException(string prefix, string streamName, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public ResolvingIdentifierFromStreamNameException(string prefix, string streamName, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.SasPermissions : Enum {
    public int value__;
    public static SasPermissions None;
    public static SasPermissions Read;
    public static SasPermissions Write;
    public static SasPermissions Delete;
    public static SasPermissions List;
    public static SasPermissions Add;
    public static SasPermissions Create;
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.Segment`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public IEnumerable`1<T> Values { get; }
    public string ContinuationToken { get; }
    public Segment`1(IEnumerable`1<T> values, string continuationToken);
    [CompilerGeneratedAttribute]
public IEnumerable`1<T> get_Values();
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
}
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.SerializationAccessMode : Enum {
    public int value__;
    public static SerializationAccessMode Create;
    public static SerializationAccessMode CreateNew;
}
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.StorageFileUsageCriteria : Enum {
    public int value__;
    public static StorageFileUsageCriteria None;
    public static StorageFileUsageCriteria VeryShortOperations;
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.StorageItemLocation : Enum {
    public int value__;
    public static StorageItemLocation None;
    public static StorageItemLocation InProc;
    public static StorageItemLocation LocalFilesystem;
    public static StorageItemLocation RemoteFilesystem;
    public static StorageItemLocation Network;
}
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.StorageItemLocationMode : Enum {
    public int value__;
    public static StorageItemLocationMode PrimaryOnly;
    public static StorageItemLocationMode PrimaryThenSecondary;
    public static StorageItemLocationMode SecondaryOnly;
    public static StorageItemLocationMode SecondaryThenPrimary;
}
public enum Kusto.Cloud.Platform.Storage.PersistentStorage.StorageItemOpenMode : Enum {
    public int value__;
    public static StorageItemOpenMode OpenExisting;
    public static StorageItemOpenMode CreateNew;
    public static StorageItemOpenMode OpenOrCreate;
}
public class Kusto.Cloud.Platform.Storage.PersistentStorage.TrivialPersistentStorageUri : object {
    private string m_resourceUriString;
    private Uri m_resourceUri;
    public TrivialPersistentStorageUri(string resourceUri);
    public sealed virtual string ToSecureString();
    public sealed virtual string ToUnsecureString();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Storage.PersistentStorage.UpdatingPointerLocationsFailureException : Exception {
    public string Error;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UpdatingPointerLocationsFailureException(SerializationInfo info, StreamingContext context);
    public UpdatingPointerLocationsFailureException(string error, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UpdatingPointerLocationsFailureException(string error, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Storage.StorageRetryPolicy : object {
    public static TimeSpan DefaultClientBackoff;
    public static TimeSpan MaxBackoff;
    public static TimeSpan MinBackoff;
    private static StorageRetryPolicy();
    public static TimeSpan GetRetryInterval(int currentRetryCount, Nullable`1<int> minBackoffMsec, Nullable`1<int> maxBackoffMsec);
}
public interface Kusto.Cloud.Platform.Storage.VirtualFileSystem.IFileSystem {
    public abstract virtual string Combine(string basePath, string offsetPath);
    public abstract virtual IDisposable CreateScopedRootContainer(bool createContainer);
    public abstract virtual void CreateRootContainer();
    public abstract virtual string GetRootPath();
}
[DebuggerDisplayAttribute("Root={m_path}")]
public class Kusto.Cloud.Platform.Storage.VirtualFileSystem.WindowsFileSystem : object {
    private string m_path;
    private WindowsFileSystem(string folder);
    public static WindowsFileSystem CreateByPrefix(string prefix);
    public static WindowsFileSystem CreateByFolder(string folder);
    public sealed virtual string Combine(string basePath, string offsetPath);
    public sealed virtual IDisposable CreateScopedRootContainer(bool createContainer);
    public sealed virtual void CreateRootContainer();
    public sealed virtual string GetRootPath();
    [CompilerGeneratedAttribute]
private void <CreateScopedRootContainer>b__5_0();
}
public static class Kusto.Cloud.Platform.Text.ExtendedClipboard : object {
    private static Lazy`1<MethodInfo> s_lazySetTextMethodInfo;
    private static ExtendedClipboard();
    private static MethodInfo GetSetTextMethodInfo();
    private static T InvokeSingleThreadedApartment(Func`1<T> func);
    public static bool TryCopyToClipboard(string content);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Text.ExtendedGuid : object {
    public static string EmptyGuidString;
    private static char HexDigitToChar(int a);
    [ExtensionAttribute]
public static void FastAppendToStringBuilder(Guid value, StringBuilder sb, bool curlies, bool hyphens);
    [ExtensionAttribute]
public static Guid Rotate(Guid guid);
    [ExtensionAttribute]
public static bool IsEmpty(Guid guid);
    [ExtensionAttribute]
public static bool IsNotEmpty(Guid guid);
}
public class Kusto.Cloud.Platform.Text.FastCharacterNormalizer : object {
    private char m_replacement;
    private FastCharacterNormalizer(char replacement);
    public static FastCharacterNormalizer CreateWithReplacement(char replacement);
    public static FastCharacterNormalizer CreateWithNoReplacement();
    public string Normalize(string value);
    private int FindNextAbnormal(string value, int startAt);
    private int FindFirstAbnormal(Char* p, int length);
    private bool IsAbnormal(char c);
}
public class Kusto.Cloud.Platform.Text.FastWildcardMatcher : object {
    private static string s_null;
    private string m_prefix;
    private string m_suffix;
    private PatternType m_patternType;
    private StringComparison m_comparisonType;
    private string m_forbiddenWildcardCharacter;
    private FastWildcardMatcher(string prefix, string suffix, StringComparison comparisonType, PatternType patternType, Nullable`1<char> forbiddenWildcardCharacter);
    public static FastWildcardMatcher Create(string pattern, StringComparison comparisonType, Nullable`1<char> forbiddenWildcardCharacter);
    private bool CheckNoForbiddenWildcardCharacters(string value, int startIndex, int count);
    public bool IsMatch(string value);
    private static Tuple`3<PatternType, string, string> DeterminePatternType(string pattern);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Text.InvalidFormatException : FormatException {
    public string StringToParse;
    public string ParsedType;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public InvalidFormatException(string message, Exception innerException);
    protected InvalidFormatException(SerializationInfo info, StreamingContext context);
    public InvalidFormatException(string stringToParse, string parsedType, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public InvalidFormatException(string stringToParse, string parsedType, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Text.SequentialGuidGenerator : object {
    private int m_left;
    private long m_right;
    public SequentialGuidGenerator(int left);
    public Guid NewGuid();
    public FastGuid NewFastGuid();
}
public static class Kusto.Cloud.Platform.Text.StringLiteral : object {
    private static Byte[] categoryForLatin1;
    private static StringLiteral();
    public static string ParseStringLiteral(string literal);
    public static string ParseStringLiteral(string literal, Boolean& isHidden);
    public static bool TryParseStringLiteral(string str, String& literal);
    public static bool TryParseStringLiteral(string str, String& literal, Boolean& isHidden);
    public static bool Equals(string str1, string str2);
    public static string TrimSingleQuotes(string name);
    public static string TrimBrackets(string input);
    public static void InitArray(T[] arr, T value);
    public static string GetLiteral(string value);
    public static string GetLiteralAsHiddenString(string value);
    public static string GetLiteral(string value, bool hidden);
    private static bool ShouldBeEscaped(char c);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
}
public static class Kusto.Cloud.Platform.Text.StringLiteralParser : object {
    private static bool TryParseMultilineStringLiteral(string literal, int pos, int length, String& result);
    private static string SubstringAndReduce(string literal, int pos, int length, char c);
    public static bool TryParseStringLiteral(string literal, String& result, Boolean& isHidden);
}
public class Kusto.Cloud.Platform.Text.TemplateFormatter`1 : object {
    private string m_template;
    private Func`3<string, TArgs, object> m_argFetcher;
    private ComponentFormatter[] m_componentFormatters;
    public TemplateFormatter`1(string template, Func`3<string, TArgs, object> argFetcher);
    public string Format(TArgs args, Func`2<string, string> formatExceptionHandler);
    private static ComponentFormatter[] ParseTemplate(string template);
    private static ValueTuple`2<int, ComponentFormatter<TArgs>> ParseTemplateArg(string template, int pos);
}
public class Kusto.Cloud.Platform.Threading.BlockingCollectionPartitioner`1 : Partitioner`1<T> {
    private BlockingCollection`1<T> m_collection;
    private CancellationToken m_cancellationToken;
    public bool SupportsDynamicPartitions { get; }
    public BlockingCollectionPartitioner`1(BlockingCollection`1<T> collection, CancellationToken cancellationToken);
    public virtual bool get_SupportsDynamicPartitions();
    public virtual IList`1<IEnumerator`1<T>> GetPartitions(int partitionCount);
    public virtual IEnumerable`1<T> GetDynamicPartitions();
}
public class Kusto.Cloud.Platform.Threading.ConcurrentJobsBatcher`1 : object {
    private ConcurrentJobsBatcherConfiguration m_configuration;
    private Action`1<IEnumerable`1<TJob>> m_jobsExecutor;
    private string m_name;
    private ConcurrentQueue`1<TJob> m_jobsQueue;
    private JobsContext<TJob> m_currentJobsContext;
    private int m_activeJobExecutors;
    private ReaderWriterLockSlim m_switchContextLock;
    private object m_lastTimeQueueProcessedLock;
    private object m_activeJobExecutorsLock;
    private int m_disposed;
    private ConcurrentJobsBatcherState<TJob> m_state;
    private Task m_waitForJobExecutors;
    private DateTime m_lastTimeQueueProcessed;
    private Timer m_timer;
    private static ConcurrentJobsBatcherPeriodicActivityType<TJob> s_concurrentJobsBatcherPeriodicActivityType;
    private static ConcurrentJobsBatcherJobsExecutionActivityType<TJob> s_jobsExecutionActivityType;
    public string Name { get; }
    public ConcurrentJobsBatcher`1(Action`1<IEnumerable`1<TJob>> jobsExecutor, string name, ConcurrentJobsBatcherConfiguration configuration);
    private static ConcurrentJobsBatcher`1();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void QueueJob(TJob job);
    public sealed virtual void ExecuteJob(TJob job, bool executeImmediately);
    public sealed virtual void Stop();
    public sealed virtual void WaitForStopToComplete();
    public sealed virtual void Shutdown();
    private void CreatePeriodicQueueChecker();
    private void DequeueAndExecuteJobsPeriodic();
    private bool ShouldProcessQueue(TimeSpan minTimeToElapseSinceLastProcess);
    private void DelayPeriodic();
    private JobsBatch<TJob> TryGetJobsWithContext();
    private JobsBatch<TJob> DequeueAllJobsAndSwitchContext();
    private void TryGetJobsWithContextAndExecute(TJob additionalJobToExecute);
    private void PerformActionUnderActiveJobExecutorsCounter(Action action);
    private void ExecuteJobsBatch(JobsBatch<TJob> jobsBatch, TJob additionalJobToExecute);
    private void AddJobToQueueAndWaitForCompletion(TJob job);
    private JobsContext<TJob> AddJobToQueue(TJob job);
    private void SetStateToStopInProgress();
    private void ThrowIfStopped(string operation);
    private static string ActivitySafeToString(Activity activity);
    [CompilerGeneratedAttribute]
private void <Stop>b__22_0();
    [CompilerGeneratedAttribute]
private void <CreatePeriodicQueueChecker>b__25_0();
    [CompilerGeneratedAttribute]
private void <CreatePeriodicQueueChecker>b__25_1(object _);
    [CompilerGeneratedAttribute]
private void <DequeueAndExecuteJobsPeriodic>b__26_0();
    [CompilerGeneratedAttribute]
private void <DequeueAndExecuteJobsPeriodic>b__26_1();
}
public class Kusto.Cloud.Platform.Threading.ConcurrentJobsBatcherConfiguration : object {
    [CompilerGeneratedAttribute]
private TimeSpan <JobMaxTimeUntilExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <JobsExecutionTimeout>k__BackingField;
    public TimeSpan JobMaxTimeUntilExecution { get; }
    public TimeSpan JobsExecutionTimeout { get; }
    public ConcurrentJobsBatcherConfiguration(TimeSpan jobMaxTimeUntilExecution, TimeSpan jobsExecutionTimeout);
    [CompilerGeneratedAttribute]
public TimeSpan get_JobMaxTimeUntilExecution();
    [CompilerGeneratedAttribute]
public TimeSpan get_JobsExecutionTimeout();
}
public class Kusto.Cloud.Platform.Threading.ConcurrentJobsBatcherFactory`1 : object {
    public sealed virtual IConcurrentJobsBatcher`1<TJob> Create(Action`1<IEnumerable`1<TJob>> jobsExecutor, string name, ConcurrentJobsBatcherConfiguration configuration);
}
public static class Kusto.Cloud.Platform.Threading.ExtendedMutex : object {
    public static Mutex AcquireMutex(string mutexName, Nullable`1<TimeSpan> timeout, Nullable`1<TimeSpan> pollInterval, ITraceSource tracer);
}
public interface Kusto.Cloud.Platform.Threading.IConcurrentJobsBatcher`1 {
    public abstract virtual void QueueJob(TJob job);
    public abstract virtual void ExecuteJob(TJob job, bool executeImmediately);
}
public interface Kusto.Cloud.Platform.Threading.IConcurrentJobsBatcherFactory`1 {
    public abstract virtual IConcurrentJobsBatcher`1<TJob> Create(Action`1<IEnumerable`1<TJob>> jobsExecutor, string name, ConcurrentJobsBatcherConfiguration configuration);
}
public class Kusto.Cloud.Platform.Threading.LimitBlockingCollectionPartitioner`1 : ThrottlingBlockingCollectionPartitioner`1<T> {
    private int m_take;
    private int m_count;
    public LimitBlockingCollectionPartitioner`1(BlockingCollection`1<T> collection, Action throttlerAction, int every, int take, CancellationToken cancellationToken);
    public virtual IEnumerable`1<T> GetDynamicPartitions();
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Threading.LimitBlockingCollectionPartitioner`1/<InterlockedTakeIterator>d__4`1")]
private IEnumerable`1<TSource> InterlockedTakeIterator(IEnumerable`1<TSource> source);
}
public class Kusto.Cloud.Platform.Threading.ThrottlingBlockingCollectionPartitioner`1 : BlockingCollectionPartitioner`1<T> {
    private Action m_throttlerAction;
    private int m_every;
    private long m_counter;
    public ThrottlingBlockingCollectionPartitioner`1(BlockingCollection`1<T> collection, Action throttlerAction, int every, CancellationToken cancellationToken);
    public virtual IEnumerable`1<T> GetDynamicPartitions();
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Threading.ThrottlingBlockingCollectionPartitioner`1/<InterlockedThrottlingIterator>d__5`1")]
private IEnumerable`1<TSource> InterlockedThrottlingIterator(IEnumerable`1<TSource> source);
}
public class Kusto.Cloud.Platform.Threading.WaitHandleAsyncFactory : object {
    public static Task FromWaitHandle(WaitHandle handle);
    public static Task`1<bool> FromWaitHandle(WaitHandle handle, TimeSpan timeout);
    public static Task FromWaitHandle(WaitHandle handle, CancellationToken token);
    public static Task`1<bool> FromWaitHandle(WaitHandle handle, TimeSpan timeout, CancellationToken token);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Threading.WaitHandleAsyncFactory/<DoFromWaitHandle>d__4")]
private static Task`1<bool> DoFromWaitHandle(WaitHandle handle, TimeSpan timeout, CancellationToken token);
}
[DebuggerDisplayAttribute("Resource={m_resourceKind}/{m_resourceId}, Max={m_maxConcurrentCalls}, Outstanding={m_outstanding}")]
public class Kusto.Cloud.Platform.Throttling.AdjustableMaxConcurrentCallsThrottlerPolicy : object {
    private string m_resourceKind;
    private string m_resourceId;
    private Action`2<ResourceUtilizationMeasure, bool> m_onChange;
    private int m_outstanding;
    private int m_maxConcurrentCalls;
    public int MaxConcurrentCalls { get; public set; }
    public AdjustableMaxConcurrentCallsThrottlerPolicy(string resourceKind, string resourceId, int maxConcurrentCalls, Action`2<ResourceUtilizationMeasure, bool> onChange);
    public int get_MaxConcurrentCalls();
    public void set_MaxConcurrentCalls(int value);
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public sealed virtual void OnInvokeDone();
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    private void NotifyOnChange(int outstanding, bool utilizationWentUp);
}
public class Kusto.Cloud.Platform.Throttling.AggregateThrottlerPolicy : object {
    private IThrottlerPolicy[] m_throttlerPolicies;
    public AggregateThrottlerPolicy(IThrottlerPolicy[] throttlerPolicies);
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Throttling.AggregateThrottlerPolicy/<ShouldInvokeAsync>d__3")]
public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    public sealed virtual void OnInvokeDone();
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    private void ReleaseInvoked(int lastInvokedIndex);
    private DateTime ProvideUtcNow(Nullable`1<DateTime> utcNow);
}
public interface Kusto.Cloud.Platform.Throttling.IOperationsPolicer {
    public abstract virtual void RemoveOperationThrottlerPolicy(Func`3<string, IThrottlerPolicy, bool> predicate);
    public abstract virtual bool TryGetOperationThrottlerPolicy(string policerResourceId, IThrottlerPolicy& throttler);
    public abstract virtual IThrottlerPolicy GetOperationThrottlerPolicy(string policerResourceId);
    public abstract virtual IThrottlerPolicy GetOrAddOperationThrottlerPolicy(string policerResourceId, IThrottlerPolicy throttler);
    public abstract virtual IThrottlerPolicy GetOrAddOperationThrottlerPolicy(string policerResourceId, Func`2<string, IThrottlerPolicy> throttlerFactory);
}
public class Kusto.Cloud.Platform.Throttling.OperationsPolicer : object {
    private ConcurrentDictionary`2<string, IThrottlerPolicy> m_throttlersDictionary;
    public sealed virtual void RemoveOperationThrottlerPolicy(Func`3<string, IThrottlerPolicy, bool> predicate);
    public sealed virtual bool TryGetOperationThrottlerPolicy(string policerResourceId, IThrottlerPolicy& throttler);
    public sealed virtual IThrottlerPolicy GetOperationThrottlerPolicy(string policerResourceId);
    public sealed virtual IThrottlerPolicy GetOrAddOperationThrottlerPolicy(string policerResourceId, IThrottlerPolicy throttler);
    public sealed virtual IThrottlerPolicy GetOrAddOperationThrottlerPolicy(string policerResourceId, Func`2<string, IThrottlerPolicy> throttlerFactory);
}
public class Kusto.Cloud.Platform.Tracing.RecordingTraceListener : TraceListener {
    private object m_lock;
    private LinkedList`1<string> m_recorded;
    private Action`1<RecordingTraceListener> m_onDisposed;
    private TriState m_confidential;
    [CompilerGeneratedAttribute]
private string <ServiceAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RolloverPeriod>k__BackingField;
    public string ServiceAlias { get; public set; }
    public string MachineName { get; public set; }
    public string TargetFolder { get; }
    public TimeSpan RolloverPeriod { get; public set; }
    public TriState IsConfidential { get; public set; }
    public RecordingTraceListener(Action`1<RecordingTraceListener> onDisposed);
    public sealed virtual void SuperFlush();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceAlias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServiceAlias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MachineName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFolder();
    [CompilerGeneratedAttribute]
public TimeSpan get_RolloverPeriod();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RolloverPeriod(TimeSpan value);
    public sealed virtual TriState get_IsConfidential();
    public void set_IsConfidential(TriState value);
    public virtual void Close();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public IEnumerable`1<string> PlaybackAndErase();
    private void WriteInternal(TraceEventType eventType, string source, string message);
}
public abstract class Kusto.Cloud.Platform.Utils.AbstractConsumerPool`1 : object {
    protected ConcurrentQueue`1<TConsumable> m_toConsumeQueue;
    protected ConcurrentDictionary`2<TConsumable, bool> m_deduplicateSet;
    protected IAtomicCounter m_consumersCounter;
    protected Func`2<Action, Task> m_taskRunner;
    private protected ConsumerPoolTracer m_tracer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected AbstractConsumerPool`1(string name, long maxConsumersInParallel, bool guaranteeAllWorkIsDoneWhenDisposed, IEqualityComparer`1<TConsumable> deduplicatingComparer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public abstract virtual void EnqueueRange(IEnumerable`1<TConsumable> items);
    public sealed virtual void Enqueue(TConsumable item);
}
public class Kusto.Cloud.Platform.Utils.AccumulateAndNotifyDumper : object {
    private Action`1<string> m_notify;
    private bool m_formatBufferAsJson;
    private StringBuilder m_sb;
    private StringBuilder m_sbBuffer;
    private bool m_disposed;
    public bool SupportsText { get; }
    public bool SupportsBinary { get; }
    public AccumulateAndNotifyDumper(Action`1<string> notify, bool formatBufferAsJson);
    public sealed virtual void Dispose();
    public sealed virtual bool get_SupportsText();
    public sealed virtual bool get_SupportsBinary();
    public sealed virtual void Append(string text);
    public sealed virtual void Append(Char[] buffer, int start, int count);
    public sealed virtual void Append(Byte[] buffer, int start, int count);
    private void FlushBufferIfNeeded();
}
public class Kusto.Cloud.Platform.Utils.AccumulateAndNotifyOpinionatedDumper : AccumulateAndNotifyDumper {
    private Func`2<string, bool> m_predicate;
    public AccumulateAndNotifyOpinionatedDumper(Action`1<string> notify, Func`2<string, bool> predicate, bool formatBufferAsJson);
    public sealed virtual bool Predicate(string arg);
}
public class Kusto.Cloud.Platform.Utils.ActionBasedIDisposable : object {
    private int m_numDisposed;
    private Action m_action;
    private bool m_swallowExceptions;
    private bool m_invokeActionOnFinalization;
    private Context m_creationContext;
    public ActionBasedIDisposable(Action action, bool swallowExceptions, bool invokeActionOnFinalization);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.Activity : object {
    [DataMemberAttribute]
private Guid m_activityId;
    [DataMemberAttribute]
private Guid m_subActivityId;
    [DataMemberAttribute]
private Guid m_parentActivityId;
    [DataMemberAttribute]
private string m_clientRequestId;
    [DataMemberAttribute]
private string m_activityType;
    public Guid ActivityId { get; }
    public Guid SubActivityId { get; }
    public Guid ParentActivityId { get; }
    public string ClientRequestId { get; }
    public string ActivityType { get; }
    public Guid get_ActivityId();
    public Guid get_SubActivityId();
    public Guid get_ParentActivityId();
    public string get_ClientRequestId();
    public string get_ActivityType();
    public virtual string ToString();
    public static Activity FromString(string str);
    public Activity CreateSubActivity(ActivityType activityType);
    public static Activity CreateTopLevelActivity(ActivityType activityType, string clientRequestId);
    public static Activity CreateImportActivity(Guid activityId, Guid subActivityId, Guid parentActivityId, string clientRequestId, string activityType);
    public sealed virtual bool Equals(Activity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Kusto.Cloud.Platform.Utils.ActivityStack : object {
    private Stack`1<Activity> m_stack;
    internal ActivityStack(IEnumerable`1<Activity> stack);
    public sealed virtual IEnumerator`1<Activity> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
public abstract class Kusto.Cloud.Platform.Utils.ActivityType : object {
    private string m_name;
    private string m_description;
    private TraceVerbosity m_createTraceVerbosity;
    private TraceVerbosity m_succeededTraceVerbosity;
    private TraceVerbosity m_FailedTraceVerbosity;
    public string Name { get; }
    public string Description { get; }
    public TraceVerbosity CreateTraceVerbosity { get; }
    public TraceVerbosity SucceededTraceVerbosity { get; }
    public TraceVerbosity FailedTraceVerbosity { get; }
    protected ActivityType(string name, string description, TraceVerbosity createTraceVerbosity, TraceVerbosity succeededTraceVerbosity, TraceVerbosity failedTraceVerbosity);
    protected ActivityType(string name, string description);
    public static string NormalizeArbitraryStringAsActivityTypeName(string name);
    public string get_Name();
    public string get_Description();
    public virtual TraceVerbosity get_CreateTraceVerbosity();
    public virtual TraceVerbosity get_SucceededTraceVerbosity();
    public virtual TraceVerbosity get_FailedTraceVerbosity();
}
public class Kusto.Cloud.Platform.Utils.AggregateResult`2 : object {
    private object m_lock;
    private int m_nResults;
    private List`1<OpResult<TInput, TResult>> m_results;
    public void SetResult(int index, TInput input, TResult result);
    public void SetException(int index, TInput input, Exception exception);
    public IEnumerable`1<Tuple`3<TInput, TResult, Exception>> GetCompletedResults();
    public IEnumerable`1<Tuple`3<TInput, TResult, Exception>> WaitAndGetCompletedResults(int numResults);
    private void SetOpResult(int index, OpResult<TInput, TResult> opResult);
}
public enum Kusto.Cloud.Platform.Utils.AlertDebuggerBehavior : Enum {
    public int value__;
    public static AlertDebuggerBehavior Dont;
    public static AlertDebuggerBehavior IfAttached;
    public static AlertDebuggerBehavior Always;
}
public static class Kusto.Cloud.Platform.Utils.Anchor : object {
    private static Assembly s_anchorAssembly;
    private static string s_anchorAssemblyName;
    private static string s_anchorAssemblyLocation;
    private static Tweaks s_tweaks;
    private static GarbageCollector s_garbageCollector;
    private static CriticalTimer s_criticalTimer;
    public static Tweaks Tweaks { get; }
    internal static CriticalTimer CriticalTimer { get; }
    private static Anchor();
    private static void PreventCloudPlatformFromMultipleLoad();
    internal static void Initialize();
    public static Tweaks get_Tweaks();
    internal static CriticalTimer get_CriticalTimer();
}
internal class Kusto.Cloud.Platform.Utils.AppSettingsBaseProvider : object {
    private DefaultTraceListener m_trace;
    private object m_locker;
    private string m_id;
    private OnAppSettingsChanged m_onAppSettingsChanged;
    private NameValueDictionary m_switches;
    protected int CountForDebugging { get; }
    public string Name { get; }
    protected AppSettingsBaseProvider(string id, OnAppSettingsChanged onAppSettingsChanged);
    protected void Trace(string format, Object[] args);
    protected void SetAppSettings(NameValueDictionary switches);
    protected void SetNameValue(string name, string value);
    protected void InvokedOnAppSettingsChanged();
    protected int get_CountForDebugging();
    public sealed virtual NameValueDictionary GetAppSettings();
    public sealed virtual string get_Name();
}
internal class Kusto.Cloud.Platform.Utils.AppSettingsFileProvider : AppSettingsBaseProvider {
    private string m_path;
    private string m_file;
    private FileSystemWatcher m_fileWatcher;
    public AppSettingsFileProvider(OnAppSettingsChanged onAppSettingsChanged, string path, string file);
    public void StartWatching();
    public virtual string ToString();
    private static string CreateIdFromPathFile(string path, string file);
    private void OnFileChanged(object sender, FileSystemEventArgs e);
    private void ReadAppSettingsFromFile(string file);
}
internal class Kusto.Cloud.Platform.Utils.AppSettingsInMemoryProvider : AppSettingsBaseProvider {
    public AppSettingsInMemoryProvider(string id, OnAppSettingsChanged onAppSettingsChanged);
    public void SetNameValue(string name, string value);
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Utils.AsAppropriateStreamWriter : TextWriter {
    private Func`1<Stream> m_streamFactory;
    private Encoding m_encoding;
    private Stream m_stream;
    private StreamWriter m_writer;
    public Encoding Encoding { get; }
    public AsAppropriateStreamWriter(Func`1<Stream> streamFactory, Encoding encoding);
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual void Flush();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    private void OpenIfNeeded();
}
public static class Kusto.Cloud.Platform.Utils.AssemblyLoader : object {
    [ThreadStaticAttribute]
private static int RunWithDisabledVersionedAssemblyResolutionThreadId;
    private static AssemblyLoader();
    public static object LoadAndCallFactory(string assemblyNameOrPath, string binPath, string typeName, string factoryName, Object[] factoryArgs, ITraceSource tracer);
    private static T RunWithDisabledVersionedAssemblyResolution(Func`1<T> func);
    private static string CopyAssemblyAndSymbolsIfNeeded(string sourceFullFilePath, string destPath, ITraceSource tracer);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.AssertionFailedException : Exception {
    public string Assertion;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected AssertionFailedException(SerializationInfo info, StreamingContext context);
    public AssertionFailedException(string assertion, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public AssertionFailedException(string assertion, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.AsyncInvokeOptions : Enum {
    public int value__;
    public static AsyncInvokeOptions None;
    public static AsyncInvokeOptions RunWithClearContext;
    public static AsyncInvokeOptions LongRunning;
    public static AsyncInvokeOptions RethrowExceptions;
}
public static class Kusto.Cloud.Platform.Utils.AsyncInvoker : object {
    public static void Invoke(Action action, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void Invoke(Action`1<TContext> action, TContext context, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static Task InvokeAsTask(Action`1<TContext> action, TContext context, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static Task InvokeAsync(Action action, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static Task`1<TResult> InvokeAsync(Func`1<TResult> action, Func`2<Exception, TResult> faultAction, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static Task`1<TResult> InvokeAsync(Func`1<TResult> action, string faultTraceMessage, AsyncInvokeOptions options, string actionName, string callerMemberName, string callerFilePath, int callerLineNumber);
    private static Task`1<TResult> StartTask(AsyncInvokerCapsuleFunc`1<TResult> capsule);
    private static Task`1<TResult> StartTask(AsyncInvokerCapsuleFuncFault`1<TResult> capsule);
    private static Task StartTask(AsyncInvokerCapsuleAction`1<TContext> capsule);
    private static Task StartTask(AsyncInvokerCapsuleAction capsule);
    private static void StartThread(AsyncInvokerCapsuleAction capsule);
    private static void StartThread(AsyncInvokerCapsuleAction`1<TContext> capsule);
}
public class Kusto.Cloud.Platform.Utils.AsyncLock : object {
    private SemaphoreSlim m_semaphoreSlim;
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.AsyncLock/<LockAsync>d__2")]
public Task`1<IDisposable> LockAsync();
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Utils.AsyncManualResetEvent : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_tcs;
    public Task WaitAsync();
    public void Set();
    public void Reset();
}
public class Kusto.Cloud.Platform.Utils.AsyncReaderWriterLockSlim : object {
    private object syncRoot;
    private bool isDisposed;
    private SemaphoreSlim writeLockSemaphore;
    private SemaphoreSlim readLockReleaseSemaphore;
    private WriteLockState currentWriteLockState;
    private int currentReadLockCount;
    private long currentWaitingWriteLockCount;
    private static int GetRemainingTimeout(int millisecondsTimeout, long initialTicks);
    public sealed virtual void Dispose();
    public void EnterReadLock(CancellationToken cancellationToken);
    public Task EnterReadLockAsync(CancellationToken cancellationToken);
    public bool TryEnterReadLock(int millisecondsTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.AsyncReaderWriterLockSlim/<TryEnterReadLockAsync>d__13")]
public Task`1<bool> TryEnterReadLockAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    public void EnterWriteLock(CancellationToken cancellationToken);
    public Task EnterWriteLockAsync(CancellationToken cancellationToken);
    public bool TryEnterWriteLock(int millisecondsTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.AsyncReaderWriterLockSlim/<TryEnterWriteLockAsync>d__17")]
public Task`1<bool> TryEnterWriteLockAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    public void DowngradeWriteLockToReadLock();
    public void ExitReadLock();
    public void ExitWriteLock();
    protected virtual void Dispose(bool disposing);
    private void DenyIfDisposed();
    private bool EnterReadLockPreface(WriteLockState& existingWriteLockState);
    private void EnterReadLockPostface(WriteLockState existingLockState, bool waitResult);
    private void ExitReadLockCore(bool getLock);
    private bool EnterWriteLockPreface(Boolean& waitForReadLocks);
    private void EnterWriteLockPostface(bool writeLockWaitResult, Boolean& waitForReadLocks, bool getLock);
    private void HandleEnterWriteLockWaitFailure();
    private void ExitWriteLockInternal(bool downgradeLock);
    private void ExitWriteLockCore(bool downgradeLock, bool waitFailure);
    private void ReleaseWriteLockState();
}
public class Kusto.Cloud.Platform.Utils.AsyncSemaphore : object {
    private long m_count;
    private long m_maxCount;
    private ConcurrentStack`1<TaskCompletionSource`1<bool>> m_waiting;
    public int CurrentCount { get; }
    public AsyncSemaphore(int initialCount, int maxCount);
    public int get_CurrentCount();
    public Task WaitAsync();
    public void Release();
}
public class Kusto.Cloud.Platform.Utils.AtomicBucketCounter : AtomicCounter {
    private TimeSpan m_intervalSize;
    private TimeSpan m_bucketLifetime;
    private DateTime m_lastPeriodic;
    private Guid m_activeBucketGuid;
    private IDictionary`2<Guid, Bucket> m_buckets;
    public AtomicBucketCounter(string name, ITraceSource tracer);
    public AtomicBucketCounter(string name, ITraceSource tracer, AtomicBucketCounterPolicy policy);
    public AtomicBucketCounter(string name, long initialCapacity, ITraceSource tracer);
    public AtomicBucketCounter(string name, long initialCapacity, ITraceSource tracer, AtomicBucketCounterPolicy policy);
    public sealed virtual long Take(long count, ReturnKey& returnKey);
    public sealed virtual void Return(long count, ReturnKey returnKey);
    private void RefreshBucketsUnderLock(DateTime currentTime);
    private void RefreshBucketsPeriodicIfNeededUnderLock(DateTime currentTime);
    protected virtual void TraceCapacityChanged(long from, long to);
}
public class Kusto.Cloud.Platform.Utils.AtomicBucketCounterPolicy : object {
    [CompilerGeneratedAttribute]
private TimeSpan <IntervalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BucketLifetime>k__BackingField;
    public static AtomicBucketCounterPolicy Default;
    public TimeSpan IntervalSize { get; private set; }
    public TimeSpan BucketLifetime { get; private set; }
    public AtomicBucketCounterPolicy(TimeSpan intervalSize, TimeSpan bucketLifetime);
    private static AtomicBucketCounterPolicy();
    [CompilerGeneratedAttribute]
public TimeSpan get_IntervalSize();
    [CompilerGeneratedAttribute]
private void set_IntervalSize(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_BucketLifetime();
    [CompilerGeneratedAttribute]
private void set_BucketLifetime(TimeSpan value);
}
public class Kusto.Cloud.Platform.Utils.AtomicCounter : object {
    protected object m_lock;
    protected long m_capacity;
    protected long m_remaining;
    protected long m_consumed;
    protected ITraceSource m_tracer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public AtomicCounter(string name, ITraceSource tracer);
    public AtomicCounter(string name, long initialCapacity, ITraceSource tracer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual long Take(long count);
    public sealed virtual void Return(long count);
    public sealed virtual void Resize(long newCapacity);
    public sealed virtual AtomicCounterSnapshot TakeSnapshot();
    protected virtual void TraceCapacityChanged(long from, long to);
}
public class Kusto.Cloud.Platform.Utils.AtomicCounterSnapshot : object {
    [CompilerGeneratedAttribute]
private long <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Remaining>k__BackingField;
    public long Capacity { get; private set; }
    public long Consumed { get; private set; }
    public long Remaining { get; private set; }
    public AtomicCounterSnapshot(long capacity, long consumed, long remaining);
    [CompilerGeneratedAttribute]
public long get_Capacity();
    [CompilerGeneratedAttribute]
private void set_Capacity(long value);
    [CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    [CompilerGeneratedAttribute]
public long get_Remaining();
    [CompilerGeneratedAttribute]
private void set_Remaining(long value);
}
public class Kusto.Cloud.Platform.Utils.AtomicNetworkCounter : object {
    private object m_lock;
    private string m_name;
    private AtomicCounter m_counter;
    private Dictionary`2<string, long> m_entitiesAcquiredCapacity;
    private Dictionary`2<string, DateTime> m_entitiesCapacityLastReported;
    private DateTime m_lastReportTime;
    private Dictionary`2<string, long> m_entitiesLastReportVersion;
    private bool m_isReportingRequired;
    public string Name { get; }
    public AtomicNetworkCounter(string name, bool isReportingRequired);
    public AtomicNetworkCounter(string name, long initialCapacity, bool isReportingRequired);
    public sealed virtual string get_Name();
    public sealed virtual long Take(long count, string entityId);
    public sealed virtual void Return(long count, string entityId);
    public sealed virtual void ReportEntityAcquiredCapacity(string entityId, long consumed, long reportVersion, bool disableTraces);
    public sealed virtual void Resize(long newCapacity);
    public sealed virtual AtomicCounterSnapshot TakeSnapshot();
    public void CleanExpiredEntitiesCapacity(TimeSpan entityReportTimeout, bool disableTraces);
    private bool IsOutdatedReportVersion(string entityId, long consumed, long reportVersion);
    [CompilerGeneratedAttribute]
private string <CleanExpiredEntitiesCapacity>b__17_0(string entity);
    [CompilerGeneratedAttribute]
private string <CleanExpiredEntitiesCapacity>b__17_1(string entity);
}
public class Kusto.Cloud.Platform.Utils.AtomicNetworkCountersManager : object {
    private List`1<AtomicNetworkCounter> m_counters;
    private PeriodicNonoverlappingTimer m_timer;
    private static double c_periodicTaskFrequency;
    private TimeSpan m_entitiesAcquiredCapacityTimeout;
    private object m_lock;
    private static AtomicNetworkCountersManagerPeriodicActivityType m_atomicNetworkCounterPeriodicActivityType;
    private static AtomicNetworkCountersManager();
    public sealed virtual void Dispose();
    public AtomicNetworkCounter CreateCounter(string name, bool isReportingRequired);
    public void SetReportCapacityTimeoutForTests(TimeSpan entitiesAcquiredCapacityTimeout);
    private void CleanExpiredEntitiesCapacityForAllCountersPeriodic(PeriodicNonoverlappingTimer timer, object o);
    private void StartPeriodicIfNeeded();
}
public class Kusto.Cloud.Platform.Utils.BatchConsumerPool`1 : AbstractConsumerPool`1<TConsumable> {
    private Action`1<IEnumerable`1<TConsumable>> m_batchConsumerAction;
    private Func`2<IEnumerable`1<TConsumable>, string> m_batchConsumablesToString;
    public BatchConsumerPool`1(string name, long maxConsumersInParallel, Action`1<IEnumerable`1<TConsumable>> batchConsumerAction, bool guaranteeAllWorkIsDoneWhenDisposed, IEqualityComparer`1<TConsumable> deduplicatingComparer, Func`2<IEnumerable`1<TConsumable>, string> batchConsumablesToString);
    public virtual void EnqueueRange(IEnumerable`1<TConsumable> items);
    private void BatchConsume();
}
public class Kusto.Cloud.Platform.Utils.BigList`1 : object {
    private int c_elementsPerArray;
    private List`1<T[]> m_arrays;
    private long m_count;
    private int m_nextElementArrayIndex;
    private int m_nextElementArrayOffset;
    private int m_version;
    public long Count { get; }
    public int ElementSizeForDebugging { get; }
    public BigList`1(int capacity);
    public BigList`1(IEnumerable`1<T> source);
    private BigList`1(T dummy);
    public long get_Count();
    public int get_ElementSizeForDebugging();
    public void Add(T item);
    public void Reset(int capacity);
    public Enumerator<T> GetUnsafeEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Utils.BigLookup`2 : object {
    private Dictionary`2<TKey, BigList`1<TElement>> m_data;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public void Add(TKey key, TElement element);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.BigLookup`2/<GetEnumerator>d__8")]
public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Kusto.Cloud.Platform.Utils.BinaryFileDumper : object {
    private Stream m_stream;
    public bool SupportsText { get; }
    public bool SupportsBinary { get; }
    public BinaryFileDumper(string fileName);
    public sealed virtual void Dispose();
    public sealed virtual bool get_SupportsText();
    public sealed virtual bool get_SupportsBinary();
    public sealed virtual void Append(string text);
    public sealed virtual void Append(Char[] buffer, int start, int count);
    public sealed virtual void Append(Byte[] buffer, int start, int count);
}
[DefaultMemberAttribute("Item")]
public abstract class Kusto.Cloud.Platform.Utils.BinaryHeap`1 : object {
    private List`1<T> m_entries;
    private Action`2<int, T> m_notification;
    public int Count { get; }
    public T Top { get; }
    public T Item { get; public set; }
    public BinaryHeap`1(Action`2<int, T> notification, IEnumerable`1<T> elements);
    public BinaryHeap`1(BinaryHeap`1<T> other, Func`2<IEnumerable`1<T>, IEnumerable`1<T>> modifier);
    public int get_Count();
    public void Push(T entry);
    public T get_Top();
    public T get_Item(int position);
    public void set_Item(int position, T value);
    public void Remove(int position);
    public void Pop();
    private Exception Notify(int i);
    private Exception Swap(int i, int j);
    protected abstract virtual int Compare(T a, T b);
    private Exception SiftUp(int position);
    private Exception SiftDown(int position);
    private Exception Heapify(int position);
}
public static class Kusto.Cloud.Platform.Utils.BitTwiddling : object {
    public static int CountBits(int n);
    public static int CountBits(long n);
}
public static class Kusto.Cloud.Platform.Utils.BlobStorageResourceUriParseUtilities : object {
    private static string s_tokenAuthMethod;
    private static string s_managedIdentityAuthMethod;
    public static Char[] s_uriSecretDelimiters;
    public static string DevStoreAccountBlobEndpoint { get; }
    private static BlobStorageResourceUriParseUtilities();
    public static string get_DevStoreAccountBlobEndpoint();
    public static string GetResourceUriWithoutSecrets(string path);
    public static String[] SplitResourceUriToUriAndSecrets(string path, Char& delimiter);
    public static string CombineResourceUriWithKey(string path, string key);
    public static string CombineResourceUriWithSasKey(string path, string sasKey);
    public static string CombineResourceUriWithToken(string path, string token);
    public static string CombineResourceUriWithManagedIdentityAuthenticationHint(string path, string managedIdentityIdentifier);
    public static bool TryExtractCallerCredentialsFromResourceUri(string uriString, String& callerCredentials, Boolean& isSas);
    public static bool DoesResourceUriHaveSecrets(string path);
}
public class Kusto.Cloud.Platform.Utils.BomParser : object {
    private static State[0...,0...] s_transitionToState;
    private State m_state;
    private Byte[] m_buffer;
    private int m_bufferCount;
    private static BomParser();
    private static State[0...,0...] CreateTransitionToState();
    public void Reset();
    public BomParserResult Parse(byte b);
    private static string FinalStateToName(State state);
}
public class Kusto.Cloud.Platform.Utils.BomParserResult : object {
    public bool EncodingDetermined;
    public string Encoding;
    public Byte[] NonBomBytes;
    public int NonBomBytesCount;
}
public static class Kusto.Cloud.Platform.Utils.BrowserLauncher : object {
    public static bool TryLaunchBrowser(string uri);
}
public class Kusto.Cloud.Platform.Utils.ByteArrayTextReader : StreamReader {
    public ByteArrayTextReader(Byte[] buffer, Encoding encoding);
    public ByteArrayTextReader(Byte[] buffer, int index, int count, Encoding encoding);
    public ByteArrayTextReader(Byte[] buffer, int index, int count, bool detectEncodingFromByteOrderMark);
    public ByteArrayTextReader(Byte[] buffer, int index, int count, Encoding encoding, bool detectEncodingFromByteOrderMark);
}
public class Kusto.Cloud.Platform.Utils.BytePointerReadStream : Stream {
    private Byte* m_buffer;
    private int m_bufferSize;
    private int m_pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BytePointerReadStream(Byte* buffer, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Utils.CachedBufferEncoder : object {
    private Encoding m_encoding;
    private int m_maxData;
    private Encoder m_encoder;
    private Byte[] m_encodingByteBuffer;
    private Char[] m_encodingCharBuffer;
    private Byte[] m_encodingCrlfBuffer;
    private int m_encodingCrlfBufferSize;
    public CachedBufferEncoder(Encoding encoding, int maxData);
    public Buffer WriteLine(string text);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.CertificateBySubjectAndIssuerNameNotFoundException : UtilsException {
    public string SubjectName;
    public string IssuerName;
    public string StoreLocation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public CertificateBySubjectAndIssuerNameNotFoundException(string message, Exception innerException);
    protected CertificateBySubjectAndIssuerNameNotFoundException(SerializationInfo info, StreamingContext context);
    public CertificateBySubjectAndIssuerNameNotFoundException(string subjectName, string issuerName, string storeLocation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectAndIssuerNameNotFoundException(string subjectName, string issuerName, string storeLocation, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectAndIssuerNameNotFoundException(string subjectName, string issuerName, string storeLocation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectAndIssuerNameNotFoundException(string subjectName, string issuerName, string storeLocation, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.CertificateBySubjectNameNotFoundException : UtilsException {
    public string SubjectName;
    public string StoreLocation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public CertificateBySubjectNameNotFoundException(string message, Exception innerException);
    protected CertificateBySubjectNameNotFoundException(SerializationInfo info, StreamingContext context);
    public CertificateBySubjectNameNotFoundException(string subjectName, string storeLocation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectNameNotFoundException(string subjectName, string storeLocation, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectNameNotFoundException(string subjectName, string storeLocation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateBySubjectNameNotFoundException(string subjectName, string storeLocation, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.CertificateNotFoundException : UtilsException {
    public string Thumbprint;
    public string StoreLocation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public CertificateNotFoundException(string message, Exception innerException);
    protected CertificateNotFoundException(SerializationInfo info, StreamingContext context);
    public CertificateNotFoundException(string thumbprint, string storeLocation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateNotFoundException(string thumbprint, string storeLocation, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateNotFoundException(string thumbprint, string storeLocation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public CertificateNotFoundException(string thumbprint, string storeLocation, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum Kusto.Cloud.Platform.Utils.ChopOptions : Enum {
    public int value__;
    public static ChopOptions ChopFromBeginning;
    public static ChopOptions ChopFromEnd;
    public static ChopOptions ChopFromMiddle;
    public static ChopOptions ThreeDotsCharacterNotSupported;
}
public class Kusto.Cloud.Platform.Utils.ClientDetails : object {
    private static Dictionary`2<char, string> s_replaceChars;
    public string ApplicationName;
    public string UserName;
    public string ClientVersion;
    public ClientDetails(string applicationName, string userName, string clientVersion, string clientInstance, bool replaceNullsWithDefaults);
    public ClientDetails(string applicationName, string userName, string clientVersion, bool replaceNullsWithDefaults);
    public ClientDetails(string applicationName, string userName, Type typeInClient, bool replaceNullsWithDefaults);
    private static ClientDetails();
    private static string GetUserName();
    public static string GetClientVersionStringForAssembly(Type typeInAssembly, string clientInstance);
    public static string BuildHeaderFormat(ValueTuple`2[] values);
    private static string EscapeHeader(string value);
    public static string GetProcessName();
    public static ValueTuple`2<string, string> SetConnectorDetails(string name, string version, string appName, string appVersion, bool sendUser, string overrideUser, ValueTuple`2[] additional);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.ClientServerProfile : Enum {
    public int value__;
    public static ClientServerProfile Client;
    public static ClientServerProfile Server;
}
public enum Kusto.Cloud.Platform.Utils.CloudPlatformExecutionMode : Enum {
    public int value__;
    public static CloudPlatformExecutionMode None;
    public static CloudPlatformExecutionMode Library;
    public static CloudPlatformExecutionMode HostEnvironment;
}
internal static class Kusto.Cloud.Platform.Utils.CloudPlatformLibrary : object {
    public static Assembly Assembly;
    public static string AssemblyManifestFileOrNull;
    public static string AssemblyManifestDirectoryOrNull;
    public static string AssemblyNameAndProductVersion;
    public static string ProductVersion;
    private static CloudPlatformLibrary();
}
public class Kusto.Cloud.Platform.Utils.CodeGenerator : object {
    private StringWriter m_swriter;
    private IndentedTextWriter m_writer;
    private bool m_emptyAbove;
    private static String[] c_newline;
    private static CodeGenerator();
    public string GetText();
    public void WriteHeader(string templateExtension, string templateName);
    public void WriteUsingBlock(IEnumerable`1<string> usingNamespaces, bool addBclNamespaces, bool addKcpNamespaces);
    public void WriteNamespaceDeclaration(string namespace, Action inside);
    public void WriteNamespaceDeclarationBegin(string namespace);
    public void WriteNamespaceDeclarationEnd();
    public void WriteIfBlock(string if, Action inside);
    public void WriteIfBlock(string if, string body);
    public void WriteRegion(string region, Action inside);
    public void WriteRegionSlim(string region, Action inside);
    public void WriteRegionBegin(string region);
    public void WriteRegionEnd(string region);
    public void WriteDocString(string summary, string remarks);
    public void WriteScope(string head, Action inside, string suffix);
    public void WriteScopeStart();
    public void WriteScopeStart(string head);
    public void WriteScopeEnd(string suffix);
    public void UnsafeIndent();
    public void UnsafeUnindent();
    public void WriteEmptyLineIfNeeded();
    public void WriteLine();
    public void Write(string text);
    public void WriteLine(string text, bool detectNewLines);
    public void WriteLine(string format, Object[] args);
    public static string GetPascalCase(string name);
    public static string GetCamelCase(string name);
    public static string GetClassMemberName(string name);
}
public class Kusto.Cloud.Platform.Utils.ComDisposer : object {
    private object m_object;
    public ComDisposer(object obj);
    public void Detach();
    public sealed virtual void Dispose();
}
[AttributeUsageAttribute("256")]
public class Kusto.Cloud.Platform.Utils.CommandLineArgAttribute : Attribute {
    public string ShortName;
    public String[] Aliases;
    public string FullName;
    public string Description;
    public object DefaultValue;
    public bool Mandatory;
    public bool IsSecret;
    public bool ContainsKnownSecrets;
    public bool SupportsEncryption;
    public string WhenSet;
    public bool AllowNull;
    public bool ParseAsJson;
    public CommandLineArgAttribute(string fullName, string description);
    public CommandLineArgAttribute(string fullName, string description, String[] aliases);
    public IEnumerable`1<string> GetShortNameAndAliases();
}
[AttributeUsageAttribute("4")]
public class Kusto.Cloud.Platform.Utils.CommandLineArgsAttribute : Attribute {
    public string Description;
    public string WhenDone;
    public CommandLineArgsAttribute(string description);
}
public static class Kusto.Cloud.Platform.Utils.CommandLineArgsParser : object {
    public static string MultiValueSeparator;
    private static Char[] c_quote;
    private static char c_multiValueSeparator;
    private static Char[] c_multiValueSeparatorArray;
    private static BindingFlags WhenXxxLookup;
    private static string s_debugArgName;
    private static CommandLineArgsParser();
    public static void DebugSetArgName(string argName);
    public static String[] SplitCommandLineArgsString(string line);
    public static IEnumerable`1<ValueTuple`2<CommandLineArgAttribute, FieldInfo>> GetCommandLineArgAttributes(Object[] targets);
    public static void WriteHelpStringMarkdown(ExtendedStringBuilder esb, Object[] targets);
    public static void WriteHelpString(ExtendedStringBuilder esb, Object[] targets);
    public static void WriteHelpStringTo(ExtendedStringBuilder esb, IEnumerable`1<object> targets, string predeterminedArguments);
    public static string ToCommandLineString(T target, bool secure, bool omitDefaultValues, bool shouldEscapeOnSpaces);
    public static IEnumerable`1<KeyValuePair`2<string, string>> ToKeyValueStringsPairs(T target, bool secure, bool omitDefaultValues);
    private static String[] ToCommandLineArgsImpl(T target, bool secure, bool omitDefaultValues, bool fileFormat, bool shouldEscapeOnSpaces);
    public static String[] ToCommandLineArgs(T target, bool secure, bool omitDefaultValues, bool shouldEscapeOnSpaces);
    public static string CreateResponseFile(Object[] targets, string filePath, bool secure, bool omitDefaultValues);
    public static void WriteHelpStringToConsoleAndQuit(String[] args, T target, string fault);
    public static void WriteHelpStringToConsoleAndQuit(IEnumerable`1<string> args, T target, string fault);
    public static void WriteHelpStringToConsoleAndQuit(String[] args, T target, string fault, bool markdown);
    private static void WriteHelpStringToConsoleAndQuit(IEnumerable`1<string> args, T target, string fault, bool markdown);
    private static void ParseTrampoline(IEnumerable`1<string> args, T target);
    public static T Parse(IEnumerable`1<string> args, T target, Action`3<String[], T, string> faultAction, bool autoHelp, string envVar);
    public static void Parse(String[] args, Object[] targets, Action`3<String[], object, string> faultAction, bool autoHelp, string envVar);
    public static T Decrypt(T target, string decryptionCertificateThumbprint);
    public static T Decrypt(T target, IDecryptor decryptor);
    private static void GatherArgsForHelpString(Object[] targets, HashSet`1<string> names, List`1<Tuple`2<CommandLineArgAttribute, FieldInfo>> args, List`1<string> descriptions);
    private static void GatherArgsForHelpString(object target, HashSet`1<string> names, List`1<Tuple`2<CommandLineArgAttribute, FieldInfo>> args, List`1<string> descriptions);
    private static string FormatArg(Tuple`2<CommandLineArgAttribute, FieldInfo> pair, bool includeDefaultValue);
    private static string AsString(CommandLineArgAttribute attribute, object value, bool secure, bool fileFormat, bool shouldEscapeOnSpaces);
    private static bool ShouldEscape(string str, bool shouldEscapeOnSpaces);
    private static IEnumerable`1<string> ResolveResponseFile(IEnumerable`1<string> args);
    private static void ResolveResponseFileImpl(IEnumerable`1<string> args, Boolean& acceptingFreeArgs, LinkedList`1<string> freeArgs, Dictionary`2<string, List`1<string>> namedArgs);
    private static bool IsDash(char c);
    private static bool StartsWithSwitchCharacter(string what);
    private static void GetFreeAndCandidateArgs(IEnumerable`1<string> args, string envVar, LinkedList`1& freeArgs, Dictionary`2& candidateArgs);
    private static ValueTuple`2<string, string> GetArgumentNameAndValue(string a);
    private static void AssignArgsToTargetGetValue(IEnumerable`1<string> args, T target, Action`3<String[], T, string> faultAction, LinkedList`1<string> freeArgs, Dictionary`2<string, string> candidateArgs);
    private static bool TryGetValue(Dictionary`2<string, string> candidateArgs, string fullName, IEnumerable`1<string> aliases, String& value);
    private static string GetLastValueIfMultivalue(string value);
    private static void DebugBreakOnArgName(string argName);
    private static void SetField(object target, FieldInfo field, string switchName, string value, bool allowNull, bool parseAsJson);
    private static bool IsHelpArgEnabled(IDictionary`2<string, string> args, string switchName);
    private static void VerifyNoNullValue(string switchName, string value);
    private static void VerifyNoMultiValue(string switchName, string value);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.CommunicationContext : object {
    [DataMemberAttribute]
private bool m_shouldTrackConnection;
    public bool ShouldTrackConnection { get; }
    public CommunicationContext(bool shouldTrackConnection);
    public bool get_ShouldTrackConnection();
}
public class Kusto.Cloud.Platform.Utils.CompletionCallback : object {
    private object m_lock;
    private Action`2<CompletionCallbackCompletionStatus, object> m_callback;
    private CompletionCallbackCompletionStatus modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    private Timer m_timer;
    private object m_timerGeneration;
    public CompletionCallback(Action`2<CompletionCallbackCompletionStatus, object> callback);
    public bool SetTimeout(TimeSpan timeout);
    public bool Complete(CompletionCallbackCompletionStatus state, object completionContext);
    private void OnTimer(object context);
    private bool CompleteImpl(CompletionCallbackCompletionStatus state, object completionContext, object timerGeneration);
    private static string GetStateString(CompletionCallbackCompletionStatus state);
}
public enum Kusto.Cloud.Platform.Utils.CompletionCallbackCompletionStatus : Enum {
    public int value__;
    public static CompletionCallbackCompletionStatus Pending;
    public static CompletionCallbackCompletionStatus Completed;
    public static CompletionCallbackCompletionStatus Cancelled;
    public static CompletionCallbackCompletionStatus Timeout;
    public static CompletionCallbackCompletionStatus Shutdown;
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.ConcurrentJobsBatcherJobFailedException : Exception {
    public object Job;
    public Exception Ex;
    public string Activity;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public ConcurrentJobsBatcherJobFailedException(string message, Exception innerException);
    protected ConcurrentJobsBatcherJobFailedException(SerializationInfo info, StreamingContext context);
    public ConcurrentJobsBatcherJobFailedException(object job, Exception ex, string activity, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public ConcurrentJobsBatcherJobFailedException(object job, Exception ex, string activity, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Utils.ConditionGroup : object {
    private static TimeSpan s_defaultCheckInterval;
    private List`1<ConditionItem> m_conditionList;
    private string m_conditionGroupName;
    private ConditionGroup(string conditionGroupName);
    private static ConditionGroup();
    public static ConditionGroup AllConditions(string conditionGroupName);
    public ConditionGroup IsNotNull(Func`1<T> predicate, string objectName);
    public ConditionGroup IsTrue(Func`1<bool> predicate, string evaluatedCondition);
    public ConditionGroup IsFalse(Func`1<bool> predicate, string evaluatedCondition);
    public ConditionGroup IsNotNullOrWhitespace(Func`1<string> predicate, string stringName);
    public bool AreMet(bool throwOnFailure);
    public bool AreMetWithin(TimeSpan timespan, Nullable`1<TimeSpan> checkInterval, Nullable`1<DateTime> now, bool throwOnFailure);
    private static bool EvaluateAllConditions(string conditionGroupName, ConditionItem[] conditions, Boolean[]& results, bool throwOnFailure, bool lastRun);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.ConditionGroupEvaluationFailedException : Exception {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public ConditionGroupEvaluationFailedException(string message, Exception innerException);
    protected ConditionGroupEvaluationFailedException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Kusto.Cloud.Platform.Utils.ConditionItem : object {
    [CompilerGeneratedAttribute]
private string <ConditionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConditionFailTerm>k__BackingField;
    private Func`1<bool> m_predicate;
    public string ConditionName { get; private set; }
    public string ConditionFailTerm { get; private set; }
    public ConditionItem(string conditionName, string failTerm, Func`1<bool> predicate);
    [CompilerGeneratedAttribute]
public string get_ConditionName();
    [CompilerGeneratedAttribute]
private void set_ConditionName(string value);
    [CompilerGeneratedAttribute]
public string get_ConditionFailTerm();
    [CompilerGeneratedAttribute]
private void set_ConditionFailTerm(string value);
    public bool Evaluate();
}
public class Kusto.Cloud.Platform.Utils.ConsoleTraceListener : TraceListener {
    private static int s_disabledCount;
    private static Char[] c_comma;
    public bool IsThreadSafe { get; }
    private static ConsoleTraceListener();
    public static void Enable();
    public static void Disable();
    public static bool IsEnabled();
    public virtual bool get_IsThreadSafe();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    private void WriteInternal(TraceEventType eventType, string source, string message);
    public static bool ParseFinalMessage(string finalMessage, String& originalMessage, DateTime& dateTime);
}
public class Kusto.Cloud.Platform.Utils.ConsumeRateLimiter : object {
    private double m_R;
    private double m_D;
    private DateTime m_T;
    public virtual string ToString();
    public double GetCurrentRateInUnitsPerSecond(DateTime now);
    public void ReportConsumption(DateTime now, double units, TimeSpan duration);
    private void AdvanceStateToTime(DateTime new_T);
}
public class Kusto.Cloud.Platform.Utils.ConsumerPool`1 : AbstractConsumerPool`1<TConsumable> {
    private Action`1<TConsumable> m_consumerAction;
    private Func`2<TConsumable, string> m_consumableToString;
    public ConsumerPool`1(string name, int maxConsumersInParallel, Action`1<TConsumable> consumerAction, bool guaranteeAllWorkIsDoneWhenDisposed, IEqualityComparer`1<TConsumable> deduplicatingComparer, Func`2<TConsumable, string> consumableToString);
    public virtual void EnqueueRange(IEnumerable`1<TConsumable> items);
    private void Consume();
    [CompilerGeneratedAttribute]
private string <EnqueueRange>b__3_0(TConsumable item);
}
internal class Kusto.Cloud.Platform.Utils.ConsumerPoolTracer : TraceSourceBase`1<ConsumerPoolTracer> {
    public TraceVerbosity DefaultVerbosity { get; }
    public string Id { get; }
    public virtual TraceVerbosity get_DefaultVerbosity();
    public virtual string get_Id();
}
public class Kusto.Cloud.Platform.Utils.Context : MarshalByRefObject {
    private static Context s_empty;
    private static AsyncLocal`1<Context> s_current;
    private Context m_prevContext;
    private Activity m_activityContext;
    private MonitoredActivity m_monitoredActivityContext;
    private TracingContext m_tracingContext;
    private CommunicationContext m_communicationContext;
    private KuiperContext m_kuiperContext;
    private bool m_setInAsyncAwait;
    public static Activity ActivityContext { get; }
    internal Activity InternalActivityContext { get; }
    public static MonitoredActivity MonitoredActivityContext { get; }
    public static KuiperContext KuiperContext { get; }
    public static TracingContext TracingContext { get; }
    public static CommunicationContext CommunicationContext { get; }
    private static Context CurrentContext { get; private set; }
    private static Context();
    public static Context Capture();
    public static IDisposable Restore(Context context);
    public static IDisposable RestoreIfNoContextPresent(Context context);
    public static IDisposable Suppress();
    public static IDisposable TemporarilyReplaceContext(Activity activityContext, TracingContext tracingContext, CommunicationContext communicationContext, KuiperContext kuiperContext);
    public static void SetInAsyncAwait();
    private static IDisposable TemporarilyReplaceContext(Context newContext);
    public static void Clear();
    public static void RunWithClearContext(Action action);
    public static void RunWithClearContext(T input, Action`1<T> action);
    public static TResult RunWithClearContext(Func`1<TResult> func);
    public static TResult RunWithClearContext(T input, Func`2<T, TResult> func);
    public virtual string ToString();
    private sealed virtual override void System.IDisposable.Dispose();
    public static Activity get_ActivityContext();
    internal Activity get_InternalActivityContext();
    public static MonitoredActivity get_MonitoredActivityContext();
    public static KuiperContext get_KuiperContext();
    internal static IDisposable PushActivityContext(Activity activity, MonitoredActivity monitoredActivity);
    public static IDisposable PushActivityContext(Activity activity);
    public static IDisposable PushNewActivityContext(ActivityType activityType, string clientRequestId);
    public static IDisposable PushNewActivityContextIfHasNone(ActivityType activityType, string clientRequestId);
    public static ActivityStack GetActivityStack();
    public static TracingContext get_TracingContext();
    public static IDisposable PushTracingContext(TracingContext tracingContext);
    public static CommunicationContext get_CommunicationContext();
    public static IDisposable PushCommunicationContext(CommunicationContext communicationContext);
    public static IDisposable PushKuiperContext(KuiperContext kuiperContext);
    private static Context get_CurrentContext();
    private static void set_CurrentContext(Context value);
    private static Context CloneAndPush();
    private Context Clone();
}
public static class Kusto.Cloud.Platform.Utils.ContextAwareTraceFormatter : object {
    private static int c_maxDataSize;
    private static string c_emptyGuidString;
    private static string s_instanceId;
    private static string s_serviceAlias;
    private static string s_machineName;
    private static int s_instanceNumericId;
    private static ContextAwareTraceFormatter();
    public static void SetStaticContext(string serviceAlias, string machineName, string instanceId, int instanceNumericId);
    public static void GetStaticContext(String& serviceAlias, String& machineName, String& instanceId, Int32& instanceNumericId);
    public static bool ShouldTrace(TraceVerbosity traceVerbosity, TraceVerbosity sourceVerbosity);
    public static bool ShouldTrace(TraceVerbosity traceVerbosity, TraceVerbosity sourceTraceVerbosity, TracingContext tracingContext);
    public static void Trace(TraceSource traceSource, TraceVerbosity verbosity, string message);
    public static void Trace(TraceSource traceSource, TraceVerbosity verbosity, TraceVerbosity overrideTraceVerbosityLevel, TracingContext tracingContext, Activity activity, string sourceId, string message);
    public static void TraceNoHeader(TraceSource traceSource, TraceVerbosity verbosity, string message);
    [ConditionalAttribute("TRACE")]
public static void EnsureTraceEnabledByThrowing(Exception ex);
    private static void TraceData(TraceSource traceSource, TracingContext tracingContext, TraceEventType eventType, int id, object data, TraceEventCache eventCache);
    public static string LimitAndEscapeValue(string value, int maxSize, List`1& rest);
    private static bool ShouldOmitAnAdditionalDoubleQuote(string value, int startIndex, int maxSize);
    private static int CountBackwardTrailingCharSequenceLength(string value, int startIndex, int endIndex, char c);
    public static string GetSourceId(int entropy, string str);
    public static string GetSourceId(string entropy, string str);
}
public class Kusto.Cloud.Platform.Utils.ContextBoundTracer`1 : ValueType {
    private T m_tracer;
    private Activity m_activityContext;
    private TracingContext m_tracingContext;
    private TraceVerbosity m_overrideTraceVerbosityLevel;
    public ContextBoundTracer`1(T tracer);
    public void TraceFatal(string message);
    public void TraceFatal(string format, Object[] args);
    public void TraceError(string message);
    public void TraceError(string format, Object[] args);
    public void TraceWarning(string message);
    public void TraceWarning(string format, Object[] args);
    public void TraceInformation(string message);
    public void TraceInformation(string format, Object[] args);
    public void TraceVerbose(string message);
    public void TraceVerbose(string format, Object[] args);
    public bool ShouldTrace(TraceVerbosity level);
}
public static class Kusto.Cloud.Platform.Utils.CountConstants : object {
    public static int _1K;
    public static int _64K;
    public static int _1M;
}
public class Kusto.Cloud.Platform.Utils.CountingStream : Stream {
    private Stream m_inner;
    private long m_bytesRead;
    private long m_bytesWritten;
    private OnStreamRead m_onRead;
    private OnStreamWrite m_onWrite;
    private OnStreamDispose m_onDispose;
    public long BytesRead { get; }
    public long BytesWritten { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CountingStream(Stream inner);
    public CountingStream(Stream inner, OnStreamRead onRead, OnStreamWrite onWrite, OnStreamDispose onDispose);
    public long get_BytesRead();
    public long get_BytesWritten();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.CountingStream/<ReadAsync>d__34")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.CountingStream/<WriteAsync>d__35")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public static class Kusto.Cloud.Platform.Utils.CrashHandler : object {
    private static string c_cannotEvenCrashProperly;
    private static string c_newline;
    private static FirstChanceExceptionPrivateTracer s_tracer;
    private static FirstChanceExceptionBaselineTracer s_tracerBaseline;
    private static object s_lock;
    private static CrashTrail s_crashTrails;
    [ThreadStaticAttribute]
private static bool ts_firstChanceExceptionScope;
    public static string CrashHandlerFirstChanceExceptionTraceSourceName { get; }
    private static CrashHandler();
    public static string get_CrashHandlerFirstChanceExceptionTraceSourceName();
    internal static void Initialize();
    public static void Crash(CrashScenario scenario, string message, Action`1<string> failAction);
    public static void Crash(CrashScenario scenario, string message);
    public static void Crash(CrashScenario scenario, string message, Exception ex);
    public static void Crash(string message, Exception ex, Action`1<string> failAction);
    public static void InvokeWithFirstChanceExceptionTracingOverride(TraceVerbosity verbosity, Action action);
    internal static IEnumerable`1<IManageableTraceSource> GetTracers();
    internal static void TraceAccumulatedStatus();
    private static void CrashImpl(CrashScenario scenario, string message, Exception ex, Action`1<string> failAction);
    private static int UnhandledExceptionFilter(IntPtr exceptionInfo);
    private static void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e);
    private static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    private static void OnUnhandledException(object exceptionObject);
    private static bool IsHttpListenerException(Exception ex);
    private static bool IsMdsCommonException(Exception ex);
}
public enum Kusto.Cloud.Platform.Utils.CrashScenario : Enum {
    public int value__;
    public static CrashScenario None;
    public static CrashScenario Unknown;
    public static CrashScenario FailSlow;
    public static CrashScenario UnhandledException;
    public static CrashScenario BackgroundThread;
    public static CrashScenario ProcessHasTimedOut;
    public static CrashScenario UnrecoverableException;
}
public class Kusto.Cloud.Platform.Utils.CrashSiteInformation : object {
    public int ThreadId;
    public UInt32 ExceptionCode;
    public IntPtr Arg0;
    public IntPtr Arg1;
    public IntPtr Arg2;
    public IntPtr Arg3;
    public UInt32 StackTraceFramesMaxCount;
    public UInt32 StackTraceFramesCount;
    public IntPtr StackTraceFramesAddresses;
}
public class Kusto.Cloud.Platform.Utils.CrashTrail : object {
    private CrashScenario m_crashScenario;
    private StackTrace m_crashStackTrace;
    private string m_message;
    private Exception m_ex;
    private string m_asString;
    public CrashTrail(CrashScenario scenario, string message, Exception ex);
    public string AsString();
    public virtual string ToString();
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.CreationContext : object {
    [DataMemberAttribute]
public DateTime Timestamp;
    [DataMemberAttribute]
public string ServiceAlias;
    [DataMemberAttribute]
public string MachineName;
    [DataMemberAttribute]
public string ProcessName;
    [DataMemberAttribute]
public int ProcessId;
    [DataMemberAttribute]
public int ThreadId;
    [DataMemberAttribute]
public string AppDomainName;
    [DataMemberAttribute]
public string CallStack;
    [DataMemberAttribute]
public Activity ActivityContext;
    [DataMemberAttribute]
public string ActivityStack;
    [DataMemberAttribute]
public TracingContext TracingContext;
    [DataMemberAttribute]
public MonitoredActivity MonitoredActivityContext;
    [DataMemberAttribute]
public string TestContext;
    public CreationContext(bool deserializing);
    public CreationContext(bool deserializing, bool captureCallStack);
    public static IDisposable PushTestContext(string value, ActivityType activityType, string clientActivityId);
    public virtual string ToString();
    public sealed virtual void WriteAsString(ExtendedStringBuilder esb);
    public static CreationContext FromJsonString(string creationContextAsString);
    public string ToJsonString();
}
public class Kusto.Cloud.Platform.Utils.CriticalTimer : object {
    private string m_name;
    private bool m_autoStart;
    private object m_lock;
    private TrivialSortedList`1<TimerRegistration> m_timers;
    private Thread m_thread;
    private bool m_disposed;
    public string Name { get; }
    public CriticalTimer(string name, bool autoStart);
    public sealed virtual void Dispose();
    public sealed virtual string get_Name();
    public void RegisterPeriodicTimer(string timerId, TimeSpan period, Action action, ActivityType activityType);
    public void Start();
    private void StartTimerThreadIfNeededUnderLock();
    private void TimerThread();
    private void Invoke(TimerRegistration timerRegistration);
    [CompilerGeneratedAttribute]
private void <StartTimerThreadIfNeededUnderLock>b__12_0();
}
public class Kusto.Cloud.Platform.Utils.CsvFromDataReaderJitStream : CsvJitStream {
    private IDataReader m_input;
    private bool m_leaveOpen;
    private bool m_writeHeader;
    private bool m_enumerationStarted;
    private int m_fieldCount;
    private bool m_enumerationDone;
    public CsvFromDataReaderJitStream(IDataReader input, bool leaveOpen, ITraceSource tracer, int internalBufferSize, Encoding encoding, bool writeHeader);
    protected virtual bool WriteRecord(WriteField writeField, Boolean& recordWritten);
    protected virtual bool IsEndOfStream();
    private void WriteRecord(WriteField writeField);
}
public class Kusto.Cloud.Platform.Utils.CsvFromIEnumerableJitStream`1 : CsvJitStream {
    private IEnumerator`1<TRecord> m_input;
    private Action`2<TRecord, WriteField> m_writeRecord;
    private bool m_enumerationDone;
    public CsvFromIEnumerableJitStream`1(IEnumerable`1<TRecord> input, Action`2<TRecord, WriteField> writeRecord, ITraceSource tracer, int internalBufferSize, Encoding encoding);
    protected virtual bool WriteRecord(WriteField writeField, Boolean& recordWritten);
    protected virtual bool IsEndOfStream();
}
public enum Kusto.Cloud.Platform.Utils.CsvFromJsonStream_TransformationMethod : Enum {
    public int value__;
    public static CsvFromJsonStream_TransformationMethod None;
    public static CsvFromJsonStream_TransformationMethod PropertyBagArrayToDictionary;
    public static CsvFromJsonStream_TransformationMethod SourceLocation;
    public static CsvFromJsonStream_TransformationMethod SourceLineNumber;
    public static CsvFromJsonStream_TransformationMethod UnknownMethod1;
    public static CsvFromJsonStream_TransformationMethod UnknownMethod;
    public static CsvFromJsonStream_TransformationMethod DateTimeFromUnixSeconds;
    public static CsvFromJsonStream_TransformationMethod DateTimeFromUnixMilliseconds;
    public static CsvFromJsonStream_TransformationMethod DateTimeFromUnixMicroseconds;
    public static CsvFromJsonStream_TransformationMethod DateTimeFromUnixNanoseconds;
    public static CsvFromJsonStream_TransformationMethod DropMappedFields;
    public static CsvFromJsonStream_TransformationMethod BytesAsBase64;
}
public abstract class Kusto.Cloud.Platform.Utils.CsvJitStream : Stream {
    private CsvJitStreamHelper m_csvJitStreamHelper;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool EndOfStream { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected CsvJitStream(ITraceSource tracer, int internalBufferSize, Encoding encoding);
    protected virtual void Dispose(bool disposing);
    protected void CompleteRecord();
    protected abstract virtual bool WriteRecord(WriteField writeField, Boolean& recordWritten);
    protected abstract virtual bool IsEndOfStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public bool get_EndOfStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Utils.CsvJitStreamHelper : object {
    private WriteRecord m_writeRecord;
    private ITraceSource m_tracer;
    private int m_internalBufferSize;
    private Encoding m_encoding;
    private bool m_isInitialized;
    private Byte[] m_readByteBuffer;
    private Stream m_csvIntermediateStream;
    private IXsvWriter m_csvWriter;
    private WriteField m_csvWriteField;
    private long m_lastInternalStreamPositionRead;
    private long m_lastInternalStreamPositionWrite;
    public bool HasPendingData { get; }
    public CsvJitStreamHelper(WriteRecord writeRecord, ITraceSource tracer, int internalBufferSize, Encoding encoding);
    public sealed virtual void Dispose();
    public void CompleteRecord();
    public bool get_HasPendingData();
    public int ReadByte();
    public int Read(Byte[] buffer, int offset, int count);
    private void InitializeIfNeeded();
    private void ResetIntermediateStream();
    private void DisposeCsvIntermediateStreamAndCsvWriter();
    private void RecreateInternalStreamIfNeeded();
    private int CopyBytesToReadBuffer(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
private void <ResetIntermediateStream>b__21_0(string data);
}
public class Kusto.Cloud.Platform.Utils.CsvWriter : object {
    protected bool m_firstField;
    protected TextWriter m_writer;
    [CompilerGeneratedAttribute]
private long <BytesWritten>k__BackingField;
    public long BytesWritten { get; protected set; }
    protected CsvWriter(TextWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual long get_BytesWritten();
    [CompilerGeneratedAttribute]
protected void set_BytesWritten(long value);
    public static IXsvWriter Create(TextWriter writer, CsvWriterImplementation implementation);
    public static IXsvWriter Create(Stream stream, Encoding encoding, CsvWriterImplementation implementation);
    public static string EscapeIfNeeded(string what, bool addDoubleQuotesIfEscaped);
    public virtual bool WriteField(string what, bool abortOnWriteFailures);
    public sealed virtual void Flush();
    public virtual void CompleteRecord();
}
public enum Kusto.Cloud.Platform.Utils.CsvWriterImplementation : Enum {
    public int value__;
    public static CsvWriterImplementation Default;
    public static CsvWriterImplementation Legacy;
    public static CsvWriterImplementation Fast;
    public static CsvWriterImplementation UltraFast;
}
public static class Kusto.Cloud.Platform.Utils.CurrentProcess : object {
    [CompilerGeneratedAttribute]
private static string <MainModuleFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MainModuleShortFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MainModuleDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NameOrMainModule>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private static ProcessWellKnownHost <WellKnownHost>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasMainWindowsHandle>k__BackingField;
    public static string MainModuleFileName { get; private set; }
    public static string MainModuleShortFileName { get; private set; }
    public static string MainModuleDirectory { get; private set; }
    public static string Name { get; private set; }
    public static string NameOrMainModule { get; private set; }
    public static int Id { get; private set; }
    public static ProcessWellKnownHost WellKnownHost { get; private set; }
    public static string NodeId { get; public set; }
    public static string InstanceId { get; public set; }
    public static bool HasMainWindowsHandle { get; public set; }
    private static CurrentProcess();
    [CompilerGeneratedAttribute]
public static string get_MainModuleFileName();
    [CompilerGeneratedAttribute]
private static void set_MainModuleFileName(string value);
    [CompilerGeneratedAttribute]
public static string get_MainModuleShortFileName();
    [CompilerGeneratedAttribute]
private static void set_MainModuleShortFileName(string value);
    [CompilerGeneratedAttribute]
public static string get_MainModuleDirectory();
    [CompilerGeneratedAttribute]
private static void set_MainModuleDirectory(string value);
    [CompilerGeneratedAttribute]
public static string get_Name();
    [CompilerGeneratedAttribute]
private static void set_Name(string value);
    [CompilerGeneratedAttribute]
public static string get_NameOrMainModule();
    [CompilerGeneratedAttribute]
private static void set_NameOrMainModule(string value);
    [CompilerGeneratedAttribute]
public static int get_Id();
    [CompilerGeneratedAttribute]
private static void set_Id(int value);
    [CompilerGeneratedAttribute]
public static ProcessWellKnownHost get_WellKnownHost();
    [CompilerGeneratedAttribute]
private static void set_WellKnownHost(ProcessWellKnownHost value);
    [CompilerGeneratedAttribute]
public static string get_NodeId();
    [CompilerGeneratedAttribute]
public static void set_NodeId(string value);
    [CompilerGeneratedAttribute]
public static string get_InstanceId();
    [CompilerGeneratedAttribute]
public static void set_InstanceId(string value);
    [CompilerGeneratedAttribute]
public static bool get_HasMainWindowsHandle();
    [CompilerGeneratedAttribute]
public static void set_HasMainWindowsHandle(bool value);
    public static void Initialize();
    internal static void Initialize(Assembly entryAssembly);
    private static ProcessWellKnownHost GetCurrentProcessWellKnownHost();
}
public static class Kusto.Cloud.Platform.Utils.CurrentProcessor : object {
    [ThreadStaticAttribute]
private static int t_executionIdCache;
    private static int ExecutionIdCacheShift;
    private static int ExecutionIdCacheCountDownMask;
    private static int ExecutionIdRefreshRate;
    internal static int CurrentExecutionId { get; }
    private static int RefreshExecutionId();
    internal static int get_CurrentExecutionId();
    private static int CurrentProcessorNumber();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetCurrentProcessorNumber();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMonoProcessorNumber();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetUnixProcessorNumber();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMacOSProcessorNumber();
}
public static class Kusto.Cloud.Platform.Utils.CurrentThread : object {
    public static int NativeThreadId { get; }
    public static int ManagedThreadId { get; }
    public static int get_NativeThreadId();
    public static int get_ManagedThreadId();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetWindowsThreadId();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMonoThreadId();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetUnixThreadId(int id);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMacOSThreadId(int id);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Utils.DataReaderDisposeLich : DisposeLichBase`1<IDataReader> {
    private bool m_isClosed;
    public PlatformExceptionDetail PlatformExceptionDetail { get; }
    public object Item { get; }
    public object Item { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public DataReaderDisposeLich(IDataReader inner, Action onDisposed);
    public sealed virtual PlatformExceptionDetail get_PlatformExceptionDetail();
    public sealed virtual object get_Item(int i);
    public sealed virtual object get_Item(string name);
    public sealed virtual int get_Depth();
    public sealed virtual bool get_IsClosed();
    public sealed virtual int get_RecordsAffected();
    public sealed virtual int get_FieldCount();
    public sealed virtual void Close();
    public sealed virtual bool GetBoolean(int i);
    public sealed virtual byte GetByte(int i);
    public sealed virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public sealed virtual char GetChar(int i);
    public sealed virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public sealed virtual IDataReader GetData(int i);
    public sealed virtual string GetDataTypeName(int i);
    public sealed virtual DateTime GetDateTime(int i);
    public sealed virtual decimal GetDecimal(int i);
    public sealed virtual double GetDouble(int i);
    public sealed virtual Type GetFieldType(int i);
    public sealed virtual float GetFloat(int i);
    public sealed virtual Guid GetGuid(int i);
    public sealed virtual short GetInt16(int i);
    public sealed virtual int GetInt32(int i);
    public sealed virtual long GetInt64(int i);
    public sealed virtual string GetName(int i);
    public sealed virtual int GetOrdinal(string name);
    public sealed virtual DataTable GetSchemaTable();
    public sealed virtual string GetString(int i);
    public sealed virtual object GetValue(int i);
    public sealed virtual int GetValues(Object[] values);
    public sealed virtual bool IsDBNull(int i);
    public sealed virtual bool NextResult();
    public sealed virtual bool Read();
}
public class Kusto.Cloud.Platform.Utils.DateTimeComparer : object {
    private bool m_ascending;
    public DateTimeComparer(bool ascending);
    public sealed virtual int Compare(DateTime x, DateTime y);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.DateTimeRange : ValueType {
    public static DateTimeRange All;
    [DataMemberAttribute]
private DateTime m_begin;
    [DataMemberAttribute]
private DateTime m_end;
    public DateTime Begin { get; }
    public DateTime End { get; }
    public TimeSpan Span { get; }
    public bool IsOpenRange { get; }
    public DateTimeRange(DateTime begin, DateTime end);
    private static DateTimeRange();
    public DateTime get_Begin();
    public DateTime get_End();
    public TimeSpan get_Span();
    public bool get_IsOpenRange();
    public bool IsInRangeInclusive(DateTime value);
    public bool IsInRangeExclusive(DateTime value);
    public static DateTimeRange Aggregate(DateTimeRange a, DateTimeRange b);
    public static HashSet`1<DateTimeRange> Merge(IEnumerable`1<DateTimeRange> ranges);
    public static HashSet`1<DateTimeRange> Intersect(IEnumerable`1<DateTimeRange> rangeGroupA, IEnumerable`1<DateTimeRange> rangeGroupB);
    public sealed virtual bool Equals(DateTimeRange other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Utils.DebugBreakTraceListener : TraceListener {
    private object m_lock;
    private ImmutableList`1<string> m_triggers;
    public bool IsThreadSafe { get; }
    public DebugBreakTraceListener(IEnumerable`1<string> triggers);
    public virtual bool get_IsThreadSafe();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public void CheckTriggersAndBreakIfNeeded(string message);
}
public class Kusto.Cloud.Platform.Utils.DebuggableMonitorWaiter : object {
    private object m_monitor;
    private int m_timeout;
    private Stopwatch m_sw;
    public DebuggableMonitorWaiter(object monitor, int timeout);
    public bool TryWait();
}
public class Kusto.Cloud.Platform.Utils.DebugLogger : object {
    private static long s_id;
    private static TranscriptLogger`1<ConsoleColor> s_logger;
    private bool m_enabled;
    private string m_id;
    public bool IsEnabled { get; }
    public DebugLogger(string idPrefix, bool enabled);
    private static DebugLogger();
    public sealed virtual void Dispose();
    public bool get_IsEnabled();
    private static TranscriptLogger`1<ConsoleColor> CreateLogger();
    public void TraceInformation(string message);
    public void TraceInformation(string format, Object[] args);
}
public class Kusto.Cloud.Platform.Utils.DecayCache.CompoundKey`2 : ValueType {
    public TGroup GroupId;
    public TMember MemberId;
    public static CompoundKey`2<TGroup, TMember> op_Implicit(ValueTuple`2<TGroup, TMember> tuple);
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Utils.DecayCache.DecayCache`4 : object {
    private static int c_epoch;
    private static int c_tolerance;
    private static int c_horizon;
    private Catalog<TGroup, TMember, TData, TMeta> m_catalog;
    private BinaryHeap`1<HeapEntry<TGroup, TMember, TData, TMeta>> m_candidates;
    private BinaryHeap`1<HeapEntry<TGroup, TMember, TData, TMeta>> m_residents;
    private long m_budget;
    private TimeSpan m_decayHalfLife;
    private TimeSpan m_timeGranularity;
    private long m_size;
    private DateTime m_epochStart;
    private DateTime m_unitUpdateTimestamp;
    private long m_unit;
    private long m_dataSizeAccountOverhead;
    public Stats Stats { get; }
    public DecayCache`4(long budget, TimeSpan decayHalfLife, TimeSpan timeGranularity, long dataSizeAccountOverhead);
    public Stats get_Stats();
    private CatalogEntry<TGroup, TMember, TData, TMeta> GetCatalogEntry(CompoundKey`2<TGroup, TMember> key, bool verboseTracing);
    public TData TryGet(CompoundKey`2<TGroup, TMember> key);
    private static long AddToScore(long score, long profit);
    public void Evaluate(CompoundKey`2<TGroup, TMember> key, long contribution, Func`2<TC, TMeta> metaFactory, TC context);
    public void Groom();
    public IEnumerable`1<TMember> GetGroupMissing(TGroup groupId);
    public Nullable`1<ValueTuple`2<CompoundKey`2<TGroup, TMember>, Nullable`1<TMeta>>> NominateRetrievalCandidate();
    public void TryPut(CompoundKey`2<TGroup, TMember> key, TData value);
    private long GetDataSize(TData value);
    private long CalculateProfit(long contribution);
    private void InflateUnit();
    private void DevaluateUnit();
    private void HeapNotification(int position, HeapEntry<TGroup, TMember, TData, TMeta> heapEntry);
}
public class Kusto.Cloud.Platform.Utils.DecayCache.Stats : ValueType {
    public long Size;
    public int TotalCount;
    public int CandidateCount;
    public int ResidentCount;
    public long Unit;
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Utils.DecimalHasher : object {
    private int m_numDigits;
    private UInt32 m_numBins;
    private string m_formatter;
    public int NumDigits { get; }
    public DecimalHasher(int numDigits);
    public int get_NumDigits();
    public string Hash(string value);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.DecryptionException : UtilsException {
    public string Thumbprint;
    public string UserMsg;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public DecryptionException(string message, Exception innerException);
    protected DecryptionException(SerializationInfo info, StreamingContext context);
    public DecryptionException(string thumbprint, string userMsg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public DecryptionException(string thumbprint, string userMsg, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public DecryptionException(string thumbprint, string userMsg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public DecryptionException(string thumbprint, string userMsg, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Utils.DeferredDispose : ActionBasedIDisposable {
    public DeferredDispose(Action onDispose, bool swallowExceptions);
    public DeferredDispose(Action onInit, Action onDispose, bool swallowExceptions);
}
public class Kusto.Cloud.Platform.Utils.DelegateBasedEqualityComparer`1 : object {
    private Func`3<T, T, bool> m_equals;
    private Func`2<T, int> m_getHashCode;
    public DelegateBasedEqualityComparer`1(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public class Kusto.Cloud.Platform.Utils.DiagnosticsTrace : TraceSourceBase`1<DiagnosticsTrace> {
    private static string c_tracerId;
    private static string c_errorSeparator;
    private static int s_baseSourceId;
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    private static DiagnosticsTrace();
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
    public static void TraceException(string message, Object[] args, Exception ex, ITraceSource tracer, TraceExceptionOptions options, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void TraceException(string message, Exception ex, ITraceSource tracer, TraceExceptionOptions options, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static string Error(string message, ITraceSource tracer, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static string FormatErrorMessage(string message, Exception ex, string callerMemberName, string callerFilePath, int callerLineNumber, TraceExceptionOptions options);
    public static string FormatErrorMessage(string message, Exception ex, TraceExceptionOptions options);
    public static string FormatErrorMessage(string message, string callerMemberName, string callerFilePath, int callerLineNumber);
    private static void TraceExceptionInternal(string message, Object[] args, Exception ex, ITraceSource tracer, TraceExceptionOptions options, string callerMemberName, string callerFilePath, int callerLineNumber);
    private static void BreakOnException(Exception ex);
    private static string CookExceptionMessageAndToString(Exception ex, TraceExceptionOptions options);
}
public class Kusto.Cloud.Platform.Utils.DisposableDictionary`2 : Dictionary`2<TKey, TValue> {
    private object m_locker;
    private bool m_disposeItemsWhenDone;
    public sealed virtual void Dispose();
    public void Clear();
    public void PreventDispose();
}
public class Kusto.Cloud.Platform.Utils.DisposableList`1 : List`1<T> {
    private object m_locker;
    public sealed virtual void Dispose();
}
public abstract class Kusto.Cloud.Platform.Utils.DisposeLichBase`1 : object {
    private T m_inner;
    private Action m_onDisposed;
    public T Inner { get; }
    protected DisposeLichBase`1(T inner, Action onDisposed);
    public T get_Inner();
    public sealed virtual void Dispose();
    private void ThrowObjectDisposed();
}
[DebuggerDisplayAttribute("Disposer: Type={m_objectType}, name={m_objectName}, Count={m_pending.Count}, Disposed={m_numDisposed}")]
public class Kusto.Cloud.Platform.Utils.Disposer : object {
    private object m_lock;
    private string m_objectType;
    private string m_objectName;
    private bool m_swallowAllExceptions;
    private List`1<Tuple`2<IDisposable, bool>> m_pending;
    private int m_numDisposed;
    public Disposer(string objectType, string objectName, bool swallowAllExceptions);
    public Disposer(string objectType, string objectName, IDisposable disposable, bool swallowExceptions, bool swallowAllExceptions);
    public Disposer(string objectType, string objectName, IEnumerable`1<IDisposable> disposables, bool swallowExceptions, bool swallowAllExceptions);
    public static bool SafeDispose(T& that);
    public static bool SafeDispose(Disposer& that);
    public static ExceptionDispatchInfo DisposeItem(IDisposable disposable, bool swallowExceptions);
    public void AddIfNotNull(IDisposable disposable, bool swallowExceptions);
    public void Add(IDisposable disposable, bool swallowExceptions);
    public void AddRange(IEnumerable`1<IDisposable> disposables, bool swallowExceptions);
    public void Abandon(IDisposable disposable);
    public IEnumerable`1<IDisposable> AbandonAll();
    public void ThrowIfDisposed(string methodName);
    public bool IsDisposed();
    public sealed virtual void Dispose();
    private static ExceptionDispatchInfo StaticDisposeMany(IEnumerable`1<IDisposable> disposables, bool swallowExceptions);
    private static ExceptionDispatchInfo StaticDisposeMany(IEnumerable`1<Tuple`2<IDisposable, bool>> disposables, bool swallowExceptions);
    private void ThrowIfDisposedUnderLock(string methodName);
    private bool IsDisposedUnderLock();
    private void AddToPendingListUnderLock(IDisposable disposable, bool swallowExceptions);
    private void CreatePendingListIfNeededUnderLock();
}
public class Kusto.Cloud.Platform.Utils.DisposerSlim : object {
    public static DisposerSlim`1<T1> Create(Action`1<T1> onDispose, T1 arg0);
    public static DisposerSlim`2<T1, T2> Create(Action`2<T1, T2> onDispose, T1 arg0, T2 arg1);
}
public class Kusto.Cloud.Platform.Utils.DisposerSlim`1 : object {
    private Action`1<T1> m_action;
    private T1 m_arg0;
    public DisposerSlim`1(Action`1<T1> onDispose, T1 arg0);
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Utils.DisposerSlim`2 : object {
    private Action`2<T1, T2> m_action;
    private T1 m_arg0;
    private T2 m_arg1;
    public DisposerSlim`2(Action`2<T1, T2> onDispose, T1 arg0, T2 arg1);
    public sealed virtual void Dispose();
}
internal class Kusto.Cloud.Platform.Utils.DisposeTrace : TraceSourceBase`1<DisposeTrace> {
    public TraceVerbosity DefaultVerbosity { get; }
    public string Id { get; }
    public virtual TraceVerbosity get_DefaultVerbosity();
    public virtual string get_Id();
}
public static class Kusto.Cloud.Platform.Utils.DnsUtils : object {
    public static IEnumerable`1<string> DnsLookup(Uri uri);
    public static void TryDumpDnsLookup(string uri);
}
public class Kusto.Cloud.Platform.Utils.DumpingStream : Stream {
    private Stream m_inner;
    private IDumper m_dumper;
    private bool m_binary;
    private bool m_leaveDumperOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DumpingStream(Stream stream, IDumper dumper, bool binary, bool leaveDumperOpen);
    public virtual void Close();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void Dump(string method, int b);
    private void Dump(string method, string text);
    private void Dump(string method, Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Utils.DumpingStreamReader : StreamReader {
    private IDumper m_dumper;
    private bool m_leaveDumperOpen;
    private bool m_alwaysDumpToEndOfStream;
    public DumpingStreamReader(Stream stream, IDumper dumper, bool leaveDumperOpen, bool alwaysDumpToEndOfStream);
    public DumpingStreamReader(Stream stream, Encoding encoding, IDumper dumper, bool leaveDumperOpen, bool alwaysDumpToEndOfStream);
    private static Stream CreateDumpingStream(Stream inner, IDumper dumper);
    public virtual void Close();
    public virtual int Read();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.DumpingStreamReader/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.DumpingStreamReader/<ReadBlockAsync>d__11")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.DumpingStreamReader/<ReadLineAsync>d__13")]
public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.DumpingStreamReader/<ReadToEndAsync>d__15")]
public virtual Task`1<string> ReadToEndAsync();
    private void Dump(string method, string text);
    private void Dump(string method, Char[] buffer, int index, int nCharacters);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Char[] buffer, int index, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__1(Char[] buffer, int index, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<string> <>n__2();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<string> <>n__3();
}
[FlagsAttribute]
[DataContractAttribute]
public enum Kusto.Cloud.Platform.Utils.DumpOptions : Enum {
    public int value__;
    [EnumMemberAttribute]
public static DumpOptions None;
    [EnumMemberAttribute]
public static DumpOptions FullMemory;
    [EnumMemberAttribute]
public static DumpOptions DetachDebugger;
    [EnumMemberAttribute]
public static DumpOptions KillProcess;
    [EnumMemberAttribute]
public static DumpOptions WatsonEnabled;
}
public class Kusto.Cloud.Platform.Utils.EdiExceptionHandler : MulticastDelegate {
    public EdiExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(string message, ExceptionDispatchInfo edi);
    public virtual IAsyncResult BeginInvoke(string message, ExceptionDispatchInfo edi, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.EncryptionException : UtilsException {
    public string Thumbprint;
    public string UserMsg;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public EncryptionException(string message, Exception innerException);
    protected EncryptionException(SerializationInfo info, StreamingContext context);
    public EncryptionException(string thumbprint, string userMsg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public EncryptionException(string thumbprint, string userMsg, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public EncryptionException(string thumbprint, string userMsg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public EncryptionException(string thumbprint, string userMsg, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Utils.Ensure : object {
    public static void ValueIsUsed(T value);
    public static void ValuesAreUsed(String[] values);
    public static void Fail(string message, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void IsTrue(bool condition, string message, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void IsFalse(bool condition, string message, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ObjectNotDisposed(bool trueIfNotDisposed, string objectName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNullOrEmpty(string value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNullOrEmpty(string value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNullOrWhiteSpace(string value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNullOrWhiteSpace(string value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNullOrEmpty(IEnumerable value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNullOrEmpty(IEnumerable value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNull(T value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNull(string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNull(T value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNotNull(T value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsInRange(T value, T begin, T end, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNotInRange(T value, T begin, T end, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgSatisfiesCondition(bool condition, string argName, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailCondition(string argName, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgSatisfiesCondition(T value, bool condition, string argName, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailCondition(T value, bool condition, string argName, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNegative(long value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNegative(long value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsNotNegative(double value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNegative(double value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsPositive(long value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNotPositive(long value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgIsPositive(double value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailNotPositive(double value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ArgEnumValueIsDefinedSlow(T value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailEnum(T value, string argName, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void ConditionIsMet(bool condition, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void FailConditionIsMet(bool condition, string conditionDescription, string callerMemberName, string callerFilePath, int callerLineNumber);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.EnvironmentCharacteristics : Enum {
    public int value__;
    public static EnvironmentCharacteristics None;
    public static EnvironmentCharacteristics DebugRunMultipleNodesPerProcess;
}
public class Kusto.Cloud.Platform.Utils.EvaluationEnvironment`1 : object {
    private int m_currentDepth;
    private Dictionary`2<string, ValueStack<TValue>> m_map;
    public IDisposable NewScope();
    public int Push();
    public int Pop();
    public void Set(string name, TValue value);
    public bool TryGet(string name, TValue& value);
    public TValue Get(string name);
    public bool IsDefined(string name);
    [CompilerGeneratedAttribute]
private void <NewScope>b__3_0();
}
public class Kusto.Cloud.Platform.Utils.EventRateLimiter : object {
    private TimeSpan m_slotDuration;
    private int m_slotMaxEvents;
    private static DateTime s_timeInitialSlot;
    private DateTime m_timeSlotBegins;
    private DateTime m_timeSlotEnds;
    private DateTime m_timeSlotHorizon;
    private int m_timeSlotEventCount;
    public int TimeslotEventCount { get; }
    public int MaxSlotEvents { get; }
    public EventRateLimiter(TimeSpan slotDuration, int slotMaxEvents);
    private static EventRateLimiter();
    public int get_TimeslotEventCount();
    public int get_MaxSlotEvents();
    public DateTime GetEventProcessingTime(DateTime eventTime);
    public void UpdateTimeslotState(DateTime eventTime);
    private void StartNewSlot(DateTime firstItemInSlot, int initialEventCount);
    private void AddEventToCurrentTimeSlot(DateTime eventTime);
}
public enum Kusto.Cloud.Platform.Utils.ExceptionDisposition : Enum {
    public int value__;
    public static ExceptionDisposition ContinueSearch;
    public static ExceptionDisposition ExecuteHandler;
}
public static class Kusto.Cloud.Platform.Utils.ExceptionFilters : object {
    public static Action`2<Action, Action`1<Exception>> TryFilter;
    public static Func`4<Action, Func`2<Exception, ExceptionDisposition>, Action`1<Exception>, Exception> TryFilterCatch;
    private static ExceptionFilters();
    public static TResult RunTraceRethrow(Func`1<TResult> runAction, string faultTraceMessage, ITraceSource tracer, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void RunTraceRethrow(Action runAction, string faultTraceMessage, ITraceSource tracer, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void RunTraceSwallow(Action runAction, string faultTraceMessage, ITraceSource tracer, string callerMemberName, string callerFilePath, int callerLineNumber);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExceptionFilters/<RunTraceSwallowAsync>d__5")]
public static Task RunTraceSwallowAsync(Func`1<Task> runAction, string faultTraceMessage, ITraceSource tracer, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static TResult RunTraceSwallow(Func`1<TResult> runAction, Func`2<Exception, TResult> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExceptionFilters/<RunTraceSwallowAsync>d__7")]
public static Task RunTraceSwallowAsync(Func`1<Task> runAction, Action`1<Exception> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExceptionFilters/<RunTraceSwallowAsync>d__8`1")]
public static Task`1<TResult> RunTraceSwallowAsync(Func`1<Task`1<TResult>> runAction, Func`2<Exception, TResult> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void RunTraceSwallow(Action runAction, Action`1<Exception> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static TResult RunFaultRethrow(Func`1<TResult> runAction, Action`1<Exception> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExceptionFilters/<RunFaultRethrowAsync>d__11")]
public static Task RunFaultRethrowAsync(Func`1<Task> runAction, Action`1<Exception> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static void RunFaultRethrow(Action runAction, Action`1<Exception> faultAction, string callerMemberName, string callerFilePath, int callerLineNumber);
    public static ExceptionFiltersTestResult TestExceptionFilters();
}
internal static class Kusto.Cloud.Platform.Utils.ExceptionFiltersCodeGenerator : object {
    private static string c_dynamicCodeAssemblyName;
    private static string c_dynamicCodeAssemblyFileName;
    private static string c_dynamicCodeModuleName;
    private static bool s_dynamicCodeWriteToDisk;
    private static string c_debugExceptionFiltersName;
    private static bool s_neuterExceptionFilters;
    private static string c_neuterExceptionFiltersName;
    private static bool s_emitDebugCalls;
    private static MethodInfo s_dumpMethod;
    public static Func`4<Action, Func`2<Exception, ExceptionDisposition>, Action`1<Exception>, Exception> TryFilterCatch;
    public static string TryFilterCatchKind;
    private static ExceptionFiltersCodeGenerator();
    public static void TryFilter(Action tryBlock, Action`1<Exception> filterBlock);
    public static void Dump(string text);
    private static Exception TryFilterCatch_Neutered(Action tryBlock, Func`2<Exception, ExceptionDisposition> filterBlock, Action`1<Exception> catchBlock);
}
public static class Kusto.Cloud.Platform.Utils.ExceptionsTemplateHelper : object {
    private static object s_alertDebuggerOnExceptionsLock;
    private static Tweak`1<string> s_alertDebuggerOnExceptionsTweak;
    private static Regex s_alertDebuggerOnExceptionsLockValue;
    [ThreadStaticAttribute]
private static int ts_magicLevel;
    private static TraceVerbosity s_Contruct_Trace_Verbosity;
    public static string AlertDebuggerOnExceptionsTweakName { get; }
    public static int MagicLevel { get; }
    private static ExceptionsTemplateHelper();
    internal static void Initialize();
    public static string get_AlertDebuggerOnExceptionsTweakName();
    private static void RegisterAlertDebuggerOnExceptionsTweak();
    public static void ConditionalAlertDebuggerOnException(string exception);
    public static void ConditionalAlertDebuggerOnException(Exception ex);
    private static void ConditionalAlertDebuggerOnExceptionImpl(string exception);
    public static void IncrementMagicLevel();
    public static void DecrementMagicLevel();
    public static int get_MagicLevel();
    public static TraceVerbosity SetContructTraceVerbosity(TraceVerbosity verbosity);
    public static bool Construct_Trace(Exception that, ITraceSource traceSource);
    public static bool IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    public static string MessageEx(Exception ex);
    public static string NestedMessageEx(Exception ex);
    public static void WriteExceptionTo(StringBuilder sb, Exception ex, ICloudPlatformException cpEx, string callStackMarker);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedArray : object {
    [ExtensionAttribute]
public static T[] SlowAppend(T[] array, T item);
    [ExtensionAttribute]
public static T[] SlowAppend(T[] array, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static T[] SlowInsert(T[] array, T item, int index);
    [ExtensionAttribute]
public static T[] SlowInsert(T[] array, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static T[] SlowReplaceByIndex(T[] array, int index, T item);
    [ExtensionAttribute]
public static T[] SlowRemoveByValue(T[] array, T value);
    [ExtensionAttribute]
public static T[] SlowRemoveByIndex(T[] array, int index, int count);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] array);
    public static T[] Concat(IEnumerable`1<T[]> arrays);
    public static T[] Concat(T[] lhs, T[] rhs);
    [ExtensionAttribute]
public static bool EqualsTo(T[] array1, T[] array2, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int CopyFrom(T[] destination, T[] source, int sourceOffset);
    [ExtensionAttribute]
public static long CopyFrom(T[] destination, T[] source, long sourceOffset);
    [ExtensionAttribute]
public static long CopyFrom(T[] destination, T[] source, long sourceOffset, long length);
    [ExtensionAttribute]
public static void ForEach(T[] array, Action`2<T, int> action);
    [ExtensionAttribute]
public static T[] SafeShallowClone(T[] array);
    [ExtensionAttribute]
public static T[] Sort(T[] array);
    [ExtensionAttribute]
public static T[] RadixSort(T[] items, Func`2<T, UInt32> getKey);
    [ExtensionAttribute]
public static T[] Fill(T[] array, T val);
    [ExtensionAttribute]
public static T[] Fill(T[] array, Func`2<int, T> generator);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedAssembly : object {
    [ExtensionAttribute]
public static string GetAssemblyManifestFileOrNull(Assembly assembly);
    [ExtensionAttribute]
public static string GetAssemblyManifestDirectoryOrNull(Assembly assembly);
    [ExtensionAttribute]
public static string GetAssemblyNameAndProductVersionString(Assembly assembly);
    [ExtensionAttribute]
public static string GetProductVersionString(Assembly assembly);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedBoolean : object {
    public static bool True { get; }
    public static bool False { get; }
    public static bool get_True();
    public static bool get_False();
    [ExtensionAttribute]
public static string ToStringLowercase(bool value);
    [ExtensionAttribute]
public static bool Implies(bool firstCondition, bool secondCondition);
}
public class Kusto.Cloud.Platform.Utils.ExtendedCallStack : object {
    private static Func`1<string> s_defaultCapture;
    private static Func`1<string> s_capture;
    private ExtendedCallStack(StackTrace stackTrace);
    private static ExtendedCallStack();
    public static Func`1<string> SetStackTraceCaptureFunction(Func`1<string> function);
    public static string CurrentCallStackAsString();
    public static ExtendedCallStack Capture(int skipFrames, bool needStackInfo);
    public static ExtendedCallStack Capture(bool needStackInfo);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedChar : object {
    [ExtensionAttribute]
public static bool IsAsciiPrintable(char c, bool includeNewLines);
    [ExtensionAttribute]
public static bool IsAscii(char c);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedConsole : object {
    private static object s_locker;
    private static ExtendedConsole();
    public static IDisposable TryPushTitle(string title);
    public static IDisposable TryPushForegroundColor(ConsoleColor color);
    public static string ReadLineAsPassword(bool obfuscate, int maxLength);
    public static void Write(ConsoleColor color, string value);
    public static void Write(ConsoleColor color, string format, Object[] args);
    public static void WriteLine(ConsoleColor color, string value);
    public static void WriteLine(ConsoleColor color, string format, Object[] args);
    public static void WriteLineToError(ConsoleColor color, string value);
    public static void WriteLineToError(ConsoleColor color, string format, Object[] args);
    public static void WriteLineToError(string value);
    public static void WriteLineToError(string format, Object[] args);
    private static void Write(TextWriter stream, ConsoleColor color, string format, Object[] args);
    private static void WriteLine(TextWriter stream, ConsoleColor color, string format, Object[] args);
    public static void Clear(bool includeScrollBack);
    private static void ClearImpl(bool includeScrollBack);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedConvert : object {
    public static bool CanAcceptDBNull(Type type);
    public static bool IsNullableType(Type type);
    public static bool IsNullAssignable(Type type);
    public static bool TryConvertToType(object value, Type convertedType, bool expectNull, bool forceConversion, Object& result);
    public static object ConvertToType(object value, Type convertedType, bool allowDBNull);
    public static string ToString(object value);
    public static string ToString(DateTime value);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedCrashScenario : object {
    [ExtensionAttribute]
public static string FastToString(CrashScenario that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CrashScenario that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CrashScenario that, CrashScenario flag);
    public static CrashScenario FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CrashScenario& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CrashScenario that);
    [ExtensionAttribute]
public static string FastGetDescription(CrashScenario that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedCsvFromJsonStream_TransformationMethod : object {
    [ExtensionAttribute]
public static string FastToString(CsvFromJsonStream_TransformationMethod that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CsvFromJsonStream_TransformationMethod that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CsvFromJsonStream_TransformationMethod that, CsvFromJsonStream_TransformationMethod flag);
    public static CsvFromJsonStream_TransformationMethod FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CsvFromJsonStream_TransformationMethod& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CsvFromJsonStream_TransformationMethod that);
    [ExtensionAttribute]
public static string FastGetDescription(CsvFromJsonStream_TransformationMethod that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedCsvWriterImplementation : object {
    [ExtensionAttribute]
public static string FastToString(CsvWriterImplementation that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(CsvWriterImplementation that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(CsvWriterImplementation that, CsvWriterImplementation flag);
    public static CsvWriterImplementation FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, CsvWriterImplementation& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(CsvWriterImplementation that);
    [ExtensionAttribute]
public static string FastGetDescription(CsvWriterImplementation that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedDateTime : object {
    public static DateTime MinValueUtc;
    public static DateTime MaxValueUtc;
    public static Dictionary`2<int, String[]> SupportedNonStandardFormats;
    public static DateTime EpochStart;
    public static long MaxUnixTimeMilliseconds;
    public static long MinUnixTimeMilliseconds;
    public static long MaxUnixTimeMicroseconds;
    public static long MinUnixTimeMicroseconds;
    private static bool s_simulating;
    private static DateTime s_simulatedUtcNow;
    private static TimeZoneInfo s_simulatedTimeZoneInfo;
    private static int s_numCharactersInIso8601;
    [ThreadStaticAttribute]
private static DateTime ts_lastUtcNow;
    [ThreadStaticAttribute]
private static string ts_lastUtcNowAsString;
    [CompilerGeneratedAttribute]
private static Action`1<DateTime> OnSimulatedTimeChange;
    [CompilerGeneratedAttribute]
private static Action OnStopSimulatingTime;
    private static long MicrosecondsPerMillisecond;
    public static long TicksPerMicrosecond;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    internal static int DaysTo1970;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMillis;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    public static bool IsSimulatingTime { get; }
    public static TimeZoneInfo SimulatedTimeZoneInfo { get; public set; }
    public static DateTime Now { get; }
    public static DateTime UtcNow { get; }
    public static string UtcNowAsString { get; }
    public static string UtcTodayAsString { get; }
    public static Tuple`2<DateTime, string> UtcNowAndString { get; }
    public static DateTime Today { get; }
    private static ExtendedDateTime();
    [CompilerGeneratedAttribute]
public static void add_OnSimulatedTimeChange(Action`1<DateTime> value);
    [CompilerGeneratedAttribute]
public static void remove_OnSimulatedTimeChange(Action`1<DateTime> value);
    [CompilerGeneratedAttribute]
public static void add_OnStopSimulatingTime(Action value);
    [CompilerGeneratedAttribute]
public static void remove_OnStopSimulatingTime(Action value);
    public static bool get_IsSimulatingTime();
    public static void SetSimulatedTime(DateTime utcNow, bool allowNonUtcKind);
    public static void StopSimulatingTime();
    public static TimeZoneInfo get_SimulatedTimeZoneInfo();
    public static void set_SimulatedTimeZoneInfo(TimeZoneInfo value);
    public static DateTime get_Now();
    public static DateTime get_UtcNow();
    public static string get_UtcNowAsString();
    public static string get_UtcTodayAsString();
    public static Tuple`2<DateTime, string> get_UtcNowAndString();
    public static DateTime get_Today();
    [ExtensionAttribute]
public static DateTime Round(DateTime dateTime, RoundTo roundTo);
    [ExtensionAttribute]
public static DateTime Round(DateTime dateTime, TimeSpan roundTo);
    [ExtensionAttribute]
public static DateTime Floor(DateTime dateTime, TimeSpan timeSpan);
    [ExtensionAttribute]
public static DateTime Ceiling(DateTime dateTime, TimeSpan timeSpan);
    [ExtensionAttribute]
public static string ToUtcString(DateTime value);
    [ExtensionAttribute]
public static string ToUtcString(DateTime value, CultureInfo culture);
    public static DateTime Max(DateTime t1, DateTime t2);
    public static Nullable`1<DateTime> Max(Nullable`1<DateTime> t1, Nullable`1<DateTime> t2);
    public static DateTime Min(DateTime t1, DateTime t2);
    public static Nullable`1<DateTime> Min(Nullable`1<DateTime> t1, Nullable`1<DateTime> t2);
    public static bool RangesIntersect(DateTime firstStart, DateTime firstEnd, DateTime secondStart, DateTime secondEnd);
    [ExtensionAttribute]
public static DateTime SafeAdd(DateTime datetime, TimeSpan value);
    [ExtensionAttribute]
public static DateTime SafeSubtract(DateTime datetime, TimeSpan value);
    public static bool RangesIntersect(DateTimeRange range1, DateTimeRange range2);
    public static DateTime ParseExactUtc(string value, string format);
    public static bool TryParseExactUtc(string value, string format, DateTime& result);
    public static bool TryParseByExactFormat(string value, string format, DateTime& result);
    public static DateTime ParseInexactUtc(string value, bool allowEpochTime, bool throwIfInvalid);
    public static bool TryParseInexactUtc(string value, bool allowEpochTime, DateTime& result);
    public static TimeSpan ToUnixTimeSpan(DateTime date);
    public static long ToUnixTimeMicroseconds(DateTime date);
    public static long ToUnixTimeMilliseconds(DateTime date);
    public static DateTime FromTimeSpan(TimeSpan timeSpan);
    [ExtensionAttribute]
public static string ToZonalTimeDisplayString(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime ToUtc(DateTime value);
    public static List`1<DateTimeRange> PartitionRange(DateTime beginRange, DateTime endRange, TimeSpan step);
    [ExtensionAttribute]
public static string FastToString(DateTime value);
    [ExtensionAttribute]
public static void FastAppendToStringBuilder(DateTime value, StringBuilder sb);
    private static void FastAppendFormattedInt7(StringBuilder sb, long value);
    private static void FastAppendFormattedInt4(StringBuilder sb, int value);
    private static void FastAppendFormattedInt2(StringBuilder sb, int value);
    [ExtensionAttribute]
public static void FastGetParts(DateTime value, Int32& year, Int32& month, Int32& day, Int32& hour, Int32& minute, Int32& second, Int64& fraction);
    public static DateTime FromUnixTimeSeconds(long seconds);
    public static DateTime FromUnixTimeSeconds(double seconds);
    public static DateTime FromUnixTimeMilliseconds(long milliseconds);
    public static DateTime FromUnixTimeMilliseconds(double milliseconds);
    public static DateTime FromUnixTimeMicroseconds(long microseconds);
    public static Nullable`1<DateTime> FromUnixTimeMicroseconds(Nullable`1<long> microseconds);
    public static DateTime FromUnixTimeMicroseconds(double microseconds);
    public static DateTime FromUnixTimeNanoseconds(long nanoseconds);
    public static DateTime FromUnixTimeNanoseconds(double nanoseconds);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedDebugger : object {
    private static DefaultTraceListener s_defaultTraceListener;
    private static Lazy`1<string> s_lazyDacPath;
    private static ExtendedDebugger();
    public static void WriteLineIfAttached(string message);
    public static void WriteLine(string message);
    public static void ProcessBreakOnStartCommandLineArgIfExist(String[] args);
    public static void ProcessBreakOnStartSwitch(string value);
    public static bool IsDebuggerAttached();
    public static void AlertDebugger(bool force);
    public static bool AlertDebuggerIfAttached(string why);
    public static string GetDacPath();
    private static string GetDacPathImpl();
    private static bool LaunchDebuggerIfPossible();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedDictionary : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrUpdate(Dictionary`2<TKey, TValue> target, TKey key, TValue value, Func`3<TKey, TValue, TValue> updateFunc);
    [ExtensionAttribute]
public static Dictionary`2<TKey, ICollection`1<TValue>> AddOrUpdateCollection(Dictionary`2<TKey, ICollection`1<TValue>> target, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, List`1<TValue>> AddOrUpdateList(Dictionary`2<TKey, List`1<TValue>> target, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrSet(Dictionary`2<TKey, TValue> target, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrSetIfNotNull(Dictionary`2<TKey, TValue> target, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrSetRange(Dictionary`2<TKey, TValue> target, IDictionary`2<TKey, AValue> additionalDict);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrSetRange(Dictionary`2<TKey, TValue> target, IEnumerable`1<KeyValuePair`2<TKey, AValue>> additionalData);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddOrThrow(IDictionary`2<TKey, TValue> target, TKey key, TValue value, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AddOrEnsureValuesMatch(Dictionary`2<TKey, TValue> target, TKey key, TValue value, string collection);
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> target, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> target, TKey key, TValue retIfUnset);
    [ExtensionAttribute]
public static TValue GetOrDefault(IDictionary`2<TKey, TValue> target, TKey key, TValue retIfUnset);
    [ExtensionAttribute]
public static TValue GetOrDefault(IDictionary`2<TKey, object> target, TKey key, TValue retIfUnset);
    [ExtensionAttribute]
public static TValue GetOrThrow(IDictionary`2<TKey, TValue> target, TKey key, string collection);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> target, TKey key, Func`2<TKey, TValue> valueFactory);
    [ExtensionAttribute]
public static string SafeToString(KeyValuePair`2<TKey, TValue> pair);
    [ExtensionAttribute]
public static string Dump(IDictionary`2<TKey, TValue> target, string delimiter);
    [ExtensionAttribute]
public static string Dump(IDictionary`2<TKey, TValue> target);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ShallowClone(Dictionary`2<TKey, TValue> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ShallowClone(IDictionary`2<TKey, TValue> source);
    [ExtensionAttribute]
public static bool RemoveRange(Dictionary`2<TKey, TValue> source, IEnumerable`1<TKey> itemsToRemove);
    [ExtensionAttribute]
public static bool RemoveKeyValuePair(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool ExtendedEquals(IDictionary`2<TKey, TValue> lhs, IDictionary`2<TKey, TValue> rhs);
    [ExtensionAttribute]
public static bool ExtendedEquals(IDictionary`2<TKey, TValue> lhs, IDictionary`2<TKey, TValue> rhs, Func`3<TValue, TValue, bool> comparer);
    [ExtensionAttribute]
public static bool SafeFastContainsKey(IDictionary`2<TKey, TValue> that, TKey key);
    [ExtensionAttribute]
public static bool SafeTryGetValue(IDictionary`2<TKey, TValue> that, TKey key, TValue& value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> kvp, TKey& key, TValue& value);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> ToReadOnlyDictionary(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> ToReadOnlyDictionary(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryIfNotAlready(IReadOnlyDictionary`2<TKey, TValue> dictionary);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedDictionary`2 : object {
    public static IDictionary`2<TKey, TValue> Empty;
    private static ExtendedDictionary`2();
}
public static class Kusto.Cloud.Platform.Utils.ExtendedDirectory : object {
    private static int MAX_PATH;
    [ThreadStaticAttribute]
private static FastGetTempFileNameState s_fastGetTempFileNameState;
    public static string FastGetTempFileName(string prefix);
    public static IEnumerable`1<string> GetFilesByPattern(string pathPattern, ITraceSource tracer, SearchOption searchOption);
    public static bool CreateDirectoryIfNotExists(string path);
    public static bool TryCleanDirectory(string path);
    public static bool TryCleanDirectory(string path, IEnumerable`1& remainingEntries, bool deleteRoot, bool unsetReadonly);
    public static bool TrySafeDelete(string path, Func`2<string, bool> isExpectedFile);
    public static bool IsDirectoryWriteable(string path);
    public static ulong CalculateDirectorySize(DirectoryInfo root);
    public static ulong CalculateDirectorySize(string path);
    private static void RemoveReadonlyAttributeIfExists(string path);
    private static string PatchPathIfRequired(string path);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedEncoding : object {
    public static Encoding UTF8NoBOM;
    public static Encoding UTF8NoBOMNoExceptions;
    public static Encoding UTF8NoExceptions;
    public static Encoding UTF8DefaultEncoding;
    private static ExtendedEncoding();
    private static Encoding GetEncodingWithFallback(Encoding encoding);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedEnum : object {
    public static IEnumerable`1<T> GetValues();
    public static T Parse(string value, bool ignoreCase);
    public static bool TryParse(string value, T& enumMember, bool ignoreCase);
    public static IEnumerable`1<T> GetFlags(T enumValue);
    public static bool SingleFlagSet(T enumValue);
    public static bool SingleOrNoFlagSet(T enumValue);
    private static bool SingleFlagSetImp(T enumValue, bool succeedIfNoFlagSet);
    [ExtensionAttribute]
public static string GetDescription(Enum enumValue);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedEnumerable : object {
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToBigLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToBigLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source, long maxCount);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeFastDistinct(IEnumerable`1<T> collection);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<WithIndex>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<T, int>> WithIndex(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static long SafeFastCountUpTo(IEnumerable`1<T> collection, long maxCount);
    [ExtensionAttribute]
public static bool SafeSequenceEquals(IEnumerable`1<T> collection, IEnumerable`1<T> other, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static bool SortedSequenceEquals(IEnumerable`1<T> sortedCollection1, IEnumerable`1<T> sortedCollection2, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> collection, IEnumerable`1<T> other, Func`3<T, T, bool> predicate);
    private static bool IsCollectionUnordered(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ImmutableArray`1<T> SafeToImmutableArray(IEnumerable`1<T> that);
    [ExtensionAttribute]
public static bool SafeSetEquals(IEnumerable`1<T> that, IEnumerable`1<T> other);
    private static Nullable`1<bool> BasicCompare(IEnumerable`1<T> collection, IEnumerable`1<T> other);
    private static Nullable`1<long> GetSequenceLength(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static string ToDisplayString(IEnumerable`1<T> collection, string delimiter, Nullable`1<int> maxTake, string nullString, int estimatedStringSize, string elementPrefix, string elementPostfix, Func`2<T, string> customElementToString);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeShallowClone(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<TCollection> collection, Func`2<TCollection, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeConcat(IEnumerable`1<T> first, IEnumerable`1<T> second);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeUnion(IEnumerable`1<T> first, IEnumerable`1<T> second);
    [ExtensionAttribute]
public static TCollection SafeFastNullIfEmpty(TCollection collection);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeEmptyIEnumerableIfNull(IEnumerable`1<T> collectionEnumerable);
    [ExtensionAttribute]
public static bool SafeFastAny(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool SafeFastAny(List`1<T> list);
    [ExtensionAttribute]
public static bool SafeFastAny(ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool SafeFastAny(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static bool SafeFastAny(ConcurrentDictionary`2<K, V> collection);
    [ExtensionAttribute]
public static bool SafeFastAny(IEnumerable collection);
    [ExtensionAttribute]
public static bool SafeFastAny(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool SafeFastNone(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool SafeFastNone(ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool SafeFastNone(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static bool SafeFastNone(ConcurrentDictionary`2<K, V> collection);
    [ExtensionAttribute]
public static bool SafeFastNone(IEnumerable collection);
    [ExtensionAttribute]
public static bool SafeFastNone(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool SafeFastContains(IEnumerable`1<T> collection, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> DistinctBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<T> DistinctBy(IEnumerable`1<T> source, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> Intersect(IEnumerable`1<IEnumerable`1<T>> collections);
    [ExtensionAttribute]
public static Tuple`2<List`1<TR>, List`1<TR>> SplitBy(IEnumerable`1<T> collection, Func`2<T, Nullable`1<bool>> isFirst, Func`2<T, TR> transform);
    [ExtensionAttribute]
public static IEnumerable`1<T> IntersectWith(IEnumerable`1<T> collection, IEnumerable`1<T> other);
    private static bool IsTupleType(Type type, bool checkBaseTypes);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Yield>d__43`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Yield(T item);
    [ExtensionAttribute]
public static bool SafeCollectionsContainSameItems(IEnumerable`1<T> collection, IEnumerable`1<T> other, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static bool SafeSortedCollectionsContainSameItems(IEnumerable`1<T> collection, IEnumerable`1<T> other, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static T ArgMax(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static T ArgMaxOrDefault(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IDictionary`2<B, T> ArgMax(IEnumerable`1<T> source, IComparer`1<T> comparer, Func`2<T, B> aggregatedBy);
    [ExtensionAttribute]
public static T ArgMax(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T ArgMaxOrDefault(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T ArgMax(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    [ExtensionAttribute]
public static T ArgMaxOrDefault(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    [ExtensionAttribute]
public static Tuple`2<T, U> ArgMaxWithField(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    [ExtensionAttribute]
public static Tuple`2<T, U> ArgMaxWithFieldOrDefault(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    [ExtensionAttribute]
public static T ArgMin(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static T ArgMinOrDefault(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IDictionary`2<B, T> ArgMin(IEnumerable`1<T> source, IComparer`1<T> comparer, Func`2<T, B> aggregatedBy);
    [ExtensionAttribute]
public static T ArgMin(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T ArgMinDefault(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T ArgMin(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    [ExtensionAttribute]
public static T ArgMinOrDefault(IEnumerable`1<T> source, Func`2<T, U> fieldSelector);
    public static void WalkTree(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [ExtensionAttribute]
public static int SafeMin(IEnumerable`1<TSource> source, int default, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static long SafeMax(IEnumerable`1<TSource> source, Func`2<TSource, long> selector, long retIfNullOrEmpty);
    [ExtensionAttribute]
public static long SafeFastCountIfPossible(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static T SafeSingleOrDefault(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static T SafeSingleOrDefault(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static long SafeFastCount(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static long SafeFastCount(ICollection`1<T> collection);
    [ExtensionAttribute]
public static int SafeCount(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeFastTake(IEnumerable`1<T> collection, int count);
    [ExtensionAttribute]
public static void SafeFastForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
public static T[] ToArrayIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ICollection`1<T> ToCollectionIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static List`1<T> ToListIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> collection, int initialLength);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSetEx(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSetEx(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSetIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> ToImmutableHashSetIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayIfNotAlready(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ImmutableArray`1<V> SelectAsImmutableArray(IEnumerable`1<T> collection, Func`2<T, V> selector);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSetIfNotAlready(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IReadOnlyDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryFromKeyValueCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryFromKeyValueCollection(ICollection`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> FastToDictionary(IEnumerable`1<TSource> source, int count, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionaryIgnoreDuplicates(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionaryIgnoreDuplicates(IEnumerable`1<TSource> source, int count, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer, string collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionaryIgnoreDuplicatesWithActionPerDuplicate(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Action`1<TSource> actionForDuplicate, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TCollectionOfTElement> ToMultiDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Partition>d__100`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Partition(IEnumerable`1<T> sequence, int partitionSize);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Batch>d__101`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Batch(IEnumerable`1<T> source, int batchSize);
    [ExtensionAttribute]
public static void ParallelForEachWithExceptionAggregation(IEnumerable`1<T> source, int maxParallelism, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeEmptyIfNull(IEnumerable`1<T> source);
    public static IEnumerable`1<T> AsEnumerableOrEmptyIfNull(T item);
    public static IEnumerable`1<T> AsEnumerable(T item);
    public static IEnumerable`1<T> AsEnumerable(T first, T second);
    [ExtensionAttribute]
public static void AddToMulti(IDictionary`2<TKey, CollectionOfTValue> multiDictionary, TKey key, TValue value);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<SelectManyWithRoundRobin>d__108`3")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> SelectManyWithRoundRobin(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static DataTable ToDataTable(IEnumerable`1<T> collection, string tableName);
    private static void AppendColumn(DataTable dataTable, string columnName, Type columnType);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> ZipWhen(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, Tuple`2<bool, TResult>> resultSelector);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<ZipIterator>d__112`3")]
private static IEnumerable`1<TResult> ZipIterator(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, Tuple`2<bool, TResult>> resultSelector);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Flatten>d__113`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> getChildren);
    [ExtensionAttribute]
public static IEnumerable`1<T> SafeMergeSortedWithSorted(IEnumerable`1<T> collection1, IEnumerable`1<T> collection2);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<MergeSortedWithSorted>d__115`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> MergeSortedWithSorted(IEnumerable`1<T> collection1, IEnumerable`1<T> collection2);
    public static IEnumerable`1<TSource> SafeFastMergeSorted(ICollection`1<IEnumerable`1<TSource>> sortedCollections, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static T GetRandomItem(IEnumerable`1<T> enumerable);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Continuously>d__118`1")]
public static IEnumerable`1<T> Continuously(Func`1<T> supplier);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Continuously>d__119`1")]
public static IEnumerable`1<T> Continuously(T startValue, Func`2<T, T> step);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Cycle>d__120`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Cycle(IEnumerable`1<T> collection);
    public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static ulong Sum(IEnumerable`1<T> source, Func`2<T, ulong> summer);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<Split>d__123`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Split(IEnumerable`1<T> source, int chunkSize);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<GetChunk>d__124`1")]
private static IEnumerable`1<T> GetChunk(IEnumerator`1<T> enumerator, int chunkSize);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedEnumerable/<ConcatIfEmpty>d__126`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ConcatIfEmpty(IEnumerable`1<T> that, IEnumerable`1<T> enumerable, Action onConcat);
    [ExtensionAttribute]
public static ICollection`1<string> AddIfNotNullOrWhiteSpace(ICollection`1<string> that, string value);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedEnvironment : object {
    public static string WindowsNewLine;
    private static char PathListDelimiter;
    private static Char[] PathListDelimiterArray;
    private static StringComparison PathComparisonMode;
    private static string s_machineName;
    private static string s_userName;
    private static string s_userDomainName;
    private static bool s_isUserInteractive;
    private static bool s_isWindows;
    private static bool s_isWindowsServer;
    private static bool s_isMono;
    private static int s_restrictedProcessorCount;
    private static IEnumerable`1<IPAddress> s_machinesAddresses;
    public static string MachineName { get; }
    public static string UserName { get; }
    public static string UserDomainName { get; }
    public static bool IsUserInteractive { get; }
    public static bool IsWindows { get; }
    public static bool IsWindowsServer { get; }
    public static bool IsLinux { get; }
    public static bool IsMacOS { get; }
    public static bool IsMono { get; }
    public static int RestrictedProcessorCount { get; }
    public static string NetAndClrVersion { get; }
    public static string NetAndClrVersionShort { get; }
    public static string OSVersion { get; }
    public static string DomainNameAndUserName { get; }
    public static string MachineFqdn { get; }
    private static ExtendedEnvironment();
    private static string GetMachineName();
    public static string get_MachineName();
    private static string GetUserName();
    public static string get_UserName();
    private static string GetUserDomainName();
    public static string get_UserDomainName();
    private static bool GetIsUserInteractive();
    public static bool get_IsUserInteractive();
    private static bool GetIsWindows();
    public static bool get_IsWindows();
    public static bool get_IsWindowsServer();
    public static bool get_IsLinux();
    public static bool get_IsMacOS();
    private static bool GetIsMono();
    public static bool get_IsMono();
    private static int GetRestrictedProcessorCountFromOS();
    public static int get_RestrictedProcessorCount();
    public static void InitRestrictedProcessorCount(int processorCount);
    public static string get_NetAndClrVersion();
    public static string get_NetAndClrVersionShort();
    public static string get_OSVersion();
    public static string get_DomainNameAndUserName();
    public static string get_MachineFqdn();
    public static IEnumerable`1<IPAddress> GetMachineAddresses(bool retryUntilAny);
    private static IEnumerable`1<IPAddress> GetMachineAddressesInternal();
    public static void FailFast(string message);
    public static void FailFast(string message, Exception ex);
    public static void FailSlow(string message);
    public static void FailSlow(string message, Exception ex);
    public static string GetEnvironmentVariable(string variableName, IEnumerable`1<EnvironmentVariableTarget> environmentVariableTargets);
    public static void SetTempPath(string folder);
    public static string SearchPathForFile(string filename, bool includeCurrentDirectory);
    public static bool AddFolderToPath(string folder);
    public static void ValidateServerGC();
    public static void ValidateNetCoreTimer();
    public static void ValidateServerTracing();
    private static string GetOSVersionString();
    private static string GetNetAndClrVersionString(bool concise);
    private static string GetClrVersionString(bool concise);
    private static string GetClrDllVersionString(bool concise);
    private static string GetNetVersionString(bool concise);
    internal static ValueTuple`3<int, int, int> GetNetRuntimeVersion();
    private static ValueTuple`3<int, int, int> GetNetRuntimeVersion450OrLater(int releaseKey);
    private static string GetNetVersionString45OrLater(int releaseKey);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedEnvironmentTweaks : object {
    public static string RestrictedProcessorCountTweakName;
    internal static Tweak`1<int> RestrictedProcessorCountTweak;
    private static ExtendedEnvironmentTweaks();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedException : object {
    private static object s_isTransientProvidersLock;
    private static List`1<Func`2<Exception, TriState>> s_isTransientProviders;
    private static ExtendedException();
    public static void RegisterIsTransientProvider(Func`2<Exception, TriState> provider);
    public static void UnRegisterIsTransientProvider(Func`2<Exception, TriState> provider);
    [ExtensionAttribute]
public static ExceptionDispatchInfo Capture(Exception ex);
    [ExtensionAttribute]
public static string MessageEx(Exception ex, bool forceNesting);
    [ExtensionAttribute]
public static string ToStringEx(Exception ex, string alternativeStackTrace);
    [ExtensionAttribute]
public static TriState IsPermanent(Exception ex);
    [ExtensionAttribute]
public static TriState IsTransient(Exception ex);
    [ExtensionAttribute]
public static Exception UnwrapFirstException(Exception ex);
    [ExtensionAttribute]
public static Exception UnwrapSingleException(Exception ex);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedException/<FlattenInnerExceptions>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<Exception> FlattenInnerExceptions(AggregateException aggregateException);
    private static string MessageEx_CombineOuterAndInners(Exception ex, IEnumerable`1<Exception> inners, bool forceNesting);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedExtendedProcessOptions : object {
    [ExtensionAttribute]
public static string FastToString(ExtendedProcessOptions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(ExtendedProcessOptions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(ExtendedProcessOptions that, ExtendedProcessOptions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(ExtendedProcessOptions that, ExtendedProcessOptions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(ExtendedProcessOptions that, ExtendedProcessOptions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(ExtendedProcessOptions that, ExtendedProcessOptions flags);
    public static ExtendedProcessOptions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, ExtendedProcessOptions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(ExtendedProcessOptions that);
    [ExtensionAttribute]
public static string FastGetDescription(ExtendedProcessOptions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedExtendedProcessOptions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<ExtendedProcessOptions> FastGetFlags(ExtendedProcessOptions that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedFile : object {
    private static short INVALID_HANDLE_VALUE;
    private static UInt32 GENERIC_READ;
    private static UInt32 GENERIC_WRITE;
    public static UInt32 FILE_ATTRIBUTE_ARCHIVE;
    public static UInt32 FILE_ATTRIBUTE_ENCRYPTED;
    public static UInt32 FILE_ATTRIBUTE_HIDDEN;
    public static UInt32 FILE_ATTRIBUTE_OFFLINE;
    public static UInt32 FILE_ATTRIBUTE_READONLY;
    public static UInt32 FILE_ATTRIBUTE_SYSTEM;
    public static UInt32 FILE_ATTRIBUTE_TEMPORARY;
    public static UInt32 FILE_ATTRIBUTE_NORMAL;
    public static UInt32 FILE_FLAG_BACKUP_SEMANTICS;
    public static UInt32 FILE_FLAG_DELETE_ON_CLOSE;
    public static UInt32 FILE_FLAG_NO_BUFFERING;
    public static UInt32 FILE_FLAG_OPEN_NO_RECALL;
    public static UInt32 FILE_FLAG_OPEN_REPARSE_POINT;
    public static UInt32 FILE_FLAG_OVERLAPPED;
    public static UInt32 FILE_FLAG_POSIX_SEMANTICS;
    public static UInt32 FILE_FLAG_RANDOM_ACCESS;
    public static UInt32 FILE_FLAG_SESSION_AWARE;
    public static UInt32 FILE_FLAG_SEQUENTIAL_SCAN;
    public static UInt32 FILE_FLAG_WRITE_THROUGH;
    private static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    public static long GetFileOrUnderlyingSymbolicLinkSize(string path);
    public static FileStream CreateFile(string fileName, FileAccess desiredAccess, FileShare shareMode, FileMode creationDisposition, UInt32 flagsAndAttributes);
    public static void DeleteFile(string path);
    public static void TryDeleteFile(string path);
    public static FileCopyResults Copy(string sourceFileName, string destFileName, FileCopyOptions options);
}
public class Kusto.Cloud.Platform.Utils.ExtendedFileStream : FileStream {
    private static int DefaultBufferSize;
    private static HashSet`1<ExtendedFileStream> s_streams;
    private string m_path;
    private FileMode m_mode;
    private FileAccess m_access;
    private FileShare m_share;
    private StackTrace m_creationCallStack;
    public ExtendedFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    private static ExtendedFileStream();
    public static FileStream CreateFileStream(string path, FileMode mode);
    public static FileStream CreateFileStream(string path, FileMode mode, FileAccess access);
    public static FileStream CreateFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public static FileStream CreateFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public virtual void Close();
    private static void RegisterFileStream(ExtendedFileStream that);
    private static void UnregisterFileStream(ExtendedFileStream that);
    [ConditionalAttribute("DEBUG_FILE_STREAM_VERBOSE")]
private static void ReportAction(string path, string action, Exception ex);
    public static string DebugDumpOpenStreams(string fileNameFragment);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Utils.ExtendedFileVersionInfo : object {
    private string m_filename;
    private int m_handle;
    private IntPtr m_buffer;
    private int m_langid;
    private int m_codepage;
    private string Item { get; }
    private ExtendedFileVersionInfo(string fileName);
    public static ExtendedFileVersionInfo TryCreate(string fileName);
    protected virtual override void Finalize();
    private string get_Item(string name);
    public static string GetVersionString(string fileName, string name);
    public static bool TryGetVersionString(string fileName, string name, String& result);
    public bool TryGetVersionString(string name, String& result);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private string GetSpvString(string name);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.ExtendedFileVersionInfoException : Win32Exception {
    public string FileName;
    public string Function;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public ExtendedFileVersionInfoException(string message, Exception innerException);
    protected ExtendedFileVersionInfoException(SerializationInfo info, StreamingContext context);
    public ExtendedFileVersionInfoException(string fileName, string function, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public ExtendedFileVersionInfoException(string fileName, string function, int errorCode, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public ExtendedFileVersionInfoException(string fileName, string function, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedHashSet : object {
    [ExtensionAttribute]
public static HashSet`1<T> SafeAddRange(HashSet`1<T> that, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static HashSet`1<T> SafeAdd(HashSet`1<T> collection, T item);
    [ExtensionAttribute]
public static HashSet`1<string> AddIfNotNullOrWhiteSpace(HashSet`1<string> that, string value);
    [ExtensionAttribute]
public static HashSet`1<string> AddRangeIfNotNullOrWhiteSpace(HashSet`1<string> that, IEnumerable`1<string> collection);
    [ExtensionAttribute]
public static bool SafeSetEquals(HashSet`1<T> that, HashSet`1<T> other);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedHttpStatusCode : object {
    private static HashSet`1<HttpStatusCodeEx> c_transientCodes;
    private static ExtendedHttpStatusCode();
    [ExtensionAttribute]
public static bool IsTransient(HttpStatusCode statusCode);
    [ExtensionAttribute]
public static bool IsTransient(HttpStatusCodeEx statusCode);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedHttpStatusCodeEx : object {
    [ExtensionAttribute]
public static string FastToString(HttpStatusCodeEx that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(HttpStatusCodeEx that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(HttpStatusCodeEx that, HttpStatusCodeEx flag);
    public static HttpStatusCodeEx FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, HttpStatusCodeEx& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(HttpStatusCodeEx that);
    [ExtensionAttribute]
public static string FastGetDescription(HttpStatusCodeEx that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedHttpUtility : object {
    public static string EncodePlainTextAsHtml(string s);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedInterlocked : object {
    public static bool ReadModifyWrite(Int64& valueLocation, Func`2<long, bool> bailOnValue, Func`2<long, long> determineNewValue);
    public static long ReadModifyWrite(Int64& valueLocation, long proposedValue, Func`3<long, long, long> determineNewValue);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedIPAddress : object {
    [CompilerGeneratedAttribute]
private static IsSpecialAddressDelegate <IsSpecialAddress>k__BackingField;
    public static IsSpecialAddressDelegate IsSpecialAddress { get; public set; }
    [CompilerGeneratedAttribute]
public static IsSpecialAddressDelegate get_IsSpecialAddress();
    [CompilerGeneratedAttribute]
public static void set_IsSpecialAddress(IsSpecialAddressDelegate value);
    [ExtensionAttribute]
public static IPAddressCategory GetCategory(IPAddress address, IsSpecialAddressDelegate isSpecialAddress);
    public static bool AreSameSubnet(Byte[] addressBytes1, Byte[] addressBytes2, int numBits);
    [ExtensionAttribute]
public static bool IsIPv4LinkLocal(IPAddress address);
    public static bool IsIPv4LinkLocal(Byte[] bytes);
    [ExtensionAttribute]
public static bool IsIPv4PrivateAddress(IPAddress address);
    public static bool IsIPv4PrivateAddress(Byte[] bytes);
    [ExtensionAttribute]
public static bool IsIPv6PrivateAddress(IPAddress address);
    public static bool IsIPv6PrivateAddress(Byte[] bytes);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedIPAddressCategory : object {
    [ExtensionAttribute]
public static string FastToString(IPAddressCategory that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(IPAddressCategory that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(IPAddressCategory that, IPAddressCategory flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(IPAddressCategory that, IPAddressCategory flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(IPAddressCategory that, IPAddressCategory flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(IPAddressCategory that, IPAddressCategory flags);
    public static IPAddressCategory FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, IPAddressCategory& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(IPAddressCategory that);
    [ExtensionAttribute]
public static string FastGetDescription(IPAddressCategory that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedIPAddressCategory/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<IPAddressCategory> FastGetFlags(IPAddressCategory that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedIpCalloutFailType : object {
    [ExtensionAttribute]
public static string FastToString(IpCalloutFailType that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(IpCalloutFailType that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(IpCalloutFailType that, IpCalloutFailType flag);
    public static IpCalloutFailType FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, IpCalloutFailType& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(IpCalloutFailType that);
    [ExtensionAttribute]
public static string FastGetDescription(IpCalloutFailType that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedKustoCalloutAuthenticationMethod : object {
    [ExtensionAttribute]
public static KustoCalloutAuthorizationClass ToCalloutAuthorizationClass(KustoHttpAuthenticationMethod httpAuthMethod);
    [ExtensionAttribute]
public static KustoCalloutAuthorizationClass ToCalloutAuthorizationClass(KustoSqlAuthenticationMethod sqlAuthMethod);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedList : object {
    [ExtensionAttribute]
public static List`1<T> AppendRange(List`1<T> collection, T[] items);
    [ExtensionAttribute]
public static List`1<T> AppendRange(List`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static List`1<T> SafeAdd(List`1<T> collection, T item);
    [ExtensionAttribute]
public static List`1<T> SafeAddRange(List`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static T GetRandomItem(List`1<T> collection);
    [ExtensionAttribute]
public static void Swap(List`1<T> collection, int index1, int index2);
    [ExtensionAttribute]
public static void CopyTo(List`1<T> source, List`1<T> target);
    [ExtensionAttribute]
public static IList`1<T> Clone(IList`1<T> collection);
    public static IList`1<T> ToListFromItem(T item);
    [ExtensionAttribute]
public static void AddTimes(IList`1<T> collection, T item, int times);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedMath : object {
    public static DateTime Max(DateTime lhs, DateTime rhs);
    public static double CalculateStandardDeviation(ICollection`1<double> doubleCollection);
    public static double CalculateStandardDeviation(ICollection`1<long> longCollection);
    public static double CalculateStandardDeviation(ICollection`1<int> intCollection);
    public static double CalculatePercentile(Double[] sortedData, double p);
    public static double CalculatePercentile(IEnumerable`1<int> sortedData, double p);
    public static int Clamp(int value, int min, int max);
    public static double Clamp(double value, double min, double max);
    [ExtensionAttribute]
public static int ZeroIfNegative(int number);
    [ExtensionAttribute]
public static long ZeroIfNegative(long number);
}
public class Kusto.Cloud.Platform.Utils.ExtendedMemoryStream : object {
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedObjectModel : object {
    [ExtensionAttribute]
public static void AddRange(Collection`1<TItem> collection, IEnumerable`1<TItem> items);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedOneLakeAccessType : object {
    [ExtensionAttribute]
public static string FastToString(OneLakeAccessType that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(OneLakeAccessType that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(OneLakeAccessType that, OneLakeAccessType flag);
    public static OneLakeAccessType FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, OneLakeAccessType& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(OneLakeAccessType that);
    [ExtensionAttribute]
public static string FastGetDescription(OneLakeAccessType that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedParallel : object {
    private static int c_defaultMaxParallelism;
    public static ParallelLoopResult ScatterGather(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TReturn>> func, List`1& flatResults, int parallelism);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body, CancellationToken cancellationToken);
    public static ParallelLoopResult ForEachEx(IEnumerable`1<TSource> source, int parallelism, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, int maxParallelism, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, int maxParallelism, Action`1<TSource> body, CancellationToken cancellationToken);
    public static Task ForEachAsync(IEnumerable`1<TSource> source, Func`2<TSource, Task> asyncBody);
    public static Task ForEachAsync(IEnumerable`1<TSource> source, int maxParallelism, Func`2<TSource, Task> asyncBody);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedParallel/<ForEachAsync>d__9`1")]
public static Task ForEachAsync(IEnumerable`1<TSource> source, int maxParallelism, Func`3<TSource, CancellationToken, Task> asyncBody, CancellationToken cancellationToken);
    public static ParallelLoopResult ForAll(IEnumerable`1<TSource> source, Action`1<TSource> body, Func`2<TSource, string> failureFormatter);
    public static ParallelLoopResult ForAll(IEnumerable`1<TSource> source, int maxParallelism, Action`1<TSource> body, Func`2<TSource, string> failureFormatter);
    public static ParallelLoopResult ForAll(IEnumerable`1<TSource> source, int maxParallelism, Action`1<TSource> body, Func`2<TSource, string> failureFormatter, ITraceSource tracer);
    public static ParallelLoopResult ForAll(IEnumerable`1<TSource> source, int maxParallelism, Action`1<TSource> body, Func`2<TSource, string> failureFormatter, CancellationToken cancellationToken, ITraceSource tracer);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, int maxParallelism, Action`1<int> body);
    public static ParallelLoopResult ForEx(int fromInclusive, int toExclusive, int maxParallelism, Action`1<int> body);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedParquetCompressionType : object {
    [ExtensionAttribute]
public static string FastToString(ParquetCompressionType that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(ParquetCompressionType that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(ParquetCompressionType that, ParquetCompressionType flag);
    public static ParquetCompressionType FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, ParquetCompressionType& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(ParquetCompressionType that);
    [ExtensionAttribute]
public static string FastGetDescription(ParquetCompressionType that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedPath : object {
    private static Regex s_forbiddenFilenameChars;
    private static TriState s_tempPathExists;
    private static ExtendedPath();
    public static string SafeCombine(string lhs, string rhs, char separator);
    public static string Combine(string lhs, string rhs, char separator);
    public static bool IsPathWithWildcards(string path);
    public static bool IsSubPath(string basePath, string path, bool caseInsensitive);
    public static string RemoveBasePath(string basePath, string path, bool caseInsensitive);
    private static string WithEnding(string str, string ending);
    private static string Right(string value, int length);
    public static bool IsPathOrUriLocal(string path);
    public static string RandomizeFileName(string path);
    public static string GetTempFileName(string name);
    public static string CreateAndGetTempFolder();
    public static string CreateAndGetTempFolder(string prefix);
    public static string ShortenToMaxPath(string path, int deleteIndex, int MaxPath);
    private static void EnsureTempPathExists();
    private static DriveType GetDriveType(string lpRootPathName);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedPlatformExceptionDetailLevel : object {
    [ExtensionAttribute]
public static string FastToString(PlatformExceptionDetailLevel that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(PlatformExceptionDetailLevel that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(PlatformExceptionDetailLevel that, PlatformExceptionDetailLevel flag);
    public static PlatformExceptionDetailLevel FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, PlatformExceptionDetailLevel& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(PlatformExceptionDetailLevel that);
    [ExtensionAttribute]
public static string FastGetDescription(PlatformExceptionDetailLevel that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedProcess : object {
    private static string Redacted;
    [CompilerGeneratedAttribute]
private static TraceOptions <Tracing>k__BackingField;
    public static TraceOptions Tracing { get; public set; }
    private static ExtendedProcess();
    [CompilerGeneratedAttribute]
public static TraceOptions get_Tracing();
    [CompilerGeneratedAttribute]
public static void set_Tracing(TraceOptions value);
    public static bool ToTrace(TraceOptions tracing);
    public static int Run(string fileName, string arguments, int timeout, ExtendedProcessOptions options, TraceOptions traceOptions);
    public static int Run(string fileName, string arguments, String& output, String& error);
    public static int Run(string fileName, string arguments, int timeout, ExtendedProcessOptions options, String& output, String& error, string workingDirectory, TraceOptions traceOptions);
    public static Process Run(ProcessStartInfo psi, int timeout, ExtendedProcessOptions options, string input, Action`1<string> outputHandler, Action`1<string> errorHandler, Process& process, TraceOptions traceOptions);
    public static int Run(ProcessStartInfo psi, int timeout, ExtendedProcessOptions options, string input, Action`1<string> outputHandler, Action`1<string> errorHandler, TraceOptions traceOptions);
    public static int Run(ProcessStartInfo psi, int timeout, ExtendedProcessOptions options, String& output, String& error, TraceOptions traceOptions);
    public static ProcessStartInfo CreateDefaultProcessStartInfo(string fileName, string arguments);
    public static ProcessStartInfo CreateProcessStartInfoWithoutOutputRedirection(string fileName, string arguments);
    public static Process Start(ProcessStartInfo psi, DataReceivedEventHandler outputDataReceived, DataReceivedEventHandler errorDataReceived);
    public static Process Start(ProcessStartInfo psi, DataReceivedEventHandler outputDataReceived, DataReceivedEventHandler errorDataReceived, EventHandler processExited);
    private static int RunImpl(ProcessStartInfo psi, int timeout, ExtendedProcessOptions options, string input, Action`1<string> outputHandler, Action`1<string> errorHandler, TraceOptions traceOptions, bool waitForCompletionOrTimeout, Process& process);
    private static void KillProcess(Process p, string exceptionTextPrefix);
    private static void LockAndAppendLine(StringBuilder outputBuilder, string text);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.ExtendedProcessOptions : Enum {
    public int value__;
    public static ExtendedProcessOptions None;
    public static ExtendedProcessOptions KillProcessOnTimeout;
    public static ExtendedProcessOptions DumpOnProcessTimeout;
    public static ExtendedProcessOptions WrapInJobObject;
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedRandom : object {
    [ThreadStaticAttribute]
private static Random s_randomGenerator;
    private static RandomNumberGenerator s_cryptoRandomGenerator;
    private static Random RandomGenerator { get; private set; }
    private static RandomNumberGenerator CryptoRandomGenerator { get; private set; }
    private static void set_RandomGenerator(Random value);
    private static Random get_RandomGenerator();
    private static void set_CryptoRandomGenerator(RandomNumberGenerator value);
    private static RandomNumberGenerator get_CryptoRandomGenerator();
    public static IDisposable SetRandomBehavior(Random random);
    public static void SeedCurrentThread(int value);
    public static bool GetBoolean();
    public static char GetAsciiUppercaseChar();
    public static char GetAsciiLowercaseChar();
    public static short GetInt16();
    public static short GetInt16(short maxValue);
    public static short GetInt16(short minValue, short maxValue);
    public static int GetInt32();
    public static int GetInt32(int maxValue);
    public static int GetInt32(int minValue, int maxValue);
    public static long GetInt64();
    public static long GetInt64(long minValue, long maxValue);
    public static TimeSpan GetTimeSpan(long minTicks, long maxTicks);
    public static TimeSpan GetTimeSpan();
    public static double GetF64();
    public static byte GetUInt8();
    public static byte GetUInt8(byte maxValue);
    public static byte GetUInt8(byte minValue, byte maxValue);
    public static ushort GetUInt16();
    public static UInt32 GetUInt32();
    public static ulong GetUInt64();
    public static string GetString();
    public static string GetString(int maxLength);
    public static string GetStringWithExactLength(int length);
    public static string GetRandomLowerCharOrDigitString(int length);
    public static string GetString(int minLength, int maxLength);
    public static Byte[] GetByteArray(int maxLength);
    public static Byte[] GetFixedSizeByteArray(int fixedLength);
    public static DateTime GetDateTime(DateTime from, DateTime to);
    public static int GetCryptographicRandomNumber(int minValue, int maxValue);
    public static string GeneratePassword(int minLength);
    public static string GenerateHashSalt(int length);
    public static T GetEnumValue();
    public static T GetOneOfSeveral(IEnumerable`1<T> values);
    public static IEnumerable`1<T> GetRandomSubsetWithMinSize(IEnumerable`1<T> values, int minDistinctSubsetSize);
    public static IEnumerable`1<T> GetRandomSubsetWithExactSize(IEnumerable`1<T> values, int size);
    public static IEnumerable`1<T> GetRandomValues(IEnumerable`1<T> values, int count);
    [ExtensionAttribute]
public static IEnumerable`1<T> Shuffle(IEnumerable`1<T> source);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedReflection : object {
    public static string GetFullyQualifiedMemberName(MemberInfo member);
    public static CustomAttributeData GetCustomAttribute(IList`1<CustomAttributeData> customAttributes, string attribute);
    public static object GetParameterValueFromCustomAttribute(CustomAttributeData attributeData, string paramName);
    public static object GetParameterValueFromCustomAttribute(MemberInfo method, CustomAttributeData attribute, string paramName);
    public static object GetParameterValueFromCustomAttribute(MemberInfo method, string attribute, string paramName);
    public static CustomAttributeData GetBaseCustomAttribute(IList`1<CustomAttributeData> customAttributes, string attribute);
    public static bool IsCustomAttributePresent(MemberInfo method, string attribute);
    public static bool IsCustomAttributePresent(ParameterInfo parameter, string attribute);
    public static bool IsCustomAttributePresent(IEnumerable`1<CustomAttributeData> customAttributes, string attribute);
    public static IEnumerable`1<T> GetMethodInfoAttributes(MethodInfo methodInfo);
    public static IEnumerable`1<T> GetAssemblyAttributes(Assembly assembly);
    public static bool TryGetNestedPropertyOrField(object root, string path, Object& ret);
    private static bool CheckAttribute(CustomAttributeData customAttribute, string attribute);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedRegex : object {
    public static bool TryUnescape(string str, String& result);
    public static Regex TryTransformWildCardPatternToRegex(string wildcardPattern);
    public static bool IsWildCardPattern(string wildcardPattern);
    [ExtensionAttribute]
public static bool RegexEquals(Regex regex, object other);
    [ExtensionAttribute]
public static bool RegexEquals(Regex regex, Regex other);
    [ExtensionAttribute]
public static bool RegexEquivalent(Regex regex, Regex other);
    [ExtensionAttribute]
public static string ReplaceAndCountReplacements(Regex regex, string input, string replacement, Int32& replacesCount);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedRuntime : object {
    public static MemoryStatus GetMemoryStatus();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedSocketError : object {
    private static HashSet`1<SocketError> s_transientCodes;
    private static ExtendedSocketError();
    [ExtensionAttribute]
public static bool IsTransient(SocketError statusCode);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedStopwatch : object {
    public static Stopwatch StartNew();
    [ExtensionAttribute]
public static TimeSpan Lap(Stopwatch sw);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedStream : object {
    private static RecyclableMemoryStreamManager s_manager;
    [ThreadStaticAttribute]
private static Byte[] t_buffer;
    private static ExtendedStream();
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedStream/<GetMemPoolsStatus>d__2")]
public static IEnumerable`1<MemPoolStatus> GetMemPoolsStatus();
    public static MemoryStream CreateMemoryStream();
    public static MemoryStream CreateContiguousMemoryStream(int requiredSize);
    public static MemoryStream CreateMemoryStream(Byte[] buffer);
    public static MemoryStream CreateMemoryStream(Byte[] buffer, int index, int count);
    public static MemoryStream CreateMemoryStream(string tag, int capacity);
    [ExtensionAttribute]
public static string GetBufferAsUtf8String(MemoryStream stream);
    [ExtensionAttribute]
public static string GetBufferAsBase64String(MemoryStream stream);
    public static void SetInternalMemoryStreamManagerMaximumFreeLargePoolBytes(long limitInBytes);
    public static void SetInternalMemoryStreamManagerMaximumFreeSmallPoolBytes(long limitInBytes);
    [ExtensionAttribute]
public static Byte[] SafeToArray(MemoryStream stream);
    [ExtensionAttribute]
public static int SafeReadAtLeast(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static long SafeConsumeAndDispose(Stream stream);
    [ExtensionAttribute]
public static string SafePeekStreamContentsAsString(Stream stream, bool forceRead);
    [ExtensionAttribute]
public static long FastCopyTo(Stream source, Stream destination, int bufferSize);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedStream/<FastCopyToAsync>d__17")]
[ExtensionAttribute]
public static Task`1<long> FastCopyToAsync(Stream source, Stream destination, int bufferSize, CancellationToken cancellationToken);
    public static int FastReadByte(Stream stream, Byte[] buffer);
    private static Byte[] RentBuffer(int bufferSize);
    private static void ReturnBuffer(Byte[] buffer);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedString : object {
    public static string EllipsisAsThreePeriods;
    private static String[] c_newlineAsStringArray;
    private static string c_wrap;
    private static String[] c_nullGuids;
    public static Func`2<object, string> SafeToString;
    public static String[] EmptyArray;
    private static HashSet`1<char> s_alternativeSpaceChars;
    private static HashSet`1<char> s_alternativeNewlineChars;
    private static Dictionary`2<char, string> s_alternativeQutoes;
    private static ExtendedString();
    [ExtensionAttribute]
public static int SafeGetHashCode(string value);
    [ExtensionAttribute]
public static int SafeGetHashCodeOrdinalIgnoreCase(string value);
    [ExtensionAttribute]
public static int GuidSafeFastGetHashCode(string value);
    public static string SafeToTraceString(object value);
    [ExtensionAttribute]
public static string SafeToTraceString(string value);
    public static string SafeFormat(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWithCurrentCulture(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWithInvariantCulture(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider formatProvider, Object[] args);
    [ExtensionAttribute]
public static string ToCamelCase(string str);
    [ExtensionAttribute]
public static string Pluralize(string singular, int nHowMany);
    [ExtensionAttribute]
public static string Pluralize(string singular, long nHowMany);
    [ExtensionAttribute]
public static string Pluralize(string singular, int nHowMany, StringPluralizeOptions options);
    [ExtensionAttribute]
public static string Pluralize(string singular, long nHowMany, StringPluralizeOptions options);
    [ExtensionAttribute]
public static bool SafeIsNullGuid(string value);
    [ExtensionAttribute]
public static bool SafeIsValidGuid(string value);
    public static string GetDiff(string lhs, string rhs);
    private static string GetDiffFromPosition(string lhs, string rhs, int position);
    [ExtensionAttribute]
public static string SafeSubstring(string value, int startIndex, int count);
    [ExtensionAttribute]
public static string CanonicalizeBase64String(string value);
    [ExtensionAttribute]
public static bool SafeIsValidNonEmptyBase64(string value, bool allowWhitespace);
    public static bool SafeIsDoubleSlashCommentOrEmptyBlock(string cmd);
    [ExtensionAttribute]
public static string SafeFastRemoveCharacter(string text, char c);
    [ExtensionAttribute]
public static string SafeFastTrimEmptyLines(string text);
    [ExtensionAttribute]
public static string SafeFastTrim(string text);
    [ExtensionAttribute]
public static string TrimStart(string text, string prefix, StringComparison comparison);
    [ExtensionAttribute]
public static string TrimEnd(string text, string suffix, StringComparison comparison);
    [ExtensionAttribute]
public static string TrimStart(string text, char c, bool justOne);
    [ExtensionAttribute]
public static string TrimBalancedSquareBrackets(string text);
    [ExtensionAttribute]
public static string TrimBalancedRoundBrackets(string text);
    [ExtensionAttribute]
public static string TrimBalancedCurlyBrackets(string text);
    [ExtensionAttribute]
public static string TrimBalanced(string text, string openning, string closing, StringComparison comparison);
    [ExtensionAttribute]
public static string TrimBalancedSingleAndDoubleQuotes(string text);
    public static int DetermineMaxLineWidth(string text);
    [ExtensionAttribute]
public static long SafeCountCharacterUpTo(string value, char c, long maxCount);
    [ExtensionAttribute]
public static long SafeCountAnyCharacterUpTo(string value, Char[] chars, long maxCount);
    [ExtensionAttribute]
public static int FindFirstNonWhitespaceCharacter(string value, int index);
    public static int FirstFirstUnequalCharacter(string lhs, string rhs);
    [ExtensionAttribute]
public static int CountNonOverlappingSubstrings(string text, string substring, StringComparison comparison);
    [ExtensionAttribute]
public static bool SafeStartsWith(string what, char c);
    [ExtensionAttribute]
public static bool SafeStartsWith(string what, string value, StringComparison comparison);
    [ExtensionAttribute]
public static bool EqualsOrdinalIgnoreCase(string me, string other);
    [ExtensionAttribute]
public static bool IsEmpty(string me);
    [ExtensionAttribute]
public static bool IsNotEmpty(string me);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string me);
    [ExtensionAttribute]
public static bool IsNotNullOrEmpty(string me);
    [ExtensionAttribute]
public static string EmptyIfNull(string me);
    [ExtensionAttribute]
public static string SafeGetTail(string what, int length);
    [ExtensionAttribute]
public static int SafeIndexOf(string what, char value);
    [ExtensionAttribute]
public static int SafeIndexOf(string what, string value, int startIndex, StringComparison comparisonType);
    [ExtensionAttribute]
public static int SafeIndexOf(string what, string value, int startIndex, int count, StringComparison comparisonType);
    [ExtensionAttribute]
public static string SplitFirst(string what, string delimiter, StringComparison comparison);
    [ExtensionAttribute]
public static string SplitFirst(string what, char delimiter);
    [ExtensionAttribute]
public static string SplitFirst(string what, Char[] delimiters);
    [ExtensionAttribute]
public static string Rotate(string s);
    [ExtensionAttribute]
public static string AdjustNewLineDelimiter(string text);
    [ExtensionAttribute]
public static string ReplaceInvisibleWhitespaces(string value);
    [ExtensionAttribute]
public static bool HasNonAsciiQuotes(string value);
    [ExtensionAttribute]
public static string ReplaceNonAsciiQuotes(string value);
    [ExtensionAttribute]
public static string Replace(string value, IDictionary`2<char, string> replacements);
    [ExtensionAttribute]
private static string Replace(string value, ShouldReplace shouldReplace);
    [ExtensionAttribute]
public static bool IsAscii(string str);
    [ExtensionAttribute]
public static string ValueOrDefaultIfNullOrWhitespace(string value, string default);
    public static string WriteJsonPropertyBag(IEnumerable`1<string> propNames, IEnumerable`1<string> propValues);
    [ExtensionAttribute]
public static string SafeFormatBytesAsHexDump(Byte[] value, int bytesPerLine);
    [ExtensionAttribute]
public static string SafeFormatBytesAsHexDump(Byte[] value, int offset, int count, int bytesPerLine);
    [ExtensionAttribute]
public static string SafeDumpBytes(string value);
    [ExtensionAttribute]
public static string SafeDumpBytes(Byte[] value, int offset, int count);
    [ExtensionAttribute]
public static string SafeDumpBytes(Byte[] value);
    [ExtensionAttribute]
public static string TakeWhile(string what, Func`2<char, bool> predicate);
    [ExtensionAttribute]
public static string SplitLast(string what, string delimiter);
    [ExtensionAttribute]
public static string SplitLast(string what, char delimiter);
    [ExtensionAttribute]
public static string SplitTakeLast(string what, char delimiter);
    [ExtensionAttribute]
public static string SplitTakeLast(string what, string delimiter);
    [ExtensionAttribute]
public static string SplitTakeLast(string what, Char[] delimiters);
    [ExtensionAttribute]
public static int NthIndexOf(string what, char c, int n);
    [ExtensionAttribute]
public static int NthIndexOfAny(string what, Char[] anyOf, int n);
    [ExtensionAttribute]
public static string SplitRest(string what, string delimiter, StringComparison comparison);
    [ExtensionAttribute]
public static string SplitRest(string what, char delimiter);
    [ExtensionAttribute]
public static string SplitFirst(string what, string delimiter, String& remaining);
    [ExtensionAttribute]
public static string SplitFirst(string what, char delimiter, String& remaining);
    [ExtensionAttribute]
public static string SplitNth(string what, char delimiter, UInt32 nth, String& remaining);
    [ExtensionAttribute]
public static string SplitLast(string what, string delimiter, String& remaining);
    [ExtensionAttribute]
public static string SplitLast(string what, char delimiter, String& remaining);
    [ExtensionAttribute]
public static string SplitFirstNumber(string what, String& remaining);
    [ExtensionAttribute]
public static String[] SplitLines(string what);
    [ExtensionAttribute]
public static String[] SplitLines(string what, StringSplitOptions options, StringComparison comparison);
    [ExtensionAttribute]
public static String[] SplitToChunks(string what, int maxChunkLength);
    [ExtensionAttribute]
public static string DoubleQuote(string target);
    public static string Join(string separator, string first, string second, StringJoinOptions options, StringComparison comparison);
    [ExtensionAttribute]
public static string StringJoin(IEnumerable`1<T> sequence, string separator, Func`2<T, string> converter);
    [ExtensionAttribute]
public static string StringJoin(IEnumerable`1<T> sequence, string separator);
    [ExtensionAttribute]
public static string StringJoin(String[] sequence, string separator);
    [ExtensionAttribute]
public static string SafeFastStringJoin(IEnumerable`1<T> sequence, string separator, int maxCount, string suffixIfMaxCountExceeded, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static string ChopRectangular(string text, int width, int height);
    [ExtensionAttribute]
public static string Chop(string text, int length, ChopOptions options);
    [ExtensionAttribute]
public static string Chop(string text, int length, ChopOptions options, String& remaining);
    [ExtensionAttribute]
private static string ChopInternal(string text, int length, ChopOptions options, bool shouldSetRemaining, String& remaining);
    [ExtensionAttribute]
public static bool Contains(string that, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Contains(string that, char value);
    [ExtensionAttribute]
public static string Head(string that, int numberOfCharacters);
    [ExtensionAttribute]
public static string ReplaceFirstOccurrence(string source, string toReplace, string replaceWith, bool ignoreCase);
    [ExtensionAttribute]
public static string ReplaceLastOccurrence(string source, string toReplace, string replaceWith, bool ignoreCase);
    [ExtensionAttribute]
public static void ParseVersion(string version, Int32& majorVersion, Int32& minorVersion);
    [ExtensionAttribute]
public static string ReplaceNonPrintable(string text);
    [ExtensionAttribute]
public static string ReplaceNonAsciiOrNonPrintable(string text);
    public static string SafeFastConcat(string s0, string s1, string s2, string s3, string s4, string s5, string s6, string s7);
}
public class Kusto.Cloud.Platform.Utils.ExtendedStringBuilder : object {
    private static int c_tabSize;
    private int m_tabSize;
    private int m_indentation;
    private Char[] m_indentors;
    private bool m_firstColumn;
    [CompilerGeneratedAttribute]
private StringBuilder <StringBuilder>k__BackingField;
    public StringBuilder StringBuilder { get; private set; }
    public ExtendedStringBuilder(ExtendedStringBuilder parent);
    public ExtendedStringBuilder(int tabSize, int initialIndentation, Char[] indentors);
    [CompilerGeneratedAttribute]
public StringBuilder get_StringBuilder();
    [CompilerGeneratedAttribute]
private void set_StringBuilder(StringBuilder value);
    public static StringBuilder CreateStringBuilder();
    public static StringBuilder CreateStringBuilder(int capacity);
    public static void AppendJoin(StringBuilder sb, string separator, IEnumerable`1<string> values);
    public static void AppendJoin(StringBuilder sb, string separator, IEnumerable`1<T> values);
    public static void AppendJoin(StringBuilder sb, string separator, IEnumerable`1<T> values, Action`2<StringBuilder, T> appendAction);
    public static void AppendJoin(StringBuilder sb, string separator, IEnumerable`1<T> values, Action`3<StringBuilder, T, int> appendAction);
    public void AppendLines(string str);
    private void AppendIndent();
    private void UpdateFirstColumn(string writtenLast);
    public ExtendedStringBuilder Append(string str);
    public ExtendedStringBuilder Append(char value);
    public ExtendedStringBuilder Append(DateTime value);
    public ExtendedStringBuilder Append(Guid value);
    public ExtendedStringBuilder Append(double value);
    public void AppendNoIndent(string str);
    public void AppendLine(string str);
    public void AppendLine(char c);
    public void AppendLine();
    public void AppendLineIfHasValue(string prefix, string value, string suffix);
    public ExtendedStringBuilder AppendLineIfHasValue(string value);
    public void AppendLineIfHasValue(string prefix, T value, string suffix);
    public void AppendLineIfHasValue(string prefix, object value, string suffix);
    public virtual string ToString();
    public void Indent();
    public void Unindent();
    public void SetIndentation(int indentation);
    public static StringBuilder InitializeStringBuildIfNeeded(string value, StringBuilder sb, int i);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedStringJoinOptions : object {
    [ExtensionAttribute]
public static string FastToString(StringJoinOptions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StringJoinOptions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StringJoinOptions that, StringJoinOptions flag);
    [ExtensionAttribute]
public static bool FastHasAllFlags(StringJoinOptions that, StringJoinOptions flags);
    [ExtensionAttribute]
public static bool FastHasAnyFlags(StringJoinOptions that, StringJoinOptions flags);
    [ExtensionAttribute]
public static int FastCountIntersectionsWith(StringJoinOptions that, StringJoinOptions flags);
    public static StringJoinOptions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StringJoinOptions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StringJoinOptions that);
    [ExtensionAttribute]
public static string FastGetDescription(StringJoinOptions that);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedStringJoinOptions/<FastGetFlags>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<StringJoinOptions> FastGetFlags(StringJoinOptions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedStringPluralizeOptions : object {
    [ExtensionAttribute]
public static string FastToString(StringPluralizeOptions that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(StringPluralizeOptions that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(StringPluralizeOptions that, StringPluralizeOptions flag);
    public static StringPluralizeOptions FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, StringPluralizeOptions& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(StringPluralizeOptions that);
    [ExtensionAttribute]
public static string FastGetDescription(StringPluralizeOptions that);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTask : object {
    private static Task`1<bool> s_completedWithFalse;
    private static Task`1<bool> s_completedWithTrue;
    private static Task s_completed;
    public static Task Completed { get; }
    public static Task`1<bool> CompletedWithFalse { get; }
    public static Task`1<bool> CompletedWithTrue { get; }
    private static ExtendedTask();
    public static Task get_Completed();
    public static Task`1<bool> get_CompletedWithFalse();
    public static Task`1<bool> get_CompletedWithTrue();
    [ExtensionAttribute]
public static Task IgnoreExceptions(Task task);
    [ExtensionAttribute]
public static Task SwallowTaskCanceledException(Task task);
    [ExtensionAttribute]
public static void WaitEx(Task task);
    [ExtensionAttribute]
public static bool WaitEx(Task task, TimeSpan timeout);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WaitExAsync>d__13")]
[ExtensionAttribute]
public static Task`1<bool> WaitExAsync(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void ResultEx(Task task);
    [ExtensionAttribute]
public static TResult ResultEx(Task`1<TResult> task);
    [ExtensionAttribute]
public static void ResultEx(ConfiguredTaskAwaitable cta);
    [ExtensionAttribute]
public static TResult ResultEx(ConfiguredTaskAwaitable`1<TResult> cta);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__18`2")]
public static Task`1<ValueTuple`2<T1, T2>> WhenAll(Task`1<T1> task1, Task`1<T2> task2);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__19`3")]
public static Task`1<ValueTuple`3<T1, T2, T3>> WhenAll(Task`1<T1> task1, Task`1<T2> task2, Task`1<T3> task3);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__20`4")]
public static Task`1<ValueTuple`4<T1, T2, T3, T4>> WhenAll(Task`1<T1> task1, Task`1<T2> task2, Task`1<T3> task3, Task`1<T4> task4);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__21`1")]
public static Task`1<T1> WhenAll(Task`1<T1> task1, Task task2);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__22`1")]
public static Task`1<T1> WhenAll(Task`1<T1> task1, Task task2, Task task3);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__23`2")]
public static Task`1<ValueTuple`2<T1, T2>> WhenAll(Task`1<T1> task1, Task`1<T2> task2, Task task3);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__24`2")]
public static Task`1<ValueTuple`2<T1, T2>> WhenAll(Task`1<T1> task1, Task`1<T2> task2, Task task3, Task task4);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__25`3")]
public static Task`1<ValueTuple`3<T1, T2, T3>> WhenAll(Task`1<T1> task1, Task`1<T2> task2, Task`1<T3> task3, Task task4);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<WhenAll>d__26`1")]
public static Task`1<T1> WhenAll(Task`1<T1> task1, Task task2, Task task3, Task task4);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<RunUnderCancellationTokenAndTimeout>d__27`1")]
public static Task`1<T> RunUnderCancellationTokenAndTimeout(Task`1<T> task, CancellationToken token, TimeSpan timeout, string callingMethod);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.ExtendedTask/<ExecuteWithTimeout>d__28`1")]
public static Task`1<T> ExecuteWithTimeout(Func`1<Task`1<T>> operation, TimeSpan timeout, CancellationToken cancellationToken, string callingMethod);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTestEnum : object {
    [ExtensionAttribute]
public static string FastToString(TestEnum that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(TestEnum that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(TestEnum that, TestEnum flag);
    public static TestEnum FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, TestEnum& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(TestEnum that);
    [ExtensionAttribute]
public static string FastGetDescription(TestEnum that);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedTextWriterTraceListener : object {
    public static TextWriterTraceListener Create(string fileName);
    public static TextWriterTraceListener Create(string fileName, string name);
    public static TextWriter CreateTextWriter(string fileName);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedThreadPool : object {
    private static DateTime s_threadPoolLatencyMonitorQueueTime;
    private static void ThreadPoolLatencyMonitor();
    private static void ThreadPoolLatencyMonitorCallback(object state);
    private static void AlertIfThreadPoolRunningLow();
    public static void AdjustThreadPoolForServerScenarios(bool setMinMaxThreads, bool enableRunningLowMonitor, bool enableLatencyMonitor);
    public static ThreadPoolStatus GetCurrentThreadPoolStatus();
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTimeSpan : object {
    public static Regex s_timeSpanRegex;
    private static TimeSpan s_invalidTimerPeriod;
    public static int Infinite;
    public static TimeSpan InfiniteTimeSpan;
    public static TimeSpan InvalidTimerPeriod { get; }
    private static ExtendedTimeSpan();
    [ExtensionAttribute]
public static bool IsValidAsTimerPeriod(TimeSpan value);
    [ExtensionAttribute]
public static bool IsValidAsTimeout(TimeSpan value);
    [ExtensionAttribute]
public static int AsIntTimeoutIfInRange(TimeSpan timeout, string argName);
    public static TimeSpan get_InvalidTimerPeriod();
    public static TimeSpan Min(TimeSpan a, TimeSpan b);
    public static TimeSpan Max(TimeSpan a, TimeSpan b);
    public static TimeSpan Abs(TimeSpan a);
    [ExtensionAttribute]
public static bool IsInfinite(TimeSpan value);
    [ExtensionAttribute]
public static bool IsZero(TimeSpan value);
    [ExtensionAttribute]
public static TimeSpan SafeAdd(TimeSpan a, TimeSpan b);
    public static int SecondsToMilliseconds(int seconds);
    public static int MinutesToMilliseconds(int minutes);
    [ExtensionAttribute]
public static string Hummanize(TimeSpan span);
    public static TimeSpan Parse(string s);
    public static bool TryParse(string s, TimeSpan& result);
    [ExtensionAttribute]
public static TimeSpan Multiply(TimeSpan value, int factor);
    [ExtensionAttribute]
public static TimeSpan Multiply(TimeSpan value, long factor);
    [ExtensionAttribute]
public static TimeSpan Multiply(TimeSpan value, double factor);
    [ExtensionAttribute]
public static string ToTimeSpanLiteralInHours(TimeSpan timeSpan);
    public static TimeSpan Convert(object value);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTimeZoneInfo : object {
    [ExtensionAttribute]
public static TimeSpan DaylightSavingTimeOffset(TimeZoneInfo tz, DateTime datetime);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedToString : object {
    [ExtensionAttribute]
public static string ToString(ulong x, ToStringFormat format, int width);
    [ExtensionAttribute]
public static string ToString(long x, ToStringFormat format, int width);
    [ExtensionAttribute]
public static string ToString(double x, ToStringFormat format, int width);
    private static string GetFormatStringForNumber(ToStringFormat format, int width);
}
public static class Kusto.Cloud.Platform.Utils.ExtendedTraceListener : object {
    public static TriState IsConfidential(TraceListener traceListener);
    public static TraceListener[] RemoveByConfidentiality(bool confidential, TraceListenerCollection collection);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTraceSource : object {
    private static string c_defaultTraceID;
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message);
    [ExtensionAttribute]
public static void TraceWithDefaultTraceId(ITraceSource traceSource, TraceVerbosity verbosity, string message);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15);
    [ExtensionAttribute]
public static void Trace(ITraceSource traceSource, TraceVerbosity verbosity, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16);
    public static void TraceToBothNonConfidentialAndConfidential(ITraceSource tracer, ITraceSource confidentialTracer, string message, Object[] argsWithoutConfidentialData, Object[] argsContainingConfidentialData, TraceVerbosity traceVerbosity, Nullable`1<TraceVerbosity> confidentialTraceVerbosity, bool shouldTraceToConfidential);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedTraceVerbosity : object {
    [ExtensionAttribute]
public static EventLevel ToEventLevel(TraceVerbosity traceVerbosity);
    [ExtensionAttribute]
public static TraceVerbosity ToTraceVerbosity(EventLevel eventLevel);
    [ExtensionAttribute]
public static SourceLevels ToSourceLevels(TraceVerbosity traceVerbosity);
    [ExtensionAttribute]
public static TraceVerbosity ToTraceVerbosity(SourceLevels sourceLevels);
    [ExtensionAttribute]
public static TraceLevel ToTraceLevel(TraceVerbosity traceVerbosity);
    [ExtensionAttribute]
public static TraceVerbosity ToTraceVerbosity(TraceLevel traceLevel);
    [ExtensionAttribute]
public static TraceEventType ToTraceEventType(TraceVerbosity traceVerbosity);
    [ExtensionAttribute]
public static string ToTraceEventTypeString(TraceVerbosity traceVerbosity);
    [ExtensionAttribute]
public static TraceVerbosity ToTraceVerbosity(TraceEventType traceEventType);
    public static TraceVerbosity ToTraceVerbosity(int numericVerbosity);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedType : object {
    [ExtensionAttribute]
public static string GetDisplayName(Type type);
    private static void AppendTypeDisplayName(StringBuilder sb, Type type);
    public static Type TryResolveTypeByName(string name);
    [ExtensionAttribute]
public static FieldInfo[] GetFieldsOrdered(Type type);
    [ExtensionAttribute]
public static FieldInfo[] GetFieldsOrdered(Type type, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static PropertyInfo[] GetPropertiesOrdered(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] GetPropertiesOrdered(Type type, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsNumericOrBoolean(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsDoubleConvertableNumeric(Type type);
    [ExtensionAttribute]
public static bool IsLongConvertableNumeric(Type type);
    [ExtensionAttribute]
public static bool IsScalar(Type type);
    [ExtensionAttribute]
public static bool IsAnonymous(Type type);
    [ExtensionAttribute]
public static bool IsDescendantOf(Type type, Type ancestor);
    [ExtensionAttribute]
public static object CreateDefaultValue(Type type);
    [ExtensionAttribute]
public static bool HasParameterlessConstructor(Type type);
    [ExtensionAttribute]
public static bool HasSingleParameterConstructor(Type type, Type paramType);
    public static Type GetTypeEx(string typeName, bool throwOnError, bool ignoreCase);
    [ExtensionAttribute]
public static Type GetTypeWithNullableSupport(Type type);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedUri : object {
    [ExtensionAttribute]
public static string FullQueryEncode(Uri uri);
    [ExtensionAttribute]
public static string GetFullyEncodedQueryString(Uri uri);
    [ExtensionAttribute]
public static string ToSecureString(Uri uri);
    private static bool IsPublicOrPrivate(IPAddress address);
    [ExtensionAttribute]
public static bool IsLoopbackOrLinkLocal(Uri uri);
    [ExtensionAttribute]
public static bool IsSecureTlsUri(Uri uri);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string UrlEncode(string str);
    public static string UrlEncode(string str, Encoding encoding);
    public static string UrlDecode(string str);
    public static string UrlDecode(string str, Encoding encoding);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(string s);
    public static string HtmlEncode(object value);
    public static void HtmlEncode(string s, TextWriter output);
    public static Uri CombineUriAndRelativePath(string uriStr, string relativePath);
    public static string JavaScriptStringEncode(string value);
    public static string JavaScriptStringEncode(string value, bool addDoubleQuotes);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedUriParser : object {
    private static string c_cww;
    private static Char[] c_cos;
    private static ExtendedUriParser();
    public static ParsedUri Parse(string text);
    public static bool TryParse(string text, ParsedUri& ret);
    private static void IfFictivePortRemoveIt(Uri uri, ParsedUri parsedUri, string originalText);
    [ExtensionAttribute]
private static string NullIfWhiteSpace(string str, string alsoIf);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ExtendedWebExceptionStatus : object {
    private static HashSet`1<WebExceptionStatus> s_transientCodes;
    private static ExtendedWebExceptionStatus();
    [ExtensionAttribute]
public static bool IsTransient(WebExceptionStatus webExceptionStatus);
}
public class Kusto.Cloud.Platform.Utils.FastCsvWriter : CsvWriter {
    [ThreadStaticAttribute]
private static Char[] t_scratch;
    public FastCsvWriter(TextWriter writer);
    public virtual bool WriteField(string what, bool abortOnWriteFailures);
}
public class Kusto.Cloud.Platform.Utils.FastSuffixMatcher`1 : object {
    private int m_suffixLength;
    private Dictionary`2<string, List`1<MatchRule<T>>> m_rules;
    private bool m_ignoreCase;
    private FastSuffixMatcher`1(int suffixLength, Dictionary`2<string, List`1<MatchRule<T>>> rules, bool ignoreCase);
    public static FastSuffixMatcher`1<T> Create(IEnumerable`1<MatchRule<T>> rules, bool ignoreCase);
    public static FastSuffixMatcher`1<T> Create(FastSuffixMatcher`1<T> existing, IEnumerable`1<MatchRule<T>> rules, bool ignoreCase);
    public bool IsMatch(string candidate);
    public ValueTuple`2<bool, MatchRule<T>> Match(string candidate);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.FileCopyOptions : Enum {
    public int value__;
    public static FileCopyOptions OverwriteUnconditionally;
    public static FileCopyOptions OverwriteIfNewer;
}
public enum Kusto.Cloud.Platform.Utils.FileCopyResults : Enum {
    public int value__;
    public static FileCopyResults Copied;
    public static FileCopyResults SourceNotFound;
    public static FileCopyResults DestAlreadyExists;
    public static FileCopyResults DestNewer;
    public static FileCopyResults Exception;
}
public class Kusto.Cloud.Platform.Utils.FileDumper : object {
    private StreamWriter m_writer;
    private bool m_autoFlush;
    public bool SupportsText { get; }
    public bool SupportsBinary { get; }
    public FileDumper(string file, bool autoFlush);
    public sealed virtual void Dispose();
    public sealed virtual bool get_SupportsText();
    public sealed virtual bool get_SupportsBinary();
    private static bool AllSpaces(string text);
    public sealed virtual void Append(string text);
    public sealed virtual void Append(Char[] buffer, int start, int count);
    public sealed virtual void Append(Byte[] buffer, int start, int count);
}
public class Kusto.Cloud.Platform.Utils.FileTailWatcher : object {
    private string m_file;
    private Action`1<string> m_onChanged;
    private FileSystemWatcher m_watcher;
    private FileStream m_fileStream;
    private StreamReader m_reader;
    private long m_pos;
    public FileTailWatcher(string file, Action`1<string> onChanged);
    public sealed virtual void Dispose();
    private void OnChanged(object sender, FileSystemEventArgs args);
}
public class Kusto.Cloud.Platform.Utils.FixedWindowThrottlerPolicy : object {
    private TimeSpan m_timeWindow;
    private ulong m_maxOperationsInTimeWindow;
    private string m_resourceKind;
    private string m_resourceId;
    private DateTime m_lastUpdate;
    private ulong m_operationsCounter;
    private object m_lock;
    public FixedWindowThrottlerPolicy(ulong maxOperationsInTimeWindow, TimeSpan timeWindow, string resourceKind, string resourceId, Nullable`1<DateTime> utcNow);
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    public sealed virtual void OnInvokeDone();
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    protected DateTime ProvideUtcNow(Nullable`1<DateTime> utcNow);
}
public class Kusto.Cloud.Platform.Utils.GarbageCollector : object {
    private static string c_gcnowTweakName;
    private static MethodInfo s_GC_GetAllocatedBytesForCurrentThread;
    private static Thinner s_thinner;
    private long m_lock;
    private Tweak`1<int> m_gcnowTweak;
    public GarbageCollector(Tweaks tweaks);
    private static GarbageCollector();
    private void GCNow(Tweak`1<int> tweak);
    internal static IManageableTraceSource GetTracer();
    public static void ExecuteForcedManagedHeapCleanup();
    public static IDisposable TraceAllocatedBytesForCurrentThread(string request);
    public static IDisposable TraceAllocatedBytesForCurrentThread(string request, Action`1<long> onDone);
    private static MethodInfo InitGCGetAllocatedBytesForCurrentThread();
}
public class Kusto.Cloud.Platform.Utils.GrannyComparer : object {
    public static GrannyComparer Instance;
    private static GrannyComparer();
    public sealed virtual int Compare(string left, string right);
}
public class Kusto.Cloud.Platform.Utils.HtmlTabulator : object {
    private int m_columnCount;
    private Action`1<string> m_outputWriter;
    private bool m_firstLine;
    public HtmlTabulator(int columnCount, Action`1<string> outputWriter);
    public sealed virtual void Add(String[] row);
    public sealed virtual void Done();
}
public enum Kusto.Cloud.Platform.Utils.HttpStatusCodeEx : Enum {
    public int value__;
    public static HttpStatusCodeEx Continue;
    public static HttpStatusCodeEx SwitchingProtocols;
    public static HttpStatusCodeEx Processing;
    public static HttpStatusCodeEx OK;
    public static HttpStatusCodeEx Created;
    public static HttpStatusCodeEx Accepted;
    public static HttpStatusCodeEx NonAuthoritativeInformation;
    public static HttpStatusCodeEx NoContent;
    public static HttpStatusCodeEx ResetContent;
    public static HttpStatusCodeEx PartialContent;
    public static HttpStatusCodeEx MultiStatus;
    public static HttpStatusCodeEx AlreadyReported;
    public static HttpStatusCodeEx IMUsed;
    public static HttpStatusCodeEx MultipleChoices;
    public static HttpStatusCodeEx Ambiguous;
    public static HttpStatusCodeEx MovedPermanently;
    public static HttpStatusCodeEx Moved;
    public static HttpStatusCodeEx Redirect;
    public static HttpStatusCodeEx Found;
    public static HttpStatusCodeEx RedirectMethod;
    public static HttpStatusCodeEx SeeOther;
    public static HttpStatusCodeEx NotModified;
    public static HttpStatusCodeEx UseProxy;
    public static HttpStatusCodeEx SwitchProxy;
    public static HttpStatusCodeEx Unused;
    public static HttpStatusCodeEx TemporaryRedirect;
    public static HttpStatusCodeEx RedirectKeepVerb;
    public static HttpStatusCodeEx PermanentRedirect;
    public static HttpStatusCodeEx BadRequest;
    public static HttpStatusCodeEx Unauthorized;
    public static HttpStatusCodeEx PaymentRequired;
    public static HttpStatusCodeEx Forbidden;
    public static HttpStatusCodeEx NotFound;
    public static HttpStatusCodeEx MethodNotAllowed;
    public static HttpStatusCodeEx NotAcceptable;
    public static HttpStatusCodeEx ProxyAuthenticationRequired;
    public static HttpStatusCodeEx RequestTimeout;
    public static HttpStatusCodeEx Conflict;
    public static HttpStatusCodeEx Gone;
    public static HttpStatusCodeEx LengthRequired;
    public static HttpStatusCodeEx PreconditionFailed;
    public static HttpStatusCodeEx RequestEntityTooLarge;
    public static HttpStatusCodeEx PayloadTooLarge;
    public static HttpStatusCodeEx RequestUriTooLong;
    public static HttpStatusCodeEx UnsupportedMediaType;
    public static HttpStatusCodeEx RequestedRangeNotSatisfiable;
    public static HttpStatusCodeEx ExpectationFailed;
    public static HttpStatusCodeEx ImATeapot;
    public static HttpStatusCodeEx MisdirectedRequest;
    public static HttpStatusCodeEx UnprocessableEntity;
    public static HttpStatusCodeEx Locked;
    public static HttpStatusCodeEx FailedDependency;
    public static HttpStatusCodeEx UpgradeRequired;
    public static HttpStatusCodeEx PreconditionRequired;
    public static HttpStatusCodeEx TooManyRequests;
    public static HttpStatusCodeEx RequestHeaderFieldsTooLarge;
    public static HttpStatusCodeEx InternalServerError;
    public static HttpStatusCodeEx NotImplemented;
    public static HttpStatusCodeEx BadGateway;
    public static HttpStatusCodeEx ServiceUnavailable;
    public static HttpStatusCodeEx GatewayTimeout;
    public static HttpStatusCodeEx HttpVersionNotSupported;
    public static HttpStatusCodeEx Variant;
    public static HttpStatusCodeEx InsufficientStorag;
    public static HttpStatusCodeEx LoopDetected;
    public static HttpStatusCodeEx NotExtended;
    public static HttpStatusCodeEx NetworkAuthenticationRequire;
    public static HttpStatusCodeEx UnknownError;
}
internal interface Kusto.Cloud.Platform.Utils.IAppSettingsProvider {
    public abstract virtual NameValueDictionary GetAppSettings();
}
public interface Kusto.Cloud.Platform.Utils.IAtomicBucketCounter {
    public abstract virtual long Take(long count, ReturnKey& returnKey);
    public abstract virtual void Return(long count, ReturnKey returnKey);
    public abstract virtual void Resize(long capacity);
    public abstract virtual AtomicCounterSnapshot TakeSnapshot();
}
public interface Kusto.Cloud.Platform.Utils.IAtomicCounter {
    public abstract virtual long Take(long count);
    public abstract virtual void Return(long count);
    public abstract virtual void Resize(long capacity);
    public abstract virtual AtomicCounterSnapshot TakeSnapshot();
}
public interface Kusto.Cloud.Platform.Utils.IAtomicNetworkCounter {
    public abstract virtual long Take(long count, string entityId);
    public abstract virtual void Return(long count, string entityId);
    public abstract virtual void ReportEntityAcquiredCapacity(string entityId, long consumed, long reportVersion, bool disableTraces);
    public abstract virtual void Resize(long newCapacity);
    public abstract virtual AtomicCounterSnapshot TakeSnapshot();
}
public interface Kusto.Cloud.Platform.Utils.ICloudPlatformException {
    public int FailureCode { get; }
    public string FailureSubCode { get; }
    public bool IsPermanent { get; }
    public CreationContext CreationContext { get; }
    public bool AlreadyTraced { get; }
    public abstract virtual int get_FailureCode();
    public abstract virtual string get_FailureSubCode();
    public abstract virtual bool get_IsPermanent();
    public abstract virtual CreationContext get_CreationContext();
    public abstract virtual bool get_AlreadyTraced();
    public abstract virtual void WriteToStringTo(StringBuilder sb);
    public abstract virtual void WritePropertiesTo(StringBuilder sb);
}
public interface Kusto.Cloud.Platform.Utils.IConsumerPool`1 {
    public abstract virtual void EnqueueRange(IEnumerable`1<TConsumable> items);
    public abstract virtual void Enqueue(TConsumable item);
}
public interface Kusto.Cloud.Platform.Utils.IDumper {
    public bool SupportsText { get; }
    public bool SupportsBinary { get; }
    public abstract virtual bool get_SupportsText();
    public abstract virtual bool get_SupportsBinary();
    public abstract virtual void Append(string text);
    public abstract virtual void Append(Char[] buffer, int start, int count);
    public abstract virtual void Append(Byte[] buffer, int start, int count);
}
public interface Kusto.Cloud.Platform.Utils.IEmergencyTracer {
    public abstract virtual void AsEdiExceptionHandler(string messaage, ExceptionDispatchInfo edi);
    public abstract virtual void WriteLine(string what, bool force);
}
public interface Kusto.Cloud.Platform.Utils.IIdentifiable {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface Kusto.Cloud.Platform.Utils.IImmutable {
}
public interface Kusto.Cloud.Platform.Utils.IJitStreamSource {
    public abstract virtual IEnumerator`1<string> Write(TextWriter writer, Func`1<bool> ShouldPause);
}
public interface Kusto.Cloud.Platform.Utils.ILogger`1 {
    public bool Enabled { get; public set; }
    public abstract virtual void Write(string value);
    public abstract virtual void Write(T flavor, string value);
    public abstract virtual void Write(string format, Object[] args);
    public abstract virtual void Write(T flavor, string format, Object[] args);
    public abstract virtual void WriteLine(string value);
    public abstract virtual void WriteLine(T flavor, string value);
    public abstract virtual void WriteLine(string format, Object[] args);
    public abstract virtual void WriteLine(T flavor, string format, Object[] args);
    public abstract virtual void Flush();
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
}
public interface Kusto.Cloud.Platform.Utils.IManageableTraceSource {
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public TraceVerbosity Verbosity { get; public set; }
    public bool Confidential { get; }
    public abstract virtual string get_Id();
    public abstract virtual TraceVerbosity get_DefaultVerbosity();
    public abstract virtual TraceVerbosity get_Verbosity();
    public abstract virtual void set_Verbosity(TraceVerbosity value);
    public abstract virtual bool get_Confidential();
    public abstract virtual void SetTraceSourceListeners(TraceListenerCollection listeners);
    public abstract virtual void AddTraceListener(TraceListener traceListener, bool forceAddEvenIfTypeAlreadyExists);
    public abstract virtual void RemoveTraceListener(TraceListener traceListener);
}
public class Kusto.Cloud.Platform.Utils.ImmediateConsoleDumper : object {
    private ConsoleColor m_color;
    public bool SupportsText { get; }
    public bool SupportsBinary { get; }
    public sealed virtual void Dispose();
    public sealed virtual bool get_SupportsText();
    public sealed virtual bool get_SupportsBinary();
    private static bool AllSpaces(string text);
    public sealed virtual void Append(string text);
    public sealed virtual void Append(Char[] buffer, int start, int count);
    public sealed virtual void Append(Byte[] buffer, int start, int count);
}
public class Kusto.Cloud.Platform.Utils.ImmutableManyToManyMap`3 : object {
    private Dictionary`2<TOuter, HashSet`1<TInner>> m_outerToInner;
    private Dictionary`2<TInner, HashSet`1<TOuter>> m_innerToOuter;
    private Dictionary`2<TInner, TInnerData> m_innerData;
    public ImmutableManyToManyMap`3<TOuter, TInner, TInnerData> NewOrNullAdd(TOuter outer, IEnumerable`1<TInner> inners);
    public ImmutableManyToManyMap`3<TOuter, TInner, TInnerData> NewOrNullAdd(TOuter outer, IEnumerable`1<Tuple`2<TInner, TInnerData>> inners);
    private ImmutableManyToManyMap`3<TOuter, TInner, TInnerData> Clone();
    private static Dictionary`2<TKey, HashSet`1<TElement>> CloneDHSI(Dictionary`2<TKey, HashSet`1<TElement>> src);
}
internal class Kusto.Cloud.Platform.Utils.Indentation : object {
    private IndentedTextWriter writer;
    private int indent;
    private string s;
    internal string IndentationString { get; }
    internal Indentation(IndentedTextWriter writer, int indent);
    internal string get_IndentationString();
}
public class Kusto.Cloud.Platform.Utils.IndentedTextWriter : TextWriter {
    private TextWriter writer;
    private int indentLevel;
    private bool tabsPending;
    private string tabString;
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    internal string TabString { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    internal string get_TabString();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual void WriteLine(UInt32 value);
    internal void InternalOutputTabs();
}
public interface Kusto.Cloud.Platform.Utils.INetworkCacheValueFactory`3 {
    public bool IsBatchCreationSupported { get; }
    public abstract virtual Task`1<TValue> CreateCacheEntryValueAsync(TKey key, TGetContext context, NetworkCacheEntry`3<TKey, TGetContext, TValue> previous);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<TKey, TValue>>> CreateCacheEntriesValuesAsync(IEnumerable`1<TKey> keys, TGetContext context, Dictionary`2<TKey, NetworkCacheEntry`3<TKey, TGetContext, TValue>> previous);
    public abstract virtual bool get_IsBatchCreationSupported();
    public abstract virtual bool IsApplicableCacheEntryValue(NetworkCacheEntry`3<TKey, TGetContext, TValue> current, DateTime now);
}
public class Kusto.Cloud.Platform.Utils.InterlockedBool : ValueType {
    private long m_bit;
    public void Set(bool value);
    public bool Get();
    public bool Exchange(bool value);
}
internal static class Kusto.Cloud.Platform.Utils.Interop : object {
}
public class Kusto.Cloud.Platform.Utils.IntPtrWriteStream : Stream {
    private IntPtr m_buffer;
    private int m_bufferSize;
    private int m_pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public IntPtrWriteStream(IntPtr buffer, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.InvalidSwitchValue : ArgumentException {
    public object Value;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public InvalidSwitchValue(string message, Exception innerException);
    protected InvalidSwitchValue(SerializationInfo info, StreamingContext context);
    public InvalidSwitchValue(object value, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public InvalidSwitchValue(object value, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.InvalidTypeException : Exception {
    public string DataType;
    public string Context;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public InvalidTypeException(string message, Exception innerException);
    protected InvalidTypeException(SerializationInfo info, StreamingContext context);
    public InvalidTypeException(string dataType, string context, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public InvalidTypeException(string dataType, string context, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Kusto.Cloud.Platform.Utils.IO_COUNTERS : ValueType {
    public ulong ReadOperationCount;
    public ulong WriteOperationCount;
    public ulong OtherOperationCount;
    public ulong ReadTransferCount;
    public ulong WriteTransferCount;
    public ulong OtherTransferCount;
}
public interface Kusto.Cloud.Platform.Utils.IObjectDumperUsesToDumpString {
    public abstract virtual void ToDumpString(ExtendedStringBuilder esb, object context);
}
public interface Kusto.Cloud.Platform.Utils.IObjectDumperUsesToString {
}
public interface Kusto.Cloud.Platform.Utils.IObjectPool`2 {
    public int Count { get; }
    public IEnumerable`1<TValue> Values { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> Items { get; }
    public abstract virtual void Add(TKey key, TValue obj);
    public abstract virtual bool TryRemove(TKey key, TValue& obj);
    public abstract virtual bool TryTouch(TKey key, TValue& obj);
    public abstract virtual bool TryTouchMatching(TKey key, Func`2<TValue, bool> predicate, TValue& obj);
    public abstract virtual List`1<KeyValuePair`2<TKey, TValue>> RemoveMatching(Func`3<TKey, TValue, bool> predicate);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TValue>> get_Items();
    public abstract virtual IEnumerable`1<TValue> RemoveKey(TKey key);
}
public interface Kusto.Cloud.Platform.Utils.IOpinionatedDumper {
    public abstract virtual bool Predicate(string arg);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.IPAddressCategory : Enum {
    public int value__;
    public static IPAddressCategory NoCategory;
    public static IPAddressCategory Any;
    public static IPAddressCategory Broadcast;
    public static IPAddressCategory LinkLocal;
    public static IPAddressCategory Loopback;
    public static IPAddressCategory Multicast;
    public static IPAddressCategory Private;
    public static IPAddressCategory Public;
    public static IPAddressCategory SiteLocal;
    public static IPAddressCategory Special;
    public static IPAddressCategory AllCategories;
}
public enum Kusto.Cloud.Platform.Utils.IpCalloutFailType : Enum {
    public int value__;
    public static IpCalloutFailType InvalidInput;
    public static IpCalloutFailType DnsResolutionFailed;
    public static IpCalloutFailType IpNotAllowed;
}
public interface Kusto.Cloud.Platform.Utils.IPlatformExceptionDetailProvider {
    public PlatformExceptionDetail PlatformExceptionDetail { get; }
    public abstract virtual PlatformExceptionDetail get_PlatformExceptionDetail();
}
public interface Kusto.Cloud.Platform.Utils.IPlatformTraceListener {
    public string ServiceAlias { get; public set; }
    public string MachineName { get; public set; }
    public string TargetFolder { get; }
    unknown TimeSpan RolloverPeriod {public set; }
    public TriState IsConfidential { get; }
    public abstract virtual void SuperFlush();
    public abstract virtual string get_ServiceAlias();
    public abstract virtual void set_ServiceAlias(string value);
    public abstract virtual string get_MachineName();
    public abstract virtual void set_MachineName(string value);
    public abstract virtual string get_TargetFolder();
    public abstract virtual void set_RolloverPeriod(TimeSpan value);
    public abstract virtual TriState get_IsConfidential();
}
public interface Kusto.Cloud.Platform.Utils.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
public interface Kusto.Cloud.Platform.Utils.IResourcesManager`2 {
    public abstract virtual Task`1<TResourceToken> AcquireResourceAsync(TResourceKind resourceKind);
    public abstract virtual TResourceToken TryAcquireResource(TResourceKind resourceKind, ResourceSnapshot`1& resourceSnapshot);
    public abstract virtual TResourceToken TryAcquireMultipleResources(TResourceKind resourceKind, long count, ResourceSnapshot`1& resourceSnapshot);
    public abstract virtual ResourceSnapshot`1<TResourceKind> TakeSnapshot(TResourceKind resourceKind);
    public abstract virtual ResourceSnapshot`1<TResourceKind> TakeClusterSnapshot(TResourceKind resourceKind);
    public abstract virtual ResourceSnapshot`1<TResourceKind> TakeLocalSnapshot(TResourceKind resourceKind);
}
public interface Kusto.Cloud.Platform.Utils.IRollingWriteStreamPolicy {
    public abstract virtual RollingWriteStreamContext CreateContext();
    public abstract virtual bool ShouldDisposeContext(RollingWriteStreamContext context);
    public abstract virtual void OnContextDisposed(RollingWriteStreamContext context);
    public abstract virtual void CleanupInProgressStreams(string fileToAvoid);
}
public interface Kusto.Cloud.Platform.Utils.IShuttable {
    public abstract virtual void Stop();
    public abstract virtual void WaitForStopToComplete();
    public abstract virtual void Shutdown();
}
public interface Kusto.Cloud.Platform.Utils.ISizable {
    public long Size { get; }
    public abstract virtual long get_Size();
}
public interface Kusto.Cloud.Platform.Utils.ITabulator {
    public abstract virtual void Add(String[] row);
    public abstract virtual void Done();
}
public interface Kusto.Cloud.Platform.Utils.IThrottler {
    public abstract virtual bool TryInvoke(Action action, Nullable`1<DateTime> utcNow);
    public abstract virtual Task`1<bool> TryInvokeAsync(Func`1<Task> action, Nullable`1<DateTime> utcNow);
    public abstract virtual Tuple`2<bool, Task`1<TResult>> TryInvokeAsync(Func`1<Task`1<TResult>> action, Nullable`1<DateTime> utcNow);
}
public interface Kusto.Cloud.Platform.Utils.IThrottlerPolicy {
    public abstract virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public abstract virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    public abstract virtual void OnInvokeDone();
    public abstract virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
}
public interface Kusto.Cloud.Platform.Utils.IToStringWriter {
    public abstract virtual void WriteAsString(ExtendedStringBuilder esb);
}
public interface Kusto.Cloud.Platform.Utils.ITraceIngestor {
    public abstract virtual void Start(bool scanUponStart);
    public abstract virtual void Stop();
    public abstract virtual bool TryScanNow();
    public abstract virtual string GetDestinationForTracing();
}
public abstract class Kusto.Cloud.Platform.Utils.ITraceSource : object {
    public abstract virtual void TraceWithHeader(TraceVerbosity verbosity, string header, string message);
    public abstract virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string message);
    public abstract virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string format, Object[] args);
    public abstract virtual void TraceFatal(string message);
    public abstract virtual void TraceFatal(string format, Object[] args);
    public abstract virtual void TraceError(string message);
    public abstract virtual void TraceError(string format, Object[] args);
    public abstract virtual void TraceWarning(string message);
    public abstract virtual void TraceWarning(string format, Object[] args);
    public abstract virtual void TraceInformation(string message);
    public abstract virtual void TraceInformation(string format, Object[] args);
    public abstract virtual void TraceVerbose(string message);
    public abstract virtual void TraceVerbose(string format, Object[] args);
    public abstract virtual bool ShouldTrace(TraceVerbosity level);
    public abstract virtual bool ShouldTrace(TraceVerbosity level, TracingContext tracingContext);
    public abstract virtual void Flush();
}
public interface Kusto.Cloud.Platform.Utils.ITraceString {
    public abstract virtual string ToTraceString();
}
public interface Kusto.Cloud.Platform.Utils.ITrie`2 {
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual IEnumerable`1<Tuple`2<TKey, TValue>> MatchByPrefix(TKey prefix);
}
public interface Kusto.Cloud.Platform.Utils.IWorkTicketFactory {
    public long NumPendingWorkTickets { get; }
    public abstract virtual WorkTicket TryCreateWorkTicket(IIdentifiable owningEntity, string description);
    public abstract virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, string description);
    public abstract virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    public abstract virtual bool TryCreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    public abstract virtual long get_NumPendingWorkTickets();
}
public interface Kusto.Cloud.Platform.Utils.IXsvWriter {
    public long BytesWritten { get; }
    public abstract virtual bool WriteField(string what, bool abortOnWriteFailures);
    public abstract virtual void CompleteRecord();
    public abstract virtual long get_BytesWritten();
    public abstract virtual void Flush();
}
public class Kusto.Cloud.Platform.Utils.JitStream : Stream {
    private JitStreamHelper m_jitStreamHelper;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool EndOfStream { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public JitStream(IJitStreamSource source, ITraceSource tracer, int internalBufferSize, Encoding encoding, Byte[] initialData, IDisposable whenDone);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public bool get_EndOfStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Utils.JitStreamHelper : object {
    private Context m_creationContext;
    private ITraceSource m_tracer;
    private IDisposable m_whenDone;
    private IJitStreamSource m_source;
    private IEnumerator`1<string> m_sourceEnumerator;
    private bool m_sourceDone;
    private Byte[] m_initialData;
    private int m_internalBufferSize;
    private Encoding m_encoding;
    private StreamWriter m_intermediateStreamWriter;
    private WriteStreamsCartridge m_intermediateStreamWrapper;
    private Stream m_intermediateStream;
    private Byte[] m_readByteBuffer;
    private bool m_isInitialized;
    private long m_lastInternalStreamPositionRead;
    private long m_lastInternalStreamPositionWrite;
    private long m_intermediateStreamPositionToStop;
    public bool IsEndOfStream { get; }
    public bool HasPendingData { get; }
    public JitStreamHelper(IJitStreamSource source, ITraceSource tracer, int internalBufferSize, Encoding encoding, Byte[] initialData, IDisposable whenDone);
    public sealed virtual void Dispose();
    public bool get_IsEndOfStream();
    public bool get_HasPendingData();
    public int ReadByte();
    private bool ShouldPause();
    public int Read(Byte[] buffer, int offset, int count);
    private void InitializeIfNeeded();
    private void RecycleIntermediateStream();
    private void RecreateInternalStreamIfNeeded();
    private int CopyBytesToReadBuffer(Byte[] buffer, int offset, int count);
}
public class Kusto.Cloud.Platform.Utils.JobObject : object {
    private static long s_howMany;
    private JobObjectSafeHandle m_handle;
    private JobObject(IntPtr handle, bool ownsHandle);
    public static JobObject Create(string name, bool killOnJobClose, bool ownsHandle);
    public sealed virtual void Dispose();
    public void Close();
    public bool Terminate(UInt32 exitCode);
    public void InvokeDangerous(Action`1<IntPtr> action);
    public T InvokeDangerous(Func`2<IntPtr, T> func);
    public bool IsProcessInJob(Process process);
    public static long GetCreatedButUndisposedCount();
    public static MemoryStatus GetMemoryStatus(Process process);
    public ResourcesUtilization GetResourcesUtilization();
    public void AddProcess(IntPtr processHandle);
    public void AddCurrentProcess();
    public void LimitProcessVirtualMemorySize(ulong size);
    public void LimitMaxCpuPercentage(UInt32 maxPercentage);
    public void LimitNetworkUsage(ulong bandwidthInBytesPerSecond);
    private static bool IsProcessInJobImpl(IntPtr hProcess, IntPtr hJobHandle);
    private JOBOBJECT_BASIC_ACCOUNTING_INFORMATION GetBasicAccountingInformation();
    private static JOBOBJECT_EXTENDED_LIMIT_INFORMATION GetExtendedLimitInformation(IntPtr hJobObject);
    private void KillProcessOnJobClose();
    private void SetExtendedLimitInfo(JOBOBJECT_EXTENDED_LIMIT_INFORMATION& info);
    private void SetCpuRateControlInfo(JOBOBJECT_CPU_RATE_CONTROL_INFORMATION& info);
    internal static JOBOBJECT_CPU_RATE_CONTROL_INFORMATION GetCpuRateControlInfo(IntPtr hJobObject, bool useEmptyObjectToIndicateFailures);
    private void SetNetworkControlInfo(JOBOBJECT_NET_RATE_CONTROL_INFORMATION& info);
    internal static JOBOBJECT_NET_RATE_CONTROL_INFORMATION GetNetworkControlInfo(IntPtr hJobObject, bool useEmptyObjectToIndicateFailures);
    private static MemoryStatus GetOSMemoryStatus();
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_BASIC_ACCOUNTING_INFORMATION : ValueType {
    public ulong TotalUserTime;
    public ulong TotalKernelTime;
    public ulong ThisPeriodTotalUserTime;
    public ulong ThisPeriodTotalKernelTime;
    public UInt32 TotalPageFaultCount;
    public UInt32 TotalProcesses;
    public UInt32 ActiveProcesses;
    public UInt32 TotalTerminatedProcesses;
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_BASIC_LIMIT_INFORMATION : ValueType {
    public long PerProcessUserTimeLimit;
    public long PerJobUserTimeLimit;
    public UInt32 LimitFlags;
    public ulong MinimumWorkingSetSize;
    public ulong MaximumWorkingSetSize;
    public UInt32 ActiveProcessLimit;
    public UIntPtr Affinity;
    public UInt32 PriorityClass;
    public UInt32 SchedulingClass;
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION : ValueType {
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_ENABLE;
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED;
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP;
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY;
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE;
    public static UInt32 JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS;
    public UInt32 ControlFlags;
    public UInt32 CpuRate;
    public UInt32 Weight;
    public ushort MinRate;
    public ushort MaxRate;
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_EXTENDED_LIMIT_INFORMATION : ValueType {
    public static UInt32 JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    public static UInt32 JOB_OBJECT_LIMIT_JOB_MEMORY;
    public static UInt32 JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
    public static UInt32 JOB_OBJECT_LIMIT_WORKINGSET;
    public JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    public IO_COUNTERS IoInfo;
    public ulong ProcessMemoryLimit;
    public ulong JobMemoryLimit;
    public ulong PeakProcessMemoryUsed;
    public ulong PeakJobMemoryUsed;
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_NET_RATE_CONTROL_FLAGS : ValueType {
    public static UInt32 JOB_OBJECT_NET_RATE_CONTROL_ENABLE;
    public static UInt32 JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH;
    public static UInt32 JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG;
    public static UInt32 JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS;
}
internal class Kusto.Cloud.Platform.Utils.JOBOBJECT_NET_RATE_CONTROL_INFORMATION : ValueType {
    public ulong MaxBandwidth;
    public UInt32 ControlFlags;
    public byte DscpTag;
}
public enum Kusto.Cloud.Platform.Utils.JobObjectInfoType : Enum {
    public int value__;
    public static JobObjectInfoType BasicAccountingInformation;
    public static JobObjectInfoType AssociateCompletionPortInformation;
    public static JobObjectInfoType BasicLimitInformation;
    public static JobObjectInfoType BasicUIRestrictions;
    public static JobObjectInfoType EndOfJobTimeInformation;
    public static JobObjectInfoType ExtendedLimitInformation;
    public static JobObjectInfoType SecurityLimitInformation;
    public static JobObjectInfoType GroupInformation;
    public static JobObjectInfoType CpuRateControlInformation;
    public static JobObjectInfoType JobObjectNetRateControlInformation;
}
[SecurityCriticalAttribute]
public class Kusto.Cloud.Platform.Utils.JobObjectSafeHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public JobObjectSafeHandle(IntPtr preexistingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SuppressUnmanagedCodeSecurityAttribute]
public static bool CloseHandle(IntPtr hObject);
}
public class Kusto.Cloud.Platform.Utils.JustifiedResult : object {
    private static JustifiedResult s_success;
    private static string s_noReason;
    [CompilerGeneratedAttribute]
private TriState <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public TriState Result { get; }
    public string Justification { get; }
    protected JustifiedResult(TriState result, string justification);
    private static JustifiedResult();
    [CompilerGeneratedAttribute]
public TriState get_Result();
    [CompilerGeneratedAttribute]
public string get_Justification();
    public static JustifiedResult FromSuccess();
    public static JustifiedResult FromError(string justification);
    public static JustifiedResult FromDontKnow(string justification);
    public virtual string ToString();
}
public class Kusto.Cloud.Platform.Utils.JustifiedResult`1 : JustifiedResult {
    private static JustifiedResult`1<T> s_successT;
    [CompilerGeneratedAttribute]
private T <Context>k__BackingField;
    public T Context { get; }
    private JustifiedResult`1(TriState result, string justification);
    private JustifiedResult`1(TriState result, string justification, T context);
    private static JustifiedResult`1();
    [CompilerGeneratedAttribute]
public T get_Context();
    public static JustifiedResult`1<T> FromSuccess();
    public static JustifiedResult`1<T> FromError(string justification, T context);
    public static JustifiedResult`1<T> FromDontKnow(string justification, T context);
}
public class Kusto.Cloud.Platform.Utils.KuiperContext : object {
    private Guid m_kuiperJobId;
    public Guid JobId { get; }
    public KuiperContext(Guid kuiperJobId);
    public Guid get_JobId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(KuiperContext other);
}
public abstract class Kusto.Cloud.Platform.Utils.KustoEventSourceBase : EventSource {
    public static int EtwSizeLimit;
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, Guid rootActivityId);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId, string arg1);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId, int arg1);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId, string arg1, string arg2);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId, string arg1, int arg2);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, Guid rootActivityId, string arg1);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, bool success);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, DateTime time, string arg1, string arg2, string arg3);
    [NonEventAttribute]
protected void FastWriteEvent(int eventId, string clientRequestId, Guid rootActivityId, string traceId, string severity, string message);
}
public static class Kusto.Cloud.Platform.Utils.LeakDetector : object {
    private static Dictionary`2<string, LeakDetectorEntry> s_tracked;
    private static LeakDetector();
    public static void Reset();
    public static IDisposable Register(object value, string comment);
    public static List`1<LeakDetectorEntry> GetCurrentLeaks();
    private static void Deregister(string id);
}
public class Kusto.Cloud.Platform.Utils.LeakDetectorSlim : object {
    private static LeakDetectorSlimTimerActivityType s_activityType;
    private string m_name;
    private long m_countThreshold;
    private long m_corrupted;
    private long m_count;
    private PeriodicNonoverlappingTimer m_timer;
    public static IManageableTraceSource TracerForDebugging { get; }
    public LeakDetectorSlim(string name, long countThreshold);
    private static LeakDetectorSlim();
    public sealed virtual void Dispose();
    public void AddRef();
    public void Release();
    public static IManageableTraceSource get_TracerForDebugging();
    public void SimulateTimerForDebugging();
    private void OnTimer(PeriodicNonoverlappingTimer timer, object context);
}
public static class Kusto.Cloud.Platform.Utils.Library : object {
    private static CloudPlatformExecutionMode s_mode;
    private static ClientServerProfile s_profile;
    public static CloudPlatformExecutionMode Mode { get; }
    public static ClientServerProfile ClientServerProfile { get; }
    public static Tweaks Initialize(CloudPlatformExecutionMode cloudPlatformExecutionMode, ClientServerProfile clientServerProfile, Assembly assembly);
    public static CloudPlatformExecutionMode get_Mode();
    public static ClientServerProfile get_ClientServerProfile();
    private static Assembly TryLoadKustoCommonSvc();
    private static void ReplaceTraceListenersIfNecessary();
    private static void DisableDebuggerProxy();
}
public class Kusto.Cloud.Platform.Utils.LoggerTracer : object {
    private ITraceSource m_tracer;
    private bool m_writeToConsole;
    private static int Success;
    private static int Info;
    private static int Verbose;
    private static int Error;
    private static int Warning;
    private static int Fatal;
    public ITraceSource Tracer { get; }
    public LoggerTracer(ITraceSource tracer, bool writeToConsole);
    public LoggerTracer(ITraceSource tracer);
    public void SetTraceVerbosity(TraceVerbosity traceVerbosity);
    public ITraceSource get_Tracer();
    public void LogSuccess(string msg);
    public void LogInfo(string msg);
    public void LogVerbose(string msg);
    public void LogError(string msg);
    public void LogWarning(string msg);
    public void LogFatal(string msg);
    public void LogSuccess(string format, Object[] args);
    public void LogInfo(string format, Object[] args);
    public void LogVerbose(string format, Object[] args);
    public void LogError(string format, Object[] args);
    public void LogWarning(string format, Object[] args);
    public void LogFatal(string format, Object[] args);
    private static TraceVerbosity LevelToTraceVerbosity(int level);
    private void Log(string sourceId, int level, string msg);
    private void Log(int level, string format, Object[] args);
}
public static class Kusto.Cloud.Platform.Utils.LogicalCallContext`1 : object {
    private static AsyncLocal`1<T> s_currentContext;
    public static T Current { get; }
    private static LogicalCallContext`1();
    public static IDisposable Push(T value);
    public static T get_Current();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.LoopbackIPAddressOverflowException : UtilsException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public LoopbackIPAddressOverflowException(string message, Exception innerException);
    protected LoopbackIPAddressOverflowException(SerializationInfo info, StreamingContext context);
    public LoopbackIPAddressOverflowException(string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public LoopbackIPAddressOverflowException(string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Utils.MasterNamer : object {
    private static DecimalHasher modreq(System.Runtime.CompilerServices.IsVolatile) s_hasher;
    private static int c_azureStorageObjectsRandomPrefixLength;
    private static int c_azureStorageAccountNameMaxLength;
    private static int c_azureStorageQueueOrContainerNameMaxLength;
    public static int NumDethrottlerDigits { get; public set; }
    private static MasterNamer();
    public static int get_NumDethrottlerDigits();
    public static void set_NumDethrottlerDigits(int value);
    public static string GetName(string filenameBase, string filenameExtention, NamingOptions options, string delimiter);
    public static string GetContainerNameForTests(string tag);
    public static string ShortenStorageAccountNameIfRequiredAndAddRandomPrefix(string storageAccountName);
    public static string ShortenQueueNameIfRequiredAndAddRandomPrefix(string queueName);
    public static string ShortenContainerNameIfRequiredAndAddRandomPrefix(string containerName);
    public static string ShortenStorageAccountNameIfRequired(string storageAccountName);
    public static string ShortenQueueNameIfRequired(string queueName);
    private static string ShortenQueueOrContainerNameIfRequiredAndAddRandomPrefix(string queueOrContainerName);
    private static string TrimStartIfRequired(string str, int maxAllowedLength);
    private static string TrimEndIfRequired(string str, int maxAllowedLength);
}
public class Kusto.Cloud.Platform.Utils.MaxBinaryHeap`1 : BinaryHeap`1<T> {
    public MaxBinaryHeap`1(Action`2<int, T> notification, IEnumerable`1<T> elements);
    public MaxBinaryHeap`1(BinaryHeap`1<T> other, Func`2<IEnumerable`1<T>, IEnumerable`1<T>> modifier);
    protected virtual int Compare(T a, T b);
}
[DebuggerDisplayAttribute("Resource={m_resourceKind}/{m_resourceId}, Max={m_maxConcurrentCalls}, Remaining={m_remaining}")]
public class Kusto.Cloud.Platform.Utils.MaxConcurrentCallsThrottlerPolicy : object {
    private string m_resourceKind;
    private string m_resourceId;
    private Action`2<ResourceUtilizationMeasure, bool> m_onChange;
    private int m_remaining;
    private int m_maxConcurrentCalls;
    public int MaxConcurrentCalls { get; }
    public MaxConcurrentCallsThrottlerPolicy(string resourceKind, string resourceId, int maxConcurrentCalls, Action`2<ResourceUtilizationMeasure, bool> onChange);
    public int get_MaxConcurrentCalls();
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public sealed virtual void OnInvokeDone();
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    private void NotifyOnChange(int remaining, bool utilizationWentUp);
}
public class Kusto.Cloud.Platform.Utils.Maybe`1 : ValueType {
    private T m_value;
    private bool m_hasValue;
    public bool HasValue { get; }
    public T Value { get; }
    public static Maybe`1<T> Nothing { get; }
    public Maybe`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public static Maybe`1<T> get_Nothing();
}
public static class Kusto.Cloud.Platform.Utils.MemoryConstants : object {
    public static int _1KB;
    public static int _2KB;
    public static int _4KB;
    public static int _8KB;
    public static int _16KB;
    public static int _32KB;
    public static int _64KB;
    public static int _128KB;
    public static int _256KB;
    public static int _512KB;
    public static int _1MB;
    public static int _2MB;
    public static int _32MB;
    public static int _64MB;
    public static int _128MB;
    public static int _512MB;
    public static int _1GB;
    public static long _1TB;
    public static long _1PB;
    public static int LargeObjectHeap;
    public static int LargeObjectHeapChars;
    public static int LargeObjectHeapCharsStreamReaderWriter;
}
public class Kusto.Cloud.Platform.Utils.MemoryDumpCapsule : object {
    public string TargetName;
    public string FullDumpFileFullPath;
    public string PartialDumpFileFullPath;
    public string CrashEventName;
    public CrashSiteInformation CrashSiteInformation;
    public EventWaitHandle CrashEventHandle;
    public EventWaitHandle UncrashEventHandle;
    public string DebuggerPath;
    public string DebuggerArguments;
    public string ResponseFilePath;
    public string ResponseFileContents;
}
public static class Kusto.Cloud.Platform.Utils.MemoryDumper : object {
    private static string s_cdbPath;
    private static int c_waitTimeout;
    private static int s_suppressionLevel;
    private static HashSet`1<string> s_symbols;
    private static Action`2<CrashSiteInformation, StringBuilder> s_crashSiteInformationDecorator;
    private static MemoryDumper();
    public static void SetCrashSiteInformationDecorator(Action`2<CrashSiteInformation, StringBuilder> decorator);
    public static string DetermineDumpFileName(string dumpDirectory, string dumpFileName, Process targetProcess);
    public static void AddSymbolsDirectory(string path);
    public static String[] GetSymbolsDirectories();
    public static MemoryDumpCapsule CreateMemoryDumpCapsule(string dumpDirectory, string dumpFileName, Process targetProcess, string pathToDebugger, DumpOptions dumpOptions, bool enableCrashEventListening);
    public static string DumpMemory(CrashScenario scenario, MemoryDumpCapsule capsule);
    public static string DumpMemory(CrashScenario scenario, string dumpDirectory, string dumpFileName, DumpOptions dumpOptions);
    public static string DumpMemory(CrashScenario scenario, Process process, string processName, string dumpDirectory, string dumpFileName, DumpOptions dumpOptions);
    public static string DumpMemory(CrashScenario scenario, Process targetProcess, string targetName, string pathToDebugger, string dumpDirectory, string dumpFileName, DumpOptions dumpOptions);
    public static IDisposable CreateSuppressScope();
    private static void CrashSiteInformationDefaultDecorator(CrashSiteInformation crashSiteInformation, StringBuilder sb);
    private static string CreateCdbPath();
    private static bool ProbePathForDebugger(string path, String& res);
    private static bool CdbExistsInDirectory(string path);
    private static bool SafeDirectoryExists(string directory);
    private static bool SafeFileExists(string file);
    private static string DeterminePathToDebugger(string pathToDebugger);
    private static string DetermineDumpDirectory(string dumpDirectory);
    private static void InvokeWithProcess(Process targetProcess, Action`1<Process> action);
    private static void WaitForCrashEvent(MemoryDumpCapsule memoryDumpCapsule);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperCdbErrorException : MemoryDumperException {
    public int CdbErrorCode;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public MemoryDumperCdbErrorException(string message, Exception innerException);
    protected MemoryDumperCdbErrorException(SerializationInfo info, StreamingContext context);
    public MemoryDumperCdbErrorException(int cdbErrorCode, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperCdbErrorException(int cdbErrorCode, string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperCdbErrorException(int cdbErrorCode, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperCdbErrorException(int cdbErrorCode, string processIdentifier, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperException : Exception {
    public string ProcessIdentifier;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected MemoryDumperException(SerializationInfo info, StreamingContext context);
    public MemoryDumperException(string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperException(string processIdentifier, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperPathDoesNotExistException : MemoryDumperException {
    public string TargetDirectory;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected MemoryDumperPathDoesNotExistException(SerializationInfo info, StreamingContext context);
    public MemoryDumperPathDoesNotExistException(string targetDirectory, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperPathDoesNotExistException(string targetDirectory, string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperPathDoesNotExistException(string targetDirectory, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public MemoryDumperPathDoesNotExistException(string targetDirectory, string processIdentifier, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperProcessCouldNotBeOpenException : MemoryDumperException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public MemoryDumperProcessCouldNotBeOpenException(string message, Exception innerException);
    protected MemoryDumperProcessCouldNotBeOpenException(SerializationInfo info, StreamingContext context);
    public MemoryDumperProcessCouldNotBeOpenException(string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperSuppressedException : MemoryDumperException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public MemoryDumperSuppressedException(string message, Exception innerException);
    protected MemoryDumperSuppressedException(SerializationInfo info, StreamingContext context);
    public MemoryDumperSuppressedException(string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.MemoryDumperWatsonNotSupportedException : MemoryDumperException {
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public MemoryDumperWatsonNotSupportedException(string message, Exception innerException);
    protected MemoryDumperWatsonNotSupportedException(SerializationInfo info, StreamingContext context);
    public MemoryDumperWatsonNotSupportedException(string processIdentifier, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Utils.MemoryStatus : object {
    [CompilerGeneratedAttribute]
private long <TotalPhysicalMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AvailablelPhysicalMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalVirtualMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AvailableVirtualMemory>k__BackingField;
    public long TotalPhysicalMemory { get; private set; }
    public long AvailablelPhysicalMemory { get; private set; }
    public long TotalVirtualMemory { get; private set; }
    public long AvailableVirtualMemory { get; private set; }
    public MemoryStatus(long totalPhysicalMemory, long availablePhysicalMemory, long totalVirtualMemory, long availableVirtualMemory);
    [CompilerGeneratedAttribute]
public long get_TotalPhysicalMemory();
    [CompilerGeneratedAttribute]
private void set_TotalPhysicalMemory(long value);
    [CompilerGeneratedAttribute]
public long get_AvailablelPhysicalMemory();
    [CompilerGeneratedAttribute]
private void set_AvailablelPhysicalMemory(long value);
    [CompilerGeneratedAttribute]
public long get_TotalVirtualMemory();
    [CompilerGeneratedAttribute]
private void set_TotalVirtualMemory(long value);
    [CompilerGeneratedAttribute]
public long get_AvailableVirtualMemory();
    [CompilerGeneratedAttribute]
private void set_AvailableVirtualMemory(long value);
    public string ToTraceString();
}
public class Kusto.Cloud.Platform.Utils.MemPoolStatus : object {
    public string NodeId;
    public string PoolName;
    public string TagName;
    public long FreeSize;
    public long InUseSize;
}
public class Kusto.Cloud.Platform.Utils.MidStringReader : TextReader {
    private string m_string;
    private int m_pos;
    private int m_lpo;
    public MidStringReader(string str, int start, int length);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    private void ReaderClosed(string methodName);
    public virtual int Peek();
    public virtual int Read();
    public int Read(Byte[] buffer, int index, int count, Encoder encoder);
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
}
public class Kusto.Cloud.Platform.Utils.MinBinaryHeap`1 : BinaryHeap`1<T> {
    public MinBinaryHeap`1(Action`2<int, T> notification, IEnumerable`1<T> elements);
    public MinBinaryHeap`1(BinaryHeap`1<T> other, Func`2<IEnumerable`1<T>, IEnumerable`1<T>> modifier);
    protected virtual int Compare(T a, T b);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.MonitoredActivity : object {
    private static Func`1<ConcurrentDictionary`2<string, object>> s_customPropertiesCreator;
    [DataMemberAttribute]
private DateTime m_created;
    [DataMemberAttribute]
private Activity m_activity;
    private IDisposable m_contextDisposer;
    private Lazy`1<ConcurrentDictionary`2<string, object>> m_customProperties;
    public static string TraceSourceId { get; }
    private MonitoredActivity(ActivityType activityType, string clientRequestId);
    private MonitoredActivity(Activity activity, ActivityType activityType);
    private static MonitoredActivity();
    public static string get_TraceSourceId();
    public static IDisposable CreateAndPush(TActivityType activityType, string clientRequestId);
    public static void Invoke(TActivityType activityType, Action action, string clientRequestId);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.MonitoredActivity/<InvokeAsync>d__9`1")]
public static Task InvokeAsync(TActivityType activityType, Func`1<Task> action, string clientRequestId);
    public static TResult Invoke(TActivityType activityType, Func`1<TResult> func, string clientRequestId);
    public static TResult Invoke(TActivityType activityType, Func`2<TArg0, TResult> func, TArg0 arg0, string clientRequestId);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.MonitoredActivity/<InvokeAsync>d__12`2")]
public static Task`1<TResult> InvokeAsync(TActivityType activityType, Func`1<Task`1<TResult>> func, string clientRequestId);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.MonitoredActivity/<InvokeAsync>d__13`3")]
public static Task`1<TResult> InvokeAsync(TActivityType activityType, Func`2<TArg0, Task`1<TResult>> func, TArg0 arg0, string clientRequestId);
    public static void InvokeDetached(TActivityType activityType, Action action, string clientRequestId);
    public static TResult InvokeDetached(TActivityType activityType, Func`1<TResult> func, string clientRequestId);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.MonitoredActivity/<InvokeDetachedAsync>d__16`1")]
public static Task InvokeDetachedAsync(TActivityType activityType, Func`1<Task> func, string clientRequestId);
    public void AddCustomProperty(string name, object value);
    public virtual string ToString();
    public sealed virtual void WriteAsString(ExtendedStringBuilder esb);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    private void Close(Exception ex, ActivityType activityType);
    private void WriteCustomPropertiesAsString(StringBuilder sb);
    private string GetCustomPropertiesString();
}
public class Kusto.Cloud.Platform.Utils.MonitoredLock : object {
    private static Func`2<Action, bool> s_actionInvoker;
    private string m_name;
    private TimeSpan m_alertThreshold;
    private object m_lock;
    private string m_lastActionDescription;
    private long m_currentlyWaiting;
    public string Name { get; }
    public MonitoredLock(string name, TimeSpan alertThreshold);
    private static MonitoredLock();
    public sealed virtual string get_Name();
    public void InvokeUnderLock(string actionDescription, Action action, TimeSpan& timeWaited);
    public void InvokeUnderLock(string actionDescription, Action action);
    public TResult InvokeUnderLock(string actionDescription, Func`1<TResult> func, TimeSpan& timeWaited);
    public TResult InvokeUnderLock(string actionDescription, Func`1<TResult> func);
    public TResult InvokeUnderLock(string actionDescription, Func`2<TInput, TResult> func, TInput input, TimeSpan& timeWaited);
}
public class Kusto.Cloud.Platform.Utils.NameValueDictionary : Dictionary`2<string, string> {
    public NameValueDictionary(int capacity);
    public NameValueDictionary(NameValueDictionary source, int additionalCapacity);
    public void CopyFrom(NameValueDictionary source);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.NamingOptions : Enum {
    public int value__;
    public static NamingOptions None;
    public static NamingOptions Dethrottled;
    public static NamingOptions Uniquified;
    public static NamingOptions All;
}
public static class Kusto.Cloud.Platform.Utils.NativeFile : object {
    public static UInt32 FILE_ATTRIBUTE_NORMAL;
    public static UInt32 FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static UInt32 FILE_SHARE_READ;
    public static UInt32 FILE_SHARE_WRITE;
    public static UInt32 OPEN_EXISTING;
    public static UInt32 PIPE_ACCESS_INBOUND;
    public static UInt32 PIPE_ACCESS_OUTBOUND;
    public static UInt32 PIPE_READMODE_BYTE;
    public static UInt32 PIPE_TYPE_BYTE;
    public static UInt32 PIPE_UNLIMITED_INSTANCES;
    public static UInt32 PIPE_WAIT;
    public static UInt32 GENERIC_READ;
    public static UInt32 GENERIC_WRITE;
    public static SafeFileHandle OpenPipeFile(string name, FileAccess accessMode);
    public static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr attr, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    public static SafeFileHandle CreateNamedPipe(string lpName, UInt32 dwOpenMode, UInt32 dwPipeMode, UInt32 nMaxInstances, int nOutBufferSize, int nInBufferSize, UInt32 nDefaultTimeOut, SecurityAttributes pipeSecurityDescriptor);
}
internal static class Kusto.Cloud.Platform.Utils.NativeMethods : object {
    public static int STD_OUTPUT_HANDLE;
    public static int STD_INPUT_HANDLE;
    public static int STD_ERROR_HANDLE;
    public static IntPtr INVALID_HANDLE_VALUE;
    public static UInt32 ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    private static NativeMethods();
    public static bool GetConsoleMode(IntPtr hConsoleHandle, UInt32& lpMode);
    public static bool SetConsoleMode(IntPtr hConsoleHandle, UInt32 dwMode);
    public static bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO& ConsoleScreenBufferInfo);
    public static bool ScrollConsoleScreenBuffer(IntPtr hConsoleOutput, SMALL_RECT& lpScrollRectangle, IntPtr lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO& lpFill);
    public static bool SetConsoleCursorPosition(IntPtr hConsoleOutput, COORD dwCursorPosition);
    public static IntPtr GetStdHandle(int nStdHandle);
}
public static class Kusto.Cloud.Platform.Utils.NativeProcess : object {
    public static int DefaultRedirectionBufferSize;
    public static UInt32 NMPWAIT_WAIT_FOREVER;
    public static int CREATE_SUSPENDED;
    public static int CREATE_NO_WINDOW;
    public static int CREATE_UNICODE_ENVIRONMENT;
    public static int THREAD_SUSPEND_RESUME;
    public static int STD_INPUT_HANDLE;
    public static int STD_OUTPUT_HANDLE;
    public static int STD_ERROR_HANDLE;
    public static int STARTF_USESTDHANDLES;
    public static bool TryResumeThread(int threadId);
    [SuppressUnmanagedCodeSecurityAttribute]
public static bool CloseHandle(IntPtr hObject);
    [SuppressUnmanagedCodeSecurityAttribute]
public static bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, IntPtr& lpTargetHandle, UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwOptions);
    public static IntPtr GetStdHandle(int whichHandle);
    public static bool CreateProcessAsUser(SafeProcessHandle hToken, string lpApplicationName, StringBuilder lpCommandLine, SecurityAttributes lpProcessAttributes, SecurityAttributes lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, StartupInfo lpStartupInfo, ProcessInformation lpProcessInformation);
    public static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, SecurityAttributes lpProcessAttributes, SecurityAttributes lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, StartupInfo lpStartupInfo, ProcessInformation lpProcessInformation);
    [SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetCurrentProcess();
    [SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr OpenThread(int desiredAccess, bool inheritHandle, int threadId);
    [SuppressUnmanagedCodeSecurityAttribute]
public static int ResumeThread(IntPtr hThread);
    [SuppressUnmanagedCodeSecurityAttribute]
public static bool TerminateProcess(IntPtr hProcess, UInt32 uExitCode);
}
public static class Kusto.Cloud.Platform.Utils.NativeThread : object {
    private static IntPtr s_hUnavailable;
    private static IntPtr s_hCurrentThread;
    private static bool s_getSetThreadDescriptionFunctional;
    private static NativeThread();
    public static IDisposable TemporarilySetThreadDescription(string threadDescription);
    public static void SetThreadDescription(string threadDescription);
    public static string GetThreadDescription();
    private static bool IsHresultSucceeded(int hr);
    private static bool TestGetSetThreadDescription();
    private static IntPtr GetCurrentThread();
}
public class Kusto.Cloud.Platform.Utils.NetworkCache`3 : object {
    public static int NoLimitOnFollowers;
    public static int c_maxNumOfKeysToTrace;
    private string m_name;
    private INetworkCacheValueFactory`3<TKey, TGetContext, TValue> m_factory;
    private string m_tracePrefix;
    private NetworkCacheFetchActivityType<TKey, TGetContext, TValue> m_fetchActivityType;
    private NetworkCacheTimerActivityType<TKey, TGetContext, TValue> m_timerActivityType;
    private int m_maxNumFollowers;
    private int m_numFollowersToWarnOn;
    private DateTime m_creationTime;
    private IEqualityComparer`1<TKey> m_comparer;
    private TimeSpan m_timeout;
    private ConcurrentDictionary`2<TKey, NetworkCacheEntry`3<TKey, TGetContext, TValue>> m_cache;
    private ReaderWriterLockSlim modreq(System.Runtime.CompilerServices.IsVolatile) m_cacheRwLock;
    private ConcurrentDictionary`2<TKey, FetchContext<TKey, TGetContext, TValue>> m_fetching;
    protected AbstractConsumerPool`1<ValueTuple`2<TKey, TGetContext>> m_refreshConsumerPool;
    private NetworkCacheEvictionRefreshPolicy m_evictionRefreshPolicy;
    private Timer m_evictionRefreshTimer;
    private object m_evictionPolicyLock;
    protected int m_evictionRefreshTimerExecuting;
    private bool m_disposed;
    public string Name { get; }
    public NetworkCache`3(string name, INetworkCacheValueFactory`3<TKey, TGetContext, TValue> factory, int maxNumFollowers, IEqualityComparer`1<TKey> comparer, int numFollowersToWarnOn);
    public void SetCacheEntryCreationTimeout(TimeSpan timeout);
    public void SetEvictionRefreshPolicy(NetworkCacheEvictionRefreshPolicy policy);
    public sealed virtual string get_Name();
    public void ForEach(Action`1<KeyValuePair`2<TKey, TValue>> action);
    public bool SetIfLater(TKey key, TGetContext getContext, DateTime now, TValue value);
    public bool TryRemoveCacheEntry(TKey key);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetCacheEntryAsync>d__31")]
public Task`1<NetworkCacheEntry`3<TKey, TGetContext, TValue>> GetCacheEntryAsync(TKey key, TGetContext getContext, bool forceRefetch);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetCacheEntriesAsync>d__32")]
public Task`1<IEnumerable`1<NetworkCacheEntry`3<TKey, TGetContext, TValue>>> GetCacheEntriesAsync(IEnumerable`1<TKey> keys, TGetContext getContext, bool forceRefetch);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetAsync>d__33")]
public Task`1<TValue> GetAsync(TKey key, TGetContext getContext, bool forceRefetch);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetAsync>d__34")]
public Task`1<IEnumerable`1<KeyValuePair`2<TKey, TValue>>> GetAsync(IEnumerable`1<TKey> keys, TGetContext getContext, bool forceRefetch);
    protected void ApplyEvictionRefreshPolicy(NetworkCacheEvictionRefreshPolicy policy, DateTime now);
    private AbstractConsumerPool`1<ValueTuple`2<TKey, TGetContext>> CreateRefreshConsumerPool(bool isBatchSupported, string name, IEqualityComparer`1<TKey> keyComparer);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetCacheEntryAsync>d__37")]
protected Task`1<NetworkCacheEntry`3<TKey, TGetContext, TValue>> GetCacheEntryAsync(TKey key, TGetContext getContext, bool forceRefetch, bool triggeredByTimer, bool forceRefetchSecondEvaluation);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.NetworkCache`3/<GetCacheEntriesAsync>d__38")]
protected Task`1<IEnumerable`1<NetworkCacheEntry`3<TKey, TGetContext, TValue>>> GetCacheEntriesAsync(IEnumerable`1<TKey> keys, TGetContext getContext, bool forceRefetch, bool triggeredByTimer, bool forceRefetchSecondEvaluation);
    private NetworkCacheEntry`3<TKey, TGetContext, TValue> TryGetUnderLock(TKey key, TGetContext getContext, DateTime now);
    private void OnEvictionRefreshTimer(object state);
    private void OnEvictionRefreshTimerImpl();
    private static string SafeGetActivityAsString(FetchContext<TKey, TGetContext, TValue> fetchContext);
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <SetEvictionRefreshPolicy>b__25_0();
}
public class Kusto.Cloud.Platform.Utils.NetworkCacheEntry`3 : object {
    private TKey m_key;
    private TGetContext m_getContext;
    private DateTime m_lastUpdated;
    private DateTime m_lastRead;
    private TValue m_value;
    public TKey Key { get; }
    public TGetContext GetContext { get; }
    public DateTime LastUpdated { get; }
    public DateTime LastRead { get; public set; }
    public TValue Value { get; }
    public NetworkCacheEntry`3(TKey key, TGetContext getContext, DateTime lastUpdated, DateTime lastRead, TValue value);
    public TKey get_Key();
    public TGetContext get_GetContext();
    public DateTime get_LastUpdated();
    public DateTime get_LastRead();
    public void set_LastRead(DateTime value);
    public TValue get_Value();
}
public class Kusto.Cloud.Platform.Utils.NetworkCacheEvictionRefreshPolicy : object {
    private static int c_pollingFrequency;
    private static TimeSpan s_maxPollingPeriod;
    private TimeSpan m_evictAfter;
    private TimeSpan m_refreshOnAverageAfter;
    private TimeSpan m_startRefreshingAfter;
    private TimeSpan m_pollingPeriod;
    public TimeSpan StartRefreshingAfter { get; }
    public TimeSpan PollingPeriod { get; }
    public NetworkCacheEvictionRefreshPolicy(TimeSpan evictAfter, TimeSpan refreshAfter);
    private NetworkCacheEvictionRefreshPolicy(TimeSpan evictAfter, TimeSpan refreshOnAverageAfter, TimeSpan startRefreshingAfter);
    private static NetworkCacheEvictionRefreshPolicy();
    public TimeSpan get_StartRefreshingAfter();
    public TimeSpan get_PollingPeriod();
    public virtual string ToString();
    public bool ShouldEvict(NetworkCacheEntry`3<TKey, TGetContext, TValue> cacheEntry, DateTime now);
    public bool ShouldRefresh(NetworkCacheEntry`3<TKey, TGetContext, TValue> cacheEntry, DateTime now);
    public NetworkCacheEvictionRefreshPolicy Clone();
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.NetworkCacheFailedOnAnotherThreadRedirectException : UtilsException {
    public string Reason;
    public string CacheKey;
    public string FetchActivity;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public NetworkCacheFailedOnAnotherThreadRedirectException(string message, Exception innerException);
    protected NetworkCacheFailedOnAnotherThreadRedirectException(SerializationInfo info, StreamingContext context);
    public NetworkCacheFailedOnAnotherThreadRedirectException(string reason, string cacheKey, string fetchActivity, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NetworkCacheFailedOnAnotherThreadRedirectException(string reason, string cacheKey, string fetchActivity, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NetworkCacheFailedOnAnotherThreadRedirectException(string reason, string cacheKey, string fetchActivity, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NetworkCacheFailedOnAnotherThreadRedirectException(string reason, string cacheKey, string fetchActivity, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public virtual string ToString();
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Kusto.Cloud.Platform.Utils.NetworkCachePrivateTracer : TraceSourceBase`1<NetworkCachePrivateTracer> {
    public TraceVerbosity DefaultVerbosity { get; }
    public string Id { get; }
    public virtual TraceVerbosity get_DefaultVerbosity();
    public virtual string get_Id();
}
public class Kusto.Cloud.Platform.Utils.NetworkThrottle`2 : object {
    private string m_name;
    private Func`2<TRequest, Task`1<TResponse>> m_func;
    private int m_maxConcurrentExecuting;
    private TimeSpan m_abandonTimespan;
    private object m_lock;
    private Queue`1<PendingRequest<TRequest, TResponse>> m_pending;
    private int m_executing;
    public NetworkThrottle`2(string name, Func`2<TRequest, Task`1<TResponse>> func, int maxConcurrentExecuting, TimeSpan abandonTimespan);
    public Task`1<TResponse> ExecuteAsync(TRequest request);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.NotEligibleToAcquireLockException : UtilsException {
    public string DlockName;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected NotEligibleToAcquireLockException(SerializationInfo info, StreamingContext context);
    public NotEligibleToAcquireLockException(string dlockName, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NotEligibleToAcquireLockException(string dlockName, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NotEligibleToAcquireLockException(string dlockName, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public NotEligibleToAcquireLockException(string dlockName, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Kusto.Cloud.Platform.Utils.ObjectDumper : object {
    private static HashSet`1<Type> s_justUseToStringTypes;
    private static ObjectDumper();
    public static string Dump(object what);
    public static void Dump(object what, ExtendedStringBuilder esb);
    public static string Dump(object what, int recursionLevel);
    public static void Dump(string name, object what, ExtendedStringBuilder esb, object context);
    private static void Dump(string name, object what, ExtendedStringBuilder esb, ObjectDumperContext context, int recursionLevel);
    private static bool JustUseToString(object what);
    private static bool PrintObjectIdentity(object what);
    private static bool JustIgnore(string name, object what);
}
[AttributeUsageAttribute("384")]
public class Kusto.Cloud.Platform.Utils.ObjectDumperIgnoreAttribute : Attribute {
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.ObjectHashCode : object {
    [ExtensionAttribute]
public static int SafeGetHashCode(T obj);
    [ExtensionAttribute]
public static int GetStableHashCode(string str);
    [ExtensionAttribute]
public static int GetDeterministicHashCode(string str);
    [ExtensionAttribute]
public static int GetStableHashCode(Guid guid);
    public static int Combine(T1 obj0, T2 obj1);
    public static int Combine(T1 obj0, T2 obj1, T3 obj2);
    public static int Combine(int hash0, int hash1);
    public static int Combine(int hash0, int hash1, int hash2);
    public static int Combine(int hash0, int hash1, int hash2, int hash3);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7, int hash8);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7, int hash8, int hash9);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7, int hash8, int hash9, int hash10);
    public static int Combine(int hash0, int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7, int hash8, int hash9, int hash10, int hash11);
    public static int Combine(IEnumerable`1<T> values);
    public static int CombineValues(IEnumerable`1<T> values);
    public static long CombineHashValuesInt64(IEnumerable`1<long> values);
    public static int Combine(IEnumerable`1<int> values);
    public static void Merge(Int32& existingHash, int newHash);
    public static void Merge(Int32& existingHash, Byte* d, int len);
    public static void Merge(Int32& existingHash, Byte[] d);
    public static int GetHashCodeFromMerge(int hash);
    private static void MergeInt64(Int64& existingHash, long newHash);
    private static void MergeInt64(Int64& existingHash, Byte* d, int len);
    private static void MergeInt64(Int64& existingHash, Byte[] d);
    private static long GetHashCodeFromMergeInt64(long hash);
}
public static class Kusto.Cloud.Platform.Utils.ObjectNavigator : object {
    private static BindingFlags c_bindingFlags;
    public static ValueTuple`2<bool, IEnumerable`1<KeyValuePair`2<object, object>>> WalkKeyValueEnumerable(object source, string key, string value);
    public static ValueTuple`2<bool, object> Walk(object source, string path);
}
public class Kusto.Cloud.Platform.Utils.ObjectPool`2 : object {
    private LinkedList`1<ObjectPoolItem<TKey, TValue>> m_objectList;
    private Dictionary`2<TKey, LinkedList`1<LinkedListNode`1<ObjectPoolItem<TKey, TValue>>>> m_fastLookupDictionary;
    private int m_maxSize;
    private ObjectPoolRemovalPolicy m_poolPolicy;
    private Action`2<TKey, TValue> m_onEviction;
    private Thinner m_maxSizeAlertThinner;
    public IEnumerable`1<TValue> Values { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TValue>> Items { get; }
    public int Count { get; }
    public ObjectPool`2(int maxSize, ObjectPoolRemovalPolicy poolPolicy);
    public ObjectPool`2(int maxSize, ObjectPoolRemovalPolicy poolPolicy, Action`2<TKey, TValue> onEviction);
    public ObjectPool`2(int maxSize, ObjectPoolRemovalPolicy poolPolicy, Action`2<TKey, TValue> onEviction, IEqualityComparer`1<TKey> comparator);
    public sealed virtual void Add(TKey key, TValue obj);
    public sealed virtual List`1<KeyValuePair`2<TKey, TValue>> RemoveMatching(Func`3<TKey, TValue, bool> predicate);
    public sealed virtual bool TryTouchMatching(TKey key, Func`2<TValue, bool> predicate, TValue& obj);
    public sealed virtual bool TryRemove(TKey key, TValue& obj);
    public sealed virtual bool TryTouch(TKey key, TValue& obj);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ObjectPool`2/<get_Values>d__15")]
public sealed virtual IEnumerable`1<TValue> get_Values();
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.ObjectPool`2/<get_Items>d__17")]
public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TValue>> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TValue> RemoveKey(TKey key);
    public string DumpForDebugging();
    private void AlertOnEviction();
}
public enum Kusto.Cloud.Platform.Utils.ObjectPoolRemovalPolicy : Enum {
    public int value__;
    public static ObjectPoolRemovalPolicy PreferMostRecentlyUsed;
    public static ObjectPoolRemovalPolicy PreferLeastRecentlyUsed;
}
public enum Kusto.Cloud.Platform.Utils.OneLakeAccessType : Enum {
    public int value__;
    public static OneLakeAccessType OneLakeService;
    public static OneLakeAccessType OneLakeClient;
}
public class Kusto.Cloud.Platform.Utils.OneOrNone`1 : OneOrNoneBase {
    private AlertDebuggerBehavior m_alertDebuggerBehaviorOnFailures;
    private EnvironmentCharacteristics m_deactivateWhen;
    private ITraceSource m_tracer;
    private Func`2<T, string> m_instanceToString;
    private T m_instance;
    private StackTrace m_instanceCreationCallStack;
    public OneOrNone`1(AlertDebuggerBehavior alertDebuggerBehaviorOnFailures, ITraceSource tracer, Func`2<T, string> instanceToString, EnvironmentCharacteristics deactivateWhen);
    public void Add(T instance);
    public void Remove(T instance);
}
public class Kusto.Cloud.Platform.Utils.OneOrNoneBase : object {
    protected static EnvironmentCharacteristics m_environmentCharacteristics;
    public static EnvironmentCharacteristics AddCharacteristics(EnvironmentCharacteristics characteristic);
    public static EnvironmentCharacteristics SetCharacteristics(EnvironmentCharacteristics characteristics);
}
public class Kusto.Cloud.Platform.Utils.OnStreamDispose : MulticastDelegate {
    public OnStreamDispose(object object, IntPtr method);
    public virtual void Invoke(long bytesRead, long BytesWritten);
    public virtual IAsyncResult BeginInvoke(long bytesRead, long BytesWritten, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Kusto.Cloud.Platform.Utils.OnStreamRead : MulticastDelegate {
    public OnStreamRead(object object, IntPtr method);
    public virtual void Invoke(long bytesRead);
    public virtual IAsyncResult BeginInvoke(long bytesRead, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Kusto.Cloud.Platform.Utils.OnStreamWrite : MulticastDelegate {
    public OnStreamWrite(object object, IntPtr method);
    public virtual void Invoke(long bytesWritted);
    public virtual IAsyncResult BeginInvoke(long bytesWritted, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.OperationThrottledException : UtilsException {
    public string Operation;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected OperationThrottledException(SerializationInfo info, StreamingContext context);
    public OperationThrottledException(string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public OperationThrottledException(string operation, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public OperationThrottledException(string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public OperationThrottledException(string operation, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum Kusto.Cloud.Platform.Utils.ParquetCompressionType : Enum {
    public int value__;
    public static ParquetCompressionType Uncompressed;
    public static ParquetCompressionType Snappy;
    public static ParquetCompressionType Gzip;
    public static ParquetCompressionType Lzo;
    public static ParquetCompressionType Brotli;
    public static ParquetCompressionType Lz4;
    public static ParquetCompressionType Zstd;
    public static ParquetCompressionType Lz4_Raw;
}
public class Kusto.Cloud.Platform.Utils.ParsedUri : object {
    public string Scheme;
    public string Hostname;
    public int Port;
    public string Path;
    public string Query;
    public string Fragment;
    public string UserInfo;
}
public class Kusto.Cloud.Platform.Utils.PeriodicFlushingTextWriter : TextWriter {
    private object m_lock;
    private TextWriter m_inner;
    private PeriodicNonoverlappingTimer m_timer;
    public Encoding Encoding { get; }
    public PeriodicFlushingTextWriter(TextWriter inner, TimeSpan flushPeriod);
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual void Flush();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    private void OnTimer(PeriodicNonoverlappingTimer timer, object context);
}
public class Kusto.Cloud.Platform.Utils.PeriodicNonoverlappingTimer : object {
    private static int InvalidManagedThreadId;
    private string m_name;
    private string m_asThreadName;
    private TimeSpan m_period;
    private Action`2<PeriodicNonoverlappingTimer, object> m_onTick;
    private object m_context;
    private ActivityType m_activityType;
    private bool m_autoRunWhenElapsePeriod;
    private object m_lock;
    private int m_runningManagedThreadId;
    private DateTime m_lastTicked;
    private Context m_runningContext;
    private Timer m_timer;
    public PeriodicNonoverlappingTimer(string name, TimeSpan period, Action`2<PeriodicNonoverlappingTimer, object> onTick, object context, ActivityType activityType, bool firstExecutionImmediately, bool autoRunWhenElapsePeriod);
    public PeriodicNonoverlappingTimer(string name, TimeSpan period, Action`2<PeriodicNonoverlappingTimer, object> onTick, object context, TimeSpan firstExecution, ActivityType activityType, bool autoRunWhenElapsePeriod);
    public sealed virtual void Dispose();
    public void Dispose(bool waitForCallbackToCompleteExecution);
    public void TriggerTimerCallback(object context, bool skipIfAlreadyRunning);
    public bool SetNextTimerCallbackExecution(TimeSpan dueTime);
    private void OnTimerCallback(object context);
    private void OnTimerCallbackImpl(object context, bool skipIfAlreadyRunning);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.PlatformExceptionDetail : object {
    [DataMemberAttribute]
public Dictionary`2<string, string> Data;
    [DataMemberAttribute]
public string HelpLink;
    [DataMemberAttribute]
public PlatformExceptionDetail InnerException;
    [DataMemberAttribute]
public string Message;
    [DataMemberAttribute]
public string StackTrace;
    [DataMemberAttribute]
public string Type;
    [DataMemberAttribute]
public int FailureCode;
    [DataMemberAttribute]
public string FailureSubCode;
    [DataMemberAttribute]
public bool IsPermanent;
    [DataMemberAttribute]
public CreationContext CreationContext;
    [DataMemberAttribute]
public string AsString;
    public Exception LocalExceptionIfAvailable;
    private PlatformExceptionDetail(Exception ex, PlatformExceptionDetailLevel detailsLevel);
    public static PlatformExceptionDetail FromException(Exception ex, PlatformExceptionDetailLevel detailsLevel);
    public bool IsMatch(Type exceptionType);
    public bool IsMatch(string exceptionType);
    public virtual string ToString();
    public static PlatformExceptionDetail FromJsonString(string ped);
    public string ToJsonString();
    public static void GetExceptionEssentials(Exception ex, Int32& failureCode, String& message);
    private static Exception ExtractFromAggregateExceptionIfNeeded(Exception ex);
    private static bool TryExtractICloudPlatformException(Exception ex, ICloudPlatformException& asPlatformException, Exception& firstNonAggregateException);
}
public enum Kusto.Cloud.Platform.Utils.PlatformExceptionDetailLevel : Enum {
    public int value__;
    public static PlatformExceptionDetailLevel Full;
    public static PlatformExceptionDetailLevel Slim;
    public static PlatformExceptionDetailLevel ExtraSlim;
}
public enum Kusto.Cloud.Platform.Utils.ProcessWellKnownHost : Enum {
    public int value__;
    public static ProcessWellKnownHost None;
    public static ProcessWellKnownHost MSTest;
    public static ProcessWellKnownHost WebDev;
    public static ProcessWellKnownHost AzureWorker;
    public static ProcessWellKnownHost AzureWeb;
    public static ProcessWellKnownHost UIAF;
    public static ProcessWellKnownHost IIS;
    public static ProcessWellKnownHost DotNet;
}
public class Kusto.Cloud.Platform.Utils.ProtectedValue`1 : object {
    private object m_lock;
    private T m_value;
    public T Get();
    public T Set(T value);
}
[DefaultMemberAttribute("Item")]
public class Kusto.Cloud.Platform.Utils.QuasistaticConcurrentDictionary`2 : object {
    private object m_lock;
    private Dictionary`2<TKey, TValue> m_dict;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public void BulkReadModifyWrite(Action`1<Dictionary`2<TKey, TValue>> modifier);
    public void BulkRead(Action`1<Dictionary`2<TKey, TValue>> reader);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private Dictionary`2<TKey, TValue> CloneUnderLock();
}
public class Kusto.Cloud.Platform.Utils.QueuedTaskRunner : object {
    private string m_name;
    private object m_lock;
    private Dictionary`2<string, QueuedTaskScheduler> m_queueTaskSchedulers;
    private Dictionary`2<string, int> m_maxConcurrencyPolicy;
    public QueuedTaskRunner(string name);
    public void SetMaxConcurrencyLevel(string queueIdPrefix, int priority, int maxConcurrencyLevel);
    public Task StartNew(string queueId, int priority, QueuedTaskRunnerOptions options, Action func);
}
[DebuggerTypeProxyAttribute("Kusto.Cloud.Platform.Utils.QueuedTaskScheduler/QueuedTaskSchedulerDebugView")]
[DebuggerDisplayAttribute("Id={Id}, Queues={DebugQueueCount}, ScheduledTasks = {DebugTaskCount}")]
public class Kusto.Cloud.Platform.Utils.QueuedTaskScheduler : TaskScheduler {
    private SortedList`2<int, QueueGroup> _queueGroups;
    private CancellationTokenSource _disposeCancellation;
    private int _concurrencyLevel;
    private static ThreadLocal`1<bool> _taskProcessingThread;
    private TaskScheduler _targetScheduler;
    private Queue`1<Task> _nonthreadsafeTaskQueue;
    private int _delegatesQueuedOrRunning;
    private Thread[] _threads;
    private BlockingCollection`1<Task> _blockingTaskQueue;
    public int MaximumConcurrencyLevel { get; }
    private int DebugQueueCount { get; }
    private int DebugTaskCount { get; }
    public QueuedTaskScheduler(TaskScheduler targetScheduler);
    public QueuedTaskScheduler(TaskScheduler targetScheduler, int maxConcurrencyLevel);
    public QueuedTaskScheduler(int threadCount);
    public QueuedTaskScheduler(int threadCount, string threadName, bool useForegroundThreads, ThreadPriority threadPriority, ApartmentState threadApartmentState, int threadMaxStackSize, Action threadInit, Action threadFinally);
    private static QueuedTaskScheduler();
    public sealed virtual void Dispose();
    public TaskScheduler ActivateNewQueue();
    public TaskScheduler ActivateNewQueue(int priority);
    public TaskScheduler ActivateNewOrGetExistingQueue(int priority);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    private void ThreadBasedDispatchLoop(Action threadInit, Action threadFinally);
    private int get_DebugQueueCount();
    private int get_DebugTaskCount();
    private void FindNextTask_NeedsLock(Task& targetTask, QueuedTaskSchedulerQueue& queueForTargetTask);
    private void ProcessPrioritizedAndBatchedTasks();
    private void NotifyNewWorkItem();
    private void RemoveQueue_NeedsLock(QueuedTaskSchedulerQueue queue);
}
internal class Kusto.Cloud.Platform.Utils.QueuedTaskSchedulerTracer : TraceSourceBase`1<QueuedTaskSchedulerTracer> {
    public TraceVerbosity DefaultVerbosity { get; }
    public string Id { get; }
    public virtual TraceVerbosity get_DefaultVerbosity();
    public virtual string get_Id();
}
public static class Kusto.Cloud.Platform.Utils.RangeExtractor : object {
    public static string ConsolidateSequencesToRanges(IList`1<long> numbers, string rangeSeparator, string elementsSeparator);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.ResourceSnapshot`1 : object {
    [CompilerGeneratedAttribute]
private TResourceKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Remaining>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceSnapshotScope <Scope>k__BackingField;
    [DataMemberAttribute]
public TResourceKind Kind { get; public set; }
    [DataMemberAttribute]
public long Capacity { get; public set; }
    [DataMemberAttribute]
public long Remaining { get; public set; }
    [DataMemberAttribute]
public long Consumed { get; public set; }
    [DataMemberAttribute]
public ResourceSnapshotScope Scope { get; public set; }
    [CompilerGeneratedAttribute]
public TResourceKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(TResourceKind value);
    [CompilerGeneratedAttribute]
public long get_Capacity();
    [CompilerGeneratedAttribute]
public void set_Capacity(long value);
    [CompilerGeneratedAttribute]
public long get_Remaining();
    [CompilerGeneratedAttribute]
public void set_Remaining(long value);
    [CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
public void set_Consumed(long value);
    [CompilerGeneratedAttribute]
public ResourceSnapshotScope get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(ResourceSnapshotScope value);
    public bool IsInUse();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResourceSnapshot`1<TResourceKind> other);
    public virtual int GetHashCode();
}
[DataContractAttribute]
public enum Kusto.Cloud.Platform.Utils.ResourceSnapshotScope : Enum {
    public int value__;
    [EnumMemberAttribute]
public static ResourceSnapshotScope WorkloadGroup;
    [EnumMemberAttribute]
public static ResourceSnapshotScope Principal;
    [EnumMemberAttribute]
public static ResourceSnapshotScope TrackedResource;
    [EnumMemberAttribute]
public static ResourceSnapshotScope ControlCommand;
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.ResourcesUtilization : object {
    [JsonPropertyAttribute("TotalCpu")]
[DataMemberAttribute]
private TimeSpan m_totalCpu;
    [JsonPropertyAttribute("UserCpu")]
[DataMemberAttribute]
private TimeSpan m_userCpu;
    [JsonPropertyAttribute("KernelCpu")]
[DataMemberAttribute]
private TimeSpan m_kernelCpu;
    [JsonPropertyAttribute("MemoryPeak")]
[DataMemberAttribute]
private long m_memoryPeak;
    [JsonPropertyAttribute("TotalProcesses")]
[DataMemberAttribute]
private int m_totalProcesses;
    [JsonIgnoreAttribute]
public TimeSpan TotalCpu { get; }
    [JsonIgnoreAttribute]
public TimeSpan UserCpu { get; }
    [JsonIgnoreAttribute]
public TimeSpan KernelCpu { get; }
    [JsonIgnoreAttribute]
public long MemoryPeak { get; }
    [JsonIgnoreAttribute]
public int TotalProcesses { get; }
    public ResourcesUtilization(TimeSpan totalCpu, TimeSpan userCpu, TimeSpan kernelCpu, long memoryPeak, int totalProcesses);
    public ResourcesUtilization(ResourcesUtilization other);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    public ResourcesUtilization NewSetTotalCpu(TimeSpan totalCpu);
    public ResourcesUtilization NewSetUserCpu(TimeSpan userCpu);
    public ResourcesUtilization NewSetKernelCpu(TimeSpan kernelCpu);
    public ResourcesUtilization NewSetMemoryPeak(long memoryPeak);
    public ResourcesUtilization NewSetTotalProcesses(int totalProcesses);
    public TimeSpan get_TotalCpu();
    public TimeSpan get_UserCpu();
    public TimeSpan get_KernelCpu();
    public long get_MemoryPeak();
    public int get_TotalProcesses();
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.ResourceUtilizationMeasure : object {
    [DataMemberAttribute]
private string m_resourceKind;
    [DataMemberAttribute]
private string m_resourceId;
    [DataMemberAttribute]
private double m_currentUtilization;
    [DataMemberAttribute]
private double m_maxUtilization;
    [DataMemberAttribute]
private DateTime m_whenMeasured;
    [DataMemberAttribute]
private double m_percentUtilized;
    public string ResourceKind { get; }
    public string ResourceId { get; }
    public double CurrentUtilization { get; }
    public double MaxUtilization { get; }
    public DateTime WhenMeasured { get; }
    public double PercentUtilized { get; }
    public ResourceUtilizationMeasure(string resourceKind, string resourceId, double currentUtilization, double maxUtilization, Nullable`1<DateTime> whenMeasured);
    public ResourceUtilizationMeasure(string resourceKind, string resourceId, double currentUtilization, Nullable`1<DateTime> whenMeasured);
    [JsonConstructorAttribute]
public ResourceUtilizationMeasure(string resourceKind, string resourceId, double currentUtilization, double maxUtilization, DateTime whenMeasured, double percentUtilized);
    public virtual string ToString();
    public string get_ResourceKind();
    public string get_ResourceId();
    public double get_CurrentUtilization();
    public double get_MaxUtilization();
    public DateTime get_WhenMeasured();
    public double get_PercentUtilized();
}
public class Kusto.Cloud.Platform.Utils.ResourceUtilizationMeasures : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResourceUtilizationMeasure> <ResourcesUtilizationMeasures>k__BackingField;
    public IEnumerable`1<ResourceUtilizationMeasure> ResourcesUtilizationMeasures { get; }
    public ResourceUtilizationMeasures(IEnumerable`1<ResourceUtilizationMeasure> resourcesUtilizationMeasures);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ResourceUtilizationMeasure> get_ResourcesUtilizationMeasures();
    public virtual string ToString();
}
public static class Kusto.Cloud.Platform.Utils.RetryOperation : object {
    public static TReturn Retry(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<TReturn> func, Action onFailAction, Func`2<Exception, bool> shouldRetry, bool retryOnPermanentException);
    public static TReturn Retry(int maxNumberOfTries, Func`2<int, TimeSpan> waitIntervalFuncByRetryNum, string description, Func`1<TReturn> func, Action onFailAction, Func`2<Exception, bool> shouldRetry, bool retryOnPermanentException);
    public static TReturn Retry(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<TReturn> func, Func`2<TReturn, bool> shouldRetry, Action onFailAction);
    public static TReturn Retry(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<TReturn> func, Func`3<TReturn, TException, bool> shouldRetry, Action onFailAction);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__4`2")]
public static Task`1<TReturn> RetryAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<Task`1<TReturn>> func, Action onFailAction, CancellationToken cancellationToken, bool retryOnPermanentException);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__5`1")]
public static Task`1<TReturn> RetryAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<Task`1<TReturn>> func, Func`2<TReturn, bool> shouldRetry, Action onFailAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__6`1")]
public static Task`1<TReturn> RetryAsync(int maxNumberOfTries, Func`2<TReturn, TimeSpan> waitIntervalFunc, string description, Func`1<Task`1<TReturn>> func, Func`2<TReturn, bool> shouldRetry, Action onFailAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryCheckExceptionAsync>d__7`1")]
public static Task`1<TReturn> RetryCheckExceptionAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<Task`1<TReturn>> func, Func`2<Exception, bool> shouldRetry, Action onFailAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__8`2")]
public static Task`1<TReturn> RetryAsync(int maxNumberOfTries, Func`2<int, TimeSpan> waitIntervalFuncByRetryNum, string description, Func`1<Task`1<TReturn>> func, Func`3<TException, int, bool> shouldRetry, Action onFailAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__9`1")]
public static Task RetryAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Func`1<Task> func, Action onFailAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__10`1")]
public static Task RetryAsync(int maxNumberOfTries, Func`2<int, TimeSpan> waitIntervalFuncByRetryNum, string description, Func`1<Task> func, Action onFailAction, bool retryOnPermanentException, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<RetryAsync>d__11`1")]
public static Task RetryAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Action action, Action onFailAction, bool retryOnPermanentException, CancellationToken cancellationToken);
    public static void Retry(int maxNumberOfTries, TimeSpan waitInterval, string description, Action action, Action onFailAction, Func`2<Exception, bool> shouldRetry);
    public static void Retry(int maxNumberOfTries, Func`2<int, TimeSpan> waitIntervalFuncByRetryNum, string description, Action action, Action onFailAction, Func`2<Exception, bool> shouldRetry);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.RetryOperation/<HandleExceptionWithRetriesAsync>d__14")]
private static Task HandleExceptionWithRetriesAsync(int maxNumberOfTries, TimeSpan waitInterval, string description, Action onFailAction, int i, ExceptionDispatchInfo edi, CancellationToken cancellationToken, bool retryOnPermanentException);
    private static void HandleExceptionWithRetries(int maxNumberOfTries, TimeSpan waitInterval, string description, Action onFailAction, int i, ExceptionDispatchInfo edi, Func`2<Exception, bool> shouldRetry, bool retryOnPermanentException);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.ReturnKey : object {
    [CompilerGeneratedAttribute]
private Guid <BucketGuid>k__BackingField;
    [DataMemberAttribute]
public Guid BucketGuid { get; private set; }
    public ReturnKey(Guid bucketGuid);
    [CompilerGeneratedAttribute]
public Guid get_BucketGuid();
    [CompilerGeneratedAttribute]
private void set_BucketGuid(Guid value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Kusto.Cloud.Platform.Utils.RollingCsvTraceListener2 : TraceListener {
    protected static int c_maxFieldSize;
    public static string EnableEmergencyTracer_TweakName;
    public static string ConfidentialTracesDirectorySuffix;
    protected IEmergencyTracer m_tracer;
    private string m_fileNamePrefix;
    private int m_numRollingWriteStreams;
    private RollingWriteStream[] m_rollingWriteStreams;
    private string m_preformattedPrefixPredicate;
    private string m_serviceAlias;
    private TriState m_confidential;
    private bool m_crashOnMinExpectedBytesPerRolloverSignaled;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    public bool CrashOnMinExpectedBytesPerRolloverSignaled { get; public set; }
    public string ServiceAlias { get; public set; }
    public string MachineName { get; public set; }
    public int ProcessId { get; public set; }
    unknown TimeSpan RolloverPeriod {public set; }
    public string TargetFolder { get; private set; }
    public TriState IsConfidential { get; private set; }
    public bool IsThreadSafe { get; }
    public RollingCsvTraceListener2(string logsFolder);
    public RollingCsvTraceListener2(string logsFolder, string fileNamePrefix);
    public RollingCsvTraceListener2(string logsFolder, Action`1<RollingCsvTraceListener2> preConstruct);
    public RollingCsvTraceListener2(string logsFolder, string traceListenerName, bool scanFolderForPreviousTraces, bool parallelizeWriters, Action`1<RollingCsvTraceListener2> preConstruct, string fileNamePrefix);
    protected virtual RollingWriteStream CreateRollingWriteStream(int rws);
    protected virtual IRollingWriteStreamPolicy CreateRollingWriteStreamPolicy(string directory, string extension, TimeSpan maxAge, int maxSize, EdiExceptionHandler errorHandler);
    public bool get_CrashOnMinExpectedBytesPerRolloverSignaled();
    public void set_CrashOnMinExpectedBytesPerRolloverSignaled(bool value);
    public void SetContext(string serviceAlias, string machineName, int processId, TimeSpan rolloverPeriod);
    public sealed virtual string get_ServiceAlias();
    public sealed virtual void set_ServiceAlias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MachineName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(int value);
    public sealed virtual void set_RolloverPeriod(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFolder();
    [CompilerGeneratedAttribute]
private void set_TargetFolder(string value);
    public sealed virtual TriState get_IsConfidential();
    private void set_IsConfidential(TriState value);
    public static RollingCsvTraceListener2 CreateAndInitializeByCommandLineUtilitiesIfNeeded(Assembly toolAssembly, string commandLineDevTracingValue);
    public static RollingCsvTraceListener2 CreateAndInitialize(string serviceAlias, string tracesLocalRootPath, bool scanFolderForPreviousTraces, string machineName, int rolloverPeriodInSeconds, bool warnUponOtherSetListeners, bool removeOtherSetListeners, bool crashOnMinExpectedBytesPerRolloverSignaled, bool parallelizeWriters);
    public static RollingCsvTraceListener2 CreateAndInitialize(RollingCsvTraceListener2Manifest manifest);
    private static List`1<TraceListener> GetForeignTraceListeners(TraceListenerCollection traceListeners, TraceListener survivor1, TraceListener survivor2, bool remove);
    public static void CleanupInProgressStreamsInPathRecursively(string directoryRootPath, EdiExceptionHandler errorHandler);
    [ConditionalAttribute("DEBUG")]
public void SetOnTraceWrite(Action`1<string> onTraceWrite);
    [ConditionalAttribute("DEBUG")]
private void OnTraceWrite(string trace);
    public virtual bool get_IsThreadSafe();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public sealed virtual void SuperFlush();
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void Write(object o);
    public virtual void Write(object o, string category);
    public virtual void Write(string message);
    public virtual void Write(string message, string category);
    public virtual void WriteLine(object o);
    public virtual void WriteLine(object o, string category);
    public virtual void WriteLine(string message);
    public virtual void WriteLine(string message, string category);
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    private void WriteDataToCsv(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string data);
    private void WriteLineIfInValidState(string formattedData);
    private void WriteGenericFormatTraceToCsv(TraceEventCache eventCache, string source, TraceEventType eventType, string data);
    private void SplitAndWrite(string data, string header);
    private void WriteGenericFormatTraceToCsv(string data, string category);
    [CompilerGeneratedAttribute]
private bool <CreateRollingWriteStream>b__11_0();
}
public class Kusto.Cloud.Platform.Utils.RollingCsvTraceListener2Manifest : object {
    public string ServiceAlias;
    public string TracesLocalRootPath;
    public bool ScanFolderForPreviousTraces;
    public string MachineName;
    public string InstanceIdSuffix;
    public int RolloverPeriodInSeconds;
    public bool WarnUponOtherSetListeners;
    public bool RemoveOtherSetListeners;
    public bool AddConsoleTraceListener;
    public bool CrashOnMinExpectedBytesPerRolloverSignaled;
    public bool ParallelizeWriters;
    public TriState IsConfidential;
}
public class Kusto.Cloud.Platform.Utils.RollingWriteStream : Stream {
    private Encoding m_encoding;
    private int m_maxData;
    private IRollingWriteStreamPolicy m_policy;
    private EdiExceptionHandler m_errorHandler;
    private object m_lock;
    private TraceAndSwallowEdiExceptionHandler m_tracer;
    private Timer m_rolloverTimer;
    private long m_position;
    private CachedBufferEncoder m_encoder;
    private RollingWriteStreamContext m_currentContext;
    private static long c_minExpectedBytesPerRollover;
    private Int64[] m_positionHistory;
    private Func`1<bool> m_crashOnMinExpectedBytesPerRolloverSignaled;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RollingWriteStream(Encoding encoding, int maxData, IRollingWriteStreamPolicy policy, EdiExceptionHandler errorHandler, Func`1<bool> crashOnMinExpectedBytesPerRolloverSignaled);
    public RollingWriteStream(Encoding encoding, int maxFieldSize, int maxSize, string directory, string fileNamePrefix, string extension, TimeSpan maxAge, EdiExceptionHandler errorHandler, Func`1<bool> crashOnMinExpectedBytesPerRolloverSignaled);
    public void SetMaxAge(TimeSpan maxAge);
    public void SetMaxSize(int maxSize);
    public RollingWriteStreamContext DebuggingGetCurrentContext();
    public void CleanupInProgressStreams();
    private void OnRolloverTimer(object state);
    private RollingWriteStreamContext RollOverUnderLockIfNeeded(bool force, bool crashOnWritingStopped);
    private void DisposeContext(RollingWriteStreamContext context);
    private RollingWriteStreamContext GetOrCreateContextUnderLock();
    private RollingWriteStreamContext WriteImpl(Byte[] array, int offset, int count, Byte[] suffix);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public void SuperFlush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer, int offset, int count, Byte[] suffix);
    public void WriteLine(string text);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public class Kusto.Cloud.Platform.Utils.RollingWriteStreamContext : object {
    private string m_filePath;
    private DateTime m_whenCreated;
    private EdiExceptionHandler m_errorHandler;
    private FileStream m_stream;
    private long m_bytesWritten;
    public string FilePath { get; }
    public DateTime WhenCreated { get; }
    public long BytesWritten { get; }
    public RollingWriteStreamContext(string filePath, DateTime now, EdiExceptionHandler errorHandler);
    public bool TryClose();
    public void Flush();
    public void Write(Byte[] array, int offset, int count);
    public string get_FilePath();
    public DateTime get_WhenCreated();
    public long get_BytesWritten();
}
public class Kusto.Cloud.Platform.Utils.RollingWriteStreamPolicy : object {
    protected static int c_maxPath;
    protected static string c_inProgress;
    protected EdiExceptionHandler m_errorHandler;
    protected string m_directory;
    protected string m_extension;
    protected TimeSpan m_maxAge;
    protected int m_maxSize;
    protected string m_fileNamePrefix;
    protected string m_dateTimePartFormat;
    protected string m_machineName;
    protected string m_processId;
    protected string m_processName;
    protected NamingOptions m_namingOptions;
    protected DateTime UtcNow { get; }
    public RollingWriteStreamPolicy(string directory, string fileNamePrefix, string extension, TimeSpan maxAge, int maxSize, EdiExceptionHandler errorHandler);
    public virtual RollingWriteStreamContext CreateContext();
    public virtual bool ShouldDisposeContext(RollingWriteStreamContext context);
    public virtual void OnContextDisposed(RollingWriteStreamContext context);
    public virtual void CleanupInProgressStreams(string fileToAvoid);
    public static void CleanupInProgressStreams(string rootDirectory, string fileToAvoid, EdiExceptionHandler errorHandler, Action`1<string> renameInProgressStream);
    public void SetMaxAge(TimeSpan maxAge);
    public void SetMaxSize(int maxSize);
    protected virtual void RenameInProgressStream(string fromPath);
    private static void RenameInProgressStream(string fromPath, EdiExceptionHandler errorHandler);
    protected virtual DateTime get_UtcNow();
    protected virtual string CreateFileStreamName(DateTime now);
}
public class Kusto.Cloud.Platform.Utils.RootAllEventSourcesListener : EventListener {
    private List`1<EventSource> m_sources;
    protected virtual void OnEventSourceCreated(EventSource source);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
}
public class Kusto.Cloud.Platform.Utils.ScopedSimulatedTime : object {
    public ScopedSimulatedTime(DateTime utcNow);
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Utils.SecretiveUri : object {
    private static char c_semicolon;
    private static string c_questionMark;
    private Uri m_uri;
    private string m_uriStringOriginal;
    private string m_uriStringNoSemicolon;
    private string m_uriStringNoSecrets;
    private string m_uriStringObfuscatedSecrets;
    private string m_semicolonSecret;
    private string m_querySecret;
    public string SemicolonSecret { get; }
    public string QuerySecret { get; }
    public Uri Uri { get; }
    public SecretiveUri(string uriString);
    private SecretiveUri(string uriString, String& secureString, Exception& ex);
    private SecretiveUri(string uriString, bool validateInput);
    public static SecretiveUri TryCreate(string uriString, String& secureString, Exception& ex);
    public SecretiveUri WithUpdatedAbsolutePath(string absolutePath);
    public SecretiveUri WithUpdatedPathAndQueryString(string pathAndQueryString);
    public SecretiveUri WithUpdatedQueryString(string queryString);
    public SecretiveUri WithUpdatedAbsoluteUri(string absoluteUri);
    public string MergeSecretWithAbsoluteUri(string absoluteUri);
    public bool ContainsAuthentication();
    public static string ToTraceString(string uri);
    public string ToSecureString();
    public string ToUnsecureString();
    public string ToBaseString();
    public string get_SemicolonSecret();
    public string get_QuerySecret();
    public Uri get_Uri();
}
internal class Kusto.Cloud.Platform.Utils.SECURITY_ATTRIBUTES : ValueType {
    public UInt32 nLength;
    public IntPtr lpSecurityDescriptor;
    public int bInheritHandle;
}
public class Kusto.Cloud.Platform.Utils.ShutdownHandler : object {
    private static int TRUE;
    private static int FALSE;
    private static int ADD;
    private static int SWALLOW;
    private static int PROCEED_NEXT_HANDLER;
    private static ConsoleCtrlDelegate s_consoleControlDel;
    [CompilerGeneratedAttribute]
private static EventWaitHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsRegistered>k__BackingField;
    public static EventWaitHandle Handle { get; }
    public static bool IsRegistered { get; }
    private static ShutdownHandler();
    [CompilerGeneratedAttribute]
public static EventWaitHandle get_Handle();
    [CompilerGeneratedAttribute]
public static bool get_IsRegistered();
    public static void RegisterConsoleCtrlHandler(Action action);
    private static int ConsoleCtrlDelegate(CtrlTypes ctrlType);
}
public class Kusto.Cloud.Platform.Utils.ShutdownSequenceStartedException : Exception {
    public ShutdownSequenceStartedException(string msg);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.SignatureVerificationException : UtilsException {
    public string Thumbprint;
    public string UserMsg;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public SignatureVerificationException(string message, Exception innerException);
    protected SignatureVerificationException(SerializationInfo info, StreamingContext context);
    public SignatureVerificationException(string thumbprint, string userMsg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SignatureVerificationException(string thumbprint, string userMsg, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SignatureVerificationException(string thumbprint, string userMsg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SignatureVerificationException(string thumbprint, string userMsg, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.SigningException : UtilsException {
    public string Thumbprint;
    public string UserMsg;
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public SigningException(string message, Exception innerException);
    protected SigningException(SerializationInfo info, StreamingContext context);
    public SigningException(string thumbprint, string userMsg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SigningException(string thumbprint, string userMsg, string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SigningException(string thumbprint, string userMsg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public SigningException(string thumbprint, string userMsg, string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Kusto.Cloud.Platform.Utils.SimpleStreamChain : StreamChainBase {
    [CompilerGeneratedAttribute]
private Action Disposing;
    [CompilerGeneratedAttribute]
private Action Disposed;
    public SimpleStreamChain(Stream innerStream, string innerStreamId, ITraceSource tracer, Context ioContext, bool leaveOpen, string creationCallStackAsString);
    [CompilerGeneratedAttribute]
public void add_Disposing(Action value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(Action value);
    [CompilerGeneratedAttribute]
public void add_Disposed(Action value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(Action value);
    public void add_IoStarting(EventHandler`1<StreamIoStartingEventArgs> value);
    public void remove_IoStarting(EventHandler`1<StreamIoStartingEventArgs> value);
    protected virtual void OnDisposing();
    protected virtual void OnDisposed();
}
public class Kusto.Cloud.Platform.Utils.SimpleStreamChainBuilder : object {
    private Context m_creationContext;
    private string m_creationCallStackAsString;
    public SimpleStreamChain Build(Stream innerStream, string innerStreamId, ITraceSource tracer, Context ioContext, bool leaveOpen);
}
public class Kusto.Cloud.Platform.Utils.SkipLineStream : SkipLineStreamBase {
    public SkipLineStream(Stream stream, int linesToSkip);
    protected virtual void ConsumeLine();
}
public abstract class Kusto.Cloud.Platform.Utils.SkipLineStreamBase : Stream {
    private int m_linesToSkip;
    private Nullable`1<byte> m_buffer;
    private int m_bytesSkipped;
    private Stream m_baseStream;
    private Byte[] m_readByteBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SkipLineStreamBase(Stream stream, int linesToSkip);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
    private void ConsumeLinesIfNeeded();
    protected abstract virtual void ConsumeLine();
    protected int ConsumeTill(Char[] chars);
    protected void ConsumeByteIfEqual(byte b);
}
public class Kusto.Cloud.Platform.Utils.SkipQuotedLineStream : SkipLineStreamBase {
    private static char c_quote;
    public SkipQuotedLineStream(Stream stream, int linesToSkip);
    protected virtual void ConsumeLine();
}
public class Kusto.Cloud.Platform.Utils.SlidingWindowResourceUsageThrottlerPolicy : object {
    private static UInt32 c_maxUsage_upperBound;
    private static UInt32 c_maxUsageTimeSpanCoefficient_10ms;
    private static UInt32 c_maxUsageTimeSpanCoefficient_100ms;
    private static UInt32 c_maxUsageOveruseCoefficient;
    private UInt32 m_originalMaxUtilization;
    private UInt32 m_maxUsageTimeSpanCoefficient;
    private TimeSpan m_timeWindow;
    private string m_resourceKind;
    private string m_resourceId;
    private Action`2<ResourceUtilizationMeasure, bool> m_onQuotaExceeded;
    private TokenBucket m_tokenBucket;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<UInt32, TimeSpan> MaxUtilization { get; }
    public SlidingWindowResourceUsageThrottlerPolicy(string resourceKind, string resourceId, UInt32 maxUsageInTimeWindow, TimeSpan timeWindow, Nullable`1<DateTime> utcNow, Action`2<ResourceUtilizationMeasure, bool> onQuotaExceeded);
    public ValueTuple`2<UInt32, TimeSpan> get_MaxUtilization();
    public sealed virtual void OnInvokeDone();
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public void ReportResourceUsage(DateTime utcNow, double seconds);
    public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    private DateTime ProvideUtcNow(Nullable`1<DateTime> utcNow);
    private UInt32 ConvertResourceUsage(double seconds);
    private UInt32 ConvertMaxUsageInTimeWindow(UInt32 maxUsageInTimeWindow);
    private static UInt32 GetMaxUsageTimeSpanCoefficient(UInt32 maxUsageInTimeWindow);
}
public class Kusto.Cloud.Platform.Utils.SlidingWindowThrottlerPolicy : object {
    private string m_resourceKind;
    private string m_resourceId;
    private Action`2<ResourceUtilizationMeasure, bool> m_onChange;
    private UInt32 m_maxOperationsInTimeWindow;
    private TimeSpan m_timeWindow;
    private TokenBucket m_tokenBucket;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<UInt32, TimeSpan> MaxUtilization { get; }
    public SlidingWindowThrottlerPolicy(string resourceKind, string resourceId, UInt32 maxOperationsInTimeWindow, TimeSpan timeWindow, Nullable`1<DateTime> utcNow, Action`2<ResourceUtilizationMeasure, bool> onChange);
    public ValueTuple`2<UInt32, TimeSpan> get_MaxUtilization();
    public sealed virtual bool ShouldInvoke(Nullable`1<DateTime> utcNow);
    public void ReportUsage(DateTime utcNow, UInt32 amount);
    public sealed virtual void OnInvokeDone();
    public sealed virtual ResourceUtilizationMeasures GetResourceUtilization(Nullable`1<DateTime> utcNow);
    public sealed virtual Task`1<bool> ShouldInvokeAsync(Nullable`1<DateTime> utcNow);
    protected DateTime ProvideUtcNow(Nullable`1<DateTime> utcNow);
    private void NotifyOnChange(bool requestPassedBelowThrottlingLimit, DateTime utcNow);
}
public class Kusto.Cloud.Platform.Utils.SlotCache`1 : object {
    private TimeSpan m_validFor;
    private TimeSpan m_invalidFor;
    private DateTime m_latestUpdateTime;
    private TriState m_latestUpdateState;
    private T m_value;
    public SlotCache`1(TimeSpan validFor, TimeSpan invalidFor);
    public TriState TryGet(DateTime now, T& value);
    public bool TrySetValid(DateTime now, T value);
    public bool TrySetInvalid(DateTime now);
    public virtual string ToString();
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.SplitPlatformExceptionDetail : object {
    [ThreadStaticAttribute]
private static StringBuilder s_stringBuilderCache;
    private static int c_maxAsStringCharacters;
    private static int c_maxDataValueCharacters;
    private static int c_maxStackTraceCharacters;
    private static int c_maxMessageCharacters;
    [CompilerGeneratedAttribute]
private PlatformExceptionDetail <PlatformExceptionDetail>k__BackingField;
    [DataMemberAttribute]
public string StackTrace;
    [DataMemberAttribute]
public CreationContext CreationContext;
    [CompilerGeneratedAttribute]
private SplitPlatformExceptionDetail <InnerPlatformExceptionDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [DataMemberAttribute]
public PlatformExceptionDetail PlatformExceptionDetail { get; public set; }
    [DataMemberAttribute]
public SplitPlatformExceptionDetail InnerPlatformExceptionDetail { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    private SplitPlatformExceptionDetail(PlatformExceptionDetail ped, PlatformExceptionDetail innerPed);
    [CompilerGeneratedAttribute]
public PlatformExceptionDetail get_PlatformExceptionDetail();
    [CompilerGeneratedAttribute]
public void set_PlatformExceptionDetail(PlatformExceptionDetail value);
    [CompilerGeneratedAttribute]
public SplitPlatformExceptionDetail get_InnerPlatformExceptionDetail();
    [CompilerGeneratedAttribute]
public void set_InnerPlatformExceptionDetail(SplitPlatformExceptionDetail value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public static SplitPlatformExceptionDetail FromException(Exception ex);
    public static SplitPlatformExceptionDetail FromComponents(PlatformExceptionDetail ped, string message, string stackTrace, CreationContext creationContext, SplitPlatformExceptionDetail innerPed);
    public PlatformExceptionDetail ToPlatformExceptionDetail();
    public static string TruncateAndAppendEllipsis(string input, int maxLength);
}
internal class Kusto.Cloud.Platform.Utils.StopLock : ValueType {
    private long m_state;
    private Action m_callback;
    private static long c_stopping;
    private static long c_stopped;
    private static long c_maxShared;
    public StopLock(Action onStopCompleted);
    public bool TryEnter();
    public void Leave();
    public void Stop();
    private void InvokeCallbackIfPossible();
    private bool InterlockedAddToStateIfEqualsOrHigher(long addend, long comparand);
    private bool InterlockedAddToStateIfEquals(long addend, long comparand);
}
public abstract class Kusto.Cloud.Platform.Utils.StreamChainBase : Stream {
    public static string LeakDetectionCaptureCallStackEnabled_TweakName;
    private static Tweak`1<bool> s_leakDetectionCaptureCallStackEnabledTweak;
    private static Thinner s_thinner;
    [ThreadStaticAttribute]
private static Exception s_alternativeExceptionToThrowIfDisposed;
    private Exception m_alternativeExceptionToThrowIfDisposed;
    private Context m_creationContext;
    private string m_callStack;
    private Stream m_innerStream;
    private bool m_disposed;
    private string m_id;
    protected ITraceSource m_tracer;
    protected Context m_ioContext;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamIoStartingEventArgs> IoStarting;
    protected bool m_leaveOpen;
    private bool m_canRead;
    private bool m_canSeek;
    private bool m_canTimeout;
    private bool m_canWrite;
    internal static bool EnableCapturingCallStacks { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    protected StreamChainBase(string id);
    protected StreamChainBase(Context creationContext, string id, string creationCallStackAsString);
    private static StreamChainBase();
    [CompilerGeneratedAttribute]
protected void add_IoStarting(EventHandler`1<StreamIoStartingEventArgs> value);
    [CompilerGeneratedAttribute]
protected void remove_IoStarting(EventHandler`1<StreamIoStartingEventArgs> value);
    public static IDisposable TemporarilySetAlternativeExceptionToThrowIfDisposed(Exception ex);
    internal static bool get_EnableCapturingCallStacks();
    private void TraceCreationWithNoContextNorId();
    protected virtual override void Finalize();
    protected virtual void OnUnexpectedFinalization();
    protected virtual void OnDisposing();
    protected virtual void OnDisposed();
    protected virtual void Dispose(bool disposing);
    protected Stream SetInnerStream(Stream innerStream);
    protected Stream GetInnerStream(string methodName);
    private Stream ThrowObjectDisposedException(string methodName);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.StreamChainBase/<CopyToAsync>d__44")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.StreamChainBase/<ReadAsync>d__55")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.StreamChainBase/<WriteAsync>d__63")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
public class Kusto.Cloud.Platform.Utils.StreamDisposeLich : SimpleStreamChain {
    public StreamDisposeLich(Stream inner, Action onDisposed);
}
public class Kusto.Cloud.Platform.Utils.StreamIoStartingEventArgs : EventArgs {
    private bool m_write;
    private bool m_async;
    private int m_size;
    public bool IsWrite { get; }
    public bool IsRead { get; }
    public bool IsAsync { get; }
    public bool IsSync { get; }
    public int Size { get; }
    internal StreamIoStartingEventArgs(bool write, bool async, int size);
    public bool get_IsWrite();
    public bool get_IsRead();
    public bool get_IsAsync();
    public bool get_IsSync();
    public int get_Size();
}
public class Kusto.Cloud.Platform.Utils.StreamOrLocalFile : object {
    private bool m_streamBased;
    private Stream m_stream;
    private string m_filePath;
    private Func`1<Stream> m_streamOpener;
    private Func`2<Stream, Stream> m_streamWrapper;
    private bool m_disposeStream;
    private bool m_deleteFile;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_disposed;
    [CompilerGeneratedAttribute]
private string <LocalFilePath>k__BackingField;
    public string LocalFilePath { get; private set; }
    public StreamOrLocalFile(Stream stream, bool disposeStream);
    public StreamOrLocalFile(string filePath, Func`1<Stream> streamOpener, Func`2<Stream, Stream> streamWrapper, bool deleteFile);
    [CompilerGeneratedAttribute]
private void set_LocalFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_LocalFilePath();
    public void WrapStream(Func`2<Stream, Stream> streamWrapper);
    public sealed virtual void Dispose();
    public string GetLocalFilePath();
    public Stream GetStream();
    private void TryDeleteLocalFile();
}
public static class Kusto.Cloud.Platform.Utils.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    private static int DEFAULT_CAPACITY;
    public static StringBuilder Acquire(StringBuilder& threadStaticStringBuilder, int capacity, int maxBuilderSize);
    public static StringBuilder Acquire(StringBuilder& threadStaticStringBuilder, string value);
    public static void Release(StringBuilder& threadStaticStringBuilder, StringBuilder sb, int maxBuilderSize);
    public static string GetStringAndRelease(StringBuilder& threadStaticStringBuilder, StringBuilder sb, int maxBuilderSize);
    public static string GetStringAndClear(StringBuilder& threadStaticStringBuilder, StringBuilder sb);
}
[ExtensionAttribute]
public static class Kusto.Cloud.Platform.Utils.StringBuilderExtensions : object {
    private static char HexDigitToChar(int a, bool uppercase);
    [ExtensionAttribute]
public static StringBuilder AppendByteAsHex(StringBuilder sb, byte b, bool prefix, bool uppercase);
    [ExtensionAttribute]
public static StringBuilder AppendAsHex(StringBuilder sb, IntPtr address, bool prefix, bool uppercase);
    [ExtensionAttribute]
public static StringBuilder AppendAsHex(StringBuilder sb, int value, bool prefix, bool uppercase);
    [ExtensionAttribute]
public static StringBuilder AppendAsHex(StringBuilder sb, UInt32 value, bool prefix, bool uppercase);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.StringJoinOptions : Enum {
    public int value__;
    public static StringJoinOptions None;
    public static StringJoinOptions KeepEmptyEntries;
    public static StringJoinOptions MergeSeparatorsIntoOne;
}
public class Kusto.Cloud.Platform.Utils.StringLogger`1 : object {
    private T m_defaultFlavor;
    private bool m_enabled;
    private List`1<LogRecord<T>> m_records;
    public bool Enabled { get; public set; }
    public StringLogger`1(T defaultFlavor);
    public sealed virtual void Dispose();
    public sealed virtual void Write(string value);
    public sealed virtual void Write(T flavor, string value);
    public sealed virtual void Write(string format, Object[] args);
    public sealed virtual void Write(T flavor, string format, Object[] args);
    public sealed virtual void WriteLine(string value);
    public sealed virtual void WriteLine(T flavor, string value);
    public sealed virtual void WriteLine(string format, Object[] args);
    public sealed virtual void WriteLine(T flavor, string format, Object[] args);
    public sealed virtual void Flush();
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public IEnumerable`1<LogRecord<T>> AllRecords();
    private void WriteInternal(T flavor, string value);
}
public enum Kusto.Cloud.Platform.Utils.StringPluralizeOptions : Enum {
    public int value__;
    public static StringPluralizeOptions NoTense;
    public static StringPluralizeOptions PrependPastTense;
    public static StringPluralizeOptions PrependPresentTense;
}
public class Kusto.Cloud.Platform.Utils.SuspendedProcess : object {
    private static string ProcessField_StandardOutput;
    private static string ProcessField_StandardError;
    private static string ProcessField_StandardInput;
    [CompilerGeneratedAttribute]
private ProcessStartInfo <ProcessStartInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdOutPipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdErrPipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdInPipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeProcessHandle <ProcessHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeProcessHandle <ThreadHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resumed>k__BackingField;
    public ProcessStartInfo ProcessStartInfo { get; private set; }
    public string StdOutPipeName { get; private set; }
    public string StdErrPipeName { get; private set; }
    public string StdInPipeName { get; private set; }
    public int ProcessId { get; private set; }
    public int ThreadId { get; private set; }
    public SafeProcessHandle ProcessHandle { get; private set; }
    public SafeProcessHandle ThreadHandle { get; private set; }
    public bool Resumed { get; private set; }
    [CompilerGeneratedAttribute]
public ProcessStartInfo get_ProcessStartInfo();
    [CompilerGeneratedAttribute]
private void set_ProcessStartInfo(ProcessStartInfo value);
    [CompilerGeneratedAttribute]
public string get_StdOutPipeName();
    [CompilerGeneratedAttribute]
private void set_StdOutPipeName(string value);
    [CompilerGeneratedAttribute]
public string get_StdErrPipeName();
    [CompilerGeneratedAttribute]
private void set_StdErrPipeName(string value);
    [CompilerGeneratedAttribute]
public string get_StdInPipeName();
    [CompilerGeneratedAttribute]
private void set_StdInPipeName(string value);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
private void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public SafeProcessHandle get_ProcessHandle();
    [CompilerGeneratedAttribute]
private void set_ProcessHandle(SafeProcessHandle value);
    [CompilerGeneratedAttribute]
public SafeProcessHandle get_ThreadHandle();
    [CompilerGeneratedAttribute]
private void set_ThreadHandle(SafeProcessHandle value);
    [CompilerGeneratedAttribute]
public bool get_Resumed();
    [CompilerGeneratedAttribute]
private void set_Resumed(bool value);
    public static SuspendedProcess Create(SafeProcessHandle userToken, ProcessStartInfo processStartInfo, int redirectionBufferSize);
    public Process Resume(Action`1<Process> creationHandler, Action`1<string> outputHandler, Action`1<string> errorHandler);
    public sealed virtual void Dispose();
    private static StringBuilder BuildCommandLine(string executablePath, string arguments);
    private static string CreateRandomNamedPipe(SafeFileHandle& fileHandle, int bufferSize, FileAccess fileHandleMode);
    private static Byte[] CreateSecurityDescriptor(GCHandle& securityDescriptorPtr);
    private void PreparePipes(Action`1<string> outputHandler, Action`1<string> errorHandler, Process process);
    private static Encoding GetEncoding(int codePage);
}
public enum Kusto.Cloud.Platform.Utils.TestEnum : Enum {
    public int value__;
    public static TestEnum None;
    public static TestEnum TestA;
}
public class Kusto.Cloud.Platform.Utils.TextFileListener : TextWriterTraceListener {
    public TextFileListener(string logsFolder);
    private static string GetLogFileName(string logsFolder);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
}
public class Kusto.Cloud.Platform.Utils.TextTabulator : object {
    private int m_columnCount;
    private int m_bufferedRowCount;
    private Action`1<string> m_outputWriter;
    private List`1<String[]> m_buffered;
    private Int32[] m_widths;
    private int m_rowsWritten;
    private int m_lineWidth;
    private bool m_markdown;
    private bool m_trim;
    private bool m_verticalGuardrails;
    private List`1<string> m_output;
    public bool MarkDown { get; public set; }
    public bool Trim { get; public set; }
    public bool VerticalGuardrails { get; public set; }
    public TextTabulator(int columnCount, int bufferedRowCount, Action`1<string> outputWriter);
    public static string Box(string text);
    public bool get_MarkDown();
    public void set_MarkDown(bool value);
    public bool get_Trim();
    public void set_Trim(bool value);
    public bool get_VerticalGuardrails();
    public void set_VerticalGuardrails(bool value);
    public sealed virtual void Add(String[] row);
    public sealed virtual void Done();
    public void Done(IEnumerable`1& lines);
    private void DetermineWidthsAndWriteBuffered();
    private void DetermineWidths();
    private void WriteBuffered();
    private string FormatCell(string value, int col);
    private int TrimAndGetRowHeight(String[] row);
    private void WriteRowNoRulers(String[] row);
    private string FormatRowNoNewLines(String[] row);
    private void WriteRow(String[] row);
    private void WriteRuler();
}
public class Kusto.Cloud.Platform.Utils.TextWriterTraceSource : ITraceSource {
    private string m_id;
    private TraceVerbosity m_verbosity;
    private TextWriter m_writer;
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public TraceVerbosity Verbosity { get; public set; }
    public char Delimiter { get; }
    public TextWriterTraceSource(string id, TraceVerbosity verbosity, TextWriter writer);
    public string get_Id();
    public TraceVerbosity get_DefaultVerbosity();
    public TraceVerbosity get_Verbosity();
    public void set_Verbosity(TraceVerbosity value);
    public virtual void TraceWithHeader(TraceVerbosity verbosity, string header, string message);
    public virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string message);
    public virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string format, Object[] args);
    public virtual void TraceFatal(string message);
    public virtual void TraceFatal(string format, Object[] args);
    public virtual void TraceError(string message);
    public virtual void TraceError(string format, Object[] args);
    public virtual void TraceWarning(string message);
    public virtual void TraceWarning(string format, Object[] args);
    public virtual void TraceInformation(string message);
    public virtual void TraceInformation(string format, Object[] args);
    public virtual void TraceVerbose(string message);
    public virtual void TraceVerbose(string format, Object[] args);
    public virtual bool ShouldTrace(TraceVerbosity level);
    public virtual bool ShouldTrace(TraceVerbosity level, TracingContext tracingContext);
    public virtual void Flush();
    public char get_Delimiter();
    public bool ShouldTrace(TraceEventType verbosity);
}
public class Kusto.Cloud.Platform.Utils.Thinner : object {
    private Func`1<bool> m_canInvoke;
    private TimeSpan m_minSeparation;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    public Thinner(Func`1<bool> canInvoke);
    public Thinner(TimeSpan minSeparation);
    public bool Invoke(Action action);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.Thinner/<InvokeAsync>d__6")]
public Task`1<bool> InvokeAsync(Func`1<Task> func);
    public bool Invoke(Action`1<T> action, T arg);
    private bool CanInvoke();
    private void InvokeDone();
}
public class Kusto.Cloud.Platform.Utils.ThreadPoolStatus : object {
    public string NodeId;
    public int AvailableWorkerThreads;
    public int AvailableCompletionPortThreads;
    public int MinWorkerThreads;
    public int MinCompletionPortThreads;
    public int MaxWorkerThreads;
    public int MaxCompletionPortThreads;
    public int WorkerThreadsOverMinSize { get; }
    public int CompletionPortThreadsOverMinSize { get; }
    public int get_WorkerThreadsOverMinSize();
    public int get_CompletionPortThreadsOverMinSize();
    public virtual string ToString();
}
public static class Kusto.Cloud.Platform.Utils.ThreadSafeRandom : object {
    private static Random s_globalRandom;
    private static ThreadLocal`1<Random> s_threadLocalRandom;
    public static Random Instance { get; }
    private static ThreadSafeRandom();
    public static Random get_Instance();
    private static Random CreateRandom();
}
public class Kusto.Cloud.Platform.Utils.Throttler : object {
    private IThrottlerPolicy m_policy;
    public Throttler(IThrottlerPolicy policy);
    public sealed virtual bool TryInvoke(Action action, Nullable`1<DateTime> utcNow);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.Throttler/<TryInvokeAsync>d__3")]
public sealed virtual Task`1<bool> TryInvokeAsync(Func`1<Task> action, Nullable`1<DateTime> utcNow);
    public sealed virtual Tuple`2<bool, Task`1<TResult>> TryInvokeAsync(Func`1<Task`1<TResult>> action, Nullable`1<DateTime> utcNow);
    [CompilerGeneratedAttribute]
private TResult <TryInvokeAsync>b__4_0(Task`1<TResult> parent);
}
public static class Kusto.Cloud.Platform.Utils.TimeConstants : object {
    public static int HoursInDay;
    public static int DaysInWeek;
    public static int HoursInWeek;
    public static int MinutesInHour;
    public static int MinutesInDay;
    public static int SecondsInMinute;
    public static int SecondsInHour;
    public static int SecondsInDay;
    public static int MillisecondsInSecond;
    public static int MillisecondsInMinute;
    public static int MillisecondsInDay;
    public static int MinUtcOffset;
    public static int MaxUtcOffset;
    public static TimeSpan InfiniteTimeSpan;
    private static TimeConstants();
    public static bool InRange(int start, int end, int lowerBound, int upperBound, int value);
    public static int Normalize(int value, int upperBound);
}
public class Kusto.Cloud.Platform.Utils.TimedStream : Stream {
    private Stream m_baseStream;
    private TimeSpan m_timeout;
    private DateTime m_lastFlushed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public TimedStream(Stream stream, TimeSpan timeout);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.TimedStream/<WriteAsync>d__22")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.TimedStream/<FlushAsync>d__27")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    private void FlushImpl();
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.TimedStream/<FlushImplAsync>d__38")]
private Task FlushImplAsync();
    private bool ShouldFlush();
}
internal class Kusto.Cloud.Platform.Utils.TimeMachine : object {
    private DateTime m_now;
    private AlarmClockSortedList m_alarms;
    private static AlarmClock s_nullAlarmClock;
    public TimeMachine(DateTime now);
    private static TimeMachine();
    public object AddAlarmClock(DateTime alarmTime, TimeSpan snooze, Action alarmCallback);
    public void RemoveAlarmClock(object alarmClock);
    public void JumpToTime(DateTime value);
    public void AdvanceInTime(TimeSpan period);
}
public class Kusto.Cloud.Platform.Utils.TimeoutStream : Stream {
    private Stream m_baseStream;
    private object m_lock;
    private bool m_closed;
    private bool m_disposed;
    private Timer m_timer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public TimeoutStream(Stream stream, DateTime expires);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    private void OnTimeout(object state);
    private void CloseUnderLock();
}
public class Kusto.Cloud.Platform.Utils.TimePeriodControl : object {
    private UInt32 m_period;
    public TimePeriodControl(int period);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public static class Kusto.Cloud.Platform.Utils.TimerUtils : object {
    public static string SuppressPeriodicTraces_TweakName;
    internal static Tweak`1<bool> SuppressPeriodicTracesTweak;
    public static bool SuppressPeriodicTraces { get; }
    private static TimerUtils();
    public static void CreateActivityAndInvoke(TActivityType activityType, Action action);
    public static TResult CreateActivityAndInvoke(TActivityType activityType, Func`1<TResult> func);
    public static bool get_SuppressPeriodicTraces();
    public static bool PollUntil(Func`1<bool> predicate, TimeSpan timeout, Nullable`1<TimeSpan> pollInterval);
}
public static class Kusto.Cloud.Platform.Utils.TimeSpanConstants : object {
    public static TimeSpan _2sec;
    public static TimeSpan _5sec;
    public static TimeSpan _10sec;
    public static TimeSpan _20sec;
    public static TimeSpan _1min;
    public static TimeSpan _2min;
    public static TimeSpan _3min;
    public static TimeSpan _4min;
    public static TimeSpan _5min;
    public static TimeSpan _10min;
    public static TimeSpan _30min;
    public static TimeSpan _59min;
    public static TimeSpan _60min;
    public static TimeSpan _1hour;
    public static TimeSpan _2hours;
    public static TimeSpan _3hours;
    public static TimeSpan _4hours;
    public static TimeSpan _5hours;
    public static TimeSpan _6hours;
    public static TimeSpan _10hours;
    private static TimeSpanConstants();
}
public class Kusto.Cloud.Platform.Utils.TokenBucket : object {
    private static int c_timeSpanSecondsBits;
    private static UInt32 c_maxTokensLimit;
    private static long c_maxTimeSpanLimit;
    private static DateTime c_timeCountBase;
    private UInt32 m_bucketFillTokensToAdd;
    private TimeSpan m_bucketFillTimePeriod;
    private UInt32 m_maxCapacity;
    private double m_bucketFillRate;
    private long m_updatedTokensBudget;
    public TokenBucket(UInt32 rateTokensToAdd, TimeSpan rateInTimePeriod, UInt32 maxCapacity, DateTime utcNow);
    private static TokenBucket();
    public void GetConfiguration(UInt32& rateTokensToAdd, TimeSpan& rateInTimePeriod, UInt32& maxCapacity);
    public void GetUtilizatonStatus(UInt32& utilizedTokens, DateTime& updateTimeStamp, DateTime utcNow, bool adjustToCurrent);
    public bool TryClaimTokens(UInt32 tokensToClaim, DateTime utcNow, bool allowPartialConsumption);
    private UInt32 GrantTokensByTimeExpired(UInt32 originalTokensBudget, long originalTimeStamp, DateTime utcNow, Int64& tokenAdjustedTimeStamp);
    private long PackTokensAndUpdateTime(long tokens, long updateTimeIntervalSeconds);
    private void UnpackTokensAndUpdateTime(long packedTokensAndTimeStamp, UInt32& tokens, Int64& timeStamp);
    private void VerifyUpdateTimeWithinLimits(long updateTimeIntervalSeconds);
    private long GetTimeFromBaseInSeconds(DateTime utcNow);
    private DateTime GetDateTime(long totalSecondsFromBase);
}
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.ToStringFormat : Enum {
    public int value__;
    public static ToStringFormat Inexact;
}
public class Kusto.Cloud.Platform.Utils.TraceAndContinueEncoderFallback : EncoderFallback {
    private string m_replacement;
    private ITraceSource m_tracer;
    public int MaxCharCount { get; }
    public TraceAndContinueEncoderFallback(ITraceSource tracer);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class Kusto.Cloud.Platform.Utils.TraceAndRethrowEdiExceptionHandler : object {
    private static TraceAndRethrowEdiExceptionHandler s_defaultInstance;
    public static EdiExceptionHandler DefaultEdiExceptionHandler;
    private ITraceSource m_tracer;
    private TraceAndRethrowEdiExceptionHandler(ITraceSource tracer);
    private static TraceAndRethrowEdiExceptionHandler();
    public static TraceAndRethrowEdiExceptionHandler Create();
    public static TraceAndRethrowEdiExceptionHandler Create(ITraceSource tracer);
    public sealed virtual void WriteLine(string message, bool force);
    public sealed virtual void AsEdiExceptionHandler(string message, ExceptionDispatchInfo edi);
}
public class Kusto.Cloud.Platform.Utils.TraceAndSwallowEdiExceptionHandler : object {
    private Thinner m_alternateTraceListenerThinner;
    public TraceAndSwallowEdiExceptionHandler(TimeSpan thinningPolicy);
    private static void OutputDebugString(string message);
    public sealed virtual void AsEdiExceptionHandler(string message, ExceptionDispatchInfo edi);
    public sealed virtual void WriteLine(string what, bool force);
    private static void WriteImpl(string what);
}
public class Kusto.Cloud.Platform.Utils.TraceListenerOnITraceSource : TraceListener {
    private ITraceSource m_tracer;
    private string m_source;
    public TraceListenerOnITraceSource(ITraceSource tracer, string source);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    private void WriteInternal(TraceVerbosity eventType, string source, string message);
}
public abstract class Kusto.Cloud.Platform.Utils.TraceSourceBase`1 : ITraceSource {
    private static T s_tracer;
    private TraceVerbosity m_verbosity;
    private string m_prefix;
    private string m_suffix;
    private int m_baseSourceId;
    private TraceSource m_dotNetTraceSource;
    private static bool s_listenersDumped;
    public static T Tracer { get; }
    public static ContextBoundTracer`1<T> LocalTracer { get; }
    protected bool EnableCloning { get; }
    public string Prefix { get; public set; }
    public string Suffix { get; public set; }
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public TraceVerbosity Verbosity { get; public set; }
    public bool Confidential { get; }
    protected TraceSource UnderlyingDotNetTraceSource { get; }
    private static TraceSourceBase`1();
    protected TraceSourceBase`1(string callerMemberName, string callerFilePath, int callerLineNumber);
    public static T get_Tracer();
    public static ContextBoundTracer`1<T> get_LocalTracer();
    public static void Init();
    protected virtual bool get_EnableCloning();
    protected void CopyPropertiesTo(TraceSourceBase`1<T> target, string updatedId);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Suffix();
    public void set_Suffix(string value);
    public sealed virtual void SetTraceSourceListeners(TraceListenerCollection listeners);
    public sealed virtual void AddTraceListener(TraceListener traceListener, bool forceAddEvenIfTypeAlreadyExists);
    public sealed virtual void RemoveTraceListener(TraceListener traceListener);
    public abstract virtual string get_Id();
    public abstract virtual TraceVerbosity get_DefaultVerbosity();
    public virtual TraceVerbosity get_Verbosity();
    public virtual void set_Verbosity(TraceVerbosity value);
    public virtual bool get_Confidential();
    public virtual void TraceFatal(string message);
    public virtual void TraceFatal(string format, Object[] args);
    public virtual void TraceError(string message);
    public virtual void TraceError(string format, Object[] args);
    public virtual void TraceWarning(string message);
    public virtual void TraceWarning(string format, Object[] args);
    public virtual void TraceInformation(string message);
    public virtual void TraceInformation(string format, Object[] args);
    public virtual void TraceVerbose(string message);
    public virtual void TraceVerbose(string format, Object[] args);
    public virtual void TraceWithHeader(TraceVerbosity verbosity, string header, string message);
    public virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string message);
    public virtual void TraceWithSourceId(string sourceId, TraceVerbosity verbosity, string format, Object[] args);
    public virtual bool ShouldTrace(TraceVerbosity level);
    public virtual bool ShouldTrace(TraceVerbosity level, TracingContext tracingContext);
    public virtual void Flush();
    protected string GetSourceId(string format);
    protected TraceSource get_UnderlyingDotNetTraceSource();
    internal void TraceInternal(string sourceId, TraceVerbosity verbosity, TraceVerbosity overrideTraceVerbosityLevel, TracingContext tracingContext, Activity activity, string format, Object[] args);
    private RollingCsvTraceListener2 TryGetRollingCsvTraceListener();
    public virtual string ToString();
}
public static class Kusto.Cloud.Platform.Utils.TraceSourceManager : object {
    private static object m_initLock;
    private static TaskCompletionSource`1<bool> m_initializeTCS;
    private static Thinner m_superFlushThinner;
    private static object m_traceSourcesLock;
    private static Dictionary`2<string, IManageableTraceSource> m_traceSources;
    private static TraceVerbosity m_overrideTraceVerbosityLevel;
    private static object m_traceListenersLock;
    private static object m_traceIngestorsLock;
    private static List`1<ITraceIngestor> m_traceIngestors;
    private static TraceSourceManager();
    public static void Initialize();
    private static List`1<IManageableTraceSource> GetAllTraceSources();
    public static bool TryAddTraceSource(string traceSourceID, IManageableTraceSource traceSource);
    public static List`1<string> GetAllTraceSourceIDs();
    internal static List`1<string> GetAllTraceSourceIDsOfConfidentiality(bool confidential);
    public static IManageableTraceSource TryGetTraceSource(string traceId);
    public static void SetTraceVerbosityForAll(TraceVerbosity traceVerbosity);
    public static TraceVerbosity GetOverrideTraceVerbosityLevel();
    public static TraceVerbosity SetOverrideTraceVerbosityLevel(TraceVerbosity traceVerbosity);
    public static void RegisterTraceListener(TraceListener listener);
    public static IEnumerable`1<TraceListener> GetAllTraceListeners();
    public static void RemoveTraceListener(TraceListener listener);
    public static IEnumerable`1<string> GetTargetFolders();
    private static HashSet`1<IPlatformTraceListener> GetAllPlatformTraceListeners();
    private static List`1<ITraceIngestor> GetAllTraceIngestors();
    public static void SafeAddTraceIngestor(ITraceIngestor traceIngestor, bool start, bool scanUponStart);
    public static void Flush();
    public static void SuperFlush(SuperFlushMode mode);
    private static void SuperFlushImpl(SuperFlushMode mode);
    public static void Shutdown();
}
public class Kusto.Cloud.Platform.Utils.TraceSourceTextWriter : TextWriter {
    private ITraceSource m_tracer;
    public Encoding Encoding { get; }
    public TraceSourceTextWriter(ITraceSource traceSource);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine();
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void WriteLine(Char[] buffer, int index, int count);
}
public class Kusto.Cloud.Platform.Utils.TraceToFileAndSwallowEdiExceptionHandler : object {
    private string m_outputFolder;
    private string m_fileExtension;
    private Thinner m_alternateTraceListenerThinner;
    private TraceSource m_traceSource;
    public TraceToFileAndSwallowEdiExceptionHandler(string outputFolder, string fileExtension);
    public TraceToFileAndSwallowEdiExceptionHandler(string outputFolder, string fileExtension, TimeSpan thinningPolicy);
    public sealed virtual void AsEdiExceptionHandler(string message, ExceptionDispatchInfo edi);
    public sealed virtual void WriteLine(string what, bool force);
    private void WriteImpl(string what);
}
public enum Kusto.Cloud.Platform.Utils.TraceVerbosity : Enum {
    public int value__;
    public static TraceVerbosity Fatal;
    public static TraceVerbosity Error;
    public static TraceVerbosity Warning;
    public static TraceVerbosity Info;
    public static TraceVerbosity Verbose;
    public static TraceVerbosity Invalid;
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.TracingContext : object {
    [DataMemberAttribute]
private TraceVerbosity m_suppressedTraceVerbosity;
    [DataMemberAttribute]
private TraceVerbosity m_forcedTraceVerbosity;
    [DataMemberAttribute]
private string m_additionalTraceDestination;
    [DataMemberAttribute]
private string m_additionalTraceDestinationPrefix;
    [DataMemberAttribute]
private bool m_additionalTraceAsyncUpload;
    private TraceListener m_additionalTraceListener;
    public TraceVerbosity SuppressedTraceVerbosity { get; }
    public TraceVerbosity ForcedTraceVerbosity { get; }
    public string AdditionalTraceDestination { get; }
    public string AdditionalTraceDestinationPrefix { get; }
    public bool AdditionalTraceAsyncUpload { get; }
    public TraceListener AdditionalTraceListener { get; }
    public TracingContext(TraceVerbosity suppressedTraceVerbosity, TraceVerbosity forcedTraceVerbosity);
    public TracingContext(TraceVerbosity suppressedTraceVerbosity, TraceVerbosity forcedTraceVerbosity, string additionalTraceDestination, string additionalTraceDestinationPrefix, bool additionalTraceAsyncUpload, TraceListener additionalTraceListener);
    public TraceVerbosity get_SuppressedTraceVerbosity();
    public TraceVerbosity get_ForcedTraceVerbosity();
    public string get_AdditionalTraceDestination();
    public string get_AdditionalTraceDestinationPrefix();
    public bool get_AdditionalTraceAsyncUpload();
    public TraceListener get_AdditionalTraceListener();
}
public class Kusto.Cloud.Platform.Utils.TranscriptLogger`1 : object {
    private T m_defaultFlavor;
    private bool m_enabled;
    private bool m_consoleEnabled;
    private Nullable`1<ConsoleColor> m_forcedColor;
    private IDictionary`2<T, ConsoleColor> m_flavorColors;
    private bool m_fileEnabled;
    private string m_filename;
    private TextWriter m_file;
    public bool Enabled { get; public set; }
    public TranscriptLogger`1(T defaultFlavor);
    public TranscriptLogger`1<T> EnableLoggingToConsole(ConsoleColor color);
    public TranscriptLogger`1<T> EnableLoggingToConsole(IDictionary`2<T, ConsoleColor> mapFlavorsToColors);
    public TranscriptLogger`1<T> EnableLoggingToFile(string filename, bool append);
    public TranscriptLogger`1<T> EnableLoggingToStream(TextWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void Write(string value);
    public sealed virtual void Write(T flavor, string value);
    public sealed virtual void Write(string format, Object[] args);
    public sealed virtual void Write(T flavor, string format, Object[] args);
    public sealed virtual void WriteLine(string value);
    public sealed virtual void WriteLine(T flavor, string value);
    public sealed virtual void WriteLine(string format, Object[] args);
    public sealed virtual void WriteLine(T flavor, string format, Object[] args);
    public sealed virtual void Flush();
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    private void WriteInternal(T flavor, string value);
}
public class Kusto.Cloud.Platform.Utils.Trie`1 : object {
    private static string c_defaultRootWord;
    private IEqualityComparer`1<string> m_comparer;
    private Func`2<string, String[]> m_tokenizer;
    private TrieNode<TValue> m_rootNode;
    private int m_count;
    public int Count { get; }
    public Trie`1(IEqualityComparer`1<string> comparer);
    public Trie`1(Func`2<string, String[]> tokenizer);
    public Trie`1(Func`2<string, String[]> tokenizer, IEqualityComparer`1<string> comparer);
    public Trie`1(IEnumerable`1<Tuple`2<string, TValue>> elements, Func`2<string, String[]> tokenizer, IEqualityComparer`1<string> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<Tuple`2<string, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(string key, TValue value);
    public void AddRange(IEnumerable`1<Tuple`2<string, TValue>> collection);
    [IteratorStateMachineAttribute("Kusto.Cloud.Platform.Utils.Trie`1/<MatchByPrefix>d__16")]
public sealed virtual IEnumerable`1<Tuple`2<string, TValue>> MatchByPrefix(string prefix);
}
[DataContractAttribute]
public class Kusto.Cloud.Platform.Utils.TriState : ValueType {
    public static TriState False;
    public static TriState True;
    public static TriState DontKnow;
    [DataMemberAttribute]
private int m_value;
    public bool IsTrue { get; }
    public bool IsFalse { get; }
    public bool IsDontKnow { get; }
    public bool IsFalseOrDontKnow { get; }
    public bool IsTrueOrDontKnow { get; }
    private static TriState();
    private static TriState FromValue(int value);
    public static TriState FromBool(bool value);
    public static TriState FromString(string value);
    public static bool TryParse(string value, TriState& triState);
    public static TriState FromResultString(string value);
    public static TriState op_Implicit(bool value);
    public static TriState op_Equality(TriState lhs, TriState rhs);
    public static TriState op_LogicalNot(TriState lhs);
    public static TriState op_Inequality(TriState lhs, TriState rhs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TriState other);
    public virtual string ToString();
    public string ToDisplayString();
    public sealed virtual void ToDumpString(ExtendedStringBuilder esb, object context);
    public bool get_IsTrue();
    public bool get_IsFalse();
    public bool get_IsDontKnow();
    public bool get_IsFalseOrDontKnow();
    public bool get_IsTrueOrDontKnow();
}
public class Kusto.Cloud.Platform.Utils.TriStateJsonConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Kusto.Cloud.Platform.Utils.TsvWriter : object {
    private TextWriter m_writer;
    private long m_bytesWritten;
    private bool m_firstField;
    public long BytesWritten { get; }
    public TsvWriter(TextWriter writer);
    public sealed virtual long get_BytesWritten();
    public sealed virtual bool WriteField(string what, bool abortOnWriteFailures);
    public sealed virtual void CompleteRecord();
    public sealed virtual void Flush();
}
public abstract class Kusto.Cloud.Platform.Utils.Tweak : object {
    private string m_name;
    private string m_description;
    private Action`1<Tweak> m_notifyChangesTo;
    public string Name { get; }
    public string Description { get; }
    public Action`1<Tweak> NotifyChangesTo { get; }
    internal Tweak(string name, string description, Action`1<Tweak> notifyChangesTo);
    public string get_Name();
    public string get_Description();
    public Action`1<Tweak> get_NotifyChangesTo();
}
public class Kusto.Cloud.Platform.Utils.Tweak`1 : Tweak {
    private T m_value;
    public T Value { get; internal set; }
    internal Tweak`1(string name, string description, Action`1<Tweak`1<T>> notifyChangesTo);
    public virtual string ToString();
    public T get_Value();
    internal void set_Value(T value);
}
public class Kusto.Cloud.Platform.Utils.Tweaks : object {
    private DefaultTraceListener m_trace;
    private object m_locker;
    private Dictionary`2<string, Tweak> m_namesToTweaks;
    private TweaksDefaults m_defaults;
    private AppSettingsInMemoryProvider m_environmentAppSettings;
    private AppSettingsInMemoryProvider m_cmdLineArgsAppSettings;
    private AppSettingsInMemoryProvider m_featureFlagsAppSettings;
    private AppSettingsInMemoryProvider m_programmaticAppSettings;
    private Dictionary`2<string, IAppSettingsProvider> m_appSettingsProviders;
    private static string c_tweaksFileExtension;
    public void TryRegisterTweaksFile(string path, string file);
    public void RegisterTweaksFile(string file);
    public void RegisterTweaksFile(Assembly assembly);
    public Tweak`1<T> RegisterTweak(string name, string description, T defaultValue);
    public Tweak`1<T> RegisterTweak(string name, string description, T defaultValue, Action`1<Tweak`1<T>> notifyChangesTo, bool notifyNow);
    public void SetProgrammaticAppSwitch(string name, string value);
    internal void SetFeatureFlagAppSwitch(string name, string value);
    public static string GetFileNameWithTweakExtension(string fileName);
    private void Trace(string format, Object[] args);
    private void RegisterEnvironmentTweaksProvider();
    private void RegisterCmdLineArgsTweaksProvider();
    internal void OnAppSettingsChanged();
    private void RegisterMandatoryTweaksFiles();
    private bool SetTweak(Tweak tweak, string value);
    private NameValueDictionary DetermineAppSettingsUnderLock();
    private List`1<Tweak> SetTweaksUnderLock(NameValueDictionary appSettings);
    private bool SetTweakUnderLock(Tweak tweak, NameValueDictionary appSettings);
    private string DetermineTweakValueUnderLock(Tweak`1<T> tweak);
    private string GetAssemblyPath(Assembly assembly);
    private void AssertLockHeld();
    private static string GetAssemblyName(Assembly assembly, bool byFileName);
}
public class Kusto.Cloud.Platform.Utils.UltraFastCsvWriter : object {
    [ThreadStaticAttribute]
private static Buffers t_buffers;
    private Stream m_stream;
    private Encoder m_encoder;
    private Buffers m_buffers;
    private Char[] m_charBuffer;
    private Byte[] m_byteBuffer;
    private int m_charPos;
    private bool m_firstField;
    [CompilerGeneratedAttribute]
private long <BytesWritten>k__BackingField;
    public long BytesWritten { get; private set; }
    public UltraFastCsvWriter(Stream stream, Encoding encoding);
    public UltraFastCsvWriter(StreamWriter writer);
    public sealed virtual bool WriteField(string what, bool abortOnWriteFailures);
    public sealed virtual void CompleteRecord();
    [CompilerGeneratedAttribute]
public sealed virtual long get_BytesWritten();
    [CompilerGeneratedAttribute]
private void set_BytesWritten(long value);
    public sealed virtual void Flush();
    private void InitBuffers();
    private void InitBuffersSlowPath();
    private void DisposeBuffers();
    private void WriteChar(char c);
    private void FlushCharBuffer(bool flushEncoder);
}
public static class Kusto.Cloud.Platform.Utils.UriEncodeUtilities : object {
    private static string c_percentReplacementUnique;
    private static string c_percent;
    private static string c_abfssScheme;
    public static string EncodeStorageSecureUri(string secureUri);
}
public static class Kusto.Cloud.Platform.Utils.UrlUtils : object {
    public static char PathSeparatorChar;
    public static string ConcatPath(string path1, string path2);
    public static string EscapeFqdnForRegex(string domainName);
    public static string GetUrlRecordName(string url, bool useSecondLevelRecordName, String& zoneName);
    public static string GetUrlRecordName(string url, String& zoneName);
    public static string GetUrlRecordName(string url, UInt32 nth, String& zoneName);
    public static string GetUrlHost(string url);
    public static string PrependPeriodIfMissing(string hostSubdomain);
    public static string CombineSubdomainNames(string subdomainNameFirst, string subdomainNameSecond);
    public static string AddIntermediateZone(string url, bool useSecondLevelRecordName, string intermediateZoneName);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsArgumentException : ArgumentException {
    public string MethodName;
    public string ArgumentName;
    public string Details;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsArgumentException(string message, Exception innerException);
    protected UtilsArgumentException(SerializationInfo info, StreamingContext context);
    public UtilsArgumentException(string methodName, string argumentName, string details, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsArgumentException(string methodName, string argumentName, string details, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsCodeGenerationException : Exception {
    public string Details;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UtilsCodeGenerationException(SerializationInfo info, StreamingContext context);
    public UtilsCodeGenerationException(string details, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsCodeGenerationException(string details, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsException : Exception {
    public string Msg;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UtilsException(SerializationInfo info, StreamingContext context);
    public UtilsException(string msg, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsException(string msg, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsFileNotFoundException : Exception {
    public string FileName;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UtilsFileNotFoundException(SerializationInfo info, StreamingContext context);
    public UtilsFileNotFoundException(string fileName, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsFileNotFoundException(string fileName, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsInvalidOperationException : InvalidOperationException {
    public string MethodName;
    public string ObjectType;
    public string ObjectName;
    public string ObjectState;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsInvalidOperationException(string message, Exception innerException);
    protected UtilsInvalidOperationException(SerializationInfo info, StreamingContext context);
    public UtilsInvalidOperationException(string methodName, string objectType, string objectName, string objectState, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsInvalidOperationException(string methodName, string objectType, string objectName, string objectState, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsIOException : IOException {
    public int Hresult;
    public string Description;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsIOException(string message, Exception innerException);
    protected UtilsIOException(SerializationInfo info, StreamingContext context);
    public UtilsIOException(int hresult, string description, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsIOException(int hresult, string description, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsJsonReaderException : JsonReaderException {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsJsonReaderException(string message, Exception innerException);
    protected UtilsJsonReaderException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsKeyAlreadyDefinedException : ArgumentException {
    public string KeyValue;
    public string KeyType;
    public string Collection;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsKeyAlreadyDefinedException(string message, Exception innerException);
    protected UtilsKeyAlreadyDefinedException(SerializationInfo info, StreamingContext context);
    public UtilsKeyAlreadyDefinedException(string keyValue, string keyType, string collection, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsKeyAlreadyDefinedException(string keyValue, string keyType, string collection, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsKeyNotFoundException : KeyNotFoundException {
    public string KeyValue;
    public string KeyType;
    public string Collection;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsKeyNotFoundException(string message, Exception innerException);
    protected UtilsKeyNotFoundException(SerializationInfo info, StreamingContext context);
    public UtilsKeyNotFoundException(string keyValue, string keyType, string collection, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsKeyNotFoundException(string keyValue, string keyType, string collection, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsNotImplementedException : NotImplementedException {
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public UtilsNotImplementedException(string message, Exception innerException);
    protected UtilsNotImplementedException(SerializationInfo info, StreamingContext context);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsNotSupportedException : NotSupportedException {
    public string Operation;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UtilsNotSupportedException(SerializationInfo info, StreamingContext context);
    public UtilsNotSupportedException(string operation, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsNotSupportedException(string operation, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.UtilsObjectDisposedException : ObjectDisposedException {
    public string MethodName;
    public string ObjectType;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    protected UtilsObjectDisposedException(SerializationInfo info, StreamingContext context);
    public UtilsObjectDisposedException(string methodName, string objectType, string objectName, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public UtilsObjectDisposedException(string methodName, string objectType, string objectName, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class Kusto.Cloud.Platform.Utils.UtilsStringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    private static int DEFAULT_CAPACITY;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static StringBuilder Acquire(string value);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
    public static string GetStringAndClear(StringBuilder sb);
}
internal class Kusto.Cloud.Platform.Utils.UtilsTrace : TraceSourceBase`1<UtilsTrace> {
    public static string IdentifierString;
    public string Id { get; }
    public TraceVerbosity DefaultVerbosity { get; }
    public virtual string get_Id();
    public virtual TraceVerbosity get_DefaultVerbosity();
}
public static class Kusto.Cloud.Platform.Utils.ValueOrException : object {
    public static ValueOrException`1<T> FromException(Exception exception);
    public static ValueOrException`1<T> FromValue(T value);
}
public class Kusto.Cloud.Platform.Utils.ValueOrException`1 : object {
    private T m_value;
    private ExceptionDispatchInfo m_exceptionDispatchInfo;
    private bool m_hasValue;
    public bool HasValue { get; }
    public T Value { get; }
    public T ValueOrDefault { get; }
    internal ValueOrException`1(T value);
    internal ValueOrException`1(Exception exception);
    public bool get_HasValue();
    public T get_Value();
    public T get_ValueOrDefault();
}
public class Kusto.Cloud.Platform.Utils.VoidDisposable : object {
    public static VoidDisposable Instance;
    private static VoidDisposable();
    public sealed virtual void Dispose();
}
public class Kusto.Cloud.Platform.Utils.VoidThrottlerPolicy : MaxConcurrentCallsThrottlerPolicy {
    public VoidThrottlerPolicy(string resourceKind, string resourceId, Action`2<ResourceUtilizationMeasure, bool> onChange);
}
internal class Kusto.Cloud.Platform.Utils.WaitableStopLock : object {
    private StopLock m_stopLock;
    private object m_lock;
    private List`1<EventWaitHandle> m_notificationHandles;
    private bool m_stopCompleted;
    public bool TryEnter();
    public void Leave();
    public void Stop(EventWaitHandle notificationHandle);
    private void OnStopCompleted();
}
public static class Kusto.Cloud.Platform.Utils.WatchdogTimer : object {
    public static Task`1<TResult> InvokeWithTimeoutAsync(string description, Func`1<TResult> body, TimeSpan timeout, Action onTimeout, Action`1<TResult> onResultAbandoned);
    [AsyncStateMachineAttribute("Kusto.Cloud.Platform.Utils.WatchdogTimer/<InvokeWithTimeoutAsync>d__1`1")]
public static Task`1<TResult> InvokeWithTimeoutAsync(string description, Func`1<Task`1<TResult>> body, TimeSpan timeout, Action onTimeout, Action`1<TResult> onResultAbandoned);
    public static void InvokeWithTimeout(string description, Action body, TimeSpan timeout, Action onTimeout);
    public static TResult InvokeWithTimeout(string description, Func`1<TResult> body, TimeSpan timeout, Action onTimeout, Action`1<TResult> onResultAbadoned);
    private static void InvokeBody(object context);
    private static void InvokeBody(object context);
}
[GeneratedCodeAttribute("CloudPlatformException", "4.5.0.0")]
public class Kusto.Cloud.Platform.Utils.WatchdogTimerTimeoutException : TimeoutException {
    public string Action;
    public TimeSpan Timeout;
    protected string creationMessage;
    protected bool alreadyTraced;
    protected CreationContext creationContext;
    protected string creationContextStr;
    [CompilerGeneratedAttribute]
private int <FailureCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureSubCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPermanent>k__BackingField;
    public CreationContext CreationContext { get; }
    public int FailureCode { get; protected set; }
    public string FailureSubCode { get; protected set; }
    public bool IsPermanent { get; protected set; }
    public bool AlreadyTraced { get; }
    public string Message { get; }
    public WatchdogTimerTimeoutException(string message, Exception innerException);
    protected WatchdogTimerTimeoutException(SerializationInfo info, StreamingContext context);
    public WatchdogTimerTimeoutException(string action, TimeSpan timeout, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public WatchdogTimerTimeoutException(string action, TimeSpan timeout, Exception innerException, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    public sealed virtual CreationContext get_CreationContext();
    [CompilerGeneratedAttribute]
public virtual int get_FailureCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureCode(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FailureSubCode();
    [CompilerGeneratedAttribute]
protected virtual void set_FailureSubCode(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPermanent();
    [CompilerGeneratedAttribute]
protected virtual void set_IsPermanent(bool value);
    private void Construct(bool deserializing, Nullable`1<int> failureCode, string failureSubCode, Nullable`1<bool> isPermanent);
    private void Construct_Debugger();
    private void Construct_IsPermanent(Nullable`1<bool> isPermanent, int failureCode);
    private void Construct_ExceptionCreationContext(bool deserializing);
    private void Construct_Trace();
    public virtual bool get_AlreadyTraced();
    public virtual string get_Message();
    private string CreateMessageFromTemplate();
    public virtual string ToString();
    public virtual void WriteToStringTo(StringBuilder sb);
    public virtual void WritePropertiesTo(StringBuilder sb);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DataContractAttribute]
[FlagsAttribute]
public enum Kusto.Cloud.Platform.Utils.WeekDay : Enum {
    public int value__;
    [EnumMemberAttribute]
public static WeekDay None;
    [EnumMemberAttribute]
public static WeekDay Sunday;
    [EnumMemberAttribute]
public static WeekDay Monday;
    [EnumMemberAttribute]
public static WeekDay Tuesday;
    [EnumMemberAttribute]
public static WeekDay Wednesday;
    [EnumMemberAttribute]
public static WeekDay Thursday;
    [EnumMemberAttribute]
public static WeekDay Friday;
    [EnumMemberAttribute]
public static WeekDay Saturday;
}
public static class Kusto.Cloud.Platform.Utils.WeekDayConverter : object {
    private static Dictionary`2<DayOfWeek, WeekDay> s_dayOfWeekToWeekDay;
    private static WeekDayConverter();
    public static WeekDay FromDayOfWeek(DayOfWeek dayOfWeek);
    public static WeekDay FromDaysOfWeek(IEnumerable`1<DayOfWeek> dayOfWeek);
    public static IEnumerable`1<DayOfWeek> ToDaysOfWeek(WeekDay weekDay);
}
public class Kusto.Cloud.Platform.Utils.WildcardPatternMatcher : object {
    private string m_pattern;
    private Regex m_matchingRegex;
    private static Regex s_wildcardRegex;
    private static Regex s_escapeCharacters;
    private static string c_startDelimeter;
    private static string c_endDelimeter;
    public WildcardPatternMatcher(string pattern, bool ignoreCase);
    private static WildcardPatternMatcher();
    public bool IsMatch_WithSystemObjectsTweak(string str);
    public bool IsMatch(string str);
    public static bool IsWildcardPattern(string pattern);
    public static string ReplaceKustoDelimeters(string pattern);
    public static string ConvertWildcardToRegexPattern(string pattern, bool isCaseSensitive, bool useStartDelimeter, bool useEndDelimeter);
    private bool IsMatchImpl(string str, bool systemObjectsTweak);
}
public class Kusto.Cloud.Platform.Utils.WorkTicket : object {
    private WorkTicketFactory m_factory;
    private long m_id;
    private IIdentifiable m_owningEntity;
    private bool m_disposed;
    private object m_context;
    private bool m_tracked;
    private bool m_detectLeaks;
    private ExtendedCallStack m_creationCallStack;
    private string m_description;
    public long Id { get; }
    public IIdentifiable OwningEntity { get; }
    public object Context { get; public set; }
    public WorkTicketFactory WorkTicketFactory { get; }
    public string DisplayName { get; }
    internal bool Tracked { get; }
    internal ExtendedCallStack CreationCallStack { get; }
    internal string Description { get; }
    public WorkTicket(string description);
    public bool IsValid();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public long get_Id();
    public IIdentifiable get_OwningEntity();
    public object get_Context();
    public void set_Context(object value);
    public WorkTicketFactory get_WorkTicketFactory();
    public virtual string get_DisplayName();
    public virtual string ToString();
    internal bool get_Tracked();
    internal ExtendedCallStack get_CreationCallStack();
    internal string get_Description();
    internal void Init(WorkTicketFactory workTicketFactory, long workTicketId, IIdentifiable owner, bool isTracked, bool detectLeaks, bool captureStack);
    protected virtual void OnWorkTicketInitialized();
}
public class Kusto.Cloud.Platform.Utils.WorkTicketFactory : object {
    public static string LeakDetectionEnabledTweakName;
    public static string TrackTicketsTweakName;
    public static string CaptureTicketsCallStackTweakName;
    private string m_name;
    private object m_locker;
    private bool m_active;
    private bool m_canBeActivated;
    private long m_numPendingWorkTickets;
    private long m_nextId;
    private bool m_trackTickets;
    private bool m_traceTickets;
    private bool m_captureTicketsCallStack;
    private Dictionary`2<long, WorkTicket> m_pendingWorkTickets;
    private string m_creationCallStackString;
    private static Tweak`1<bool> sm_leakDetectionEnabledTweak;
    private static Tweak`1<bool> sm_trackTicketsTweak;
    private static Tweak`1<bool> sm_captureTicketsCallStackTweak;
    [CompilerGeneratedAttribute]
private bool <TraceTickets>k__BackingField;
    public string Name { get; }
    public bool TrackTickets { get; public set; }
    private bool TraceTickets { get; private set; }
    public bool CaptureTicketsCallStack { get; public set; }
    public string CreationCallStackString { get; }
    public long NumPendingWorkTickets { get; }
    public WorkTicketFactory(string name);
    public WorkTicketFactory(string name, bool initiallyActive, bool trackTickets, bool captureTicketsCallStack, bool traceTickets);
    private static WorkTicketFactory();
    public sealed virtual string get_Name();
    public bool get_TrackTickets();
    public void set_TrackTickets(bool value);
    [CompilerGeneratedAttribute]
private bool get_TraceTickets();
    [CompilerGeneratedAttribute]
private void set_TraceTickets(bool value);
    public bool get_CaptureTicketsCallStack();
    public void set_CaptureTicketsCallStack(bool value);
    public IEnumerable`1<WorkTicket> EnumeratePendingTickets(int maxOfTickets);
    public IEnumerable`1<WorkTicket> EnumeratePendingTickets(IIdentifiable owningEntity);
    public void Start();
    public void NonFinalStop();
    public bool SleepIfNotStopped(TimeSpan duration);
    public string get_CreationCallStackString();
    public sealed virtual void Stop();
    public sealed virtual void WaitForStopToComplete();
    public void WaitForStopToCompleteOrCrash(int timeout, Action`1<WorkTicketFactory> invokeOnTimeout, string userMessage);
    public sealed virtual void Shutdown();
    public sealed virtual long get_NumPendingWorkTickets();
    public sealed virtual WorkTicket TryCreateWorkTicket(IIdentifiable owningEntity, string description);
    public sealed virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, string description);
    public sealed virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    public sealed virtual bool TryCreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    private bool InitWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    internal void OnWorkTicketDisposed(WorkTicket ticket);
}
public class Kusto.Cloud.Platform.Utils.WorkTicketFactorySlim : object {
    private string m_name;
    private int m_stopped;
    private static int NotStopped;
    private static int YesStopped;
    private long m_numPendingWorkTickets;
    private static long Stopping;
    private static long Stopped;
    private static long ShuttedDown;
    private static long MaxConcurrentTickets;
    private WorkTicketSlim m_workTicket;
    public string Name { get; }
    public long NumPendingWorkTickets { get; }
    public WorkTicketFactorySlim(string name);
    public sealed virtual string get_Name();
    public sealed virtual long get_NumPendingWorkTickets();
    public sealed virtual WorkTicket TryCreateWorkTicket(IIdentifiable owningEntity, string description);
    public sealed virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, string description);
    public sealed virtual WorkTicket CreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    public sealed virtual bool TryCreateWorkTicket(IIdentifiable owningEntity, WorkTicket ticket);
    public sealed virtual void Stop();
    public sealed virtual void WaitForStopToComplete();
    public sealed virtual void Shutdown();
    private void OnWorkTicketDisposed();
}
public class Kusto.Cloud.Platform.Utils.WriteStreamsCartridge : StreamChainBase {
    public WriteStreamsCartridge(Context creationContext, string id);
    public void Reload(Stream inner);
}
public static class Kusto.Cloud.Platform.Utils.XxHash : object {
    private static ulong prime64v1;
    private static ulong prime64v2;
    private static ulong prime64v3;
    private static ulong prime64v4;
    private static ulong prime64v5;
    private static UInt32 prime32v1;
    private static UInt32 prime32v2;
    private static UInt32 prime32v3;
    private static UInt32 prime32v4;
    private static UInt32 prime32v5;
    public static UInt32 Hash32(Byte[] buffer, UInt32 seed);
    public static UInt32 Hash32(Byte* inputPtr, int len, UInt32 seed);
    public static ulong Hash64(Byte[] buffer, ulong seed);
    public static ulong Hash64(Byte* inputPtr, int len, ulong seed);
    private static ValueTuple`4<ulong, ulong, ulong, ulong> InitAccumulators64(ulong seed);
    private static ulong ProcessStripe64(Byte*& pInput, UInt64& acc1, UInt64& acc2, UInt64& acc3, UInt64& acc4, bool bigEndian);
    private static void ProcessLane64(UInt64& accn, Byte*& pInput);
    private static void ProcessLaneBigEndian64(UInt64& accn, Byte*& pInput);
    private static ulong ProcessRemaining64(Byte* pInput, ulong acc, int remainingLen, bool bigEndian);
    private static ulong Avalanche64(ulong acc);
    private static ulong Round64(ulong accn, ulong lane);
    private static void MergeAccumulator64(UInt64& acc, ulong accn);
    private static ValueTuple`4<UInt32, UInt32, UInt32, UInt32> InitAccumulators32(UInt32 seed);
    private static UInt32 ProcessStripe32(Byte*& pInput, UInt32& acc1, UInt32& acc2, UInt32& acc3, UInt32& acc4, bool bigEndian);
    private static void ProcessLane32(Byte*& pInput, UInt32& accn);
    private static void ProcessLaneBigEndian32(Byte*& pInput, UInt32& accn);
    private static UInt32 ProcessRemaining32(Byte* pInput, UInt32 acc, int remainingLen, bool bigEndian);
    private static UInt32 Round32(UInt32 accn, UInt32 lane);
    private static UInt32 Avalanche32(UInt32 acc);
}
public class Kusto.Cloud.Platform.Utils.ZipArchiveEntryStream : StreamChainBase {
    private ZipArchive m_zipArchive;
    public ITraceSource Tracer { get; public set; }
    public Context IoContext { get; public set; }
    private ZipArchiveEntryStream(ZipArchiveMode mode, Stream zipStream, string entryName, string zipStreamId, bool leaveOpen);
    public static ZipArchiveEntryStream OpenForRead(Stream zipStream, string zipStreamId, bool leaveOpen);
    public static ZipArchiveEntryStream OpenForWrite(Stream zipStream, string entryName, string zipStreamId, bool leaveOpen);
    public ITraceSource get_Tracer();
    public void set_Tracer(ITraceSource value);
    public Context get_IoContext();
    public void set_IoContext(Context value);
    private static string GetId(string zipStreamId);
    protected virtual void OnDisposed();
}
public class Kusto.DataNode.Common.UniqueIncrementingTimestampProvider : object {
    private object m_lock;
    private DateTime m_lastRead;
    public DateTime GetUniqueTimestamp();
}
[DefaultMemberAttribute("Item")]
public class System.Data.DataTableReader2 : DbDataReader {
    private DataTable[] tables;
    private bool isOpen;
    private DataTable schemaTable;
    private int tableCounter;
    private int rowCounter;
    private DataTable currentDataTable;
    private DataRow currentDataRow;
    private bool hasRows;
    private bool reachEORows;
    private bool currentRowRemoved;
    private bool schemaIsChanged;
    private bool started;
    private bool readerIsInvalid;
    private DataTableReaderListener listener;
    private bool tableCleared;
    private bool ReaderIsInvalid { get; private set; }
    private bool IsSchemaChanged { get; private set; }
    internal DataTable CurrentDataTable { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public bool HasRows { get; }
    public object Item { get; }
    public object Item { get; }
    public int FieldCount { get; }
    public DataTableReader2(DataTable dataTable);
    public DataTableReader2(DataTable[] dataTables);
    private bool get_ReaderIsInvalid();
    private void set_ReaderIsInvalid(bool value);
    private bool get_IsSchemaChanged();
    private void set_IsSchemaChanged(bool value);
    internal DataTable get_CurrentDataTable();
    private void init();
    public virtual void Close();
    public virtual DataTable GetSchemaTable();
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual int get_Depth();
    public virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
    public virtual bool get_HasRows();
    public virtual object get_Item(int ordinal);
    public virtual object get_Item(string name);
    public virtual int get_FieldCount();
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual bool GetBoolean(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual long GetBytes(int ordinal, long dataIndex, Byte[] buffer, int bufferIndex, int length);
    public virtual char GetChar(int ordinal);
    public virtual long GetChars(int ordinal, long dataIndex, Char[] buffer, int bufferIndex, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual Type GetFieldType(int ordinal);
    public virtual float GetFloat(int ordinal);
    public virtual Guid GetGuid(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual string GetString(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int ordinal);
    public virtual IEnumerator GetEnumerator();
    public static DataTable GetSchemaTableFromDataTable(DataTable table);
    private void ValidateOpen(string caller);
    private void ValidateReader();
    private void ValidateState(string caller);
    private void ValidateRow(int rowPosition);
    internal void SchemaChanged();
    internal void DataTableCleared();
    internal void DataChanged(DataRowChangeEventArgs args);
}
[ExtensionAttribute]
public static class System.Diagnostics.ExtendedTraceEventType : object {
    [ExtensionAttribute]
public static string FastToString(TraceEventType that);
    public static bool FastIsDefined(string value);
    public static bool FastIsDefined(int value);
    [ExtensionAttribute]
public static bool FastHasFlag(TraceEventType that, int flag);
    [ExtensionAttribute]
public static bool FastHasFlag(TraceEventType that, TraceEventType flag);
    public static TraceEventType FastParse(string value, bool ignoreCase, bool ignoreInts);
    public static bool FastTryParse(string value, TraceEventType& ret, bool ignoreCase, bool ignoreInts);
    [ExtensionAttribute]
public static int FastGetHashCode(TraceEventType that);
    [ExtensionAttribute]
public static string FastGetDescription(TraceEventType that);
}
internal class System.Web.HttpUtility : object {
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(string s);
    public static string HtmlEncode(object value);
    public static void HtmlEncode(string s, TextWriter output);
    public static string HtmlAttributeEncode(string s);
    public static void HtmlAttributeEncode(string s, TextWriter output);
    public static string UrlEncode(string str);
    public static string UrlPathEncode(string str);
    public static string UrlEncode(string str, Encoding e);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    [ObsoleteAttribute("This method produces non-standards-compliant output and has interoperability issues. The preferred alternative is UrlEncodeToBytes(String).")]
public static Byte[] UrlEncodeUnicodeToBytes(string str);
    public static string UrlDecode(string str);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    [ObsoleteAttribute("This method produces non-standards-compliant output and has interoperability issues. The preferred alternative is UrlEncode(String).")]
public static string UrlEncodeUnicode(string str);
    public static string UrlDecode(string str, Encoding e);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string JavaScriptStringEncode(string value);
    public static string JavaScriptStringEncode(string value, bool addDoubleQuotes);
}
internal static class System.Web.Util.HttpEncoder : object {
    private static void AppendCharAsUnicodeJavaScript(StringBuilder builder, char c);
    private static bool CharRequiresJavaScriptEncoding(char c);
    internal static string HtmlAttributeEncode(string value);
    internal static void HtmlAttributeEncode(string value, TextWriter output);
    private static void HtmlAttributeEncodeInternal(string s, TextWriter output);
    internal static string HtmlDecode(string value);
    internal static void HtmlDecode(string value, TextWriter output);
    internal static string HtmlEncode(string value);
    internal static void HtmlEncode(string value, TextWriter output);
    private static int IndexOfHtmlAttributeEncodingChars(string s, int startPos);
    private static bool IsNonAsciiByte(byte b);
    internal static string JavaScriptStringEncode(string value);
    internal static Byte[] UrlDecode(Byte[] bytes, int offset, int count);
    internal static string UrlDecode(Byte[] bytes, int offset, int count, Encoding encoding);
    internal static string UrlDecode(string value, Encoding encoding);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static string UrlEncodeNonAscii(string str, Encoding e);
    private static Byte[] UrlEncodeNonAscii(Byte[] bytes, int offset, int count);
    [ObsoleteAttribute("This method produces non-standards-compliant output and has interoperability issues. The preferred alternative is UrlEncode(*).")]
internal static string UrlEncodeUnicode(string value);
    internal static string UrlPathEncode(string value);
    private static string UrlPathEncodeImpl(string value);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
internal static class System.Web.Util.HttpEncoderUtility : object {
    public static int HexToInt(char h);
    public static char IntToHex(int n);
    public static bool IsUrlSafeChar(char ch);
    internal static string UrlEncodeSpaces(string str);
}
internal static class System.Web.Util.UriUtil : object {
    private static Char[] s_queryFragmentSeparators;
    private static UriUtil();
    private static void ExtractQueryAndFragment(string input, String& path, String& queryAndFragment);
    internal static bool TrySplitUriForPathEncode(string input, String& schemeAndAuthority, String& path, String& queryAndFragment);
}
internal static class System.Web.Util.Utf16StringValidator : object {
    private static char UnicodeReplacementChar;
    internal static string ValidateString(string input);
}
