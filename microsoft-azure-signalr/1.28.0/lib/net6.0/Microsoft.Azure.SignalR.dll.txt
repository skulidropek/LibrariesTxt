[ExtensionAttribute]
public static class Microsoft.AspNetCore.Builder.AzureSignalRApplicationBuilderExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("IApplicationBuilder.UseAzureSignalR is obsoleted, please use IApplicationBuilder.UseEndpoints() instead.")]
public static IApplicationBuilder UseAzureSignalR(IApplicationBuilder app, Action`1<ServiceRouteBuilder> configure);
}
internal static class Microsoft.Azure.SignalR.AuthorizeHelper : object {
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.AuthorizeHelper/<AuthorizeAsync>d__0")]
public static Task`1<bool> AuthorizeAsync(HttpContext context, IList`1<IAuthorizeData> policies);
    public static List`1<IAuthorizeData> BuildAuthorizePolicy(Type hub);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.AzureSignalRConnectionBuilderExtensions : object {
    private static MethodInfo _useHubMethod;
    private static AzureSignalRConnectionBuilderExtensions();
    [ExtensionAttribute]
public static IConnectionBuilder UseHub(IConnectionBuilder builder, Type hubType);
}
internal class Microsoft.Azure.SignalR.AzureSignalRHostedService : object {
    private EndpointDataSource _dataSource;
    private IServiceProvider _serviceProvider;
    public AzureSignalRHostedService(EndpointDataSource dataSource, IServiceProvider serviceProvider);
    public void Start();
}
internal class Microsoft.Azure.SignalR.AzureSignalRHostingStartup : object {
    public sealed virtual void Configure(IWebHostBuilder builder);
}
internal class Microsoft.Azure.SignalR.AzureSignalRMarkerService : object {
    [CompilerGeneratedAttribute]
private bool <IsConfigured>k__BackingField;
    internal bool IsConfigured { get; internal set; }
    [CompilerGeneratedAttribute]
internal void set_IsConfigured(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsConfigured();
}
internal class Microsoft.Azure.SignalR.AzureSignalRStartupFilter : object {
    public sealed virtual Action`1<IApplicationBuilder> Configure(Action`1<IApplicationBuilder> build);
}
internal class Microsoft.Azure.SignalR.ClientConnectionContext : ConnectionContext {
    private static int WritingState;
    private static int CompletedState;
    private static int IdleState;
    private static PipeOptions DefaultPipeOptions;
    private TaskCompletionSource`1<object> _connectionEndTcs;
    private TaskCompletionSource`1<object> _hanshakeCompleteTcs;
    private CancellationTokenSource _abortOutgoingCts;
    private object _heartbeatLock;
    private SemaphoreSlim _writeLock;
    private Queue`1<IMemoryOwner`1<byte>> _bufferedMessages;
    private int _closeTimeOutMilliseconds;
    private bool _isMigrated;
    private PauseHandler _pauseHandler;
    private int _connectionState;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Action`1<object>, object>> _heartbeatHandlers;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _abortOnClose;
    private long _lastMessageReceivedAt;
    private long _receivedBytes;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceConnection <ServiceConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HubProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpContext <HttpContext>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedAtUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger`1<ServiceConnection> <Logger>k__BackingField;
    public string ConnectionId { get; public set; }
    public string InstanceId { get; }
    public IServiceConnection ServiceConnection { get; public set; }
    public string HubProtocol { get; }
    public bool AbortOnClose { get; public set; }
    public IFeatureCollection Features { get; }
    public IDictionary`2<object, object> Items { get; public set; }
    public IDuplexPipe Transport { get; public set; }
    public IDuplexPipe Application { get; public set; }
    public ClaimsPrincipal User { get; public set; }
    public Task LifetimeTask { get; }
    public Task HandshakeResponseTask { get; }
    public HttpContext HttpContext { get; public set; }
    public DateTime LastMessageReceivedAtUtc { get; }
    public DateTime StartedAtUtc { get; }
    public long ReceivedBytes { get; }
    public ILogger`1<ServiceConnection> Logger { get; public set; }
    private Task DelayTask { get; }
    private CancellationToken OutgoingAborted { get; }
    public ClientConnectionContext(OpenConnectionMessage serviceMessage, Action`1<HttpContext> configureContext, PipeOptions transportPipeOptions, PipeOptions appPipeOptions, int closeTimeOutMilliseconds);
    private static ClientConnectionContext();
    [CompilerGeneratedAttribute]
public virtual string get_ConnectionId();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceId();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceConnection get_ServiceConnection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServiceConnection(IServiceConnection value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HubProtocol();
    public bool get_AbortOnClose();
    public void set_AbortOnClose(bool value);
    [CompilerGeneratedAttribute]
public virtual IFeatureCollection get_Features();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<object, object> get_Items();
    [CompilerGeneratedAttribute]
public virtual void set_Items(IDictionary`2<object, object> value);
    [CompilerGeneratedAttribute]
public virtual IDuplexPipe get_Transport();
    [CompilerGeneratedAttribute]
public virtual void set_Transport(IDuplexPipe value);
    [CompilerGeneratedAttribute]
public IDuplexPipe get_Application();
    [CompilerGeneratedAttribute]
public void set_Application(IDuplexPipe value);
    [CompilerGeneratedAttribute]
public sealed virtual ClaimsPrincipal get_User();
    [CompilerGeneratedAttribute]
public sealed virtual void set_User(ClaimsPrincipal value);
    public Task get_LifetimeTask();
    public Task get_HandshakeResponseTask();
    [CompilerGeneratedAttribute]
public sealed virtual HttpContext get_HttpContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HttpContext(HttpContext value);
    public sealed virtual DateTime get_LastMessageReceivedAtUtc();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartedAtUtc();
    public sealed virtual long get_ReceivedBytes();
    [CompilerGeneratedAttribute]
public ILogger`1<ServiceConnection> get_Logger();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Logger(ILogger`1<ServiceConnection> value);
    private Task get_DelayTask();
    private CancellationToken get_OutgoingAborted();
    public void CompleteIncoming();
    public void OnCompleted();
    public sealed virtual void OnHeartbeat(Action`1<object> action, object state);
    public void TickHeartbeat();
    public void CancelOutgoing(bool wait);
    public sealed virtual Task PauseAsync();
    public sealed virtual Task PauseAckAsync();
    public sealed virtual Task ResumeAsync();
    internal static bool TryGetRemoteIpAddress(IHeaderDictionary headers, IPAddress& address);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<ProcessOutgoingMessagesAsync>d__88")]
internal Task ProcessOutgoingMessagesAsync(IHubProtocol protocol);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<ProcessApplicationAsync>d__89")]
internal Task ProcessApplicationAsync(ConnectionDelegate connectionDelegate);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<PerformDisconnectAsync>d__90")]
internal Task PerformDisconnectAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<ProcessConnectionDataMessageAsync>d__91")]
internal Task ProcessConnectionDataMessageAsync(ConnectionDataMessage connectionDataMessage);
    internal void ClearBufferedMessages();
    private static void ProcessQuery(string queryString, String& originalPath);
    private static void SetCurrentThreadCulture(string cultureName);
    private static void SetCurrentThreadUiCulture(string uiCultureName);
    private static string GetInstanceId(IDictionary`2<string, StringValues> header);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<ForwardMessage>d__97")]
private Task`1<ForwardMessageResult> ForwardMessage(ConnectionDataMessage data);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<WriteToApplicationAsync>d__98")]
private Task WriteToApplicationAsync(ReadOnlySequence`1<byte> payload);
    private FeatureCollection BuildFeatures(OpenConnectionMessage serviceMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionContext/<WriteMessageAsyncCore>d__100")]
private Task WriteMessageAsyncCore(ReadOnlySequence`1<byte> payload);
    private DefaultHttpContext BuildHttpContext(OpenConnectionMessage message);
}
internal class Microsoft.Azure.SignalR.ClientConnectionFactory : object {
    private ILogger`1<ServiceConnection> _logger;
    private int _closeTimeOutMilliseconds;
    public ClientConnectionFactory(ILoggerFactory loggerFactory, int closeTimeOutMilliseconds);
    public sealed virtual IClientConnection CreateConnection(OpenConnectionMessage message, Action`1<HttpContext> configureContext);
}
internal class Microsoft.Azure.SignalR.ClientConnectionManager : object {
    private ConcurrentDictionary`2<string, IClientConnection> _clientConnections;
    public IEnumerable`1<IClientConnection> ClientConnections { get; }
    public int Count { get; }
    [IteratorStateMachineAttribute("Microsoft.Azure.SignalR.ClientConnectionManager/<get_ClientConnections>d__2")]
public sealed virtual IEnumerable`1<IClientConnection> get_ClientConnections();
    public sealed virtual int get_Count();
    public sealed virtual bool TryAddClientConnection(IClientConnection connection);
    public sealed virtual bool TryRemoveClientConnection(string connectionId, IClientConnection& connection);
    public sealed virtual bool TryGetClientConnection(string connectionId, IClientConnection& connection);
    public sealed virtual Task WhenAllCompleted();
}
internal class Microsoft.Azure.SignalR.Common.ExactSizeMemoryPool : MemoryPool`1<byte> {
    [CompilerGeneratedAttribute]
private static ExactSizeMemoryPool <Shared>k__BackingField;
    public static ExactSizeMemoryPool Shared { get; }
    public int MaxBufferSize { get; }
    private static ExactSizeMemoryPool();
    [CompilerGeneratedAttribute]
public static ExactSizeMemoryPool get_Shared();
    public virtual int get_MaxBufferSize();
    public virtual IMemoryOwner`1<byte> Rent(int size);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Azure.SignalR.ConnectionMigrationFeature : object {
    [CompilerGeneratedAttribute]
private string <MigrateTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MigrateFrom>k__BackingField;
    public string MigrateTo { get; private set; }
    public string MigrateFrom { get; private set; }
    public ConnectionMigrationFeature(string from, string to);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MigrateTo();
    [CompilerGeneratedAttribute]
private void set_MigrateTo(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MigrateFrom();
    [CompilerGeneratedAttribute]
private void set_MigrateFrom(string value);
}
internal class Microsoft.Azure.SignalR.DefaultEndpointRouter : DefaultMessageRouter {
    public sealed virtual ServiceEndpoint GetNegotiateEndpoint(HttpContext context, IEnumerable`1<ServiceEndpoint> endpoints);
    private ServiceEndpoint[] GetNegotiateEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
    private ServiceEndpoint GetEndpointAccordingToWeight(ServiceEndpoint[] availableEndpoints);
}
internal class Microsoft.Azure.SignalR.DefaultHubMessageSerializer : object {
    private Dictionary`2<string, IHubProtocol> _hubProtocols;
    public DefaultHubMessageSerializer(IHubProtocolResolver hubProtocolResolver, IList`1<string> globalSupportedProtocols, IList`1<string> hubSupportedProtocols);
    public IReadOnlyList`1<SerializedMessage> SerializeMessage(HubMessage message);
    public ReadOnlyMemory`1<byte> SerializeMessage(string protocol, HubMessage message);
}
internal class Microsoft.Azure.SignalR.DefaultServiceEndpointGenerator : object {
    private static string ClientPath;
    private static string ServerPath;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AudienceBaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerEndpoint>k__BackingField;
    public string Version { get; }
    public string AudienceBaseUrl { get; }
    public string ClientEndpoint { get; }
    public string ServerEndpoint { get; }
    public DefaultServiceEndpointGenerator(ServiceEndpoint endpoint);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_AudienceBaseUrl();
    [CompilerGeneratedAttribute]
public string get_ClientEndpoint();
    [CompilerGeneratedAttribute]
public string get_ServerEndpoint();
    public sealed virtual string GetClientAudience(string hubName, string applicationName);
    public sealed virtual string GetClientEndpoint(string hubName, string applicationName, string originalPath, string queryString);
    public sealed virtual string GetServerAudience(string hubName, string applicationName);
    public sealed virtual string GetServerEndpoint(string hubName, string applicationName);
    private string GetPrefixedHubName(string applicationName, string hubName);
    private string InternalGetUri(string path, string hubName, string applicationName, string target);
}
public class Microsoft.Azure.SignalR.EndpointRouterDecorator : object {
    private IEndpointRouter _inner;
    public EndpointRouterDecorator(IEndpointRouter router);
    public virtual ServiceEndpoint GetNegotiateEndpoint(HttpContext context, IEnumerable`1<ServiceEndpoint> endpoints);
    public virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForBroadcast(IEnumerable`1<ServiceEndpoint> endpoints);
    public virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForConnection(string connectionId, IEnumerable`1<ServiceEndpoint> endpoints);
    public virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForGroup(string groupName, IEnumerable`1<ServiceEndpoint> endpoints);
    public virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForUser(string userId, IEnumerable`1<ServiceEndpoint> endpoints);
}
internal class Microsoft.Azure.SignalR.FakeBlazorPackHubProtocol : object {
    private static HubMessage Invocation;
    private static HubMessage Close;
    private static HubMessage Data;
    internal static IHubProtocol Instance;
    public string Name { get; }
    public TransferFormat TransferFormat { get; }
    public int Version { get; }
    private static FakeBlazorPackHubProtocol();
    public sealed virtual string get_Name();
    public sealed virtual TransferFormat get_TransferFormat();
    public sealed virtual int get_Version();
    public sealed virtual ReadOnlyMemory`1<byte> GetMessageBytes(HubMessage message);
    public sealed virtual bool IsVersionSupported(int version);
    public sealed virtual bool TryParseMessage(ReadOnlySequence`1& input, IInvocationBinder binder, HubMessage& message);
    public sealed virtual void WriteMessage(HubMessage message, IBufferWriter`1<byte> output);
}
public class Microsoft.Azure.SignalR.GracefulShutdownOptions : object {
    private Dictionary`2<string, List`1<object>> _dict;
    [CompilerGeneratedAttribute]
private GracefulShutdownMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public GracefulShutdownMode Mode { get; public set; }
    public TimeSpan Timeout { get; public set; }
    [CompilerGeneratedAttribute]
public GracefulShutdownMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(GracefulShutdownMode value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(TimeSpan value);
    public void Add(Func`2<IHubContext`1<THub>, Task> func);
    public void Add(Action`1<IHubContext`1<THub>> action);
    public void Add(Func`1<Task> func);
    public void Add(Action action);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.GracefulShutdownOptions/<OnShutdown>d__13`1")]
internal Task OnShutdown(IHubContext`1<THub> context);
    private void AddMethod(object method);
}
internal class Microsoft.Azure.SignalR.HeartBeat : BackgroundService {
    private static TimeSpan HeartbeatTickRate;
    private IClientConnectionManager _connectionManager;
    private TimerAwaitable _nextHeartbeat;
    public HeartBeat(IClientConnectionManager connectionManager);
    private static HeartBeat();
    public virtual Task StartAsync(CancellationToken cancellationToken);
    public virtual Task StopAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.HeartBeat/<ExecuteAsync>d__6")]
protected virtual Task ExecuteAsync(CancellationToken stoppingToken);
}
public interface Microsoft.Azure.SignalR.IConnectionMigrationFeature {
    public string MigrateFrom { get; }
    public string MigrateTo { get; }
    public abstract virtual string get_MigrateFrom();
    public abstract virtual string get_MigrateTo();
}
public interface Microsoft.Azure.SignalR.IConnectionStatFeature {
    public DateTime StartedAtUtc { get; }
    public DateTime LastMessageReceivedAtUtc { get; }
    public long ReceivedBytes { get; }
    public abstract virtual DateTime get_StartedAtUtc();
    public abstract virtual DateTime get_LastMessageReceivedAtUtc();
    public abstract virtual long get_ReceivedBytes();
}
public interface Microsoft.Azure.SignalR.IEndpointRouter {
    public abstract virtual ServiceEndpoint GetNegotiateEndpoint(HttpContext context, IEnumerable`1<ServiceEndpoint> endpoints);
}
internal interface Microsoft.Azure.SignalR.IServiceConnectionManager`1 {
    public abstract virtual void SetServiceConnection(IServiceConnectionContainer serviceConnection);
    public abstract virtual Task StartAsync();
    public abstract virtual Task StopAsync();
    public abstract virtual Task OfflineAsync(GracefulShutdownMode mode);
    public abstract virtual Task WriteAsync(ServiceMessage seviceMessage);
    public abstract virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage seviceMessage, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.SignalR.IServiceEndpointGenerator {
    public abstract virtual string GetClientAudience(string hubName, string applicationName);
    public abstract virtual string GetClientEndpoint(string hubName, string applicationName, string originalPath, string queryString);
    public abstract virtual string GetServerAudience(string hubName, string applicationName);
    public abstract virtual string GetServerEndpoint(string hubName, string applicationName);
}
internal class Microsoft.Azure.SignalR.MemoryBufferWriter : Stream {
    [ThreadStaticAttribute]
private static MemoryBufferWriter _cachedInstance;
    private int _minimumSegmentSize;
    private int _bytesWritten;
    private List`1<CompletedBuffer> _completedSegments;
    private Byte[] _currentSegment;
    private int _position;
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public MemoryBufferWriter(int minimumSegmentSize);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static MemoryBufferWriter Get();
    public static void Return(MemoryBufferWriter writer);
    public void Reset();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    public void CopyTo(IBufferWriter`1<byte> destination);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void EnsureCapacity(int sizeHint);
    private void AddSegment(int sizeHint);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MemoryBufferWriter/<CopyToSlowAsync>d__28")]
private Task CopyToSlowAsync(Stream destination);
    public Byte[] ToArray();
    public void CopyTo(Span`1<byte> span);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> span);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Azure.SignalR.NegotiateHandler`1 : object {
    private IUserIdProvider _userIdProvider;
    private IConnectionRequestIdProvider _connectionRequestIdProvider;
    private Func`2<HttpContext, IEnumerable`1<Claim>> _claimsProvider;
    private Func`2<HttpContext, bool> _diagnosticClientFilter;
    private IServiceEndpointManager _endpointManager;
    private IEndpointRouter _router;
    private IBlazorDetector _blazorDetector;
    private string _serverName;
    private ServerStickyMode _mode;
    private bool _enableDetailedErrors;
    private int _endpointsCount;
    private Nullable`1<int> _maxPollInterval;
    private int _customHandshakeTimeout;
    private string _hubName;
    private ILogger`1<NegotiateHandler`1<THub>> _logger;
    private Func`2<HttpContext, HttpTransportType> _transportTypeDetector;
    private HttpConnectionDispatcherOptions _dispatcherOptions;
    public NegotiateHandler`1(IOptions`1<HubOptions> globalHubOptions, IOptions`1<HubOptions`1<THub>> hubOptions, IServiceEndpointManager endpointManager, IEndpointRouter router, IUserIdProvider userIdProvider, IServerNameProvider nameProvider, IConnectionRequestIdProvider connectionRequestIdProvider, IOptions`1<ServiceOptions> options, IBlazorDetector blazorDetector, EndpointDataSource endpointDataSource, ILogger`1<NegotiateHandler`1<THub>> logger);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.NegotiateHandler`1/<Process>d__18")]
public Task`1<NegotiationResponse> Process(HttpContext context);
    private string GetQueryString(string originalQueryString, string cultureName, string uiCultureName);
    private IEnumerable`1<Claim> BuildClaims(HttpContext context);
    private Func`1<IEnumerable`1<Claim>> GetClaimsProvider(HttpContext context);
    private bool IsDiagnosticClient(HttpContext context);
    private int GetCustomHandshakeTimeout(Nullable`1<TimeSpan> handshakeTimeout);
    private static string GetOriginalPath(string path);
    private static HttpConnectionDispatcherOptions GetDispatcherOptions(EndpointDataSource source, Type hubType);
}
internal class Microsoft.Azure.SignalR.NegotiateMatcherPolicy : MatcherPolicy {
    private static MethodInfo _createNegotiateEndpointCoreMethodInfo;
    private ConcurrentDictionary`2<Type, Endpoint> _negotiateEndpointCache;
    public int Order { get; }
    private static NegotiateMatcherPolicy();
    public virtual int get_Order();
    public sealed virtual bool AppliesToEndpoints(IReadOnlyList`1<Endpoint> endpoints);
    public sealed virtual Task ApplyAsync(HttpContext httpContext, CandidateSet candidates);
    private Func`2<Type, Endpoint> CreateNegotiateEndpoint(Type hubType, RouteEndpoint routeEndpoint);
    private static Endpoint CreateNegotiateEndpointCore(RouteEndpoint routeEndpoint);
}
internal static class Microsoft.Azure.SignalR.Protocol.BinaryMessageParser : object {
    private static int MaxLengthPrefixSize;
    public static bool TryParseMessage(ReadOnlySequence`1& buffer, ReadOnlySequence`1& payload);
    private static ReadOnlySpan`1<byte> GetSpan(ReadOnlySequence`1& lengthPrefixBuffer);
}
internal class Microsoft.Azure.SignalR.ServerLifetimeManager : object {
    private ConcurrentBag`1<Func`1<Task>> _shutdownHooks;
    public ServerLifetimeManager(IServiceProvider provider);
    internal void Register(Func`1<Task> func);
    private void Shutdown();
}
internal class Microsoft.Azure.SignalR.ServiceConnection : ServiceConnectionBase {
    private static string ClientConnectionCountInHub;
    private static string ClientConnectionCountInServiceConnection;
    private static Dictionary`2<string, string> CustomHeader;
    private IConnectionFactory _connectionFactory;
    private IClientConnectionFactory _clientConnectionFactory;
    private IClientConnectionManager _clientConnectionManager;
    private ConcurrentDictionary`2<string, string> _connectionIds;
    private String[] _pingMessages;
    private ConnectionDelegate _connectionDelegate;
    private IClientInvocationManager _clientInvocationManager;
    private IHubProtocolResolver _hubProtocolResolver;
    [CompilerGeneratedAttribute]
private Action`1<HttpContext> <ConfigureContext>k__BackingField;
    public Action`1<HttpContext> ConfigureContext { get; public set; }
    public ServiceConnection(IServiceProtocol serviceProtocol, IClientConnectionManager clientConnectionManager, IConnectionFactory connectionFactory, ILoggerFactory loggerFactory, ConnectionDelegate connectionDelegate, IClientConnectionFactory clientConnectionFactory, string serverId, string connectionId, HubServiceEndpoint endpoint, IServiceMessageHandler serviceMessageHandler, IServiceEventHandler serviceEventHandler, IClientInvocationManager clientInvocationManager, IHubProtocolResolver hubProtocolResolver, ServiceConnectionType connectionType, GracefulShutdownMode mode, bool allowStatefulReconnects);
    private static ServiceConnection();
    [CompilerGeneratedAttribute]
public Action`1<HttpContext> get_ConfigureContext();
    [CompilerGeneratedAttribute]
public void set_ConfigureContext(Action`1<HttpContext> value);
    public virtual bool TryAddClientConnection(IClientConnection connection);
    public virtual bool TryRemoveClientConnection(string connectionId, IClientConnection& connection);
    protected virtual Task`1<ConnectionContext> CreateConnection(string target);
    protected virtual Task DisposeConnection(ConnectionContext connection);
    protected virtual Task CleanupClientConnections(string fromInstanceId);
    protected virtual ReadOnlyMemory`1<byte> GetPingMessage();
    protected virtual Task OnClientConnectedAsync(OpenConnectionMessage message);
    protected virtual Task OnClientDisconnectedAsync(CloseConnectionMessage message);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnection/<OnClientMessageAsync>d__24")]
protected virtual Task OnClientMessageAsync(ConnectionDataMessage connectionDataMessage);
    protected virtual Task DispatchMessageAsync(ServiceMessage message);
    protected virtual Task OnPingMessageAsync(PingMessage pingMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnection/<ProcessClientConnectionAsync>d__27")]
private Task ProcessClientConnectionAsync(ClientConnectionContext connection, IHubProtocol protocol);
    private Task OnClientInvocationAsync(ClientInvocationMessage message);
    private Task OnServiceMappingAsync(ServiceMappingMessage message);
    private Task OnClientCompletionAsync(ClientCompletionMessage clientCompletionMessage);
    private Task OnErrorCompletionAsync(ErrorCompletionMessage errorCompletionMessage);
    private Task OnConnectionReconnectAsync(ConnectionReconnectMessage message);
}
internal class Microsoft.Azure.SignalR.ServiceConnectionFactory : object {
    private IServiceProtocol _serviceProtocol;
    private IClientConnectionManager _clientConnectionManager;
    private IConnectionFactory _connectionFactory;
    private ILoggerFactory _loggerFactory;
    private ConnectionDelegate _connectionDelegate;
    private IClientConnectionFactory _clientConnectionFactory;
    private IServerNameProvider _nameProvider;
    private IServiceEventHandler _serviceEventHandler;
    private IClientInvocationManager _clientInvocationManager;
    private IHubProtocolResolver _hubProtocolResolver;
    [CompilerGeneratedAttribute]
private GracefulShutdownMode <ShutdownMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowStatefulReconnects>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<HttpContext> <ConfigureContext>k__BackingField;
    public GracefulShutdownMode ShutdownMode { get; public set; }
    public bool AllowStatefulReconnects { get; public set; }
    public Action`1<HttpContext> ConfigureContext { get; public set; }
    public ServiceConnectionFactory(IServiceProtocol serviceProtocol, IClientConnectionManager clientConnectionManager, IConnectionFactory connectionFactory, ILoggerFactory loggerFactory, ConnectionDelegate connectionDelegate, IClientConnectionFactory clientConnectionFactory, IServerNameProvider nameProvider, IServiceEventHandler serviceEventHandler, IClientInvocationManager clientInvocationManager, IHubProtocolResolver hubProtocolResolver);
    [CompilerGeneratedAttribute]
public GracefulShutdownMode get_ShutdownMode();
    [CompilerGeneratedAttribute]
public void set_ShutdownMode(GracefulShutdownMode value);
    [CompilerGeneratedAttribute]
public bool get_AllowStatefulReconnects();
    [CompilerGeneratedAttribute]
public void set_AllowStatefulReconnects(bool value);
    [CompilerGeneratedAttribute]
public Action`1<HttpContext> get_ConfigureContext();
    [CompilerGeneratedAttribute]
public void set_ConfigureContext(Action`1<HttpContext> value);
    public virtual IServiceConnection Create(HubServiceEndpoint endpoint, IServiceMessageHandler serviceMessageHandler, AckHandler ackHandler, ServiceConnectionType type);
}
internal class Microsoft.Azure.SignalR.ServiceConnectionManager`1 : object {
    private IServiceConnectionContainer _serviceConnection;
    public sealed virtual void SetServiceConnection(IServiceConnectionContainer serviceConnection);
    public sealed virtual Task StartAsync();
    public sealed virtual Task StopAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionManager`1/<OfflineAsync>d__4")]
public sealed virtual Task OfflineAsync(GracefulShutdownMode mode);
    public sealed virtual Task WriteAsync(ServiceMessage serviceMessage);
    public sealed virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage seviceMessage, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.SignalR.ServiceEndpointManager : ServiceEndpointManagerBase {
    private ILogger _logger;
    private ServiceOptions _options;
    private TimeSpan _scaleTimeout;
    private IAccessKeySynchronizer _synchronizer;
    public ServiceEndpointManager(IAccessKeySynchronizer synchronizer, IOptionsMonitor`1<ServiceOptions> optionsMonitor, ILoggerFactory loggerFactory);
    public virtual IServiceEndpointProvider GetEndpointProvider(ServiceEndpoint endpoint);
    private void OnChange(ServiceOptions options);
    private Task ReloadServiceEndpointsAsync(IEnumerable`1<ServiceEndpoint> serviceEndpoints);
}
internal class Microsoft.Azure.SignalR.ServiceEndpointProvider : object {
    public static string ConnectionStringNotFound;
    private AccessKey _accessKey;
    private string _appName;
    private TimeSpan _accessTokenLifetime;
    private IServiceEndpointGenerator _generator;
    private AccessTokenAlgorithm _algorithm;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    public IWebProxy Proxy { get; }
    public ServiceEndpointProvider(ServiceEndpoint endpoint, ServiceOptions serviceOptions);
    private static ServiceEndpointProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_Proxy();
    public sealed virtual Task`1<string> GenerateClientAccessTokenAsync(string hubName, IEnumerable`1<Claim> claims, Nullable`1<TimeSpan> lifetime);
    public sealed virtual string GetClientEndpoint(string hubName, string originalPath, string queryString);
    public sealed virtual IAccessTokenProvider GetServerAccessTokenProvider(string hubName, string serverId);
    public sealed virtual string GetServerEndpoint(string hubName);
}
internal class Microsoft.Azure.SignalR.ServiceHubConnectionContext : HubConnectionContext {
    public static string UnavailableErrorTemplate;
    public static string ConnectionAbortedUnavailableError;
    public static string ConnectionIdUnavailableError;
    public static string ItemsUnavailableError;
    public static string ProtocolUnavailableError;
    public CancellationToken ConnectionAborted { get; }
    public string ConnectionId { get; }
    public IDictionary`2<object, object> Items { get; }
    public IHubProtocol Protocol { get; }
    public ServiceHubConnectionContext(HttpContext context);
    public virtual CancellationToken get_ConnectionAborted();
    public virtual string get_ConnectionId();
    public virtual IDictionary`2<object, object> get_Items();
    public virtual IHubProtocol get_Protocol();
}
internal class Microsoft.Azure.SignalR.ServiceHubDispatcher : object {
    private Type _serviceDispatcherType;
    private IServiceProvider _serviceProvider;
    public ServiceHubDispatcher(IServiceProvider serviceProvider);
    public void Start(Endpoint endpoint, Type hubType, ConnectionDelegate app);
}
internal class Microsoft.Azure.SignalR.ServiceHubDispatcher`1 : object {
    private static string Name;
    [CompilerGeneratedAttribute]
private IHubContext`1<THub> <Context>k__BackingField;
    private ILoggerFactory _loggerFactory;
    private ILogger`1<ServiceHubDispatcher`1<THub>> _logger;
    private ServiceOptions _options;
    private IServiceEndpointManager _serviceEndpointManager;
    private IServiceConnectionManager`1<THub> _serviceConnectionManager;
    private IClientConnectionManager _clientConnectionManager;
    private IServiceProtocol _serviceProtocol;
    private IClientConnectionFactory _clientConnectionFactory;
    private IEndpointRouter _router;
    private string _hubName;
    private IServiceEventHandler _serviceEventHandler;
    private IClientInvocationManager _clientInvocationManager;
    private IHubProtocolResolver _hubProtocolResolver;
    protected IServerNameProvider _nameProvider;
    private IHubContext`1<THub> Context { get; }
    public ServiceHubDispatcher`1(IServiceProtocol serviceProtocol, IHubContext`1<THub> context, IServiceConnectionManager`1<THub> serviceConnectionManager, IClientConnectionManager clientConnectionManager, IServiceEndpointManager serviceEndpointManager, IOptions`1<ServiceOptions> options, ILoggerFactory loggerFactory, IEndpointRouter router, IServerNameProvider nameProvider, ServerLifetimeManager serverLifetimeManager, IClientConnectionFactory clientConnectionFactory, IClientInvocationManager clientInvocationManager, IServiceEventHandler serviceEventHandler, IHubProtocolResolver hubProtocolResolver);
    private static ServiceHubDispatcher`1();
    [CompilerGeneratedAttribute]
private IHubContext`1<THub> get_Context();
    public void Start(ConnectionDelegate connectionDelegate, Action`1<HttpContext> contextConfig);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceHubDispatcher`1/<ShutdownAsync>d__20")]
public Task ShutdownAsync();
    private IServiceConnectionContainer GetServiceConnectionContainer(string hub, ConnectionDelegate connectionDelegate, Action`1<HttpContext> contextConfig);
    internal virtual ServiceConnectionFactory GetServiceConnectionFactory(ConnectionFactory connectionFactory, ConnectionDelegate connectionDelegate, Action`1<HttpContext> contextConfig);
}
internal class Microsoft.Azure.SignalR.ServiceLifetimeManager`1 : ServiceLifetimeManagerBase`1<THub> {
    private static string MarkerNotConfiguredError;
    private IClientInvocationManager _clientInvocationManager;
    private IClientConnectionManager _clientConnectionManager;
    private string _callerId;
    private string _hub;
    public ServiceLifetimeManager`1(IServiceConnectionManager`1<THub> serviceConnectionManager, IClientConnectionManager clientConnectionManager, IHubProtocolResolver protocolResolver, ILogger`1<ServiceLifetimeManager`1<THub>> logger, AzureSignalRMarkerService marker, IOptions`1<HubOptions> globalHubOptions, IOptions`1<HubOptions`1<THub>> hubOptions, IBlazorDetector blazorDetector, IServerNameProvider nameProvider, IClientInvocationManager clientInvocationManager);
    public virtual Task OnConnectedAsync(HubConnectionContext connection);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceLifetimeManager`1/<SendConnectionAsync>d__7")]
public virtual Task SendConnectionAsync(string connectionId, string methodName, Object[] args, CancellationToken cancellationToken);
    private MultiConnectionDataMessage CreateMessage(string connectionId, string methodName, Object[] args, IClientConnection clientConnection);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(string connectionId, string methodName, Object[] args, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Azure.SignalR.ServiceLifetimeManagerBase`1 : HubLifetimeManager`1<THub> {
    protected static string NullOrEmptyStringErrorMessage;
    protected static string TtlOutOfRangeErrorMessage;
    protected IServiceConnectionManager`1<THub> ServiceConnectionContainer;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    private DefaultHubMessageSerializer _messageSerializer;
    protected ILogger Logger { get; protected set; }
    public ServiceLifetimeManagerBase`1(IServiceConnectionManager`1<THub> serviceConnectionManager, IHubProtocolResolver protocolResolver, IOptions`1<HubOptions> globalHubOptions, IOptions`1<HubOptions`1<THub>> hubOptions, ILogger logger);
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected void set_Logger(ILogger value);
    public virtual Task OnConnectedAsync(HubConnectionContext connection);
    public virtual Task OnDisconnectedAsync(HubConnectionContext connection);
    public virtual Task SendAllAsync(string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendAllExceptAsync(string methodName, Object[] args, IReadOnlyList`1<string> excludedIds, CancellationToken cancellationToken);
    public virtual Task SendConnectionAsync(string connectionId, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendConnectionsAsync(IReadOnlyList`1<string> connectionIds, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupAsync(string groupName, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupsAsync(IReadOnlyList`1<string> groupNames, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendGroupExceptAsync(string groupName, string methodName, Object[] args, IReadOnlyList`1<string> excludedIds, CancellationToken cancellationToken);
    public virtual Task SendUserAsync(string userId, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task SendUsersAsync(IReadOnlyList`1<string> userIds, string methodName, Object[] args, CancellationToken cancellationToken);
    public virtual Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    public virtual Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken);
    protected Task WriteAsync(T message);
    protected Task`1<bool> WriteAckableMessageAsync(T message, CancellationToken cancellation);
    protected static bool IsInvalidArgument(string value);
    protected static bool IsInvalidArgument(IReadOnlyList`1<object> list);
    protected IDictionary`2<string, ReadOnlyMemory`1<byte>> SerializeAllProtocols(string method, Object[] args, string invocationId);
    protected ReadOnlyMemory`1<byte> SerializeProtocol(string protocol, string method, Object[] args);
    protected ReadOnlyMemory`1<byte> SerializeCompletionMessage(CompletionMessage message, string protocol);
    protected virtual T AppendMessageTracingId(T message);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceLifetimeManagerBase`1/<WriteCoreAsync>d__30`1")]
private Task WriteCoreAsync(T message, Func`2<T, Task> task);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceLifetimeManagerBase`1/<WriteAckableCoreAsync>d__31`1")]
private Task`1<bool> WriteAckableCoreAsync(T message, Func`2<T, Task`1<bool>> task);
}
public class Microsoft.Azure.SignalR.ServiceOptions : object {
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialHubServerConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxHubServerConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<HttpContext, IEnumerable`1<Claim>> <ClaimsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<HttpContext, bool> <DiagnosticClientFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AccessTokenLifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessTokenAlgorithm <AccessTokenAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceEndpoint[] <Endpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerStickyMode <ServerStickyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private GracefulShutdownOptions <GracefulShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ServiceScaleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPollIntervalInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<HttpContext, HttpTransportType> <TransportTypeDetector>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowStatefulReconnects>k__BackingField;
    public string ConnectionString { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use InitialHubServerConnectionCount instead.")]
public int ConnectionCount { get; public set; }
    public int InitialHubServerConnectionCount { get; public set; }
    public Nullable`1<int> MaxHubServerConnectionCount { get; public set; }
    public string ApplicationName { get; public set; }
    public Func`2<HttpContext, IEnumerable`1<Claim>> ClaimsProvider { get; public set; }
    public Func`2<HttpContext, bool> DiagnosticClientFilter { get; public set; }
    public TimeSpan AccessTokenLifetime { get; public set; }
    public AccessTokenAlgorithm AccessTokenAlgorithm { get; public set; }
    public ServiceEndpoint[] Endpoints { get; public set; }
    public ServerStickyMode ServerStickyMode { get; public set; }
    public GracefulShutdownOptions GracefulShutdown { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public TimeSpan ServiceScaleTimeout { get; public set; }
    public Nullable`1<int> MaxPollIntervalInSeconds { get; public set; }
    public Func`2<HttpContext, HttpTransportType> TransportTypeDetector { get; public set; }
    public Nullable`1<bool> AllowStatefulReconnects { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    public int get_ConnectionCount();
    public void set_ConnectionCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_InitialHubServerConnectionCount();
    [CompilerGeneratedAttribute]
public void set_InitialHubServerConnectionCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MaxHubServerConnectionCount();
    [CompilerGeneratedAttribute]
public void set_MaxHubServerConnectionCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Func`2<HttpContext, IEnumerable`1<Claim>> get_ClaimsProvider();
    [CompilerGeneratedAttribute]
public void set_ClaimsProvider(Func`2<HttpContext, IEnumerable`1<Claim>> value);
    [CompilerGeneratedAttribute]
public Func`2<HttpContext, bool> get_DiagnosticClientFilter();
    [CompilerGeneratedAttribute]
public void set_DiagnosticClientFilter(Func`2<HttpContext, bool> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_AccessTokenLifetime();
    [CompilerGeneratedAttribute]
public void set_AccessTokenLifetime(TimeSpan value);
    [CompilerGeneratedAttribute]
public AccessTokenAlgorithm get_AccessTokenAlgorithm();
    [CompilerGeneratedAttribute]
public void set_AccessTokenAlgorithm(AccessTokenAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual ServiceEndpoint[] get_Endpoints();
    [CompilerGeneratedAttribute]
public void set_Endpoints(ServiceEndpoint[] value);
    [CompilerGeneratedAttribute]
public ServerStickyMode get_ServerStickyMode();
    [CompilerGeneratedAttribute]
public void set_ServerStickyMode(ServerStickyMode value);
    [CompilerGeneratedAttribute]
public GracefulShutdownOptions get_GracefulShutdown();
    [CompilerGeneratedAttribute]
public void set_GracefulShutdown(GracefulShutdownOptions value);
    [CompilerGeneratedAttribute]
public IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
public void set_Proxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ServiceScaleTimeout();
    [CompilerGeneratedAttribute]
public void set_ServiceScaleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPollIntervalInSeconds();
    [CompilerGeneratedAttribute]
public void set_MaxPollIntervalInSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Func`2<HttpContext, HttpTransportType> get_TransportTypeDetector();
    [CompilerGeneratedAttribute]
public void set_TransportTypeDetector(Func`2<HttpContext, HttpTransportType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowStatefulReconnects();
    [CompilerGeneratedAttribute]
public void set_AllowStatefulReconnects(Nullable`1<bool> value);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.ServiceOptionsExtensions : object {
    private static Regex AppNameRegex;
    private static ServiceOptionsExtensions();
    [ExtensionAttribute]
public static void Validate(ServiceOptions options);
}
internal class Microsoft.Azure.SignalR.ServiceOptionsSetup : object {
    private IConfiguration _configuration;
    private string _connectionName;
    public string Name { get; }
    public ServiceOptionsSetup(IConfiguration configuration);
    public ServiceOptionsSetup(IConfiguration configuration, string connectionName);
    public sealed virtual string get_Name();
    public sealed virtual void Configure(ServiceOptions options);
    public sealed virtual IChangeToken GetChangeToken();
    private TimeSpan GetConfiguredTimeSpanFromSeconds(Nullable`1<int> seconds, TimeSpan defaultValue);
    private T GetConfiguredEnum(string value, T defaultValue);
    private ValueTuple`4<string, string, ServiceEndpoint[], ConfigurableServiceOptions> ParseConfiguration(string connectionName);
    private string GetApplicationName(string sectionKey);
    private string GetConnectionString(string sectionKey, string connectionName);
    private ServiceEndpoint[] GetEndpoints(string sectionKey);
}
public class Microsoft.Azure.SignalR.ServiceRouteBuilder : object {
    private IServiceProvider _serviceProvider;
    private RouteBuilder _routes;
    public ServiceRouteBuilder(RouteBuilder routes);
    public void MapHub(string path);
    public void MapHub(PathString path);
    private void Start();
}
internal class Microsoft.Azure.SignalR.ServiceRouteHelper : object {
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceRouteHelper/<RedirectToService>d__0`1")]
public static Task RedirectToService(HttpContext context, IList`1<IAuthorizeData> authorizationData);
}
internal class Microsoft.Azure.SignalR.ServiceUserIdFeature : object {
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    public string UserId { get; }
    public ServiceUserIdFeature(string userId);
    [CompilerGeneratedAttribute]
public string get_UserId();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.AzureSignalRDependencyInjectionExtensions : object {
    [ExtensionAttribute]
public static ISignalRServerBuilder AddAzureSignalR(ISignalRServerBuilder builder);
    [ExtensionAttribute]
public static ISignalRServerBuilder AddNamedAzureSignalR(ISignalRServerBuilder builder, string name);
    [ExtensionAttribute]
public static ISignalRServerBuilder AddAzureSignalR(ISignalRServerBuilder builder, string connectionString);
    [ExtensionAttribute]
public static ISignalRServerBuilder AddAzureSignalR(ISignalRServerBuilder builder, Action`1<ServiceOptions> configure);
    [ExtensionAttribute]
internal static ISignalRServerBuilder AddAzureSignalR(ISignalRServerBuilder builder);
    [ExtensionAttribute]
private static ISignalRServerBuilder AddAzureSignalRCore(ISignalRServerBuilder builder);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
