internal class Microsoft.Azure.SignalR.AccessKey : object {
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2<string, string> <Key>k__BackingField;
    public string Id { get; }
    public string Value { get; }
    public Uri Endpoint { get; }
    protected Tuple`2<string, string> Key { get; protected set; }
    public AccessKey(string uri, string key);
    public AccessKey(Uri uri, string key);
    protected AccessKey(Uri uri);
    public string get_Id();
    public string get_Value();
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
protected Tuple`2<string, string> get_Key();
    [CompilerGeneratedAttribute]
protected void set_Key(Tuple`2<string, string> value);
    public virtual Task`1<string> GenerateAccessTokenAsync(string audience, IEnumerable`1<Claim> claims, TimeSpan lifetime, AccessTokenAlgorithm algorithm, CancellationToken ctoken);
}
internal class Microsoft.Azure.SignalR.AccessKeySynchronizer : object {
    private ConcurrentDictionary`2<ServiceEndpoint, object> _endpoints;
    private ILoggerFactory _factory;
    private TimerAwaitable _timer;
    internal IEnumerable`1<MicrosoftEntraAccessKey> AccessKeyForMicrosoftEntraList { get; }
    public AccessKeySynchronizer(ILoggerFactory loggerFactory);
    internal AccessKeySynchronizer(ILoggerFactory loggerFactory, bool start);
    internal IEnumerable`1<MicrosoftEntraAccessKey> get_AccessKeyForMicrosoftEntraList();
    public sealed virtual void AddServiceEndpoint(ServiceEndpoint endpoint);
    public sealed virtual void Dispose();
    public sealed virtual void UpdateServiceEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
    internal bool ContainsServiceEndpoint(ServiceEndpoint e);
    internal int ServiceEndpointsCount();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.AccessKeySynchronizer/<UpdateAccessKeyAsync>d__12")]
private Task UpdateAccessKeyAsync();
}
public enum Microsoft.Azure.SignalR.AccessTokenAlgorithm : Enum {
    public int value__;
    public static AccessTokenAlgorithm HS256;
    public static AccessTokenAlgorithm HS512;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Azure.SignalR.AckHandler : object {
    public static AckHandler Singleton;
    private ConcurrentDictionary`2<int, IAckInfo> _acks;
    private Timer _timer;
    private TimeSpan _defaultAckTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private int _nextId;
    public AckHandler(int ackIntervalInMilliseconds, int ackTtlInMilliseconds);
    internal AckHandler(TimeSpan ackInterval, TimeSpan defaultAckTimeout);
    private static AckHandler();
    private int NextId();
    public Task`1<AckStatus> CreateSingleAck(Int32& id, Nullable`1<TimeSpan> ackTimeout, CancellationToken cancellationToken);
    public static bool HandleAckStatus(IAckableMessage message, AckStatus status);
    public Task`1<AckStatus> CreateMultiAck(Int32& id, Nullable`1<TimeSpan> ackTimeout);
    public void TriggerAck(int id, AckStatus status);
    public void SetExpectedCount(int id, int expectedCount);
    private void CheckAcks();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__8_0(object _);
}
internal enum Microsoft.Azure.SignalR.AckStatus : Enum {
    public int value__;
    public static AckStatus Ok;
    public static AckStatus NotFound;
    public static AckStatus Timeout;
    public static AckStatus InternalServerError;
}
internal static class Microsoft.Azure.SignalR.AuthUtility : object {
    private static int MaxTokenLength;
    private static SignalRJwtSecurityTokenHandler JwtTokenHandler;
    private static AuthUtility();
    public static string GenerateJwtBearer(string issuer, string audience, IEnumerable`1<Claim> claims, Nullable`1<DateTime> expires, AccessKey signingKey, Nullable`1<DateTime> issuedAt, Nullable`1<DateTime> notBefore, AccessTokenAlgorithm algorithm);
    public static string GenerateAccessToken(AccessKey signingKey, string audience, IEnumerable`1<Claim> claims, TimeSpan lifetime, AccessTokenAlgorithm algorithm);
    public static string GenerateRequestId();
}
internal static class Microsoft.Azure.SignalR.Base64UrlEncoder : object {
    private static char base64PadCharacter;
    private static char base64Character62;
    private static char base64Character63;
    private static char base64UrlCharacter62;
    private static char base64UrlCharacter63;
    internal static Char[] s_base64Table;
    private static Base64UrlEncoder();
    public static string Encode(string arg);
    public static string Encode(Byte[] inArray, int offset, int length);
    public static string Encode(Byte[] inArray);
    public static string EncodeString(string str);
    public static Byte[] DecodeBytes(string str);
    public static string Decode(string arg);
    private static Byte[] UnsafeDecode(string str);
}
[ExtensionAttribute]
public static class Microsoft.Azure.SignalR.CancellationTokenExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.CancellationTokenExtensions/<AsTask>d__0")]
[ExtensionAttribute]
public static Task AsTask(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CancellationTokenAwaiter GetAwaiter(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.ClaimsUtility : object {
    private static string DefaultAuthenticationType;
    private static String[] SystemClaims;
    private static ClaimsIdentity DefaultClaimsIdentity;
    private static ClaimsPrincipal EmptyPrincipal;
    private static string DefaultNameClaimType;
    private static string DefaultRoleClaimType;
    private static ClaimsUtility();
    [IteratorStateMachineAttribute("Microsoft.Azure.SignalR.ClaimsUtility/<BuildJwtClaims>d__6")]
public static IEnumerable`1<Claim> BuildJwtClaims(ClaimsPrincipal user, string userId, Func`1<IEnumerable`1<Claim>> claimsProvider, string serverName, ServerStickyMode mode, bool enableDetailedErrors, int endpointsCount, Nullable`1<int> maxPollInterval, bool isDiagnosticClient, int handshakeTimeout, Nullable`1<HttpTransportType> httpTransportType, bool closeOnAuthenticationExpiration, Nullable`1<DateTimeOffset> authenticationExpiresOn);
    [ExtensionAttribute]
public static ClaimsPrincipal GetUserPrincipal(OpenConnectionMessage message);
    internal static ClaimsPrincipal GetUserPrincipal(Claim[] messageClaims);
}
internal static class Microsoft.Azure.SignalR.ClaimTypeMapping : object {
    private static Dictionary`2<string, string> shortToLongClaimTypeMapping;
    private static IDictionary`2<string, string> longToShortClaimTypeMapping;
    private static HashSet`1<string> inboundClaimFilter;
    public static IDictionary`2<string, string> InboundClaimTypeMap { get; }
    public static IDictionary`2<string, string> OutboundClaimTypeMap { get; }
    public static ISet`1<string> InboundClaimFilter { get; }
    private static ClaimTypeMapping();
    public static IDictionary`2<string, string> get_InboundClaimTypeMap();
    public static IDictionary`2<string, string> get_OutboundClaimTypeMap();
    public static ISet`1<string> get_InboundClaimFilter();
}
internal class Microsoft.Azure.SignalR.ClientConnectionScope : object {
    private bool _needCleanup;
    internal static bool IsScopeEstablished { get; }
    internal static ConcurrentDictionary`2<long, WeakReference`1<IServiceConnection>> OutboundServiceConnections { get; internal set; }
    internal static bool IsDiagnosticClient { get; internal set; }
    protected internal ClientConnectionScope(HubServiceEndpoint endpoint, IServiceConnection outboundConnection, bool isDiagnosticClient);
    public sealed virtual void Dispose();
    internal static bool get_IsScopeEstablished();
    internal static ConcurrentDictionary`2<long, WeakReference`1<IServiceConnection>> get_OutboundServiceConnections();
    internal static void set_OutboundServiceConnections(ConcurrentDictionary`2<long, WeakReference`1<IServiceConnection>> value);
    internal static bool get_IsDiagnosticClient();
    internal static void set_IsDiagnosticClient(bool value);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRAccessTokenNotAuthorizedException : AzureSignalRException {
    private static string Postfix;
    [ObsoleteAttribute]
public AzureSignalRAccessTokenNotAuthorizedException(string message);
    public AzureSignalRAccessTokenNotAuthorizedException(string credentialName, Exception innerException);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRAccessTokenTooLongException : AzureSignalRException {
    protected AzureSignalRAccessTokenTooLongException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRConfigurationNoEndpointException : AzureSignalRException {
    protected AzureSignalRConfigurationNoEndpointException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRException : Exception {
    public AzureSignalRException(string message);
    public AzureSignalRException(string message, Exception ex);
    protected AzureSignalRException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRInaccessibleEndpointException : AzureSignalRException {
    private static string ErrorPhenomenon;
    private static string SuggestAction;
    public AzureSignalRInaccessibleEndpointException(string requestUri, Exception innerException);
    protected AzureSignalRInaccessibleEndpointException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRInvalidArgumentException : AzureSignalRException {
    private static string ErrorMessage;
    public AzureSignalRInvalidArgumentException(string requestUri, Exception innerException, string detail);
    protected AzureSignalRInvalidArgumentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRInvalidServiceOptionsException : AzureSignalRException {
    public AzureSignalRInvalidServiceOptionsException(string propertyName, string validScope);
    protected AzureSignalRInvalidServiceOptionsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRNoEndpointAvailableException : AzureSignalRException {
    protected AzureSignalRNoEndpointAvailableException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRNoPrimaryEndpointException : AzureSignalRException {
    protected AzureSignalRNoPrimaryEndpointException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRNotConnectedException : AzureSignalRException {
    protected AzureSignalRNotConnectedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRRuntimeException : AzureSignalRException {
    private static string ErrorMessage;
    public AzureSignalRRuntimeException(string requestUri, Exception innerException);
    protected AzureSignalRRuntimeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.SignalR.Common.AzureSignalRUnauthorizedException : AzureSignalRException {
    private static string ErrorMessage;
    public AzureSignalRUnauthorizedException(string requestUri, Exception innerException);
    internal AzureSignalRUnauthorizedException(Exception innerException);
    protected AzureSignalRUnauthorizedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.SignalR.Common.BackOffPolicy : object {
    private TaskCompletionSource`1<bool> _currentProbeTcs;
    private int _currentRetryCount;
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Common.BackOffPolicy/<CallProbeWithBackOffAsync>d__2")]
public Task`1<bool> CallProbeWithBackOffAsync(Func`1<Task`1<bool>> probe, Func`2<int, TimeSpan> getRetryDelay);
}
internal class Microsoft.Azure.SignalR.Common.BinaryPayloadContentBuilder : object {
    [NullableAttribute("1")]
private IReadOnlyList`1<IHubProtocol> _hubProtocols;
    [NullableContextAttribute("1")]
public BinaryPayloadContentBuilder(IReadOnlyList`1<IHubProtocol> hubProtocols);
    [NullableContextAttribute("2")]
public sealed virtual HttpContent Build(PayloadMessage payload);
}
internal class Microsoft.Azure.SignalR.Common.BinaryPayloadMessageContent : HttpContent {
    private static Dictionary`2<string, Byte[]> ProtocolMap;
    private static MediaTypeHeaderValue ContentType;
    private PayloadMessage _payloadMessage;
    private IReadOnlyList`1<IHubProtocol> _hubProtocols;
    public BinaryPayloadMessageContent(PayloadMessage payloadMessage, IReadOnlyList`1<IHubProtocol> hubProtocols);
    private static BinaryPayloadMessageContent();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Common.BinaryPayloadMessageContent/<SerializeToStreamAsync>d__5")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    private void WriteMessageCore(IBufferWriter`1<byte> bufferWriter);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.Common.ExceptionExtensions : object {
    [ExtensionAttribute]
internal static Exception WrapAsAzureSignalRException(Exception e);
}
public class Microsoft.Azure.SignalR.Common.FailedWritingMessageToServiceException : ServiceConnectionNotActiveException {
    [CompilerGeneratedAttribute]
private string <EndpointUri>k__BackingField;
    public string EndpointUri { get; }
    public FailedWritingMessageToServiceException(string endpointUri);
    protected FailedWritingMessageToServiceException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_EndpointUri();
}
[NullableContextAttribute("2")]
internal interface Microsoft.Azure.SignalR.Common.IPayloadContentBuilder {
    public abstract virtual HttpContent Build(PayloadMessage payload);
}
internal class Microsoft.Azure.SignalR.Common.JsonPayloadContentBuilder : object {
    [NullableAttribute("1")]
private ObjectSerializer _jsonObjectSerializer;
    [NullableContextAttribute("1")]
public JsonPayloadContentBuilder(ObjectSerializer jsonObjectSerializer);
    [NullableContextAttribute("2")]
public sealed virtual HttpContent Build(PayloadMessage payload);
}
public class Microsoft.Azure.SignalR.Common.ServiceConnectionNotActiveException : AzureSignalRException {
    private static string NotActiveMessage;
    public ServiceConnectionNotActiveException(string message);
    protected ServiceConnectionNotActiveException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.SignalR.Common.Utilities.ScopePropertiesAccessor`1 : object {
    private static AsyncLocal`1<ScopePropertiesAccessor`1<TProps>> s_currentAccessor;
    [CompilerGeneratedAttribute]
private TProps <Properties>k__BackingField;
    protected internal static ScopePropertiesAccessor`1<TProps> Current { get; protected internal set; }
    internal TProps Properties { get; internal set; }
    private static ScopePropertiesAccessor`1();
    protected internal static ScopePropertiesAccessor`1<TProps> get_Current();
    protected internal static void set_Current(ScopePropertiesAccessor`1<TProps> value);
    [CompilerGeneratedAttribute]
internal TProps get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(TProps value);
}
internal class Microsoft.Azure.SignalR.Common.WeakServiceConnectionContainer : ServiceConnectionContainerBase {
    protected ServiceConnectionType InitialConnectionType { get; }
    public WeakServiceConnectionContainer(IServiceConnectionFactory serviceConnectionFactory, int fixedConnectionCount, HubServiceEndpoint endpoint, ILogger logger);
    protected virtual ServiceConnectionType get_InitialConnectionType();
    public virtual Task OfflineAsync(GracefulShutdownMode mode);
}
internal class Microsoft.Azure.SignalR.ConnectionFactory : object {
    private ILoggerFactory _loggerFactory;
    private string _serverId;
    public ConnectionFactory(IServerNameProvider nameProvider, ILoggerFactory loggerFactory);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ConnectionFactory/<ConnectAsync>d__3")]
public sealed virtual Task`1<ConnectionContext> ConnectAsync(HubServiceEndpoint hubServiceEndpoint, TransferFormat transferFormat, string connectionId, string target, CancellationToken cancellationToken, IDictionary`2<string, string> headers);
    public sealed virtual Task DisposeAsync(ConnectionContext connection);
    private Uri GetServiceUrl(IServiceEndpointProvider provider, string hubName, string connectionId, string target);
}
internal class Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport : object {
    public static PipeOptions DefaultOptions;
    private WebSocketMessageType _webSocketMessageType;
    private ClientWebSocket _webSocket;
    private IAccessTokenProvider _accessTokenProvider;
    private IDuplexPipe _application;
    private ILogger _logger;
    private TimeSpan _closeTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _aborted;
    private IDuplexPipe _transport;
    [CompilerGeneratedAttribute]
private Task <Running>k__BackingField;
    internal Task Running { get; private set; }
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public WebSocketsTransport(WebSocketConnectionOptions connectionOptions, ILoggerFactory loggerFactory, IAccessTokenProvider accessTokenProvider);
    private static WebSocketsTransport();
    [CompilerGeneratedAttribute]
internal Task get_Running();
    [CompilerGeneratedAttribute]
private void set_Running(Task value);
    public sealed virtual PipeReader get_Input();
    public sealed virtual PipeWriter get_Output();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport/<StartAsync>d__18")]
public Task StartAsync(Uri url, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport/<ProcessSocketAsync>d__19")]
private Task ProcessSocketAsync(WebSocket socket);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport/<StartReceiving>d__20")]
private Task StartReceiving(WebSocket socket);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport/<StartSending>d__21")]
private Task StartSending(WebSocket socket);
    private static bool WebSocketCanSend(WebSocket ws);
    private static Uri ResolveWebSocketsUrl(Uri url);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.Connections.Client.Internal.WebSocketsTransport/<StopAsync>d__24")]
public Task StopAsync();
}
internal static class Microsoft.Azure.SignalR.ConnectionStringParser : object {
    private static string AccessKeyProperty;
    private static string AuthTypeProperty;
    private static string ClientCertProperty;
    private static string ClientEndpointProperty;
    private static string ClientIdProperty;
    private static string ClientSecretProperty;
    private static string EndpointProperty;
    private static string ServerEndpointProperty;
    private static string InvalidVersionValueFormat;
    private static string PortProperty;
    private static string SupportedVersion;
    private static string TenantIdProperty;
    private static string TypeAzure;
    private static string TypeAzureAD;
    private static string TypeAzureApp;
    private static string TypeAzureMsi;
    private static string ValidVersionRegex;
    private static string VersionProperty;
    private static string InvalidClientEndpointProperty;
    private static string InvalidEndpointProperty;
    private static string InvalidPortValue;
    private static Char[] KeyValueSeparator;
    private static string MissingAccessKeyProperty;
    private static string MissingClientIdProperty;
    private static string MissingClientSecretProperty;
    private static string MissingEndpointProperty;
    private static string MissingTenantIdProperty;
    private static Char[] PropertySeparator;
    private static ConnectionStringParser();
    internal static ParsedConnectionString Parse(string connectionString);
    internal static bool TryGetEndpointUri(string endpoint, Uri& uriResult);
    private static AccessKey BuildAzureADAccessKey(Uri uri, Uri serverEndpointUri, Dictionary`2<string, string> dict);
    private static AccessKey BuildAccessKey(Uri uri, Dictionary`2<string, string> dict);
    private static AccessKey BuildAzureAccessKey(Uri uri, Uri serverEndpointUri, Dictionary`2<string, string> dict);
    private static AccessKey BuildAzureAppAccessKey(Uri uri, Uri serverEndpointUri, Dictionary`2<string, string> dict);
    private static AccessKey BuildAzureMsiAccessKey(Uri uri, Uri serverEndpointUri, Dictionary`2<string, string> dict);
    private static Dictionary`2<string, string> ToDictionary(string connectionString);
}
internal static class Microsoft.Azure.SignalR.Constants : object {
    public static string AsrsMigrateFrom;
    public static string AsrsMigrateTo;
    public static string AsrsUserAgent;
    public static string AsrsInstanceId;
    public static string AsrsIsDiagnosticClient;
    public static int DefaultCloseTimeoutMilliseconds;
}
internal static class Microsoft.Azure.SignalR.DateTimeUtil : object {
    public static DateTime Add(DateTime time, TimeSpan timespan);
    public static DateTime GetMaxValue(DateTimeKind kind);
    public static DateTime GetMinValue(DateTimeKind kind);
    public static Nullable`1<DateTime> ToUniversalTime(Nullable`1<DateTime> value);
    public static DateTime ToUniversalTime(DateTime value);
}
internal class Microsoft.Azure.SignalR.DefaultBlazorDetector : object {
    private ConcurrentDictionary`2<string, bool> _blazor;
    public sealed virtual bool IsBlazor(string hubName);
    public sealed virtual bool TrySetBlazor(string hubName, bool isBlazor);
}
internal class Microsoft.Azure.SignalR.DefaultConnectionRequestIdProvider : object {
    public sealed virtual string GetRequestId();
}
internal class Microsoft.Azure.SignalR.DefaultMessageRouter : object {
    public sealed virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForBroadcast(IEnumerable`1<ServiceEndpoint> endpoints);
    public sealed virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForUser(string userId, IEnumerable`1<ServiceEndpoint> endpoints);
    public sealed virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForGroup(string groupName, IEnumerable`1<ServiceEndpoint> endpoints);
    public sealed virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForConnection(string connectionId, IEnumerable`1<ServiceEndpoint> endpoints);
}
internal class Microsoft.Azure.SignalR.DefaultServerNameProvider : object {
    private string _name;
    public sealed virtual string GetName();
}
internal class Microsoft.Azure.SignalR.DefaultServiceEventHandler : object {
    private ILogger _logger;
    public DefaultServiceEventHandler(ILoggerFactory loggerFactory);
    public sealed virtual Task HandleAsync(string connectionId, ServiceEventMessage message);
}
internal class Microsoft.Azure.SignalR.DummyClientInvocationManager : object {
    public ICallerClientResultsManager Caller { get; }
    public IRoutedClientResultsManager Router { get; }
    public sealed virtual ICallerClientResultsManager get_Caller();
    public sealed virtual IRoutedClientResultsManager get_Router();
    public sealed virtual void CleanupInvocationsByConnection(string connectionId);
    public sealed virtual bool TryGetInvocationReturnType(string invocationId, Type& type);
}
internal class Microsoft.Azure.SignalR.EndpointEventHandler : MulticastDelegate {
    public EndpointEventHandler(object object, IntPtr method);
    public virtual void Invoke(HubServiceEndpoint endpoint);
    public virtual IAsyncResult BeginInvoke(HubServiceEndpoint endpoint, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Azure.SignalR.EndpointMetrics : object {
    [CompilerGeneratedAttribute]
private int <ClientConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServerConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionCapacity>k__BackingField;
    public int ClientConnectionCount { get; internal set; }
    public int ServerConnectionCount { get; internal set; }
    public int ConnectionCapacity { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_ClientConnectionCount();
    [CompilerGeneratedAttribute]
internal void set_ClientConnectionCount(int value);
    [CompilerGeneratedAttribute]
public int get_ServerConnectionCount();
    [CompilerGeneratedAttribute]
internal void set_ServerConnectionCount(int value);
    [CompilerGeneratedAttribute]
public int get_ConnectionCapacity();
    [CompilerGeneratedAttribute]
internal void set_ConnectionCapacity(int value);
}
public enum Microsoft.Azure.SignalR.EndpointType : Enum {
    public int value__;
    public static EndpointType Primary;
    public static EndpointType Secondary;
}
internal static class Microsoft.Azure.SignalR.EpochTime : object {
    public static DateTime UnixEpoch;
    private static EpochTime();
    public static long GetIntDate(DateTime datetime);
    public static DateTime DateTime(long secondsSinceUnixEpoch);
}
public enum Microsoft.Azure.SignalR.GracefulShutdownMode : Enum {
    public int value__;
    public static GracefulShutdownMode Off;
    public static GracefulShutdownMode WaitForClientsClose;
    public static GracefulShutdownMode MigrateClients;
}
internal static class Microsoft.Azure.SignalR.HttpClientFactory : object {
    [CompilerGeneratedAttribute]
private static IHttpClientFactory <Instance>k__BackingField;
    public static IHttpClientFactory Instance { get; }
    private static HttpClientFactory();
    [CompilerGeneratedAttribute]
public static IHttpClientFactory get_Instance();
}
internal class Microsoft.Azure.SignalR.HubServiceEndpoint : ServiceEndpoint {
    private ServiceEndpoint _endpoint;
    private long _uniqueIndex;
    private static long s_currentIndex;
    private TaskCompletionSource`1<bool> _scaleTcs;
    [CompilerGeneratedAttribute]
private string <Hub>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceEndpointProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceConnectionContainer <ConnectionContainer>k__BackingField;
    public string Hub { get; }
    public string Name { get; }
    public IServiceEndpointProvider Provider { get; }
    public IServiceConnectionContainer ConnectionContainer { get; public set; }
    public Task ScaleTask { get; }
    public long UniqueIndex { get; }
    internal bool PendingReload { get; }
    public HubServiceEndpoint(string hub, IServiceEndpointProvider provider, ServiceEndpoint endpoint);
    [CompilerGeneratedAttribute]
public string get_Hub();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public IServiceEndpointProvider get_Provider();
    [CompilerGeneratedAttribute]
public IServiceConnectionContainer get_ConnectionContainer();
    [CompilerGeneratedAttribute]
public void set_ConnectionContainer(IServiceConnectionContainer value);
    public Task get_ScaleTask();
    public void CompleteScale();
    public void ResetScale();
    public long get_UniqueIndex();
    public virtual string ToString();
    internal virtual bool get_PendingReload();
}
internal interface Microsoft.Azure.SignalR.IAccessKeySynchronizer {
    public abstract virtual void AddServiceEndpoint(ServiceEndpoint endpoint);
    public abstract virtual void UpdateServiceEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
}
internal interface Microsoft.Azure.SignalR.IAccessTokenProvider {
    public abstract virtual Task`1<string> ProvideAsync();
}
internal interface Microsoft.Azure.SignalR.IBlazorDetector {
    public abstract virtual bool IsBlazor(string hubName);
    public abstract virtual bool TrySetBlazor(string hubName, bool isBlazor);
}
internal interface Microsoft.Azure.SignalR.ICallerClientResultsManager {
    public abstract virtual string GenerateInvocationId(string connectionId);
    public abstract virtual Task`1<T> AddInvocation(string hub, string connectionId, string invocationId, CancellationToken cancellationToken);
    public abstract virtual void AddServiceMapping(ServiceMappingMessage serviceMappingMessage);
    public abstract virtual void CleanupInvocationsByInstance(string instanceId);
    public abstract virtual bool TryCompleteResult(string connectionId, ClientCompletionMessage message);
    public abstract virtual bool TryCompleteResult(string connectionId, ErrorCompletionMessage message);
    public abstract virtual void RemoveInvocation(string invocationId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Azure.SignalR.IClientConnection {
    public string ConnectionId { get; }
    public string InstanceId { get; }
    public string HubProtocol { get; }
    [NullableAttribute("2")]
public IServiceConnection ServiceConnection { get; public set; }
    public abstract virtual string get_ConnectionId();
    public abstract virtual string get_InstanceId();
    public abstract virtual string get_HubProtocol();
    [NullableContextAttribute("2")]
public abstract virtual IServiceConnection get_ServiceConnection();
    [NullableContextAttribute("2")]
public abstract virtual void set_ServiceConnection(IServiceConnection value);
    public abstract virtual Task PauseAsync();
    public abstract virtual Task PauseAckAsync();
    public abstract virtual Task ResumeAsync();
}
internal interface Microsoft.Azure.SignalR.IClientConnectionFactory {
    public abstract virtual IClientConnection CreateConnection(OpenConnectionMessage message, Action`1<HttpContext> configureContext);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Azure.SignalR.IClientConnectionManager {
    public IEnumerable`1<IClientConnection> ClientConnections { get; }
    public int Count { get; }
    public abstract virtual IEnumerable`1<IClientConnection> get_ClientConnections();
    public abstract virtual int get_Count();
    public abstract virtual bool TryAddClientConnection(IClientConnection connection);
    public abstract virtual bool TryRemoveClientConnection(string connectionId, IClientConnection& connection);
    public abstract virtual bool TryGetClientConnection(string connectionId, IClientConnection& connection);
    public abstract virtual Task WhenAllCompleted();
}
internal interface Microsoft.Azure.SignalR.IClientInvocationManager {
    public ICallerClientResultsManager Caller { get; }
    public IRoutedClientResultsManager Router { get; }
    public abstract virtual ICallerClientResultsManager get_Caller();
    public abstract virtual IRoutedClientResultsManager get_Router();
    public abstract virtual bool TryGetInvocationReturnType(string invocationId, Type& type);
    public abstract virtual void CleanupInvocationsByConnection(string connectionId);
}
internal interface Microsoft.Azure.SignalR.IClientResultsManager {
    public abstract virtual bool TryCompleteResult(string connectionId, CompletionMessage message);
    public abstract virtual bool TryGetInvocationReturnType(string invocationId, Type& type);
    public abstract virtual void CleanupInvocationsByConnection(string connectionId);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.IConfigurationExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<ServiceEndpoint> GetEndpoints(IConfiguration configuration, string sectionName);
}
internal interface Microsoft.Azure.SignalR.IConnectionFactory {
    public abstract virtual Task`1<ConnectionContext> ConnectAsync(HubServiceEndpoint endpoint, TransferFormat transferFormat, string connectionId, string target, CancellationToken cancellationToken, IDictionary`2<string, string> headers);
    public abstract virtual Task DisposeAsync(ConnectionContext connection);
}
internal interface Microsoft.Azure.SignalR.IConnectionRequestIdProvider {
    public abstract virtual string GetRequestId();
}
public interface Microsoft.Azure.SignalR.IMessageRouter {
    public abstract virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForBroadcast(IEnumerable`1<ServiceEndpoint> endpoints);
    public abstract virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForUser(string userId, IEnumerable`1<ServiceEndpoint> endpoints);
    public abstract virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForGroup(string groupName, IEnumerable`1<ServiceEndpoint> endpoints);
    public abstract virtual IEnumerable`1<ServiceEndpoint> GetEndpointsForConnection(string connectionId, IEnumerable`1<ServiceEndpoint> endpoints);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.IMessageWithTracingIdExtensions : object {
    [ExtensionAttribute]
public static T WithTracingId(T message);
}
internal interface Microsoft.Azure.SignalR.IRoutedClientResultsManager {
    public abstract virtual void AddInvocation(string connectionId, string invocationId, string callerServerId, CancellationToken cancellationToken);
}
public interface Microsoft.Azure.SignalR.IServerNameProvider {
    public abstract virtual string GetName();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.IServiceCollectionExtension : object {
    [ExtensionAttribute]
public static IServiceCollection SetupOptions(IServiceCollection services, TOptionsSetup setupInstance);
    [ExtensionAttribute]
public static IServiceCollection SetupOptions(IServiceCollection services, Func`2<IServiceProvider, TOptionsSetup> implementationFactory);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Azure.SignalR.IServiceConnection {
    public string ConnectionId { get; }
    public string ServerId { get; }
    public ServiceConnectionStatus Status { get; }
    public Task ConnectionInitializedTask { get; }
    public Task ConnectionOfflineTask { get; }
    public abstract virtual string get_ConnectionId();
    public abstract virtual string get_ServerId();
    public abstract virtual ServiceConnectionStatus get_Status();
    public abstract virtual Task get_ConnectionInitializedTask();
    public abstract virtual Task get_ConnectionOfflineTask();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionStatusChanged(Action`1<StatusChange> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionStatusChanged(Action`1<StatusChange> value);
    public abstract virtual Task StartAsync(string target);
    public abstract virtual Task StopAsync();
    public abstract virtual Task WriteAsync(ServiceMessage serviceMessage);
    public abstract virtual Task`1<bool> SafeWriteAsync(ServiceMessage serviceMessage);
}
internal interface Microsoft.Azure.SignalR.IServiceConnectionContainer {
    public ServiceConnectionStatus Status { get; }
    public Task ConnectionInitializedTask { get; }
    public string ServersTag { get; }
    public bool HasClients { get; }
    public abstract virtual ServiceConnectionStatus get_Status();
    public abstract virtual Task get_ConnectionInitializedTask();
    public abstract virtual string get_ServersTag();
    public abstract virtual bool get_HasClients();
    public abstract virtual Task StartAsync();
    public abstract virtual Task StopAsync();
    public abstract virtual Task OfflineAsync(GracefulShutdownMode mode);
    public abstract virtual Task WriteAsync(ServiceMessage serviceMessage);
    public abstract virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    public abstract virtual Task StartGetServersPing();
    public abstract virtual Task StopGetServersPing();
}
internal interface Microsoft.Azure.SignalR.IServiceConnectionContainerFactory {
    public abstract virtual IServiceConnectionContainer Create(string hub);
}
internal interface Microsoft.Azure.SignalR.IServiceConnectionFactory {
    public abstract virtual IServiceConnection Create(HubServiceEndpoint endpoint, IServiceMessageHandler serviceMessageHandler, AckHandler ackHandler, ServiceConnectionType type);
}
internal interface Microsoft.Azure.SignalR.IServiceEndpointManager {
    public IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> Endpoints { get; }
    public abstract virtual IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> get_Endpoints();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAdd(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAdd(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRemove(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRemove(EndpointEventHandler value);
    public abstract virtual IServiceEndpointProvider GetEndpointProvider(ServiceEndpoint endpoint);
    public abstract virtual IReadOnlyList`1<HubServiceEndpoint> GetEndpoints(string hub);
}
internal interface Microsoft.Azure.SignalR.IServiceEndpointOptions {
    public ServiceEndpoint[] Endpoints { get; }
    public string ApplicationName { get; }
    public string ConnectionString { get; }
    public int InitialHubServerConnectionCount { get; }
    public Nullable`1<int> MaxHubServerConnectionCount { get; }
    public abstract virtual ServiceEndpoint[] get_Endpoints();
    public abstract virtual string get_ApplicationName();
    public abstract virtual string get_ConnectionString();
    public abstract virtual int get_InitialHubServerConnectionCount();
    public abstract virtual Nullable`1<int> get_MaxHubServerConnectionCount();
}
internal interface Microsoft.Azure.SignalR.IServiceEndpointProvider {
    public IWebProxy Proxy { get; }
    public abstract virtual Task`1<string> GenerateClientAccessTokenAsync(string hubName, IEnumerable`1<Claim> claims, Nullable`1<TimeSpan> lifetime);
    public abstract virtual string GetClientEndpoint(string hubName, string originalPath, string queryString);
    public abstract virtual IAccessTokenProvider GetServerAccessTokenProvider(string hubName, string serverId);
    public abstract virtual string GetServerEndpoint(string hubName);
    public abstract virtual IWebProxy get_Proxy();
}
public interface Microsoft.Azure.SignalR.IServiceEventHandler {
    public abstract virtual Task HandleAsync(string connectionId, ServiceEventMessage message);
}
internal interface Microsoft.Azure.SignalR.IServiceMessageHandler {
    public abstract virtual Task HandlePingAsync(PingMessage pingMessage);
    public abstract virtual void HandleAck(AckMessage ackMessage);
}
internal class Microsoft.Azure.SignalR.JsonPayloadMessageContent : HttpContent {
    private static MediaTypeHeaderValue ContentType;
    private static JsonWriterOptions JsonWriterOptions;
    private PayloadMessage _payloadMessage;
    private ObjectSerializer _jsonObjectSerializer;
    public JsonPayloadMessageContent(PayloadMessage payloadMessage, ObjectSerializer jsonObjectSerializer);
    private static JsonPayloadMessageContent();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.JsonPayloadMessageContent/<SerializeToStreamAsync>d__5")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
internal class Microsoft.Azure.SignalR.JwtHeader : Dictionary`2<string, object> {
    public JwtHeader(string kid, AccessTokenAlgorithm algorithm);
    public string Base64UrlEncode();
}
internal class Microsoft.Azure.SignalR.JwtPayload : Dictionary`2<string, object> {
    public JwtPayload(string issuer, string audience, IEnumerable`1<Claim> claims, Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, Nullable`1<DateTime> issuedAt);
    public void AddClaim(Claim claim);
    public void AddClaims(IEnumerable`1<Claim> claims);
    public string Base64UrlEncode();
}
internal class Microsoft.Azure.SignalR.JwtRegisteredClaimNames : ValueType {
    public static string Actort;
    public static string Acr;
    public static string Amr;
    public static string Aud;
    public static string AuthTime;
    public static string Azp;
    public static string Birthdate;
    public static string CHash;
    public static string AtHash;
    public static string Email;
    public static string Exp;
    public static string Gender;
    public static string FamilyName;
    public static string GivenName;
    public static string Iat;
    public static string Iss;
    public static string Jti;
    public static string Name;
    public static string NameId;
    public static string Nonce;
    public static string Nbf;
    public static string PhoneNumber;
    public static string PhoneNumberVerified;
    public static string Prn;
    public static string Sid;
    public static string Sub;
    public static string Typ;
    public static string UniqueName;
    public static string Website;
}
internal class Microsoft.Azure.SignalR.LocalTokenProvider : object {
    private AccessKey _accessKey;
    private AccessTokenAlgorithm _algorithm;
    private string _audience;
    private TimeSpan _tokenLifetime;
    private IEnumerable`1<Claim> _claims;
    public LocalTokenProvider(AccessKey accessKey, string audience, IEnumerable`1<Claim> claims, AccessTokenAlgorithm algorithm, Nullable`1<TimeSpan> tokenLifetime);
    public sealed virtual Task`1<string> ProvideAsync();
}
internal class Microsoft.Azure.SignalR.LogHelper : object {
    public static ArgumentNullException LogArgumentNullException(string name);
    public static Exception LogExceptionMessage(Exception exception);
    public static string FormatInvariant(string format, Object[] args);
}
internal static class Microsoft.Azure.SignalR.MessageLog : object {
    public static string StartToBroadcastMessageTemplate;
    public static string StartToBroadcastMessageWithExcludedConnectionTemplate;
    public static string StartToSendMessageToConnectionsTemplate;
    public static string StartToSendMessageToConnectionTemplate;
    public static string StartToBroadcastMessageToGroupTemplate;
    public static string StartToBroadcastMessageToGroupWithExcludedConnectionsTemplate;
    public static string StartToBroadcastMessageToGroupsTemplate;
    public static string StartToSendMessageToUserTemplate;
    public static string StartToSendMessageToUsersTemplate;
    public static string StartToAddConnectionToGroupTemplate;
    public static string StartToRemoveConnectionFromGroupTemplate;
    public static string StartToAddUserToGroupTemplate;
    public static string StartToAddUserToGroupWithTtlTemplate;
    public static string StartToRemoveUserFromGroupTemplate;
    public static string StartToRemoveUserFromAllGroupsTemplate;
    public static string StartToRemoveConnectionFromAllGroupsTemplate;
    public static string StartToCheckIfUserInGroupTemplate;
    public static string FailedToSendMessageTemplate;
    public static string SucceededToSendMessageTemplate;
    public static string ReceivedMessageFromClientConnectionTemplate;
    public static string StartToSendMessageToCloseConnectionTemplate;
    public static string StartToSendMessageToCheckConnectionTemplate;
    public static string StartToSendMessageToCheckIfUserExistsTemplate;
    public static string StartToSendMessageToCheckIfGroupExistsTemplate;
    private static Action`3<ILogger, Nullable`1<ulong>, Exception> _startToBroadcastMessage;
    private static Action`5<ILogger, Nullable`1<ulong>, int, string, Exception> _startToBroadcastMessageWithExcludedConnection;
    private static Action`5<ILogger, Nullable`1<ulong>, int, string, Exception> _startToSendMessageToConnections;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToSendMessageToConnection;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToBroadcastMessageToGroup;
    private static Action`6<ILogger, Nullable`1<ulong>, string, int, string, Exception> _startToBroadcastMessageToGroupWithExcludedConnections;
    private static Action`5<ILogger, Nullable`1<ulong>, int, string, Exception> _startToBroadcastMessageToGroups;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToSendMessageToUser;
    private static Action`5<ILogger, Nullable`1<ulong>, int, string, Exception> _startToSendMessageToUsers;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToAddConnectionToGroup;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToRemoveConnectionFromGroup;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToAddUserToGroup;
    private static Action`6<ILogger, Nullable`1<ulong>, string, string, Nullable`1<int>, Exception> _startToAddUserToGroupWithTtl;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToRemoveUserFromGroup;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToRemoveUserFromAllGroups;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToRemoveConnectionFromAllGroups;
    private static Action`3<ILogger, Nullable`1<ulong>, Exception> _failedToSendMessage;
    private static Action`3<ILogger, Nullable`1<ulong>, Exception> _succeededToSendMessage;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _receivedMessageFromService;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToCheckIfUserInGroup;
    private static Action`5<ILogger, Nullable`1<ulong>, string, string, Exception> _startToCloseConnection;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToCheckIfConnectionExists;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToCheckIfUserExists;
    private static Action`4<ILogger, Nullable`1<ulong>, string, Exception> _startToCheckIfGroupExists;
    private static MessageLog();
    public static void ReceiveMessageFromService(ILogger logger, ConnectionDataMessage message);
    public static void SucceededToSendMessage(ILogger logger, IMessageWithTracingId message);
    public static void FailedToSendMessage(ILogger logger, IMessageWithTracingId message, Exception ex);
    public static void StartToBroadcastMessage(ILogger logger, BroadcastDataMessage message);
    public static void StartToSendMessageToConnections(ILogger logger, MultiConnectionDataMessage message);
    public static void StartToSendMessageToConnection(ILogger logger, ConnectionDataMessage message);
    public static void StartToBroadcastMessageToGroup(ILogger logger, GroupBroadcastDataMessage message);
    public static void StartToBroadcastMessageToGroups(ILogger logger, MultiGroupBroadcastDataMessage message);
    public static void StartToSendMessageToUser(ILogger logger, UserDataMessage message);
    public static void StartToSendMessageToUsers(ILogger logger, MultiUserDataMessage message);
    public static void StartToAddConnectionToGroup(ILogger logger, JoinGroupWithAckMessage message);
    public static void StartToRemoveConnectionFromGroup(ILogger logger, LeaveGroupWithAckMessage message);
    public static void StartToAddUserToGroup(ILogger logger, UserJoinGroupMessage message);
    public static void StartToAddUserToGroup(ILogger logger, UserJoinGroupWithAckMessage message);
    public static void StartToRemoveUserFromGroup(ILogger logger, UserLeaveGroupMessage message);
    public static void StartToRemoveUserFromGroup(ILogger logger, UserLeaveGroupWithAckMessage message);
    public static void StartToCheckIfUserInGroup(ILogger logger, CheckUserInGroupWithAckMessage message);
    public static void StartToCloseConnection(ILogger logger, CloseConnectionMessage message);
    public static void StartToCheckIfConnectionExists(ILogger logger, CheckConnectionExistenceWithAckMessage message);
    public static void StartToCheckIfUserExists(ILogger logger, CheckUserExistenceWithAckMessage message);
    public static void StartToCheckIfGroupExists(ILogger logger, CheckGroupExistenceWithAckMessage message);
    private static void StartToAddUserToGroupCore(ILogger logger, Nullable`1<ulong> tracingId, string groupName, string userId, Nullable`1<int> ttl);
    private static void StartToRemoveUserFromGroupCore(ILogger logger, string userId, string groupName, Nullable`1<ulong> tracingId);
    private static void StartToRemoveConnectionFromGroupCore(ILogger logger, string connectionId, string groupName, Nullable`1<ulong> tracingId);
}
internal static class Microsoft.Azure.SignalR.MessageWithTracingIdHelper : object {
    [CompilerGeneratedAttribute]
private static ulong <Prefix>k__BackingField;
    private static int _index;
    internal static ulong Prefix { get; internal set; }
    private static MessageWithTracingIdHelper();
    [CompilerGeneratedAttribute]
internal static ulong get_Prefix();
    [CompilerGeneratedAttribute]
internal static void set_Prefix(ulong value);
    public static ulong Generate();
}
internal class Microsoft.Azure.SignalR.MicrosoftEntraAccessKey : AccessKey {
    internal static TimeSpan GetAccessKeyTimeout;
    private static int GetAccessKeyIntervalInMinute;
    private static int GetAccessKeyMaxRetryTimes;
    private static int GetMicrosoftEntraTokenMaxRetryTimes;
    private static string DefaultScope;
    private static TokenRequestContext DefaultRequestContext;
    private static TimeSpan GetAccessKeyInterval;
    private static TimeSpan GetAccessKeyIntervalWhenUnauthorized;
    private static TimeSpan GetAccessKeyRetryInterval;
    private TaskCompletionSource`1<object> _initializedTcs;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isAuthorized;
    private Exception _lastException;
    private DateTime _lastUpdatedTime;
    [CompilerGeneratedAttribute]
private TokenCredential <TokenCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GetAccessKeyUrl>k__BackingField;
    public bool IsAuthorized { get; private set; }
    public TokenCredential TokenCredential { get; }
    internal string GetAccessKeyUrl { get; }
    internal bool HasExpired { get; }
    private Task`1<object> InitializedTask { get; }
    public MicrosoftEntraAccessKey(Uri endpoint, TokenCredential credential, Uri serverEndpoint);
    private static MicrosoftEntraAccessKey();
    public bool get_IsAuthorized();
    private void set_IsAuthorized(bool value);
    [CompilerGeneratedAttribute]
public TokenCredential get_TokenCredential();
    [CompilerGeneratedAttribute]
internal string get_GetAccessKeyUrl();
    internal bool get_HasExpired();
    private Task`1<object> get_InitializedTask();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MicrosoftEntraAccessKey/<GetMicrosoftEntraTokenAsync>d__27")]
public virtual Task`1<string> GetMicrosoftEntraTokenAsync(CancellationToken ctoken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MicrosoftEntraAccessKey/<GenerateAccessTokenAsync>d__28")]
public virtual Task`1<string> GenerateAccessTokenAsync(string audience, IEnumerable`1<Claim> claims, TimeSpan lifetime, AccessTokenAlgorithm algorithm, CancellationToken ctoken);
    internal void UpdateAccessKey(string kid, string accessKey);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MicrosoftEntraAccessKey/<UpdateAccessKeyAsync>d__30")]
internal Task UpdateAccessKeyAsync(CancellationToken ctoken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MicrosoftEntraAccessKey/<GetAccessKeyInternalAsync>d__31")]
private Task GetAccessKeyInternalAsync(string accessToken, CancellationToken ctoken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MicrosoftEntraAccessKey/<HandleHttpResponseAsync>d__32")]
private Task`1<bool> HandleHttpResponseAsync(HttpResponseMessage response);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<string> <>n__0(string audience, IEnumerable`1<Claim> claims, TimeSpan lifetime, AccessTokenAlgorithm algorithm, CancellationToken ctoken);
}
internal class Microsoft.Azure.SignalR.MicrosoftEntraTokenProvider : object {
    private MicrosoftEntraAccessKey _accessKey;
    public MicrosoftEntraTokenProvider(MicrosoftEntraAccessKey accessKey);
    public sealed virtual Task`1<string> ProvideAsync();
}
internal class Microsoft.Azure.SignalR.MultiEndpointMessageWriter : object {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private HubServiceEndpoint[] <TargetEndpoints>k__BackingField;
    internal HubServiceEndpoint[] TargetEndpoints { get; }
    public Task ConnectionInitializedTask { get; }
    public ServiceConnectionStatus Status { get; }
    public string ServersTag { get; }
    public bool HasClients { get; }
    public MultiEndpointMessageWriter(IReadOnlyCollection`1<ServiceEndpoint> targetEndpoints, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
internal HubServiceEndpoint[] get_TargetEndpoints();
    public sealed virtual Task get_ConnectionInitializedTask();
    public sealed virtual Task WriteAsync(ServiceMessage serviceMessage);
    public sealed virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointMessageWriter/<WriteMultiResultAckableMessage>d__9")]
private Task`1<bool> WriteMultiResultAckableMessage(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointMessageWriter/<WriteSingleResultAckableMessage>d__10")]
private Task`1<bool> WriteSingleResultAckableMessage(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointMessageWriter/<WriteMultiEndpointMessageAsync>d__11")]
private Task WriteMultiEndpointMessageAsync(ServiceMessage serviceMessage, Func`2<IServiceConnectionContainer, Task> inner);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointMessageWriter/<WriteSingleEndpointMessageAsync>d__12")]
private Task WriteSingleEndpointMessageAsync(HubServiceEndpoint endpoint, ServiceMessage serviceMessage, Func`2<IServiceConnectionContainer, Task> inner);
    public sealed virtual Task StartAsync();
    public sealed virtual Task StopAsync();
    public sealed virtual void Dispose();
    public sealed virtual ServiceConnectionStatus get_Status();
    public sealed virtual string get_ServersTag();
    public sealed virtual bool get_HasClients();
    public sealed virtual Task OfflineAsync(GracefulShutdownMode mode);
    public sealed virtual Task StartGetServersPing();
    public sealed virtual Task StopGetServersPing();
}
internal class Microsoft.Azure.SignalR.MultiEndpointServiceConnectionContainer : object {
    private string _hubName;
    private IMessageRouter _router;
    private ILoggerFactory _loggerFactory;
    private ILogger _logger;
    private IServiceEndpointManager _serviceEndpointManager;
    private TimeSpan _scaleTimeout;
    private Func`2<HubServiceEndpoint, IServiceConnectionContainer> _generator;
    private object _lock;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<bool, IReadOnlyList`1<HubServiceEndpoint>> _routerEndpoints;
    private int _started;
    public ServiceConnectionStatus Status { get; }
    public Task ConnectionInitializedTask { get; }
    public string ServersTag { get; }
    public bool HasClients { get; }
    internal MultiEndpointServiceConnectionContainer(string hub, Func`2<HubServiceEndpoint, IServiceConnectionContainer> generator, IServiceEndpointManager endpointManager, IMessageRouter router, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> scaleTimeout);
    public MultiEndpointServiceConnectionContainer(IServiceConnectionFactory serviceConnectionFactory, string hub, int count, Nullable`1<int> maxCount, IServiceEndpointManager endpointManager, IMessageRouter router, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> scaleTimeout);
    public IEnumerable`1<HubServiceEndpoint> GetOnlineEndpoints();
    private static IServiceConnectionContainer CreateContainer(IServiceConnectionFactory serviceConnectionFactory, HubServiceEndpoint endpoint, int count, Nullable`1<int> maxCount, ILoggerFactory loggerFactory);
    public sealed virtual ServiceConnectionStatus get_Status();
    public sealed virtual Task get_ConnectionInitializedTask();
    public sealed virtual string get_ServersTag();
    public sealed virtual bool get_HasClients();
    public sealed virtual Task StartAsync();
    public sealed virtual Task StopAsync();
    public sealed virtual Task OfflineAsync(GracefulShutdownMode mode);
    public sealed virtual Task WriteAsync(ServiceMessage serviceMessage);
    public sealed virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    public sealed virtual Task StartGetServersPing();
    public sealed virtual Task StopGetServersPing();
    public sealed virtual void Dispose();
    internal IEnumerable`1<ServiceEndpoint> GetRoutedEndpoints(ServiceMessage message);
    private MultiEndpointMessageWriter CreateMessageWriter(ServiceMessage serviceMessage);
    private void OnAdd(HubServiceEndpoint endpoint);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointServiceConnectionContainer/<AddHubServiceEndpointAsync>d__33")]
private Task AddHubServiceEndpointAsync(HubServiceEndpoint endpoint);
    private void OnRemove(HubServiceEndpoint endpoint);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointServiceConnectionContainer/<RemoveHubServiceEndpointAsync>d__35")]
private Task RemoveHubServiceEndpointAsync(HubServiceEndpoint endpoint);
    private void UpdateEndpointsStore(HubServiceEndpoint endpoint, ScaleOperation operation);
    private void UpdateRoutedEndpoints(IReadOnlyList`1<HubServiceEndpoint> currentEndpoints);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointServiceConnectionContainer/<WaitForServerStable>d__38")]
private Task WaitForServerStable(IServiceConnectionContainer container, HubServiceEndpoint endpoint);
    private bool IsServerReady(IServiceConnectionContainer container);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.MultiEndpointServiceConnectionContainer/<WaitForClientsDisconnect>d__40")]
private Task WaitForClientsDisconnect(HubServiceEndpoint endpoint);
    private IEnumerable`1<ServiceEndpoint> SingleOrNotSupported(IEnumerable`1<ServiceEndpoint> endpoints, ServiceMessage message);
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__22_0(HubServiceEndpoint s);
    [CompilerGeneratedAttribute]
private Task <StopAsync>b__23_0(HubServiceEndpoint s);
}
internal class Microsoft.Azure.SignalR.ParsedConnectionString : object {
    [CompilerGeneratedAttribute]
private AccessKey <AccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ClientEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServerEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    internal AccessKey AccessKey { get; internal set; }
    internal Uri Endpoint { get; internal set; }
    internal Uri ClientEndpoint { get; internal set; }
    internal Uri ServerEndpoint { get; internal set; }
    internal string Version { get; internal set; }
    [CompilerGeneratedAttribute]
internal AccessKey get_AccessKey();
    [CompilerGeneratedAttribute]
internal void set_AccessKey(AccessKey value);
    [CompilerGeneratedAttribute]
internal Uri get_Endpoint();
    [CompilerGeneratedAttribute]
internal void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_ClientEndpoint();
    [CompilerGeneratedAttribute]
internal void set_ClientEndpoint(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_ServerEndpoint();
    [CompilerGeneratedAttribute]
internal void set_ServerEndpoint(Uri value);
    [CompilerGeneratedAttribute]
internal string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
}
internal class Microsoft.Azure.SignalR.PauseHandler : object {
    private SemaphoreSlim _pauseSemaphore;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _paused;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _pauseAcked;
    public bool ShouldReplyAck { get; }
    public bool get_ShouldReplyAck();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.PauseHandler/<WaitAsync>d__5")]
public Task`1<bool> WaitAsync(int ms, CancellationToken ctoken);
    public void Release();
    public Task PauseAsync();
    public Task ResumeAsync();
}
internal class Microsoft.Azure.SignalR.PayloadMessage : object {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public string Target { get; public set; }
    public Object[] Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(Object[] value);
}
internal static class Microsoft.Azure.SignalR.ProductInfo : object {
    public static string GetProductInfo(Assembly assembly);
}
internal class Microsoft.Azure.SignalR.RestApiAccessTokenGenerator : object {
    private AccessKey _accessKey;
    private Claim[] _claims;
    private static AccessTokenAlgorithm DefaultAlgorithm;
    public RestApiAccessTokenGenerator(AccessKey accessKey, string serverName);
    public Task`1<string> Generate(string audience, Nullable`1<TimeSpan> lifetime);
    public static string GenerateServerName();
}
internal class Microsoft.Azure.SignalR.RestApiEndpoint : object {
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, StringValues> <Query>k__BackingField;
    public string Audience { get; }
    public string Token { get; }
    public IDictionary`2<string, StringValues> Query { get; public set; }
    public RestApiEndpoint(string endpoint, string token);
    [CompilerGeneratedAttribute]
public string get_Audience();
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, StringValues> get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(IDictionary`2<string, StringValues> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Azure.SignalR.RestClient : object {
    private IHttpClientFactory _httpClientFactory;
    private IPayloadContentBuilder _payloadContentBuilder;
    public RestClient(IHttpClientFactory httpClientFactory, IPayloadContentBuilder contentBuilder);
    internal RestClient(IHttpClientFactory httpClientFactory);
    public Task SendAsync(RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args, Func`2<HttpResponseMessage, bool> handleExpectedResponse, CancellationToken cancellationToken);
    public Task SendAsync(RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args, Func`2<HttpResponseMessage, Task`1<bool>> handleExpectedResponseAsync, CancellationToken cancellationToken);
    public Task SendWithRetryAsync(RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args, Func`2<HttpResponseMessage, bool> handleExpectedResponse, CancellationToken cancellationToken);
    public Task SendMessageWithRetryAsync(RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args, Func`2<HttpResponseMessage, bool> handleExpectedResponse, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.RestClient/<ThrowExceptionOnResponseFailureAsync>d__8")]
private Task ThrowExceptionOnResponseFailureAsync(HttpResponseMessage response);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.RestClient/<SendAsyncCore>d__9")]
private Task SendAsyncCore(string httpClientName, RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args, Func`2<HttpResponseMessage, Task`1<bool>> handleExpectedResponseAsync, CancellationToken cancellationToken);
    private static Uri GetUri(string url, IDictionary`2<string, StringValues> query);
    private HttpRequestMessage BuildRequest(RestApiEndpoint api, HttpMethod httpMethod, string methodName, Object[] args);
    private HttpRequestMessage GenerateHttpRequest(string url, IDictionary`2<string, StringValues> query, HttpMethod httpMethod, PayloadMessage payload, string tokenString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Azure.SignalR.ReusableUtf8JsonWriter : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ReusableUtf8JsonWriter _cachedInstance;
    private Utf8JsonWriter _writer;
    public ReusableUtf8JsonWriter(IBufferWriter`1<byte> stream);
    public static ReusableUtf8JsonWriter Get(IBufferWriter`1<byte> stream);
    public static void Return(ReusableUtf8JsonWriter writer);
    public Utf8JsonWriter GetJsonWriter();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.RuntimeServicePingMessage : object {
    private static string EchoKey;
    private static string OfflineKey;
    private static string TargetKey;
    private static string StatusKey;
    private static string ShutdownKey;
    private static string ServersKey;
    private static string ClientCountKey;
    private static string ServerCountKey;
    private static string CapacityKey;
    private static string DiagnosticLogsMessagingTypeKey;
    private static string MessagingLogEnableValue;
    private static string StatusActiveValue;
    private static string StatusInactiveValue;
    private static string ShutdownFinValue;
    private static string ShutdownFinMigrateClientsValue;
    private static string ShutdownFinWaitForClientsValue;
    private static string ShutdownFinAckValue;
    private static PingMessage StatusActive;
    private static PingMessage StatusInactive;
    private static PingMessage ShutdownFin;
    private static PingMessage ShutdownFinMigrateClients;
    private static PingMessage ShutdownFinWaitForClients;
    private static PingMessage ShutdownFinAck;
    private static PingMessage ServersTag;
    private static RuntimeServicePingMessage();
    [ExtensionAttribute]
public static bool IsEchoMessage(PingMessage ping);
    [ExtensionAttribute]
public static bool TryGetMessageLogEnableFlag(PingMessage ping, Boolean& enableMessageLog);
    [ExtensionAttribute]
public static bool TryGetOffline(PingMessage ping, String& instanceId);
    [ExtensionAttribute]
public static bool TryGetRebalance(PingMessage ping, String& target);
    public static PingMessage GetStatusPingMessage(bool isActive);
    public static PingMessage GetStatusPingMessage(bool isActive, int clientCount);
    [ExtensionAttribute]
public static bool TryGetStatus(PingMessage ping, Boolean& isActive);
    [ExtensionAttribute]
public static bool TryGetClientCount(PingMessage ping, Int32& clientCount);
    [ExtensionAttribute]
public static bool TryGetServerCount(PingMessage ping, Int32& serverCount);
    [ExtensionAttribute]
public static bool TryGetConnectionCapacity(PingMessage ping, Int32& connectionCapacity);
    [ExtensionAttribute]
public static bool TryGetServersTag(PingMessage ping, String& serversTag, Int64& updatedTime);
    public static PingMessage GetFinPingMessage(GracefulShutdownMode mode);
    public static PingMessage GetFinAckPingMessage();
    public static PingMessage GetServersPingMessage();
    [ExtensionAttribute]
public static bool IsFin(ServiceMessage serviceMessage);
    [ExtensionAttribute]
public static bool IsFinAck(PingMessage ping);
    [ExtensionAttribute]
public static bool IsGetServers(ServiceMessage serviceMessage);
    internal static bool TryGetValue(PingMessage pingMessage, string key, String& value);
}
internal enum Microsoft.Azure.SignalR.ScaleOperation : Enum {
    public int value__;
    public static ScaleOperation Add;
    public static ScaleOperation Remove;
}
public enum Microsoft.Azure.SignalR.ServerStickyMode : Enum {
    public int value__;
    public static ServerStickyMode Disabled;
    public static ServerStickyMode Preferred;
    public static ServerStickyMode Required;
}
internal abstract class Microsoft.Azure.SignalR.ServiceConnectionBase : object {
    protected static TimeSpan DefaultHandshakeTimeout;
    private static TimeSpan DefaultServiceTimeout;
    private static long DefaultServiceTimeoutTicks;
    private static TimeSpan DefaultKeepAliveInterval;
    private static TimeSpan DefaultSyncAzureIdentityInterval;
    private static long DefaultKeepAliveTicks;
    private ReadOnlyMemory`1<byte> _cachedPingBytes;
    private HandshakeRequestMessage _handshakeRequest;
    private SemaphoreSlim _writeLock;
    private TaskCompletionSource`1<bool> _serviceConnectionStartTcs;
    private TaskCompletionSource`1<object> _serviceConnectionOfflineTcs;
    private ServiceConnectionType _connectionType;
    private IServiceMessageHandler _serviceMessageHandler;
    private IServiceEventHandler _serviceEventHandler;
    private IClientConnectionManager _clientConnectionManager;
    private object _statusLock;
    private string _endpointName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _errorMessage;
    private long _lastReceiveTimestamp;
    private long _lastSendTimestamp;
    private ServiceConnectionStatus _status;
    private int _started;
    private ConnectionContext _connectionContext;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private HubServiceEndpoint <HubEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProtocol <ServiceProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<StatusChange> ConnectionStatusChanged;
    public ServiceConnectionStatus Status { get; protected set; }
    public Task ConnectionInitializedTask { get; }
    public Task ConnectionOfflineTask { get; }
    public string ServerId { get; }
    public string ConnectionId { get; }
    protected HubServiceEndpoint HubEndpoint { get; }
    protected ILogger Logger { get; }
    protected IServiceProtocol ServiceProtocol { get; }
    protected ServiceConnectionBase(IServiceProtocol serviceProtocol, string serverId, string connectionId, HubServiceEndpoint endpoint, IServiceMessageHandler serviceMessageHandler, IServiceEventHandler serviceEventHandler, IClientConnectionManager clientConnectionManager, ServiceConnectionType connectionType, ILogger logger, GracefulShutdownMode mode, bool allowStatefulReconnects);
    private static ServiceConnectionBase();
    public sealed virtual ServiceConnectionStatus get_Status();
    protected void set_Status(ServiceConnectionStatus value);
    public sealed virtual Task get_ConnectionInitializedTask();
    public sealed virtual Task get_ConnectionOfflineTask();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServerId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConnectionId();
    [CompilerGeneratedAttribute]
protected HubServiceEndpoint get_HubEndpoint();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected IServiceProtocol get_ServiceProtocol();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionStatusChanged(Action`1<StatusChange> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionStatusChanged(Action`1<StatusChange> value);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<StartAsync>d__49")]
public sealed virtual Task StartAsync(string target);
    public sealed virtual Task StopAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<WriteAsync>d__51")]
public sealed virtual Task WriteAsync(ServiceMessage serviceMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<SafeWriteAsync>d__52")]
public virtual Task`1<bool> SafeWriteAsync(ServiceMessage serviceMessage);
    public abstract virtual bool TryAddClientConnection(IClientConnection connection);
    public abstract virtual bool TryRemoveClientConnection(string connectionId, IClientConnection& connection);
    protected abstract virtual Task`1<ConnectionContext> CreateConnection(string target);
    protected abstract virtual Task DisposeConnection(ConnectionContext connection);
    protected abstract virtual Task CleanupClientConnections(string fromInstanceId);
    protected abstract virtual Task OnClientConnectedAsync(OpenConnectionMessage openConnectionMessage);
    protected abstract virtual Task OnClientDisconnectedAsync(CloseConnectionMessage closeConnectionMessage);
    protected abstract virtual Task OnClientMessageAsync(ConnectionDataMessage connectionDataMessage);
    protected Task OnServiceErrorAsync(ServiceErrorMessage serviceErrorMessage);
    protected virtual Task OnPingMessageAsync(PingMessage pingMessage);
    protected Task OnAckMessageAsync(AckMessage ackMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<HandshakeAsync>d__64")]
protected virtual Task`1<bool> HandshakeAsync(ConnectionContext context);
    protected virtual Task DispatchMessageAsync(ServiceMessage message);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<TrySendPingAsync>d__66")]
protected virtual ValueTask TrySendPingAsync();
    protected virtual ReadOnlyMemory`1<byte> GetPingMessage();
    private Task OnEventMessageAsync(ServiceEventMessage message);
    private Task OnAccessKeyMessageAsync(AccessKeyResponseMessage keyMessage);
    private Task OfflineAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<PauseClientConnectionAsync>d__71")]
private Task PauseClientConnectionAsync(IClientConnection clientConnection);
    private Task ResumeClientConnectionAsync(IClientConnection clientConnection);
    private Task OnFlowControlMessageAsync(ConnectionFlowControlMessage flowControlMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<EstablishConnectionAsync>d__74")]
private Task`1<ConnectionContext> EstablishConnectionAsync(string target);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<SendHandshakeRequestAsync>d__75")]
private Task SendHandshakeRequestAsync(PipeWriter output);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<ReceiveHandshakeResponseAsync>d__76")]
private Task`1<bool> ReceiveHandshakeResponseAsync(PipeReader input, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<UpdateAzureIdentityAsync>d__77")]
private Task UpdateAzureIdentityAsync(MicrosoftEntraAccessKey key, TimerAwaitable timer);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<SendAccessKeyRequestMessageAsync>d__78")]
private Task SendAccessKeyRequestMessageAsync(MicrosoftEntraAccessKey key);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<ProcessIncomingAsync>d__79")]
private Task ProcessIncomingAsync(ConnectionContext connection);
    private TimerAwaitable StartKeepAliveTimer();
    private void UpdateReceiveTimestamp();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionBase/<KeepAliveAsync>d__82")]
private Task KeepAliveAsync(TimerAwaitable timer);
}
internal abstract class Microsoft.Azure.SignalR.ServiceConnectionContainerBase : object {
    private static int CheckWindow;
    private static int MaxRetryRemoveSeverConnection;
    private static TimeSpan CheckTimeSpan;
    private static int MaxReconnectBackOffInternalInMilliseconds;
    private static TimeSpan MessageWriteRetryDelay;
    private static int MessageWriteMaxRetry;
    private static long DefaultServersPingTimeoutTicks;
    private static Tuple`2<string, long> DefaultServersTagContext;
    private IReadOnlyDictionary`2<byte, StrongBox`1<WeakReference`1<IServiceConnection>>> _partitionedCache;
    private BackOffPolicy _backOffPolicy;
    private object _lock;
    private object _statusLock;
    private AckHandler _ackHandler;
    private CustomizedPingTimer _statusPing;
    private CustomizedPingTimer _serversPing;
    private ServiceDiagnosticLogsContext _serviceDiagnosticLogsContext;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<int, Nullable`1<DateTime>> _inactiveInfo;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) _serviceConnections;
    private ServiceConnectionStatus modreq(System.Runtime.CompilerServices.IsVolatile) _status;
    private Tuple`2 modreq(System.Runtime.CompilerServices.IsVolatile) _serversTagContext;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasClients;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _terminated;
    [CompilerGeneratedAttribute]
private HubServiceEndpoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceConnectionFactory <ServiceConnectionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FixedConnectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceConnectionType <InitialConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<StatusChange> ConnectionStatusChanged;
    public HubServiceEndpoint Endpoint { get; }
    public string ServersTag { get; }
    public bool HasClients { get; }
    public ServiceConnectionStatus Status { get; private set; }
    public Task ConnectionInitializedTask { get; }
    protected ILogger Logger { get; }
    protected List`1<IServiceConnection> ServiceConnections { get; protected set; }
    protected IServiceConnectionFactory ServiceConnectionFactory { get; }
    protected int FixedConnectionCount { get; }
    protected ServiceConnectionType InitialConnectionType { get; }
    private static TimeSpan ReconnectInterval { get; }
    protected ServiceConnectionContainerBase(IServiceConnectionFactory serviceConnectionFactory, int minConnectionCount, HubServiceEndpoint endpoint, IReadOnlyList`1<IServiceConnection> initialConnections, ILogger logger, AckHandler ackHandler);
    private static ServiceConnectionContainerBase();
    [CompilerGeneratedAttribute]
public HubServiceEndpoint get_Endpoint();
    public sealed virtual string get_ServersTag();
    public sealed virtual bool get_HasClients();
    public sealed virtual ServiceConnectionStatus get_Status();
    private void set_Status(ServiceConnectionStatus value);
    public sealed virtual Task get_ConnectionInitializedTask();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    protected List`1<IServiceConnection> get_ServiceConnections();
    protected void set_ServiceConnections(List`1<IServiceConnection> value);
    [CompilerGeneratedAttribute]
protected IServiceConnectionFactory get_ServiceConnectionFactory();
    [CompilerGeneratedAttribute]
protected int get_FixedConnectionCount();
    [CompilerGeneratedAttribute]
protected virtual ServiceConnectionType get_InitialConnectionType();
    private static TimeSpan get_ReconnectInterval();
    [CompilerGeneratedAttribute]
public void add_ConnectionStatusChanged(Action`1<StatusChange> value);
    [CompilerGeneratedAttribute]
public void remove_ConnectionStatusChanged(Action`1<StatusChange> value);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<StartAsync>d__55")]
public sealed virtual Task StartAsync();
    public virtual Task StopAsync();
    public virtual Task HandlePingAsync(PingMessage pingMessage);
    public sealed virtual void HandleAck(AckMessage ackMessage);
    public virtual Task WriteAsync(ServiceMessage serviceMessage);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<WriteAckableMessageAsync>d__60")]
public sealed virtual Task`1<bool> WriteAckableMessageAsync(ServiceMessage serviceMessage, CancellationToken cancellationToken);
    public virtual Task OfflineAsync(GracefulShutdownMode mode);
    public sealed virtual Task StartGetServersPing();
    public sealed virtual Task StopGetServersPing();
    public sealed virtual void Dispose();
    internal static TimeSpan GetRetryDelay(int retryCount);
    internal bool GetServiceStatus(bool active, int checkWindow, TimeSpan checkTimeSpan);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<StartCoreAsync>d__67")]
protected Task StartCoreAsync(IServiceConnection connection, string target);
    protected IServiceConnection CreateServiceConnectionCore(ServiceConnectionType type);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<OnConnectionComplete>d__69")]
protected virtual Task OnConnectionComplete(IServiceConnection serviceConnection);
    protected void AddOnDemandConnection(IServiceConnection serviceConnection);
    protected virtual void Dispose(bool disposing);
    protected virtual ServiceConnectionStatus GetStatus();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<RemoveConnectionAsync>d__73")]
protected Task RemoveConnectionAsync(IServiceConnection c, GracefulShutdownMode mode);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<WriteMessageAsync>d__74")]
private Task WriteMessageAsync(ServiceMessage serviceMessage);
    private IServiceConnection SelectConnection(ServiceMessage message);
    private bool IsActiveConnection(IServiceConnection connection);
    private IServiceConnection GetRandomActiveConnection();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<RestartFixedServiceConnectionCoreAsync>d__78")]
private Task RestartFixedServiceConnectionCoreAsync(int index);
    private void ReplaceFixedConnection(int index, IServiceConnection serviceConnection);
    private void RemoveOnDemandConnection(IServiceConnection serviceConnection);
    private void OnStatusChanged(StatusChange obj);
    private void OnConnectionStatusChanged(StatusChange obj);
    [IteratorStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<CreateFixedServiceConnection>d__83")]
private IEnumerable`1<IServiceConnection> CreateFixedServiceConnection(int count);
    private Task WriteServiceStatusPingAsync();
    private Task WriteServersPingAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceConnectionContainerBase/<SafeWriteAsync>d__86")]
private Task SafeWriteAsync(ServiceMessage serviceMessage);
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__55_0(IServiceConnection c);
}
internal class Microsoft.Azure.SignalR.ServiceConnectionContainerFactory : object {
    private IServiceEndpointOptions _options;
    private ILoggerFactory _loggerFactory;
    private IServiceEndpointManager _serviceEndpointManager;
    private IMessageRouter _router;
    private IServiceConnectionFactory _serviceConnectionFactory;
    private Nullable`1<TimeSpan> _serviceScaleTimeout;
    public ServiceConnectionContainerFactory(IServiceConnectionFactory serviceConnectionFactory, IServiceEndpointManager serviceEndpointManager, IMessageRouter router, IServiceEndpointOptions options, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> serviceScaleTimeout);
    public sealed virtual IServiceConnectionContainer Create(string hub);
}
internal class Microsoft.Azure.SignalR.ServiceConnectionContainerScope : object {
    private static AsyncLocal`1<ServiceDiagnosticLogsContext> _asyncLocal;
    private bool _needCleanup;
    public static bool IsScopeEstablished { get; }
    public static bool EnableMessageLog { get; }
    public ServiceConnectionContainerScope(ServiceDiagnosticLogsContext props);
    private static ServiceConnectionContainerScope();
    public static bool get_IsScopeEstablished();
    public static bool get_EnableMessageLog();
    public sealed virtual void Dispose();
}
internal enum Microsoft.Azure.SignalR.ServiceConnectionStatus : Enum {
    public int value__;
    public static ServiceConnectionStatus Inited;
    public static ServiceConnectionStatus Disconnected;
    public static ServiceConnectionStatus Connecting;
    public static ServiceConnectionStatus Connected;
}
internal enum Microsoft.Azure.SignalR.ServiceConnectionType : Enum {
    public int value__;
    public static ServiceConnectionType Default;
    public static ServiceConnectionType OnDemand;
    public static ServiceConnectionType Weak;
}
internal class Microsoft.Azure.SignalR.ServiceDiagnosticLogsContext : object {
    [CompilerGeneratedAttribute]
private bool <EnableMessageLog>k__BackingField;
    public bool EnableMessageLog { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableMessageLog();
    [CompilerGeneratedAttribute]
public void set_EnableMessageLog(bool value);
}
public class Microsoft.Azure.SignalR.ServiceEndpoint : object {
    private Uri _serviceEndpoint;
    private Uri _serverEndpoint;
    private Uri _clientEndpoint;
    private TokenCredential _tokenCredential;
    private object _lock;
    private AccessKey modreq(System.Runtime.CompilerServices.IsVolatile) _accessKey;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointType <EndpointType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Online>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointMetrics <EndpointMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AudienceBaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PendingReload>k__BackingField;
    public string ConnectionString { get; }
    public EndpointType EndpointType { get; }
    public string Name { get; internal set; }
    public Uri ServerEndpoint { get; public set; }
    public Uri ClientEndpoint { get; public set; }
    public bool Online { get; internal set; }
    public bool IsActive { get; internal set; }
    public EndpointMetrics EndpointMetrics { get; internal set; }
    public string Endpoint { get; }
    internal string AudienceBaseUrl { get; }
    internal string Version { get; }
    internal AccessKey AccessKey { get; private set; }
    internal bool PendingReload { get; internal set; }
    [EditorBrowsableAttribute("1")]
public ServiceEndpoint(string nameWithEndpointType, string connectionString);
    public ServiceEndpoint(string connectionString, EndpointType type, string name);
    [EditorBrowsableAttribute("1")]
public ServiceEndpoint(string nameWithEndpointType, Uri endpoint, TokenCredential credential);
    public ServiceEndpoint(Uri endpoint, TokenCredential credential, EndpointType endpointType, string name, Uri serverEndpoint, Uri clientEndpoint);
    public ServiceEndpoint(ServiceEndpoint other);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public EndpointType get_EndpointType();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
internal virtual void set_Name(string value);
    public Uri get_ServerEndpoint();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ServerEndpoint(Uri value);
    public Uri get_ClientEndpoint();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClientEndpoint(Uri value);
    [CompilerGeneratedAttribute]
public bool get_Online();
    [CompilerGeneratedAttribute]
internal void set_Online(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
internal void set_IsActive(bool value);
    [CompilerGeneratedAttribute]
public EndpointMetrics get_EndpointMetrics();
    [CompilerGeneratedAttribute]
internal void set_EndpointMetrics(EndpointMetrics value);
    [CompilerGeneratedAttribute]
public string get_Endpoint();
    [CompilerGeneratedAttribute]
internal string get_AudienceBaseUrl();
    [CompilerGeneratedAttribute]
internal string get_Version();
    internal AccessKey get_AccessKey();
    private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccessKey(AccessKey value);
    [CompilerGeneratedAttribute]
internal virtual bool get_PendingReload();
    [CompilerGeneratedAttribute]
internal virtual void set_PendingReload(bool value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static string BuildAudienceBaseUrlEndWithSlash(Uri uri);
    private static string BuildEndpointString(Uri uri);
    private static ValueTuple`2<string, EndpointType> Parse(string nameWithEndpointType);
    private static void CheckScheme(Uri uri);
}
internal abstract class Microsoft.Azure.SignalR.ServiceEndpointManagerBase : object {
    private ConcurrentDictionary`2<string, IReadOnlyList`1<HubServiceEndpoint>> _endpointsPerHub;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> <Endpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointEventHandler OnAdd;
    [CompilerGeneratedAttribute]
private EndpointEventHandler OnRemove;
    public IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> Endpoints { get; private set; }
    protected ServiceEndpointManagerBase(IServiceEndpointOptions options, ILogger logger);
    internal ServiceEndpointManagerBase(IEnumerable`1<ServiceEndpoint> endpoints, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> get_Endpoints();
    [CompilerGeneratedAttribute]
private void set_Endpoints(IReadOnlyDictionary`2<ServiceEndpoint, ServiceEndpoint> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAdd(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAdd(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRemove(EndpointEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRemove(EndpointEventHandler value);
    public abstract virtual IServiceEndpointProvider GetEndpointProvider(ServiceEndpoint endpoint);
    public sealed virtual IReadOnlyList`1<HubServiceEndpoint> GetEndpoints(string hub);
    protected Dictionary`2<ServiceEndpoint, ServiceEndpoint> GetValuableEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<ReloadServiceEndpointsAsync>d__17")]
protected virtual Task ReloadServiceEndpointsAsync(IEnumerable`1<ServiceEndpoint> serviceEndpoints, TimeSpan scaleTimeout);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<AddServiceEndpointsAsync>d__18")]
private Task AddServiceEndpointsAsync(IReadOnlyList`1<ServiceEndpoint> endpoints, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<RemoveServiceEndpointsAsync>d__19")]
private Task RemoveServiceEndpointsAsync(IReadOnlyList`1<ServiceEndpoint> endpoints, CancellationToken cancellationToken);
    private void AddEndpointsToNegotiationStore(Dictionary`2<string, IReadOnlyList`1<HubServiceEndpoint>> endpoints);
    private IReadOnlyList`1<HubServiceEndpoint> UpdateAndGetRemovedHubServiceEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
    private HubServiceEndpoint CreateHubServiceEndpoint(string hub, ServiceEndpoint endpoint);
    private IReadOnlyList`1<HubServiceEndpoint> CreateHubServiceEndpoints(string hub, IEnumerable`1<ServiceEndpoint> endpoints);
    private Dictionary`2<string, IReadOnlyList`1<HubServiceEndpoint>> CreateHubServiceEndpoints(IEnumerable`1<ServiceEndpoint> endpoints);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<AddHubServiceEndpointAsync>d__25")]
private Task AddHubServiceEndpointAsync(HubServiceEndpoint endpoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<RemoveHubServiceEndpointAsync>d__26")]
private Task RemoveHubServiceEndpointAsync(HubServiceEndpoint endpoint, CancellationToken cancellationToken);
    private void UpdateEndpoints(Dictionary`2<ServiceEndpoint, ServiceEndpoint> updatedEndpoints, IReadOnlyList`1& addedEndpoints, IReadOnlyList`1& removedEndpoints);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointManagerBase/<WaitTaskOrTimeout>d__28")]
private static Task`1<bool> WaitTaskOrTimeout(Task task, CancellationTokenSource cts);
    [CompilerGeneratedAttribute]
private ServiceEndpoint <GetValuableEndpoints>b__16_1(IGrouping`2<string, ServiceEndpoint> s);
}
internal static class Microsoft.Azure.SignalR.ServiceEndpointUtility : object {
    [IteratorStateMachineAttribute("Microsoft.Azure.SignalR.ServiceEndpointUtility/<Merge>d__0")]
public static IEnumerable`1<ServiceEndpoint> Merge(string connectionString, IEnumerable`1<ServiceEndpoint> endpoints);
}
internal class Microsoft.Azure.SignalR.SignalRJwtSecurityTokenHandler : object {
    public static IDictionary`2<string, string> DefaultOutboundClaimTypeMap;
    private static IDictionary`2<string, string> _outboundClaimTypeMap;
    private static SignalRJwtSecurityTokenHandler();
    public string CreateJwtSecurityToken(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, Nullable`1<DateTime> issuedAt, string issuer, string audience, ClaimsIdentity subject, Byte[] key, string kid, AccessTokenAlgorithm algorithm);
    [IteratorStateMachineAttribute("Microsoft.Azure.SignalR.SignalRJwtSecurityTokenHandler/<OutboundClaimTypeTransform>d__3")]
private static IEnumerable`1<Claim> OutboundClaimTypeTransform(IEnumerable`1<Claim> claims);
}
internal class Microsoft.Azure.SignalR.StaticRandom : object {
    private static object RandomLock;
    private static Random RandomInterval;
    private static StaticRandom();
    public static int Next(int maxValue);
    public static int Next(int minValue, int maxValue);
}
internal class Microsoft.Azure.SignalR.StatusChange : object {
    [CompilerGeneratedAttribute]
private ServiceConnectionStatus <OldStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceConnectionStatus <NewStatus>k__BackingField;
    public ServiceConnectionStatus OldStatus { get; }
    public ServiceConnectionStatus NewStatus { get; }
    public StatusChange(ServiceConnectionStatus oldStatus, ServiceConnectionStatus newStatus);
    [CompilerGeneratedAttribute]
public ServiceConnectionStatus get_OldStatus();
    [CompilerGeneratedAttribute]
public ServiceConnectionStatus get_NewStatus();
}
internal class Microsoft.Azure.SignalR.StrongServiceConnectionContainer : ServiceConnectionContainerBase {
    private Nullable`1<int> _maxConnectionCount;
    public StrongServiceConnectionContainer(IServiceConnectionFactory serviceConnectionFactory, int fixedConnectionCount, Nullable`1<int> maxConnectionCount, HubServiceEndpoint endpoint, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.StrongServiceConnectionContainer/<HandlePingAsync>d__2")]
public virtual Task HandlePingAsync(PingMessage pingMessage);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(PingMessage pingMessage);
}
internal class Microsoft.Azure.SignalR.TimerAwaitable : object {
    private Timer _timer;
    private Action _callback;
    private static Action _callbackCompleted;
    private TimeSpan _period;
    private TimeSpan _dueTime;
    private bool _disposed;
    private bool _running;
    private object _lockObj;
    public bool IsCompleted { get; }
    public TimerAwaitable(TimeSpan dueTime, TimeSpan period);
    private static TimerAwaitable();
    public void Start();
    public TimerAwaitable GetAwaiter();
    public bool get_IsCompleted();
    public bool GetResult();
    private void Tick();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public void Stop();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class Microsoft.Azure.SignalR.TokenUtilities : object {
    internal static string Json;
    internal static string JsonArray;
    internal static string JsonNull;
    internal static object GetClaimValueUsingValueType(Claim claim);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.SignalR.UriExtensions : object {
    [ExtensionAttribute]
public static Uri Append(Uri uri, String[] paths);
}
internal class Microsoft.Azure.SignalR.WebSocketConnectionContext : ConnectionContext {
    private WebSocketsTransport _websocketTransport;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureCollection <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDuplexPipe <Transport>k__BackingField;
    public string ConnectionId { get; public set; }
    public IFeatureCollection Features { get; }
    public IDictionary`2<object, object> Items { get; public set; }
    public IDuplexPipe Transport { get; public set; }
    public WebSocketConnectionContext(WebSocketConnectionOptions httpConnectionOptions, ILoggerFactory loggerFactory, IAccessTokenProvider accessTokenProvider);
    [CompilerGeneratedAttribute]
public virtual string get_ConnectionId();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public virtual IFeatureCollection get_Features();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<object, object> get_Items();
    [CompilerGeneratedAttribute]
public virtual void set_Items(IDictionary`2<object, object> value);
    [CompilerGeneratedAttribute]
public virtual IDuplexPipe get_Transport();
    [CompilerGeneratedAttribute]
public virtual void set_Transport(IDuplexPipe value);
    [AsyncStateMachineAttribute("Microsoft.Azure.SignalR.WebSocketConnectionContext/<StartAsync>d__17")]
public Task StartAsync(Uri url, CancellationToken cancellationToken);
    public Task StopAsync();
}
internal class Microsoft.Azure.SignalR.WebSocketConnectionOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CookieContainer <Cookies>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CloseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseDefaultCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ClientWebSocketOptions> <WebSocketConfiguration>k__BackingField;
    public IDictionary`2<string, string> Headers { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public CookieContainer Cookies { get; public set; }
    public TimeSpan CloseTimeout { get; public set; }
    public ICredentials Credentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Nullable`1<bool> UseDefaultCredentials { get; public set; }
    public Action`1<ClientWebSocketOptions> WebSocketConfiguration { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
public CookieContainer get_Cookies();
    [CompilerGeneratedAttribute]
public void set_Cookies(CookieContainer value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CloseTimeout();
    [CompilerGeneratedAttribute]
public void set_CloseTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(ICredentials value);
    [CompilerGeneratedAttribute]
public IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
public void set_Proxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseDefaultCredentials();
    [CompilerGeneratedAttribute]
public void set_UseDefaultCredentials(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Action`1<ClientWebSocketOptions> get_WebSocketConfiguration();
    [CompilerGeneratedAttribute]
public void set_WebSocketConfiguration(Action`1<ClientWebSocketOptions> value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.IO.Pipelines.DuplexPipe : object {
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public DuplexPipe(PipeReader reader, PipeWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    public static DuplexPipePair CreateConnectionPair(PipeOptions inputOptions, PipeOptions outputOptions);
}
[ExtensionAttribute]
internal static class System.Net.WebSockets.WebSocketExtensions : object {
    [ExtensionAttribute]
public static ValueTask SendAsync(WebSocket webSocket, ReadOnlySequence`1<byte> buffer, WebSocketMessageType webSocketMessageType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketExtensions/<SendMultiSegmentAsync>d__1")]
private static ValueTask SendMultiSegmentAsync(WebSocket webSocket, ReadOnlySequence`1<byte> buffer, WebSocketMessageType webSocketMessageType, CancellationToken cancellationToken);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[IsReadOnlyAttribute]
internal class System.Threading.Tasks.ForceAsyncAwaiter : ValueType {
    private Task _task;
    public bool IsCompleted { get; }
    internal ForceAsyncAwaiter(Task task);
    public ForceAsyncAwaiter GetAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action action);
    public sealed virtual void UnsafeOnCompleted(Action action);
}
[IsReadOnlyAttribute]
internal class System.Threading.Tasks.ForceAsyncAwaiter`1 : ValueType {
    private Task`1<T> _task;
    public bool IsCompleted { get; }
    internal ForceAsyncAwaiter`1(Task`1<T> task);
    public ForceAsyncAwaiter`1<T> GetAwaiter();
    public bool get_IsCompleted();
    public T GetResult();
    public sealed virtual void OnCompleted(Action action);
    public sealed virtual void UnsafeOnCompleted(Action action);
}
[ExtensionAttribute]
internal static class System.Threading.Tasks.ForceAsyncTaskExtensions : object {
    [ExtensionAttribute]
public static ForceAsyncAwaiter ForceAsync(Task task);
    [ExtensionAttribute]
public static ForceAsyncAwaiter`1<T> ForceAsync(Task`1<T> task);
}
