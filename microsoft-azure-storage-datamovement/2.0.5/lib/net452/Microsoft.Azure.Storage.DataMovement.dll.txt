internal class Microsoft.Azure.Storage.DataMovement.Attributes : object {
    [CompilerGeneratedAttribute]
private string <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentDisposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentMD5>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CloudFileNtfsAttributes> <CloudFileNtfsAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastWriteTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PortableSDDL>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverWriteAll>k__BackingField;
    public string CacheControl { get; public set; }
    public string ContentDisposition { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentLanguage { get; public set; }
    public string ContentMD5 { get; public set; }
    public string ContentType { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public Nullable`1<CloudFileNtfsAttributes> CloudFileNtfsAttributes { get; public set; }
    public Nullable`1<DateTimeOffset> CreationTime { get; public set; }
    public Nullable`1<DateTimeOffset> LastWriteTime { get; public set; }
    public string PortableSDDL { get; public set; }
    public bool OverWriteAll { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CacheControl();
    [CompilerGeneratedAttribute]
public void set_CacheControl(string value);
    [CompilerGeneratedAttribute]
public string get_ContentDisposition();
    [CompilerGeneratedAttribute]
public void set_ContentDisposition(string value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentLanguage();
    [CompilerGeneratedAttribute]
public void set_ContentLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_ContentMD5();
    [CompilerGeneratedAttribute]
public void set_ContentMD5(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CloudFileNtfsAttributes> get_CloudFileNtfsAttributes();
    [CompilerGeneratedAttribute]
public void set_CloudFileNtfsAttributes(Nullable`1<CloudFileNtfsAttributes> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreationTime();
    [CompilerGeneratedAttribute]
public void set_CreationTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastWriteTime();
    [CompilerGeneratedAttribute]
public void set_LastWriteTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_PortableSDDL();
    [CompilerGeneratedAttribute]
public void set_PortableSDDL(string value);
    [CompilerGeneratedAttribute]
public bool get_OverWriteAll();
    [CompilerGeneratedAttribute]
public void set_OverWriteAll(bool value);
}
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableBlobRequestOptions")]
internal class Microsoft.Azure.Storage.DataMovement.AzureBlobDirectoryLocation : TransferLocation {
    private static string BlobDirName;
    private static string RequestOptionsName;
    private SerializableCloudBlobDirectory blobDirectorySerializer;
    private SerializableRequestOptions requestOptions;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public CloudBlobDirectory BlobDirectory { get; }
    internal BlobRequestOptions BlobRequestOptions { get; internal set; }
    public AzureBlobDirectoryLocation(CloudBlobDirectory blobDir);
    private AzureBlobDirectoryLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    public CloudBlobDirectory get_BlobDirectory();
    internal BlobRequestOptions get_BlobRequestOptions();
    internal void set_BlobRequestOptions(BlobRequestOptions value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Validate();
    public void UpdateCredentials(StorageCredentials credentials);
    public virtual string ToString();
}
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableBlobRequestOptions")]
internal class Microsoft.Azure.Storage.DataMovement.AzureBlobLocation : TransferLocation {
    private static string BlobName;
    private static string AccessConditionName;
    private static string CheckedAccessConditionName;
    private static string RequestOptionsName;
    private static string ETagName;
    private static string BlockIDPrefixName;
    private SerializableCloudBlob blobSerializer;
    private SerializableAccessCondition accessCondition;
    private SerializableRequestOptions requestOptions;
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckedAccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlockIdPrefix>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public AccessCondition AccessCondition { get; public set; }
    public CloudBlob Blob { get; private set; }
    internal string ETag { get; internal set; }
    internal bool CheckedAccessCondition { get; internal set; }
    internal BlobRequestOptions BlobRequestOptions { get; internal set; }
    internal string BlockIdPrefix { get; internal set; }
    public AzureBlobLocation(CloudBlob blob);
    private AzureBlobLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    public AccessCondition get_AccessCondition();
    public void set_AccessCondition(AccessCondition value);
    public CloudBlob get_Blob();
    private void set_Blob(CloudBlob value);
    [CompilerGeneratedAttribute]
internal string get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(string value);
    [CompilerGeneratedAttribute]
internal bool get_CheckedAccessCondition();
    [CompilerGeneratedAttribute]
internal void set_CheckedAccessCondition(bool value);
    internal BlobRequestOptions get_BlobRequestOptions();
    internal void set_BlobRequestOptions(BlobRequestOptions value);
    [CompilerGeneratedAttribute]
internal string get_BlockIdPrefix();
    [CompilerGeneratedAttribute]
internal void set_BlockIdPrefix(string value);
    public virtual void Validate();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void UpdateCredentials(StorageCredentials credentials);
    public virtual string ToString();
}
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableFileRequestOptions")]
internal class Microsoft.Azure.Storage.DataMovement.AzureFileDirectoryLocation : TransferLocation {
    private static string FileDirName;
    private static string RequestOptionsName;
    private SerializableCloudFileDirectory fileDirectorySerializer;
    private SerializableRequestOptions requestOptions;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public CloudFileDirectory FileDirectory { get; }
    internal FileRequestOptions FileRequestOptions { get; internal set; }
    public AzureFileDirectoryLocation(CloudFileDirectory fileDir);
    private AzureFileDirectoryLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    public CloudFileDirectory get_FileDirectory();
    internal FileRequestOptions get_FileRequestOptions();
    internal void set_FileRequestOptions(FileRequestOptions value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Validate();
    public void UpdateCredentials(StorageCredentials credentials);
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.AzureFileDirectorySDDLCache : object {
    private Dictionary`2<string, string> sddlPermissionKey;
    private Queue`1<string> dictionaryKeys;
    private ReaderWriterLockSlim cacheLock;
    private int itemCount;
    private static int MaximumItemCount;
    public bool TryGetValue(string key, String& value);
    public bool TryAddValue(string key, string value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableFileRequestOptions")]
internal class Microsoft.Azure.Storage.DataMovement.AzureFileLocation : TransferLocation {
    private static string AzureFileName;
    private static string AccessConditionName;
    private static string CheckedAccessConditionName;
    private static string RequestOptionsName;
    private static string ETagName;
    private SerializableAccessCondition accessCondition;
    private SerializableRequestOptions requestOptions;
    private SerializableCloudFile fileSerializer;
    [CompilerGeneratedAttribute]
private TransferLocationType <TransferLocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ETag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckedAccessCondition>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public AccessCondition AccessCondition { get; public set; }
    public TransferLocationType TransferLocationType { get; private set; }
    public CloudFile AzureFile { get; private set; }
    internal string ETag { get; internal set; }
    internal bool CheckedAccessCondition { get; internal set; }
    internal FileRequestOptions FileRequestOptions { get; internal set; }
    public AzureFileLocation(CloudFile azureFile);
    private AzureFileLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    public AccessCondition get_AccessCondition();
    public void set_AccessCondition(AccessCondition value);
    [CompilerGeneratedAttribute]
public TransferLocationType get_TransferLocationType();
    [CompilerGeneratedAttribute]
private void set_TransferLocationType(TransferLocationType value);
    public CloudFile get_AzureFile();
    private void set_AzureFile(CloudFile value);
    [CompilerGeneratedAttribute]
internal string get_ETag();
    [CompilerGeneratedAttribute]
internal void set_ETag(string value);
    [CompilerGeneratedAttribute]
internal bool get_CheckedAccessCondition();
    [CompilerGeneratedAttribute]
internal void set_CheckedAccessCondition(bool value);
    internal FileRequestOptions get_FileRequestOptions();
    internal void set_FileRequestOptions(FileRequestOptions value);
    public virtual void Validate();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void UpdateCredentials(StorageCredentials credentials);
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.ChunkedMemoryStream : Stream {
    private Byte[][] buffer;
    private int origin;
    private int length;
    private int position;
    private int currentChunk;
    private int currentChunkOffset;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ChunkedMemoryStream(Byte[][] buffer, int index, int count);
    public virtual void Flush();
    [SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
public virtual long Seek(long offset, SeekOrigin seekOrigin);
    public virtual void SetLength(long value);
    [SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
public virtual int Read(Byte[] toBuffer, int offset, int count);
    [SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
public virtual void Write(Byte[] fromBuffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private void SetPosition(long value);
}
public static class Microsoft.Azure.Storage.DataMovement.Constants : object {
    public static int MaxBlockSize;
    public static int DefaultBlockBlobBlockSize;
    public static int DefaultTransferChunkSize;
    public static int DefaultMemoryChunkSize;
    public static string DirectoryBlobMetadataKey;
    internal static int MaxSDDLLengthInProperties;
    internal static int MaxFilePathLength;
    internal static int MaxRelativePathLength;
    internal static long CacheSizeMultiplierInByte;
    internal static string DefaultContainerName;
    internal static int MinBlockSize;
    internal static long MaxAppendBlobFileSize;
    internal static long MaxBlockBlobFileSize;
    internal static int MaxCountInTransferWindow;
    internal static long PageRangesSpanSize;
    internal static long FileRangeSpanSize;
    internal static double MemoryCacheMultiplier;
    internal static long MemoryCacheMaximum;
    internal static int MemoryManagerCellsMaximum;
    internal static int CopySASLifeTimeInMinutes;
    internal static long CopyStatusRefreshMinWaitTimeInMilliseconds;
    internal static long CopyStatusRefreshMaxWaitTimeInMilliseconds;
    internal static long CopyStatusRefreshWaitTimeMaxRequestCount;
    internal static long CopyApproachingFinishThresholdInBytes;
    internal static int ListSegmentLengthMultiplier;
    internal static string BlobTypeMismatch;
    internal static string FileSizeOutOfRangeErrorCode;
    internal static long MaxSinglePutBlobSize;
    internal static string UserAgentProductName;
    internal static string UserAgent;
    internal static string FormatVersion;
    private static Constants();
    private static string GetUserAgent();
    private static string GetFormatVersion();
    private static long GetMemoryCacheMaximum();
}
public class Microsoft.Azure.Storage.DataMovement.CopyDirectoryOptions : DirectoryOptions {
    private char delimiter;
    [CompilerGeneratedAttribute]
private bool <PreserveSMBAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveSMBPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSnapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBPermissions { get; public set; }
    public BlobType BlobType { get; public set; }
    public bool IncludeSnapshots { get; public set; }
    public char Delimiter { get; public set; }
    public string EncryptionScope { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PreserveSMBAttributes();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveSMBPermissions();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBPermissions(bool value);
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
public void set_BlobType(BlobType value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSnapshots();
    [CompilerGeneratedAttribute]
public void set_IncludeSnapshots(bool value);
    public char get_Delimiter();
    public void set_Delimiter(char value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
}
public enum Microsoft.Azure.Storage.DataMovement.CopyMethod : Enum {
    public int value__;
    public static CopyMethod SyncCopy;
    public static CopyMethod ServiceSideAsyncCopy;
    public static CopyMethod ServiceSideSyncCopy;
}
public class Microsoft.Azure.Storage.DataMovement.CopyOptions : object {
    [CompilerGeneratedAttribute]
private bool <PreserveSMBAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveSMBPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessCondition <SourceAccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessCondition <DestinationAccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBPermissions { get; public set; }
    public AccessCondition SourceAccessCondition { get; public set; }
    public AccessCondition DestinationAccessCondition { get; public set; }
    public string EncryptionScope { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PreserveSMBAttributes();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveSMBPermissions();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBPermissions(bool value);
    [CompilerGeneratedAttribute]
public AccessCondition get_SourceAccessCondition();
    [CompilerGeneratedAttribute]
public void set_SourceAccessCondition(AccessCondition value);
    [CompilerGeneratedAttribute]
public AccessCondition get_DestinationAccessCondition();
    [CompilerGeneratedAttribute]
public void set_DestinationAccessCondition(AccessCondition value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
}
internal class Microsoft.Azure.Storage.DataMovement.DirectoryListingScheduler : object {
    private SemaphoreSlim semaphore;
    public DirectoryListingScheduler(int maxParallelListingThreads);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public Task Schedule(SubDirectoryTransfer subDirectoryTransfer, CancellationToken cancellationToken, Action persistDirTransfer, int timeOut);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <Schedule>b__2_0(Task sourceTask);
}
internal class Microsoft.Azure.Storage.DataMovement.DirectoryLocation : TransferLocation {
    private static string DirPathName;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public string DirectoryPath { get; private set; }
    public DirectoryLocation(string dirPath);
    private DirectoryLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
private void set_DirectoryPath(string value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Validate();
    public virtual string ToString();
}
public class Microsoft.Azure.Storage.DataMovement.DirectoryOptions : object {
    [CompilerGeneratedAttribute]
private string <SearchPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    public string SearchPattern { get; public set; }
    public bool Recursive { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SearchPattern();
    [CompilerGeneratedAttribute]
public void set_SearchPattern(string value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.DirectoryTransfer : Transfer {
    private DirectoryTransferContext dirTransferContext;
    private static string HasDelimiterName;
    private static string DelimiterName;
    private INameResolver nameResolver;
    private List`1<CloudFileDirectory> lastAzureFileDirectory;
    private Nullable`1<char> delimiter;
    [CompilerGeneratedAttribute]
private ITransferEnumerator <SourceEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransferConcurrency>k__BackingField;
    protected INameResolver NameResolver { get; }
    public Nullable`1<char> Delimiter { get; public set; }
    public bool IsForceOverwrite { get; }
    public TransferContext Context { get; public set; }
    public DirectoryTransferContext DirectoryContext { get; }
    public ITransferEnumerator SourceEnumerator { get; public set; }
    public int MaxTransferConcurrency { get; public set; }
    public DirectoryTransfer(TransferLocation source, TransferLocation dest, TransferMethod transferMethod);
    protected DirectoryTransfer(SerializationInfo info, StreamingContext context);
    protected DirectoryTransfer(DirectoryTransfer other);
    protected INameResolver get_NameResolver();
    public Nullable`1<char> get_Delimiter();
    public void set_Delimiter(Nullable`1<char> value);
    public bool get_IsForceOverwrite();
    public virtual TransferContext get_Context();
    public virtual void set_Context(TransferContext value);
    public DirectoryTransferContext get_DirectoryContext();
    [CompilerGeneratedAttribute]
public ITransferEnumerator get_SourceEnumerator();
    [CompilerGeneratedAttribute]
public void set_SourceEnumerator(ITransferEnumerator value);
    [CompilerGeneratedAttribute]
public virtual int get_MaxTransferConcurrency();
    [CompilerGeneratedAttribute]
public virtual void set_MaxTransferConcurrency(int value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.DirectoryTransfer/<ExecuteAsync>d__30")]
public virtual Task ExecuteAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    public abstract virtual Task ExecuteInternalAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    protected static TransferLocation GetSourceTransferLocation(TransferLocation dirLocation, TransferEntry entry);
    protected TransferLocation GetDestTransferLocationForEmptyDir(TransferLocation dirLocation, TransferEntry entry);
    protected TransferLocation GetDestinationTransferLocation(TransferLocation dirLocation, TransferEntry entry);
    public void CreateParentDirectory(SingleObjectTransfer transfer);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
internal SingleObjectTransfer CreateTransfer(TransferEntry entry);
    private bool IsDummyCopy(TransferEntry entry);
    private static bool IsDirectoryBlob(CloudBlob blob);
    protected void UpdateTransfer(Transfer transfer);
    private static void UpdateCredentials(TransferLocation dirLocation, TransferLocation subLocation);
    private static INameResolver GetNameResolver(TransferLocation sourceLocation, TransferLocation destLocation, Nullable`1<char> delimiter);
    private void CreateParentDirectoryIfNotExists(CloudFile file);
    public void CreateDirectoryIfNotExist(CloudFileDirectory directory);
    private void CreateDirectoryRecursive(CloudFileDirectory directory, Int32& index);
    private static string AppendSlash(string input);
}
public class Microsoft.Azure.Storage.DataMovement.DirectoryTransferContext : TransferContext {
    [CompilerGeneratedAttribute]
private ShouldTransferCallbackAsync <ShouldTransferCallbackAsync>k__BackingField;
    public ShouldTransferCallbackAsync ShouldTransferCallbackAsync { get; public set; }
    public DirectoryTransferContext(TransferCheckpoint checkpoint);
    public DirectoryTransferContext(Stream journalStream);
    [CompilerGeneratedAttribute]
public ShouldTransferCallbackAsync get_ShouldTransferCallbackAsync();
    [CompilerGeneratedAttribute]
public void set_ShouldTransferCallbackAsync(ShouldTransferCallbackAsync value);
}
public class Microsoft.Azure.Storage.DataMovement.DownloadDirectoryOptions : DirectoryOptions {
    private bool preserveSMBAttributes;
    private PreserveSMBPermissions preserveSMBPermissions;
    private char delimiter;
    [CompilerGeneratedAttribute]
private bool <DisableContentMD5Validation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSnapshots>k__BackingField;
    public bool DisableContentMD5Validation { get; public set; }
    public bool IncludeSnapshots { get; public set; }
    public char Delimiter { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public PreserveSMBPermissions PreserveSMBPermissions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableContentMD5Validation();
    [CompilerGeneratedAttribute]
public void set_DisableContentMD5Validation(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSnapshots();
    [CompilerGeneratedAttribute]
public void set_IncludeSnapshots(bool value);
    public char get_Delimiter();
    public void set_Delimiter(char value);
    public bool get_PreserveSMBAttributes();
    public void set_PreserveSMBAttributes(bool value);
    public PreserveSMBPermissions get_PreserveSMBPermissions();
    public void set_PreserveSMBPermissions(PreserveSMBPermissions value);
}
public class Microsoft.Azure.Storage.DataMovement.DownloadOptions : object {
    private bool preserveSMBAttributes;
    private PreserveSMBPermissions preserveSMBPermissions;
    [CompilerGeneratedAttribute]
private AccessCondition <SourceAccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableContentMD5Validation>k__BackingField;
    public AccessCondition SourceAccessCondition { get; public set; }
    public bool DisableContentMD5Validation { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public PreserveSMBPermissions PreserveSMBPermissions { get; public set; }
    [CompilerGeneratedAttribute]
public AccessCondition get_SourceAccessCondition();
    [CompilerGeneratedAttribute]
public void set_SourceAccessCondition(AccessCondition value);
    [CompilerGeneratedAttribute]
public bool get_DisableContentMD5Validation();
    [CompilerGeneratedAttribute]
public void set_DisableContentMD5Validation(bool value);
    public bool get_PreserveSMBAttributes();
    public void set_PreserveSMBAttributes(bool value);
    public PreserveSMBPermissions get_PreserveSMBPermissions();
    public void set_PreserveSMBPermissions(PreserveSMBPermissions value);
}
internal class Microsoft.Azure.Storage.DataMovement.Extensions.StorageCopyState : object {
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageCopyStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytesCopied>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TotalBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    public string CopyId { get; private set; }
    public StorageCopyStatus Status { get; private set; }
    public Uri Source { get; private set; }
    public Nullable`1<long> BytesCopied { get; public set; }
    public Nullable`1<long> TotalBytes { get; public set; }
    public string StatusDescription { get; private set; }
    public StorageCopyState(CopyState blobCopyState);
    public StorageCopyState(CopyState fileCopyState);
    private void SetStatus(CopyStatus blobCopyStatus);
    private void SetStatus(CopyStatus fileCopyStatus);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
private void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public StorageCopyStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(StorageCopyStatus value);
    [CompilerGeneratedAttribute]
public Uri get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytesCopied();
    [CompilerGeneratedAttribute]
public void set_BytesCopied(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TotalBytes();
    [CompilerGeneratedAttribute]
public void set_TotalBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
private void set_StatusDescription(string value);
}
internal enum Microsoft.Azure.Storage.DataMovement.Extensions.StorageCopyStatus : Enum {
    public int value__;
    public static StorageCopyStatus Invalid;
    public static StorageCopyStatus Pending;
    public static StorageCopyStatus Success;
    public static StorageCopyStatus Aborted;
    public static StorageCopyStatus Failed;
}
internal class Microsoft.Azure.Storage.DataMovement.FileLocation : TransferLocation {
    private static string FilePathName;
    private static string FilePathType;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public string RelativePath { get; private set; }
    public string FilePath { get; private set; }
    public FileLocation(string filePath);
    public FileLocation(string filePath, string relativePath);
    private FileLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
private void set_RelativePath(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SuppressMessageAttribute("Microsoft.Performance", "CA1804:RemoveUnusedLocals")]
public virtual void Validate();
    public virtual string ToString();
}
internal static class Microsoft.Azure.Storage.DataMovement.FileSecurityOperations : object {
    private static long OwnerPrivilegeJobCount;
    private static long SACLPrivilegeJobCount;
    private static object OwnerPrivilegeLock;
    private static object SACLPrivilegeLock;
    private static bool OwnerPrivilegeEnabledOriginal;
    private static bool SACLPrivilegeEnabledOriginal;
    private static bool OwnerPrivilegeEnabled;
    private static bool SACLPrivilegeEnabled;
    private static FileSecurityOperations();
    public static void EnableRequiredPrivileges(PreserveSMBPermissions preserveSMBPermissions, bool setLocalFilePermission);
    public static void DisablePrivileges(PreserveSMBPermissions preserveSMBPermissions, bool setLocalFilePermission);
    [SuppressMessageAttribute("Microsoft.Interoperability", "CA1404:CallGetLastErrorImmediatelyAfterPInvoke")]
private static bool SetPrivilege(string securityPrivilege, bool bEnablePrivilege);
    public static void SetFileSecurity(string filePath, string portableSDDL, PreserveSMBPermissions preserveSMBPermissions);
    public static string GetFilePortableSDDL(string filePath, PreserveSMBPermissions preserveSMBPermissions);
    private static SECURITY_INFORMATION ToSecurityInfo(PreserveSMBPermissions preserveSMBPermissions);
    private static string GetUserName();
    private static string GetPortableSDDL(string sddl, string domainSid);
    private static string GetFileSDDL(string filePath, SECURITY_INFORMATION securityInfo);
    private static string GetDomainSid(string accountName);
}
internal class Microsoft.Azure.Storage.DataMovement.FlatDirectoryTransfer : DirectoryTransfer {
    private static string ListContinuationTokenName;
    private static string SubTransfersName;
    protected SerializableListContinuationToken enumerateContinuationToken;
    private object lockEnumerateContinuationToken;
    private TimeSpan EnumerationWaitTimeOut;
    private AutoResetEvent enumerationResetEvent;
    private Exception enumerateException;
    private long outstandingTasks;
    private ReaderWriterLockSlim progressUpdateLock;
    private TaskQueue`1<Tuple`2<SingleObjectTransfer, TransferEntry>> shouldTransferQueue;
    private TransferCollection`1<SingleObjectTransfer> subTransfers;
    private TaskCompletionSource`1<object> allTransfersCompleteSource;
    public FlatDirectoryTransfer(TransferLocation source, TransferLocation dest, TransferMethod transferMethod);
    protected FlatDirectoryTransfer(SerializationInfo info, StreamingContext context);
    private FlatDirectoryTransfer(FlatDirectoryTransfer other);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Transfer Copy();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.FlatDirectoryTransfer/<ExecuteInternalAsync>d__17")]
public virtual Task ExecuteInternalAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void ListNewTransfers(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.FlatDirectoryTransfer/<AllTransfers>d__20")]
private IEnumerable`1<SingleObjectTransfer> AllTransfers(CancellationToken cancellationToken);
    private void EnumerateAndTransfer(TransferScheduler scheduler, CancellationToken cancellationToken);
    private void CheckAndPauseEnumeration(CancellationToken cancellationToken);
    private void ResetExecutionStatus();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.FlatDirectoryTransfer/<DoTransfer>d__24")]
private void DoTransfer(Transfer transfer, TransferScheduler scheduler, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.GlobalMemoryStatusNativeMethods : object {
    [CompilerGeneratedAttribute]
private ulong <AvailablePhysicalMemory>k__BackingField;
    public ulong AvailablePhysicalMemory { get; private set; }
    [CompilerGeneratedAttribute]
public ulong get_AvailablePhysicalMemory();
    [CompilerGeneratedAttribute]
private void set_AvailablePhysicalMemory(ulong value);
}
internal class Microsoft.Azure.Storage.DataMovement.HierarchyDirectoryTransfer : DirectoryTransfer {
    private static string OngoingSubDirectoriesCountName;
    private static string OngoingSubDirectoryName;
    private static string SubDirectoriesCountName;
    private static string SubDirectoryName;
    private static string EnumerationstartedName;
    private static string SubTransfersName;
    private long outstandingTasks;
    private TaskCompletionSource`1<object> transfersCompleteSource;
    private TaskCompletionSource`1<object> subDirTransfersCompleteSource;
    private ConcurrentQueue`1<string> subDirectories;
    private ConcurrentDictionary`2<SubDirectoryTransfer, object> ongoingSubDirTransfers;
    private SemaphoreSlim maxConcurrencyControl;
    private int maxConcurrency;
    private object continuationTokenLock;
    private Exception enumerateException;
    private CancellationTokenSource cancellationTokenSource;
    private ReaderWriterLockSlim progressUpdateLock;
    private TransferCollection`1<SingleObjectTransfer> subTransfers;
    private TransferScheduler currentScheduler;
    private CancellationToken currentCancellationToken;
    private ManualResetEventSlim newAddSubDirResetEventSlim;
    private DirectoryListingScheduler directoryListingScheduler;
    private AzureFileDirectorySDDLCache azureFileDirectorySDDLCache;
    private int enumerationStarted;
    [CompilerGeneratedAttribute]
private string <SearchPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FollowSymblink>k__BackingField;
    unknown int MaxTransferConcurrency {public set; }
    public AzureFileDirectorySDDLCache SDDLCache { get; }
    public string SearchPattern { get; public set; }
    public bool Recursive { get; public set; }
    public bool FollowSymblink { get; public set; }
    public HierarchyDirectoryTransfer(TransferLocation source, TransferLocation dest, TransferMethod transferMethod);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected HierarchyDirectoryTransfer(HierarchyDirectoryTransfer other);
    protected HierarchyDirectoryTransfer(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void set_MaxTransferConcurrency(int value);
    public AzureFileDirectorySDDLCache get_SDDLCache();
    [CompilerGeneratedAttribute]
public string get_SearchPattern();
    [CompilerGeneratedAttribute]
public void set_SearchPattern(string value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public bool get_FollowSymblink();
    [CompilerGeneratedAttribute]
public void set_FollowSymblink(bool value);
    public virtual Transfer Copy();
    protected virtual void Dispose(bool disposing);
    private void ResetExecutionStatus();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.HierarchyDirectoryTransfer/<ExecuteInternalAsync>d__47")]
public virtual Task ExecuteInternalAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    internal void AddSubDir(string relativePath, Func`1<SerializableListContinuationToken> updateContinuationToken);
    internal void AddSingleObjectTransfer(SingleObjectTransfer singleObjectTransfer, Func`1<SerializableListContinuationToken> updateContinuationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.HierarchyDirectoryTransfer/<TransferFile>d__50")]
internal void TransferFile(SingleObjectTransfer transferItem, TransferScheduler scheduler, CancellationToken cancellationToken);
    private bool Resume(TransferScheduler scheduler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.HierarchyDirectoryTransfer/<DoEnumerationAndTransferAsync>d__52")]
private Task DoEnumerationAndTransferAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    private void SignalSubDirTaskDecrement();
    private bool ScheduleSubDirectoryTransfer(SubDirectoryTransfer subDirectoryTransfer, CancellationToken cancellationToken, Action persistDirTransfer, int timeOut);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.HierarchyDirectoryTransfer/<WaitOnSubDirectoryListTask>d__55")]
private void WaitOnSubDirectoryListTask(Task directoryListTask, SubDirectoryTransfer subDirTransfer);
    internal void GetSubDirLocation(string relativePath, TransferLocation& sourceLocation, TransferLocation& destLocation);
    protected TransferEntry CreateDirectoryTransferEntry(string relativePath);
    protected static TransferLocation GetSourceDirectoryTransferLocation(TransferLocation dirLocation, string relativePath);
    protected TransferLocation GetDestinationSubDirTransferLocation(TransferLocation dirLocation, TransferEntry entry);
    [CompilerGeneratedAttribute]
private void <ExecuteInternalAsync>b__47_0();
}
internal static class Microsoft.Azure.Storage.DataMovement.Interop.CrossPlatformHelpers : object {
    public static bool IsWindows { get; }
    public static bool IsOSX { get; }
    public static bool IsLinux { get; }
    public static bool get_IsWindows();
    public static bool get_IsOSX();
    public static bool get_IsLinux();
    public static ulong GetAvailableMemory();
}
internal static class Microsoft.Azure.Storage.DataMovement.Interop.NativeMethods : object {
    public static int ERROR_SUCCESS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_DIRECTORY_NOT_FOUND;
    public static int ERROR_NO_MORE_FILES;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_HANDLE_EOF;
    public static UInt32 FILE_BEGIN;
    public static UInt32 INVALID_SET_FILE_POINTER;
    public static UInt32 GENERIC_READ;
    public static UInt32 GENERIC_WRITE;
    public static UInt32 GENERIC_READ_WRITE;
    public static UInt32 FILE_FLAG_BACKUP_SEMANTICS;
    public static int SE_PRIVILEGE_ENABLED;
    public static int SE_PRIVILEGE_DISABLED;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_NOT_ALL_ASSIGNED;
    public static int ERROR_INVALID_OWNER;
    public static int ERROR_PRIVILEGE_NOT_HELD;
    public static int ERROR_INSUFFICIENT_BUFFER;
    public static int SDDL_REVISION_1;
    public static string SACLPrivilegeName;
    public static string OwnerPrivilegeName;
    private static string MemInfoPath;
    private static int HOST_VM_INFO;
    private static string CORE_FILE_APIS;
    private static string CORE_SYSINFO_APIS;
    public static SafeFileHandle GetFileHandleW(string filename, UInt32 access, FileShare share, IntPtr securityAttributes, FileMode creationDisposition, UInt32 flagsAndAttributes, IntPtr templateFile);
    public static bool CreateDirectoryW(string lpPathName, IntPtr lpSecurityAttributes);
    public static UInt32 GetFullPathNameW(string lpFileName, UInt32 nBufferLength, StringBuilder lpBuffer, StringBuilder lpFilePart);
    public static SafeFindHandle FindFirstFileW(string lpFileName, WIN32_FIND_DATA& lpFindFileData);
    public static bool FindNextFileW(SafeFindHandle hFindFile, WIN32_FIND_DATA& lpFindFileData);
    public static bool PathFileExistsW(string pszPath);
    public static UInt32 GetFileAttributesW(string lpFileName);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api")]
public static bool SetFileAttributesW(string lpFileName, UInt32 dwFileAttributes);
    public static bool SetFileTime(SafeFileHandle hFile, FILETIME& lpCreationTime, FILETIME& lpLastAccessTime, FILETIME& lpLastWriteTime);
    public static void ThrowExceptionForLastWin32ErrorIfExists();
    public static void ThrowExceptionForLastWin32ErrorIfExists(Int32[] expectErrorCodes);
    public static void ThrowExceptionForLastWin32ErrorIfExists(int errorCode, Int32[] expectErrorCodes);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api")]
public static bool GetUserName(StringBuilder sb, Int32& length);
    public static bool LookupAccountName(string lpSystemName, string lpAccountName, Byte[] Sid, UInt32& cbSid, StringBuilder ReferencedDomainName, UInt32& cchReferencedDomainName, SID_NAME_USE& peUse);
    public static bool GetWindowsAccountDomainSid(Byte[] sid, Byte[] domainSid, UInt32& length);
    public static UInt32 GetNamedSecurityInfoW(string pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, IntPtr& pSidOwner, IntPtr& pSidGroup, IntPtr& pDacl, IntPtr& pSacl, IntPtr& pSecurityDescriptor);
    public static void SetFileSecurity(string path, int type_of_sd, IntPtr sd);
    public static IntPtr LocalFree(IntPtr handle);
    public static bool ConvertSidToStringSid(Byte[] sid, IntPtr& ptrSid);
    public static bool ConvertStringSecurityDescriptorToSecurityDescriptor(string StringSecurityDescriptor, UInt32 StringSDRevision, IntPtr& SecurityDescriptor, UIntPtr& SecurityDescriptorSize);
    public static bool ConvertSecurityDescriptorToStringSecurityDescriptor(IntPtr SecurityDescriptor, UInt32 StringSDRevision, SECURITY_INFORMATION SecurityInformation, IntPtr& StringSecurityDescriptor, UIntPtr& StringSecurityDescriptorLen);
    public static bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGES& NewState, UInt32 BufferLengthInBytes, TOKEN_PRIVILEGES& PreviousState, UInt32& ReturnLengthInBytes);
    public static bool LookupPrivilegeValue(string lpSystemName, string lpName, LUID& lpLuid);
    internal static Dictionary`2<string, ulong> GetLinuxMemoryInfo();
    internal static int sysctlbyname(string name, Int32& oldp, Int32& oldlenp, IntPtr newp, int newlen);
    private static IntPtr mach_host_self();
    private static IntPtr host_statistics(IntPtr host, int hostFlavor, vm_statistics& vmStat, Int32& count);
    internal static vm_statistics GetOSXHostStatistics();
    internal static bool GlobalMemoryStatusEx(MEMORYSTATUSEX lpBuffer);
    public static bool FindClose(SafeHandle findFileHandle);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.JournalItem : object {
    [CompilerGeneratedAttribute]
private StreamJournal <Journal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StreamJournalOffset>k__BackingField;
    public StreamJournal Journal { get; public set; }
    public long StreamJournalOffset { get; public set; }
    [CompilerGeneratedAttribute]
public StreamJournal get_Journal();
    [CompilerGeneratedAttribute]
public void set_Journal(StreamJournal value);
    [CompilerGeneratedAttribute]
public long get_StreamJournalOffset();
    [CompilerGeneratedAttribute]
public void set_StreamJournalOffset(long value);
}
internal static class Microsoft.Azure.Storage.DataMovement.LongPath : object {
    private static string ExtendedPathPrefix;
    private static string UncPathPrefix;
    private static string UncExtendedPrefixToInsert;
    internal static int DevicePrefixLength;
    internal static bool IsPartiallyQualified(string path);
    internal static bool IsValidDriveChar(char value);
    internal static bool IsDevice(string path);
    internal static bool IsExtended(string path);
    private static bool IsDirectorySeparator(char ch);
    public static string ToUncPath(string path);
    public static string GetFullPath(string path);
    public static string Combine(string path1, string path2);
    public static string GetDirectoryName(string path);
    private static int GetRootLength(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetFileName(string path);
    private static int FindFileNameIndex(string path);
}
internal static class Microsoft.Azure.Storage.DataMovement.LongPathDirectory : object {
    public static bool Exists(string path);
    public static void CreateDirectory(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.LongPathDirectory/<EnumerateFileSystemEntries>d__4")]
public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption, FilesOrDirectory filter);
}
internal static class Microsoft.Azure.Storage.DataMovement.LongPathFile : object {
    public static bool Exists(string path);
    public static FileStream Open(string filePath, FileMode mode, FileAccess access, FileShare share);
    private static SafeFileHandle GetFileHandle(string path, FileMode mode, FileAccess access, FileShare share, bool isDirectory);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileAttributes GetAttributes(string path);
    public static void GetFileProperties(string path, Nullable`1& creationTime, Nullable`1& lastWriteTime, Nullable`1& fileAttributes);
    public static void SetFileTime(string path, DateTimeOffset creationTimeUtc, DateTimeOffset lastWriteTimeUtc, bool isDirectory);
}
internal class Microsoft.Azure.Storage.DataMovement.MD5HashStream : object {
    private Stream stream;
    private SemaphoreSlim semaphore;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) finishedSeparateMd5Calculator;
    private bool succeededSeparateMd5Calculator;
    private MD5Wrapper md5hash;
    private long md5hashOffset;
    private bool canSeek;
    public bool CheckMd5Hash { get; }
    public bool FinishedSeparateMd5Calculator { get; }
    public bool SucceededSeparateMd5Calculator { get; }
    public MD5HashStream(Stream stream, long lastTransferOffset, bool md5hashCheck);
    public bool get_CheckMd5Hash();
    public bool get_FinishedSeparateMd5Calculator();
    public bool get_SucceededSeparateMd5Calculator();
    public void CalculateMd5(MemoryManager memoryManager, Action checkCancellation);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.MD5HashStream/<ReadAsync>d__15")]
public Task`1<int> ReadAsync(long readOffset, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.MD5HashStream/<ReadAsync>d__16")]
public Task`1<int> ReadAsync(long readOffset, Byte[][] buffers, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.MD5HashStream/<WriteAsync>d__17")]
public Task WriteAsync(long writeOffset, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.MD5HashStream/<WriteAsync>d__18")]
public Task WriteAsync(long writeOffset, Byte[][] buffers, int offset, int count, CancellationToken cancellationToken);
    public bool MD5HashTransformBlock(long streamOffset, Byte[] inputBuffer, int inputOffset, int inputCount);
    public bool MD5HashTransformBlock(long streamOffset, Byte[][] inputBuffer, int inputOffset, int inputCount);
    public string MD5HashTransformFinalBlock();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private int Read(long readOffset, Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.MD5HashStream/<WaitOnSemaphoreAsync>d__25")]
private Task WaitOnSemaphoreAsync(CancellationToken cancellationToken);
    private void ReleaseSemaphore();
    private void WaitMD5CalculationToFinish();
}
internal class Microsoft.Azure.Storage.DataMovement.MD5Wrapper : object {
    private MD5 hash;
    internal void UpdateHash(Byte[] input, int offset, int count);
    internal string ComputeHash();
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.Storage.DataMovement.MemoryManager : object {
    private MemoryPool memoryPool;
    private long currentCapacity;
    private int BufferSize;
    private object memoryCapacityLockObject;
    public MemoryManager(long capacity, int bufferSize);
    public Byte[] RequireBuffer();
    public Byte[][] RequireBuffers(int count);
    public void ReleaseBuffer(Byte[] buffer);
    public void ReleaseBuffers(Byte[][] buffer);
    internal void SetMemoryLimitation(long memoryLimitation);
}
internal class Microsoft.Azure.Storage.DataMovement.NativeMD5 : MD5 {
    private static UInt32 ProvRsaFull;
    private static UInt32 CryptVerifyContext;
    private static UInt32 CalgMD5;
    private static UInt32 HashVal;
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources")]
private IntPtr hashHandle;
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources")]
private IntPtr hashProv;
    private bool disposed;
    protected virtual override void Finalize();
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int offset, int dataLen);
    protected virtual Byte[] HashFinal();
    protected virtual void Dispose(bool disposing);
    private static void ValidateReturnCode(bool status);
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
[FlagsAttribute]
public enum Microsoft.Azure.Storage.DataMovement.PreserveSMBPermissions : Enum {
    public int value__;
    public static PreserveSMBPermissions None;
    public static PreserveSMBPermissions Owner;
    public static PreserveSMBPermissions Group;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public static PreserveSMBPermissions DACL;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public static PreserveSMBPermissions SACL;
}
internal class Microsoft.Azure.Storage.DataMovement.ReadDataState : TransferDataState {
    [CompilerGeneratedAttribute]
private Stream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryManager <MemoryManager>k__BackingField;
    public Stream MemoryStream { get; public set; }
    public MemoryManager MemoryManager { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_MemoryStream();
    [CompilerGeneratedAttribute]
public void set_MemoryStream(Stream value);
    [CompilerGeneratedAttribute]
public MemoryManager get_MemoryManager();
    [CompilerGeneratedAttribute]
public void set_MemoryManager(MemoryManager value);
    protected virtual void Dispose(bool disposing);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Azure.Storage.DataMovement.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AppendBlob { get; }
    internal static string AsyncCopyFromFileToAppendBlobNotSupportException { get; }
    internal static string AsyncCopyFromFileToPageBlobNotSupportException { get; }
    internal static string AzureFile { get; }
    internal static string BlobFileSizeInvalidException { get; }
    internal static string BlobFileSizeTooLargeException { get; }
    internal static string BlockBlob { get; }
    internal static string BlockSizeMustBeMultipleOf4MB { get; }
    internal static string BlockSizeOutOfRangeException { get; }
    internal static string CannotDeserializeLocationType { get; }
    internal static string CannotSerializeStreamLocation { get; }
    internal static string CanOnlyCopyToFileOrBlobException { get; }
    internal static string CloudFileSizeTooLargeException { get; }
    internal static string DeadLoop { get; }
    internal static string DeserializationVersionNotMatchException { get; }
    internal static string DestinationBlobTypeNotMatch { get; }
    internal static string DestinationChangedException { get; }
    internal static string DestinationMustBeBaseBlob { get; }
    internal static string DownloadedMd5MismatchException { get; }
    internal static string EnumerateDirectoryException { get; }
    internal static string FailedToAllocateMemoryException { get; }
    internal static string FailedToAsyncCopyObjectException { get; }
    internal static string FailedToCreateDirectoryException { get; }
    internal static string FailedToEnablePrivilegeException { get; }
    internal static string FailedToEnumerateDirectory { get; }
    internal static string FailedToGetBlobTypeException { get; }
    internal static string FailedToGetFileInfoException { get; }
    internal static string FailedToOpenFileException { get; }
    internal static string FailedToRetrieveCopyStateForObjectException { get; }
    internal static string FailedToValidateDestinationException { get; }
    internal static string FilePathTooLong { get; }
    internal static string InvalidInitialEntryStatusForControllerException { get; }
    internal static string LocalToLocalTransferUnsupportedException { get; }
    internal static string MaxListingConcurrencyNotPositiveException { get; }
    internal static string MismatchFoundBetweenLocalAndServerCopyIdsException { get; }
    internal static string NotSupportedBlobType { get; }
    internal static string OnlyOneTransferAllowed { get; }
    internal static string OnlySupportBlobAzureFileSource { get; }
    internal static string OverwriteCallbackCancelTransferException { get; }
    internal static string PageBlob { get; }
    internal static string ParallelCountNotPositiveException { get; }
    internal static string ParameterCannotBeNullException { get; }
    internal static string PathNotFound { get; }
    internal static string PrivilegeRequiredException { get; }
    internal static string ProvideExactlyOneOfThreeParameters { get; }
    internal static string ReadableSizeFormatBytes { get; }
    internal static string ReadableSizeFormatExaBytes { get; }
    internal static string ReadableSizeFormatGigaBytes { get; }
    internal static string ReadableSizeFormatKiloBytes { get; }
    internal static string ReadableSizeFormatMegaBytes { get; }
    internal static string ReadableSizeFormatPetaBytes { get; }
    internal static string ReadableSizeFormatTeraBytes { get; }
    internal static string RelativePathTooLong { get; }
    internal static string RestartableInfoCorruptedException { get; }
    internal static string RestartableLogCorrupted { get; }
    internal static string ResumeStreamTransferNotSupported { get; }
    internal static string SearchPatternInRecursiveModeFromAzureFileNotSupportedException { get; }
    internal static string ServiceSideSyncCopyFromFileNotSupportedException { get; }
    internal static string ServiceSideSyncCopyNotSupportException { get; }
    internal static string ServiceSideSyncCopyToFileNotSupportedException { get; }
    internal static string SmallMemoryCacheSizeLimitationException { get; }
    internal static string SourceAndDestinationBlobTypeDifferent { get; }
    internal static string SourceAndDestinationLocationCannotBeEqualException { get; }
    internal static string SourceBlobDoesNotExistException { get; }
    internal static string SourceBlobTypeNotMatch { get; }
    internal static string SourceChangedException { get; }
    internal static string SourceDoesNotExistException { get; }
    internal static string SourceMustBeFixedSize { get; }
    internal static string SourceNameInvalidInFileSystem { get; }
    internal static string StreamMustSupportReadException { get; }
    internal static string StreamMustSupportSeekException { get; }
    internal static string StreamMustSupportWriteException { get; }
    internal static string StreamNotExpandable { get; }
    internal static string SubTransferFailsException { get; }
    internal static string SyncCopyFromUriToAzureBlobNotSupportedException { get; }
    internal static string SyncCopyFromUriToAzureFileNotSupportedException { get; }
    internal static string TransferAlreadyExists { get; }
    internal static string TransferCancelledException { get; }
    internal static string TransferEntryCopyIdCannotBeNullOrEmptyException { get; }
    internal static string UnableToLoadDLL { get; }
    internal static string UncategorizedException { get; }
    internal static string UnsupportedBlobTypeException { get; }
    internal static string UnsupportedDummyTransferException { get; }
    internal static string UnsupportedTransferLocationException { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AppendBlob();
    internal static string get_AsyncCopyFromFileToAppendBlobNotSupportException();
    internal static string get_AsyncCopyFromFileToPageBlobNotSupportException();
    internal static string get_AzureFile();
    internal static string get_BlobFileSizeInvalidException();
    internal static string get_BlobFileSizeTooLargeException();
    internal static string get_BlockBlob();
    internal static string get_BlockSizeMustBeMultipleOf4MB();
    internal static string get_BlockSizeOutOfRangeException();
    internal static string get_CannotDeserializeLocationType();
    internal static string get_CannotSerializeStreamLocation();
    internal static string get_CanOnlyCopyToFileOrBlobException();
    internal static string get_CloudFileSizeTooLargeException();
    internal static string get_DeadLoop();
    internal static string get_DeserializationVersionNotMatchException();
    internal static string get_DestinationBlobTypeNotMatch();
    internal static string get_DestinationChangedException();
    internal static string get_DestinationMustBeBaseBlob();
    internal static string get_DownloadedMd5MismatchException();
    internal static string get_EnumerateDirectoryException();
    internal static string get_FailedToAllocateMemoryException();
    internal static string get_FailedToAsyncCopyObjectException();
    internal static string get_FailedToCreateDirectoryException();
    internal static string get_FailedToEnablePrivilegeException();
    internal static string get_FailedToEnumerateDirectory();
    internal static string get_FailedToGetBlobTypeException();
    internal static string get_FailedToGetFileInfoException();
    internal static string get_FailedToOpenFileException();
    internal static string get_FailedToRetrieveCopyStateForObjectException();
    internal static string get_FailedToValidateDestinationException();
    internal static string get_FilePathTooLong();
    internal static string get_InvalidInitialEntryStatusForControllerException();
    internal static string get_LocalToLocalTransferUnsupportedException();
    internal static string get_MaxListingConcurrencyNotPositiveException();
    internal static string get_MismatchFoundBetweenLocalAndServerCopyIdsException();
    internal static string get_NotSupportedBlobType();
    internal static string get_OnlyOneTransferAllowed();
    internal static string get_OnlySupportBlobAzureFileSource();
    internal static string get_OverwriteCallbackCancelTransferException();
    internal static string get_PageBlob();
    internal static string get_ParallelCountNotPositiveException();
    internal static string get_ParameterCannotBeNullException();
    internal static string get_PathNotFound();
    internal static string get_PrivilegeRequiredException();
    internal static string get_ProvideExactlyOneOfThreeParameters();
    internal static string get_ReadableSizeFormatBytes();
    internal static string get_ReadableSizeFormatExaBytes();
    internal static string get_ReadableSizeFormatGigaBytes();
    internal static string get_ReadableSizeFormatKiloBytes();
    internal static string get_ReadableSizeFormatMegaBytes();
    internal static string get_ReadableSizeFormatPetaBytes();
    internal static string get_ReadableSizeFormatTeraBytes();
    internal static string get_RelativePathTooLong();
    internal static string get_RestartableInfoCorruptedException();
    internal static string get_RestartableLogCorrupted();
    internal static string get_ResumeStreamTransferNotSupported();
    internal static string get_SearchPatternInRecursiveModeFromAzureFileNotSupportedException();
    internal static string get_ServiceSideSyncCopyFromFileNotSupportedException();
    internal static string get_ServiceSideSyncCopyNotSupportException();
    internal static string get_ServiceSideSyncCopyToFileNotSupportedException();
    internal static string get_SmallMemoryCacheSizeLimitationException();
    internal static string get_SourceAndDestinationBlobTypeDifferent();
    internal static string get_SourceAndDestinationLocationCannotBeEqualException();
    internal static string get_SourceBlobDoesNotExistException();
    internal static string get_SourceBlobTypeNotMatch();
    internal static string get_SourceChangedException();
    internal static string get_SourceDoesNotExistException();
    internal static string get_SourceMustBeFixedSize();
    internal static string get_SourceNameInvalidInFileSystem();
    internal static string get_StreamMustSupportReadException();
    internal static string get_StreamMustSupportSeekException();
    internal static string get_StreamMustSupportWriteException();
    internal static string get_StreamNotExpandable();
    internal static string get_SubTransferFailsException();
    internal static string get_SyncCopyFromUriToAzureBlobNotSupportedException();
    internal static string get_SyncCopyFromUriToAzureFileNotSupportedException();
    internal static string get_TransferAlreadyExists();
    internal static string get_TransferCancelledException();
    internal static string get_TransferEntryCopyIdCannotBeNullOrEmptyException();
    internal static string get_UnableToLoadDLL();
    internal static string get_UncategorizedException();
    internal static string get_UnsupportedBlobTypeException();
    internal static string get_UnsupportedDummyTransferException();
    internal static string get_UnsupportedTransferLocationException();
}
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.AzureBlobDirectoryLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.AzureBlobLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.AzureFileDirectoryLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.AzureFileLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.DirectoryLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.FileLocation")]
[KnownTypeAttribute("Microsoft.Azure.Storage.DataMovement.UriLocation")]
internal class Microsoft.Azure.Storage.DataMovement.SerializableTransferLocation : object {
    private static string TransferLocationTypeName;
    private static string TransferLocationName;
    [CompilerGeneratedAttribute]
private TransferLocation <Location>k__BackingField;
    public TransferLocation Location { get; private set; }
    public SerializableTransferLocation(TransferLocation location);
    private SerializableTransferLocation(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public TransferLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(TransferLocation value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableAccessCondition : object {
    private static string IfMatchETagName;
    private static string IfModifiedSinceTimeName;
    private static string IfNoneMatchETagName;
    private static string IfNotModifiedSinceTimeName;
    private static string IfSequenceNumberEqualName;
    private static string IfSequenceNumberLessThanName;
    private static string IfSequenceNumberLessThanOrEqualName;
    private static string LeaseIdName;
    private AccessCondition accessCondition;
    internal AccessCondition AccessCondition { get; internal set; }
    private SerializableAccessCondition(SerializationInfo info, StreamingContext context);
    internal AccessCondition get_AccessCondition();
    internal void set_AccessCondition(AccessCondition value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static AccessCondition GetAccessCondition(SerializableAccessCondition serialization);
    internal static void SetAccessCondition(SerializableAccessCondition& serialization, AccessCondition value);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableBlobRequestOptions : SerializableRequestOptions {
    private static string DisableContentMD5ValidationName;
    private static string MaximumExecutionTimeName;
    private static string ServerTimeoutName;
    private static string StoreBlobContentMD5Name;
    private static string UseTransactionalMD5Name;
    private BlobRequestOptions blobRequestOptions;
    protected IRequestOptions RequestOptions { get; protected set; }
    private SerializableBlobRequestOptions(SerializationInfo info, StreamingContext context);
    protected virtual IRequestOptions get_RequestOptions();
    protected virtual void set_RequestOptions(IRequestOptions value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableCloudBlob : object {
    private static string BlobUriName;
    private static string BlobTypeName;
    [CompilerGeneratedAttribute]
private CloudBlob <Blob>k__BackingField;
    internal CloudBlob Blob { get; internal set; }
    private SerializableCloudBlob(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal CloudBlob get_Blob();
    [CompilerGeneratedAttribute]
internal void set_Blob(CloudBlob value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static CloudBlob GetBlob(SerializableCloudBlob blobSerialization);
    internal static void SetBlob(SerializableCloudBlob& blobSerialization, CloudBlob value);
    internal void UpdateStorageCredentials(StorageCredentials credentials);
    private void CreateCloudBlobInstance(Uri blobUri, BlobType blobType, StorageCredentials credentials);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableCloudBlobDirectory : object {
    private static string ContainerUriName;
    private static string RelativeAddressName;
    private Uri containerUri;
    private string relativeAddress;
    private CloudBlobDirectory blobDir;
    internal CloudBlobDirectory BlobDirectory { get; }
    public SerializableCloudBlobDirectory(CloudBlobDirectory blobDir);
    private SerializableCloudBlobDirectory(SerializationInfo info, StreamingContext context);
    internal CloudBlobDirectory get_BlobDirectory();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal void UpdateStorageCredentials(StorageCredentials credentials);
    private void CreateCloudBlobDirectoryInstance(StorageCredentials credentials);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableCloudFile : object {
    private static string FileUriName;
    [CompilerGeneratedAttribute]
private CloudFile <File>k__BackingField;
    internal CloudFile File { get; internal set; }
    private SerializableCloudFile(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal CloudFile get_File();
    [CompilerGeneratedAttribute]
internal void set_File(CloudFile value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static CloudFile GetFile(SerializableCloudFile fileSerialization);
    internal static void SetFile(SerializableCloudFile& fileSerialization, CloudFile value);
    internal void UpdateStorageCredentials(StorageCredentials credentials);
    private void CreateCloudFileInstance(Uri fileUri, StorageCredentials credentials);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableCloudFileDirectory : object {
    private static string FileDirectoryUriName;
    [CompilerGeneratedAttribute]
private CloudFileDirectory <FileDirectory>k__BackingField;
    internal CloudFileDirectory FileDirectory { get; private set; }
    public SerializableCloudFileDirectory(CloudFileDirectory fileDir);
    private SerializableCloudFileDirectory(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal CloudFileDirectory get_FileDirectory();
    [CompilerGeneratedAttribute]
private void set_FileDirectory(CloudFileDirectory value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal void UpdateStorageCredentials(StorageCredentials credentials);
    private void CreateCloudFileDirectoryInstance(Uri fileDirectoryUri, StorageCredentials credentials);
}
internal class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableFileRequestOptions : SerializableRequestOptions {
    private static string DisableContentMD5ValidationName;
    private static string MaximumExecutionTimeName;
    private static string ServerTimeoutName;
    private static string StoreFileContentMD5Name;
    private static string UseTransactionalMD5Name;
    private FileRequestOptions fileRequestOptions;
    protected IRequestOptions RequestOptions { get; protected set; }
    private SerializableFileRequestOptions(SerializationInfo info, StreamingContext context);
    protected virtual IRequestOptions get_RequestOptions();
    protected virtual void set_RequestOptions(IRequestOptions value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.SerializationHelper.SerializableRequestOptions : object {
    protected IRequestOptions RequestOptions { get; protected set; }
    protected SerializableRequestOptions(SerializationInfo info, StreamingContext context);
    protected abstract virtual IRequestOptions get_RequestOptions();
    protected abstract virtual void set_RequestOptions(IRequestOptions value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static IRequestOptions GetRequestOptions(SerializableRequestOptions serializer);
    internal static void SetRequestOptions(SerializableRequestOptions& serializer, IRequestOptions requestOptions);
    private static SerializableRequestOptions CreateSerializableRequestOptions(IRequestOptions requestOptions);
}
public class Microsoft.Azure.Storage.DataMovement.SetAttributesCallbackAsync : MulticastDelegate {
    public SetAttributesCallbackAsync(object object, IntPtr method);
    public virtual Task Invoke(object source, object destination);
    public virtual IAsyncResult BeginInvoke(object source, object destination, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Microsoft.Azure.Storage.DataMovement.SharedTransferData : object {
    private long totalLength;
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryChunksRequiredEachTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferJob <TransferJob>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<long, TransferData> <AvailableData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableContentMD5Validation>k__BackingField;
    [CompilerGeneratedAttribute]
private Attributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler OnTotalLengthChanged;
    public long TotalLength { get; public set; }
    public int BlockSize { get; public set; }
    public int MemoryChunksRequiredEachTime { get; public set; }
    public TransferJob TransferJob { get; public set; }
    public ConcurrentDictionary`2<long, TransferData> AvailableData { get; public set; }
    public bool DisableContentMD5Validation { get; public set; }
    public Attributes Attributes { get; public set; }
    public long get_TotalLength();
    public void set_TotalLength(long value);
    public void UpdateTotalLength(long value);
    [CompilerGeneratedAttribute]
public int get_BlockSize();
    [CompilerGeneratedAttribute]
public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public int get_MemoryChunksRequiredEachTime();
    [CompilerGeneratedAttribute]
public void set_MemoryChunksRequiredEachTime(int value);
    [CompilerGeneratedAttribute]
public TransferJob get_TransferJob();
    [CompilerGeneratedAttribute]
public void set_TransferJob(TransferJob value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<long, TransferData> get_AvailableData();
    [CompilerGeneratedAttribute]
public void set_AvailableData(ConcurrentDictionary`2<long, TransferData> value);
    [CompilerGeneratedAttribute]
public bool get_DisableContentMD5Validation();
    [CompilerGeneratedAttribute]
public void set_DisableContentMD5Validation(bool value);
    [CompilerGeneratedAttribute]
public Attributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Attributes value);
    [CompilerGeneratedAttribute]
public void add_OnTotalLengthChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnTotalLengthChanged(EventHandler value);
}
public class Microsoft.Azure.Storage.DataMovement.ShouldOverwriteCallbackAsync : MulticastDelegate {
    public ShouldOverwriteCallbackAsync(object object, IntPtr method);
    public virtual Task`1<bool> Invoke(object source, object destination);
    public virtual IAsyncResult BeginInvoke(object source, object destination, AsyncCallback callback, object object);
    public virtual Task`1<bool> EndInvoke(IAsyncResult result);
}
public class Microsoft.Azure.Storage.DataMovement.ShouldTransferCallbackAsync : MulticastDelegate {
    public ShouldTransferCallbackAsync(object object, IntPtr method);
    public virtual Task`1<bool> Invoke(object source, object destination);
    public virtual IAsyncResult BeginInvoke(object source, object destination, AsyncCallback callback, object object);
    public virtual Task`1<bool> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Azure.Storage.DataMovement.SingleObjectCheckpoint : object {
    [CompilerGeneratedAttribute]
private long <EntryTransferOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<long> <TransferWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TransferWindowLock>k__BackingField;
    public long EntryTransferOffset { get; public set; }
    public List`1<long> TransferWindow { get; public set; }
    public object TransferWindowLock { get; private set; }
    public SingleObjectCheckpoint(long entryTransferOffset, IEnumerable`1<long> transferWindow);
    [CompilerGeneratedAttribute]
public long get_EntryTransferOffset();
    [CompilerGeneratedAttribute]
public void set_EntryTransferOffset(long value);
    [CompilerGeneratedAttribute]
public List`1<long> get_TransferWindow();
    [CompilerGeneratedAttribute]
public void set_TransferWindow(List`1<long> value);
    [CompilerGeneratedAttribute]
public object get_TransferWindowLock();
    [CompilerGeneratedAttribute]
private void set_TransferWindowLock(object value);
    public SingleObjectCheckpoint Copy();
}
internal class Microsoft.Azure.Storage.DataMovement.SingleObjectTransfer : Transfer {
    private static string TransferJobName;
    private static string ShouldTransferCheckedName;
    private TransferJob transferJob;
    private bool shouldTransferChecked;
    [CompilerGeneratedAttribute]
private AzureFileDirectorySDDLCache <SDDLCache>k__BackingField;
    public bool ShouldTransferChecked { get; public set; }
    public AzureFileDirectorySDDLCache SDDLCache { get; public set; }
    public SingleObjectTransfer(TransferLocation source, TransferLocation dest, TransferMethod transferMethod);
    protected SingleObjectTransfer(SerializationInfo info, StreamingContext context);
    private SingleObjectTransfer(SingleObjectTransfer other);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public bool get_ShouldTransferChecked();
    public void set_ShouldTransferChecked(bool value);
    [CompilerGeneratedAttribute]
public AzureFileDirectorySDDLCache get_SDDLCache();
    [CompilerGeneratedAttribute]
public void set_SDDLCache(AzureFileDirectorySDDLCache value);
    public virtual Transfer Copy();
    public void UpdateProgressLock(ReaderWriterLockSlim uploadLock);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.SingleObjectTransfer/<ExecuteAsync>d__17")]
public virtual Task ExecuteAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    public void OnTransferFailed(Exception ex);
    private void OnTransferFailed(TransferEventArgs eventArgs);
    public bool IsValid();
}
public class Microsoft.Azure.Storage.DataMovement.SingleTransferContext : TransferContext {
    public SingleTransferContext(TransferCheckpoint checkpoint);
    public SingleTransferContext(Stream journalStream);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Storage.DataMovement.StorageExtensions : object {
    internal static bool Equals(CloudBlob blob, CloudBlob comparand);
    [ExtensionAttribute]
internal static CloudFile GenerateCopySourceFile(CloudFile file, bool preservePermission);
    [ExtensionAttribute]
internal static Uri GenerateCopySourceUri(CloudFile file, bool preservePermission);
    private static string GetFileSASToken(CloudFile file, bool preservePermission);
    [ExtensionAttribute]
internal static CloudBlob GenerateCopySourceBlob(CloudBlob blob);
    [ExtensionAttribute]
internal static Uri GenerateCopySourceUri(CloudBlob cloudBlob);
    [ExtensionAttribute]
internal static string ConvertToString(object instance);
    private static string GetBlobSasToken(CloudBlob blob);
}
internal class Microsoft.Azure.Storage.DataMovement.StreamJournal : object {
    private static int TransferChunkSize;
    private static int TransferItemContentSize;
    private static int ProcessTrackerSize;
    private static int SubDirectoryTransferChunkSize;
    private static int JournalHeadOffset;
    private static int ContentOffset;
    private static int SubTransferContentOffset;
    private static int MaxTransferChunkSize;
    private Transfer baseTransfer;
    private Stream stream;
    private string absoluteDirectoryPath;
    private object journalLock;
    private IFormatter formatter;
    private long singleTransferChunkHead;
    private long singleTransferChunkTail;
    private long OngoingSubDirTransferChunkHead;
    private long OngoingSubDirTransferChunkTail;
    private long subDirTransferChunkHead;
    private long subDirTransferChunkTail;
    private long subDirTransferNextWriteOffset;
    private long subDirTransferCurrentReadOffset;
    private long freeChunkHead;
    private long freeChunkTail;
    private long preservedChunkCount;
    private static int BufferSizeGranularity;
    private Byte[] memoryBuffer;
    public string DirectoryPath { get; public set; }
    public StreamJournal(Stream journal);
    public string get_DirectoryPath();
    public void set_DirectoryPath(string value);
    public Transfer Initialize();
    internal void AddOngoingSubDirTransfer(SubDirectoryTransfer directoryTransfer);
    internal void RemoveSubDirTransfer(SubDirectoryTransfer directoryTransfer);
    internal void RemoveFirstSubDirTransfer();
    internal string PeekSubDirTransfer();
    internal void AddSubDirTransfer(string relativePath);
    internal void AddTransfer(Transfer transfer);
    internal void AddSubtransfer(SingleObjectTransfer transfer);
    internal void RemoveTransfer(Transfer transfer);
    internal void FreeChunk(long chunkOffset, Int64& usedChunkHead, Int64& usedChunkTail);
    internal void UpdateJournalItem(JournalItem item);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.StreamJournal/<ListSubDirTransfers>d__41")]
public IEnumerable`1<SubDirectoryTransfer> ListSubDirTransfers();
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.StreamJournal/<ListSubTransfers>d__42")]
public IEnumerable`1<SingleObjectTransfer> ListSubTransfers();
    private void WriteJournalHead();
    private long ReadLong();
    private void ReadAndCheck(int length);
    private bool ReadAndCheckEmpty();
    private void AllocateBuffer(int length);
    private long SearchFreeOffset();
}
[SuppressMessageAttribute("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
internal class Microsoft.Azure.Storage.DataMovement.StreamLocation : TransferLocation {
    private static ConditionalWeakTable`2<Stream, string> StreamIdTable;
    private string streamLocationIdentity;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public Stream Stream { get; private set; }
    public StreamLocation(Stream stream);
    private static StreamLocation();
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    public virtual void Validate();
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.SubDirectoryTransfer : JournalItem {
    private static string SubDirListContinuationTokenName;
    private static string SubDirRelativePathName;
    private HierarchyDirectoryTransfer baseDirectoryTransfer;
    private ITransferEnumerator transferEnumerator;
    private string relativePath;
    private SerializableListContinuationToken enumerateContinuationToken;
    private TransferLocation source;
    private TransferLocation dest;
    public SerializableListContinuationToken ListContinuationToken { get; public set; }
    public TransferLocation Source { get; }
    public SubDirectoryTransfer(HierarchyDirectoryTransfer baseDirectoryTransfer, string relativePath);
    public SubDirectoryTransfer(SubDirectoryTransfer other);
    protected SubDirectoryTransfer(SerializationInfo info, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public SerializableListContinuationToken get_ListContinuationToken();
    public void set_ListContinuationToken(SerializableListContinuationToken value);
    public TransferLocation get_Source();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.SubDirectoryTransfer/<ExecuteAsync>d__17")]
public Task ExecuteAsync(CancellationToken cancellationToken);
    public void Update(HierarchyDirectoryTransfer baseDirectoryTransferInstance);
    public void CreateDestinationParentDirectoryRecursively(SingleObjectTransfer transferItem);
    private void InitializeEnumerator();
    private void CreateDestinationDirectory(CancellationToken cancellationToken);
    private void GetSourceProperites(Nullable`1& fileAttributes, String& portableSDDL, Nullable`1& creationTime, Nullable`1& lastWriteTime, IDictionary`2& metadata, CancellationToken cancellationToken);
    private void CreateCloudFileDestinationDirectory(CloudFileDirectory fileDirectory, Nullable`1<CloudFileNtfsAttributes> fileAttributes, Nullable`1<DateTimeOffset> creationTime, Nullable`1<DateTimeOffset> lastWriteTime, IDictionary`2<string, string> metadata, string portableSDDL, CancellationToken cancellationToken);
    private static void SetAzureFileDirectoryAttributes(CloudFileDirectory fileDirectory, Nullable`1<CloudFileNtfsAttributes> fileAttributes, Nullable`1<DateTimeOffset> creationTime, Nullable`1<DateTimeOffset> lastWriteTime, string filePermissionKey, string portableSDDL, IDictionary`2<string, string> metadata, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.Transfer : JournalItem {
    private static string FormatVersionName;
    private static string SourceName;
    private static string DestName;
    private static string TransferMethodName;
    private static string TransferProgressName;
    [CompilerGeneratedAttribute]
private string <OriginalFormatVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferLocation <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferLocation <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferMethod <TransferMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveSMBAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private PreserveSMBPermissions <PreserveSMBPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferProgressTracker <ProgressTracker>k__BackingField;
    private string OriginalFormatVersion { get; private set; }
    public TransferLocation Source { get; private set; }
    public TransferLocation Destination { get; private set; }
    public TransferMethod TransferMethod { get; private set; }
    public TransferContext Context { get; public set; }
    public BlobType BlobType { get; public set; }
    public bool PreserveSMBAttributes { get; public set; }
    public PreserveSMBPermissions PreserveSMBPermissions { get; public set; }
    public TransferProgressTracker ProgressTracker { get; protected set; }
    public Transfer(TransferLocation source, TransferLocation dest, TransferMethod transferMethod);
    protected Transfer(SerializationInfo info, StreamingContext context);
    protected Transfer(Transfer other);
    [CompilerGeneratedAttribute]
private string get_OriginalFormatVersion();
    [CompilerGeneratedAttribute]
private void set_OriginalFormatVersion(string value);
    [CompilerGeneratedAttribute]
public TransferLocation get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(TransferLocation value);
    [CompilerGeneratedAttribute]
public TransferLocation get_Destination();
    [CompilerGeneratedAttribute]
private void set_Destination(TransferLocation value);
    [CompilerGeneratedAttribute]
public TransferMethod get_TransferMethod();
    [CompilerGeneratedAttribute]
private void set_TransferMethod(TransferMethod value);
    [CompilerGeneratedAttribute]
public virtual TransferContext get_Context();
    [CompilerGeneratedAttribute]
public virtual void set_Context(TransferContext value);
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
public void set_BlobType(BlobType value);
    [CompilerGeneratedAttribute]
public bool get_PreserveSMBAttributes();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBAttributes(bool value);
    [CompilerGeneratedAttribute]
public PreserveSMBPermissions get_PreserveSMBPermissions();
    [CompilerGeneratedAttribute]
public void set_PreserveSMBPermissions(PreserveSMBPermissions value);
    [CompilerGeneratedAttribute]
public TransferProgressTracker get_ProgressTracker();
    [CompilerGeneratedAttribute]
protected void set_ProgressTracker(TransferProgressTracker value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual Task ExecuteAsync(TransferScheduler scheduler, CancellationToken cancellationToken);
    public void UpdateTransferJobStatus(TransferJob transferJob, TransferJobStatus targetStatus);
    public abstract virtual Transfer Copy();
    public void UpdateJournal();
    private static void UpdateProgress(TransferJob job, Action updateAction);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <UpdateTransferJobStatus>b__46_0();
    [CompilerGeneratedAttribute]
private void <UpdateTransferJobStatus>b__46_1();
    [CompilerGeneratedAttribute]
private void <UpdateTransferJobStatus>b__46_2();
    [CompilerGeneratedAttribute]
private void <UpdateTransferJobStatus>b__46_3();
}
internal static class Microsoft.Azure.Storage.DataMovement.Transfer_RequestOptions : object {
    private static int DefaultRetryCountXMsError;
    private static int DefaultRetryCountOtherError;
    private static TimeSpan DefaultMaximumExecutionTime;
    private static TimeSpan DefaultServerTimeout;
    public static TimeSpan DefaultCreationServerTimeout;
    private static TimeSpan retryPoliciesDefaultBackoff;
    public static BlobRequestOptions DefaultBlobRequestOptions { get; }
    public static BlobRequestOptions DefaultHttpsBlobRequestOptions { get; }
    public static FileRequestOptions DefaultFileRequestOptions { get; }
    public static FileRequestOptions DefaultHttpsFileRequestOptions { get; }
    private static Transfer_RequestOptions();
    public static BlobRequestOptions get_DefaultBlobRequestOptions();
    public static BlobRequestOptions get_DefaultHttpsBlobRequestOptions();
    public static FileRequestOptions get_DefaultFileRequestOptions();
    public static FileRequestOptions get_DefaultHttpsFileRequestOptions();
    internal static IRequestOptions CreateDefaultRequestOptions(TransferLocation location);
}
public class Microsoft.Azure.Storage.DataMovement.TransferCheckpoint : object {
    private static string TransferCollectionName;
    private StreamJournal Journal;
    [CompilerGeneratedAttribute]
private TransferCollection`1<Transfer> <TransferCollection>k__BackingField;
    internal TransferCollection`1<Transfer> TransferCollection { get; private set; }
    private TransferCheckpoint(TransferCheckpoint other);
    internal TransferCheckpoint(Stream journalStream);
    protected TransferCheckpoint(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal TransferCollection`1<Transfer> get_TransferCollection();
    [CompilerGeneratedAttribute]
private void set_TransferCollection(TransferCollection`1<Transfer> value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal void AddTransfer(Transfer transfer);
    internal Transfer GetTransfer(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod);
    internal TransferCheckpoint Copy();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferCollection`1 : object {
    private static string SingleObjectTransfersName;
    private static string DirectoryTransfersName;
    private ConcurrentDictionary`2<Tuple`2<TransferLocation, TransferLocation>, Transfer> transfers;
    private TransferProgressTracker overallProgressTracker;
    public int Count { get; }
    public TransferProgressTracker OverallProgressTracker { get; }
    protected TransferCollection`1(SerializationInfo info, StreamingContext context);
    public int get_Count();
    public TransferProgressTracker get_OverallProgressTracker();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void AddTransfer(T transfer, bool updateProgress);
    public bool RemoveTransfer(Transfer transfer);
    public Transfer GetTransfer(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod);
    public IEnumerable`1<Transfer> GetEnumerator();
    public TransferCollection`1<T> Copy();
}
public class Microsoft.Azure.Storage.DataMovement.TransferConfigurations : object {
    private int blockSize;
    private int parallelOperations;
    private long maximumCacheSize;
    private Nullable`1<int> maxListingConcurrency;
    private GlobalMemoryStatusNativeMethods memStatus;
    [CompilerGeneratedAttribute]
private string <UserAgentPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportUncPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryChunkSize>k__BackingField;
    public int ParallelOperations { get; public set; }
    public Nullable`1<int> MaxListingConcurrency { get; public set; }
    public int BlockSize { get; public set; }
    public string UserAgentPrefix { get; public set; }
    internal long MaximumCacheSize { get; internal set; }
    internal bool SupportUncPath { get; private set; }
    internal int MemoryChunkSize { get; private set; }
    public int get_ParallelOperations();
    public void set_ParallelOperations(int value);
    public Nullable`1<int> get_MaxListingConcurrency();
    public void set_MaxListingConcurrency(Nullable`1<int> value);
    public int get_BlockSize();
    public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public string get_UserAgentPrefix();
    [CompilerGeneratedAttribute]
public void set_UserAgentPrefix(string value);
    internal long get_MaximumCacheSize();
    internal void set_MaximumCacheSize(long value);
    [CompilerGeneratedAttribute]
internal bool get_SupportUncPath();
    [CompilerGeneratedAttribute]
private void set_SupportUncPath(bool value);
    [CompilerGeneratedAttribute]
internal int get_MemoryChunkSize();
    [CompilerGeneratedAttribute]
private void set_MemoryChunkSize(int value);
    internal void UpdateMaximumCacheSize(int newBlockSize);
}
public abstract class Microsoft.Azure.Storage.DataMovement.TransferContext : object {
    [CompilerGeneratedAttribute]
private string <ClientRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ShouldOverwriteCallbackAsync <ShouldOverwriteCallbackAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private SetAttributesCallbackAsync <SetAttributesCallbackAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransferEventArgs> FileTransferred;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransferEventArgs> FileSkipped;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransferEventArgs> FileFailed;
    [CompilerGeneratedAttribute]
private TransferCheckpoint <Checkpoint>k__BackingField;
    public string ClientRequestId { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public TransferCheckpoint LastCheckpoint { get; }
    public ShouldOverwriteCallbackAsync ShouldOverwriteCallbackAsync { get; public set; }
    public SetAttributesCallbackAsync SetAttributesCallbackAsync { get; public set; }
    public IProgress`1<TransferStatus> ProgressHandler { get; public set; }
    internal TransferProgressTracker OverallProgressTracker { get; }
    internal TransferCheckpoint Checkpoint { get; private set; }
    protected TransferContext(TransferCheckpoint checkpoint);
    protected TransferContext(Stream journalStream);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferContext/<ForceOverwrite>d__0")]
public static Task`1<bool> ForceOverwrite(object source, object destination);
    [CompilerGeneratedAttribute]
public string get_ClientRequestId();
    [CompilerGeneratedAttribute]
public void set_ClientRequestId(string value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    public TransferCheckpoint get_LastCheckpoint();
    [CompilerGeneratedAttribute]
public ShouldOverwriteCallbackAsync get_ShouldOverwriteCallbackAsync();
    [CompilerGeneratedAttribute]
public void set_ShouldOverwriteCallbackAsync(ShouldOverwriteCallbackAsync value);
    [CompilerGeneratedAttribute]
public SetAttributesCallbackAsync get_SetAttributesCallbackAsync();
    [CompilerGeneratedAttribute]
public void set_SetAttributesCallbackAsync(SetAttributesCallbackAsync value);
    public IProgress`1<TransferStatus> get_ProgressHandler();
    public void set_ProgressHandler(IProgress`1<TransferStatus> value);
    [CompilerGeneratedAttribute]
public void add_FileTransferred(EventHandler`1<TransferEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FileTransferred(EventHandler`1<TransferEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_FileSkipped(EventHandler`1<TransferEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FileSkipped(EventHandler`1<TransferEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_FileFailed(EventHandler`1<TransferEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FileFailed(EventHandler`1<TransferEventArgs> value);
    internal TransferProgressTracker get_OverallProgressTracker();
    [CompilerGeneratedAttribute]
internal TransferCheckpoint get_Checkpoint();
    [CompilerGeneratedAttribute]
private void set_Checkpoint(TransferCheckpoint value);
    internal void OnTransferSuccess(TransferEventArgs eventArgs);
    internal void OnTransferSkipped(TransferEventArgs eventArgs);
    internal void OnTransferFailed(TransferEventArgs eventArgs);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobServiceSideSyncCopyController : ServiceSideSyncCopyController {
    private CloudAppendBlob destAppendBlob;
    private long blockSize;
    private AzureBlobLocation destLocation;
    internal AppendBlobServiceSideSyncCopyController(TransferScheduler scheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual void PostFetchSourceAttributes();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobServiceSideSyncCopyController/<GetDestinationAsync>d__5")]
protected virtual Task GetDestinationAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobServiceSideSyncCopyController/<CopyChunkAsync>d__6")]
protected virtual Task CopyChunkAsync();
    protected virtual Task DoPreCopyAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobServiceSideSyncCopyController/<ValidateAppendedChunkAsync>d__8")]
private Task`1<bool> ValidateAppendedChunkAsync(long startOffset, long length);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobServiceSideSyncCopyController/<CommitAsync>d__9")]
protected virtual Task CommitAsync();
    protected virtual void SetErrorState(Exception ex);
    private void SetFinish();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter : TransferReaderWriterBase {
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private AzureBlobLocation destLocation;
    private CloudAppendBlob appendBlob;
    private long expectedOffset;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) workToken;
    private bool destExist;
    public bool HasWork { get; }
    public bool IsFinished { get; }
    public AppendBlobWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    public virtual bool get_HasWork();
    public virtual bool get_IsFinished();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<DoWorkInternalAsync>d__12")]
public virtual Task DoWorkInternalAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<FetchAttributesAsync>d__13")]
private Task FetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<HandleFetchAttributesResultAsync>d__14")]
private Task HandleFetchAttributesResultAsync(bool existingBlob);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<CreateAsync>d__15")]
private Task CreateAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<UploadBlobAsync>d__16")]
private Task UploadBlobAsync();
    private void CleanupPropertyForCanonicalization();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<CommitAsync>d__18")]
private Task CommitAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AppendBlobWriter/<ValidateUploadedChunkAsync>d__19")]
private Task`1<bool> ValidateUploadedChunkAsync(Byte[][] currentData, long startOffset, long length);
    private void SetFinish();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController : TransferControllerBase {
    private Timer statusRefreshTimer;
    private object statusRefreshTimerLock;
    private long statusRefreshWaitTime;
    private bool approachingFinish;
    private long statusRefreshRequestCount;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private bool hasWork;
    private long lastBytesCopied;
    [CompilerGeneratedAttribute]
private CloudBlob <SourceBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    public bool HasWork { get; }
    protected CloudBlob SourceBlob { get; private set; }
    protected CloudFile SourceFile { get; private set; }
    protected Uri SourceUri { get; private set; }
    protected Uri DestUri { get; }
    internal AsyncCopyController(TransferScheduler scheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    public virtual bool get_HasWork();
    [CompilerGeneratedAttribute]
protected CloudBlob get_SourceBlob();
    [CompilerGeneratedAttribute]
private void set_SourceBlob(CloudBlob value);
    [CompilerGeneratedAttribute]
protected CloudFile get_SourceFile();
    [CompilerGeneratedAttribute]
private void set_SourceFile(CloudFile value);
    [CompilerGeneratedAttribute]
protected Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
    protected abstract virtual Uri get_DestUri();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<DoWorkInternalAsync>d__26")]
protected virtual Task`1<bool> DoWorkInternalAsync();
    protected virtual void SetErrorState(Exception ex);
    protected static Dictionary`2<string, string> ParseQueryString(string query);
    private void SetInitialStatus();
    private void SetHasWorkAfterStatusChanged();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<FetchSourceAttributesAsync>d__31")]
private Task FetchSourceAttributesAsync();
    private static void HandleFetchSourceAttributesException(StorageException e);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<GetDestinationAsync>d__33")]
private Task GetDestinationAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<HandleGetDestinationResultAsync>d__34")]
private Task`1<bool> HandleGetDestinationResultAsync(Exception e);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<StartCopyAsync>d__35")]
private Task StartCopyAsync();
    private bool HandleStartCopyResult(StorageException se);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<GetCopyStateAsync>d__37")]
private Task GetCopyStateAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<HandleFetchCopyStateResultAsync>d__38")]
private Task HandleFetchCopyStateResultAsync(StorageCopyState copyState, bool gotDestinationAttributes);
    private void UpdateTransferProgress(StorageCopyState copyState);
    private void SetFinished();
    private void RestartTimer();
    private void DisposeStatusRefreshTimer();
    private Uri GetSourceUri();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.AsyncCopyController/<DoFetchSourceAttributesAsync>d__44")]
protected Task DoFetchSourceAttributesAsync();
    protected abstract virtual Task DoFetchDestAttributesAsync();
    protected abstract virtual Task`1<StorageCopyState> DoStartCopyAsync();
    protected abstract virtual void DoHandleGetDestinationException(StorageException se);
    protected abstract virtual Task`1<StorageCopyState> FetchCopyStateAsync();
    protected abstract virtual Task SetAttributesAsync(SetAttributesCallbackAsync setAttributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(object timerState);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.BlobAsyncCopyController : AsyncCopyController {
    private AzureBlobLocation destLocation;
    private CloudBlob destBlob;
    protected Uri DestUri { get; }
    public BlobAsyncCopyController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken cancellationToken);
    protected virtual Uri get_DestUri();
    protected virtual Task DoFetchDestAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlobAsyncCopyController/<DoStartCopyAsync>d__6")]
protected virtual Task`1<StorageCopyState> DoStartCopyAsync();
    protected virtual void DoHandleGetDestinationException(StorageException se);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlobAsyncCopyController/<FetchCopyStateAsync>d__8")]
protected virtual Task`1<StorageCopyState> FetchCopyStateAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlobAsyncCopyController/<SetAttributesAsync>d__9")]
protected virtual Task SetAttributesAsync(SetAttributesCallbackAsync setCustomAttributes);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBasedBlobReader : TransferReaderWriterBase {
    private AzureBlobLocation sourceLocation;
    private CloudBlob sourceBlob;
    private Queue`1<long> lastTransferWindow;
    private TransferJob transferJob;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isFinished;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) workToken;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isStateSwitchedInternal;
    private CountdownEvent downloadCountdownEvent;
    public bool IsFinished { get; }
    public bool HasWork { get; }
    public BlockBasedBlobReader(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    public virtual bool get_IsFinished();
    public virtual bool get_HasWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBasedBlobReader/<DoWorkInternalAsync>d__13")]
public virtual Task DoWorkInternalAsync();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBasedBlobReader/<FetchAttributeAsync>d__15")]
private Task FetchAttributeAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBasedBlobReader/<DownloadBlockBlobAsync>d__16")]
private Task DownloadBlockBlobAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBasedBlobReader/<DownloadChunkAsync>d__17")]
private Task DownloadChunkAsync(ReadDataState asyncState);
    private void SetFinish();
    private void SetBlockDownloadHasWork();
    private bool IsTransferWindowEmpty();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobServiceSideSyncCopyController : ServiceSideSyncCopyController {
    private string BlockIdPrefix;
    private AzureBlobLocation destLocation;
    private CloudBlockBlob destBlockBlob;
    private long blockSize;
    private CountdownEvent countdownEvent;
    private SortedDictionary`2<int, string> blockIds;
    private Queue`1<long> lastTransferWindow;
    private bool gotDestinationAttributes;
    internal BlockBlobServiceSideSyncCopyController(TransferScheduler scheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual void PostFetchSourceAttributes();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobServiceSideSyncCopyController/<GetDestinationAsync>d__10")]
protected virtual Task GetDestinationAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobServiceSideSyncCopyController/<CopyChunkAsync>d__11")]
protected virtual Task CopyChunkAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobServiceSideSyncCopyController/<CommitAsync>d__12")]
protected virtual Task CommitAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobServiceSideSyncCopyController/<HandleGetDestinationResultAsync>d__13")]
private Task`1<bool> HandleGetDestinationResultAsync(Exception e);
    private void PrepareForCopy();
    private void InitializeBlockIds();
    protected virtual void SetErrorState(Exception ex);
    protected virtual void Dispose(bool disposing);
    protected virtual Task DoPreCopyAsync();
    private void SetFinish();
    private void FinishBlock();
    private string GetBlockIdByIndex(int index);
    private string GenerateBlockIdPrefix();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter : TransferReaderWriterBase {
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private SortedDictionary`2<int, string> blockIds;
    private object blockIdsLock;
    private AzureBlobLocation destLocation;
    private CloudBlockBlob blockBlob;
    private long uploadedLength;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) workToken;
    [CompilerGeneratedAttribute]
private bool <PreProcessed>k__BackingField;
    public bool PreProcessed { get; protected set; }
    public bool HasWork { get; }
    public bool IsFinished { get; }
    public BlockBlobWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual bool get_PreProcessed();
    [CompilerGeneratedAttribute]
protected virtual void set_PreProcessed(bool value);
    public virtual bool get_HasWork();
    public virtual bool get_IsFinished();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<DoWorkInternalAsync>d__17")]
public virtual Task DoWorkInternalAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<FetchAttributesAsync>d__18")]
private Task FetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<HandleFetchAttributesResultAsync>d__19")]
private Task HandleFetchAttributesResultAsync(Exception e);
    private void PrepareForPutBlockAndPutBlockList();
    private void PrepareForPutBlob();
    private string GenerateBlockIdPrefix();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<UploadBlobAsync>d__23")]
private Task UploadBlobAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<CommitAsync>d__24")]
private Task CommitAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<UploadBlobAndSetAttributesAsync>d__25")]
private Task UploadBlobAndSetAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.BlockBlobWriter/<DoUploadAndSetBlobAttributes>d__26")]
private Task DoUploadAndSetBlobAttributes(Stream sourceStream);
    private void SetFinish();
    private void FinishBlock();
    private void InitializeBlockIds();
    private string GetBlockId(long startOffset);
    private string GetBlockIdByIndex(int index);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileReader : RangeBasedReader {
    private AzureFileLocation sourceLocation;
    private CloudFile cloudFile;
    public CloudFileReader(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileReader/<DoFetchAttributesAsync>d__3")]
protected virtual Task DoFetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileReader/<DoGetRangesAsync>d__4")]
protected virtual Task`1<List`1<Range>> DoGetRangesAsync(RangesSpan rangesSpan);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileReader/<DoDownloadRangeToStreamAsync>d__5")]
protected virtual Task DoDownloadRangeToStreamAsync(RangeBasedDownloadState asyncState);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileWriter : RangeBasedWriter {
    private AzureFileLocation destLocation;
    private CloudFile cloudFile;
    private bool destExist;
    protected Uri DestUri { get; }
    internal CloudFileWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    protected virtual Uri get_DestUri();
    protected virtual void CheckInputStreamLength(long inputStreamLength);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileWriter/<DoFetchAttributesAsync>d__7")]
protected virtual Task DoFetchAttributesAsync();
    protected virtual void HandleFetchAttributesResult(Exception e);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileWriter/<DoCreateAsync>d__9")]
protected virtual Task DoCreateAsync(long size);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileWriter/<WriteRangeAsync>d__10")]
protected virtual Task WriteRangeAsync(TransferData transferData);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.CloudFileWriter/<DoCommitAsync>d__11")]
protected virtual Task DoCommitAsync();
    private void CleanupPropertyForCanonicalization();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.DummyTransferController : TransferControllerBase {
    private Status status;
    public bool HasWork { get; }
    public DummyTransferController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    public virtual bool get_HasWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.DummyTransferController/<DoWorkInternalAsync>d__5")]
protected virtual Task`1<bool> DoWorkInternalAsync();
    protected virtual void SetErrorState(Exception ex);
    [CompilerGeneratedAttribute]
private void <DoWorkInternalAsync>b__5_0();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.FileAsyncCopyController : AsyncCopyController {
    private AzureFileLocation destLocation;
    private CloudFile destFile;
    protected Uri DestUri { get; }
    public FileAsyncCopyController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken cancellationToken);
    protected virtual Uri get_DestUri();
    protected virtual Task DoFetchDestAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.FileAsyncCopyController/<DoStartCopyAsync>d__6")]
protected virtual Task`1<StorageCopyState> DoStartCopyAsync();
    protected virtual void DoHandleGetDestinationException(StorageException se);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.FileAsyncCopyController/<FetchCopyStateAsync>d__8")]
protected virtual Task`1<StorageCopyState> FetchCopyStateAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.FileAsyncCopyController/<SetAttributesAsync>d__9")]
protected virtual Task SetAttributesAsync(SetAttributesCallbackAsync setCustomAttributes);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.FileServiceSideSyncCopyController : RangeBasedServiceSideSyncCopy {
    private CloudFile destFile;
    private AzureFileLocation destLocation;
    internal FileServiceSideSyncCopyController(TransferScheduler scheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual Task CopyChunkFromUriAsync(long startOffset, long length);
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferControllers.ITransferController {
    public bool HasWork { get; }
    public bool IsFinished { get; }
    public abstract virtual bool get_HasWork();
    public abstract virtual bool get_IsFinished();
    public abstract virtual Task`1<bool> DoWorkAsync();
    public abstract virtual void CancelWork();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobReader : RangeBasedReader {
    private AzureBlobLocation sourceLocation;
    private CloudPageBlob pageBlob;
    public PageBlobReader(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobReader/<DoFetchAttributesAsync>d__3")]
protected virtual Task DoFetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobReader/<DoGetRangesAsync>d__4")]
protected virtual Task`1<List`1<Range>> DoGetRangesAsync(RangesSpan rangesSpan);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobReader/<DoDownloadRangeToStreamAsync>d__5")]
protected virtual Task DoDownloadRangeToStreamAsync(RangeBasedDownloadState asyncState);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobServiceSideSyncCopyController : RangeBasedServiceSideSyncCopy {
    private CloudPageBlob destPageBlob;
    private AzureBlobLocation destLocation;
    internal PageBlobServiceSideSyncCopyController(TransferScheduler scheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual Task CopyChunkFromUriAsync(long startOffset, long length);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobWriter : RangeBasedWriter {
    private AzureBlobLocation destLocation;
    private CloudPageBlob pageBlob;
    private static long PageBlobPageSize;
    private bool destExist;
    protected Uri DestUri { get; }
    internal PageBlobWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    protected virtual Uri get_DestUri();
    protected virtual void CheckInputStreamLength(long inputStreamLength);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobWriter/<DoFetchAttributesAsync>d__8")]
protected virtual Task DoFetchAttributesAsync();
    protected virtual void HandleFetchAttributesResult(Exception e);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobWriter/<DoCreateAsync>d__10")]
protected virtual Task DoCreateAsync(long size);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobWriter/<WriteRangeAsync>d__11")]
protected virtual Task WriteRangeAsync(TransferData transferData);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.PageBlobWriter/<DoCommitAsync>d__12")]
protected virtual Task DoCommitAsync();
    private void CleanupPropertyForCanonicalization();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader : TransferReaderWriterBase {
    private static int MinimumNoDataRangeSize;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private TransferJob transferJob;
    private CountdownEvent getRangesCountDownEvent;
    private CountdownEvent toDownloadItemsCountdownEvent;
    private int getRangesSpanIndex;
    private List`1<RangesSpan> rangesSpanList;
    private List`1<Range> rangeList;
    private int nextDownloadIndex;
    private long lastTransferOffset;
    private TransferDownloadBuffer currentDownloadBuffer;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasWork;
    [CompilerGeneratedAttribute]
private TransferLocation <Location>k__BackingField;
    public bool HasWork { get; }
    public bool IsFinished { get; }
    protected TransferLocation Location { get; private set; }
    public RangeBasedReader(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<DoWorkInternalAsync>d__14")]
public virtual Task DoWorkInternalAsync();
    public virtual bool get_HasWork();
    public virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
protected TransferLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(TransferLocation value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<FetchAttributesAsync>d__24")]
private Task FetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<GetRangesAsync>d__25")]
private Task GetRangesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<DownloadRangeAsync>d__26")]
private Task DownloadRangeAsync();
    private void SetRangeDownloadHasWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<DownloadRangeAsync>d__28")]
private Task DownloadRangeAsync(RangeBasedDownloadState asyncState);
    private void PrepareToGetRanges();
    private void ClearForGetRanges();
    private void ArrangeRanges();
    private void AddRangesByCheckPoint(long startOffset, long endOffset, bool hasData, Boolean& reachLastTransferOffset, Int32& lastTransferWindowIndex);
    private void InitDownloadInfo();
    private void SetChunkFinish();
    protected abstract virtual Task DoFetchAttributesAsync();
    protected abstract virtual Task DoDownloadRangeToStreamAsync(RangeBasedDownloadState asyncState);
    protected abstract virtual Task`1<List`1<Range>> DoGetRangesAsync(RangesSpan rangesSpan);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedReader/<<FetchAttributesAsync>b__24_0>d")]
[CompilerGeneratedAttribute]
private Task <FetchAttributesAsync>b__24_0();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedServiceSideSyncCopy : ServiceSideSyncCopyController {
    private CountdownEvent countdownEvent;
    private Queue`1<long> lastTransferWindow;
    private long nextRangesSpanOffset;
    private CountdownEvent getRangesCountdownEvent;
    private ConcurrentBag`1<List`1<long>> pageListBag;
    private List`1<long> pagesToCopy;
    private IEnumerator`1<long> nextPageToCopy;
    private bool hasNextPage;
    private IRangeBasedSourceHandler rangeBasedSourceHandler;
    protected RangeBasedServiceSideSyncCopy(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual void PostFetchSourceAttributes();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedServiceSideSyncCopy/<DoPreCopyAsync>d__11")]
protected virtual Task DoPreCopyAsync();
    private void PrepareForCopy();
    private int InitializeCopyStatus();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedServiceSideSyncCopy/<GetDestinationAsync>d__14")]
protected virtual Task GetDestinationAsync();
    protected virtual void SetErrorState(Exception ex);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedServiceSideSyncCopy/<CopyChunkAsync>d__17")]
protected virtual Task CopyChunkAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedServiceSideSyncCopy/<CommitAsync>d__18")]
protected virtual Task CommitAsync();
    private void SetFinish();
    private void FinishBlock();
    protected abstract virtual Task CopyChunkFromUriAsync(long startOffset, long length);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter : TransferReaderWriterBase {
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private CountdownEvent toUploadChunksCountdownEvent;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasWork;
    public bool IsFinished { get; }
    public bool HasWork { get; }
    protected TransferJob TransferJob { get; }
    protected Uri DestUri { get; }
    protected RangeBasedWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    public virtual bool get_IsFinished();
    public virtual bool get_HasWork();
    protected TransferJob get_TransferJob();
    protected abstract virtual Uri get_DestUri();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<DoWorkInternalAsync>d__13")]
public virtual Task DoWorkInternalAsync();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<FetchAttributesAsync>d__15")]
private Task FetchAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<CreateAsync>d__16")]
private Task CreateAsync();
    private void InitUpload();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<UploadAsync>d__18")]
private Task UploadAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<UploadChunkAsync>d__19")]
private Task UploadChunkAsync(TransferData transferData);
    private void FinishChunk(TransferData transferData);
    private void SetCommit();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<CommitAsync>d__22")]
private Task CommitAsync();
    private void SetFinished();
    protected abstract virtual void CheckInputStreamLength(long streamLength);
    protected abstract virtual Task DoFetchAttributesAsync();
    protected abstract virtual void HandleFetchAttributesResult(Exception e);
    protected abstract virtual Task DoCreateAsync(long size);
    protected abstract virtual Task WriteRangeAsync(TransferData transferData);
    protected abstract virtual Task DoCommitAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<<FetchAttributesAsync>b__15_0>d")]
[CompilerGeneratedAttribute]
private Task <FetchAttributesAsync>b__15_0();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<<CreateAsync>b__16_0>d")]
[CompilerGeneratedAttribute]
private Task <CreateAsync>b__16_0();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.RangeBasedWriter/<<CommitAsync>b__22_0>d")]
[CompilerGeneratedAttribute]
private Task <CommitAsync>b__22_0();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController : TransferControllerBase {
    protected bool hasWork;
    protected State state;
    protected bool gotDestAttributes;
    [CompilerGeneratedAttribute]
private ISourceHandler <SourceHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDestHandler <DestHandler>k__BackingField;
    public bool HasWork { get; }
    protected ISourceHandler SourceHandler { get; protected set; }
    protected IDestHandler DestHandler { get; protected set; }
    protected ServiceSideSyncCopyController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    public virtual bool get_HasWork();
    [CompilerGeneratedAttribute]
protected ISourceHandler get_SourceHandler();
    [CompilerGeneratedAttribute]
protected void set_SourceHandler(ISourceHandler value);
    [CompilerGeneratedAttribute]
protected IDestHandler get_DestHandler();
    [CompilerGeneratedAttribute]
protected void set_DestHandler(IDestHandler value);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController/<DoWorkInternalAsync>d__15")]
protected virtual Task`1<bool> DoWorkInternalAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController/<FetchSourceAttributesAsync>d__16")]
protected Task FetchSourceAttributesAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController/<CheckAndCreateDestinationAsync>d__17")]
protected Task CheckAndCreateDestinationAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController/<CommonCommitAsync>d__18")]
protected Task CommonCommitAsync();
    protected abstract virtual void PostFetchSourceAttributes();
    protected abstract virtual Task GetDestinationAsync();
    protected abstract virtual Task DoPreCopyAsync();
    protected abstract virtual Task CopyChunkAsync();
    protected abstract virtual Task CommitAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyController/<<CheckAndCreateDestinationAsync>b__17_0>d")]
[CompilerGeneratedAttribute]
private Task <CheckAndCreateDestinationAsync>b__17_0(bool exist);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.AppendBlobDestHandler : BlobDestHandler {
    private CloudAppendBlob destAppendBlob;
    public AppendBlobDestHandler(AzureBlobLocation destLocation, TransferJob transferJob);
    protected virtual Task CreateDestinationAsync(long totalLength, AccessCondition accessCondition, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.BlobDestHandler : object {
    private TransferJob transferJob;
    private AzureBlobLocation destLocation;
    private CloudBlob destBlob;
    private TransferContext transferContext;
    protected AzureBlobLocation DestLocation { get; }
    protected TransferContext TransferContext { get; }
    public Uri Uri { get; }
    public BlobDestHandler(AzureBlobLocation destLocation, TransferJob transferJob);
    protected AzureBlobLocation get_DestLocation();
    protected TransferContext get_TransferContext();
    public sealed virtual Uri get_Uri();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.BlobDestHandler/<CheckAndCreateDestinationAsync>d__11")]
public sealed virtual Task`1<bool> CheckAndCreateDestinationAsync(bool isForceOverwrite, long totalLength, Func`2<bool, Task> checkOverwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.BlobDestHandler/<CommitAsync>d__12")]
public virtual Task CommitAsync(bool gotDestAttributes, Attributes sourceAttributes, Func`3<object, object, Task> setCustomAttributes, CancellationToken cancellationToken);
    protected abstract virtual Task CreateDestinationAsync(long totalLength, AccessCondition accessCondition, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.BlockBlobDestHandler : BlobDestHandler {
    public BlockBlobDestHandler(AzureBlobLocation destLocation, TransferJob transferJob);
    protected virtual Task CreateDestinationAsync(long length, AccessCondition accessCondition, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.FileDestHandler : object {
    private TransferJob transferJob;
    private AzureFileLocation destLocation;
    private CloudFile destFile;
    private TransferContext transferContext;
    public Uri Uri { get; }
    public FileDestHandler(AzureFileLocation destLocation, TransferJob transferJob);
    public sealed virtual Uri get_Uri();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.FileDestHandler/<CheckAndCreateDestinationAsync>d__7")]
public sealed virtual Task`1<bool> CheckAndCreateDestinationAsync(bool isForceOverwrite, long totalLength, Func`2<bool, Task> checkOverwrite, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.FileDestHandler/<CommitAsync>d__8")]
public virtual Task CommitAsync(bool gotDestAttributes, Attributes sourceAttributes, Func`3<object, object, Task> setCustomAttributes, CancellationToken cancellationToken);
    private Task CreateDestinationAsync(long totalLength, AccessCondition accessCondition, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.IDestHandler {
    public Uri Uri { get; }
    public abstract virtual Uri get_Uri();
    public abstract virtual Task`1<bool> CheckAndCreateDestinationAsync(bool isForceOverwrite, long totalLength, Func`2<bool, Task> checkOverwrite, CancellationToken cancellationToken);
    public abstract virtual Task CommitAsync(bool gotDestAttributes, Attributes sourceAttributes, Func`3<object, object, Task> setCustomAttributes, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopyDest.PageBlobDestHandler : BlobDestHandler {
    private CloudPageBlob destPageBlob;
    public PageBlobDestHandler(AzureBlobLocation destLocation, TransferJob transferJob);
    protected virtual Task CreateDestinationAsync(long totalLength, AccessCondition accessCondition, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.BlobSourceHandler : object {
    private AzureBlobLocation sourceLocation;
    private CloudBlob sourceBlob;
    private TransferContext transferContext;
    private Attributes sourceAttributes;
    private long totalLength;
    private TransferJob transferJob;
    protected AzureBlobLocation SourceLocation { get; }
    protected TransferContext TransferContext { get; }
    public string ETag { get; }
    public AccessCondition AccessCondition { get; }
    public Uri Uri { get; }
    public bool NeedToCheckAccessCondition { get; }
    public Attributes SourceAttributes { get; }
    public long TotalLength { get; }
    public BlobSourceHandler(AzureBlobLocation sourceBlobLocation, TransferJob transferJob);
    protected AzureBlobLocation get_SourceLocation();
    protected TransferContext get_TransferContext();
    public sealed virtual string get_ETag();
    public sealed virtual AccessCondition get_AccessCondition();
    public sealed virtual Uri get_Uri();
    public sealed virtual bool get_NeedToCheckAccessCondition();
    public sealed virtual Task DownloadRangeToStreamAsync(Stream stream, long startOffset, long length, AccessCondition accessCondition, bool useTransactionalMD5, OperationContext operationContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.BlobSourceHandler/<FetchAttributesAsync>d__20")]
public sealed virtual Task FetchAttributesAsync(CancellationToken cancellationToken);
    private static void HandleFetchSourceAttributesException(StorageException e);
    public sealed virtual Uri GetCopySourceUri();
    public sealed virtual Attributes get_SourceAttributes();
    public sealed virtual long get_TotalLength();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.FileSourceHandler : object {
    private AzureFileLocation sourceLocation;
    private TransferContext transferContext;
    private CloudFile sourceFile;
    private TransferJob transferJob;
    private Attributes sourceAttributes;
    private long totalLength;
    public string ETag { get; }
    public AccessCondition AccessCondition { get; }
    public Uri Uri { get; }
    public bool NeedToCheckAccessCondition { get; }
    public Attributes SourceAttributes { get; }
    public long TotalLength { get; }
    public FileSourceHandler(AzureFileLocation sourceLocation, TransferJob transferJob);
    public sealed virtual string get_ETag();
    public sealed virtual AccessCondition get_AccessCondition();
    public sealed virtual Uri get_Uri();
    public sealed virtual bool get_NeedToCheckAccessCondition();
    public sealed virtual Task DownloadRangeToStreamAsync(Stream stream, long startOffset, long length, AccessCondition accessCondition, bool useTransactionalMD5, OperationContext operationContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.FileSourceHandler/<FetchAttributesAsync>d__16")]
public sealed virtual Task FetchAttributesAsync(CancellationToken cancellationToken);
    private static void HandleFetchSourceAttributesException(StorageException e);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.FileSourceHandler/<GetCopyRangesAsync>d__18")]
public sealed virtual Task`1<List`1<Range>> GetCopyRangesAsync(long startOffset, long length, CancellationToken cancellationToken);
    public sealed virtual Uri GetCopySourceUri();
    public sealed virtual Attributes get_SourceAttributes();
    public sealed virtual long get_TotalLength();
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.IRangeBasedSourceHandler {
    public abstract virtual Task`1<List`1<Range>> GetCopyRangesAsync(long startOffset, long length, CancellationToken cancellationToken);
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.ISourceHandler {
    public Uri Uri { get; }
    public Attributes SourceAttributes { get; }
    public long TotalLength { get; }
    public string ETag { get; }
    public AccessCondition AccessCondition { get; }
    public bool NeedToCheckAccessCondition { get; }
    public abstract virtual Task FetchAttributesAsync(CancellationToken cancellationToken);
    public abstract virtual Task DownloadRangeToStreamAsync(Stream stream, long startOffset, long length, AccessCondition accessCondition, bool useTransactionalMD5, OperationContext operationContext, CancellationToken cancellationToken);
    public abstract virtual Uri GetCopySourceUri();
    public abstract virtual Uri get_Uri();
    public abstract virtual Attributes get_SourceAttributes();
    public abstract virtual long get_TotalLength();
    public abstract virtual string get_ETag();
    public abstract virtual AccessCondition get_AccessCondition();
    public abstract virtual bool get_NeedToCheckAccessCondition();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.PageBlobSourceHandler : BlobSourceHandler {
    private CloudPageBlob pageBlob;
    public PageBlobSourceHandler(AzureBlobLocation sourceBlobLocation, TransferJob transferJob);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.ServiceSideSyncCopySource.PageBlobSourceHandler/<GetCopyRangesAsync>d__2")]
public sealed virtual Task`1<List`1<Range>> GetCopyRangesAsync(long startOffset, long length, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedReader : TransferReaderWriterBase {
    private Stream inputStream;
    private bool ownsStream;
    private TransferJob transferJob;
    private Queue`1<long> lastTransferWindow;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) workToken;
    private long readLength;
    private long readCompleted;
    private int setCompletionDone;
    private MD5HashStream md5HashStream;
    private string filePath;
    public bool IsFinished { get; }
    public bool HasWork { get; }
    public StreamedReader(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    public virtual bool get_IsFinished();
    public virtual bool get_HasWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedReader/<DoWorkInternalAsync>d__17")]
public virtual Task DoWorkInternalAsync();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedReader/<OpenInputStreamAsync>d__19")]
private Task OpenInputStreamAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedReader/<ReadStreamAsync>d__20")]
private Task ReadStreamAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedReader/<ReadChunkAsync>d__21")]
private Task ReadChunkAsync(ReadDataState asyncState);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private void ReadingDataHandler(ReadDataState asyncState, bool endofStream);
    private void SetHasWork();
    private void SetChunkFinish();
    private void CloseOwnStream();
    [CompilerGeneratedAttribute]
private void <OpenInputStreamAsync>b__19_0();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedWriter : TransferReaderWriterBase {
    private long expectOffset;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasWork;
    private MD5HashStream md5HashStream;
    private Stream outputStream;
    private bool ownsStream;
    private string filePath;
    private string longFilePath;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isStateSwitchedInternal;
    private TransferJob TransferJob { get; }
    public bool HasWork { get; }
    public bool IsFinished { get; }
    public StreamedWriter(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    private TransferJob get_TransferJob();
    public virtual bool get_HasWork();
    public virtual bool get_IsFinished();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedWriter/<DoWorkInternalAsync>d__17")]
public virtual Task DoWorkInternalAsync();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedWriter/<HandleOutputStreamAsync>d__19")]
private Task HandleOutputStreamAsync();
    private Task CalculateMD5Async();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedWriter/<WriteChunkDataAsync>d__21")]
private Task WriteChunkDataAsync();
    private void SetHasWorkOrFinished();
    private void CloseOwnedOutputStream();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.StreamedWriter/<<HandleOutputStreamAsync>b__19_0>d")]
[CompilerGeneratedAttribute]
private Task <HandleOutputStreamAsync>b__19_0();
    [CompilerGeneratedAttribute]
private void <CalculateMD5Async>b__20_0();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferControllers.SyncTransferController : TransferControllerBase {
    private TransferReaderWriterBase reader;
    private TransferReaderWriterBase writer;
    [CompilerGeneratedAttribute]
private SharedTransferData <SharedTransferData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorOccurred>k__BackingField;
    public bool hasWork;
    public SharedTransferData SharedTransferData { get; private set; }
    public bool ErrorOccurred { get; private set; }
    public bool HasWork { get; }
    public SyncTransferController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    [CompilerGeneratedAttribute]
public SharedTransferData get_SharedTransferData();
    [CompilerGeneratedAttribute]
private void set_SharedTransferData(SharedTransferData value);
    [CompilerGeneratedAttribute]
public bool get_ErrorOccurred();
    [CompilerGeneratedAttribute]
private void set_ErrorOccurred(bool value);
    public virtual bool get_HasWork();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.SyncTransferController/<DoWorkInternalAsync>d__14")]
protected virtual Task`1<bool> DoWorkInternalAsync();
    protected virtual void SetErrorState(Exception ex);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private TransferReaderWriterBase GetReader(TransferLocation sourceLocation);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private TransferReaderWriterBase GetWriter(TransferLocation destLocation);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(object sender, EventArgs args);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferControllerBase : object {
    private int activeTasks;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isFinished;
    private object lockOnFinished;
    private int notifiedFinish;
    private object cancelLock;
    private CancellationTokenSource cancellationTokenSource;
    private CancellationTokenRegistration transferSchedulerCancellationTokenRegistration;
    private CancellationTokenRegistration userCancellationTokenRegistration;
    private Exception transferException;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <TaskCompletionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferJob <TransferJob>k__BackingField;
    public TransferContext TransferContext { get; }
    public bool IsForceOverwrite { get; }
    public bool HasWork { get; }
    public bool IsFinished { get; }
    public TaskCompletionSource`1<object> TaskCompletionSource { get; public set; }
    protected TransferScheduler Scheduler { get; private set; }
    protected TransferJob TransferJob { get; private set; }
    protected CancellationToken CancellationToken { get; }
    protected TransferControllerBase(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken userCancellationToken);
    protected virtual override void Finalize();
    public TransferContext get_TransferContext();
    public bool get_IsForceOverwrite();
    public abstract virtual bool get_HasWork();
    public sealed virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<object> get_TaskCompletionSource();
    [CompilerGeneratedAttribute]
public void set_TaskCompletionSource(TaskCompletionSource`1<object> value);
    [CompilerGeneratedAttribute]
protected TransferScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private void set_Scheduler(TransferScheduler value);
    [CompilerGeneratedAttribute]
protected TransferJob get_TransferJob();
    [CompilerGeneratedAttribute]
private void set_TransferJob(TransferJob value);
    protected CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferControllerBase/<CheckShouldTransfer>d__33")]
protected Task`1<bool> CheckShouldTransfer();
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferControllerBase/<DoWorkAsync>d__34")]
public sealed virtual Task`1<bool> DoWorkAsync();
    public sealed virtual void CancelWork();
    public sealed virtual void Dispose();
    public void CheckCancellation();
    public void UpdateProgress(Action updateAction);
    public void UpdateProgressAddBytesTransferred(long bytesTransferredToAdd);
    public void StartCallbackHandler();
    public void FinishCallbackHandler(Exception exception);
    protected abstract virtual Task`1<bool> DoWorkInternalAsync();
    protected void PreWork();
    protected bool PostWork();
    protected bool SetFinishedAndPostWork();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void SetErrorState(Exception ex);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferControllerBase/<CheckOverwriteAsync>d__48")]
public Task CheckOverwriteAsync(bool exist, object source, object dest);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferControllerBase/<SetCustomAttributesAsync>d__49")]
public Task SetCustomAttributesAsync(object source, object dest);
    [CompilerGeneratedAttribute]
private void <CancelWork>b__35_0();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferControllers.TransferReaderWriterBase : object {
    [CompilerGeneratedAttribute]
private bool <PreProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSmallFileOptimization>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private SyncTransferController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public bool PreProcessed { get; protected set; }
    public bool HasWork { get; }
    public bool IsFinished { get; }
    internal bool EnableSmallFileOptimization { get; internal set; }
    protected bool EnableOneChunkFileOptimization { get; }
    protected TransferScheduler Scheduler { get; private set; }
    protected SyncTransferController Controller { get; private set; }
    protected SharedTransferData SharedTransferData { get; }
    protected CancellationToken CancellationToken { get; private set; }
    protected TransferReaderWriterBase(TransferScheduler scheduler, SyncTransferController controller, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual bool get_PreProcessed();
    [CompilerGeneratedAttribute]
protected virtual void set_PreProcessed(bool value);
    public abstract virtual bool get_HasWork();
    public abstract virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
internal bool get_EnableSmallFileOptimization();
    [CompilerGeneratedAttribute]
internal void set_EnableSmallFileOptimization(bool value);
    protected bool get_EnableOneChunkFileOptimization();
    [CompilerGeneratedAttribute]
protected TransferScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private void set_Scheduler(TransferScheduler value);
    [CompilerGeneratedAttribute]
protected SyncTransferController get_Controller();
    [CompilerGeneratedAttribute]
private void set_Controller(SyncTransferController value);
    protected SharedTransferData get_SharedTransferData();
    [CompilerGeneratedAttribute]
protected CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
private void set_CancellationToken(CancellationToken value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void NotifyStarting();
    protected void NotifyFinished(Exception ex);
    public abstract virtual Task DoWorkInternalAsync();
    public TransferData GetFirstAvailable();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferData : TransferDataState {
    private MemoryManager memoryManager;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public Stream Stream { get; public set; }
    public TransferData(MemoryManager memoryManager);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferDataState : object {
    [CompilerGeneratedAttribute]
private Byte[][] <MemoryBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BytesRead>k__BackingField;
    public Byte[][] MemoryBuffer { get; public set; }
    public long StartOffset { get; public set; }
    public int Length { get; public set; }
    public int BytesRead { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[][] get_MemoryBuffer();
    [CompilerGeneratedAttribute]
public void set_MemoryBuffer(Byte[][] value);
    [CompilerGeneratedAttribute]
public long get_StartOffset();
    [CompilerGeneratedAttribute]
public void set_StartOffset(long value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_BytesRead();
    [CompilerGeneratedAttribute]
public void set_BytesRead(int value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferDownloadBuffer : object {
    private int finishedLength;
    private int processed;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <MemoryBuffer>k__BackingField;
    public int Length { get; private set; }
    public long StartOffset { get; private set; }
    public Byte[][] MemoryBuffer { get; private set; }
    public bool Finished { get; }
    public TransferDownloadBuffer(long startOffset, int expectedLength, Byte[][] buffer);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
public long get_StartOffset();
    [CompilerGeneratedAttribute]
private void set_StartOffset(long value);
    [CompilerGeneratedAttribute]
public Byte[][] get_MemoryBuffer();
    [CompilerGeneratedAttribute]
private void set_MemoryBuffer(Byte[][] value);
    public bool get_Finished();
    public bool MarkAsProcessed();
    public void ReadFinish(int length);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferDownloadStream : Stream {
    private TransferDownloadBuffer firstBuffer;
    private Stream firstStream;
    private int firstOffset;
    private TransferDownloadBuffer secondBuffer;
    private Stream secondStream;
    private int secondOffset;
    private bool onSecondStream;
    private MemoryManager memoryManager;
    [CompilerGeneratedAttribute]
private bool <ReserveBuffer>k__BackingField;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool ReserveBuffer { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public TransferDownloadStream(MemoryManager memoryManager, TransferDownloadBuffer buffer, int offset, int count);
    public TransferDownloadStream(MemoryManager memoryManager, TransferDownloadBuffer firstBuffer, int firstOffset, int firstCount, TransferDownloadBuffer secondBuffer, int secondOffset, int secondCount);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public bool get_ReserveBuffer();
    [CompilerGeneratedAttribute]
public void set_ReserveBuffer(bool value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void SetAllZero();
    private static void SetAllZero(Byte[][] buffers, int offset, int length);
    public void FinishWrite();
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferDownloadStream/<GetBuffers>d__33")]
public IEnumerable`1<TransferDownloadBuffer> GetBuffers();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobEntry : TransferEntry {
    [CompilerGeneratedAttribute]
private CloudBlob <Blob>k__BackingField;
    public CloudBlob Blob { get; private set; }
    public bool IsDirectory { get; }
    public AzureBlobEntry(string relativePath, CloudBlob cloudBlob, AzureBlobListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public CloudBlob get_Blob();
    [CompilerGeneratedAttribute]
private void set_Blob(CloudBlob value);
    public virtual string ToString();
    public virtual bool get_IsDirectory();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobEnumerator : TransferEnumeratorBase {
    private static int MaxBlobNameLength;
    internal static int ListBlobsSegmentSize;
    private AzureBlobDirectoryLocation location;
    private AzureBlobListContinuationToken listContinuationToken;
    [CompilerGeneratedAttribute]
private bool <IncludeSnapshots>k__BackingField;
    public ListContinuationToken EnumerateContinuationToken { get; public set; }
    public bool IncludeSnapshots { get; public set; }
    public AzureBlobEnumerator(AzureBlobDirectoryLocation location);
    public sealed virtual ListContinuationToken get_EnumerateContinuationToken();
    public sealed virtual void set_EnumerateContinuationToken(ListContinuationToken value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSnapshots();
    [CompilerGeneratedAttribute]
public void set_IncludeSnapshots(bool value);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobEnumerator/<EnumerateLocation>d__12")]
public sealed virtual IEnumerable`1<TransferEntry> EnumerateLocation(CancellationToken cancellationToken);
    private static bool IsSnapshotTimeEarlier(Nullable`1<DateTimeOffset> first, Nullable`1<DateTimeOffset> second);
    private int GetMaxFileNameLength();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobListContinuationToken : ListContinuationToken {
    private static string BlobContinuationTokenName;
    private static string BlobNameName;
    private static string HasSnapshotName;
    private static string SnapshotTimeName;
    [CompilerGeneratedAttribute]
private BlobContinuationToken <BlobContinuationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlobName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <SnapshotTime>k__BackingField;
    public BlobContinuationToken BlobContinuationToken { get; private set; }
    public string BlobName { get; private set; }
    public Nullable`1<DateTimeOffset> SnapshotTime { get; private set; }
    public AzureBlobListContinuationToken(BlobContinuationToken blobContinuationToken, string blobName, Nullable`1<DateTimeOffset> snapshotTime);
    private AzureBlobListContinuationToken(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public BlobContinuationToken get_BlobContinuationToken();
    [CompilerGeneratedAttribute]
private void set_BlobContinuationToken(BlobContinuationToken value);
    [CompilerGeneratedAttribute]
public string get_BlobName();
    [CompilerGeneratedAttribute]
private void set_BlobName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_SnapshotTime();
    [CompilerGeneratedAttribute]
private void set_SnapshotTime(Nullable`1<DateTimeOffset> value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobToAzureBlobNameResolver : object {
    public sealed virtual string ResolveName(TransferEntry sourceEntry);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureBlobToAzureFileNameResolver : AzureNameResolver {
    private bool defaultDelimiter;
    private static Char[] invalidPathChars;
    protected string DirSeparator { get; }
    protected Char[] InvalidPathChars { get; }
    public AzureBlobToAzureFileNameResolver(Nullable`1<char> delimiter);
    private static AzureBlobToAzureFileNameResolver();
    protected virtual string get_DirSeparator();
    protected virtual Char[] get_InvalidPathChars();
    protected virtual string CombinePath(string folder, string name);
    protected virtual string TranslateDelimiters(string source);
    protected virtual string EscapeInvalidCharacters(string fileName);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileDirectoryEntry : TransferEntry {
    [CompilerGeneratedAttribute]
private CloudFileDirectory <FileDirectory>k__BackingField;
    public CloudFileDirectory FileDirectory { get; private set; }
    public bool IsDirectory { get; }
    public AzureFileDirectoryEntry(string relativePath, CloudFileDirectory cloudFileDirectory, AzureFileListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public CloudFileDirectory get_FileDirectory();
    [CompilerGeneratedAttribute]
private void set_FileDirectory(CloudFileDirectory value);
    public virtual bool get_IsDirectory();
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileEntry : TransferEntry {
    [CompilerGeneratedAttribute]
private CloudFile <File>k__BackingField;
    public CloudFile File { get; private set; }
    public bool IsDirectory { get; }
    public AzureFileEntry(string relativePath, CloudFile cloudFile, AzureFileListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public CloudFile get_File();
    [CompilerGeneratedAttribute]
private void set_File(CloudFile value);
    public virtual bool get_IsDirectory();
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileHierarchyEnumerator : TransferEnumeratorBase {
    private static int ListFilesSegmentSize;
    private static int MaxDirectoryAndFileNameLength;
    private static int MaxPathLength;
    private static char UriDelimiter;
    private AzureFileDirectoryLocation location;
    private CloudFileDirectory baseDirectory;
    private AzureFileListContinuationToken listContinuationToken;
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
public ListContinuationToken EnumerateContinuationToken { get; public set; }
    public AzureFileHierarchyEnumerator(AzureFileDirectoryLocation location, CloudFileDirectory baseDirectory);
    public sealed virtual ListContinuationToken get_EnumerateContinuationToken();
    public sealed virtual void set_EnumerateContinuationToken(ListContinuationToken value);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileHierarchyEnumerator/<EnumerateLocation>d__11")]
public sealed virtual IEnumerable`1<TransferEntry> EnumerateLocation(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileHierarchyEnumerator/<EnumerateLocationNonRecursive>d__12")]
private IEnumerable`1<TransferEntry> EnumerateLocationNonRecursive(string fileName, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileHierarchyEnumerator/<EnumerateLocationRecursive>d__13")]
private IEnumerable`1<TransferEntry> EnumerateLocationRecursive(CancellationToken cancellationToken);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileListContinuationToken : ListContinuationToken {
    private static string FilePathName;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; private set; }
    public AzureFileListContinuationToken(string filePath);
    private AzureFileListContinuationToken(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureFileToAzureNameResolver : object {
    public sealed virtual string ResolveName(TransferEntry sourceEntry);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureNameResolver : object {
    public static char DefaultDelimiter;
    private static HashSet`1<char> regexSpecialCharacters;
    private static string translateDelimitersRegexFormat;
    private Regex translateDelimitersRegex;
    private char delimiter;
    protected string DirSeparator { get; }
    protected Char[] InvalidPathChars { get; }
    public AzureNameResolver(Nullable`1<char> delimiter);
    private static AzureNameResolver();
    protected abstract virtual string get_DirSeparator();
    protected abstract virtual Char[] get_InvalidPathChars();
    public sealed virtual string ResolveName(TransferEntry sourceEntry);
    protected abstract virtual string CombinePath(string folder, string name);
    protected virtual string TranslateDelimiters(string source);
    protected virtual string EscapeInvalidCharacters(string fileName);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.AzureToFileNameResolver : AzureNameResolver {
    private static Char[] invalidFileNameChars;
    private static Char[] invalidPathChars;
    protected string DirSeparator { get; }
    protected Char[] InvalidPathChars { get; }
    public AzureToFileNameResolver(Nullable`1<char> delimiter);
    private static AzureToFileNameResolver();
    protected virtual string get_DirSeparator();
    protected virtual Char[] get_InvalidPathChars();
    protected virtual string CombinePath(string folder, string name);
    private static Char[] GetInvalidPathChars();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.DirectoryEntry : TransferEntry {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    public string FullPath { get; private set; }
    public bool IsDirectory { get; }
    public DirectoryEntry(string relativePath, string fullPath, FileListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
private void set_FullPath(string value);
    public virtual bool get_IsDirectory();
    public virtual string ToString();
}
internal static class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.EnumerateDirectoryHelper : object {
    public static IEnumerable`1<LocalEnumerateItem> EnumerateAllEntriesInDirectory(string path, string searchPattern, string fromFilePath, SearchOption searchOption, bool followsymlink, bool isBaseDirectory, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalEnumerateItem> EnumerateInDirectory(string path, string searchPattern, string fromFilePath, SearchOption searchOption, bool followsymlink, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.EnumerateDirectoryHelper/<InternalEnumerateInDirectory>d__4")]
private static IEnumerable`1<LocalEnumerateItem> InternalEnumerateInDirectory(string directoryName, string filePattern, string fromFilePath, SearchOption searchOption, bool followsymlink, bool returnDirectories, CancellationToken cancellationToken);
    private static EnumerateFileEntryInfo GetFileEntryInfo(string filePath);
    private static bool ToEnumerateTheSubDir(string dirPath, EnumerateFileEntryInfo fileEntryInfo, bool followSymlink);
    private static string AppendDirectorySeparator(string dir);
    private static void CheckSearchPattern(string searchPattern);
    private static void CheckPathDiscoveryPermission(string dir);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.ErrorEntry : TransferEntry {
    public TransferException Exception;
    public bool IsDirectory { get; }
    public ErrorEntry(TransferException ex);
    public virtual bool get_IsDirectory();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileEntry : TransferEntry {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    public string FullPath { get; private set; }
    public bool IsDirectory { get; }
    public FileEntry(string relativePath, string fullPath, FileListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
private void set_FullPath(string value);
    public virtual bool get_IsDirectory();
    public virtual string ToString();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileEnumerator : TransferEnumeratorBase {
    private static string DefaultFilePattern;
    private DirectoryLocation location;
    private FileListContinuationToken listContinuationToken;
    private bool followSymlink;
    public ListContinuationToken EnumerateContinuationToken { get; public set; }
    public FileEnumerator(DirectoryLocation location, bool followSymlink);
    public sealed virtual ListContinuationToken get_EnumerateContinuationToken();
    public sealed virtual void set_EnumerateContinuationToken(ListContinuationToken value);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileEnumerator/<EnumerateLocation>d__8")]
public sealed virtual IEnumerable`1<TransferEntry> EnumerateLocation(CancellationToken cancellationToken);
    private static string AppendDirectorySeparator(string dir);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileHierarchyEnumerator : TransferEnumeratorBase {
    private static string DefaultFilePattern;
    private DirectoryLocation location;
    private FileListContinuationToken listContinuationToken;
    private bool followSymlink;
    private string baseDirectory;
    public ListContinuationToken EnumerateContinuationToken { get; public set; }
    public FileHierarchyEnumerator(DirectoryLocation location, string baseDirectory, bool followSymlink);
    public sealed virtual ListContinuationToken get_EnumerateContinuationToken();
    public sealed virtual void set_EnumerateContinuationToken(ListContinuationToken value);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileHierarchyEnumerator/<EnumerateLocation>d__9")]
public sealed virtual IEnumerable`1<TransferEntry> EnumerateLocation(CancellationToken cancellationToken);
    private static string AppendDirectorySeparator(string dir);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileListContinuationToken : ListContinuationToken {
    private static string FilePathName;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; private set; }
    public FileListContinuationToken(string filePath);
    private FileListContinuationToken(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileToAzureBlobNameResolver : object {
    public sealed virtual string ResolveName(TransferEntry sourceEntry);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.FileToAzureFileNameResolver : object {
    private static Char[] invalidPathChars;
    private static FileToAzureFileNameResolver();
    protected static string EscapeInvalidCharacters(string fileName);
    public sealed virtual string ResolveName(TransferEntry sourceEntry);
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferEnumerators.INameResolver {
    public abstract virtual string ResolveName(TransferEntry sourceEntry);
}
internal interface Microsoft.Azure.Storage.DataMovement.TransferEnumerators.ITransferEnumerator {
    public ListContinuationToken EnumerateContinuationToken { get; public set; }
    public abstract virtual ListContinuationToken get_EnumerateContinuationToken();
    public abstract virtual void set_EnumerateContinuationToken(ListContinuationToken value);
    public abstract virtual IEnumerable`1<TransferEntry> EnumerateLocation(CancellationToken cancellationToken);
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.ListContinuationToken : object {
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.SerializableListContinuationToken : JournalItem {
    private static string ListContinuationTokenTypeName;
    private static string ListContinuationTokenName;
    private static string TokenTypeFile;
    private static string TokenTypeAzureBlob;
    private static string TokenTypeAzureFile;
    [CompilerGeneratedAttribute]
private ListContinuationToken <ListContinuationToken>k__BackingField;
    public ListContinuationToken ListContinuationToken { get; private set; }
    public SerializableListContinuationToken(ListContinuationToken listContinuationToken);
    private SerializableListContinuationToken(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ListContinuationToken get_ListContinuationToken();
    [CompilerGeneratedAttribute]
private void set_ListContinuationToken(ListContinuationToken value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.TaskQueue`1 : object {
    private BlockingCollection`1<Task`1<T>> queue;
    private bool disposedValue;
    public TaskQueue`1(int capacity);
    public void EnqueueJob(Func`1<Task`1<T>> func);
    public T DequeueResult();
    public void CompleteAdding();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.TransferEntry : object {
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ListContinuationToken <ContinuationToken>k__BackingField;
    public string RelativePath { get; private set; }
    public ListContinuationToken ContinuationToken { get; private set; }
    public bool IsDirectory { get; }
    public TransferEntry(string relativePath, ListContinuationToken continuationToken);
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
private void set_RelativePath(string value);
    [CompilerGeneratedAttribute]
public ListContinuationToken get_ContinuationToken();
    [CompilerGeneratedAttribute]
private void set_ContinuationToken(ListContinuationToken value);
    public abstract virtual bool get_IsDirectory();
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferEnumerators.TransferEnumeratorBase : object {
    [CompilerGeneratedAttribute]
private string <SearchPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    public string SearchPattern { get; public set; }
    public bool Recursive { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SearchPattern();
    [CompilerGeneratedAttribute]
public void set_SearchPattern(string value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
}
[SuppressMessageAttribute("Microsoft.Design", "CA1027:MarkEnumsWithFlags")]
public enum Microsoft.Azure.Storage.DataMovement.TransferErrorCode : Enum {
    public int value__;
    public static TransferErrorCode None;
    public static TransferErrorCode OpenFileFailed;
    public static TransferErrorCode UploadSourceFileSizeTooLarge;
    public static TransferErrorCode UploadBlobSourceFileSizeInvalid;
    public static TransferErrorCode OperationCanceled;
    public static TransferErrorCode LocalToLocalTransfersUnsupported;
    public static TransferErrorCode AsyncCopyFailed;
    public static TransferErrorCode SameSourceAndDestination;
    public static TransferErrorCode MismatchCopyId;
    public static TransferErrorCode FailToRetrieveCopyStateForObject;
    public static TransferErrorCode FailToAllocateMemory;
    public static TransferErrorCode FailToGetSourceLastWriteTime;
    public static TransferErrorCode NotOverwriteExistingDestination;
    public static TransferErrorCode TransferAlreadyExists;
    public static TransferErrorCode FailToEnumerateDirectory;
    public static TransferErrorCode FailToVadlidateDestination;
    public static TransferErrorCode SubTransferFails;
    public static TransferErrorCode UploadFileSourceFileSizeInvalid;
    public static TransferErrorCode FailedToCreateDirectory;
    public static TransferErrorCode UnsupportedDummyTransfer;
    public static TransferErrorCode FailedCheckingShouldTransfer;
    public static TransferErrorCode Unknown;
}
public class Microsoft.Azure.Storage.DataMovement.TransferEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public object Source { get; private set; }
    public object Destination { get; private set; }
    public DateTime StartTime { get; internal set; }
    public DateTime EndTime { get; internal set; }
    public Exception Exception { get; internal set; }
    public TransferEventArgs(object source, object destination);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(object value);
    [CompilerGeneratedAttribute]
public object get_Destination();
    [CompilerGeneratedAttribute]
private void set_Destination(object value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
internal void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
internal void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
internal void set_Exception(Exception value);
}
public class Microsoft.Azure.Storage.DataMovement.TransferException : Exception {
    private static int ExceptionVersion;
    private static string VersionFieldName;
    private static string ErrorCodeFieldName;
    private TransferErrorCode errorCode;
    public TransferErrorCode ErrorCode { get; }
    public TransferException(string message);
    public TransferException(string message, Exception ex);
    public TransferException(TransferErrorCode errorCode);
    public TransferException(TransferErrorCode errorCode, string message);
    public TransferException(TransferErrorCode errorCode, string message, Exception innerException);
    protected TransferException(SerializationInfo info, StreamingContext context);
    public TransferErrorCode get_ErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Azure.Storage.DataMovement.TransferJob : object {
    private static string SourceName;
    private static string DestName;
    private static string CheckedOverwriteName;
    private static string OverwriteName;
    private static string CopyIdName;
    private static string CheckpointName;
    private static string StatusName;
    [CompilerGeneratedAttribute]
private ReaderWriterLockSlim <ProgressUpdateLock>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyId>k__BackingField;
    [CompilerGeneratedAttribute]
private TransferJobStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleObjectCheckpoint <CheckPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleObjectTransfer <Transfer>k__BackingField;
    public ReaderWriterLockSlim ProgressUpdateLock { get; public set; }
    public TransferLocation Source { get; }
    public TransferLocation Destination { get; }
    public Nullable`1<bool> Overwrite { get; public set; }
    public string CopyId { get; public set; }
    public TransferJobStatus Status { get; public set; }
    public SingleObjectCheckpoint CheckPoint { get; public set; }
    public SingleObjectTransfer Transfer { get; public set; }
    public TransferJob(SingleObjectTransfer transfer);
    protected TransferJob(SerializationInfo info, StreamingContext context);
    private TransferJob(TransferJob other);
    [CompilerGeneratedAttribute]
public ReaderWriterLockSlim get_ProgressUpdateLock();
    [CompilerGeneratedAttribute]
public void set_ProgressUpdateLock(ReaderWriterLockSlim value);
    public TransferLocation get_Source();
    public TransferLocation get_Destination();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_CopyId();
    [CompilerGeneratedAttribute]
public void set_CopyId(string value);
    [CompilerGeneratedAttribute]
public TransferJobStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(TransferJobStatus value);
    [CompilerGeneratedAttribute]
public SingleObjectCheckpoint get_CheckPoint();
    [CompilerGeneratedAttribute]
public void set_CheckPoint(SingleObjectCheckpoint value);
    [CompilerGeneratedAttribute]
public SingleObjectTransfer get_Transfer();
    [CompilerGeneratedAttribute]
public void set_Transfer(SingleObjectTransfer value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public TransferJob Copy();
}
internal enum Microsoft.Azure.Storage.DataMovement.TransferJobStatus : Enum {
    public int value__;
    public static TransferJobStatus NotStarted;
    public static TransferJobStatus SkippedDueToShouldNotTransfer;
    public static TransferJobStatus Skipped;
    public static TransferJobStatus Transfer;
    public static TransferJobStatus Monitor;
    public static TransferJobStatus Finished;
    public static TransferJobStatus Failed;
}
internal abstract class Microsoft.Azure.Storage.DataMovement.TransferLocation : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsInstanceInfoFetched>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public Nullable`1<bool> IsInstanceInfoFetched { get; public set; }
    public abstract virtual TransferLocationType get_Type();
    public abstract virtual object get_Instance();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsInstanceInfoFetched();
    [CompilerGeneratedAttribute]
public void set_IsInstanceInfoFetched(Nullable`1<bool> value);
    public abstract virtual void Validate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum Microsoft.Azure.Storage.DataMovement.TransferLocationType : Enum {
    public int value__;
    public static TransferLocationType FilePath;
    public static TransferLocationType Stream;
    public static TransferLocationType AzureBlob;
    public static TransferLocationType AzureFile;
    public static TransferLocationType SourceUri;
    public static TransferLocationType LocalDirectory;
    public static TransferLocationType AzureBlobDirectory;
    public static TransferLocationType AzureFileDirectory;
}
public static class Microsoft.Azure.Storage.DataMovement.TransferManager : object {
    private static TransferConfigurations configurations;
    private static TransferScheduler scheduler;
    private static ConcurrentDictionary`2<Tuple`2<TransferLocation, TransferLocation>, Transfer> allTransfers;
    public static TransferConfigurations Configurations { get; }
    private static TransferManager();
    public static TransferConfigurations get_Configurations();
    public static Task UploadAsync(string sourcePath, CloudBlob destBlob);
    public static Task UploadAsync(string sourcePath, CloudBlob destBlob, UploadOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task UploadAsync(string sourcePath, CloudBlob destBlob, UploadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task UploadAsync(Stream sourceStream, CloudBlob destBlob);
    public static Task UploadAsync(Stream sourceStream, CloudBlob destBlob, UploadOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task UploadAsync(Stream sourceStream, CloudBlob destBlob, UploadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task UploadAsync(string sourcePath, CloudFile destFile);
    public static Task UploadAsync(string sourcePath, CloudFile destFile, UploadOptions options, SingleTransferContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<UploadAsync>d__13")]
[SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task UploadAsync(string sourcePath, CloudFile destFile, UploadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task UploadAsync(Stream sourceStream, CloudFile destFile);
    public static Task UploadAsync(Stream sourceStream, CloudFile destFile, UploadOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task UploadAsync(Stream sourceStream, CloudFile destFile, UploadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task DownloadAsync(CloudBlob sourceBlob, string destPath);
    public static Task DownloadAsync(CloudBlob sourceBlob, string destPath, DownloadOptions options, SingleTransferContext context);
    public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudBlobDirectory destBlobDir);
    public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudBlobDirectory destBlobDir, UploadDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudBlobDirectory destBlobDir, UploadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudFileDirectory destFileDir);
    public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudFileDirectory destFileDir, UploadDirectoryOptions options, DirectoryTransferContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<UploadDirectoryAsync>d__24")]
public static Task`1<TransferStatus> UploadDirectoryAsync(string sourcePath, CloudFileDirectory destFileDir, UploadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task DownloadAsync(CloudBlob sourceBlob, string destPath, DownloadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task DownloadAsync(CloudBlob sourceBlob, Stream destStream);
    public static Task DownloadAsync(CloudBlob sourceBlob, Stream destStream, DownloadOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task DownloadAsync(CloudBlob sourceBlob, Stream destStream, DownloadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task DownloadAsync(CloudFile sourceFile, string destPath);
    public static Task DownloadAsync(CloudFile sourceFile, string destPath, DownloadOptions options, SingleTransferContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<DownloadAsync>d__31")]
[SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task DownloadAsync(CloudFile sourceFile, string destPath, DownloadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task DownloadAsync(CloudFile sourceFile, Stream destStream);
    public static Task DownloadAsync(CloudFile sourceFile, Stream destStream, DownloadOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task DownloadAsync(CloudFile sourceFile, Stream destStream, DownloadOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> DownloadDirectoryAsync(CloudBlobDirectory sourceBlobDir, string destPath, DownloadDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> DownloadDirectoryAsync(CloudBlobDirectory sourceBlobDir, string destPath, DownloadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> DownloadDirectoryAsync(CloudFileDirectory sourceFileDir, string destPath, DownloadDirectoryOptions options, DirectoryTransferContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<DownloadDirectoryAsync>d__38")]
public static Task`1<TransferStatus> DownloadDirectoryAsync(CloudFileDirectory sourceFileDir, string destPath, DownloadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, bool isServiceCopy);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
[ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, CopyMethod copyMethod);
    public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudBlob destBlob, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, bool isServiceCopy);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, CopyMethod copyMethod);
    public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(CloudBlob sourceBlob, CloudFile destFile, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, bool isServiceCopy);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
[ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, CopyMethod copyMethod);
    public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(CloudFile sourceFile, CloudBlob destBlob, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, bool isServiceCopy);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
[ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, CopyMethod copyMethod);
    public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(CloudFile sourceFile, CloudFile destFile, CopyMethod copyMethod, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(Uri sourceUri, CloudBlob destBlob, bool isServiceCopy);
    public static Task CopyAsync(Uri sourceUri, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(Uri sourceUri, CloudBlob destBlob, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    public static Task CopyAsync(Uri sourceUri, CloudFile destFile, bool isServiceCopy);
    public static Task CopyAsync(Uri sourceUri, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context);
    [SuppressMessageAttribute("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
public static Task CopyAsync(Uri sourceUri, CloudFile destFile, bool isServiceCopy, CopyOptions options, SingleTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudBlobDirectory destBlobDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudBlobDirectory destBlobDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudBlobDirectory destBlobDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudBlobDirectory destBlobDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudFileDirectory destFileDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudFileDirectory destFileDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudFileDirectory destFileDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudBlobDirectory sourceBlobDir, CloudFileDirectory destFileDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudFileDirectory destFileDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudFileDirectory destFileDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudFileDirectory destFileDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudFileDirectory destFileDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudBlobDirectory destBlobDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context);
    [ObsoleteAttribute("Replaced by overload that takes CopyMethod", "False")]
public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudBlobDirectory destBlobDir, bool isServiceCopy, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudBlobDirectory destBlobDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context);
    public static Task`1<TransferStatus> CopyDirectoryAsync(CloudFileDirectory sourceFileDir, CloudBlobDirectory destBlobDir, CopyMethod copyMethod, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    internal static void SetMemoryLimitation(long memoryLimitation);
    private static Task UploadInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, UploadOptions uploadOptions, TransferContext context, CancellationToken cancellationToken);
    private static Task DownloadInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, DownloadOptions downloadOptions, TransferContext context, CancellationToken cancellationToken);
    private static Task CopyInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, CopyMethod copyMethod, CopyOptions options, TransferContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<UploadDirectoryInternalAsync>d__89")]
private static Task`1<TransferStatus> UploadDirectoryInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, ITransferEnumerator sourceEnumerator, UploadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<DownloadDirectoryInternalAsync>d__90")]
private static Task`1<TransferStatus> DownloadDirectoryInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, ITransferEnumerator sourceEnumerator, DownloadDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<CopyDirectoryInternalAsync>d__91")]
private static Task`1<TransferStatus> CopyDirectoryInternalAsync(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod, ITransferEnumerator sourceEnumerator, CopyDirectoryOptions options, DirectoryTransferContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferManager/<DoTransfer>d__92")]
private static Task DoTransfer(Transfer transfer, TransferContext transferContext, CancellationToken cancellationToken);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private static SingleObjectTransfer GetOrCreateSingleObjectTransfer(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod, TransferContext transferContext);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private static DirectoryTransfer GetOrCreateDirectoryTransfer(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod, TransferContext transferContext);
    private static Transfer GetTransfer(TransferLocation sourceLocation, TransferLocation destLocation, TransferMethod transferMethod, TransferContext transferContext);
    private static bool TryAddTransfer(Transfer transfer);
    private static void RemoveTransfer(Transfer transfer);
    private static void UpdateTransferLocation(TransferLocation targetLocation, TransferLocation location);
    private static void SetDefaultRequestOptions(TransferLocation location);
    private static bool AreSameTransferEnumerators(ITransferEnumerator enumerator1, ITransferEnumerator enumerator2);
    private static void CheckSearchPatternOfAzureFileSource(DirectoryOptions options);
    private static TransferStatus CreateTransferSummary(TransferProgressTracker progress);
    private static TransferMethod CopyMethodToTransferMethod(CopyMethod copyMethod);
}
internal enum Microsoft.Azure.Storage.DataMovement.TransferMethod : Enum {
    public int value__;
    public static TransferMethod SyncCopy;
    public static TransferMethod ServiceSideAsyncCopy;
    public static TransferMethod ServiceSideSyncCopy;
    public static TransferMethod DummyCopy;
}
internal class Microsoft.Azure.Storage.DataMovement.TransferProgressTracker : JournalItem {
    private static string BytesTransferredName;
    private static string FilesTransferredName;
    private static string FilesSkippedName;
    private static string FilesFailedName;
    private long bytesTransferred;
    private long numberOfFilesTransferred;
    private long numberOfFilesSkipped;
    private long numberOfFilesFailed;
    private int invokingProgressHandler;
    [CompilerGeneratedAttribute]
private TransferProgressTracker <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<TransferStatus> <ProgressHandler>k__BackingField;
    public TransferProgressTracker Parent { get; public set; }
    public IProgress`1<TransferStatus> ProgressHandler { get; public set; }
    public long BytesTransferred { get; }
    public long NumberOfFilesTransferred { get; }
    public long NumberOfFilesSkipped { get; }
    public long NumberOfFilesFailed { get; }
    protected TransferProgressTracker(SerializationInfo info, StreamingContext context);
    private TransferProgressTracker(TransferProgressTracker other);
    [CompilerGeneratedAttribute]
public TransferProgressTracker get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(TransferProgressTracker value);
    [CompilerGeneratedAttribute]
public IProgress`1<TransferStatus> get_ProgressHandler();
    [CompilerGeneratedAttribute]
public void set_ProgressHandler(IProgress`1<TransferStatus> value);
    public long get_BytesTransferred();
    public long get_NumberOfFilesTransferred();
    public long get_NumberOfFilesSkipped();
    public long get_NumberOfFilesFailed();
    public void AddBytesTransferred(long bytesToIncrease);
    public void AddNumberOfFilesTransferred(long numberOfFilesToIncrease);
    public void AddNumberOfFilesSkipped(long numberOfFilesToIncrease);
    public void AddNumberOfFilesFailed(long numberOfFilesToIncrease);
    public void AddProgress(TransferProgressTracker progressTracker);
    public TransferProgressTracker Copy();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private void InvokeProgressHandler();
}
internal class Microsoft.Azure.Storage.DataMovement.TransferScheduler : object {
    private BlockingCollection`1<ITransferController> controllerQueue;
    private ConcurrentQueue`1<ITransferController> internalControllerQueue;
    private ConcurrentDictionary`2<ITransferController, object> activeControllerItems;
    private long activeControllerItemCount;
    private static double ActiveControllerItemPrefetchRatio;
    private int ongoingTasks;
    private ManualResetEventSlim ongoingTaskEvent;
    private static int MaxControllerItemCountToScheduleEachRound;
    private CancellationTokenSource cancellationTokenSource;
    private TransferConfigurations transferOptions;
    private ManualResetEventSlim controllerResetEvent;
    private MemoryManager memoryManager;
    private Random randomGenerator;
    private object disposeLock;
    private bool isDisposed;
    private static int MaxActiveControllerItemCount { get; }
    internal TransferConfigurations TransferOptions { get; }
    internal CancellationTokenSource CancellationTokenSource { get; }
    internal MemoryManager MemoryManager { get; }
    public TransferScheduler(TransferConfigurations options);
    private static int get_MaxActiveControllerItemCount();
    protected virtual override void Finalize();
    internal TransferConfigurations get_TransferOptions();
    internal CancellationTokenSource get_CancellationTokenSource();
    internal MemoryManager get_MemoryManager();
    public sealed virtual void Dispose();
    public Task ExecuteJobAsync(TransferJob job, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferScheduler/<ExecuteJobInternalAsync>d__28")]
[SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private Task ExecuteJobInternalAsync(TransferJob job, CancellationToken cancellationToken);
    private void FillInQueue(ConcurrentDictionary`2<ITransferController, object> activeItems, BlockingCollection`1<ITransferController> collection, CancellationToken token);
    private void WaitForCompletion();
    private void CancelWork();
    private void Dispose(bool disposing);
    private void CheckDisposed();
    private void StartSchedule();
    private void FinishedWorkItem(ITransferController transferController);
    private bool DoWorkFrom(ConcurrentDictionary`2<ITransferController, object> activeItems);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.TransferScheduler/<DoControllerWork>d__37")]
private void DoControllerWork(ITransferController controller);
    private static TransferControllerBase GenerateTransferConstroller(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken cancellationToken);
    private static ServiceSideSyncCopyController CreateServiceSideSyncCopyConstroller(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken cancellationToken);
    private static AsyncCopyController CreateAsyncCopyController(TransferScheduler transferScheduler, TransferJob transferJob, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <StartSchedule>b__34_0();
}
public class Microsoft.Azure.Storage.DataMovement.TransferSkippedException : TransferException {
    public TransferSkippedException(string errorMessage);
    public TransferSkippedException(string errorMessage, Exception innerException);
    protected TransferSkippedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Azure.Storage.DataMovement.TransferStatus : object {
    [CompilerGeneratedAttribute]
private long <BytesTransferred>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilesTransferred>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilesSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilesFailed>k__BackingField;
    public long BytesTransferred { get; internal set; }
    public long NumberOfFilesTransferred { get; internal set; }
    public long NumberOfFilesSkipped { get; internal set; }
    public long NumberOfFilesFailed { get; internal set; }
    public TransferStatus(long bytesTransferred, long numberOfFilesTransferred, long numberOfFilesSkipped, long numberOfFilesFailed);
    [CompilerGeneratedAttribute]
public long get_BytesTransferred();
    [CompilerGeneratedAttribute]
internal void set_BytesTransferred(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilesTransferred();
    [CompilerGeneratedAttribute]
internal void set_NumberOfFilesTransferred(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilesSkipped();
    [CompilerGeneratedAttribute]
internal void set_NumberOfFilesSkipped(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilesFailed();
    [CompilerGeneratedAttribute]
internal void set_NumberOfFilesFailed(long value);
}
public class Microsoft.Azure.Storage.DataMovement.UploadDirectoryOptions : DirectoryOptions {
    private bool preserveSMBAttributes;
    private PreserveSMBPermissions preserveSMBPermissions;
    private bool followSymlink;
    [CompilerGeneratedAttribute]
private BlobType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public BlobType BlobType { get; public set; }
    public bool FollowSymlink { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public PreserveSMBPermissions PreserveSMBPermissions { get; public set; }
    public string EncryptionScope { get; public set; }
    [CompilerGeneratedAttribute]
public BlobType get_BlobType();
    [CompilerGeneratedAttribute]
public void set_BlobType(BlobType value);
    public bool get_FollowSymlink();
    public void set_FollowSymlink(bool value);
    public bool get_PreserveSMBAttributes();
    public void set_PreserveSMBAttributes(bool value);
    public PreserveSMBPermissions get_PreserveSMBPermissions();
    public void set_PreserveSMBPermissions(PreserveSMBPermissions value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
}
public class Microsoft.Azure.Storage.DataMovement.UploadOptions : object {
    private bool preserveSMBAttributes;
    private PreserveSMBPermissions preserveSMBPermissions;
    [CompilerGeneratedAttribute]
private AccessCondition <DestinationAccessCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncryptionScope>k__BackingField;
    public AccessCondition DestinationAccessCondition { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public bool PreserveSMBAttributes { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public PreserveSMBPermissions PreserveSMBPermissions { get; public set; }
    public string EncryptionScope { get; public set; }
    [CompilerGeneratedAttribute]
public AccessCondition get_DestinationAccessCondition();
    [CompilerGeneratedAttribute]
public void set_DestinationAccessCondition(AccessCondition value);
    public bool get_PreserveSMBAttributes();
    public void set_PreserveSMBAttributes(bool value);
    public PreserveSMBPermissions get_PreserveSMBPermissions();
    public void set_PreserveSMBPermissions(PreserveSMBPermissions value);
    [CompilerGeneratedAttribute]
public string get_EncryptionScope();
    [CompilerGeneratedAttribute]
public void set_EncryptionScope(string value);
}
internal class Microsoft.Azure.Storage.DataMovement.UriLocation : TransferLocation {
    private static string UriName;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public TransferLocationType Type { get; }
    public object Instance { get; }
    public Uri Uri { get; private set; }
    public UriLocation(Uri uri);
    private UriLocation(SerializationInfo info, StreamingContext context);
    public virtual TransferLocationType get_Type();
    public virtual object get_Instance();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Validate();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.Azure.Storage.DataMovement.Utils : object {
    private static int RequireBufferMaxRetryCount;
    private static String[] ReservedBaseFileNames;
    private static String[] ReservedFileNames;
    private static String[] SizeFormats;
    private static Utils();
    public static string AppendSnapShotTimeToFileName(string fileName, Nullable`1<DateTimeOffset> snapshotTime);
    public static string BytesToHumanReadableSize(double size);
    public static void CheckCancellation(CancellationToken cancellationToken);
    public static bool CompareProperties(Attributes first, Attributes second);
    [ExtensionAttribute]
public static bool DictionaryEquals(IDictionary`2<string, string> firstDic, IDictionary`2<string, string> secondDic);
    [AsyncStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.Utils/<ExecuteXsclApiCallAsync>d__11")]
public static Task ExecuteXsclApiCallAsync(Func`1<Task> func, CancellationToken cancellationToken);
    public static Attributes GenerateAttributes(CloudBlob blob);
    public static Attributes GenerateAttributes(CloudFile file, bool preserveSMBProperties);
    public static BlobRequestOptions GenerateBlobRequestOptions(BlobRequestOptions customRequestOptions, bool isCreationRequest);
    public static AccessCondition GenerateConditionWithCustomerCondition(AccessCondition customCondition, bool checkedCustomAC);
    public static FileRequestOptions GenerateFileRequestOptions(FileRequestOptions customRequestOptions, bool isCreationRequest);
    public static AccessCondition GenerateIfMatchConditionWithCustomerCondition(string etag, AccessCondition customCondition, bool checkedCustomAC);
    public static OperationContext GenerateOperationContext(TransferContext transferContext);
    public static CloudBlob GetBlobReference(Uri blobUri, StorageCredentials credentials, BlobType blobType);
    [ExtensionAttribute]
public static string GetExceptionMessage(Exception ex);
    public static bool IsExpectedHttpStatusCodes(StorageException e, HttpStatusCode[] expectedStatusCodes);
    public static Byte[] RequireBuffer(MemoryManager memoryManager, Action checkCancellation);
    public static void SetAttributes(CloudBlob blob, Attributes attributes);
    public static void SetAttributes(CloudFile file, Attributes attributes, bool preserveSMBProperties);
    [ExtensionAttribute]
public static string ToErrorDetail(StorageException ex);
    [IteratorStateMachineAttribute("Microsoft.Azure.Storage.DataMovement.Utils/<CatchException>d__26`1")]
public static IEnumerable`1<T> CatchException(Func`1<IEnumerable`1<T>> srcEnumerable, Action`1<Exception> exceptionHandler);
    public static void CreateCloudFileDirectoryRecursively(CloudFileDirectory dir);
    public static void ValidateDestinationPath(string sourcePath, string destPath);
    public static void CreateParentDirectoryIfNotExists(string path);
    public static FileAttributes AzureFileNtfsAttributesToLocalAttributes(CloudFileNtfsAttributes cloudFileNtfsAttributes);
    public static CloudFileNtfsAttributes LocalAttributesToAzureFileNtfsAttributes(FileAttributes fileAttributes);
    [ExtensionAttribute]
public static string ToLongPath(string originPath);
    private static bool IsValidWindowsFileName(string fileName);
    private static bool IgnoreDirectoryCreationError(StorageException se);
    private static void AssignToRequestOptions(IRequestOptions targetRequestOptions, IRequestOptions customRequestOptions);
    private static void GetBasePathAndExtension(string filePath, String& basePath, String& extension);
}
