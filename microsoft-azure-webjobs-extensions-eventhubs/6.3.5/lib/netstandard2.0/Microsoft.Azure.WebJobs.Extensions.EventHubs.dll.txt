internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ConnectionString : object {
    private Dictionary`2<string, string> _pairs;
    private string _pairSeparator;
    private string _keywordValueSeparator;
    private ConnectionString(Dictionary`2<string, string> pairs, string pairSeparator, string keywordValueSeparator);
    public static ConnectionString Parse(string connectionString, string segmentSeparator, string keywordValueSeparator, bool allowEmptyValues);
    public static ConnectionString Empty(string segmentSeparator, string keywordValueSeparator);
    public string GetRequired(string keyword);
    public string GetNonRequired(string keyword);
    public bool TryGetSegmentValue(string keyword, String& value);
    public string GetSegmentValueOrDefault(string keyword, string defaultValue);
    public bool ContainsSegmentKey(string keyword);
    public void Replace(string keyword, string value);
    public void Add(string keyword, string value);
    public virtual string ToString();
    private static Dictionary`2<string, string> ParseSegments(String& connectionString, String& separator, String& keywordValueSeparator);
    private static bool TryGetNextSegment(String& str, String& separator, Int32& start, Int32& end);
    private static void Validate(string connectionString, string segmentSeparator, string keywordValueSeparator, bool allowEmptyValues);
    [CompilerGeneratedAttribute]
internal static int <ParseSegments>g__GetStart|14_0(String& str, int start);
    [CompilerGeneratedAttribute]
internal static int <ParseSegments>g__GetLength|14_1(String& str, Int32& start, int end);
}
internal class Azure.Core.Diagnostics.ValueStopwatch : ValueType {
    private static double TimestampToTicks;
    private long _startTimestamp;
    public bool IsActive { get; }
    private ValueStopwatch(long startTimestamp);
    private static ValueStopwatch();
    public bool get_IsActive();
    public static ValueStopwatch StartNew();
    public TimeSpan GetElapsedTime();
}
internal class Azure.Messaging.EventHubs.Core.BasicRetryPolicy : EventHubsRetryPolicy {
    private static int s_randomSeed;
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static double MaximumTimeSpanSeconds;
    [CompilerGeneratedAttribute]
private EventHubsRetryOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private double <JitterFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumThrottleSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumThrottleSeconds>k__BackingField;
    public EventHubsRetryOptions Options { get; }
    public double JitterFactor { get; }
    public int MinimumThrottleSeconds { get; }
    public int MaximumThrottleSeconds { get; }
    public BasicRetryPolicy(EventHubsRetryOptions retryOptions);
    private static BasicRetryPolicy();
    [CompilerGeneratedAttribute]
public EventHubsRetryOptions get_Options();
    [CompilerGeneratedAttribute]
public double get_JitterFactor();
    [CompilerGeneratedAttribute]
public int get_MinimumThrottleSeconds();
    [CompilerGeneratedAttribute]
public int get_MaximumThrottleSeconds();
    public virtual TimeSpan CalculateTryTimeout(int attemptCount);
    public virtual Nullable`1<TimeSpan> CalculateRetryDelay(Exception lastException, int attemptCount);
    private static bool ShouldRetryException(Exception exception);
    private static bool IsThrottleException(Exception exception);
    private static TimeSpan CalculateExponentialDelay(int attemptCount, double baseDelaySeconds, double baseJitterSeconds, Random random);
    private static TimeSpan CalculateFixedDelay(double baseDelaySeconds, double baseJitterSeconds, Random random);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.CancellationTokenExtensions : object {
    [ExtensionAttribute]
public static void ThrowIfCancellationRequested(CancellationToken instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubsRetryOptionsExtensions : object {
    [ExtensionAttribute]
public static EventHubsRetryOptions Clone(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static EventHubsRetryPolicy ToRetryPolicy(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static bool IsEquivalentTo(EventHubsRetryOptions instance, EventHubsRetryOptions other);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Azure.Messaging.EventHubs.Core.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UnknownRetryMode { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UnknownRetryMode();
}
internal class Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal : CheckpointStore {
    private string _functionId;
    private ILogger _logger;
    private BlobContainerClient _client;
    private static string BlobsResourceDoesNotExist;
    private static ETag IfNoneMatchAllTag;
    private static string CheckpointPrefix;
    private static string FunctionsLegacyCheckpointPrefix;
    private static string OwnershipPrefix;
    [CompilerGeneratedAttribute]
private BlobContainerClient <ContainerClient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitializeWithLegacyCheckpoints>k__BackingField;
    private BlobContainerClient ContainerClient { get; }
    private bool InitializeWithLegacyCheckpoints { get; }
    public BlobCheckpointStoreInternal(BlobContainerClient blobContainerClient, string functionId, ILogger logger);
    public BlobCheckpointStoreInternal(BlobContainerClient blobContainerClient);
    internal BlobCheckpointStoreInternal(BlobContainerClient blobContainerClient, bool initializeWithLegacyCheckpoints);
    private static BlobCheckpointStoreInternal();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<CreateIfNotExistsAsync>d__5")]
public Task CreateIfNotExistsAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private BlobContainerClient get_ContainerClient();
    [CompilerGeneratedAttribute]
private bool get_InitializeWithLegacyCheckpoints();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<ListOwnershipAsync>d__19")]
public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<ClaimOwnershipAsync>d__20")]
public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<GetCheckpointAsync>d__21")]
public virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointAsync>d__22")]
public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointAsync>d__23")]
public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, CheckpointPosition startingPosition, CancellationToken cancellationToken);
    internal string GetCheckpointBlobName(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointInternalAsync>d__25")]
private Task UpdateCheckpointInternalAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, Nullable`1<long> offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    private EventProcessorCheckpoint CreateCheckpoint(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, IDictionary`2<string, string> metadata, DateTimeOffset modifiedDate);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<CreateLegacyCheckpoint>d__27")]
private Task`1<EventProcessorCheckpoint> CreateLegacyCheckpoint(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string blobName, string partitionId, CancellationToken cancellationToken);
    private static bool TryReadLegacyCheckpoint(Span`1<byte> data, Nullable`1& offset, Nullable`1& sequenceNumber);
    private void GetCheckpointError(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, Exception exception);
    private void InvalidCheckpointFound(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup);
}
internal static class Azure.Messaging.EventHubs.Primitives.BlobMetadataKey : object {
    public static string OwnerIdentifier;
    public static string Offset;
    public static string SequenceNumber;
    public static string ClientIdentifier;
}
internal class Microsoft.Azure.WebJobs.EventDataBatchImpl : object {
    [CompilerGeneratedAttribute]
private EventDataBatch <Batch>k__BackingField;
    public int Count { get; }
    public long MaximumSizeInBytes { get; }
    public EventDataBatch Batch { get; }
    public EventDataBatchImpl(EventDataBatch eventDataBatch);
    public sealed virtual int get_Count();
    public sealed virtual long get_MaximumSizeInBytes();
    [CompilerGeneratedAttribute]
public EventDataBatch get_Batch();
    public sealed virtual bool TryAdd(EventData eventData);
}
[AttributeUsageAttribute("10240")]
[BindingAttribute]
public class Microsoft.Azure.WebJobs.EventHubAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Connection>k__BackingField;
    public string EventHubName { get; }
    public string Connection { get; public set; }
    public EventHubAttribute(string eventHubName);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_Connection();
    [CompilerGeneratedAttribute]
public void set_Connection(string value);
}
internal class Microsoft.Azure.WebJobs.EventHubConsumerClientImpl : object {
    private EventHubConsumerClient _client;
    public string EventHubName { get; }
    public string FullyQualifiedNamespace { get; }
    public string ConsumerGroup { get; }
    public EventHubConsumerClientImpl(EventHubConsumerClient client);
    public sealed virtual string get_EventHubName();
    public sealed virtual string get_FullyQualifiedNamespace();
    public sealed virtual string get_ConsumerGroup();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubConsumerClientImpl/<GetPartitionsAsync>d__8")]
public sealed virtual Task`1<String[]> GetPartitionsAsync();
    public sealed virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId);
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubAsyncCollector : object {
    private IEventHubProducerClient _client;
    private SemaphoreSlim _batchSemaphore;
    private Dictionary`2<string, IEventDataBatch> _batches;
    public EventHubAsyncCollector(IEventHubProducerClient client);
    public sealed virtual Task AddAsync(EventData item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubAsyncCollector/<AddAsync>d__5")]
public Task AddAsync(EventData item, string partitionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubAsyncCollector/<FlushAsync>d__6")]
public sealed virtual Task FlushAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubClientFactory : object {
    private IConfiguration _configuration;
    private AzureComponentFactory _componentFactory;
    private EventHubOptions _options;
    private INameResolver _nameResolver;
    private CheckpointClientProvider _checkpointClientProvider;
    private ConcurrentDictionary`2<string, EventHubProducerClient> _producerCache;
    private ConcurrentDictionary`2<string, IEventHubConsumerClient> _consumerCache;
    public EventHubClientFactory(IConfiguration configuration, AzureComponentFactory componentFactory, IOptions`1<EventHubOptions> options, INameResolver nameResolver, AzureEventSourceLogForwarder forwarder, CheckpointClientProvider checkpointClientProvider);
    internal EventHubProducerClient GetEventHubProducerClient(string eventHubName, string connection);
    internal EventProcessorHost GetEventProcessorHost(string eventHubName, string connection, string consumerGroup, bool singleDispatch);
    internal IEventHubConsumerClient GetEventHubConsumerClient(string eventHubName, string connection, string consumerGroup);
    internal BlobContainerClient GetCheckpointStoreClient();
    internal static string NormalizeEventHubName(string connectionString, string configuredEventHubName);
    private EventHubsConnectionInformation ResolveConnectionInformation(string connection);
    private static bool IsEventHubsConnectionString(string connectionString);
    private static string GenerateCacheKey(EventHubConnection eventHubConnection, string consumerGroup);
}
[ExtensionAttribute("EventHubs", "EventHubs")]
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubExtensionConfigProvider : object {
    private IOptions`1<EventHubOptions> _options;
    private ILoggerFactory _loggerFactory;
    private IConverterManager _converterManager;
    private IWebJobsExtensionConfiguration`1<EventHubExtensionConfigProvider> _configuration;
    private EventHubClientFactory _clientFactory;
    private IDrainModeManager _drainModeManager;
    [CompilerGeneratedAttribute]
private Action`1<ExceptionReceivedEventArgs> <ExceptionHandler>k__BackingField;
    internal Action`1<ExceptionReceivedEventArgs> ExceptionHandler { get; internal set; }
    public EventHubExtensionConfigProvider(IOptions`1<EventHubOptions> options, ILoggerFactory loggerFactory, IConverterManager converterManager, IWebJobsExtensionConfiguration`1<EventHubExtensionConfigProvider> configuration, EventHubClientFactory clientFactory, IDrainModeManager drainModeManager);
    [CompilerGeneratedAttribute]
internal Action`1<ExceptionReceivedEventArgs> get_ExceptionHandler();
    [CompilerGeneratedAttribute]
internal void set_ExceptionHandler(Action`1<ExceptionReceivedEventArgs> value);
    private void ExceptionReceivedHandler(ExceptionReceivedEventArgs args);
    public sealed virtual void Initialize(ExtensionConfigContext context);
    internal static void LogExceptionReceivedEvent(ExceptionReceivedEventArgs e, ILoggerFactory loggerFactory);
    private IAsyncCollector`1<EventData> BuildFromAttribute(EventHubAttribute attribute);
    private static string ConvertEventDataToString(EventData x);
    private static EventData ConvertBytes2EventData(Byte[] input);
    private static Byte[] ConvertEventDataToBytes(EventData input);
    private static EventData ConvertStringToEventData(string input);
    private static Task`1<object> ConvertPocoToEventData(object arg, Attribute attrResolved, ValueBindingContext context);
    private static EventData ConvertBinaryDataToEventData(BinaryData input);
    private static BinaryData ConvertEventDataToBinaryData(EventData input);
    internal static ParameterBindingData ConvertEventDataToBindingData(EventData input);
    [CompilerGeneratedAttribute]
private EventHubProducerClient <Initialize>b__12_0(EventHubAttribute attribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_1(ExceptionReceivedEventArgs e);
}
public class Microsoft.Azure.WebJobs.EventHubs.EventHubOptions : object {
    [CompilerGeneratedAttribute]
private EventProcessorOptions <EventProcessorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubConnectionOptions <ConnectionOptions>k__BackingField;
    private int _batchCheckpointFrequency;
    private int _maxEventBatchSize;
    private int _minEventBatchSize;
    private TimeSpan _maxWaitTime;
    private Nullable`1<int> _targetUnprocessedEventThreshold;
    [CompilerGeneratedAttribute]
private InitialOffsetOptions <InitialOffsetOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCheckpointing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckpointContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ExceptionReceivedEventArgs> <ExceptionHandler>k__BackingField;
    internal EventProcessorOptions EventProcessorOptions { get; }
    internal EventHubConnectionOptions ConnectionOptions { get; }
    public EventHubsTransportType TransportType { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public Uri CustomEndpointAddress { get; public set; }
    public EventHubsRetryOptions ClientRetryOptions { get; public set; }
    public int BatchCheckpointFrequency { get; public set; }
    public int MaxEventBatchSize { get; public set; }
    public int MinEventBatchSize { get; public set; }
    public TimeSpan MaxWaitTime { get; public set; }
    public Nullable`1<int> TargetUnprocessedEventThreshold { get; public set; }
    public InitialOffsetOptions InitialOffsetOptions { get; }
    public bool EnableCheckpointing { get; public set; }
    public bool TrackLastEnqueuedEventProperties { get; public set; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<long> PrefetchSizeInBytes { get; public set; }
    public TimeSpan PartitionOwnershipExpirationInterval { get; public set; }
    public TimeSpan LoadBalancingUpdateInterval { get; public set; }
    internal string CheckpointContainer { get; internal set; }
    internal Action`1<ExceptionReceivedEventArgs> ExceptionHandler { get; internal set; }
    [CompilerGeneratedAttribute]
internal EventProcessorOptions get_EventProcessorOptions();
    [CompilerGeneratedAttribute]
internal EventHubConnectionOptions get_ConnectionOptions();
    public EventHubsTransportType get_TransportType();
    public void set_TransportType(EventHubsTransportType value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public Uri get_CustomEndpointAddress();
    public void set_CustomEndpointAddress(Uri value);
    public EventHubsRetryOptions get_ClientRetryOptions();
    public void set_ClientRetryOptions(EventHubsRetryOptions value);
    public int get_BatchCheckpointFrequency();
    public void set_BatchCheckpointFrequency(int value);
    public int get_MaxEventBatchSize();
    public void set_MaxEventBatchSize(int value);
    public int get_MinEventBatchSize();
    public void set_MinEventBatchSize(int value);
    public TimeSpan get_MaxWaitTime();
    public void set_MaxWaitTime(TimeSpan value);
    public Nullable`1<int> get_TargetUnprocessedEventThreshold();
    public void set_TargetUnprocessedEventThreshold(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public InitialOffsetOptions get_InitialOffsetOptions();
    [CompilerGeneratedAttribute]
public bool get_EnableCheckpointing();
    [CompilerGeneratedAttribute]
public void set_EnableCheckpointing(bool value);
    public bool get_TrackLastEnqueuedEventProperties();
    public void set_TrackLastEnqueuedEventProperties(bool value);
    public int get_PrefetchCount();
    public void set_PrefetchCount(int value);
    public Nullable`1<long> get_PrefetchSizeInBytes();
    public void set_PrefetchSizeInBytes(Nullable`1<long> value);
    public TimeSpan get_PartitionOwnershipExpirationInterval();
    public void set_PartitionOwnershipExpirationInterval(TimeSpan value);
    public TimeSpan get_LoadBalancingUpdateInterval();
    public void set_LoadBalancingUpdateInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_CheckpointContainer();
    [CompilerGeneratedAttribute]
internal void set_CheckpointContainer(string value);
    [CompilerGeneratedAttribute]
internal Action`1<ExceptionReceivedEventArgs> get_ExceptionHandler();
    [CompilerGeneratedAttribute]
internal void set_ExceptionHandler(Action`1<ExceptionReceivedEventArgs> value);
    private sealed virtual override string Microsoft.Azure.WebJobs.Hosting.IOptionsFormatter.Format();
    private JObject ConstructRetryOptions();
    private JObject ConstructInitialOffsetOptions();
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubProducerClientImpl : object {
    private EventHubProducerClient _client;
    private ILogger _logger;
    public EventHubProducerClientImpl(EventHubProducerClient client, ILogger logger);
    public sealed virtual Task`1<IEventDataBatch> CreateBatchAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubProducerClientImpl/<CreateBatchAsync>d__4")]
public sealed virtual Task`1<IEventDataBatch> CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubProducerClientImpl/<SendAsync>d__5")]
public sealed virtual Task SendAsync(IEventDataBatch batch, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubsWebJobsStartup : object {
    public sealed virtual void Configure(IWebJobsBuilder builder);
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerAttributeBindingProvider : object {
    private ILoggerFactory _loggerFactory;
    private IOptions`1<EventHubOptions> _options;
    private EventHubClientFactory _clientFactory;
    private IConverterManager _converterManager;
    private IDrainModeManager _drainModeManager;
    public EventHubTriggerAttributeBindingProvider(IConverterManager converterManager, IOptions`1<EventHubOptions> options, ILoggerFactory loggerFactory, EventHubClientFactory clientFactory, IDrainModeManager drainModeManager);
    public sealed virtual Task`1<ITriggerBinding> TryCreateAsync(TriggerBindingProviderContext context);
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerBindingStrategy : object {
    public sealed virtual EventHubTriggerInput ConvertFromString(string input);
    public sealed virtual EventData BindSingle(EventHubTriggerInput value, ValueBindingContext context);
    public sealed virtual EventData[] BindMultiple(EventHubTriggerInput value, ValueBindingContext context);
    public sealed virtual Dictionary`2<string, Type> GetBindingContract(bool isSingleDispatch);
    private static void AddBindingContractMember(Dictionary`2<string, Type> contract, string name, Type type, bool isSingleDispatch);
    public sealed virtual Dictionary`2<string, object> GetBindingData(EventHubTriggerInput value);
    internal static void AddBindingData(Dictionary`2<string, object> bindingData, EventData[] events);
    private static void AddBindingData(Dictionary`2<string, object> bindingData, EventData eventData);
    private static void SafeAddValue(Action addValue);
    private static IDictionary`2<string, object> GetSystemPropertiesForBinding(EventData eventData);
}
[SupportsRetryAttribute]
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerBindingWrapper : object {
    private ITriggerBinding _innerTriggerBinding;
    public Type TriggerValueType { get; }
    public IReadOnlyDictionary`2<string, Type> BindingDataContract { get; }
    public EventHubTriggerBindingWrapper(ITriggerBinding triggerBinding);
    public sealed virtual Type get_TriggerValueType();
    public sealed virtual IReadOnlyDictionary`2<string, Type> get_BindingDataContract();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerBindingWrapper/<BindAsync>d__6")]
public sealed virtual Task`1<ITriggerData> BindAsync(object value, ValueBindingContext context);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerBindingWrapper/<CreateListenerAsync>d__7")]
public sealed virtual Task`1<IListener> CreateListenerAsync(ListenerFactoryContext context);
    public sealed virtual ParameterDescriptor ToParameterDescriptor();
}
internal class Microsoft.Azure.WebJobs.EventHubs.EventHubTriggerInput : object {
    private int _selector;
    [CompilerGeneratedAttribute]
private EventData[] <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorHostPartition <ProcessorPartition>k__BackingField;
    internal EventData[] Events { get; internal set; }
    internal EventProcessorHostPartition ProcessorPartition { get; internal set; }
    public bool IsSingleDispatch { get; }
    [CompilerGeneratedAttribute]
internal EventData[] get_Events();
    [CompilerGeneratedAttribute]
internal void set_Events(EventData[] value);
    [CompilerGeneratedAttribute]
internal EventProcessorHostPartition get_ProcessorPartition();
    [CompilerGeneratedAttribute]
internal void set_ProcessorPartition(EventProcessorHostPartition value);
    public bool get_IsSingleDispatch();
    public static EventHubTriggerInput New(EventData eventData);
    public EventHubTriggerInput GetSingleEventTriggerInput(int idx);
    public EventData GetSingleEventData();
    public Dictionary`2<string, string> GetTriggerDetails(EventProcessorPartition context);
}
public class Microsoft.Azure.WebJobs.EventHubs.InitialOffsetOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<OffsetType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EnqueuedTimeUtc>k__BackingField;
    public Nullable`1<OffsetType> Type { get; public set; }
    public Nullable`1<DateTimeOffset> EnqueuedTimeUtc { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<OffsetType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<OffsetType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_EnqueuedTimeUtc();
    [CompilerGeneratedAttribute]
public void set_EnqueuedTimeUtc(Nullable`1<DateTimeOffset> value);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubListener : object {
    private ITriggeredFunctionExecutor _executor;
    private EventProcessorHost _eventProcessorHost;
    private bool _singleDispatch;
    private BlobCheckpointStoreInternal _checkpointStore;
    private EventHubOptions _options;
    private Lazy`1<EventHubsScaleMonitor> _scaleMonitor;
    private Lazy`1<EventHubsTargetScaler> _targetScaler;
    private ILoggerFactory _loggerFactory;
    private ILogger _logger;
    private string _details;
    private CancellationTokenSource _listenerCancellationTokenSource;
    private CancellationTokenSource _functionExecutionCancellationTokenSource;
    private IDrainModeManager _drainModeManager;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    public EventHubListener(string functionId, ITriggeredFunctionExecutor executor, EventProcessorHost eventProcessorHost, bool singleDispatch, IEventHubConsumerClient consumerClient, BlobCheckpointStoreInternal checkpointStore, EventHubOptions options, ILoggerFactory loggerFactory, IDrainModeManager drainModeManager);
    private sealed virtual override void Microsoft.Azure.WebJobs.Host.Listeners.IListener.Cancel();
    private sealed virtual override void System.IDisposable.Dispose();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubListener/<StartAsync>d__17")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubListener/<StopAsync>d__18")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    private sealed virtual override IEventProcessor Microsoft.Azure.WebJobs.EventHubs.Processor.IEventProcessorFactory.CreatePartitionProcessor();
    public sealed virtual IScaleMonitor GetMonitor();
    public sealed virtual ITargetScaler GetTargetScaler();
}
internal class Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubsScaleMonitor : object {
    private string _functionId;
    private IEventHubConsumerClient _client;
    private ILogger _logger;
    private BlobCheckpointStoreInternal _checkpointStore;
    private EventHubMetricsProvider _metricsProvider;
    [CompilerGeneratedAttribute]
private ScaleMonitorDescriptor <Descriptor>k__BackingField;
    public ScaleMonitorDescriptor Descriptor { get; }
    public EventHubsScaleMonitor(string functionId, IEventHubConsumerClient client, BlobCheckpointStoreInternal checkpointStore, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual ScaleMonitorDescriptor get_Descriptor();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubsScaleMonitor/<Microsoft-Azure-WebJobs-Host-Scale-IScaleMonitor-GetMetricsAsync>d__9")]
private sealed virtual override Task`1<ScaleMetrics> Microsoft.Azure.WebJobs.Host.Scale.IScaleMonitor.GetMetricsAsync();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubsScaleMonitor/<GetMetricsAsync>d__10")]
public sealed virtual Task`1<EventHubsTriggerMetrics> GetMetricsAsync();
    private sealed virtual override ScaleStatus Microsoft.Azure.WebJobs.Host.Scale.IScaleMonitor.GetScaleStatus(ScaleStatusContext context);
    public sealed virtual ScaleStatus GetScaleStatus(ScaleStatusContext`1<EventHubsTriggerMetrics> context);
    private ScaleStatus GetScaleStatusCore(int workerCount, EventHubsTriggerMetrics[] metrics);
    private static bool IsTrueForLastN(IList`1<EventHubsTriggerMetrics> samples, int count, Func`3<EventHubsTriggerMetrics, EventHubsTriggerMetrics, bool> predicate);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubsScalerProvider : object {
    private IScaleMonitor _scaleMonitor;
    private ITargetScaler _targetScaler;
    public EventHubsScalerProvider(IServiceProvider serviceProvider, TriggerMetadata triggerMetadata);
    public sealed virtual IScaleMonitor GetMonitor();
    public sealed virtual ITargetScaler GetTargetScaler();
}
internal class Microsoft.Azure.WebJobs.EventHubs.Listeners.EventHubsTriggerMetrics : ScaleMetrics {
    [CompilerGeneratedAttribute]
private long <EventCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PartitionCount>k__BackingField;
    public long EventCount { get; public set; }
    public int PartitionCount { get; public set; }
    [CompilerGeneratedAttribute]
public long get_EventCount();
    [CompilerGeneratedAttribute]
public void set_EventCount(long value);
    [CompilerGeneratedAttribute]
public int get_PartitionCount();
    [CompilerGeneratedAttribute]
public void set_PartitionCount(int value);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Listeners.PartitionProcessorEventsManager : object {
    private int _maxBatchSize;
    private int _minBatchSize;
    [CompilerGeneratedAttribute]
private Queue`1<EventData> <CachedEvents>k__BackingField;
    internal Queue`1<EventData> CachedEvents { get; internal set; }
    public bool HasCachedEvents { get; }
    public PartitionProcessorEventsManager(int maxBatchSize, int minBatchSize);
    [CompilerGeneratedAttribute]
internal Queue`1<EventData> get_CachedEvents();
    [CompilerGeneratedAttribute]
internal void set_CachedEvents(Queue`1<EventData> value);
    public bool get_HasCachedEvents();
    public void ClearEventCache();
    public EventData[] TryGetBatchofEventsWithCached(EventData[] events, bool allowPartialBatch);
}
public enum Microsoft.Azure.WebJobs.EventHubs.OffsetType : Enum {
    public int value__;
    public static OffsetType FromStart;
    public static OffsetType FromEnd;
    public static OffsetType FromEnqueuedTime;
}
internal class Microsoft.Azure.WebJobs.EventHubs.Processor.CheckpointClientProvider : StorageClientProvider`2<BlobServiceClient, BlobClientOptions> {
    protected string ServiceUriSubDomain { get; }
    public CheckpointClientProvider(IConfiguration configuration, AzureComponentFactory componentFactory, AzureEventSourceLogForwarder logForwarder, ILogger`1<BlobServiceClient> logger);
    protected virtual string get_ServiceUriSubDomain();
}
internal class Microsoft.Azure.WebJobs.EventHubs.Processor.CheckpointInfo : ValueType {
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    public long Offset { get; }
    public long SequenceNumber { get; }
    public Nullable`1<DateTimeOffset> LastModified { get; }
    public CheckpointInfo(long offset, long sequenceNumber, Nullable`1<DateTimeOffset> lastModified);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Offset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_SequenceNumber();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
}
internal class Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost : EventProcessor`1<EventProcessorHostPartition> {
    private Action`1<ExceptionReceivedEventArgs> _exceptionHandler;
    private IEventProcessorFactory _processorFactory;
    private BlobCheckpointStoreInternal _checkpointStore;
    private ConcurrentDictionary`2<string, CheckpointInfo> _lastReadCheckpoint;
    public EventProcessorHost(string consumerGroup, string connectionString, string eventHubName, EventProcessorOptions options, int eventBatchMaximumCount, Action`1<ExceptionReceivedEventArgs> exceptionHandler);
    public EventProcessorHost(string consumerGroup, string fullyQualifiedNamespace, TokenCredential credential, string eventHubName, EventProcessorOptions options, int eventBatchMaximumCount, Action`1<ExceptionReceivedEventArgs> exceptionHandler);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<ClaimOwnershipAsync>d__7")]
protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<ListOwnershipAsync>d__8")]
protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<GetCheckpointAsync>d__9")]
protected virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<CheckpointAsync>d__10")]
internal virtual Task CheckpointAsync(string partitionId, EventData checkpointEvent, CancellationToken cancellationToken);
    internal virtual Nullable`1<CheckpointInfo> GetLastReadCheckpoint(string partitionId);
    protected virtual Task OnProcessingErrorAsync(Exception exception, EventProcessorHostPartition partition, string operationDescription, CancellationToken cancellationToken);
    protected virtual Task OnProcessingEventBatchAsync(IEnumerable`1<EventData> events, EventProcessorHostPartition partition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<OnInitializingPartitionAsync>d__14")]
protected virtual Task OnInitializingPartitionAsync(EventProcessorHostPartition partition, CancellationToken cancellationToken);
    protected virtual Task OnPartitionProcessingStoppedAsync(EventProcessorHostPartition partition, ProcessingStoppedReason reason, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHost/<StartProcessingAsync>d__16")]
public Task StartProcessingAsync(IEventProcessorFactory processorFactory, BlobCheckpointStoreInternal checkpointStore, CancellationToken cancellationToken);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHostPartition : EventProcessorPartition {
    private TriggerPartitionContext _partitionContext;
    private Nullable`1<CheckpointInfo> _checkpoint;
    [CompilerGeneratedAttribute]
private IEventProcessor <EventProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorHost <ProcessorHost>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, LastEnqueuedEventProperties> <ReadLastEnqueuedEventPropertiesFunc>k__BackingField;
    public TriggerPartitionContext PartitionContext { get; }
    public string Owner { get; }
    public string EventHubPath { get; }
    public Nullable`1<CheckpointInfo> Checkpoint { get; public set; }
    public LastEnqueuedEventProperties LastEnqueuedEventProperties { get; }
    public IEventProcessor EventProcessor { get; public set; }
    public EventProcessorHost ProcessorHost { get; public set; }
    public Func`2<string, LastEnqueuedEventProperties> ReadLastEnqueuedEventPropertiesFunc { get; public set; }
    public EventProcessorHostPartition(string partitionId);
    public TriggerPartitionContext get_PartitionContext();
    public string get_Owner();
    public string get_EventHubPath();
    public Nullable`1<CheckpointInfo> get_Checkpoint();
    public void set_Checkpoint(Nullable`1<CheckpointInfo> value);
    public LastEnqueuedEventProperties get_LastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public IEventProcessor get_EventProcessor();
    [CompilerGeneratedAttribute]
public void set_EventProcessor(IEventProcessor value);
    [CompilerGeneratedAttribute]
public EventProcessorHost get_ProcessorHost();
    [CompilerGeneratedAttribute]
public void set_ProcessorHost(EventProcessorHost value);
    [CompilerGeneratedAttribute]
public Func`2<string, LastEnqueuedEventProperties> get_ReadLastEnqueuedEventPropertiesFunc();
    [CompilerGeneratedAttribute]
public void set_ReadLastEnqueuedEventPropertiesFunc(Func`2<string, LastEnqueuedEventProperties> value);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.EventHubs.Processor.EventProcessorHostPartition/<CheckpointAsync>d__27")]
public Task CheckpointAsync(EventData checkpointEvent);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Processor.ExceptionReceivedEventArgs : object {
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Action { get; }
    public string Hostname { get; }
    public string PartitionId { get; }
    public Exception Exception { get; }
    public ExceptionReceivedEventArgs(string hostname, string action, string partitionId, Exception exception);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public string get_Hostname();
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
internal interface Microsoft.Azure.WebJobs.EventHubs.Processor.IEventProcessor {
    public abstract virtual Task CloseAsync(EventProcessorHostPartition context, ProcessingStoppedReason reason);
    public abstract virtual Task OpenAsync(EventProcessorHostPartition context);
    public abstract virtual Task ProcessErrorAsync(EventProcessorHostPartition context, Exception error);
    public abstract virtual Task ProcessEventsAsync(EventProcessorHostPartition context, IEnumerable`1<EventData> messages);
}
internal interface Microsoft.Azure.WebJobs.EventHubs.Processor.IEventProcessorFactory {
    public abstract virtual IEventProcessor CreatePartitionProcessor();
}
public class Microsoft.Azure.WebJobs.EventHubs.TriggerPartitionContext : PartitionContext {
    [CompilerGeneratedAttribute]
private bool <IsCheckpointingAfterInvocation>k__BackingField;
    public bool IsCheckpointingAfterInvocation { get; internal set; }
    public TriggerPartitionContext(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    [CompilerGeneratedAttribute]
public bool get_IsCheckpointingAfterInvocation();
    [CompilerGeneratedAttribute]
internal void set_IsCheckpointingAfterInvocation(bool value);
}
internal class Microsoft.Azure.WebJobs.EventHubs.Utility : object {
    public static void LogException(Exception ex, string message, ILogger logger);
    private static LogLevel GetLevel(Exception ex);
}
[AttributeUsageAttribute("2048")]
[BindingAttribute]
public class Microsoft.Azure.WebJobs.EventHubTriggerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Connection>k__BackingField;
    public string EventHubName { get; }
    public string ConsumerGroup { get; public set; }
    public string Connection { get; public set; }
    public EventHubTriggerAttribute(string eventHubName);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public void set_ConsumerGroup(string value);
    [CompilerGeneratedAttribute]
public string get_Connection();
    [CompilerGeneratedAttribute]
public void set_Connection(string value);
}
[ExtensionAttribute]
public static class Microsoft.Azure.WebJobs.EventHubWebJobsExtensions : object {
    [ExtensionAttribute]
public static Task AddAsync(IAsyncCollector`1<EventData> instance, EventData eventData, string partitionKey, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Azure.WebJobs.Extensions.Clients.Shared.StorageClientProvider`2 : object {
    private IConfiguration _configuration;
    private AzureComponentFactory _componentFactory;
    private AzureEventSourceLogForwarder _logForwarder;
    private ILogger _logger;
    public static string DefaultStorageEndpointSuffix;
    protected string ServiceUriSubDomain { get; }
    public StorageClientProvider`2(IConfiguration configuration, AzureComponentFactory componentFactory, AzureEventSourceLogForwarder logForwarder, ILogger`1<TClient> logger);
    protected abstract virtual string get_ServiceUriSubDomain();
    public virtual TClient Get(string name, INameResolver resolver);
    public virtual TClient Get(string name);
    public IConfigurationSection GetWebJobsConnectionStringSection(string name);
    protected virtual TClient CreateClient(IConfiguration configuration, TokenCredential tokenCredential, TClientOptions options);
    public virtual TClient GetHost();
    protected virtual TClientOptions CreateClientOptions(IConfiguration configuration);
    protected virtual bool TryGetServiceUri(IConfiguration configuration, Uri& serviceUri);
    protected virtual Uri FormatServiceUri(string accountName, string defaultProtocol, string endpointSuffix);
    protected static bool IsConnectionStringPresent(IConfiguration configuration);
}
[ExtensionAttribute]
internal static class Microsoft.Azure.WebJobs.Extensions.Clients.Shared.WebJobsConfigurationExtensions : object {
    private static string WebJobsConfigurationSectionName;
    [ExtensionAttribute]
public static IConfigurationSection GetWebJobsConnectionStringSection(IConfiguration configuration, string connectionStringName);
    public static string GetPrefixedConnectionStringName(string connectionStringName);
    [ExtensionAttribute]
public static IConfigurationSection GetConnectionStringOrSetting(IConfiguration configuration, string connectionName);
}
internal class Microsoft.Azure.WebJobs.Extensions.EventHubs.Listeners.EventHubMetricsProvider : object {
    private static int PartitionLogIntervalInMinutes;
    private string _functionId;
    private IEventHubConsumerClient _client;
    private ILogger _logger;
    private BlobCheckpointStoreInternal _checkpointStore;
    private DateTime _nextPartitionLogTime;
    private DateTime _nextPartitionWarningTime;
    public EventHubMetricsProvider(string functionId, IEventHubConsumerClient client, BlobCheckpointStoreInternal checkpointStore, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.Extensions.EventHubs.Listeners.EventHubMetricsProvider/<GetMetricsAsync>d__9")]
public Task`1<EventHubsTriggerMetrics> GetMetricsAsync();
    private EventHubsTriggerMetrics CreateTriggerMetrics(List`1<PartitionProperties> partitionRuntimeInfo, EventProcessorCheckpoint[] checkpoints, bool alwaysLog);
    private static long GetUnprocessedEventCount(PartitionProperties partitionInfo, BlobStorageCheckpoint checkpoint);
}
internal class Microsoft.Azure.WebJobs.Extensions.EventHubs.Listeners.EventHubsTargetScaler : object {
    private static int ThrottleScaleDownIntervalInSeconds;
    private string _functionId;
    private IEventHubConsumerClient _client;
    private ILogger _logger;
    private EventHubMetricsProvider _metricsProvider;
    private EventHubOptions _options;
    private DateTime _lastScaleUpTime;
    private TargetScalerResult _lastTargetScalerResult;
    [CompilerGeneratedAttribute]
private TargetScalerDescriptor <TargetScalerDescriptor>k__BackingField;
    public TargetScalerDescriptor TargetScalerDescriptor { get; }
    public EventHubsTargetScaler(string functionId, IEventHubConsumerClient client, EventHubOptions options, EventHubMetricsProvider metricsProvider, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual TargetScalerDescriptor get_TargetScalerDescriptor();
    [AsyncStateMachineAttribute("Microsoft.Azure.WebJobs.Extensions.EventHubs.Listeners.EventHubsTargetScaler/<GetScaleResultAsync>d__12")]
public sealed virtual Task`1<TargetScalerResult> GetScaleResultAsync(TargetScalerContext context);
    internal static TargetScalerResult ThrottleScaleDownIfNecessaryInternal(TargetScalerResult currentResult, TargetScalerResult previousResult, DateTime lastScaleUpTime, ILogger logger);
    internal TargetScalerResult GetScaleResultInternal(TargetScalerContext context, long eventCount, int partitionCount);
    internal int GetDesiredConcurrencyInternal(TargetScalerContext context);
    internal static Int32[] GetSortedValidWorkerCountsForPartitionCount(int partitionCount);
    internal static int GetValidWorkerCount(int workerCount, Int32[] sortedValidWorkerCountList);
    private static int GetChangeWorkerCount(TargetScalerResult currentResult, TargetScalerResult previousResult);
}
internal interface Microsoft.Azure.WebJobs.IEventDataBatch {
    public int Count { get; }
    public long MaximumSizeInBytes { get; }
    public abstract virtual int get_Count();
    public abstract virtual long get_MaximumSizeInBytes();
    public abstract virtual bool TryAdd(EventData eventData);
}
internal interface Microsoft.Azure.WebJobs.IEventHubConsumerClient {
    public string EventHubName { get; }
    public string FullyQualifiedNamespace { get; }
    public string ConsumerGroup { get; }
    public abstract virtual string get_EventHubName();
    public abstract virtual string get_FullyQualifiedNamespace();
    public abstract virtual string get_ConsumerGroup();
    public abstract virtual Task`1<String[]> GetPartitionsAsync();
    public abstract virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId);
}
internal interface Microsoft.Azure.WebJobs.IEventHubProducerClient {
    public abstract virtual Task`1<IEventDataBatch> CreateBatchAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEventDataBatch> CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken);
    public abstract virtual Task SendAsync(IEventDataBatch batch, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Hosting.EventHubWebJobsBuilderExtensions : object {
    [ExtensionAttribute]
public static IWebJobsBuilder AddEventHubs(IWebJobsBuilder builder);
    [ExtensionAttribute]
public static IWebJobsBuilder AddEventHubs(IWebJobsBuilder builder, Action`1<EventHubOptions> configure);
    [ExtensionAttribute]
internal static IWebJobsBuilder AddEventHubsScaleForTrigger(IWebJobsBuilder builder, TriggerMetadata triggerMetadata);
    internal static void ConfigureOptions(EventHubOptions options);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
