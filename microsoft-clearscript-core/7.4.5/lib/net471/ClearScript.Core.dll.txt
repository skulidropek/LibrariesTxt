public class Microsoft.ClearScript.AsyncDocumentLoadCallback : MulticastDelegate {
    public AsyncDocumentLoadCallback(object object, IntPtr method);
    public virtual Task Invoke(ValueRef`1<DocumentInfo> info, Stream contents);
    public virtual IAsyncResult BeginInvoke(ValueRef`1<DocumentInfo> info, Stream contents, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Microsoft.ClearScript.BindSignature : object {
    private Type context;
    private BindingFlags flags;
    private TargetInfo targetInfo;
    private string name;
    private Type[] typeArgs;
    private ArgInfo[] argData;
    public BindSignature(Type context, BindingFlags flags, HostTarget target, string name, Type[] typeArgs, Object[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(BindSignature that);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.ClearScript.BypassCustomAttributeLoaderAttribute : Attribute {
}
internal abstract class Microsoft.ClearScript.ByRefArg`1 : HostTarget {
    private HostVariable`1<T> target;
    public T Value { get; public set; }
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    private object Microsoft.ClearScript.IByRefArg.Value { get; private set; }
    protected ByRefArg`1(HostVariable`1<T> target);
    public T get_Value();
    public void set_Value(T value);
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual String[] GetAuxMethodNames(IHostContext context, BindingFlags bindFlags);
    public virtual String[] GetAuxPropertyNames(IHostContext context, BindingFlags bindFlags);
    public virtual bool TryInvokeAuxMember(IHostContext context, string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    private sealed virtual override object Microsoft.ClearScript.IByRefArg.get_Value();
    private sealed virtual override void Microsoft.ClearScript.IByRefArg.set_Value(object value);
}
internal static class Microsoft.ClearScript.CanonicalRefTable : object {
    private static Dictionary`2<Type, ICanonicalRefMap> table;
    private static CanonicalRefTable();
    public static object GetCanonicalRef(object obj);
    private static ICanonicalRefMap GetMap(object obj);
}
public class Microsoft.ClearScript.ConcurrentPropertyBag : PropertyBag {
    public ConcurrentPropertyBag(bool isReadOnly);
    public ConcurrentPropertyBag(IEqualityComparer`1<string> comparer);
    public ConcurrentPropertyBag(bool isReadOnly, IEqualityComparer`1<string> comparer);
}
public class Microsoft.ClearScript.ContinuationCallback : MulticastDelegate {
    public ContinuationCallback(object object, IntPtr method);
    public virtual bool Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.ClearScript.CustomAttributeCache : object {
    private ConditionalWeakTable`2<ICustomAttributeProvider, Entry> table;
    public T[] GetOrLoad(CustomAttributeLoader loader, ICustomAttributeProvider resource, bool inherit);
    private T[] GetOrLoad(CustomAttributeLoader loader, Entry entry, ICustomAttributeProvider resource, bool inherit);
    private static T[] Load(CustomAttributeLoader loader, ICustomAttributeProvider resource, bool inherit);
    private bool GetIsBypass(ICustomAttributeProvider resource);
    private bool GetIsBypass(Entry entry, ICustomAttributeProvider resource);
    private bool GetIsBypassInternal(ICustomAttributeProvider resource);
    private static ICustomAttributeProvider GetParent(ICustomAttributeProvider resource);
}
public class Microsoft.ClearScript.CustomAttributeLoader : object {
    private CustomAttributeCache cache;
    [CompilerGeneratedAttribute]
private static CustomAttributeLoader <Default>k__BackingField;
    public static CustomAttributeLoader Default { get; }
    private static CustomAttributeLoader();
    [CompilerGeneratedAttribute]
public static CustomAttributeLoader get_Default();
    public virtual T[] LoadCustomAttributes(ICustomAttributeProvider resource, bool inherit);
    internal T[] GetOrLoad(ICustomAttributeProvider resource, bool inherit);
}
internal static class Microsoft.ClearScript.CustomAttributes : object {
    public static T[] GetOrLoad(IHostContext context, ICustomAttributeProvider resource, bool inherit);
    public static bool Has(IHostContext context, ICustomAttributeProvider resource, bool inherit);
}
public class Microsoft.ClearScript.DefaultDocumentLoader : DocumentLoader {
    private static IReadOnlyCollection`1<string> relativePrefixes;
    private List`1<Document> cache;
    private long fileCheckCount;
    private long webCheckCount;
    [CompilerGeneratedAttribute]
private UInt32 <MaxCacheSize>k__BackingField;
    public UInt32 MaxCacheSize { get; public set; }
    private long Microsoft.ClearScript.DocumentLoader.IStatistics.FileCheckCount { get; }
    private long Microsoft.ClearScript.DocumentLoader.IStatistics.WebCheckCount { get; }
    private static DefaultDocumentLoader();
    private Task`1<ValueTuple`2<Document, List`1<Uri>>> GetCachedDocumentOrCandidateUrisAsync(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, Uri uri);
    private Task`1<ValueTuple`2<Document, List`1<Uri>>> GetCachedDocumentOrCandidateUrisAsync(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, string specifier);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<GetCachedDocumentOrCandidateUrisWorkerAsync>d__7")]
private Task`1<ValueTuple`2<Document, List`1<Uri>>> GetCachedDocumentOrCandidateUrisWorkerAsync(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, IEnumerable`1<Uri> rawUris);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<GetRawUris>d__8")]
private static IEnumerable`1<Uri> GetRawUris(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, string specifier);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<ApplyExtensions>d__9")]
private static IEnumerable`1<Uri> ApplyExtensions(Nullable`1<DocumentInfo> sourceInfo, Uri uri, string extensions);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<GetCompatibleExtensions>d__10")]
private static IEnumerable`1<string> GetCompatibleExtensions(Nullable`1<DocumentInfo> sourceInfo, string extensions);
    private static bool SpecifierMayBeRelative(DocumentSettings settings, string specifier);
    private static Uri GetBaseUri(DocumentInfo sourceInfo);
    private static bool TryCombineSearchUri(Uri searchUri, string specifier, Uri& uri);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<IsCandidateUriAsync>d__14")]
private Task`1<bool> IsCandidateUriAsync(DocumentSettings settings, Uri uri);
    private Task`1<bool> FileDocumentExistsAsync(string path);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<WebDocumentExistsAsync>d__16")]
private Task`1<bool> WebDocumentExistsAsync(Uri uri);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<LoadDocumentAsync>d__17")]
private Task`1<Document> LoadDocumentAsync(DocumentSettings settings, Uri uri, DocumentCategory category, DocumentContextCallback contextCallback);
    [CompilerGeneratedAttribute]
public virtual UInt32 get_MaxCacheSize();
    [CompilerGeneratedAttribute]
public virtual void set_MaxCacheSize(UInt32 value);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DefaultDocumentLoader/<LoadDocumentAsync>d__22")]
public virtual Task`1<Document> LoadDocumentAsync(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public virtual Document GetCachedDocument(Uri uri);
    public virtual Document CacheDocument(Document document, bool replace);
    public virtual void DiscardCachedDocuments();
    private sealed virtual override long Microsoft.ClearScript.DocumentLoader.IStatistics.get_FileCheckCount();
    private sealed virtual override long Microsoft.ClearScript.DocumentLoader.IStatistics.get_WebCheckCount();
    private sealed virtual override void Microsoft.ClearScript.DocumentLoader.IStatistics.ResetCheckCounts();
}
[AttributeUsageAttribute("1053")]
public class Microsoft.ClearScript.DefaultScriptUsageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ScriptAccess <Access>k__BackingField;
    public ScriptAccess Access { get; }
    public DefaultScriptUsageAttribute(ScriptAccess access);
    [CompilerGeneratedAttribute]
public ScriptAccess get_Access();
}
internal static class Microsoft.ClearScript.DelegateFactory : object {
    private static int maxArgCount;
    private static Type[] procTemplates;
    private static Type[] funcTemplates;
    private static Type[] procShimTemplates;
    private static Type[] funcShimTemplates;
    private static DelegateFactory();
    public static Delegate CreateProc(ScriptEngine engine, object target, int argCount);
    public static Delegate CreateFunc(ScriptEngine engine, object target, int argCount);
    public static TDelegate CreateDelegate(ScriptEngine engine, object target);
    public static Delegate CreateDelegate(ScriptEngine engine, object target, Type delegateType);
    private static Delegate CreateSimpleDelegate(ScriptEngine engine, object target, Type delegateType);
    private static Delegate CreateComplexDelegate(ScriptEngine engine, object target, Type delegateType);
}
public abstract class Microsoft.ClearScript.Document : object {
    public DocumentInfo Info { get; }
    public Stream Contents { get; }
    public Encoding Encoding { get; }
    public abstract virtual DocumentInfo get_Info();
    public abstract virtual Stream get_Contents();
    public virtual Encoding get_Encoding();
}
[FlagsAttribute]
public enum Microsoft.ClearScript.DocumentAccessFlags : Enum {
    public int value__;
    public static DocumentAccessFlags None;
    public static DocumentAccessFlags EnableFileLoading;
    public static DocumentAccessFlags EnableWebLoading;
    public static DocumentAccessFlags EnableAllLoading;
    public static DocumentAccessFlags EnforceRelativePrefix;
    public static DocumentAccessFlags AllowCategoryMismatch;
    public static DocumentAccessFlags UseAsyncLoadCallback;
}
public abstract class Microsoft.ClearScript.DocumentCategory : object {
    [CompilerGeneratedAttribute]
private UInt32 <MaxCacheSize>k__BackingField;
    public UInt32 MaxCacheSize { get; public set; }
    public static DocumentCategory Script { get; }
    public static DocumentCategory Json { get; }
    internal DocumentKind Kind { get; }
    internal string DefaultName { get; }
    [CompilerGeneratedAttribute]
public UInt32 get_MaxCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxCacheSize(UInt32 value);
    public static DocumentCategory get_Script();
    public static DocumentCategory get_Json();
    internal abstract virtual DocumentKind get_Kind();
    internal abstract virtual string get_DefaultName();
}
public class Microsoft.ClearScript.DocumentContextCallback : MulticastDelegate {
    public DocumentContextCallback(object object, IntPtr method);
    public virtual IDictionary`2<string, object> Invoke(DocumentInfo info);
    public virtual IAsyncResult BeginInvoke(DocumentInfo info, AsyncCallback callback, object object);
    public virtual IDictionary`2<string, object> EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Microsoft.ClearScript.DocumentFlags : Enum {
    public int value__;
    public static DocumentFlags None;
    public static DocumentFlags IsTransient;
    public static DocumentFlags AwaitDebuggerAndPause;
}
public class Microsoft.ClearScript.DocumentInfo : ValueType {
    private static long lastUniqueId;
    private string name;
    private DocumentCategory category;
    private ulong uniqueId;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceMapUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DocumentFlags> <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentContextCallback <ContextCallback>k__BackingField;
    public string Name { get; }
    public Uri Uri { get; }
    public Uri SourceMapUri { get; public set; }
    public DocumentCategory Category { get; public set; }
    public Nullable`1<DocumentFlags> Flags { get; public set; }
    public DocumentContextCallback ContextCallback { get; public set; }
    public DocumentInfo(string name);
    public DocumentInfo(Uri uri);
    public string get_Name();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public Uri get_SourceMapUri();
    [CompilerGeneratedAttribute]
public void set_SourceMapUri(Uri value);
    public DocumentCategory get_Category();
    public void set_Category(DocumentCategory value);
    [CompilerGeneratedAttribute]
public Nullable`1<DocumentFlags> get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(Nullable`1<DocumentFlags> value);
    [CompilerGeneratedAttribute]
public DocumentContextCallback get_ContextCallback();
    [CompilerGeneratedAttribute]
public void set_ContextCallback(DocumentContextCallback value);
    internal UniqueDocumentInfo MakeUnique(ScriptEngine engine);
    internal UniqueDocumentInfo MakeUnique(ScriptEngine engine, Nullable`1<DocumentFlags> defaultFlags);
    internal UniqueDocumentInfo MakeUnique(IUniqueNameManager manager);
    internal UniqueDocumentInfo MakeUnique(IUniqueNameManager manager, Nullable`1<DocumentFlags> defaultFlags);
}
internal enum Microsoft.ClearScript.DocumentKind : Enum {
    public int value__;
    public static DocumentKind Script;
    public static DocumentKind JavaScriptModule;
    public static DocumentKind CommonJSModule;
    public static DocumentKind Json;
}
public class Microsoft.ClearScript.DocumentLoadCallback : MulticastDelegate {
    public DocumentLoadCallback(object object, IntPtr method);
    public virtual void Invoke(DocumentInfo& info);
    public virtual IAsyncResult BeginInvoke(DocumentInfo& info, AsyncCallback callback, object object);
    public virtual void EndInvoke(DocumentInfo& info, IAsyncResult result);
}
public abstract class Microsoft.ClearScript.DocumentLoader : object {
    public static DocumentLoader Default { get; }
    public UInt32 MaxCacheSize { get; public set; }
    public static DocumentLoader get_Default();
    public virtual UInt32 get_MaxCacheSize();
    public virtual void set_MaxCacheSize(UInt32 value);
    public virtual Document LoadDocument(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public abstract virtual Task`1<Document> LoadDocumentAsync(DocumentSettings settings, Nullable`1<DocumentInfo> sourceInfo, string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public virtual Document GetCachedDocument(Uri uri);
    public virtual Document CacheDocument(Document document, bool replace);
    public virtual void DiscardCachedDocuments();
}
public class Microsoft.ClearScript.DocumentSettings : object {
    private DocumentLoader loader;
    private ConcurrentDictionary`2<Tuple`2<string, DocumentCategory>, Document> systemDocumentMap;
    [CompilerGeneratedAttribute]
private DocumentAccessFlags <AccessFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileNameExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentLoadCallback <LoadCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncDocumentLoadCallback <AsyncLoadCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentContextCallback <ContextCallback>k__BackingField;
    public DocumentLoader Loader { get; public set; }
    public DocumentAccessFlags AccessFlags { get; public set; }
    public string SearchPath { get; public set; }
    public string FileNameExtensions { get; public set; }
    public DocumentLoadCallback LoadCallback { get; public set; }
    public AsyncDocumentLoadCallback AsyncLoadCallback { get; public set; }
    public DocumentContextCallback ContextCallback { get; public set; }
    public DocumentLoader get_Loader();
    public void set_Loader(DocumentLoader value);
    [CompilerGeneratedAttribute]
public DocumentAccessFlags get_AccessFlags();
    [CompilerGeneratedAttribute]
public void set_AccessFlags(DocumentAccessFlags value);
    [CompilerGeneratedAttribute]
public string get_SearchPath();
    [CompilerGeneratedAttribute]
public void set_SearchPath(string value);
    [CompilerGeneratedAttribute]
public string get_FileNameExtensions();
    [CompilerGeneratedAttribute]
public void set_FileNameExtensions(string value);
    [CompilerGeneratedAttribute]
public DocumentLoadCallback get_LoadCallback();
    [CompilerGeneratedAttribute]
public void set_LoadCallback(DocumentLoadCallback value);
    [CompilerGeneratedAttribute]
public AsyncDocumentLoadCallback get_AsyncLoadCallback();
    [CompilerGeneratedAttribute]
public void set_AsyncLoadCallback(AsyncDocumentLoadCallback value);
    [CompilerGeneratedAttribute]
public DocumentContextCallback get_ContextCallback();
    [CompilerGeneratedAttribute]
public void set_ContextCallback(DocumentContextCallback value);
    public void AddSystemDocument(string identifier, string contents);
    public void AddSystemDocument(string identifier, DocumentCategory category, string contents);
    public void AddSystemDocument(string identifier, DocumentCategory category, string contents, DocumentContextCallback contextCallback);
    public void AddSystemDocument(string identifier, Document document);
    internal Document LoadDocument(Nullable`1<DocumentInfo> sourceInfo, string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.DocumentSettings/<LoadDocumentAsync>d__35")]
internal Task`1<Document> LoadDocumentAsync(Nullable`1<DocumentInfo> sourceInfo, string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    private Document FindSystemDocument(string identifier, DocumentCategory category);
}
internal class Microsoft.ClearScript.DynamicHostMetaObject : DynamicMetaObject {
    private IDynamicMetaObjectProvider metaObjectProvider;
    private DynamicMetaObject metaObject;
    public DynamicHostMetaObject(IDynamicMetaObjectProvider metaObjectProvider, DynamicMetaObject metaObject);
    public bool HasMember(string name, bool ignoreCase);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
}
public abstract class Microsoft.ClearScript.DynamicHostObject : DynamicObject {
    public virtual bool HasMember(string name, bool ignoreCase);
    internal static bool HasMember(IDynamicMetaObjectProvider metaObjectProvider, DynamicMetaObject metaObject, string name, bool ignoreCase);
}
public abstract class Microsoft.ClearScript.EventConnection : object {
    private ScriptEngine engine;
    private object source;
    private MethodInfo removeMethod;
    private Object[] parameters;
    private InterlockedOneWayFlag brokenFlag;
    internal EventConnection(ScriptEngine engine, object source, EventInfo eventInfo, Delegate handler);
    internal void Break();
    public void disconnect();
}
public class Microsoft.ClearScript.EventConnection`1 : EventConnection {
    internal EventConnection`1(ScriptEngine engine, object source, EventInfo eventInfo, Delegate handler);
}
public abstract class Microsoft.ClearScript.EventSource : object {
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private EventInfo <EventInfo>k__BackingField;
    internal ScriptEngine Engine { get; }
    internal Type HandlerType { get; }
    internal object Source { get; }
    internal EventInfo EventInfo { get; }
    internal EventSource(ScriptEngine engine, object source, EventInfo eventInfo);
    [CompilerGeneratedAttribute]
internal ScriptEngine get_Engine();
    internal abstract virtual Type get_HandlerType();
    [CompilerGeneratedAttribute]
internal object get_Source();
    [CompilerGeneratedAttribute]
internal EventInfo get_EventInfo();
    public EventConnection connect(object scriptFunc);
}
public class Microsoft.ClearScript.EventSource`1 : EventSource {
    internal Type HandlerType { get; }
    internal EventSource`1(ScriptEngine engine, object source, EventInfo eventInfo);
    internal virtual Type get_HandlerType();
    public EventConnection`1<T> connect(object scriptFunc);
}
public class Microsoft.ClearScript.ExtendedHostFunctions : HostFunctions {
    public object type(string name, Object[] hostTypeArgs);
    public object type(string name, string assemblyName, Object[] hostTypeArgs);
    public object type(Type type);
    public object arrType(int rank);
    public HostTypeCollection lib(String[] assemblyNames);
    public HostTypeCollection lib(HostTypeCollection collection, String[] assemblyNames);
    public object comType(string progID, string serverName);
    public object newComObj(string progID, string serverName);
    public HostTypeCollection typeLibEnums(T obj, HostTypeCollection collection);
}
internal class Microsoft.ClearScript.ExtensionMethodSummary : object {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo[] <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MethodNames>k__BackingField;
    public Type[] Types { get; }
    public MethodInfo[] Methods { get; }
    public String[] MethodNames { get; }
    public ExtensionMethodSummary(IHostContext context, Dictionary`2<Type, MethodInfo[]> table);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public MethodInfo[] get_Methods();
    [CompilerGeneratedAttribute]
public String[] get_MethodNames();
}
internal class Microsoft.ClearScript.ExtensionMethodTable : object {
    private Dictionary`2<Type, MethodInfo[]> table;
    [CompilerGeneratedAttribute]
private ExtensionMethodSummary <Summary>k__BackingField;
    public ExtensionMethodSummary Summary { get; private set; }
    [CompilerGeneratedAttribute]
public ExtensionMethodSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ExtensionMethodSummary value);
    public bool ProcessType(IHostContext context, Type type);
    public void RebuildSummary(IHostContext context);
    private static bool IsScriptableExtensionMethod(IHostContext context, MethodInfo method);
}
[ExtensionAttribute]
public static class Microsoft.ClearScript.Extensions : object {
    [ExtensionAttribute]
public static object ToHostType(Type type);
    [ExtensionAttribute]
public static object ToHostType(Type type, ScriptEngine engine);
    [ExtensionAttribute]
public static object ToRestrictedHostObject(T target);
    [ExtensionAttribute]
public static object ToRestrictedHostObject(T target, ScriptEngine engine);
    [ExtensionAttribute]
public static object ToRestrictedHostObject(object target, Type type);
    [ExtensionAttribute]
public static object ToRestrictedHostObject(object target, Type type, ScriptEngine engine);
}
public class Microsoft.ClearScript.HostFunctions : object {
    private ScriptEngine engine;
    public PropertyBag newObj();
    public T newObj(Object[] args);
    public object newObj(object type, Object[] args);
    public object newObj(IDynamicMetaObjectProvider target, Object[] args);
    public object newArr(Int32[] lengths);
    public object newArr(Int32[] lengths);
    public object newVar(T initValue);
    public T del(object scriptFunc);
    public object proc(int argCount, object scriptFunc);
    public object func(int argCount, object scriptFunc);
    public object func(int argCount, object scriptFunc);
    public Type typeOf();
    public Type typeOf(object value);
    public bool isType(object value);
    public object asType(object value);
    public object cast(object value);
    public bool isTypeObj(object value);
    public bool isTypeObj();
    public bool isNull(object value);
    public T flags(T[] args);
    public object toSByte(IConvertible value);
    public object toByte(IConvertible value);
    public object toInt16(IConvertible value);
    public object toUInt16(IConvertible value);
    public object toChar(IConvertible value);
    public object toInt32(IConvertible value);
    public object toUInt32(IConvertible value);
    public object toInt64(IConvertible value);
    public object toUInt64(IConvertible value);
    public object toSingle(IConvertible value);
    public object toDouble(IConvertible value);
    public object toDecimal(IConvertible value);
    public object getProperty(IPropertyBag target, string name);
    public object setProperty(IPropertyBag target, string name, object value);
    public bool removeProperty(IPropertyBag target, string name);
    public object getProperty(IDynamicMetaObjectProvider target, string name);
    public object setProperty(IDynamicMetaObjectProvider target, string name, object value);
    public bool removeProperty(IDynamicMetaObjectProvider target, string name);
    public object getElement(IDynamicMetaObjectProvider target, Object[] indices);
    public object setElement(IDynamicMetaObjectProvider target, object value, Object[] indices);
    public bool removeElement(IDynamicMetaObjectProvider target, Object[] indices);
    public object toStaticType(IDynamicMetaObjectProvider value);
    public bool tryCatch(object tryFunc, object catchFunc, object finallyFunc);
    internal ScriptEngine GetEngine();
    internal static Type GetUniqueHostType(object type, string paramName);
    private sealed virtual override void Microsoft.ClearScript.IScriptableObject.OnExposedToScriptCode(ScriptEngine engine);
}
internal class Microsoft.ClearScript.HostIndexedProperty : HostTarget {
    private static String[] auxMethodNames;
    private HostItem target;
    private string name;
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    public HostIndexedProperty(HostItem target, string name);
    private static HostIndexedProperty();
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual String[] GetAuxMethodNames(IHostContext context, BindingFlags bindFlags);
    public virtual bool TryInvokeAuxMember(IHostContext context, string memberName, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
}
internal class Microsoft.ClearScript.HostItem : DynamicObject {
    private HostTargetMemberData targetMemberData;
    private static PropertyInfo[] reflectionProperties;
    internal static bool EnableVTablePatching;
    [ThreadStaticAttribute]
private static bool bypassVTablePatching;
    [CompilerGeneratedAttribute]
private HostTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private HostItemFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    private static ConcurrentDictionary`2<BindSignature, object> coreBindCache;
    private static long coreBindCount;
    public HostTarget Target { get; }
    public HostItemFlags Flags { get; }
    public Invocability Invocability { get; }
    private IReflect ThisReflect { get; }
    private IDynamic ThisDynamic { get; }
    private IDynamic TargetDynamic { get; }
    private IPropertyBag TargetPropertyBag { get; private set; }
    private IHostList TargetList { get; private set; }
    private DynamicHostMetaObject TargetDynamicMetaObject { get; private set; }
    private IEnumerator TargetEnumerator { get; }
    private HashSet`1<string> ExpandoMemberNames { get; private set; }
    private Dictionary`2<string, HostMethod> HostMethodMap { get; private set; }
    private Dictionary`2<string, HostIndexedProperty> HostIndexedPropertyMap { get; private set; }
    private Int32[] PropertyIndices { get; private set; }
    private int CachedListCount { get; private set; }
    private HostItemCollateral Collateral { get; }
    private String[] TypeEventNames { get; private set; }
    private String[] TypeFieldNames { get; private set; }
    private String[] TypeMethodNames { get; private set; }
    private String[] TypePropertyNames { get; private set; }
    private String[] AllFieldNames { get; private set; }
    private String[] AllMethodNames { get; private set; }
    private String[] OwnMethodNames { get; private set; }
    private String[] EnumeratedMethodNames { get; }
    private String[] AllPropertyNames { get; private set; }
    private String[] AllMemberNames { get; private set; }
    private FieldInfo[] AllFields { get; private set; }
    private MethodInfo[] AllMethods { get; private set; }
    private PropertyInfo[] AllProperties { get; private set; }
    private object EnumerationSettingsToken { get; private set; }
    private ExtensionMethodSummary ExtensionMethodSummary { get; private set; }
    private Nullable`1<Invocability> TargetInvocability { get; private set; }
    private CustomAttributeLoader CurrentCustomAttributeLoader { get; }
    private Type CurrentAccessContext { get; }
    private ScriptAccess CurrentDefaultAccess { get; }
    private HostTargetFlags CurrentTargetFlags { get; }
    private CustomAttributeLoader CachedCustomAttributeLoader { get; }
    private Type CachedAccessContext { get; }
    private ScriptAccess CachedDefaultAccess { get; }
    private HostTargetFlags CachedTargetFlags { get; }
    private bool UseCaseInsensitiveMemberBinding { get; }
    private StringComparison MemberNameComparison { get; }
    private StringComparer MemberNameComparer { get; }
    private Type System.Reflection.IReflect.UnderlyingSystemType { get; }
    public ScriptEngine Engine { get; }
    public CustomAttributeLoader CustomAttributeLoader { get; }
    public Type AccessContext { get; }
    public ScriptAccess DefaultAccess { get; }
    public HostTargetFlags TargetFlags { get; }
    private HostItem(ScriptEngine engine, HostTarget target, HostItemFlags flags);
    private static HostItem();
    public static object Wrap(ScriptEngine engine, object obj);
    public static object Wrap(ScriptEngine engine, object obj, Type type);
    public static object Wrap(ScriptEngine engine, object obj, HostItemFlags flags);
    private static object Wrap(ScriptEngine engine, object obj, Type type, HostItemFlags flags);
    [CompilerGeneratedAttribute]
public HostTarget get_Target();
    [CompilerGeneratedAttribute]
public HostItemFlags get_Flags();
    public Invocability get_Invocability();
    public object InvokeMember(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, CultureInfo culture, bool bypassTunneling);
    public object InvokeMember(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, CultureInfo culture, bool bypassTunneling, Boolean& isCacheable);
    private IReflect get_ThisReflect();
    private IDynamic get_ThisDynamic();
    private IDynamic get_TargetDynamic();
    private IPropertyBag get_TargetPropertyBag();
    private void set_TargetPropertyBag(IPropertyBag value);
    private IHostList get_TargetList();
    private void set_TargetList(IHostList value);
    private DynamicHostMetaObject get_TargetDynamicMetaObject();
    private void set_TargetDynamicMetaObject(DynamicHostMetaObject value);
    private IEnumerator get_TargetEnumerator();
    private HashSet`1<string> get_ExpandoMemberNames();
    private void set_ExpandoMemberNames(HashSet`1<string> value);
    private Dictionary`2<string, HostMethod> get_HostMethodMap();
    private void set_HostMethodMap(Dictionary`2<string, HostMethod> value);
    private Dictionary`2<string, HostIndexedProperty> get_HostIndexedPropertyMap();
    private void set_HostIndexedPropertyMap(Dictionary`2<string, HostIndexedProperty> value);
    private Int32[] get_PropertyIndices();
    private void set_PropertyIndices(Int32[] value);
    private int get_CachedListCount();
    private void set_CachedListCount(int value);
    private HostItemCollateral get_Collateral();
    private String[] get_TypeEventNames();
    private void set_TypeEventNames(String[] value);
    private String[] get_TypeFieldNames();
    private void set_TypeFieldNames(String[] value);
    private String[] get_TypeMethodNames();
    private void set_TypeMethodNames(String[] value);
    private String[] get_TypePropertyNames();
    private void set_TypePropertyNames(String[] value);
    private String[] get_AllFieldNames();
    private void set_AllFieldNames(String[] value);
    private String[] get_AllMethodNames();
    private void set_AllMethodNames(String[] value);
    private String[] get_OwnMethodNames();
    private void set_OwnMethodNames(String[] value);
    private String[] get_EnumeratedMethodNames();
    private String[] get_AllPropertyNames();
    private void set_AllPropertyNames(String[] value);
    private String[] get_AllMemberNames();
    private void set_AllMemberNames(String[] value);
    private FieldInfo[] get_AllFields();
    private void set_AllFields(FieldInfo[] value);
    private MethodInfo[] get_AllMethods();
    private void set_AllMethods(MethodInfo[] value);
    private PropertyInfo[] get_AllProperties();
    private void set_AllProperties(PropertyInfo[] value);
    private object get_EnumerationSettingsToken();
    private void set_EnumerationSettingsToken(object value);
    private ExtensionMethodSummary get_ExtensionMethodSummary();
    private void set_ExtensionMethodSummary(ExtensionMethodSummary value);
    private Nullable`1<Invocability> get_TargetInvocability();
    private void set_TargetInvocability(Nullable`1<Invocability> value);
    private CustomAttributeLoader get_CurrentCustomAttributeLoader();
    private Type get_CurrentAccessContext();
    private ScriptAccess get_CurrentDefaultAccess();
    private HostTargetFlags get_CurrentTargetFlags();
    private CustomAttributeLoader get_CachedCustomAttributeLoader();
    private Type get_CachedAccessContext();
    private ScriptAccess get_CachedDefaultAccess();
    private HostTargetFlags get_CachedTargetFlags();
    private static bool TargetSupportsExpandoMembers(HostTarget target, HostItemFlags flags);
    private bool CanAddExpandoMembers();
    private static object BindOrCreate(ScriptEngine engine, object target, Type type, HostItemFlags flags);
    private static object BindOrCreate(ScriptEngine engine, HostTarget target, HostItemFlags flags);
    private void BindSpecialTarget();
    private bool BindSpecialTarget(CollateralObject`2<HostItem, T> property);
    private bool BindSpecialTarget(T& specialTarget);
    private void BindTargetMemberData();
    private static bool TargetSupportsSpecialTargets(HostTarget target);
    private String[] GetLocalEventNames();
    private String[] GetLocalFieldNames();
    private String[] GetLocalMethodNames();
    private String[] GetLocalPropertyNames();
    private String[] GetAllFieldNames();
    private String[] GetAllMethodNames(String[]& ownMethodNames);
    private String[] GetAllPropertyNames();
    private void UpdateFieldNames(Boolean& updated);
    private void UpdateMethodNames(Boolean& updated);
    private void UpdatePropertyNames(Boolean& updated);
    private void UpdateEnumerationSettingsToken(Boolean& updated);
    protected virtual void AddExpandoMemberName(string name);
    protected virtual void RemoveExpandoMemberName(string name);
    private bool get_UseCaseInsensitiveMemberBinding();
    private StringComparison get_MemberNameComparison();
    private StringComparer get_MemberNameComparer();
    private T HostInvoke(Func`1<T> func);
    private BindingFlags GetCommonBindFlags();
    private BindingFlags GetMethodBindFlags();
    protected virtual string AdjustInvokeName(string name);
    private void AdjustInvokeFlags(BindingFlags& invokeFlags);
    private object InvokeReflectMember(string name, BindingFlags invokeFlags, Object[] wrappedArgs, CultureInfo culture, String[] namedParams);
    private object InvokeReflectMember(string name, BindingFlags invokeFlags, Object[] wrappedArgs, CultureInfo culture, String[] namedParams, Boolean& isCacheable);
    private object InvokeDynamicMember(string name, BindingFlags invokeFlags, Object[] args);
    private object InvokePropertyBagMember(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs);
    private object InvokeListElement(int index, BindingFlags invokeFlags, Object[] args, Object[] bindArgs);
    private object InvokeHostMember(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Boolean& isCacheable);
    private object GetHostProperty(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, bool includeBoundMembers, Boolean& isCacheable);
    private object GetHostProperty(BindSignature signature, PropertyInfo property, BindingFlags invokeFlags, Object[] args);
    private object GetHostPropertyWorker(PropertyInfo property, MethodInfo getMethod, Object[] args);
    private object GetHostField(BindSignature signature, FieldInfo field, Boolean& isCacheable);
    private object GetHostFieldWorker(FieldInfo field, Boolean& isCacheable);
    private object SetHostProperty(string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs);
    private object SetHostProperty(BindSignature signature, PropertyInfo property, Object[] args, Object[] bindArgs);
    private object SetHostPropertyWorker(PropertyInfo property, MethodInfo setMethod, Object[] args, Object[] bindArgs);
    private object SetHostField(BindSignature signature, FieldInfo field, Object[] args);
    private object SetHostFieldWorker(FieldInfo field, Object[] args);
    private static object CreateScriptableEnumerator(IEnumerable`1<T> enumerable);
    private object CreateScriptableEnumerator();
    public virtual string ToString();
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indices, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indices, object value);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    private sealed virtual override FieldInfo System.Reflection.IReflect.GetField(string name, BindingFlags bindFlags);
    private sealed virtual override FieldInfo[] System.Reflection.IReflect.GetFields(BindingFlags bindFlags);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMember(string name, BindingFlags bindFlags);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMembers(BindingFlags bindFlags);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindFlags);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindFlags, Binder binder, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override MethodInfo[] System.Reflection.IReflect.GetMethods(BindingFlags bindFlags);
    private sealed virtual override PropertyInfo[] System.Reflection.IReflect.GetProperties(BindingFlags bindFlags);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindFlags, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindFlags);
    private sealed virtual override object System.Reflection.IReflect.InvokeMember(string name, BindingFlags invokeFlags, Binder binder, object invokeTarget, Object[] wrappedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    private sealed virtual override Type System.Reflection.IReflect.get_UnderlyingSystemType();
    private sealed virtual override object Microsoft.ClearScript.Util.IDynamic.GetProperty(string name, Object[] args);
    private sealed virtual override object Microsoft.ClearScript.Util.IDynamic.GetProperty(string name, Boolean& isCacheable, Object[] args);
    private sealed virtual override void Microsoft.ClearScript.Util.IDynamic.SetProperty(string name, Object[] args);
    private sealed virtual override bool Microsoft.ClearScript.Util.IDynamic.DeleteProperty(string name);
    private sealed virtual override String[] Microsoft.ClearScript.Util.IDynamic.GetPropertyNames();
    private sealed virtual override object Microsoft.ClearScript.Util.IDynamic.GetProperty(int index);
    private sealed virtual override void Microsoft.ClearScript.Util.IDynamic.SetProperty(int index, object value);
    private sealed virtual override bool Microsoft.ClearScript.Util.IDynamic.DeleteProperty(int index);
    private sealed virtual override Int32[] Microsoft.ClearScript.Util.IDynamic.GetPropertyIndices();
    private sealed virtual override object Microsoft.ClearScript.Util.IDynamic.Invoke(bool asConstructor, Object[] args);
    private sealed virtual override object Microsoft.ClearScript.Util.IDynamic.InvokeMethod(string name, Object[] args);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IEnumVARIANT.Next(int count, Object[] elements, IntPtr pCountFetched);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IEnumVARIANT.Skip(int count);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IEnumVARIANT.Reset();
    private sealed virtual override IEnumVARIANT System.Runtime.InteropServices.ComTypes.IEnumVARIANT.Clone();
    public sealed virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& pInterface);
    [CompilerGeneratedAttribute]
public sealed virtual ScriptEngine get_Engine();
    public sealed virtual object Unwrap();
    public sealed virtual CustomAttributeLoader get_CustomAttributeLoader();
    public sealed virtual Type get_AccessContext();
    public sealed virtual ScriptAccess get_DefaultAccess();
    public sealed virtual HostTargetFlags get_TargetFlags();
    private object InvokeMethod(string name, Object[] args, Object[] bindArgs);
    private object InvokeMethod(string name, Type[] typeArgs, Object[] args, Object[] bindArgs);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.HostItem/<GetTypeArgs>d__223")]
private static IEnumerable`1<Type> GetTypeArgs(Object[] args);
    private MethodBindResult BindMethod(string name, Type[] typeArgs, Object[] args, Object[] bindArgs);
    private static MethodBindResult BindMethodInternal(BindSignature signature, Type bindContext, BindingFlags bindFlags, HostTarget target, string name, Type[] typeArgs, Object[] args, Object[] bindArgs);
    private static MethodBindResult BindMethodCore(Type bindContext, BindingFlags bindFlags, HostTarget target, string name, Type[] typeArgs, Object[] args, Object[] bindArgs);
    private static object BindMethodRaw(BindingFlags bindFlags, InvokeMemberBinder binder, HostTarget target, Object[] bindArgs);
    private IEnumerable`1<string> GetAltMethodNames(string name, BindingFlags bindFlags);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.HostItem/<GetAltMethodNamesInternal>d__229")]
private IEnumerable`1<string> GetAltMethodNamesInternal(string name, BindingFlags bindFlags);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.HostItem/<CreateArgInfoEnum>d__230")]
private static IEnumerable`1<CSharpArgumentInfo> CreateArgInfoEnum(HostTarget target, Object[] args);
    private static CSharpArgumentInfo CreateArgInfo(object arg);
    private static CSharpArgumentInfo CreateStaticTypeArgInfo();
    private MethodBindResult BindMethodUsingReflection(BindingFlags bindFlags, HostTarget hostTarget, string name, Type[] typeArgs, Object[] args, Object[] bindArgs);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.HostItem/<GetReflectionCandidates>d__234")]
private IEnumerable`1<MethodInfo> GetReflectionCandidates(BindingFlags bindFlags, HostTarget hostTarget, string name, Type[] typeArgs);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.HostItem/<GetReflectionCandidates>d__235")]
private IEnumerable`1<MethodInfo> GetReflectionCandidates(BindingFlags bindFlags, Type type, string name, Type[] typeArgs);
    internal static void ClearCoreBindCache();
    internal static long GetCoreBindCount();
    private static HostItem Create(ScriptEngine engine, HostTarget target, HostItemFlags flags);
    private object CreateAsyncEnumerator(IEnumerable`1<T> enumerable);
    private object CreateAsyncEnumerator();
    [CompilerGeneratedAttribute]
private string <GetLocalEventNames>b__126_0(EventInfo eventInfo);
    [CompilerGeneratedAttribute]
private string <GetLocalFieldNames>b__127_0(FieldInfo field);
    [CompilerGeneratedAttribute]
private string <GetLocalMethodNames>b__128_0(MethodInfo method);
    [CompilerGeneratedAttribute]
private string <GetLocalPropertyNames>b__129_0(PropertyInfo property);
    [CompilerGeneratedAttribute]
private FieldInfo[] <System.Reflection.IReflect.GetFields>b__178_0();
    [CompilerGeneratedAttribute]
private MethodInfo[] <System.Reflection.IReflect.GetMethods>b__183_0();
    [CompilerGeneratedAttribute]
private PropertyInfo[] <System.Reflection.IReflect.GetProperties>b__184_0();
    [CompilerGeneratedAttribute]
private String[] <Microsoft.ClearScript.Util.IDynamic.GetPropertyNames>b__194_0();
    [CompilerGeneratedAttribute]
private Int32[] <Microsoft.ClearScript.Util.IDynamic.GetPropertyIndices>b__198_0();
    [CompilerGeneratedAttribute]
private int <System.Runtime.InteropServices.ComTypes.IEnumVARIANT.Reset>b__203_0();
}
internal class Microsoft.ClearScript.HostItemCollateral : object {
    public CollateralObject`1<IDynamic> TargetDynamic;
    public CollateralObject`1<IPropertyBag> TargetPropertyBag;
    public CollateralObject`1<IHostList> TargetList;
    public CollateralObject`1<DynamicHostMetaObject> TargetDynamicMetaObject;
    public CollateralObject`1<IEnumerator> TargetEnumerator;
    public CollateralObject`1<HashSet`1<string>> ExpandoMemberNames;
    public CollateralObject`1<ListDataFields> ListData;
    public CollateralObject`1<Dictionary`2<string, HostMethod>> HostMethodMap;
    public CollateralObject`1<Dictionary`2<string, HostIndexedProperty>> HostIndexedPropertyMap;
}
[FlagsAttribute]
public enum Microsoft.ClearScript.HostItemFlags : Enum {
    public int value__;
    public static HostItemFlags None;
    public static HostItemFlags GlobalMembers;
    public static HostItemFlags PrivateAccess;
    public static HostItemFlags HideDynamicMembers;
    public static HostItemFlags DirectAccess;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ClearScript.HostList : object {
    private ScriptEngine engine;
    private IList list;
    private Type elementType;
    public int Count { get; }
    public object Item { get; public set; }
    public HostList(ScriptEngine engine, IList list, Type elementType);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ClearScript.HostList`1 : object {
    private ScriptEngine engine;
    private IList`1<T> list;
    public int Count { get; }
    public object Item { get; public set; }
    public HostList`1(ScriptEngine engine, IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
internal class Microsoft.ClearScript.HostMethod : HostTarget {
    private HostItem target;
    private string name;
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    public HostMethod(HostItem target, string name);
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
}
internal class Microsoft.ClearScript.HostObject : HostTarget {
    private object target;
    private Type type;
    private static MethodInfo getNullWrapperGenericMethod;
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    private HostObject(object target, Type type);
    private static HostObject();
    public static HostObject Wrap(object target);
    public static HostObject Wrap(object target, Type type);
    public static object WrapResult(object result, Type type, bool wrapNull);
    private static HostObject GetNullWrapper(Type type);
    private static HostObject GetNullWrapperGeneric();
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
}
public static class Microsoft.ClearScript.HostSettings : object {
    private static CustomAttributeLoader customAttributeLoader;
    [CompilerGeneratedAttribute]
private static bool <UseAssemblyTable>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AuxiliarySearchPath>k__BackingField;
    public static bool UseAssemblyTable { get; public set; }
    public static string AuxiliarySearchPath { get; public set; }
    public static CustomAttributeLoader CustomAttributeLoader { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_UseAssemblyTable();
    [CompilerGeneratedAttribute]
public static void set_UseAssemblyTable(bool value);
    [CompilerGeneratedAttribute]
public static string get_AuxiliarySearchPath();
    [CompilerGeneratedAttribute]
public static void set_AuxiliarySearchPath(string value);
    public static CustomAttributeLoader get_CustomAttributeLoader();
    public static void set_CustomAttributeLoader(CustomAttributeLoader value);
}
internal abstract class Microsoft.ClearScript.HostTarget : object {
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    public abstract virtual Type get_Type();
    public abstract virtual object get_Target();
    public abstract virtual object get_InvokeTarget();
    public abstract virtual object get_DynamicInvokeTarget();
    public abstract virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual String[] GetAuxMethodNames(IHostContext context, BindingFlags bindFlags);
    public virtual String[] GetAuxPropertyNames(IHostContext context, BindingFlags bindFlags);
    public virtual bool TryInvokeAuxMember(IHostContext context, string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public abstract virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
}
[FlagsAttribute]
internal enum Microsoft.ClearScript.HostTargetFlags : Enum {
    public int value__;
    public static HostTargetFlags None;
    public static HostTargetFlags AllowStaticMembers;
    public static HostTargetFlags AllowInstanceMembers;
    public static HostTargetFlags AllowExtensionMethods;
}
internal class Microsoft.ClearScript.HostTargetMemberData : object {
    public String[] TypeEventNames;
    public String[] TypeFieldNames;
    public String[] TypeMethodNames;
    public String[] TypePropertyNames;
    public String[] AllFieldNames;
    public String[] AllMethodNames;
    public String[] OwnMethodNames;
    public String[] AllPropertyNames;
    public String[] AllMemberNames;
    public FieldInfo[] AllFields;
    public MethodInfo[] AllMethods;
    public PropertyInfo[] AllProperties;
    public object EnumerationSettingsToken;
    public ExtensionMethodSummary ExtensionMethodSummary;
    public Nullable`1<Invocability> TargetInvocability;
}
internal class Microsoft.ClearScript.HostTargetMemberDataWithContext : HostTargetMemberData {
    public CustomAttributeLoader CustomAttributeLoader;
    public Type AccessContext;
    public ScriptAccess DefaultAccess;
    public HostTargetFlags TargetFlags;
    public HostTargetMemberDataWithContext(CustomAttributeLoader customAttributeLoader, Type accessContext, ScriptAccess defaultAccess, HostTargetFlags targetFlags);
}
internal class Microsoft.ClearScript.HostType : HostTarget {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    public Type[] Types { get; }
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    private HostType(Type type);
    private HostType(Type[] types);
    public static HostType Wrap(Type type);
    public static HostType Wrap(Type[] types);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    public Type GetSpecificType();
    public Type GetTypeArg();
    public Type GetTypeArgNoThrow();
    private Type GetSpecificTypeNoThrow();
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual String[] GetAuxPropertyNames(IHostContext context, BindingFlags bindFlags);
    public virtual bool TryInvokeAuxMember(IHostContext context, string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    private sealed virtual override void Microsoft.ClearScript.IScriptableObject.OnExposedToScriptCode(ScriptEngine engine);
}
public class Microsoft.ClearScript.HostTypeCollection : PropertyBag {
    private static Predicate`1<Type> defaultFilter;
    private static TypeComparer typeComparer;
    public HostTypeCollection(Assembly[] assemblies);
    public HostTypeCollection(String[] assemblyNames);
    public HostTypeCollection(Predicate`1<Type> filter, Assembly[] assemblies);
    public HostTypeCollection(Predicate`1<Type> filter, String[] assemblyNames);
    private static HostTypeCollection();
    public void AddAssembly(Assembly assembly);
    public void AddAssembly(string assemblyName);
    public void AddAssembly(Assembly assembly, Predicate`1<Type> filter);
    public void AddAssembly(string assemblyName, Predicate`1<Type> filter);
    public void AddType(Type type);
    public void AddType(string typeName, Type[] typeArgs);
    public void AddType(string typeName, string assemblyName, Type[] typeArgs);
    public PropertyBag GetNamespaceNode(string name);
    internal void AddEnumTypeInfo(ITypeInfo typeInfo);
    private PropertyBag AddEnumTypeInfoInternal(ITypeInfo typeInfo);
    private PropertyBag GetOrCreateEnumTypeInfoNode(ITypeInfo typeInfo);
    private void AddType(HostType hostType);
    private PropertyBag GetOrCreateNamespaceNode(Type type);
    private PropertyBag GetOrCreateNamespaceNode(string locator);
    private static void AddTypeToNamespaceNode(PropertyBag node, Type type);
    private static Type ResolveTypeConflict(IEnumerable`1<Type> types);
}
internal abstract class Microsoft.ClearScript.HostVariable : HostTarget {
    private static String[] auxPropertyNames;
    private static HostVariable();
    public virtual String[] GetAuxPropertyNames(IHostContext context, BindingFlags bindFlags);
}
internal class Microsoft.ClearScript.HostVariable`1 : HostVariable {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    private object Microsoft.ClearScript.IHostVariable.Value { get; private set; }
    public HostVariable`1(T initValue);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual bool TryInvokeAuxMember(IHostContext context, string name, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    private sealed virtual override object Microsoft.ClearScript.IHostVariable.get_Value();
    private sealed virtual override void Microsoft.ClearScript.IHostVariable.set_Value(object value);
}
internal interface Microsoft.ClearScript.IByRefArg {
    public Type Type { get; }
    public object Value { get; public set; }
    public abstract virtual Type get_Type();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.ClearScript.IHostList {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
internal interface Microsoft.ClearScript.IHostVariable {
    public Type Type { get; }
    public object Value { get; public set; }
    public abstract virtual Type get_Type();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[AttributeUsageAttribute("8")]
public class Microsoft.ClearScript.ImmutableValueAttribute : Attribute {
}
internal enum Microsoft.ClearScript.Invocability : Enum {
    public int value__;
    public static Invocability None;
    public static Invocability Delegate;
    public static Invocability Dynamic;
    public static Invocability DefaultProperty;
}
internal interface Microsoft.ClearScript.IOutArg {
}
public interface Microsoft.ClearScript.IPropertyBag {
}
internal interface Microsoft.ClearScript.IRefArg {
}
public interface Microsoft.ClearScript.IScriptableObject {
    public abstract virtual void OnExposedToScriptCode(ScriptEngine engine);
}
public interface Microsoft.ClearScript.IScriptEngine {
    public string Name { get; }
    public string FileNameExtension { get; }
    public Type AccessContext { get; public set; }
    public ScriptAccess DefaultAccess { get; public set; }
    public bool EnforceAnonymousTypeAccess { get; public set; }
    public bool ExposeHostObjectStaticMembers { get; public set; }
    public bool DisableExtensionMethods { get; public set; }
    public bool FormatCode { get; public set; }
    public bool AllowReflection { get; public set; }
    public bool DisableTypeRestriction { get; public set; }
    public bool DisableListIndexTypeRestriction { get; public set; }
    public bool EnableNullResultWrapping { get; public set; }
    public bool DisableFloatNarrowing { get; public set; }
    public bool DisableDynamicBinding { get; public set; }
    public bool UseReflectionBindFallback { get; public set; }
    public bool EnableAutoHostVariables { get; public set; }
    public object UndefinedImportValue { get; public set; }
    public object NullExportValue { get; public set; }
    public object VoidResultValue { get; public set; }
    public ContinuationCallback ContinuationCallback { get; public set; }
    [DynamicAttribute]
public object Script { get; }
    public ScriptObject Global { get; }
    public DocumentSettings DocumentSettings { get; public set; }
    public CustomAttributeLoader CustomAttributeLoader { get; public set; }
    public object HostData { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual string get_FileNameExtension();
    public abstract virtual Type get_AccessContext();
    public abstract virtual void set_AccessContext(Type value);
    public abstract virtual ScriptAccess get_DefaultAccess();
    public abstract virtual void set_DefaultAccess(ScriptAccess value);
    public abstract virtual bool get_EnforceAnonymousTypeAccess();
    public abstract virtual void set_EnforceAnonymousTypeAccess(bool value);
    public abstract virtual bool get_ExposeHostObjectStaticMembers();
    public abstract virtual void set_ExposeHostObjectStaticMembers(bool value);
    public abstract virtual bool get_DisableExtensionMethods();
    public abstract virtual void set_DisableExtensionMethods(bool value);
    public abstract virtual bool get_FormatCode();
    public abstract virtual void set_FormatCode(bool value);
    public abstract virtual bool get_AllowReflection();
    public abstract virtual void set_AllowReflection(bool value);
    public abstract virtual bool get_DisableTypeRestriction();
    public abstract virtual void set_DisableTypeRestriction(bool value);
    public abstract virtual bool get_DisableListIndexTypeRestriction();
    public abstract virtual void set_DisableListIndexTypeRestriction(bool value);
    public abstract virtual bool get_EnableNullResultWrapping();
    public abstract virtual void set_EnableNullResultWrapping(bool value);
    public abstract virtual bool get_DisableFloatNarrowing();
    public abstract virtual void set_DisableFloatNarrowing(bool value);
    public abstract virtual bool get_DisableDynamicBinding();
    public abstract virtual void set_DisableDynamicBinding(bool value);
    public abstract virtual bool get_UseReflectionBindFallback();
    public abstract virtual void set_UseReflectionBindFallback(bool value);
    public abstract virtual bool get_EnableAutoHostVariables();
    public abstract virtual void set_EnableAutoHostVariables(bool value);
    public abstract virtual object get_UndefinedImportValue();
    public abstract virtual void set_UndefinedImportValue(object value);
    public abstract virtual object get_NullExportValue();
    public abstract virtual void set_NullExportValue(object value);
    public abstract virtual object get_VoidResultValue();
    public abstract virtual void set_VoidResultValue(object value);
    public abstract virtual ContinuationCallback get_ContinuationCallback();
    public abstract virtual void set_ContinuationCallback(ContinuationCallback value);
    public abstract virtual object get_Script();
    public abstract virtual ScriptObject get_Global();
    public abstract virtual DocumentSettings get_DocumentSettings();
    public abstract virtual void set_DocumentSettings(DocumentSettings value);
    public abstract virtual CustomAttributeLoader get_CustomAttributeLoader();
    public abstract virtual void set_CustomAttributeLoader(CustomAttributeLoader value);
    public abstract virtual object get_HostData();
    public abstract virtual void set_HostData(object value);
    public abstract virtual void AddHostObject(string itemName, object target);
    public abstract virtual void AddHostObject(string itemName, HostItemFlags flags, object target);
    public abstract virtual void AddRestrictedHostObject(string itemName, T target);
    public abstract virtual void AddRestrictedHostObject(string itemName, HostItemFlags flags, T target);
    public abstract virtual void AddCOMObject(string itemName, string progID);
    public abstract virtual void AddCOMObject(string itemName, string progID, string serverName);
    public abstract virtual void AddCOMObject(string itemName, HostItemFlags flags, string progID);
    public abstract virtual void AddCOMObject(string itemName, HostItemFlags flags, string progID, string serverName);
    public abstract virtual void AddCOMObject(string itemName, Guid clsid);
    public abstract virtual void AddCOMObject(string itemName, Guid clsid, string serverName);
    public abstract virtual void AddCOMObject(string itemName, HostItemFlags flags, Guid clsid);
    public abstract virtual void AddCOMObject(string itemName, HostItemFlags flags, Guid clsid, string serverName);
    public abstract virtual void AddHostType(Type type);
    public abstract virtual void AddHostType(HostItemFlags flags, Type type);
    public abstract virtual void AddHostType(string itemName, Type type);
    public abstract virtual void AddHostType(string itemName, HostItemFlags flags, Type type);
    public abstract virtual void AddHostType(string itemName, string typeName, Type[] typeArgs);
    public abstract virtual void AddHostType(string itemName, HostItemFlags flags, string typeName, Type[] typeArgs);
    public abstract virtual void AddHostType(string itemName, string typeName, string assemblyName, Type[] typeArgs);
    public abstract virtual void AddHostType(string itemName, HostItemFlags flags, string typeName, string assemblyName, Type[] typeArgs);
    public abstract virtual void AddHostTypes(Type[] types);
    public abstract virtual void AddCOMType(string itemName, string progID);
    public abstract virtual void AddCOMType(string itemName, string progID, string serverName);
    public abstract virtual void AddCOMType(string itemName, HostItemFlags flags, string progID);
    public abstract virtual void AddCOMType(string itemName, HostItemFlags flags, string progID, string serverName);
    public abstract virtual void AddCOMType(string itemName, Guid clsid);
    public abstract virtual void AddCOMType(string itemName, Guid clsid, string serverName);
    public abstract virtual void AddCOMType(string itemName, HostItemFlags flags, Guid clsid);
    public abstract virtual void AddCOMType(string itemName, HostItemFlags flags, Guid clsid, string serverName);
    public abstract virtual void Execute(string code);
    public abstract virtual void Execute(string documentName, string code);
    public abstract virtual void Execute(string documentName, bool discard, string code);
    public abstract virtual void Execute(DocumentInfo documentInfo, string code);
    public abstract virtual void ExecuteDocument(string specifier);
    public abstract virtual void ExecuteDocument(string specifier, DocumentCategory category);
    public abstract virtual void ExecuteDocument(string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public abstract virtual string ExecuteCommand(string command);
    public abstract virtual object Evaluate(string code);
    public abstract virtual object Evaluate(string documentName, string code);
    public abstract virtual object Evaluate(string documentName, bool discard, string code);
    public abstract virtual object Evaluate(DocumentInfo documentInfo, string code);
    public abstract virtual object EvaluateDocument(string specifier);
    public abstract virtual object EvaluateDocument(string specifier, DocumentCategory category);
    public abstract virtual object EvaluateDocument(string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public abstract virtual object Invoke(string funcName, Object[] args);
    public abstract virtual string GetStackTrace();
    public abstract virtual void Interrupt();
    public abstract virtual void CollectGarbage(bool exhaustive);
}
public interface Microsoft.ClearScript.IScriptEngineException {
    public string Message { get; }
    public int HResult { get; }
    public string EngineName { get; }
    public string ErrorDetails { get; }
    public bool IsFatal { get; }
    public bool ExecutionStarted { get; }
    [DynamicAttribute]
public object ScriptException { get; }
    public object ScriptExceptionAsObject { get; }
    public Exception InnerException { get; }
    public abstract virtual string get_Message();
    public abstract virtual int get_HResult();
    public abstract virtual string get_EngineName();
    public abstract virtual string get_ErrorDetails();
    public abstract virtual bool get_IsFatal();
    public abstract virtual bool get_ExecutionStarted();
    public abstract virtual object get_ScriptException();
    public abstract virtual object get_ScriptExceptionAsObject();
    public abstract virtual Exception get_InnerException();
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.ClearScript.IScriptObject {
    public ScriptEngine Engine { get; }
    public IEnumerable`1<string> PropertyNames { get; }
    public object Item { get; public set; }
    public IEnumerable`1<int> PropertyIndices { get; }
    public object Item { get; public set; }
    public abstract virtual ScriptEngine get_Engine();
    public abstract virtual object GetProperty(string name, Object[] args);
    public abstract virtual void SetProperty(string name, Object[] args);
    public abstract virtual bool DeleteProperty(string name);
    public abstract virtual IEnumerable`1<string> get_PropertyNames();
    public abstract virtual object get_Item(string name, Object[] args);
    public abstract virtual void set_Item(string name, Object[] args, object value);
    public abstract virtual object GetProperty(int index);
    public abstract virtual void SetProperty(int index, object value);
    public abstract virtual bool DeleteProperty(int index);
    public abstract virtual IEnumerable`1<int> get_PropertyIndices();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual object Invoke(bool asConstructor, Object[] args);
    public abstract virtual object InvokeMethod(string name, Object[] args);
    public abstract virtual object InvokeAsFunction(Object[] args);
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
public class Microsoft.ClearScript.JavaScript.CommonJSLegacyModule : object {
    private ScriptObject context;
    private Func`2<ScriptObject, ScriptObject> initializeContext;
    private ScriptObject initializedContext;
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <uri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <exports>k__BackingField;
    public string id { get; }
    public string uri { get; }
    public object exports { get; public set; }
    public object meta { get; }
    public CommonJSLegacyModule(string id, string uri, object exports, ScriptObject context, Func`2<ScriptObject, ScriptObject> initializeContext);
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public string get_uri();
    [CompilerGeneratedAttribute]
public object get_exports();
    [CompilerGeneratedAttribute]
public void set_exports(object value);
    public object get_meta();
    private ScriptObject GetInitializedContext();
}
internal class Microsoft.ClearScript.JavaScript.CommonJSManager : object {
    private ScriptEngine engine;
    private ScriptObject createModule;
    private List`1<Module> moduleCache;
    private static DocumentInfo createModuleInfo;
    public int ModuleCacheSize { get; }
    public CommonJSManager(ScriptEngine engine);
    private static CommonJSManager();
    public int get_ModuleCacheSize();
    public Module GetOrCreateModule(UniqueDocumentInfo documentInfo, string code);
    public Module GetOrCreateModule(UniqueDocumentInfo documentInfo, UIntPtr codeDigest, Func`1<object> evaluator);
    private Module GetCachedModule(UniqueDocumentInfo documentInfo, UIntPtr codeDigest);
    private Module CacheModule(Module module);
}
public interface Microsoft.ClearScript.JavaScript.IArrayBuffer {
    public ulong Size { get; }
    public abstract virtual ulong get_Size();
    public abstract virtual Byte[] GetBytes();
    public abstract virtual ulong ReadBytes(ulong offset, ulong count, Byte[] destination, ulong destinationIndex);
    public abstract virtual ulong WriteBytes(Byte[] source, ulong sourceIndex, ulong count, ulong offset);
    public abstract virtual void InvokeWithDirectAccess(Action`1<IntPtr> action);
    public abstract virtual T InvokeWithDirectAccess(Func`2<IntPtr, T> func);
}
public interface Microsoft.ClearScript.JavaScript.IArrayBufferView {
    public IArrayBuffer ArrayBuffer { get; }
    public ulong Offset { get; }
    public ulong Size { get; }
    public abstract virtual IArrayBuffer get_ArrayBuffer();
    public abstract virtual ulong get_Offset();
    public abstract virtual ulong get_Size();
    public abstract virtual Byte[] GetBytes();
    public abstract virtual ulong ReadBytes(ulong offset, ulong count, Byte[] destination, ulong destinationIndex);
    public abstract virtual ulong WriteBytes(Byte[] source, ulong sourceIndex, ulong count, ulong offset);
    public abstract virtual void InvokeWithDirectAccess(Action`1<IntPtr> action);
    public abstract virtual T InvokeWithDirectAccess(Func`2<IntPtr, T> func);
}
public interface Microsoft.ClearScript.JavaScript.IDataView {
}
internal interface Microsoft.ClearScript.JavaScript.IJavaScriptEngine {
    public UInt32 BaseLanguageVersion { get; }
    public CommonJSManager CommonJSManager { get; }
    public JsonModuleManager JsonModuleManager { get; }
    public abstract virtual UInt32 get_BaseLanguageVersion();
    public abstract virtual CommonJSManager get_CommonJSManager();
    public abstract virtual JsonModuleManager get_JsonModuleManager();
    public abstract virtual object CreatePromiseForTask(Task`1<T> task);
    public abstract virtual object CreatePromiseForTask(Task task);
    public abstract virtual Task`1<object> CreateTaskForPromise(ScriptObject promise);
}
public interface Microsoft.ClearScript.JavaScript.IJavaScriptObject {
    public JavaScriptObjectKind Kind { get; }
    public JavaScriptObjectFlags Flags { get; }
    public abstract virtual JavaScriptObjectKind get_Kind();
    public abstract virtual JavaScriptObjectFlags get_Flags();
}
public interface Microsoft.ClearScript.JavaScript.ITypedArray {
    public ulong Length { get; }
    public abstract virtual ulong get_Length();
}
public interface Microsoft.ClearScript.JavaScript.ITypedArray`1 {
    public abstract virtual T[] ToArray();
    public abstract virtual ulong Read(ulong index, ulong length, T[] destination, ulong destinationIndex);
    public abstract virtual ulong Write(T[] source, ulong sourceIndex, ulong length, ulong index);
}
[ExtensionAttribute]
public static class Microsoft.ClearScript.JavaScript.JavaScriptExtensions : object {
    [ExtensionAttribute]
public static object ToPromise(Task`1<T> task);
    [ExtensionAttribute]
public static object ToPromise(Task`1<T> task, ScriptEngine engine);
    [ExtensionAttribute]
public static object ToPromise(Task task);
    [ExtensionAttribute]
public static object ToPromise(Task task, ScriptEngine engine);
    [ExtensionAttribute]
public static Task`1<object> ToTask(object promise);
    [ExtensionAttribute]
public static IEnumerable`1<object> ToEnumerable(object iterable);
    [ExtensionAttribute]
private static Task`1<object> ToTaskInternal(object promise);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.JavaScript.JavaScriptExtensions/<ToEnumerableInternal>d__7")]
[ExtensionAttribute]
private static IEnumerable`1<object> ToEnumerableInternal(object iterable);
}
[FlagsAttribute]
public enum Microsoft.ClearScript.JavaScript.JavaScriptObjectFlags : Enum {
    public int value__;
    public static JavaScriptObjectFlags None;
    public static JavaScriptObjectFlags Shared;
    public static JavaScriptObjectFlags Async;
    public static JavaScriptObjectFlags Generator;
}
public enum Microsoft.ClearScript.JavaScript.JavaScriptObjectKind : Enum {
    public int value__;
    public static JavaScriptObjectKind Unknown;
    public static JavaScriptObjectKind Function;
    public static JavaScriptObjectKind Iterator;
    public static JavaScriptObjectKind Promise;
    public static JavaScriptObjectKind Array;
    public static JavaScriptObjectKind ArrayBuffer;
    public static JavaScriptObjectKind DataView;
    public static JavaScriptObjectKind TypedArray;
}
internal class Microsoft.ClearScript.JavaScript.JsonModuleManager : object {
    private ScriptEngine engine;
    private List`1<Module> moduleCache;
    public int ModuleCacheSize { get; }
    public JsonModuleManager(ScriptEngine engine);
    public int get_ModuleCacheSize();
    public Module GetOrCreateModule(UniqueDocumentInfo documentInfo, string json);
    private Module GetCachedModule(UniqueDocumentInfo documentInfo, UIntPtr jsonDigest);
    private Module CacheModule(Module module);
}
public static class Microsoft.ClearScript.JavaScript.ModuleCategory : object {
    public static DocumentCategory Standard { get; }
    public static DocumentCategory CommonJS { get; }
    public static DocumentCategory get_Standard();
    public static DocumentCategory get_CommonJS();
}
[AttributeUsageAttribute("1053")]
public class Microsoft.ClearScript.NoDefaultScriptAccessAttribute : DefaultScriptUsageAttribute {
}
[AttributeUsageAttribute("2044")]
public class Microsoft.ClearScript.NoScriptAccessAttribute : ScriptUsageAttribute {
}
internal class Microsoft.ClearScript.OutArg`1 : ByRefArg`1<T> {
    public OutArg`1(HostVariable`1<T> target);
    public OutArg`1(T initValue);
    public virtual string ToString();
}
internal static class Microsoft.ClearScript.Properties.ClearScriptVersion : object {
    public static string Triad;
    public static string Informational;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.ClearScript.PropertyBag : object {
    private IDictionary`2<string, object> dictionary;
    private bool isReadOnly;
    private ConcurrentWeakSet`1<ScriptEngine> engineSet;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<string> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IEqualityComparer`1<string> Comparer { get; }
    internal int EngineCount { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public PropertyBag(bool isReadOnly);
    public PropertyBag(IEqualityComparer`1<string> comparer);
    public PropertyBag(bool isReadOnly, IEqualityComparer`1<string> comparer);
    internal PropertyBag(bool isReadOnly, IEqualityComparer`1<string> comparer, IDictionary`2<string, object> dictionary);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<string> get_Comparer();
    public void SetPropertyNoCheck(string name, object value);
    public bool RemovePropertyNoCheck(string name);
    public void ClearNoCheck();
    internal int get_EngineCount();
    private void CheckReadOnly();
    private void AddPropertyNoCheck(string name, object value);
    private void NotifyPropertyChanged(string name);
    private void NotifyExposedToScriptCode(object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void Microsoft.ClearScript.IScriptableObject.OnExposedToScriptCode(ScriptEngine engine);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.ClearScript.ReadOnlyHostList`1 : object {
    private ScriptEngine engine;
    private IReadOnlyList`1<T> list;
    public int Count { get; }
    public object Item { get; public set; }
    public ReadOnlyHostList`1(ScriptEngine engine, IReadOnlyList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
internal class Microsoft.ClearScript.RefArg`1 : ByRefArg`1<T> {
    public RefArg`1(HostVariable`1<T> target);
    public RefArg`1(T initValue);
    public virtual string ToString();
}
public enum Microsoft.ClearScript.ScriptAccess : Enum {
    public int value__;
    public static ScriptAccess Full;
    public static ScriptAccess ReadOnly;
    public static ScriptAccess None;
}
public abstract class Microsoft.ClearScript.ScriptEngine : object {
    private Type accessContext;
    private ScriptAccess defaultAccess;
    private bool enforceAnonymousTypeAccess;
    private bool exposeHostObjectStaticMembers;
    private CustomAttributeLoader customAttributeLoader;
    private DocumentSettings documentSettings;
    private DocumentSettings defaultDocumentSettings;
    private static IUniqueNameManager nameManager;
    private static object nullHostObjectProxy;
    [ThreadStaticAttribute]
private static ScriptEngine currentEngine;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowReflection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableTypeRestriction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableListIndexTypeRestriction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNullResultWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFloatNarrowing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableDynamicBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseReflectionBindFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableAutoHostVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UndefinedImportValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NullExportValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <VoidResultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ContinuationCallback <ContinuationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private object <HostData>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptFrame <CurrentScriptFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EnumerationSettingsToken>k__BackingField;
    private static ExtensionMethodTable emptyExtensionMethodTable;
    private ExtensionMethodTable realExtensionMethodTable;
    private ExtensionMethodTable extensionMethodTable;
    private Dictionary`2<BindSignature, ConstructorInfo> constructorBindCache;
    private Dictionary`2<BindSignature, object> methodBindCache;
    private Dictionary`2<BindSignature, MemberInfo> propertyGetBindCache;
    private Dictionary`2<BindSignature, MemberInfo> propertySetBindCache;
    private ConditionalWeakTable`2<object, List`1<WeakReference>> hostObjectHostItemCache;
    private ConditionalWeakTable`2<Type, List`1<WeakReference>> hostTypeHostItemCache;
    internal HostTargetMemberData SharedHostMethodMemberData;
    internal HostTargetMemberData SharedHostIndexedPropertyMemberData;
    internal HostTargetMemberData SharedScriptMethodMemberData;
    private ConditionalWeakTable`2<Type, List`1<WeakReference>> sharedHostObjectMemberDataCache;
    private EventConnectionMap eventConnectionMap;
    public static ScriptEngine Current { get; }
    public string Name { get; }
    public string FileNameExtension { get; }
    public Type AccessContext { get; public set; }
    public ScriptAccess DefaultAccess { get; public set; }
    public bool EnforceAnonymousTypeAccess { get; public set; }
    public bool ExposeHostObjectStaticMembers { get; public set; }
    public bool DisableExtensionMethods { get; public set; }
    public bool FormatCode { get; public set; }
    public bool AllowReflection { get; public set; }
    public bool DisableTypeRestriction { get; public set; }
    public bool DisableListIndexTypeRestriction { get; public set; }
    public bool EnableNullResultWrapping { get; public set; }
    public bool DisableFloatNarrowing { get; public set; }
    public bool DisableDynamicBinding { get; public set; }
    public bool UseReflectionBindFallback { get; public set; }
    public bool EnableAutoHostVariables { get; public set; }
    public object UndefinedImportValue { get; public set; }
    public object NullExportValue { get; public set; }
    public object VoidResultValue { get; public set; }
    public ContinuationCallback ContinuationCallback { get; public set; }
    [DynamicAttribute]
public object Script { get; }
    public ScriptObject Global { get; }
    public DocumentSettings DocumentSettings { get; public set; }
    public CustomAttributeLoader CustomAttributeLoader { get; public set; }
    public object HostData { get; public set; }
    internal IUniqueNameManager DocumentNameManager { get; }
    internal bool EnumerateInstanceMethods { get; }
    internal bool EnumerateExtensionMethods { get; }
    internal bool UseCaseInsensitiveMemberBinding { get; }
    internal ScriptFrame CurrentScriptFrame { get; private set; }
    internal object EnumerationSettingsToken { get; private set; }
    internal ExtensionMethodSummary ExtensionMethodSummary { get; }
    internal HostItemCollateral HostItemCollateral { get; }
    private ScriptEngine Microsoft.ClearScript.Util.IHostContext.Engine { get; }
    [ObsoleteAttribute("Use ScriptEngine(string name, string fileNameExtensions) instead.")]
protected ScriptEngine(string name);
    protected ScriptEngine(string name, string fileNameExtensions);
    private static ScriptEngine();
    public static ScriptEngine get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public abstract virtual string get_FileNameExtension();
    public sealed virtual Type get_AccessContext();
    public sealed virtual void set_AccessContext(Type value);
    public sealed virtual ScriptAccess get_DefaultAccess();
    public sealed virtual void set_DefaultAccess(ScriptAccess value);
    public sealed virtual bool get_EnforceAnonymousTypeAccess();
    public sealed virtual void set_EnforceAnonymousTypeAccess(bool value);
    public sealed virtual bool get_ExposeHostObjectStaticMembers();
    public sealed virtual void set_ExposeHostObjectStaticMembers(bool value);
    public sealed virtual bool get_DisableExtensionMethods();
    public sealed virtual void set_DisableExtensionMethods(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FormatCode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FormatCode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowReflection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowReflection(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableTypeRestriction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableTypeRestriction(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableListIndexTypeRestriction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableListIndexTypeRestriction(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableNullResultWrapping();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableNullResultWrapping(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableFloatNarrowing();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableFloatNarrowing(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableDynamicBinding();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableDynamicBinding(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseReflectionBindFallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseReflectionBindFallback(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableAutoHostVariables();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableAutoHostVariables(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_UndefinedImportValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UndefinedImportValue(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_NullExportValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NullExportValue(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_VoidResultValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VoidResultValue(object value);
    [CompilerGeneratedAttribute]
public sealed virtual ContinuationCallback get_ContinuationCallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContinuationCallback(ContinuationCallback value);
    public abstract virtual object get_Script();
    public abstract virtual ScriptObject get_Global();
    public sealed virtual DocumentSettings get_DocumentSettings();
    public sealed virtual void set_DocumentSettings(DocumentSettings value);
    public sealed virtual CustomAttributeLoader get_CustomAttributeLoader();
    public sealed virtual void set_CustomAttributeLoader(CustomAttributeLoader value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_HostData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostData(object value);
    public sealed virtual void AddHostObject(string itemName, object target);
    public sealed virtual void AddHostObject(string itemName, HostItemFlags flags, object target);
    public sealed virtual void AddRestrictedHostObject(string itemName, T target);
    public sealed virtual void AddRestrictedHostObject(string itemName, HostItemFlags flags, T target);
    public sealed virtual void AddCOMObject(string itemName, string progID);
    public sealed virtual void AddCOMObject(string itemName, string progID, string serverName);
    public sealed virtual void AddCOMObject(string itemName, HostItemFlags flags, string progID);
    public sealed virtual void AddCOMObject(string itemName, HostItemFlags flags, string progID, string serverName);
    public sealed virtual void AddCOMObject(string itemName, Guid clsid);
    public sealed virtual void AddCOMObject(string itemName, Guid clsid, string serverName);
    public sealed virtual void AddCOMObject(string itemName, HostItemFlags flags, Guid clsid);
    public sealed virtual void AddCOMObject(string itemName, HostItemFlags flags, Guid clsid, string serverName);
    public sealed virtual void AddHostType(Type type);
    public sealed virtual void AddHostType(HostItemFlags flags, Type type);
    public sealed virtual void AddHostType(string itemName, Type type);
    public sealed virtual void AddHostType(string itemName, HostItemFlags flags, Type type);
    public sealed virtual void AddHostType(string itemName, string typeName, Type[] typeArgs);
    public sealed virtual void AddHostType(string itemName, HostItemFlags flags, string typeName, Type[] typeArgs);
    public sealed virtual void AddHostType(string itemName, string typeName, string assemblyName, Type[] typeArgs);
    public sealed virtual void AddHostType(string itemName, HostItemFlags flags, string typeName, string assemblyName, Type[] typeArgs);
    public sealed virtual void AddHostTypes(Type[] types);
    public sealed virtual void AddCOMType(string itemName, string progID);
    public sealed virtual void AddCOMType(string itemName, string progID, string serverName);
    public sealed virtual void AddCOMType(string itemName, HostItemFlags flags, string progID);
    public sealed virtual void AddCOMType(string itemName, HostItemFlags flags, string progID, string serverName);
    public sealed virtual void AddCOMType(string itemName, Guid clsid);
    public sealed virtual void AddCOMType(string itemName, Guid clsid, string serverName);
    public sealed virtual void AddCOMType(string itemName, HostItemFlags flags, Guid clsid);
    public sealed virtual void AddCOMType(string itemName, HostItemFlags flags, Guid clsid, string serverName);
    public sealed virtual void Execute(string code);
    public sealed virtual void Execute(string documentName, string code);
    public sealed virtual void Execute(string documentName, bool discard, string code);
    public sealed virtual void Execute(DocumentInfo documentInfo, string code);
    public sealed virtual void ExecuteDocument(string specifier);
    public sealed virtual void ExecuteDocument(string specifier, DocumentCategory category);
    public sealed virtual void ExecuteDocument(string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public virtual string ExecuteCommand(string command);
    public sealed virtual object Evaluate(string code);
    public sealed virtual object Evaluate(string documentName, string code);
    public sealed virtual object Evaluate(string documentName, bool discard, string code);
    public sealed virtual object Evaluate(DocumentInfo documentInfo, string code);
    public sealed virtual object EvaluateDocument(string specifier);
    public sealed virtual object EvaluateDocument(string specifier, DocumentCategory category);
    public sealed virtual object EvaluateDocument(string specifier, DocumentCategory category, DocumentContextCallback contextCallback);
    public sealed virtual object Invoke(string funcName, Object[] args);
    public abstract virtual string GetStackTrace();
    public abstract virtual void Interrupt();
    public abstract virtual void CollectGarbage(bool exhaustive);
    internal abstract virtual IUniqueNameManager get_DocumentNameManager();
    internal virtual bool get_EnumerateInstanceMethods();
    internal virtual bool get_EnumerateExtensionMethods();
    internal virtual bool get_UseCaseInsensitiveMemberBinding();
    internal abstract virtual void AddHostItem(string itemName, HostItemFlags flags, object item);
    internal object PrepareResult(T result, ScriptMemberFlags flags, bool isListIndexResult);
    internal virtual object PrepareResult(object result, Type type, ScriptMemberFlags flags, bool isListIndexResult);
    internal abstract virtual object MarshalToScript(object obj, HostItemFlags flags);
    internal object MarshalToScript(object obj);
    internal Object[] MarshalToScript(Object[] args);
    internal abstract virtual object MarshalToHost(object obj, bool preserveHostTarget);
    internal Object[] MarshalToHost(Object[] args, bool preserveHostTargets);
    internal abstract virtual object Execute(UniqueDocumentInfo documentInfo, string code, bool evaluate);
    internal abstract virtual object ExecuteRaw(UniqueDocumentInfo documentInfo, string code, bool evaluate);
    internal object Evaluate(UniqueDocumentInfo documentInfo, string code, bool marshalResult);
    internal string GetCommandResultString(object result);
    internal void RequestInterrupt();
    internal void CheckReflection();
    internal virtual void OnAccessSettingsChanged();
    internal virtual void HostInvoke(Action action);
    internal virtual T HostInvoke(Func`1<T> func);
    [CompilerGeneratedAttribute]
internal ScriptFrame get_CurrentScriptFrame();
    [CompilerGeneratedAttribute]
private void set_CurrentScriptFrame(ScriptFrame value);
    internal IDisposable CreateEngineScope();
    internal virtual void ScriptInvoke(Action action);
    internal virtual T ScriptInvoke(Func`1<T> func);
    internal void ScriptInvokeInternal(Action action);
    internal T ScriptInvokeInternal(Func`1<T> func);
    internal void ThrowScriptError();
    internal static void ThrowScriptError(IScriptEngineException scriptError);
    internal virtual void SyncInvoke(Action action);
    internal virtual T SyncInvoke(Func`1<T> func);
    [CompilerGeneratedAttribute]
internal object get_EnumerationSettingsToken();
    [CompilerGeneratedAttribute]
private void set_EnumerationSettingsToken(object value);
    internal void OnEnumerationSettingsChanged();
    internal void ProcessExtensionMethodType(Type type);
    internal ExtensionMethodSummary get_ExtensionMethodSummary();
    internal void RebuildExtensionMethodSummary();
    internal void CacheConstructorBindResult(BindSignature signature, ConstructorInfo result);
    internal bool TryGetCachedConstructorBindResult(BindSignature signature, ConstructorInfo& result);
    private void ClearConstructorBindCache();
    internal void CacheMethodBindResult(BindSignature signature, object result);
    internal bool TryGetCachedMethodBindResult(BindSignature signature, Object& result);
    private void ClearMethodBindCache();
    internal void CachePropertyGetBindResult(BindSignature signature, MemberInfo property);
    internal bool TryGetCachedPropertyGetBindResult(BindSignature signature, MemberInfo& property);
    internal void CachePropertySetBindResult(BindSignature signature, MemberInfo property);
    internal bool TryGetCachedPropertySetBindResult(BindSignature signature, MemberInfo& property);
    private void ClearPropertyBindCache();
    internal HostItem GetOrCreateHostItem(HostTarget target, HostItemFlags flags, CreateFunc createHostItem);
    private HostItem GetOrCreateHostItemForHostObject(HostTarget hostTarget, object target, HostItemFlags flags, CreateFunc createHostItem);
    private HostItem GetOrCreateHostItemForHostType(HostType hostType, HostItemFlags flags, CreateFunc createHostItem);
    private HostItem CreateHostItem(HostTarget hostTarget, HostItemFlags flags, CreateFunc createHostItem, List`1<WeakReference> cacheEntry);
    internal abstract virtual HostItemCollateral get_HostItemCollateral();
    internal HostTargetMemberData GetSharedHostObjectMemberData(HostObject target, CustomAttributeLoader targetCustomAttributeLoader, Type targetAccessContext, ScriptAccess targetDefaultAccess, HostTargetFlags targetFlags);
    internal EventConnection CreateEventConnection(Type handlerType, object source, EventInfo eventInfo, Delegate handler);
    internal EventConnection`1<T> CreateEventConnection(object source, EventInfo eventInfo, Delegate handler);
    internal void BreakEventConnection(EventConnection connection);
    private void BreakAllEventConnections();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private sealed virtual override ScriptEngine Microsoft.ClearScript.Util.IHostContext.get_Engine();
    [CompilerGeneratedAttribute]
private ScriptEngine <CreateEngineScope>b__177_0();
}
public class Microsoft.ClearScript.ScriptEngineException : InvalidOperationException {
    private string engineName;
    private static string engineNameItemName;
    private string errorDetails;
    private static string errorDetailsItemName;
    private bool isFatal;
    private static string isFatalItemName;
    private bool executionStarted;
    private static string executionStartedItemName;
    private object scriptException;
    private static string defaultMessage;
    private int Microsoft.ClearScript.IScriptEngineException.HResult { get; }
    public string EngineName { get; }
    public string ErrorDetails { get; }
    public bool IsFatal { get; }
    public bool ExecutionStarted { get; }
    [DynamicAttribute]
public object ScriptException { get; }
    public object ScriptExceptionAsObject { get; }
    public ScriptEngineException(string message);
    public ScriptEngineException(string message, Exception innerException);
    protected ScriptEngineException(SerializationInfo info, StreamingContext context);
    internal ScriptEngineException(string engineName, string message, string errorDetails, int errorCode, bool isFatal, bool executionStarted, object scriptException, Exception innerException);
    private sealed virtual override int Microsoft.ClearScript.IScriptEngineException.get_HResult();
    public sealed virtual string get_EngineName();
    public sealed virtual string get_ErrorDetails();
    public sealed virtual bool get_IsFatal();
    public sealed virtual bool get_ExecutionStarted();
    public sealed virtual object get_ScriptException();
    public sealed virtual object get_ScriptExceptionAsObject();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.ClearScript.ScriptInterruptedException : OperationCanceledException {
    private string engineName;
    private static string engineNameItemName;
    private string errorDetails;
    private static string errorDetailsItemName;
    private bool isFatal;
    private static string isFatalItemName;
    private bool executionStarted;
    private static string executionStartedItemName;
    private object scriptException;
    private static string defaultMessage;
    private int Microsoft.ClearScript.IScriptEngineException.HResult { get; }
    public string EngineName { get; }
    public string ErrorDetails { get; }
    public bool IsFatal { get; }
    public bool ExecutionStarted { get; }
    [DynamicAttribute]
public object ScriptException { get; }
    public object ScriptExceptionAsObject { get; }
    public ScriptInterruptedException(string message);
    public ScriptInterruptedException(string message, Exception innerException);
    protected ScriptInterruptedException(SerializationInfo info, StreamingContext context);
    internal ScriptInterruptedException(string engineName, string message, string errorDetails, int errorCode, bool isFatal, bool executionStarted, object scriptException, Exception innerException);
    private sealed virtual override int Microsoft.ClearScript.IScriptEngineException.get_HResult();
    public sealed virtual string get_EngineName();
    public sealed virtual string get_ErrorDetails();
    public sealed virtual bool get_IsFatal();
    public sealed virtual bool get_ExecutionStarted();
    public sealed virtual object get_ScriptException();
    public sealed virtual object get_ScriptExceptionAsObject();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.ClearScript.ScriptItem : ScriptObject {
    private static MethodInfo throwLastScriptErrorMethod;
    private static MethodInfo clearLastScriptErrorMethod;
    [ThreadStaticAttribute]
private static IScriptEngineException lastScriptError;
    public IEnumerable`1<string> PropertyNames { get; }
    public IEnumerable`1<int> PropertyIndices { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    public Type UnderlyingSystemType { get; }
    private static ScriptItem();
    public static void ThrowLastScriptError();
    public static void ClearLastScriptError();
    protected abstract virtual bool TryBindAndInvoke(DynamicMetaObjectBinder binder, Object[] args, Object& result);
    protected virtual Object[] AdjustInvokeArgs(Object[] args);
    private bool TryWrappedBindAndInvoke(DynamicMetaObjectBinder binder, Object[] wrappedArgs, Object& result);
    private bool TryWrappedInvokeOrInvokeMember(DynamicMetaObjectBinder binder, ParameterInfo[] parameters, Object[] args, Object& result);
    private String[] GetAllPropertyNames();
    private static DynamicMetaObject PostProcessBindResult(DynamicMetaObject result);
    public virtual IEnumerable`1<string> get_PropertyNames();
    public virtual IEnumerable`1<int> get_PropertyIndices();
    public virtual object get_Item(string name, Object[] args);
    public virtual void set_Item(string name, Object[] args, object value);
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public virtual DynamicMetaObject GetMetaObject(Expression param);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indices, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indices, object value);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindFlags, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindFlags);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindFlags);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindFlags);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindFlags);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindFlags);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindFlags, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindFlags);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindFlags);
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindFlags);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeFlags, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public sealed virtual Type get_UnderlyingSystemType();
    public sealed virtual FieldInfo AddField(string name);
    public sealed virtual PropertyInfo AddProperty(string name);
    public sealed virtual MethodInfo AddMethod(string name, Delegate method);
    public sealed virtual void RemoveMember(MemberInfo member);
    public sealed virtual object GetProperty(string name, Boolean& isCacheable, Object[] args);
    public abstract virtual String[] GetPropertyNames();
    public abstract virtual Int32[] GetPropertyIndices();
    public abstract virtual object Unwrap();
}
[AttributeUsageAttribute("960")]
public class Microsoft.ClearScript.ScriptMemberAttribute : ScriptUsageAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptMemberFlags <Flags>k__BackingField;
    public string Name { get; public set; }
    public ScriptMemberFlags Flags { get; public set; }
    public ScriptMemberAttribute(string name);
    public ScriptMemberAttribute(ScriptAccess access);
    public ScriptMemberAttribute(string name, ScriptAccess access);
    public ScriptMemberAttribute(ScriptMemberFlags flags);
    public ScriptMemberAttribute(string name, ScriptMemberFlags flags);
    public ScriptMemberAttribute(ScriptAccess access, ScriptMemberFlags flags);
    public ScriptMemberAttribute(string name, ScriptAccess access, ScriptMemberFlags flags);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ScriptMemberFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ScriptMemberFlags value);
}
[FlagsAttribute]
public enum Microsoft.ClearScript.ScriptMemberFlags : Enum {
    public int value__;
    public static ScriptMemberFlags None;
    public static ScriptMemberFlags ExposeRuntimeType;
    public static ScriptMemberFlags WrapNullResult;
}
internal class Microsoft.ClearScript.ScriptMethod : HostTarget {
    private ScriptItem target;
    private string name;
    public Type Type { get; }
    public object Target { get; }
    public object InvokeTarget { get; }
    public object DynamicInvokeTarget { get; }
    private Type System.Reflection.IReflect.UnderlyingSystemType { get; }
    public ScriptMethod(ScriptItem target, string name);
    public object Invoke(Object[] args);
    public virtual string ToString();
    public virtual Type get_Type();
    public virtual object get_Target();
    public virtual object get_InvokeTarget();
    public virtual object get_DynamicInvokeTarget();
    public virtual HostTargetFlags GetFlags(IHostContext context);
    public virtual bool TryInvoke(IHostContext context, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, Object& result);
    public virtual Invocability GetInvocability(IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string methodName, BindingFlags bindFlags, Binder binder, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string methodName, BindingFlags bindFlags);
    private sealed virtual override MethodInfo[] System.Reflection.IReflect.GetMethods(BindingFlags bindFlags);
    private sealed virtual override FieldInfo System.Reflection.IReflect.GetField(string fieldName, BindingFlags bindFlags);
    private sealed virtual override FieldInfo[] System.Reflection.IReflect.GetFields(BindingFlags bindFlags);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string propertyName, BindingFlags bindFlags);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string propertyName, BindingFlags bindFlags, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override PropertyInfo[] System.Reflection.IReflect.GetProperties(BindingFlags bindFlags);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMember(string memberName, BindingFlags bindFlags);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMembers(BindingFlags bindFlags);
    private sealed virtual override object System.Reflection.IReflect.InvokeMember(string memberName, BindingFlags invokeFlags, Binder binder, object invokeTarget, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    private sealed virtual override Type System.Reflection.IReflect.get_UnderlyingSystemType();
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.ClearScript.ScriptObject : DynamicObject {
    public ScriptEngine Engine { get; }
    public IEnumerable`1<string> PropertyNames { get; }
    public object Item { get; public set; }
    public IEnumerable`1<int> PropertyIndices { get; }
    public object Item { get; public set; }
    public abstract virtual ScriptEngine get_Engine();
    public abstract virtual object GetProperty(string name, Object[] args);
    public abstract virtual void SetProperty(string name, Object[] args);
    public abstract virtual bool DeleteProperty(string name);
    public abstract virtual IEnumerable`1<string> get_PropertyNames();
    public abstract virtual object get_Item(string name, Object[] args);
    public abstract virtual void set_Item(string name, Object[] args, object value);
    public abstract virtual object GetProperty(int index);
    public abstract virtual void SetProperty(int index, object value);
    public abstract virtual bool DeleteProperty(int index);
    public abstract virtual IEnumerable`1<int> get_PropertyIndices();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual object Invoke(bool asConstructor, Object[] args);
    public abstract virtual object InvokeMethod(string name, Object[] args);
    public sealed virtual object InvokeAsFunction(Object[] args);
    public abstract virtual void Dispose();
}
[AttributeUsageAttribute("2044")]
public class Microsoft.ClearScript.ScriptUsageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ScriptAccess <Access>k__BackingField;
    public ScriptAccess Access { get; }
    public ScriptUsageAttribute(ScriptAccess access);
    [CompilerGeneratedAttribute]
public ScriptAccess get_Access();
}
public class Microsoft.ClearScript.StringDocument : Document {
    [CompilerGeneratedAttribute]
private string <StringContents>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentInfo <Info>k__BackingField;
    public string StringContents { get; }
    public DocumentInfo Info { get; }
    public Stream Contents { get; }
    public Encoding Encoding { get; }
    public StringDocument(DocumentInfo info, string contents);
    [CompilerGeneratedAttribute]
public string get_StringContents();
    [CompilerGeneratedAttribute]
public virtual DocumentInfo get_Info();
    public virtual Stream get_Contents();
    public virtual Encoding get_Encoding();
}
public class Microsoft.ClearScript.Undefined : object {
    public static Undefined Value;
    private static Undefined();
    public virtual string ToString();
}
internal class Microsoft.ClearScript.UniqueDocumentInfo : object {
    [CompilerGeneratedAttribute]
private DocumentInfo <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    public DocumentInfo Info { get; }
    public string Name { get; }
    public Uri Uri { get; }
    public Uri SourceMapUri { get; }
    public DocumentCategory Category { get; }
    public Nullable`1<DocumentFlags> Flags { get; }
    public DocumentContextCallback ContextCallback { get; }
    public ulong UniqueId { get; }
    public string UniqueName { get; }
    public UniqueDocumentInfo(DocumentInfo info, ulong uniqueId, string uniqueName);
    [CompilerGeneratedAttribute]
public DocumentInfo get_Info();
    public string get_Name();
    public Uri get_Uri();
    public Uri get_SourceMapUri();
    public DocumentCategory get_Category();
    public Nullable`1<DocumentFlags> get_Flags();
    public DocumentContextCallback get_ContextCallback();
    [CompilerGeneratedAttribute]
public ulong get_UniqueId();
    [CompilerGeneratedAttribute]
public string get_UniqueName();
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.ArrayHelpers : object {
    [ExtensionAttribute]
public static void Iterate(Array array, Action`1<Int32[]> action);
    private static void Iterate(Array array, Int32[] indices, int dimension, Action`1<Int32[]> action);
    public static T[] GetEmptyArray();
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.AssemblyHelpers : object {
    public static string GetFullAssemblyName(string name);
    public static Assembly TryLoad(AssemblyName name);
    [ExtensionAttribute]
public static T GetOrLoadCustomAttribute(Assembly assembly, IHostContext context, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetOrLoadCustomAttributes(Assembly assembly, IHostContext context, bool inherit);
    [ExtensionAttribute]
public static bool HasCustomAttributes(Assembly assembly, IHostContext context, bool inherit);
    [ExtensionAttribute]
public static bool IsFriendOf(Assembly thisAssembly, IHostContext context, Assembly thatAssembly);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.AssemblyHelpers/<GetReferencedEnums>d__7")]
private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, Type type, HashSet`1<Type> processedTypes);
    private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, MemberInfo member, HashSet`1<Type> processedTypes);
    private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, FieldInfo field, HashSet`1<Type> processedTypes);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.AssemblyHelpers/<GetReferencedEnums>d__10")]
private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, PropertyInfo property, HashSet`1<Type> processedTypes);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.AssemblyHelpers/<GetReferencedEnums>d__11")]
private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, MethodInfo method, HashSet`1<Type> processedTypes);
    private static IEnumerable`1<Type> GetReferencedEnums(Assembly assembly, ParameterInfo param, HashSet`1<Type> processedTypes);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetAllTypes(Assembly assembly);
}
internal static class Microsoft.ClearScript.Util.AssemblyTable : object {
    public static string GetFullAssemblyName(string name);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.BitwiseHelpers : object {
    [ExtensionAttribute]
public static byte And(byte value, byte mask);
    [ExtensionAttribute]
public static byte Or(byte value, byte mask);
    [ExtensionAttribute]
public static byte Xor(byte value, byte mask);
    [ExtensionAttribute]
public static bool Has(byte value, byte mask);
    [ExtensionAttribute]
public static bool HasAll(byte value, byte mask);
    [ExtensionAttribute]
public static short ToSigned(ushort value);
    [ExtensionAttribute]
public static int ToSigned(UInt32 value);
    [ExtensionAttribute]
public static long ToSigned(ulong value);
    [ExtensionAttribute]
public static ushort ToUnsigned(short value);
    [ExtensionAttribute]
public static UInt32 ToUnsigned(int value);
    [ExtensionAttribute]
public static ulong ToUnsigned(long value);
    [ExtensionAttribute]
public static ushort ToHostUInt16(Byte[] bytes, int index);
    [ExtensionAttribute]
public static UInt32 ToHostUInt32(Byte[] bytes, int index);
    [ExtensionAttribute]
public static ulong ToHostUInt64(Byte[] bytes, int index);
    [ExtensionAttribute]
public static Byte[] ToNetworkBytes(ushort value);
    [ExtensionAttribute]
public static Byte[] ToNetworkBytes(UInt32 value);
    [ExtensionAttribute]
public static Byte[] ToNetworkBytes(ulong value);
}
internal class Microsoft.ClearScript.Util.CollateralArray`2 : CollateralObject`2<THolder, TElement[]> {
    public virtual void Set(THolder holder, TElement[] value);
}
internal class Microsoft.ClearScript.Util.CollateralObject`2 : object {
    private ConditionalWeakTable`2<THolder, TValue> table;
    public TValue Get(THolder holder);
    public TValue GetOrCreate(THolder holder);
    public virtual void Set(THolder holder, TValue value);
    public void Clear(THolder holder);
}
internal static class Microsoft.ClearScript.Util.COM.ActivationHelpers : object {
    public static IntPtr CreateInstance(string progID);
    private static Guid CLSIDFromProgID(string progID);
}
[FlagsAttribute]
internal enum Microsoft.ClearScript.Util.COM.DispatchEnumFlags : Enum {
    public UInt32 value__;
    public static DispatchEnumFlags Default;
    public static DispatchEnumFlags All;
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.COM.DispatchExHelpers : object {
    [ExtensionAttribute]
public static ITypeInfo GetTypeInfo(IDispatchEx dispatchEx);
    [ExtensionAttribute]
public static object GetProperty(IDispatchEx dispatchEx, string name, bool ignoreCase, Object[] args);
    [ExtensionAttribute]
public static void SetProperty(IDispatchEx dispatchEx, string name, bool ignoreCase, Object[] args);
    [ExtensionAttribute]
public static bool DeleteProperty(IDispatchEx dispatchEx, string name, bool ignoreCase);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetPropertyNames(IDispatchEx dispatchEx);
    [ExtensionAttribute]
public static object Invoke(IDispatchEx dispatchEx, bool asConstructor, Object[] args);
    [ExtensionAttribute]
public static object InvokeMethod(IDispatchEx dispatchEx, string name, bool ignoreCase, Object[] args);
    [ExtensionAttribute]
public static IEnumerable`1<DispatchMember> GetMembers(IDispatchEx dispatchEx);
    [ExtensionAttribute]
private static int GetDispIDForName(IDispatchEx dispatchEx, string name, bool ensure, bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.DispatchExHelpers/<GetMembersRaw>d__9")]
[ExtensionAttribute]
private static IEnumerable`1<DispatchMember> GetMembersRaw(IDispatchEx dispatchEx);
}
[FlagsAttribute]
internal enum Microsoft.ClearScript.Util.COM.DispatchFlags : Enum {
    public ushort value__;
    public static DispatchFlags Method;
    public static DispatchFlags PropertyGet;
    public static DispatchFlags PropertyPut;
    public static DispatchFlags PropertyPutRef;
    public static DispatchFlags Construct;
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.COM.DispatchHelpers : object {
    private static Guid iid;
    public static int VariantSize;
    private static DispatchHelpers();
    [ExtensionAttribute]
public static ITypeInfo GetTypeInfo(IDispatch dispatch);
    [ExtensionAttribute]
public static object GetProperty(IDispatch dispatch, string name, Object[] args);
    [ExtensionAttribute]
public static void SetProperty(IDispatch dispatch, string name, Object[] args);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetPropertyNames(IDispatch dispatch);
    [ExtensionAttribute]
public static object Invoke(IDispatch dispatch, Object[] args);
    [ExtensionAttribute]
public static object InvokeMethod(IDispatch dispatch, string name, Object[] args);
    [ExtensionAttribute]
public static IEnumerable`1<DispatchMember> GetMembers(IDispatch dispatch);
    [ExtensionAttribute]
private static int GetDispIDForName(IDispatch dispatch, string name);
    [ExtensionAttribute]
private static IEnumerable`1<DispatchMember> GetMembersRaw(IDispatch dispatch);
}
internal class Microsoft.ClearScript.Util.COM.DispatchMember : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DispID>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchFlags <DispatchFlags>k__BackingField;
    public string Name { get; }
    public int DispID { get; }
    public DispatchFlags DispatchFlags { get; private set; }
    private DispatchMember(string name, int dispid);
    public DispatchMember(string name, int dispid, INVOKEKIND invokeKind);
    public DispatchMember(string name, int dispid, DispatchPropFlags flags);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_DispID();
    [CompilerGeneratedAttribute]
public DispatchFlags get_DispatchFlags();
    [CompilerGeneratedAttribute]
private void set_DispatchFlags(DispatchFlags value);
    public static DispatchMember Merge(int dispid, IEnumerable`1<DispatchMember> group);
}
[FlagsAttribute]
internal enum Microsoft.ClearScript.Util.COM.DispatchNameFlags : Enum {
    public UInt32 value__;
    public static DispatchNameFlags CaseSensitive;
    public static DispatchNameFlags Ensure;
    public static DispatchNameFlags Implicit;
    public static DispatchNameFlags CaseInsensitive;
    public static DispatchNameFlags Internal;
    public static DispatchNameFlags NoDynamicProperties;
}
[FlagsAttribute]
internal enum Microsoft.ClearScript.Util.COM.DispatchPropFlags : Enum {
    public UInt32 value__;
    public static DispatchPropFlags CanGet;
    public static DispatchPropFlags CannotGet;
    public static DispatchPropFlags CanPut;
    public static DispatchPropFlags CannotPut;
    public static DispatchPropFlags CanPutRef;
    public static DispatchPropFlags CannotPutRef;
    public static DispatchPropFlags NoSideEffects;
    public static DispatchPropFlags DynamicType;
    public static DispatchPropFlags CanCall;
    public static DispatchPropFlags CannotCall;
    public static DispatchPropFlags CanConstruct;
    public static DispatchPropFlags CannotConstruct;
    public static DispatchPropFlags CanSourceEvents;
    public static DispatchPropFlags CannotSourceEvents;
    public static DispatchPropFlags CanAll;
    public static DispatchPropFlags CannotAll;
    public static DispatchPropFlags ExtraAll;
    public static DispatchPropFlags All;
}
internal class Microsoft.ClearScript.Util.COM.DynamicDispatchExWrapper : object {
    private HostItem hostItem;
    private IDispatchEx dispatchEx;
    public DynamicDispatchExWrapper(HostItem hostItem, IDispatchEx dispatchEx);
    public sealed virtual object GetProperty(string name, Object[] args);
    public sealed virtual object GetProperty(string name, Boolean& isCacheable, Object[] args);
    public sealed virtual void SetProperty(string name, Object[] args);
    public sealed virtual bool DeleteProperty(string name);
    public sealed virtual String[] GetPropertyNames();
    public sealed virtual object GetProperty(int index);
    public sealed virtual void SetProperty(int index, object value);
    public sealed virtual bool DeleteProperty(int index);
    public sealed virtual Int32[] GetPropertyIndices();
    public sealed virtual object Invoke(bool asConstructor, Object[] args);
    public sealed virtual object InvokeMethod(string name, Object[] args);
}
internal class Microsoft.ClearScript.Util.COM.DynamicDispatchWrapper : object {
    private HostItem hostItem;
    private IDispatch dispatch;
    private IReadOnlyList`1<DispatchMember> members;
    public DynamicDispatchWrapper(HostItem hostItem, IDispatch dispatch);
    private IReadOnlyList`1<DispatchMember> GetMembers();
    public sealed virtual object GetProperty(string name, Object[] args);
    public sealed virtual object GetProperty(string name, Boolean& isCacheable, Object[] args);
    public sealed virtual void SetProperty(string name, Object[] args);
    public sealed virtual bool DeleteProperty(string name);
    public sealed virtual String[] GetPropertyNames();
    public sealed virtual object GetProperty(int index);
    public sealed virtual void SetProperty(int index, object value);
    public sealed virtual bool DeleteProperty(int index);
    public sealed virtual Int32[] GetPropertyIndices();
    public sealed virtual object Invoke(bool asConstructor, Object[] args);
    public sealed virtual object InvokeMethod(string name, Object[] args);
}
internal static class Microsoft.ClearScript.Util.COM.HResult : object {
    public static int SEVERITY_SUCCESS;
    public static int SEVERITY_ERROR;
    public static int FACILITY_NULL;
    public static int FACILITY_RPC;
    public static int FACILITY_DISPATCH;
    public static int FACILITY_STORAGE;
    public static int FACILITY_ITF;
    public static int FACILITY_WIN32;
    public static int FACILITY_WINDOWS;
    public static int FACILITY_CONTROL;
    public static int FACILITY_INTERNET;
    public static int FACILITY_URT;
    public static int S_OK;
    public static int S_FALSE;
    public static int E_NOINTERFACE;
    public static int E_ABORT;
    public static int E_FAIL;
    public static int E_INVALIDARG;
    public static int CO_E_CLASSSTRING;
    public static int REGDB_E_CLASSNOTREG;
    public static int DISP_E_MEMBERNOTFOUND;
    public static int DISP_E_UNKNOWNNAME;
    public static int DISP_E_EXCEPTION;
    public static int DISP_E_BADPARAMCOUNT;
    public static int SCRIPT_E_REPORTED;
    public static int CLEARSCRIPT_E_HOSTEXCEPTION;
    public static int CLEARSCRIPT_E_SCRIPTITEMEXCEPTION;
    public static int ERROR_FILE_EXISTS;
    public static int WIN32_E_FILEEXISTS;
    private static HResult();
    public static void Check(UInt32 result);
    public static void Check(int result);
    public static bool Succeeded(UInt32 result);
    public static bool Succeeded(int result);
    public static int GetSeverity(UInt32 result);
    public static int GetSeverity(int result);
    public static int GetFacility(UInt32 result);
    public static int GetFacility(int result);
    public static int GetCode(UInt32 result);
    public static int GetCode(int result);
    public static int MakeResult(int severity, int facility, int code);
}
[GuidAttribute("00020400-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.ClearScript.Util.COM.IDispatch {
    public abstract virtual int GetTypeInfoCount(UInt32& count);
    public abstract virtual int GetTypeInfo(UInt32 index, int lcid, ITypeInfo& typeInfo);
    public abstract virtual int GetIDsOfNames(Guid& iid, String[] names, UInt32 count, int lcid, Int32[] dispids);
    public abstract virtual int Invoke(int dispid, Guid& iid, int lcid, DispatchFlags flags, DISPPARAMS& args, IntPtr pVarResult, EXCEPINFO& excepInfo, UInt32& argErr);
}
[GuidAttribute("a6ef9860-c720-11d0-9337-00a0c90dcaa9")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.ClearScript.Util.COM.IDispatchEx {
    public abstract virtual int GetTypeInfoCount(UInt32& count);
    public abstract virtual int GetTypeInfo(UInt32 index, int lcid, ITypeInfo& typeInfo);
    public abstract virtual int GetIDsOfNames(Guid& iid, String[] names, UInt32 count, int lcid, Int32[] dispids);
    public abstract virtual int Invoke(int dispid, Guid& iid, int lcid, DispatchFlags flags, DISPPARAMS& args, IntPtr pVarResult, EXCEPINFO& excepInfo, UInt32& argErr);
    public abstract virtual int GetDispID(string name, DispatchNameFlags flags, Int32& dispid);
    public abstract virtual int InvokeEx(int dispid, int lcid, DispatchFlags flags, DISPPARAMS& args, IntPtr pVarResult, EXCEPINFO& excepInfo, IServiceProvider svpCaller);
    public abstract virtual int DeleteMemberByName(string name, DispatchNameFlags flags);
    public abstract virtual int DeleteMemberByDispID(int dispid);
    public abstract virtual int GetMemberProperties(int dispid, DispatchPropFlags fetchFlags, DispatchPropFlags& flags);
    public abstract virtual int GetMemberName(int dispid, String& name);
    public abstract virtual int GetNextDispID(DispatchEnumFlags flags, int dispidCurrent, Int32& dispidNext);
    public abstract virtual int GetNameSpaceParent(Object& parent);
}
[GuidAttribute("6d5140c1-7436-11ce-8034-00aa006009fa")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.ClearScript.Util.COM.IServiceProvider {
    public abstract virtual void QueryService(Guid& guidService, Guid& iid, Object& service);
}
internal static class Microsoft.ClearScript.Util.COM.StructHelpers : object {
    public static IScope`1<T> CreateScope(GetStruct get, ReleaseStruct release);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.StructHelpers/<GetStructsFromArray>d__3`1")]
public static IEnumerable`1<T> GetStructsFromArray(IntPtr pStructs, int count);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.COM.TypeInfoHelpers : object {
    private static Guid managedNameGuid;
    private static ConcurrentDictionary`2<Guid, Type> managedTypeMap;
    private static TypeInfoHelpers();
    [ExtensionAttribute]
public static ITypeLib GetContainingTypeLib(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static ITypeLib GetContainingTypeLib(ITypeInfo typeInfo, Int32& index);
    [ExtensionAttribute]
public static string GetName(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static string GetManagedName(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static string GetMemberName(ITypeInfo typeInfo, int memid);
    [ExtensionAttribute]
public static Guid GetGuid(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static Guid GetOrCreateGuid(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static TYPEFLAGS GetFlags(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static TYPEKIND GetKind(ITypeInfo typeInfo);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.TypeInfoHelpers/<GetDispatchMembers>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<DispatchMember> GetDispatchMembers(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsEnum(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static IScope`1<TYPEATTR> CreateAttrScope(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static IScope`1<VARDESC> CreateVarDescScope(ITypeInfo typeInfo, int index);
    [ExtensionAttribute]
public static IScope`1<FUNCDESC> CreateFuncDescScope(ITypeInfo typeInfo, int index);
    [ExtensionAttribute]
public static Type GetManagedType(ITypeInfo typeInfo);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.COM.TypeLibHelpers : object {
    private static Guid managedNameGuid;
    private static TypeLibHelpers();
    [ExtensionAttribute]
public static string GetName(ITypeLib typeLib);
    [ExtensionAttribute]
public static string GetMemberName(ITypeLib typeLib, int index);
    [ExtensionAttribute]
public static string GetManagedName(ITypeLib typeLib);
    [ExtensionAttribute]
public static Guid GetGuid(ITypeLib typeLib);
    [ExtensionAttribute]
public static IScope`1<TYPELIBATTR> CreateAttrScope(ITypeLib typeLib);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.TypeLibHelpers/<GetReferencedEnums>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.TypeLibHelpers/<GetReferencedEnums>d__7")]
private static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib, ITypeInfo typeInfo, Dictionary`2<Guid, ITypeInfo> processedTypeInfo);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.COM.TypeLibHelpers/<GetReferencedEnums>d__8")]
private static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib, ITypeInfo typeInfo, FUNCDESC funcDesc, Dictionary`2<Guid, ITypeInfo> processedTypeInfo);
    private static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib, ITypeInfo typeInfo, VARDESC varDesc, Dictionary`2<Guid, ITypeInfo> processedTypeInfo);
    private static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib, ITypeInfo typeInfo, ELEMDESC elemDesc, Dictionary`2<Guid, ITypeInfo> processedTypeInfo);
    private static IEnumerable`1<ITypeInfo> GetReferencedEnums(ITypeLib typeLib, ITypeInfo typeInfo, TYPEDESC typeDesc, Dictionary`2<Guid, ITypeInfo> processedTypeInfo);
}
internal static class Microsoft.ClearScript.Util.COM.UnknownHelpers : object {
    public static IntPtr QueryInterface(IntPtr pUnknown);
    public static IntPtr QueryInterfaceNoThrow(IntPtr pUnknown);
    public static void ReleaseAndEmpty(IntPtr& pInterface);
}
internal class Microsoft.ClearScript.Util.ConcurrentWeakSet`1 : object {
    private object dataLock;
    private List`1<WeakReference> weakRefs;
    public int Count { get; }
    public int get_Count();
    public bool Contains(T item);
    public bool TryAdd(T item);
    public void ForEach(Action`1<T> action);
    private List`1<T> GetItems();
    private List`1<T> GetItemsInternal();
}
internal class Microsoft.ClearScript.Util.CoTaskMemArrayBlock : CoTaskMemBlock {
    private int elementSize;
    private int length;
    public CoTaskMemArrayBlock(int elementSize, int length);
    public IntPtr GetAddr(int index);
    private IntPtr GetAddrInternal(int index);
}
internal class Microsoft.ClearScript.Util.CoTaskMemBlock : object {
    [CompilerGeneratedAttribute]
private IntPtr <Addr>k__BackingField;
    public IntPtr Addr { get; private set; }
    public CoTaskMemBlock(int size);
    [CompilerGeneratedAttribute]
public IntPtr get_Addr();
    [CompilerGeneratedAttribute]
private void set_Addr(IntPtr value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class Microsoft.ClearScript.Util.CoTaskMemVariantArgsBlock : CoTaskMemBlock {
    private int length;
    public CoTaskMemVariantArgsBlock(Object[] args);
    public IntPtr GetAddr(int index);
    private IntPtr GetAddrInternal(int index);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ClearScript.Util.CoTaskMemVariantArgsByRefBlock : CoTaskMemBlock {
    private Object[] args;
    public CoTaskMemVariantArgsByRefBlock(Object[] args);
    public IntPtr GetAddr(int index);
    private IntPtr GetAddrInternal(int index);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ClearScript.Util.CoTaskMemVariantBlock : CoTaskMemBlock {
    public CoTaskMemVariantBlock(object obj);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.DynamicHelpers : object {
    public static DynamicMetaObject Bind(DynamicMetaObjectBinder binder, object target, Object[] args);
    public static object Invoke(Expression expr);
    public static object Invoke(Expression expr, IEnumerable`1<ParameterExpression> parameters, Object[] args);
    public static bool TryBindAndInvoke(DynamicMetaObjectBinder binder, object target, Object[] args, Object& result);
    [ExtensionAttribute]
public static bool TryCreateInstance(DynamicMetaObject target, Object[] args, Object& result);
    [ExtensionAttribute]
public static bool TryInvoke(DynamicMetaObject target, IHostContext context, Object[] args, Object& result);
    [ExtensionAttribute]
public static bool TryInvokeMember(DynamicMetaObject target, IHostContext context, string name, BindingFlags invokeFlags, Object[] args, Object& result);
    [ExtensionAttribute]
public static bool TryGetMember(DynamicMetaObject target, string name, Object& result);
    [ExtensionAttribute]
public static bool TrySetMember(DynamicMetaObject target, string name, object value, Object& result);
    [ExtensionAttribute]
public static bool TryDeleteMember(DynamicMetaObject target, string name, Boolean& result);
    [ExtensionAttribute]
public static bool TryGetIndex(DynamicMetaObject target, Object[] indices, Object& result);
    [ExtensionAttribute]
public static bool TrySetIndex(DynamicMetaObject target, Object[] indices, object value, Object& result);
    [ExtensionAttribute]
public static bool TryDeleteIndex(DynamicMetaObject target, Object[] indices, Boolean& result);
    [ExtensionAttribute]
public static bool TryConvert(DynamicMetaObject target, Type type, bool explicit, Object& result);
    private static bool TryGetProperty(IReflect target, string name, bool ignoreCase, Object[] args, Object& result);
    private static bool TrySetProperty(IReflect target, string name, bool ignoreCase, Object[] args, Object& result);
    private static bool TryCreateInstance(IReflect target, Object[] args, Object& result);
    private static bool TryInvoke(IReflect target, Object[] args, Object& result);
    private static bool TryInvokeMethod(IReflect target, string name, bool ignoreCase, Object[] args, Object& result);
    private static bool TryDynamicOperation(Func`1<T> operation, T& result);
    [ExtensionAttribute]
private static object CreateInstance(DynamicMetaObject target, Object[] args);
    [ExtensionAttribute]
private static object Invoke(DynamicMetaObject target, Object[] args);
    [ExtensionAttribute]
private static object InvokeMember(DynamicMetaObject target, IHostContext context, string name, BindingFlags invokeFlags, Object[] args);
    [ExtensionAttribute]
private static object GetMember(DynamicMetaObject target, string name);
    [ExtensionAttribute]
private static object SetMember(DynamicMetaObject target, string name, object value);
    [ExtensionAttribute]
private static bool DeleteMember(DynamicMetaObject target, string name);
    [ExtensionAttribute]
private static object GetIndex(DynamicMetaObject target, Object[] indices);
    [ExtensionAttribute]
private static object SetIndex(DynamicMetaObject target, Object[] indices, object value);
    [ExtensionAttribute]
private static bool DeleteIndex(DynamicMetaObject target, Object[] indices);
    [ExtensionAttribute]
private static object Convert(DynamicMetaObject target, Type type, bool explicit);
    private static DynamicMetaObject CreateDynamicTarget(object target);
    private static DynamicMetaObject CreateDynamicArg(object arg);
    private static DynamicMetaObject[] CreateDynamicArgs(Object[] args);
    private static DynamicMetaObject CreateDynamicMetaObject(object value, Expression expr);
    private static Expression CreateThrowExpr(string message);
    private static Type GetParamTypeForArg(object arg);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.EnumerableHelpers : object {
    [ExtensionAttribute]
public static IList`1<T> ToIList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`2<T, int> action);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.EnumerableHelpers/<Flatten>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> selector);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.EnumerableHelpers/<ToEnumerable>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(T element);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.EnumerableHelpers/<ExcludeIndices>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<string> ExcludeIndices(IEnumerable`1<string> names);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.EnumerableHelpers/<GetIndices>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetIndices(IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IScriptableAsyncEnumerator`1<object> ToScriptableAsyncEnumerator(IEnumerator enumerator, ScriptEngine engine);
    [ExtensionAttribute]
public static IScriptableAsyncEnumerator`1<T> ToScriptableAsyncEnumerator(IEnumerator`1<T> enumerator, ScriptEngine engine);
}
internal class Microsoft.ClearScript.Util.Holder`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    private object Microsoft.ClearScript.Util.IHolder.Value { get; private set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    private sealed virtual override object Microsoft.ClearScript.Util.IHolder.get_Value();
    private sealed virtual override void Microsoft.ClearScript.Util.IHolder.set_Value(object value);
}
internal interface Microsoft.ClearScript.Util.IDynamic {
    public abstract virtual object GetProperty(string name, Object[] args);
    public abstract virtual object GetProperty(string name, Boolean& isCacheable, Object[] args);
    public abstract virtual void SetProperty(string name, Object[] args);
    public abstract virtual bool DeleteProperty(string name);
    public abstract virtual String[] GetPropertyNames();
    public abstract virtual object GetProperty(int index);
    public abstract virtual void SetProperty(int index, object value);
    public abstract virtual bool DeleteProperty(int index);
    public abstract virtual Int32[] GetPropertyIndices();
    public abstract virtual object Invoke(bool asConstructor, Object[] args);
    public abstract virtual object InvokeMethod(string name, Object[] args);
}
internal interface Microsoft.ClearScript.Util.IHolder {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal interface Microsoft.ClearScript.Util.IHostContext {
    public CustomAttributeLoader CustomAttributeLoader { get; }
    public ScriptEngine Engine { get; }
    public Type AccessContext { get; }
    public ScriptAccess DefaultAccess { get; }
    public abstract virtual CustomAttributeLoader get_CustomAttributeLoader();
    public abstract virtual ScriptEngine get_Engine();
    public abstract virtual Type get_AccessContext();
    public abstract virtual ScriptAccess get_DefaultAccess();
}
internal interface Microsoft.ClearScript.Util.IHostTargetContext {
    public HostTargetFlags TargetFlags { get; }
    public abstract virtual HostTargetFlags get_TargetFlags();
}
internal interface Microsoft.ClearScript.Util.INativeCallback {
    public abstract virtual void Invoke();
}
internal interface Microsoft.ClearScript.Util.INothingTag {
}
internal class Microsoft.ClearScript.Util.InterlockedOneWayFlag : object {
    private int isSet;
    public bool IsSet { get; }
    public bool get_IsSet();
    public bool Set();
}
internal static class Microsoft.ClearScript.Util.InvokeHelpers : object {
    public static object InvokeMethod(IHostContext context, MethodInfo method, object target, Object[] args, ScriptMemberFlags flags);
    public static object InvokeConstructor(IHostContext context, ConstructorInfo constructor, Object[] args);
    public static object InvokeDelegate(IHostContext context, Delegate del, Object[] args);
    public static bool TryInvokeObject(IHostContext context, object target, BindingFlags invokeFlags, Object[] args, Object[] bindArgs, bool tryDynamic, Object& result);
    private static object InvokeMethodInternal(IHostContext context, T method, object target, Object[] args, Func`4<T, object, Object[], object> invoker, Type returnType, ScriptMemberFlags flags);
    private static object GetCompatibleArg(ParameterInfo param, object value);
    private static object GetCompatibleArg(string paramName, Type type, object value);
}
internal interface Microsoft.ClearScript.Util.IScope`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
public interface Microsoft.ClearScript.Util.IScriptableAsyncEnumerator`1 {
    public T ScriptableCurrent { get; }
    public abstract virtual T get_ScriptableCurrent();
    public abstract virtual object ScriptableMoveNextAsync();
    public abstract virtual object ScriptableDisposeAsync();
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
public interface Microsoft.ClearScript.Util.IScriptableEnumerator {
    public object ScriptableCurrent { get; }
    public abstract virtual object get_ScriptableCurrent();
    public abstract virtual bool ScriptableMoveNext();
    public abstract virtual void ScriptableDispose();
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
public interface Microsoft.ClearScript.Util.IScriptableEnumerator`1 {
    public T ScriptableCurrent { get; }
    public abstract virtual T get_ScriptableCurrent();
}
internal interface Microsoft.ClearScript.Util.IScriptMarshalWrapper {
    public ScriptEngine Engine { get; }
    public abstract virtual ScriptEngine get_Engine();
    public abstract virtual object Unwrap();
}
internal interface Microsoft.ClearScript.Util.IUniqueNameManager {
    public abstract virtual string GetUniqueName(string inputName, string alternate);
}
internal interface Microsoft.ClearScript.Util.IVBScriptEngineTag {
}
internal interface Microsoft.ClearScript.Util.IWindowsScriptEngineTag {
}
internal interface Microsoft.ClearScript.Util.IWindowsScriptItemTag {
}
internal class Microsoft.ClearScript.Util.MemberComparer`1 : EqualityComparer`1<T> {
    public static MemberComparer`1<T> Instance;
    private static MemberComparer`1();
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    private static bool UnsafeEquals(T x, T y);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.MemberHelpers : object {
    [ExtensionAttribute]
public static bool IsScriptable(EventInfo eventInfo, IHostContext context);
    [ExtensionAttribute]
public static bool IsScriptable(FieldInfo field, IHostContext context);
    [ExtensionAttribute]
public static bool IsScriptable(MethodInfo method, IHostContext context);
    [ExtensionAttribute]
public static bool IsScriptable(PropertyInfo property, IHostContext context);
    [ExtensionAttribute]
public static bool IsScriptable(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(EventInfo eventInfo, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(FieldInfo field, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(MethodBase method, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(MethodInfo method, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(PropertyInfo property, IHostContext context);
    [ExtensionAttribute]
public static bool IsAccessible(Type type, IHostContext context);
    [ExtensionAttribute]
public static string GetScriptName(MemberInfo member, IHostContext context);
    [ExtensionAttribute]
public static bool IsBlockedFromScript(MemberInfo member, IHostContext context, ScriptAccess defaultAccess, bool chain);
    [ExtensionAttribute]
public static bool IsReadOnlyForScript(MemberInfo member, IHostContext context, ScriptAccess defaultAccess);
    [ExtensionAttribute]
public static ScriptAccess GetScriptAccess(MemberInfo member, IHostContext context, ScriptAccess defaultValue, bool chain);
    [ExtensionAttribute]
public static bool IsRestrictedForScript(MemberInfo member, IHostContext context);
    [ExtensionAttribute]
public static bool IsDispID(MemberInfo member, IHostContext context, int dispid);
    [ExtensionAttribute]
public static ScriptMemberFlags GetScriptMemberFlags(MemberInfo member, IHostContext context);
    [ExtensionAttribute]
public static string GetShortName(MemberInfo member);
    [ExtensionAttribute]
public static T GetOrLoadCustomAttribute(MemberInfo member, IHostContext context, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetOrLoadCustomAttributes(MemberInfo member, IHostContext context, bool inherit);
    [ExtensionAttribute]
public static bool HasCustomAttributes(MemberInfo member, IHostContext context, bool inherit);
    [ExtensionAttribute]
private static bool IsExplicitImplementation(MemberInfo member);
}
internal static class Microsoft.ClearScript.Util.MemberMap : object {
    private static MemberMapImpl`1<Field> fieldMap;
    private static MemberMapImpl`1<Method> methodMap;
    private static MemberMapImpl`1<Property> propertyMap;
    private static MemberMap();
    public static FieldInfo GetField(string name);
    public static FieldInfo[] GetFields(String[] names);
    public static MethodInfo GetMethod(string name);
    public static MethodInfo[] GetMethods(String[] names);
    public static PropertyInfo GetProperty(string name);
    public static PropertyInfo[] GetProperties(String[] names);
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.MiscHelpers : object {
    private static Regex dispIDNameRegex;
    private static Char[] searchPathSeparators;
    private static MiscHelpers();
    public static object CreateCOMObject(string progID, string serverName);
    public static object CreateCOMObject(Guid clsid, string serverName);
    public static bool TryCreateCOMObject(string progID, string serverName, T& obj);
    public static bool TryCreateCOMObject(Guid clsid, string serverName, T& obj);
    public static Type GetCOMType(string progID, string serverName);
    public static Type GetCOMType(Guid clsid, string serverName);
    public static bool TryGetCOMType(string progID, string serverName, Type& type);
    public static bool TryGetCOMType(Guid clsid, string serverName, Type& type);
    public static string GetDispIDName(int dispid);
    [ExtensionAttribute]
public static bool IsDispIDName(string name, Int32& dispid);
    public static void VerifyNonNullArgument(object value, string name);
    public static void VerifyNonBlankArgument(string value, string name, string message);
    public static string EnsureNonBlank(string input, string alternate);
    public static string FormatInvariant(string format, Object[] args);
    [ExtensionAttribute]
public static StringBuilder AppendInvariant(StringBuilder builder, string format, Object[] args);
    public static string FormatCode(string code);
    public static string GetUrlOrPath(Uri uri, string alternate);
    [ExtensionAttribute]
public static string ToQuotedJson(string value);
    [ExtensionAttribute]
public static UIntPtr GetDigest(string code);
    [ExtensionAttribute]
public static UInt32 GetDigestAsUInt32(string code);
    [ExtensionAttribute]
public static ulong GetDigestAsUInt64(string code);
    [ExtensionAttribute]
public static IEnumerable`1<string> SplitSearchPath(string searchPath);
    [ExtensionAttribute]
public static StringComparison GetMemberNameComparison(BindingFlags bindFlags);
    [ExtensionAttribute]
public static StringComparer GetMemberNameComparer(BindingFlags bindFlags);
    public static bool TryGetNumericIndex(object arg, Int32& index);
    public static bool TryGetNumericIndex(object arg, Int64& index);
    public static bool Try(Action action);
    public static bool Try(T& result, Func`1<T> func);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.MiscHelpers/<TryAsync>d__30")]
public static Task`1<bool> TryAsync(Task task);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.MiscHelpers/<TryAsync>d__31`1")]
public static Task`1<bool> TryAsync(Holder`1<T> holder, Task`1<T> task);
    public static bool TryMarshalPrimitiveToHost(object obj, bool disableFloatNarrowing, Object& result);
    public static object MarshalDoubleToHost(double value, bool disableFloatNarrowing);
    public static T Exchange(T& target, T value);
    public static void QueueNativeCallback(INativeCallback callback);
    public static Random CreateSeededRandom();
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.MiscHelpers/<CreateLockScopeAsync>d__37")]
[ExtensionAttribute]
public static Task`1<IDisposable> CreateLockScopeAsync(SemaphoreSlim semaphore);
    [ExtensionAttribute]
public static Byte[] ReadToEnd(Stream stream);
    [ExtensionAttribute]
public static string GetTextContents(Document document);
    public static void AssertUnreachable();
    public static string GetLocalDataRootPath(Boolean& usingAppPath);
    public static string GetLocalDataRootPath(string basePath);
    public static bool PlatformIsWindows();
    public static bool PlatformIsLinux();
    public static bool PlatformIsOSX();
    public static bool ProcessorArchitectureIsIntel();
    public static bool ProcessorArchitectureIsArm();
    public static object GetObjectForVariant(IntPtr pVariant);
}
internal class Microsoft.ClearScript.Util.NativeCallbackTimer : object {
    private Timer timer;
    private INativeCallback callback;
    private InterlockedOneWayFlag disposedFlag;
    public NativeCallbackTimer(int dueTime, int period, INativeCallback callback);
    public bool Change(int dueTime, int period);
    private void OnTimer(object _);
    public sealed virtual void Dispose();
}
internal static class Microsoft.ClearScript.Util.NativeMethods : object {
    public static IntPtr LoadLibrary(string path);
    public static bool FreeLibrary(IntPtr hLibrary);
    public static string GetLoadLibraryErrorMessage();
    public static UInt32 CLSIDFromProgID(string progID, Guid& clsid);
    public static UInt32 ProgIDFromCLSID(Guid& clsid, String& progID);
    public static UInt32 CoCreateInstance(Guid& clsid, IntPtr pOuter, UInt32 clsContext, Guid& iid, IntPtr& pInterface);
    public static void VariantInit(IntPtr pVariant);
    public static UInt32 VariantClear(IntPtr pVariant);
    public static IntPtr HeapCreate(UInt32 options, UIntPtr initialSize, UIntPtr maximumSize);
    public static IntPtr HeapAlloc(IntPtr hHeap, UInt32 flags, UIntPtr size);
    public static bool HeapFree(IntPtr hHeap, UInt32 flags, IntPtr pBlock);
    public static bool HeapDestroy(IntPtr hHeap);
    public static bool VirtualProtect(IntPtr pBlock, UIntPtr size, UInt32 newProtect, UInt32& oldProtect);
}
internal class Microsoft.ClearScript.Util.Nonexistent : object {
    public static Nonexistent Value;
    private static Nonexistent();
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.ObjectHelpers : object {
    private static Object[] zeroes;
    private static ObjectHelpers();
    [ExtensionAttribute]
public static bool IsZero(object value);
    [ExtensionAttribute]
public static bool IsWholeNumber(object value);
    [ExtensionAttribute]
public static Type GetTypeOrTypeInfo(object value);
    private static Type GetTypeForTypeInfo(ITypeInfo typeInfo);
    private static Assembly LoadPrimaryInteropAssembly(ITypeLib typeLib);
    [ExtensionAttribute]
public static string GetFriendlyName(object value);
    [ExtensionAttribute]
public static string GetFriendlyName(object value, Type type);
    [ExtensionAttribute]
public static T DynamicCast(object value);
    [ExtensionAttribute]
public static object ToDynamicResult(object result, ScriptEngine engine);
    private static bool GetPrimaryInteropAssembly(Guid libid, int major, int minor, String& name, String& codeBase);
}
internal class Microsoft.ClearScript.Util.OneWayFlag : object {
    private bool isSet;
    public bool IsSet { get; }
    public bool get_IsSet();
    public bool Set();
}
internal static class Microsoft.ClearScript.Util.Scope : object {
    public static IDisposable Create(Action enterAction, Action exitAction);
    public static IScope`1<T> Create(Func`1<T> enterFunc, Action`1<T> exitAction);
}
internal abstract class Microsoft.ClearScript.Util.ScriptableAsyncEnumerator`1 : ScriptableAsyncEnumeratorBase {
    private ScriptEngine engine;
    public T Current { get; }
    public T ScriptableCurrent { get; }
    protected ScriptableAsyncEnumerator`1(ScriptEngine engine);
    public abstract virtual T get_Current();
    public abstract virtual Task`1<bool> MoveNextAsync();
    public abstract virtual Task DisposeAsync();
    public sealed virtual T get_ScriptableCurrent();
    public sealed virtual object ScriptableMoveNextAsync();
    public sealed virtual object ScriptableDisposeAsync();
}
internal abstract class Microsoft.ClearScript.Util.ScriptableAsyncEnumeratorBase : object {
    protected static Task CompletedTask;
    private static ScriptableAsyncEnumeratorBase();
}
internal class Microsoft.ClearScript.Util.ScriptableAsyncEnumeratorOnEnumerator : ScriptableAsyncEnumerator`1<object> {
    private IEnumerator enumerator;
    public object Current { get; }
    public ScriptableAsyncEnumeratorOnEnumerator(ScriptEngine engine, IEnumerator enumerator);
    public virtual object get_Current();
    public virtual Task`1<bool> MoveNextAsync();
    public virtual Task DisposeAsync();
}
internal class Microsoft.ClearScript.Util.ScriptableAsyncEnumeratorOnEnumerator`1 : ScriptableAsyncEnumerator`1<T> {
    private IEnumerator`1<T> enumerator;
    public T Current { get; }
    public ScriptableAsyncEnumeratorOnEnumerator`1(ScriptEngine engine, IEnumerator`1<T> enumerator);
    public virtual T get_Current();
    public virtual Task`1<bool> MoveNextAsync();
    public virtual Task DisposeAsync();
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
internal static class Microsoft.ClearScript.Util.ScriptableEnumerableHelpers : object {
    public static HostType HostType;
    private static ScriptableEnumerableHelpers();
    public static object GetScriptableEnumerator(IEnumerable source);
    public static object GetScriptableAsyncEnumerator(IEnumerable source, ScriptEngine engine);
}
[BypassCustomAttributeLoaderAttribute]
[DefaultScriptUsageAttribute("0")]
internal static class Microsoft.ClearScript.Util.ScriptableEnumerableHelpers`1 : object {
    public static HostType HostType;
    private static ScriptableEnumerableHelpers`1();
    public static object GetScriptableEnumerator(IEnumerable`1<T> source);
    public static object GetScriptableAsyncEnumerator(IEnumerable`1<T> source, ScriptEngine engine);
}
internal class Microsoft.ClearScript.Util.ScriptableEnumeratorOnEnumerator : object {
    private IEnumerator enumerator;
    public object ScriptableCurrent { get; }
    public object Current { get; }
    public ScriptableEnumeratorOnEnumerator(IEnumerator enumerator);
    public sealed virtual object get_ScriptableCurrent();
    public sealed virtual bool ScriptableMoveNext();
    public sealed virtual void ScriptableDispose();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal class Microsoft.ClearScript.Util.ScriptableEnumeratorOnEnumerator`1 : object {
    private IEnumerator`1<T> enumerator;
    public T ScriptableCurrent { get; }
    private object Microsoft.ClearScript.Util.IScriptableEnumerator.ScriptableCurrent { get; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ScriptableEnumeratorOnEnumerator`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_ScriptableCurrent();
    private sealed virtual override object Microsoft.ClearScript.Util.IScriptableEnumerator.get_ScriptableCurrent();
    public sealed virtual bool ScriptableMoveNext();
    public sealed virtual void ScriptableDispose();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal class Microsoft.ClearScript.Util.ScriptableEnumeratorOnEnumVariant : object {
    private IEnumVARIANT enumVariant;
    [CompilerGeneratedAttribute]
private object <Current>k__BackingField;
    public object ScriptableCurrent { get; }
    public object Current { get; private set; }
    public ScriptableEnumeratorOnEnumVariant(IEnumVARIANT enumVariant);
    public sealed virtual object get_ScriptableCurrent();
    public sealed virtual bool ScriptableMoveNext();
    public sealed virtual void ScriptableDispose();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(object value);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.SocketHelpers : object {
    [ExtensionAttribute]
public static Task SendStringAsync(Socket socket, string value, Encoding encoding);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.SocketHelpers/<ReceiveLineAsync>d__1")]
[ExtensionAttribute]
public static Task`1<string> ReceiveLineAsync(Socket socket, Encoding encoding);
    [ExtensionAttribute]
public static Task SendBytesAsync(Socket socket, Byte[] bytes);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.SocketHelpers/<SendBytesAsync>d__3")]
[ExtensionAttribute]
public static Task SendBytesAsync(Socket socket, Byte[] bytes, int offset, int count);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.SocketHelpers/<ReceiveBytesAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReceiveBytesAsync(Socket socket, int count);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.SocketHelpers/<ReceiveBytesAsync>d__5")]
[ExtensionAttribute]
public static Task ReceiveBytesAsync(Socket socket, Byte[] bytes, int offset, int count);
    [ExtensionAttribute]
private static Task`1<int> SendAsync(Socket socket, Byte[] bytes, int offset, int count);
    [ExtensionAttribute]
private static Task`1<int> ReceiveAsync(Socket socket, Byte[] bytes, int offset, int count);
}
internal static class Microsoft.ClearScript.Util.SpecialDispIDs : object {
    public static int Default;
    public static int Unknown;
    public static int StartEnum;
    public static int PropertyPut;
    public static int NewEnum;
    public static int This;
    public static int GetEnumerator;
    public static int NewAsyncEnum;
}
internal static class Microsoft.ClearScript.Util.SpecialMemberNames : object {
    public static string Default;
    public static string NewEnum;
    public static string NewAsyncEnum;
    private static SpecialMemberNames();
}
internal static class Microsoft.ClearScript.Util.SpecialParamNames : object {
    public static string This;
    private static SpecialParamNames();
}
internal class Microsoft.ClearScript.Util.Test.AccessContextTestBase : object {
    [CompilerGeneratedAttribute]
private EventHandler PublicEvent;
    [CompilerGeneratedAttribute]
private EventHandler InternalEvent;
    [CompilerGeneratedAttribute]
private EventHandler ProtectedEvent;
    [CompilerGeneratedAttribute]
private EventHandler ProtectedInternalEvent;
    [CompilerGeneratedAttribute]
private EventHandler PrivateEvent;
    public string PublicField;
    internal string InternalField;
    protected string ProtectedField;
    protected internal string ProtectedInternalField;
    private string privateField;
    [CompilerGeneratedAttribute]
private string <PublicProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtectedProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtectedInternalProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrivateProperty>k__BackingField;
    public string PublicProperty { get; public set; }
    internal string InternalProperty { get; internal set; }
    protected string ProtectedProperty { get; protected set; }
    protected internal string ProtectedInternalProperty { get; protected internal set; }
    private string PrivateProperty { get; private set; }
    internal AccessContextTestBase(int arg);
    protected AccessContextTestBase(string arg);
    protected internal AccessContextTestBase(DateTime arg);
    private AccessContextTestBase(TimeSpan arg);
    [CompilerGeneratedAttribute]
public void add_PublicEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PublicEvent(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_InternalEvent(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_InternalEvent(EventHandler value);
    [CompilerGeneratedAttribute]
protected void add_ProtectedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_ProtectedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
protected internal void add_ProtectedInternalEvent(EventHandler value);
    [CompilerGeneratedAttribute]
protected internal void remove_ProtectedInternalEvent(EventHandler value);
    [CompilerGeneratedAttribute]
private void add_PrivateEvent(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_PrivateEvent(EventHandler value);
    public void PublicMethod();
    internal void InternalMethod();
    protected void ProtectedMethod();
    protected internal void ProtectedInternalMethod();
    private void PrivateMethod();
    [CompilerGeneratedAttribute]
public string get_PublicProperty();
    [CompilerGeneratedAttribute]
public void set_PublicProperty(string value);
    [CompilerGeneratedAttribute]
internal string get_InternalProperty();
    [CompilerGeneratedAttribute]
internal void set_InternalProperty(string value);
    [CompilerGeneratedAttribute]
protected string get_ProtectedProperty();
    [CompilerGeneratedAttribute]
protected void set_ProtectedProperty(string value);
    [CompilerGeneratedAttribute]
protected internal string get_ProtectedInternalProperty();
    [CompilerGeneratedAttribute]
protected internal void set_ProtectedInternalProperty(string value);
    [CompilerGeneratedAttribute]
private string get_PrivateProperty();
    [CompilerGeneratedAttribute]
private void set_PrivateProperty(string value);
}
internal class Microsoft.ClearScript.Util.Test.AccessContextTestObject : AccessContextTestBase {
}
[ExtensionAttribute]
internal static class Microsoft.ClearScript.Util.TypeHelpers : object {
    private static String[] importDenyList;
    private static ConcurrentDictionary`2<Tuple`5<Type, BindingFlags, Type, ScriptAccess, bool>, Invocability> invocabilityMap;
    private static NumericTypes[] numericConversions;
    private static TypeHelpers();
    [ExtensionAttribute]
public static bool IsStatic(Type type);
    [ExtensionAttribute]
public static bool IsSpecific(Type type);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool IsFlagsEnum(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool IsImportable(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool IsAnonymous(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool IsIntegral(Type type);
    [ExtensionAttribute]
public static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type, Boolean& isIntegral);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsNullableNumeric(Type type);
    [ExtensionAttribute]
public static bool IsUnknownCOMObject(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFromValue(Type type, Object& value);
    [ExtensionAttribute]
public static bool IsAssignableToGenericType(Type type, Type genericTypeDefinition, Type[]& typeArgs);
    [ExtensionAttribute]
public static bool IsImplicitlyConvertibleFromValue(Type type, Type sourceType, Object& value);
    [ExtensionAttribute]
public static bool IsNumericallyConvertibleFrom(Type type, Type valueType);
    [ExtensionAttribute]
public static bool HasExtensionMethods(Type type, IHostContext context);
    [ExtensionAttribute]
public static bool EqualsOrDeclares(Type type, Type thatType);
    [ExtensionAttribute]
public static bool IsFamilyOf(Type type, Type thatType);
    [ExtensionAttribute]
public static bool IsFriendOf(Type type, IHostContext context, Type thatType);
    [ExtensionAttribute]
public static bool IsCOMVisible(Type type, IHostContext context);
    [ExtensionAttribute]
public static string GetRootName(Type type);
    [ExtensionAttribute]
public static string GetFullRootName(Type type);
    [ExtensionAttribute]
public static string GetFriendlyName(Type type);
    [ExtensionAttribute]
public static string GetFullFriendlyName(Type type);
    [ExtensionAttribute]
public static string GetLocator(Type type);
    [ExtensionAttribute]
public static int GetGenericParamCount(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetScriptableEvents(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static EventInfo GetScriptableEvent(Type type, IHostContext context, string name, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetScriptableFields(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static FieldInfo GetScriptableField(Type type, IHostContext context, string name, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetScriptableMethods(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetScriptableMethods(Type type, IHostContext context, string name, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetScriptableProperties(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetScriptableDefaultProperties(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetScriptableProperties(Type type, IHostContext context, string name, BindingFlags bindFlags);
    [ExtensionAttribute]
public static PropertyInfo GetScriptableProperty(Type type, IHostContext context, string name, BindingFlags bindFlags);
    [ExtensionAttribute]
public static PropertyInfo GetScriptableProperty(Type type, IHostContext context, string name, BindingFlags bindFlags, Object[] args, Object[] bindArgs);
    [ExtensionAttribute]
public static PropertyInfo GetScriptableDefaultProperty(Type type, IHostContext context, BindingFlags bindFlags, Object[] args, Object[] bindArgs);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetScriptableNestedTypes(Type type, IHostContext context, BindingFlags bindFlags);
    [ExtensionAttribute]
public static Invocability GetInvocability(Type type, IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    [ExtensionAttribute]
public static object CreateInstance(Type type, Object[] args);
    [ExtensionAttribute]
public static object CreateInstance(Type type, BindingFlags flags, Object[] args);
    [ExtensionAttribute]
public static object CreateInstance(Type type, IHostContext context, HostTarget target, Object[] args, Object[] bindArgs);
    [ExtensionAttribute]
public static Type MakeSpecificType(Type template, Type[] typeArgs);
    [ExtensionAttribute]
public static Type ApplyTypeArguments(Type type, Type[] typeArgs);
    public static T BindToMember(IHostContext context, T[] candidates, BindingFlags bindFlags, Object[] args, Object[] bindArgs);
    public static PropertyInfo BindToMember(IHostContext context, PropertyInfo[] candidates, BindingFlags bindFlags, Object[] args, Object[] bindArgs);
    public static HostType ImportType(string typeName, string assemblyName, bool useAssemblyName, Object[] hostTypeArgs);
    public static HostType ImportType(string typeName, string assemblyName, bool useAssemblyName, Type[] typeArgs);
    private static Type ImportType(string typeName, string assemblyName, bool useAssemblyName, int typeArgCount);
    [ExtensionAttribute]
private static string GetFriendlyName(Type type, Func`2<Type, string> getBaseName);
    [ExtensionAttribute]
private static EventInfo GetScriptableEventInternal(Type type, IHostContext context, string name, BindingFlags bindFlags);
    private static Invocability GetInvocabilityInternal(Type type, IHostContext context, BindingFlags bindFlags, bool ignoreDynamic);
    private static bool IsValidLocator(string name);
    private static bool IsValidLocatorChar(char ch);
    private static string StripGenericSuffix(string name);
    [ExtensionAttribute]
private static bool IsBindableFromArg(Type type, object value, Type valueType, BindArgCost& cost);
    [ExtensionAttribute]
private static bool IsAssignableFromValueInternal(Type type, Object& value, Type valueType, BindArgCost cost);
    private static bool IsImplicitlyConvertibleFromValueInternal(Type definingType, Type sourceType, Type targetType, Object& value);
    [ExtensionAttribute]
private static NumericType GetNumericType(Type type);
    private static NumericTypes GetNumericTypes(NumericType numericType);
    private static Type GetBindArgType(object bindArg);
    private static IEnumerable`1<BindCandidate`1<T>> GetBindCandidates(IHostContext context, T[] candidates, Object[] args, Type[] argTypes);
    private static IEnumerable`1<BindCandidate`1<PropertyInfo>> GetBindCandidates(IHostContext context, PropertyInfo[] candidates, Object[] args, Type[] argTypes);
    [IteratorStateMachineAttribute("Microsoft.ClearScript.Util.TypeHelpers/<GetBindCandidates>d__69`1")]
private static IEnumerable`1<BindCandidate`1<T>> GetBindCandidates(IHostContext context, T[] candidates, Func`2<T, ParameterInfo[]> getParameters, Object[] args, Type[] argTypes);
    private static T SelectBindCandidate(BindCandidate`1[] bindCandidates);
    private static string GetFullTypeName(string name, string assemblyName, bool useAssemblyName, int typeArgCount);
    [ExtensionAttribute]
public static IntPtr GetTypeInfo(Type type);
}
internal class Microsoft.ClearScript.Util.UniqueFileNameManager : object {
    private Dictionary`2<string, UInt32> map;
    public sealed virtual string GetUniqueName(string inputName, string alternate);
}
internal class Microsoft.ClearScript.Util.UniqueNameManager : object {
    private Dictionary`2<string, UInt32> map;
    public sealed virtual string GetUniqueName(string inputName, string alternate);
}
internal static class Microsoft.ClearScript.Util.UnmanagedMemoryHelpers : object {
    private static Dictionary`2<Type, ReadArrayFromUnmanagedMemoryHandler> readArrayFromUnmanagedMemoryHandlerMap;
    private static Dictionary`2<Type, WriteArrayToUnmanagedMemoryHandler> writeArrayToUnmanagedMemoryHandlerMap;
    internal static bool DisableMarshalCopy;
    private static UnmanagedMemoryHelpers();
    public static ulong Copy(IntPtr pSource, ulong length, T[] destination, ulong destinationIndex);
    public static ulong Copy(T[] source, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong Copy(Type type, IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong Copy(Type type, Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong ReadByteArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadSByteArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadUInt16ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadCharArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadInt16ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadUInt32ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadInt32ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadUInt64ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadInt64ArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadUIntPtrArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadIntPtrArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadSingleArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong ReadDoubleArrayFromUnmanagedMemory(IntPtr pSource, ulong length, Array destinationArray, ulong destinationIndex);
    private static ulong WriteByteArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteSByteArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteUInt16ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteCharArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteInt16ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteUInt32ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteInt32ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteUInt64ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteInt64ArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteUIntPtrArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteIntPtrArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteSingleArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static ulong WriteDoubleArrayToUnmanagedMemory(Array sourceArray, ulong sourceIndex, ulong length, IntPtr pDestination);
    private static void VerifyMarshalCopyEnabled();
}
internal static class Microsoft.ClearScript.Util.VTableHelpers : object {
    public static T GetMethodDelegate(IntPtr pInterface, int methodIndex);
    public static IntPtr GetMethodPtr(IntPtr pInterface, int methodIndex);
    public static IntPtr ReadMethodPtr(IntPtr pSlot);
    public static T SetMethodDelegate(IntPtr pInterface, int methodIndex, T del);
    public static IntPtr SetMethodPtr(IntPtr pInterface, int methodIndex, IntPtr pMethod);
    public static bool WriteMethodPtr(IntPtr pSlot, IntPtr pMethod);
}
internal abstract class Microsoft.ClearScript.Util.VTablePatcher : object {
    private static HashSet`1<IntPtr> patchedVTables;
    private static IntPtr hHeap;
    public static object PatchLock { get; }
    private static VTablePatcher();
    public static VTablePatcher GetInstance();
    public static object get_PatchLock();
    public abstract virtual void PatchDispatchEx(IntPtr pDispatchEx);
    private static void ApplyVTablePatches(IntPtr pInterface, VTablePatch[] patches);
    private static void EnsureHeap();
}
internal class Microsoft.ClearScript.Util.Web.WebContext : object {
    [CompilerGeneratedAttribute]
private WebRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private WebResponse <Response>k__BackingField;
    public WebRequest Request { get; }
    public WebResponse Response { get; }
    private WebContext(Socket socket, Uri uri, NameValueCollection headers);
    [CompilerGeneratedAttribute]
public WebRequest get_Request();
    [CompilerGeneratedAttribute]
public WebResponse get_Response();
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebContext/<CreateAsync>d__7")]
public static Task`1<WebContext> CreateAsync(Socket socket);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebContext/<AcceptWebSocketAsync>d__8")]
public Task`1<WebSocket> AcceptWebSocketAsync();
    private static void Abort(Socket socket, int statusCode);
}
internal class Microsoft.ClearScript.Util.Web.WebRequest : object {
    internal static String[] Methods;
    [CompilerGeneratedAttribute]
private bool <IsWebSocketRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <Headers>k__BackingField;
    public bool IsWebSocketRequest { get; }
    public Uri Uri { get; }
    public string RawUrl { get; }
    public NameValueCollection Headers { get; }
    internal WebRequest(Uri uri, NameValueCollection headers);
    private static WebRequest();
    [CompilerGeneratedAttribute]
public bool get_IsWebSocketRequest();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_RawUrl();
    [CompilerGeneratedAttribute]
public NameValueCollection get_Headers();
}
internal class Microsoft.ClearScript.Util.Web.WebResponse : object {
    private Socket socket;
    private int state;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <OutputStream>k__BackingField;
    public int StatusCode { get; public set; }
    public string ContentType { get; public set; }
    public Stream OutputStream { get; }
    internal WebResponse(Socket socket, int statusCode);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Stream get_OutputStream();
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebResponse/<AcceptWebSocketAsync>d__14")]
internal Task`1<WebSocket> AcceptWebSocketAsync(string key);
    public void Close(Nullable`1<int> overrideStatusCode);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebResponse/<CloseAsync>d__16")]
private Task CloseAsync(Nullable`1<int> overrideStatusCode);
    private MemoryStream CreateResponseStream(Nullable`1<int> overrideStatusCode);
    private static MemoryStream CreateWebSocketResponseStream(string key);
    public sealed virtual void Dispose();
}
internal class Microsoft.ClearScript.Util.Web.WebSocket : object {
    private Socket socket;
    private bool isServerSocket;
    private Random random;
    private SemaphoreSlim receiveSemaphore;
    private SemaphoreSlim sendSemaphore;
    private InterlockedOneWayFlag closedFlag;
    internal WebSocket(Socket socket, bool isServerSocket);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebSocket/<ReceiveMessageAsync>d__7")]
public Task`1<Message> ReceiveMessageAsync();
    public Task SendMessageAsync(Byte[] payload, bool isBinary);
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebSocket/<ReceiveFrameAsync>d__9")]
private Task`1<Frame> ReceiveFrameAsync();
    [AsyncStateMachineAttribute("Microsoft.ClearScript.Util.Web.WebSocket/<SendFrameAsync>d__10")]
private Task SendFrameAsync(Frame frame);
    private void SendFrameAsync(Frame frame, Action`1<bool> callback);
    public void Close(ErrorCode errorCode, string message);
    [CompilerGeneratedAttribute]
private void <Close>b__12_0(bool succeeded);
}
public static class Microsoft.ClearScript.ValueRef : object {
    public static ValueRef`1<T> Create(T value);
}
public class Microsoft.ClearScript.ValueRef`1 : object {
    public T Value;
}
public class Microsoft.ClearScript.VoidResult : object {
    public static VoidResult Value;
    private static VoidResult();
    public virtual string ToString();
}
