[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Analyzer.Utilities.AbstractCategorizedAnalyzerConfigOptions : object {
    private static string DotnetCodeQualityKeyPrefix;
    private static string BuildPropertyKeyPrefix;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<OptionKey, ValueTuple`2<bool, object>> _computedOptionValuesMap;
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    protected abstract virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, OptionKind kind);
    private static string MapOptionKindToKeyPrefix(OptionKind optionKind);
    public bool TryGetOptionValue(string optionName, OptionKind kind, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, T& value);
    private ValueTuple`2<bool, object> ComputeOptionValue(string optionName, OptionKind kind, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetSpecificOptionValue|10_0(string specificOptionKey, string optionKeyPrefix, T& specificOptionValue, <>c__DisplayClass10_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetAnySpecificOptionValue|10_1(IEnumerable`1<string> specificOptionKeys, string optionKeyPrefix, T& specificOptionValue, <>c__DisplayClass10_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetGeneralOptionValue|10_2(string optionKeyPrefix, T& generalOptionValue, <>c__DisplayClass10_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.AdditionalFileProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AdditionalText> _additionalFiles;
    internal AdditionalFileProvider(ImmutableArray`1<AdditionalText> additionalFiles);
    public static AdditionalFileProvider FromOptions(AnalyzerOptions options);
    public AdditionalText GetFile(string fileName);
    public IEnumerable`1<AdditionalText> GetMatchingFiles(string pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.BoundedCache`2 : BoundedCacheWithFactory`2<TKey, TValue> {
    public TValue GetOrCreateValue(TKey key);
    [CompilerGeneratedAttribute]
internal static TValue <GetOrCreateValue>g__CreateDefaultValue|0_0(TKey _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.BoundedCacheWithFactory`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<WeakReference`1<Entry<TKey, TValue>>> _weakReferencedEntries;
    public TValue GetOrCreateValue(TKey key, Func`2<TKey, TValue> valueFactory);
}
internal static class Analyzer.Utilities.CategorizedAnalyzerConfigOptionsExtensions : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.DiagnosticCategory : object {
    public static string Design;
    public static string Globalization;
    public static string Interoperability;
    public static string Mobility;
    public static string Performance;
    public static string Reliability;
    public static string Security;
    public static string Usage;
    public static string Naming;
    public static string Library;
    public static string Documentation;
    public static string Maintainability;
    public static string RoslynDiagnosticsDesign;
    public static string RoslynDiagnosticsMaintainability;
    public static string RoslynDiagnosticsPerformance;
    public static string RoslynDiagnosticsReliability;
    public static string RoslynDiagnosticsUsage;
    public static string MicrosoftCodeAnalysisCorrectness;
    public static string MicrosoftCodeAnalysisDesign;
    public static string MicrosoftCodeAnalysisDocumentation;
    public static string MicrosoftCodeAnalysisLocalization;
    public static string MicrosoftCodeAnalysisPerformance;
    public static string MicrosoftCodeAnalysisCompatibility;
    public static string MicrosoftCodeAnalysisReleaseTracking;
}
internal static class Analyzer.Utilities.DiagnosticHelpers : object {
    [NullableContextAttribute("2")]
public static bool TryConvertToUInt64(object value, SpecialType specialType, UInt64& convertedValue);
    [NullableContextAttribute("1")]
public static string GetMemberName(ISymbol symbol);
}
internal enum Analyzer.Utilities.DisposeMethodKind : Enum {
    public int value__;
    public static DisposeMethodKind None;
    public static DisposeMethodKind Dispose;
    public static DisposeMethodKind DisposeBool;
    public static DisposeMethodKind DisposeAsync;
    public static DisposeMethodKind DisposeCoreAsync;
    public static DisposeMethodKind Close;
    public static DisposeMethodKind CloseAsync;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.EditorConfigOptionNames : object {
    public static string ApiSurface;
    public static string RequiredModifiers;
    public static string ExcludeAsyncVoidMethods;
    public static string EnablePlatformAnalyzerOnPreNet5Target;
    public static string OutputKind;
    public static string ExcludeSingleLetterTypeParameters;
    public static string SufficientIterationCountForWeakKDFAlgorithm;
    public static string ExcludeExtensionMethodThisParameter;
    public static string NullCheckValidationMethods;
    public static string AdditionalStringFormattingMethods;
    public static string TryDetermineAdditionalStringFormattingMethodsAutomatically;
    public static string ExcludedSymbolNames;
    public static string ExcludedTypeNamesWithDerivedTypes;
    public static string DisallowedSymbolNames;
    public static string UnsafeDllImportSearchPathBits;
    public static string ExcludeAspnetCoreMvcControllerBase;
    public static string EnumValuesPrefixTrigger;
    public static string AdditionalRequiredSuffixes;
    public static string ExcludeIndirectBaseTypes;
    public static string AdditionalRequiredGenericInterfaces;
    public static string AdditionalInheritanceExcludedSymbolNames;
    public static string AnalyzedSymbolKinds;
    public static string UseNamingHeuristic;
    public static string AdditionalUseResultsMethods;
    public static string AllowedSuffixes;
    public static string ExcludeStructs;
    public static string ExcludeOrDefaultMethods;
    public static string EnumerationMethods;
    public static string LinqChainMethods;
    public static string AssumeMethodEnumeratesParameters;
    public static string AdditionalEnumNoneNames;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.CompilationExtensions : object {
    private static Byte[] mscorlibPublicKeyToken;
    private static CompilationExtensions();
    [ExtensionAttribute]
internal static INamedTypeSymbol GetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName);
    [ExtensionAttribute]
internal static bool TryGetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    [ExtensionAttribute]
internal static bool TargetsDotNetFramework(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.DiagnosticExtensions : object {
    [NullableAttribute("2")]
private static PropertyInfo s_syntaxTreeDiagnosticOptionsProperty;
    [NullableAttribute("2")]
private static PropertyInfo s_compilationOptionsSyntaxTreeOptionsProviderProperty;
    private static DiagnosticExtensions();
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxToken token, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(CompilationAnalysisContext context, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(Compilation compilation, DiagnosticDescriptor rule, Action`1<Diagnostic> addDiagnostic, ImmutableDictionary`2<string, string> properties, Object[] args);
    [CompilerGeneratedAttribute]
internal static Nullable`1<DiagnosticSeverity> <ReportNoLocationDiagnostic>g__GetEffectiveSeverity|17_0(<>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddKeyValueIfNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static bool IsEqualTo(IReadOnlyDictionary`2<TKey, TValue> dictionary, IReadOnlyDictionary`2<TKey, TValue> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> s_notNullTest;
    private static IEnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> WhereAsArray(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
    [ExtensionAttribute]
public static void Dispose(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool HasExactly(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(IEnumerable`1<TSource> source, int count);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IEnumerableExtensions/<<Concat>g__ConcatImpl|0_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<T> <Concat>g__ConcatImpl|0_0(IEnumerable`1<T> source, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> WhereMethodDoesNotContainAttribute(IEnumerable`1<IMethodSymbol> methods, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedParameterType, bool trailingOnly);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedTrailingParameterType);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterTypes(IEnumerable`1<IMethodSymbol> members, ITypeSymbol[] expectedParameterTypesInOrder);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterInfos(IEnumerable`1<IMethodSymbol> members, ParameterInfo[] expectedParameterTypesInOrder);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterTypes(IEnumerable`1<IMethodSymbol> members, IReadOnlyList`1<ITypeSymbol> expectedParameterTypesInOrder);
    [CompilerGeneratedAttribute]
internal static bool <GetFirstOrDefaultMemberWithParameterTypes>g__Predicate|5_0(IMethodSymbol member, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IMethodSymbolExtensions : object {
    private static ImmutableHashSet`1<string> s_collectionAddMethodNameVariants;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IMethodSymbol, IBlockOperation>> s_methodToTopmostOperationBlockCache;
    private static IMethodSymbolExtensions();
    [ExtensionAttribute]
public static bool IsObjectEqualsOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsObjectEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsStaticObjectEqualsOrReferenceEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsGetHashCodeOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsToStringOverride(IMethodSymbol method);
    private static bool IsObjectMethodOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMethod(IMethodSymbol method, ITypeSymbol typeArgument, INamedTypeSymbol interfaceType, string interfaceMethodName);
    [ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [ExtensionAttribute]
public static bool IsAsyncDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iDisposable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol valueTaskType);
    [ExtensionAttribute]
private static bool HasDisposeMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeSignatureByConvention(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeBoolMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol taskType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static bool HasDisposeAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task, INamedTypeSymbol valueTask);
    [ExtensionAttribute]
private static bool HasOverriddenDisposeCoreAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task);
    [ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol task, INamedTypeSymbol valueTask);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOnDeserializationImplementation(IMethodSymbol method, INamedTypeSymbol iDeserializationCallback);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSerializationConstructor(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetObjectData(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsIndexerGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsEventAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsOperator(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool HasOptionalParameters(IMethodSymbol methodSymbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IMethodSymbolExtensions/<GetOverloads>d__30")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetOverloads(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsCollectionAddMethod(IMethodSymbol method, ImmutableHashSet`1<INamedTypeSymbol> iCollectionTypes);
    [ExtensionAttribute]
public static bool IsTaskFromResultMethod(IMethodSymbol method, INamedTypeSymbol taskType);
    [ExtensionAttribute]
public static bool IsTaskConfigureAwaitMethod(IMethodSymbol method, INamedTypeSymbol genericTaskType);
    [ExtensionAttribute]
public static IBlockOperation GetTopmostOperationBlock(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegate(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(IMethodSymbol method);
    [ExtensionAttribute]
public static int GetParameterIndex(IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
public static bool HasEventHandlerSignature(IMethodSymbol method, INamedTypeSymbol eventArgsType);
    [ExtensionAttribute]
public static bool IsLockMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingMonitor);
    [ExtensionAttribute]
public static bool IsInterlockedExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool IsInterlockedCompareExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool HasParameterWithDelegateType(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOverrideOrVirtualMethodOf(IMethodSymbol methodSymbol, INamedTypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsArgumentNullCheckMethod(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsBenchmarkOrXUnitTestMethod(IMethodSymbol method, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol benchmarkAttribute, INamedTypeSymbol xunitFactAttribute);
    [ExtensionAttribute]
public static bool IsAutoPropertyAccessor(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTopLevelStatementsEntryPointMethod(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetAwaiterFromAwaitablePattern(IMethodSymbol method, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetResultFromAwaiterPattern(IMethodSymbol method, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFromOrImplementsAnyConstructionOf(INamedTypeSymbol type, INamedTypeSymbol parentType);
    [ExtensionAttribute]
public static bool ImplementsOperator(INamedTypeSymbol symbol, string op);
    [ExtensionAttribute]
public static bool ImplementsEqualityOperators(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesEquals(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesGetHashCode(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasFinalizer(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticHolderType(INamedTypeSymbol symbol);
    private static bool IsQualifyingMember(ISymbol member);
    private static bool IsDisqualifyingMember(ISymbol member);
    [ExtensionAttribute]
public static bool IsBenchmarkOrXUnitTestAttribute(INamedTypeSymbol attributeClass, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol benchmarkAttribute, INamedTypeSymbol xunitFactAttribute);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTopLevelStatementsEntryPointType(INamedTypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IOperationExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IOperation, ControlFlowGraph>> s_operationToCfgCache;
    [NullableAttribute("0")]
private static ImmutableArray`1<OperationKind> s_LambdaAndLocalFunctionKinds;
    private static IOperationExtensions();
    [ExtensionAttribute]
public static INamedTypeSymbol GetReceiverType(IInvocationOperation invocation, Compilation compilation, bool beforeConversion, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetReceiverType(SyntaxNode receiverSyntax, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasNullConstantValue(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetBoolConstantValue(IOperation operation, Boolean& constantValue);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, long comparand);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, ulong comparand);
    private static bool HasConstantValue(Optional`1<object> constantValue, ITypeSymbol constantValueType, ulong comparand);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetElementType(IArrayCreationOperation arrayCreation);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> WithoutFullyImplicitOperations(ImmutableArray`1<IOperation> operations);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> GetTopmostExplicitDescendants(IOperation operation);
    [ExtensionAttribute]
public static bool IsOperationNoneRoot(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IBlockOperation GetTopmostParentBlock(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IBlockOperation GetFirstParentBlock(IOperation operation);
    [ExtensionAttribute]
public static TOperation GetAncestor(IOperation root, OperationKind ancestorKind, Func`2<TOperation, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IOperation GetAncestor(IOperation root, ImmutableArray`1<OperationKind> ancestorKinds, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static IConditionalAccessOperation GetConditionalAccess(IConditionalAccessInstanceOperation operation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInstanceReferenceOperation operation, bool isInsideAnonymousObjectInitializer);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate, IOperation& foundOperation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsComparisonOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static bool IsAdditionOrSubstractionOperation(IBinaryOperation binaryOperation, Char& binaryOperator);
    [ExtensionAttribute]
public static IOperation GetRoot(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetEnclosingControlFlowGraph(IOperation operation, ControlFlowGraph& cfg);
    [ExtensionAttribute]
public static ControlFlowGraph GetEnclosingControlFlowGraph(IBlockOperation blockOperation);
    private static ControlFlowGraph CreateControlFlowGraph(IOperation operation);
    [ExtensionAttribute]
public static PooledHashSet`1<ISymbol> GetCaptures(IOperation operation, IMethodSymbol lambdaOrLocalFunction);
    [ExtensionAttribute]
public static bool IsWithinLambdaOrLocalFunction(IOperation operation, IOperation& containingLambdaOrLocalFunctionOperation);
    [ExtensionAttribute]
public static bool IsWithinExpressionTree(IOperation operation, INamedTypeSymbol linqExpressionTreeType);
    [ExtensionAttribute]
public static ITypeSymbol GetPatternType(IPatternOperation pattern);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryGetParentTupleOperation(ITupleOperation tupleOperation, ITupleOperation& parentTupleOperation, IOperation& elementOfParentTupleContainingTuple);
    [ExtensionAttribute]
public static bool IsExtensionMethodAndHasNoInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static SyntaxNode GetInstanceSyntax(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static ITypeSymbol GetInstanceType(IOperation operation);
    [ExtensionAttribute]
public static ISymbol GetReferencedMemberOrLocalOrParameter(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownParentheses(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkUpParentheses(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation, Func`2<IConversionOperation, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkUpConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation GetThrownException(IThrowOperation operation);
    [ExtensionAttribute]
public static ITypeSymbol GetThrownExceptionType(IThrowOperation operation);
    [ExtensionAttribute]
public static bool HasArgument(IInvocationOperation invocationOperation, TOperation& firstFoundArgument);
    [ExtensionAttribute]
public static bool HasAnyExplicitDescendant(IOperation operation, Func`2<IOperation, bool> descendIntoOperation);
    [ExtensionAttribute]
public static bool IsSetMethodInvocation(IPropertyReferenceOperation operation);
    [ExtensionAttribute]
public static IArgumentOperation GetArgumentForParameterAtIndex(ImmutableArray`1<IArgumentOperation> arguments, int parameterIndex);
    [ExtensionAttribute]
public static ImmutableArray`1<IArgumentOperation> GetArgumentsInParameterOrder(ImmutableArray`1<IArgumentOperation> arguments);
    [CompilerGeneratedAttribute]
internal static void <GetCaptures>g__ProcessLocalOrParameter|28_0(ISymbol symbol, <>c__DisplayClass28_0& );
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IPropertySymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAutoProperty(IPropertySymbol propertySymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIsCompletedFromAwaiterPattern(IPropertySymbol property, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ISymbolExtensions : object {
    private static SymbolDisplayFormat s_memberDisplayFormat;
    private static ISymbolExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAccessorMethod(ISymbol symbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetAccessors>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetAccessors(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDefaultConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPublic(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsProtected(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPrivate(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPropertyWithBackingField(ISymbol symbol, IFieldSymbol& backingField);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsBackingFieldForProperty(ISymbol symbol, IPropertySymbol& propertySymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConversionOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExternallyVisible(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchMemberDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodDerivedByName(IMethodSymbol method, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMemberByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static string FormatMemberName(ISymbol member);
    [ExtensionAttribute]
public static bool ContainsParameterOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, SpecialType specialType);
    [ExtensionAttribute]
public static bool HasOverloadWithParameterOfType(IEnumerable`1<IMethodSymbol> overloads, IMethodSymbol self, INamedTypeSymbol type, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetParameterIndices>d__31")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetParameterIndices(IMethodSymbol method, IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParametersAreSame(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IMethodSymbol method1, IMethodSymbol method2, IEnumerable`1<int> parameterIndices, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IParameterSymbol parameter1, IParameterSymbol parameter2);
    [ExtensionAttribute]
public static bool ReturnTypeAndParametersAreSame(IMethodSymbol method, IMethodSymbol otherMethod);
    [ExtensionAttribute]
public static bool IsFromMscorlib(ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static IMethodSymbol GetMatchingOverload(IMethodSymbol method, IEnumerable`1<IMethodSymbol> overloads, int parameterIndex, INamedTypeSymbol type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol, TSymbol& interfaceMember);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static bool IsOverrideOrImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsImplementationOfAnyExplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberOrLocalOrParameterType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnlyFieldOrProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static bool HasDerivedTypeAttribute(ITypeSymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static bool HasDerivedMethodAttribute(IMethodSymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static Boolean[] HasAttributes(ISymbol symbol, INamedTypeSymbol[] attributes);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static bool IsInSource(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSymbolWithSpecialDiscardName(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConst(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnly(ISymbol symbol);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ITypeSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsPrimitiveType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool Inherits(ITypeSymbol type, ITypeSymbol possibleBase);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type, Func`2<INamedTypeSymbol, bool> takeWhilePredicate);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol symbol, ITypeSymbol candidateBaseType, bool baseTypesOnly, bool checkTypeParameterConstraints);
    [ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableAttributes(INamedTypeSymbol type, INamedTypeSymbol attributeUsageAttribute);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableExportAttributes(INamedTypeSymbol type, INamedTypeSymbol exportAttributeV1, INamedTypeSymbol exportAttributeV2, INamedTypeSymbol inheritedExportAttribute);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasValueCopySemantics(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsReferenceTypeOrNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNullableOfBoolean(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol GetNullableValueTypeUnderlyingType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ITypeSymbol GetUnderlyingValueTupleTypeOrThis(ITypeSymbol typeSymbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasAnyCollectionCountProperty(ITypeSymbol invocationTarget, WellKnownTypeProvider wellKnownTypeProvider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsDisposable>g__IsInterfaceOrImplementsInterface|5_0(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <GetApplicableAttributes>g__IsInheritedAttribute|6_0(AttributeData attributeData, INamedTypeSymbol attributeUsageAttribute);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <HasAnyCollectionCountProperty>g__isAnySupportedCollectionType|16_0(ITypeSymbol type, <>c__DisplayClass16_0& );
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.KeyValuePairExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> AsNullable(KeyValuePair`2<TKey, TValue> pair);
}
internal static class Analyzer.Utilities.Extensions.MethodKindEx : object {
    public static MethodKind LocalFunction;
    private static UInt32 LocalFunctionValueAssertion1;
    private static UInt32 LocalFunctionValueAssertion2;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.OperationBlockAnalysisContextExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsMethodNotImplementedOrSupported(OperationBlockStartAnalysisContext context, bool checkPlatformNotSupported);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsMethodNotImplementedOrSupported>g__IsSingleStatementBody|0_1(IBlockOperation body);
}
internal static class Analyzer.Utilities.Extensions.OperationKinds : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<OperationKind> <MemberReference>k__BackingField;
    public static ImmutableArray`1<OperationKind> MemberReference { get; }
    private static OperationKinds();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<OperationKind> get_MemberReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.Extensions.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ParameterType>k__BackingField;
    public int ArrayRank { get; private set; }
    public bool IsArray { get; private set; }
    public bool IsParams { get; private set; }
    public INamedTypeSymbol ParameterType { get; private set; }
    private ParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
private void set_ArrayRank(int value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
private void set_IsParams(bool value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ParameterType();
    [CompilerGeneratedAttribute]
private void set_ParameterType(INamedTypeSymbol value);
    public static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SemanticModelExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IOperation GetOperationWalkingUpParentChain(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SourceTextExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T Parse(SourceText text, Func`2<StreamReader, T> parser);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool HasSuffix(string str, string suffix);
    [ExtensionAttribute]
public static string WithoutSuffix(string str, string suffix);
    [ExtensionAttribute]
public static bool IsASCII(string value);
}
internal enum Analyzer.Utilities.Extensions.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
    public static SymbolVisibility Friend;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SymbolVisibilityExtensions : object {
    [ExtensionAttribute]
public static bool IsAtLeastAsVisibleAs(SymbolVisibility typeVisibility, SymbolVisibility comparisonVisibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.UriExtensions : object {
    private static ImmutableHashSet`1<string> s_uriWords;
    private static UriExtensions();
    [ExtensionAttribute]
public static bool ParameterNamesContainUriWordSubstring(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWordSubstring(ISymbol symbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.UriExtensions/<GetParametersThatContainUriWords>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersThatContainUriWords(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWords(ISymbol symbol, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.VersionExtension : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGreaterThanOrEqualTo(Version current, Version compare);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FxCopWellKnownDiagnosticTags : object {
    public static string PortedFromFxCop;
    public static String[] PortedFxCopRule;
    public static String[] PortedFxCopRuleEnabledInAggressiveMode;
    public static String[] PortedFxCopDataflowRule;
    public static String[] PortedFxCopDataflowRuleEnabledInAggressiveMode;
    private static FxCopWellKnownDiagnosticTags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.HashUtilities : object {
    [ExtensionAttribute]
internal static int GetHashCodeOrDefault(T obj);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int GetHashCodeOrDefault(Nullable`1<T> obj);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableArray`1<T> array);
    [NullableContextAttribute("2")]
internal static void Combine(ImmutableArray`1<T> array, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableStack`1<T> stack);
    internal static void Combine(ImmutableStack`1<T> stack, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableHashSet`1<T> set);
    internal static void Combine(ImmutableHashSet`1<T> set, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableDictionary`2<TKey, TValue> dictionary);
    internal static void Combine(ImmutableDictionary`2<TKey, TValue> dictionary, RoslynHashCode& hashCode);
}
[NullableContextAttribute("1")]
internal interface Analyzer.Utilities.ICategorizedAnalyzerConfigOptions {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, OptionKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.Lightup.IFunctionPointerInvocationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    [NullableAttribute("2")]
private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ImmutableArray`1<IArgumentOperation>> ArgumentsAccessor;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, IMethodSymbol> GetFunctionPointerSignatureAccessor;
    [CompilerGeneratedAttribute]
private IOperation <WrappedOperation>k__BackingField;
    public IOperation WrappedOperation { get; }
    [NullableAttribute("2")]
public ITypeSymbol Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public IOperation Target { get; }
    private IFunctionPointerInvocationOperationWrapper(IOperation operation);
    private static IFunctionPointerInvocationOperationWrapper();
    private static Func`2<IOperation, IMethodSymbol> CreateFunctionPointerSignatureAccessor(Type wrappedType);
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_WrappedOperation();
    [NullableContextAttribute("2")]
public ITypeSymbol get_Type();
    public ImmutableArray`1<IArgumentOperation> get_Arguments();
    public IOperation get_Target();
    public IMethodSymbol GetFunctionPointerSignature();
    public static IFunctionPointerInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.IMethodSymbolExtensions : object {
    private static Func`2<IMethodSymbol, bool> s_isInitOnly;
    private static Func`2<IMethodSymbol, MethodImplAttributes> s_methodImplementationFlags;
    private static Func`2<IMethodSymbol, SignatureCallingConvention> s_callingConvention;
    private static IMethodSymbolExtensions();
    [ExtensionAttribute]
public static bool IsInitOnly(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static MethodImplAttributes MethodImplementationFlags(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static SignatureCallingConvention CallingConvention(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.Lightup.INegatedPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    [NullableAttribute("2")]
private static Type WrappedType;
    private static Func`2<IOperation, IPatternOperation> PatternAccessor;
    [CompilerGeneratedAttribute]
private IOperation <WrappedOperation>k__BackingField;
    public IOperation WrappedOperation { get; }
    [NullableAttribute("2")]
public ITypeSymbol Type { get; }
    public IPatternOperation Pattern { get; }
    private INegatedPatternOperationWrapper(IOperation operation);
    private static INegatedPatternOperationWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_WrappedOperation();
    [NullableContextAttribute("2")]
public ITypeSymbol get_Type();
    public IPatternOperation get_Pattern();
    public static INegatedPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("2")]
internal interface Analyzer.Utilities.Lightup.IOperationWrapper {
    public IOperation WrappedOperation { get; }
    public abstract virtual IOperation get_WrappedOperation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.ITypeSymbolExtensions : object {
    private static Func`2<ITypeSymbol, NullableAnnotation> s_nullableAnnotation;
    private static Func`3<ITypeSymbol, NullableAnnotation, ITypeSymbol> s_withNullableAnnotation;
    private static Func`2<ITypeSymbol, bool> s_isNativeIntegerType;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol WithNullableAnnotation(ITypeSymbol typeSymbol, NullableAnnotation nullableAnnotation);
    [ExtensionAttribute]
public static bool IsNativeIntegerType(ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.Lightup.IUsingDeclarationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    [NullableAttribute("2")]
private static Type WrappedType;
    private static Func`2<IOperation, IVariableDeclarationGroupOperation> DeclarationGroupAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    [CompilerGeneratedAttribute]
private IOperation <WrappedOperation>k__BackingField;
    public IOperation WrappedOperation { get; }
    [NullableAttribute("2")]
public ITypeSymbol Type { get; }
    public IVariableDeclarationGroupOperation DeclarationGroup { get; }
    public bool IsAsynchronous { get; }
    private IUsingDeclarationOperationWrapper(IOperation operation);
    private static IUsingDeclarationOperationWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_WrappedOperation();
    [NullableContextAttribute("2")]
public ITypeSymbol get_Type();
    public IVariableDeclarationGroupOperation get_DeclarationGroup();
    public bool get_IsAsynchronous();
    public static IUsingDeclarationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.IUsingOperationExtensions : object {
    private static Func`2<IUsingOperation, bool> s_isAsynchronous;
    private static IUsingOperationExtensions();
    [ExtensionAttribute]
public static bool IsAsynchronous(IUsingOperation usingOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.LightupHelpers : object {
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<OperationKind, bool>> s_supportedOperationWrappers;
    private static LightupHelpers();
    [NullableContextAttribute("2")]
internal static bool CanWrapOperation(IOperation operation, Type underlyingType);
    internal static Func`2<TOperation, TProperty> CreateOperationPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`2<TSymbol, TProperty> CreateSymbolPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`2<T, TProperty> CreatePropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSymbol, TProperty, TSymbol> CreateSymbolWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`3<T, TProperty, T> CreateWithPropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<T, TArg, TValue> CreateAccessorWithArgument(Type type, string parameterName, Type argumentType, string argumentName, string methodName, TValue fallbackResult);
    private static void VerifyTypeArgument(Type type);
    private static void VerifyResultTypeCompatibility(Type resultType);
    [NullableContextAttribute("2")]
private static bool TryGetProperty(Type type, string propertyName, PropertyInfo& propertyInfo);
    [NullableContextAttribute("2")]
private static bool TryGetMethod(Type type, string methodName, MethodInfo& methodInfo);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TProperty <CreatePropertyAccessor>g__FallbackAccessor|5_1(T instance, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <CreateWithPropertyAccessor>g__FallbackAccessor|8_3(T instance, TProperty newValue, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TValue <CreateAccessorWithArgument>g__FallbackAccessor|9_1(T instance, TValue fallbackResult);
}
internal enum Analyzer.Utilities.Lightup.NullableAnnotation : Enum {
    public byte value__;
    public static NullableAnnotation None;
    public static NullableAnnotation NotAnnotated;
    public static NullableAnnotation Annotated;
}
[FlagsAttribute]
internal enum Analyzer.Utilities.Lightup.NullableContext : Enum {
    public int value__;
    public static NullableContext Disabled;
    public static NullableContext WarningsEnabled;
    public static NullableContext AnnotationsEnabled;
    public static NullableContext Enabled;
    public static NullableContext WarningsContextInherited;
    public static NullableContext AnnotationsContextInherited;
    public static NullableContext ContextInherited;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.NullableContextExtensions : object {
    private static bool IsFlagSet(NullableContext context, NullableContext flag);
    [ExtensionAttribute]
public static bool WarningsEnabled(NullableContext context);
    [ExtensionAttribute]
public static bool AnnotationsEnabled(NullableContext context);
    [ExtensionAttribute]
public static bool WarningsInherited(NullableContext context);
    [ExtensionAttribute]
public static bool AnnotationsInherited(NullableContext context);
}
internal static class Analyzer.Utilities.Lightup.OperationKindEx : object {
    public static OperationKind UsingDeclaration;
    public static OperationKind FunctionPointerInvocation;
    public static OperationKind ImplicitIndexerReference;
    public static OperationKind Attribute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.OperationWrapperHelper : object {
    private static Assembly s_codeAnalysisAssembly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static OperationWrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.SemanticModelExtensions : object {
    private static Func`3<SemanticModel, int, NullableContext> s_getNullableContext;
    private static SemanticModelExtensions();
    [ExtensionAttribute]
public static NullableContext GetNullableContext(SemanticModel semanticModel, int position);
}
internal static class Analyzer.Utilities.MSBuildItemOptionNames : object {
    [NullableAttribute("1")]
public static string SupportedPlatform;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.MSBuildItemOptionNamesHelpers : object {
    public static char ValuesSeparator;
    private static Char[] s_itemMetadataValuesSeparators;
    private static MSBuildItemOptionNamesHelpers();
    public static string GetPropertyNameForItemOptionName(string itemOptionName);
    [ConditionalAttribute("DEBUG")]
public static void VerifySupportedItemOptionName(string itemOptionName);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<string> ParseItemOptionValue(string itemOptionValue);
    [IteratorStateMachineAttribute("Analyzer.Utilities.MSBuildItemOptionNamesHelpers/<ProduceTrimmedArray>d__5")]
private static IEnumerable`1<string> ProduceTrimmedArray(string itemOptionValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.MSBuildPropertyOptionNames : object {
    public static string TargetFramework;
    public static string TargetPlatformMinVersion;
    public static string UsingMicrosoftNETSdkWeb;
    public static string ProjectTypeGuids;
    public static string InvariantGlobalization;
    public static string PlatformNeutralAssembly;
    public static string EnforceExtendedAnalyzerRules;
}
internal static class Analyzer.Utilities.MSBuildPropertyOptionNamesHelpers : object {
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void VerifySupportedPropertyOptionName(string propertyOptionName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.OptionKey : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<string, string>, OptionKey> s_keys;
    private static int s_lastOrdinal;
    private int _ordinal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    private OptionKey(string name);
    private static OptionKey();
    [CompilerGeneratedAttribute]
public string get_Name();
    public static OptionKey GetOrCreate(string ruleId, string optionName);
    public static bool op_Equality(OptionKey left, OptionKey right);
    public static bool op_Inequality(OptionKey left, OptionKey right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(OptionKey other);
}
internal enum Analyzer.Utilities.OptionKind : Enum {
    public int value__;
    public static OptionKind DotnetCodeQuality;
    public static OptionKind BuildProperty;
}
internal enum Analyzer.Utilities.Options.EnumValuesPrefixTrigger : Enum {
    public int value__;
    public static EnumValuesPrefixTrigger AnyEnumValue;
    public static EnumValuesPrefixTrigger AllEnumValues;
    public static EnumValuesPrefixTrigger Heuristic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Analyzer.Utilities.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Analyzer.Utilities.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Dispose();
    private void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
internal Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.PooledObjects.Extensions.ArrayBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T item);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.PooledObjects.Extensions.PooledHashSetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRange(PooledHashSet`1<T> builder, IEnumerable`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj, CancellationToken cancellationToken);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal static void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2 : ConcurrentDictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledConcurrentDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledConcurrentDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool);
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledConcurrentDictionary`2();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1 : object {
    private PooledConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    private PooledConcurrentSet`1(PooledConcurrentDictionary`2<T, byte> dictionary);
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public static PooledConcurrentSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
    public static PooledConcurrentSet`1<T> GetInstance(IEnumerable`1<T> initializer, IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1/<GetEnumeratorCore>d__19")]
private IEnumerator`1<T> GetEnumeratorCore();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public sealed virtual void Dispose();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryAndFree(Func`2<KeyValuePair`2<K, V>, TKey> keySelector, Func`2<KeyValuePair`2<K, V>, TValue> elementSelector, IEqualityComparer`1<TKey> comparer);
    public void Free(CancellationToken cancellationToken);
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<T>, ObjectPool`1<PooledHashSet`1<T>>> s_poolInstancesByComparer;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> comparer);
    private static PooledHashSet`1();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public ImmutableHashSet`1<T> ToImmutableAndFree();
    public ImmutableHashSet`1<T> ToImmutable();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> comparer);
    public static PooledHashSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
    public static PooledHashSet`1<T> GetInstance(IEnumerable`1<T> initializer, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledSortedSet`1 : SortedSet`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledSortedSet`1<T>> _pool;
    private static ObjectPool`1<PooledSortedSet`1<T>> s_poolInstance;
    private static ConcurrentDictionary`2<IComparer`1<T>, ObjectPool`1<PooledSortedSet`1<T>>> s_poolInstancesByComparer;
    public PooledSortedSet`1(ObjectPool`1<PooledSortedSet`1<T>> pool, IComparer`1<T> comparer);
    private static PooledSortedSet`1();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    private static ObjectPool`1<PooledSortedSet`1<T>> CreatePool(IComparer`1<T> comparer);
    public static PooledSortedSet`1<T> GetInstance(IComparer`1<T> comparer);
    public static PooledSortedSet`1<T> GetInstance(IEnumerable`1<T> initializer, IComparer`1<T> comparer);
}
internal static class Analyzer.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Analyzer.Utilities.RoslynHashCode : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static RoslynHashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Analyzer.Utilities.SmallDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvlNode<K, V> _root;
    public IEqualityComparer`1<K> Comparer;
    public static SmallDictionary`2<K, V> Empty;
    public bool IsEmpty { get; }
    public V Item { get; public set; }
    [NullableAttribute("0")]
public KeyCollection<K, V> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<K, V> Values { get; }
    public SmallDictionary`2(IEqualityComparer`1<K> comparer);
    public SmallDictionary`2(SmallDictionary`2<K, V> other, IEqualityComparer`1<K> comparer);
    private static SmallDictionary`2();
    private bool CompareKeys(K k1, K k2);
    private int GetHashCode(K k);
    public bool get_IsEmpty();
    public void Remove(K key);
    private AvlNode<K, V> Remove(AvlNode<K, V> currentNode, int hashCode);
    private static AvlNode<K, V> MinValueNode(AvlNode<K, V> node);
    private static int Height(AvlNode<K, V> node);
    public bool TryGetValue(K key, V& value);
    public void Add(K key, V value);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    [ConditionalAttribute("DEBUG")]
internal void AssertBalanced();
    private bool TryGetValue(int hashCode, K key, V& value);
    private bool GetFromList(Node<K, V> next, K key, V& value);
    private void Insert(int hashCode, K key, V value, bool add);
    private static AvlNode<K, V> LeftSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> LeftComplex(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightComplex(AvlNode<K, V> unbalanced);
    private void HandleInsert(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value, bool add);
    private void AddNode(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value);
    [NullableContextAttribute("0")]
public KeyCollection<K, V> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<K, V> get_Values();
    [NullableContextAttribute("0")]
public Enumerator<K, V> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int HeightApprox();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolByDisplayStringComparer : object {
    [CompilerGeneratedAttribute]
private SymbolDisplayStringCache <SymbolDisplayStringCache>k__BackingField;
    public SymbolDisplayStringCache SymbolDisplayStringCache { get; }
    public SymbolByDisplayStringComparer(Compilation compilation);
    public SymbolByDisplayStringComparer(SymbolDisplayStringCache symbolDisplayStringCache);
    [CompilerGeneratedAttribute]
public SymbolDisplayStringCache get_SymbolDisplayStringCache();
    public sealed virtual int Compare(ITypeSymbol x, ITypeSymbol y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat ShortSymbolDisplayFormat;
    public static SymbolDisplayFormat QualifiedTypeAndNamespaceSymbolDisplayFormat;
    private static SymbolDisplayFormats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolDisplayStringCache : object {
    private static BoundedCacheWithFactory`2<Compilation, ConcurrentDictionary`2<SymbolDisplayFormat, SymbolDisplayStringCache>> s_byCompilationCache;
    private static SymbolDisplayFormat NullSymbolDisplayFormat;
    private ConcurrentDictionary`2<ISymbol, string> SymbolToDisplayNames;
    [NullableAttribute("2")]
private SymbolDisplayFormat Format;
    [NullableContextAttribute("2")]
private SymbolDisplayStringCache(SymbolDisplayFormat format);
    private static SymbolDisplayStringCache();
    public static SymbolDisplayStringCache GetOrCreate(Compilation compilation, SymbolDisplayFormat format);
    public string GetDisplayString(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static ConcurrentDictionary`2<SymbolDisplayFormat, SymbolDisplayStringCache> <GetOrCreate>g__CreateConcurrentDictionary|5_0(Compilation compilation);
    [CompilerGeneratedAttribute]
internal static SymbolDisplayStringCache <GetOrCreate>g__CreateSymbolDisplayStringCache|5_1(SymbolDisplayFormat format);
    [CompilerGeneratedAttribute]
private string <GetDisplayString>b__6_0(ISymbol s);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolModifiers : Enum {
    public int value__;
    public static SymbolModifiers None;
    public static SymbolModifiers Static;
    public static SymbolModifiers Shared;
    public static SymbolModifiers Const;
    public static SymbolModifiers ReadOnly;
    public static SymbolModifiers Abstract;
    public static SymbolModifiers Virtual;
    public static SymbolModifiers Override;
    public static SymbolModifiers Sealed;
    public static SymbolModifiers Extern;
    public static SymbolModifiers Async;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolModifiersExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolModifiers modifiers, SymbolModifiers modifiersToCheck);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SymbolModifiers GetSymbolModifiers(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolNamesWithValueOption`1 : object {
    internal static SymbolKind AllKinds;
    internal static char WildcardChar;
    public static SymbolNamesWithValueOption`1<TValue> Empty;
    private ImmutableDictionary`2<string, TValue> _names;
    private ImmutableDictionary`2<ISymbol, TValue> _symbols;
    private ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> _wildcardNamesBySymbolKind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> _wildcardMatchResult;
    private ConcurrentDictionary`2<ISymbol, string> _symbolToDeclarationId;
    public bool IsEmpty { get; }
    private SymbolNamesWithValueOption`1(ImmutableDictionary`2<string, TValue> names, ImmutableDictionary`2<ISymbol, TValue> symbols, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind);
    private static SymbolNamesWithValueOption`1();
    public static SymbolNamesWithValueOption`1<TValue> Create(ImmutableArray`1<string> symbolNames, Compilation compilation, string optionalPrefix, Func`2<string, NameParts<TValue>> getSymbolNamePartsFunc);
    public bool get_IsEmpty();
    public bool Contains(ISymbol symbol);
    public bool TryGetValue(ISymbol symbol, TValue& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolNamesWithValueOption`1<TValue> other);
    public virtual int GetHashCode();
    private bool TryGetFirstWildcardMatch(ISymbol symbol, String& firstMatchName, TValue& firstMatchValue);
    [NullableContextAttribute("0")]
internal TestAccessor<TValue> GetTestAccessor();
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessWildcardName|10_2(NameParts<TValue> parts, PooledDictionary`2<SymbolKind, PooledDictionary`2<string, TValue>> wildcardNamesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessName|10_3(NameParts<TValue> parts, PooledDictionary`2<string, TValue> namesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessSymbolName|10_4(NameParts<TValue> parts, Compilation compilation, string optionalPrefix, PooledDictionary`2<ISymbol, TValue> symbolsBuilder);
    [CompilerGeneratedAttribute]
internal static string <TryGetFirstWildcardMatch>g__GetDeclarationId|18_7(ISymbol symbol);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolVisibilityGroup : Enum {
    public int value__;
    public static SymbolVisibilityGroup None;
    public static SymbolVisibilityGroup Public;
    public static SymbolVisibilityGroup Internal;
    public static SymbolVisibilityGroup Private;
    public static SymbolVisibilityGroup Friend;
    public static SymbolVisibilityGroup All;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolVisibilityGroupExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolVisibilityGroup symbolVisibilityGroup, SymbolVisibility symbolVisibility);
}
internal class Analyzer.Utilities.Unit : ValueType {
    public static Unit Default { get; }
    public sealed virtual bool Equals(Unit other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(Unit first, Unit second);
    public static bool op_Inequality(Unit first, Unit second);
    public static Unit get_Default();
}
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.UnusedValue : ValueType {
}
[FlagsAttribute]
internal enum Analyzer.Utilities.ValueUsageInfo : Enum {
    public int value__;
    public static ValueUsageInfo None;
    public static ValueUsageInfo Read;
    public static ValueUsageInfo Write;
    public static ValueUsageInfo Reference;
    public static ValueUsageInfo Name;
    public static ValueUsageInfo ReadWrite;
    public static ValueUsageInfo ReadableReference;
    public static ValueUsageInfo WritableReference;
    public static ValueUsageInfo ReadableWritableReference;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.ValueUsageInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsReadFrom(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsWrittenTo(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsNameOnly(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsReference(ValueUsageInfo valueUsageInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.WellKnownTypeNames : object {
    public static string BenchmarkDotNetAttributesBenchmarkAttribute;
    public static string MicrosoftAspNetCoreAntiforgeryIAntiforgery;
    public static string MicrosoftAspNetCoreHttpCookieOptions;
    public static string MicrosoftAspNetCoreHttpHttpRequest;
    public static string MicrosoftAspNetCoreHttpInternalResponseCookies;
    public static string MicrosoftAspNetCoreHttpIResponseCookies;
    public static string MicrosoftAspNetCoreMvcController;
    public static string MicrosoftAspNetCoreMvcControllerAttribute;
    public static string MicrosoftAspNetCoreMvcControllerBase;
    public static string MicrosoftAspNetCoreMvcFiltersAuthorizationFilterContext;
    public static string MicrosoftAspNetCoreMvcFiltersFilterCollection;
    public static string MicrosoftAspNetCoreMvcFiltersIAsyncAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIFilterMetadata;
    public static string MicrosoftAspNetCoreMvcFromServicesAttribute;
    public static string MicrosoftAspNetCoreMvcHttpDeleteAttribute;
    public static string MicrosoftAspNetCoreMvcHttpGetAttribute;
    public static string MicrosoftAspNetCoreMvcHttpHeadAttribute;
    public static string MicrosoftAspNetCoreMvcHttpOptionsAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPatchAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPostAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPutAttribute;
    public static string MicrosoftAspNetCoreMvcNonActionAttribute;
    public static string MicrosoftAspNetCoreMvcNonControllerAttribute;
    public static string MicrosoftAspNetCoreMvcRouteAttribute;
    public static string MicrosoftAspNetCoreMvcRoutingHttpMethodAttribute;
    public static string MicrosoftAspNetCoreRazorHostingRazorCompiledItemAttribute;
    public static string MicrosoftCodeAnalysisCompilation;
    public static string MicrosoftCodeAnalysisCSharpCSharpCompilation;
    public static string MicrosoftCodeAnalysisCSharpCSharpExtensions;
    public static string MicrosoftCodeAnalysisCSharpExtensions;
    public static string MicrosoftCodeAnalysisDiagnostic;
    public static string MicrosoftCodeAnalysisDiagnosticDescriptor;
    public static string MicrosoftCodeAnalysisDiagnosticsAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockStartAnalysisContext1;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationEndAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzer;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzerAttribute;
    public static string MicrosoftCodeAnalysisDiagnosticsGeneratedCodeAnalysisFlags;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSemanticModelAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSymbolAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxNodeAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxTreeAnalysisContext;
    public static string MicrosoftCodeAnalysisGeneratorAttribute;
    public static string MicrosoftCodeAnalysisHostMefMefConstruction;
    public static string MicrosoftCodeAnalysisLocalizableResourceString;
    public static string MicrosoftCodeAnalysisLocalizableString;
    public static string MicrosoftCodeAnalysisSharedCollectionsTemporaryArrayExtensions;
    public static string MicrosoftCodeAnalysisSymbolKind;
    public static string MicrosoftCodeAnalysisVisualBasicExtensions;
    public static string MicrosoftCodeAnalysisVisualBasicVisualBasicCompilation;
    public static string MicrosoftCodeAnalysisVisualBasicVisualBasicExtensions;
    public static string MicrosoftEntityFrameworkCoreEntityFrameworkQueryableExtensions;
    public static string MicrosoftEntityFrameworkCoreRelationalQueryableExtensions;
    public static string MicrosoftExtensionsLoggingILogger;
    public static string MicrosoftExtensionsLoggingLoggerExtensions;
    public static string MicrosoftExtensionsLoggingLoggerMessage;
    public static string MicrosoftIdentityModelTokensAudienceValidator;
    public static string MicrosoftIdentityModelTokensLifetimeValidator;
    public static string MicrosoftIdentityModelTokensSecurityToken;
    public static string MicrosoftIdentityModelTokensTokenValidationParameters;
    public static string MicrosoftSecurityApplicationAntiXss;
    public static string MicrosoftSecurityApplicationAntiXssEncoder;
    public static string MicrosoftSecurityApplicationEncoder;
    public static string MicrosoftSecurityApplicationUnicodeCharacterEncoder;
    public static string MicrosoftVisualBasicDevicesComputerInfo;
    public static string MicrosoftVisualStudioTestToolsUnitTestingAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingCollectionAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingDataTestMethodAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingExpectedExceptionAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingStringAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestCleanupAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestInitializeAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestMethodAttribute;
    public static string MicrosoftWindowsAzureStorageCloudStorageAccount;
    public static string MicrosoftWindowsAzureStorageSharedAccessProtocol;
    public static string NewtonsoftJsonJsonConvert;
    public static string NewtonsoftJsonJsonIgnoreAttribute;
    public static string NewtonsoftJsonJsonSerializer;
    public static string NewtonsoftJsonJsonSerializerSettings;
    public static string NewtonsoftJsonTypeNameHandling;
    public static string NUnitFrameworkAssert;
    public static string NUnitFrameworkInterfacesITestBuilder;
    public static string NUnitFrameworkOneTimeSetUpAttribute;
    public static string NUnitFrameworkOneTimeTearDownAttribute;
    public static string NUnitFrameworkSetUpAttribute;
    public static string NUnitFrameworkTearDownAttribute;
    public static string NUnitFrameworkTestAttribute;
    public static string RoslynUtilitiesNonDefaultableAttribute;
    public static string SystemActivator;
    public static string SystemAppContext;
    public static string SystemAppDomain;
    public static string SystemArgumentException;
    public static string SystemArgumentNullException;
    public static string SystemArgumentOutOfRangeException;
    public static string SystemAttribute;
    public static string SystemAttributeTargets;
    public static string SystemAttributeUsageAttribute;
    public static string SystemBoolean;
    public static string SystemBuffer;
    public static string SystemBuffersMemoryManager1;
    public static string SystemByte;
    public static string SystemChar;
    public static string SystemCLSCompliantAttribute;
    public static string SystemCodeDomCompilerGeneratedCodeAttribute;
    public static string SystemCollectionsConcurrentConcurrentBag1;
    public static string SystemCollectionsConcurrentConcurrentDictionary2;
    public static string SystemCollectionsConcurrentConcurrentQueue1;
    public static string SystemCollectionsConcurrentConcurrentStack1;
    public static string SystemCollectionsGenericDictionary2;
    public static string SystemCollectionsGenericHashSet1;
    public static string SystemCollectionsGenericIAsyncEnumerable1;
    public static string SystemCollectionsGenericICollection1;
    public static string SystemCollectionsGenericIDictionary2;
    public static string SystemCollectionsGenericIEnumerable1;
    public static string SystemCollectionsGenericIEnumerator1;
    public static string SystemCollectionsGenericIEqualityComparer1;
    public static string SystemCollectionsGenericIList1;
    public static string SystemCollectionsGenericIReadOnlyCollection1;
    public static string SystemCollectionsGenericIReadOnlyDictionary2;
    public static string SystemCollectionsGenericIReadOnlyList1;
    public static string SystemCollectionsGenericIReadOnlySet1;
    public static string SystemCollectionsGenericISet1;
    public static string SystemCollectionsGenericKeyNotFoundException;
    public static string SystemCollectionsGenericLinkedList1;
    public static string SystemCollectionsGenericList1;
    public static string SystemCollectionsGenericPriorityQueue2;
    public static string SystemCollectionsGenericQueue1;
    public static string SystemCollectionsGenericStack1;
    public static string SystemCollectionsGenericSortedSet1;
    public static string SystemCollectionsICollection;
    public static string SystemCollectionsIDictionary;
    public static string SystemCollectionsIEnumerable;
    public static string SystemCollectionsIEnumerator;
    public static string SystemCollectionsIHashCodeProvider;
    public static string SystemCollectionsIList;
    public static string SystemCollectionsImmutableIImmutableDictionary2;
    public static string SystemCollectionsImmutableIImmutableList;
    public static string SystemCollectionsImmutableIImmutableList1;
    public static string SystemCollectionsImmutableImmutableList;
    public static string SystemCollectionsImmutableIImmutableQueue1;
    public static string SystemCollectionsImmutableIImmutableSet1;
    public static string SystemCollectionsImmutableIImmutableStack1;
    public static string SystemCollectionsImmutableImmutableArray;
    public static string SystemCollectionsImmutableImmutableArray1;
    public static string SystemCollectionsImmutableImmutableDictionary;
    public static string SystemCollectionsImmutableImmutableDictionary2;
    public static string SystemCollectionsImmutableImmutableHashSet;
    public static string SystemCollectionsImmutableImmutableHashSet1;
    public static string SystemCollectionsImmutableImmutableList1;
    public static string SystemCollectionsImmutableImmutableSortedDictionary;
    public static string SystemCollectionsImmutableImmutableSortedDictionary2;
    public static string SystemCollectionsImmutableImmutableSortedSet;
    public static string SystemCollectionsImmutableImmutableSortedSet1;
    public static string SystemCollectionsObjectModelReadOnlyCollection1;
    public static string SystemCollectionsObjectModelReadOnlyDictionary2;
    public static string SystemCollectionsObjectModelReadOnlyObservableCollection1;
    public static string SystemCollectionsQueue;
    public static string SystemCollectionsSpecializedNameValueCollection;
    public static string SystemCollectionsStack;
    public static string SystemComponentModelComponent;
    public static string SystemComponentModelCompositionExportAttribute;
    public static string SystemComponentModelCompositionImportingConstructorAttribute;
    public static string SystemComponentModelCompositionInheritedExportAttribute;
    public static string SystemComponentModelDesignerAttribute;
    public static string SystemComponentModelDesignerCategoryAttribute;
    public static string SystemComponentModelLocalizableAttribute;
    public static string SystemCompositionExportAttribute;
    public static string SystemCompositionImportingConstructorAttribute;
    public static string SystemConfigurationConfigurationSection;
    public static string SystemConfigurationIConfigurationSectionHandler;
    public static string SystemConsole;
    public static string SystemConvert;
    public static string SystemDataDataRow;
    public static string SystemDataDataSet;
    public static string SystemDataDataTable;
    public static string SystemDataDataViewManager;
    public static string SystemDataEntityDbSet1;
    public static string SystemDataEntityQueryableExtensions;
    public static string SystemDataIDataAdapter;
    public static string SystemDataIDbCommand;
    public static string SystemDataOdbcOdbcParameter;
    public static string SystemDataOleDbOleDbParameter;
    public static string SystemDataSqlClientSqlParameter;
    public static string SystemDataTypedTableBase1;
    public static string SystemDateTime;
    public static string SystemDateTimeOffset;
    public static string SystemDecimal;
    public static string SystemDiagnosticContractsContract;
    public static string SystemDiagnosticsCodeAnalysisConstantExpectedAttribute;
    public static string SystemDiagnosticsCodeAnalysisNotNullAttribute;
    public static string SystemDiagnosticsConditionalAttribute;
    public static string SystemDiagnosticsContractsPureAttribute;
    public static string SystemDiagnosticsDebug;
    public static string SystemDiagnosticsDebuggerNonUserCode;
    public static string SystemDiagnosticsDebuggerTypeProxyAttribute;
    public static string SystemDiagnosticsProcess;
    public static string SystemDiagnosticsProcessModule;
    public static string SystemDiagnosticsProcessStartInfo;
    public static string SystemDiagnosticsTraceListener;
    public static string SystemDiagnosticsTracingEventSource;
    public static string SystemDirectoryDirectoryEntry;
    public static string SystemDirectoryServicesActiveDirectoryADSearcher;
    public static string SystemDirectoryServicesDirectorySearcher;
    public static string SystemDouble;
    public static string SystemEnvironment;
    public static string SystemEventArgs;
    public static string SystemEventHandler1;
    public static string SystemException;
    public static string SystemExecutionEngineException;
    public static string SystemFlagsAttribute;
    public static string SystemGC;
    public static string SystemGlobalizationCultureInfo;
    public static string SystemGuid;
    public static string SystemHashCode;
    public static string SystemIAsyncDisposable;
    public static string SystemIComparable;
    public static string SystemIComparable1;
    public static string SystemIDisposable;
    public static string SystemIEquatable1;
    public static string SystemIFormatProvider;
    public static string SystemIndex;
    public static string SystemInt16;
    public static string SystemInt32;
    public static string SystemInt64;
    public static string SystemInvalidOperationException;
    public static string SystemIOCompressionZipArchiveEntry;
    public static string SystemIOCompressionZipFileExtensions;
    public static string SystemIODirectory;
    public static string SystemIODirectoryInfo;
    public static string SystemIOFile;
    public static string SystemIOFileInfo;
    public static string SystemIOFileStream;
    public static string SystemIOLogLogStore;
    public static string SystemIOMemoryStream;
    public static string SystemIOPath;
    public static string SystemIOStream;
    public static string SystemIOStringReader;
    public static string SystemIOUnmanagedMemoryStream;
    public static string SystemIParsable1;
    public static string SystemIProgress1;
    public static string SystemLinqEnumerable;
    public static string SystemLinqExpressionsExpression1;
    public static string SystemLinqIOrderedEnumerable1;
    public static string SystemLinqQueryable;
    public static string SystemMarshalByRefObject;
    public static string SystemMemory1;
    public static string SystemMemoryExtensions;
    public static string SystemNetHttpHttpClient;
    public static string SystemNetHttpHttpClientHandler;
    public static string SystemNetHttpWinHttpHandler;
    public static string SystemNetSecurityProtocolType;
    public static string SystemNetSecurityRemoteCertificateValidationCallback;
    public static string SystemNetSecuritySslPolicyErrors;
    public static string SystemNetServicePointManager;
    public static string SystemNonSerializedAttribute;
    public static string SystemNotImplementedException;
    public static string SystemNotSupportedException;
    public static string SystemNullable1;
    public static string SystemNumber;
    public static string SystemNumericsINumber1;
    public static string SystemObject;
    public static string SystemObjectDisposedException;
    public static string SystemObsoleteAttribute;
    public static string SystemOperatingSystem;
    public static string SystemOperationCanceledException;
    public static string SystemOutOfMemoryException;
    public static string SystemPlatformNotSupportedException;
    public static string SystemRandom;
    public static string SystemRange;
    public static string SystemReadOnlyMemory1;
    public static string SystemReadOnlySpan1;
    public static string SystemReflectionAssembly;
    public static string SystemReflectionAssemblyName;
    public static string SystemReflectionAssemblyVersionAttribute;
    public static string SystemReflectionMemberInfo;
    public static string SystemReflectionParameterInfo;
    public static string SystemResourcesNeutralResourcesLanguageAttribute;
    public static string SystemResourcesResourceManager;
    public static string SystemRuntimeCompilerServicesAsyncMethodBuilderAttribute;
    public static string SystemRuntimeCompilerServicesCallerFilePathAttribute;
    public static string SystemRuntimeCompilerServicesCallerLineNumberAttribute;
    public static string SystemRuntimeCompilerServicesCallerMemberNameAttribute;
    public static string SystemRuntimeCompilerServicesCompilerGeneratedAttribute;
    public static string SystemRuntimeCompilerServicesConfiguredAsyncDisposable;
    public static string SystemRuntimeCompilerServicesConfiguredValueTaskAwaitable1;
    public static string SystemRuntimeCompilerServicesDisableRuntimeMarshallingAttribute;
    public static string SystemRuntimeCompilerServicesICriticalNotifyCompletion;
    public static string SystemRuntimeCompilerServicesINotifyCompletion;
    public static string SystemRuntimeCompilerServicesInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesModuleInitializerAttribute;
    public static string SystemRuntimeCompilerServicesRestrictedInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesRuntimeFeature;
    public static string SystemRuntimeCompilerServicesTaskAwaiter;
    public static string SystemRuntimeCompilerServicesTypeForwardedToAttribute;
    public static string SystemRuntimeCompilerServicesValueTaskAwaiter;
    public static string SystemRuntimeExceptionServicesHandleProcessCorruptedStateExceptionsAttribute;
    public static string SystemRuntimeInteropServicesCharSet;
    public static string SystemRuntimeInteropServicesCoClassAttribute;
    public static string SystemRuntimeInteropServicesComImportAttribute;
    public static string SystemRuntimeInteropServicesComSourceInterfacesAttribute;
    public static string SystemRuntimeInteropServicesComVisibleAttribute;
    public static string SystemRuntimeInteropServicesDefaultDllImportSearchPathsAttribute;
    public static string SystemRuntimeInteropServicesDllImportAttribute;
    public static string SystemRuntimeInteropServicesDynamicInterfaceCastableImplementationAttribute;
    public static string SystemRuntimeInteropServicesFieldOffsetAttribute;
    public static string SystemRuntimeInteropServicesGCHandle;
    public static string SystemRuntimeInteropServicesHandleRef;
    public static string SystemRuntimeInteropServicesLCIDConversionAttribute;
    public static string SystemRuntimeInteropServicesMarshal;
    public static string SystemRuntimeInteropServicesMarshalAsAttribute;
    public static string SystemRuntimeInteropServicesOSPlatform;
    public static string SystemRuntimeInteropServicesOutAttribute;
    public static string SystemRuntimeInteropServicesRuntimeInformation;
    public static string SystemRuntimeInteropServicesSafeHandle;
    public static string SystemRuntimeInteropServicesStructLayoutAttribute;
    public static string SystemRuntimeInteropServicesUnmanagedFunctionPoitnerAttribute;
    public static string SystemRuntimeInteropServicesUnmanagedType;
    public static string SystemRuntimeSerializationDataContractAttribute;
    public static string SystemRuntimeSerializationDataContractSerializer;
    public static string SystemRuntimeSerializationDataMemberAttribute;
    public static string SystemRuntimeSerializationFormattersBinaryBinaryFormatter;
    public static string SystemRuntimeSerializationFormattersSoapSoapFormatter;
    public static string SystemRuntimeSerializationIDeserializationCallback;
    public static string SystemRuntimeSerializationIgnoreDataMemberAttribute;
    public static string SystemRuntimeSerializationISerializable;
    public static string SystemRuntimeSerializationJsonDataContractJsonSerializer;
    public static string SystemRuntimeSerializationKnownTypeAttribute;
    public static string SystemRuntimeSerializationNetDataContractSerializer;
    public static string SystemRuntimeSerializationOnDeserializedAttribute;
    public static string SystemRuntimeSerializationOnDeserializingAttribute;
    public static string SystemRuntimeSerializationOnSerializedAttribute;
    public static string SystemRuntimeSerializationOnSerializingAttribute;
    public static string SystemRuntimeSerializationSerializationInfo;
    public static string SystemRuntimeSerializationStreamingContext;
    public static string SystemRuntimeVersioningRequiresPreviewFeaturesAttribute;
    public static string SystemRuntimeVersioningSupportedOSPlatformAttribute;
    public static string SystemRuntimeVersioningUnsupportedOSPlatformAttribute;
    public static string SystemSecurityAuthenticationSslProtocols;
    public static string SystemSecurityCryptographyAesCcm;
    public static string SystemSecurityCryptographyAesGcm;
    public static string SystemSecurityCryptographyAsymmetricAlgorithm;
    public static string SystemSecurityCryptographyCipherMode;
    public static string SystemSecurityCryptographyCryptoConfig;
    public static string SystemSecurityCryptographyDES;
    public static string SystemSecurityCryptographyDSA;
    public static string SystemSecurityCryptographyDSASignatureFormatter;
    public static string SystemSecurityCryptographyHashAlgorithm;
    public static string SystemSecurityCryptographyHashAlgorithmName;
    public static string SystemSecurityCryptographyHMACMD5;
    public static string SystemSecurityCryptographyHMACRIPEMD160;
    public static string SystemSecurityCryptographyHMACSHA1;
    public static string SystemSecurityCryptographyMD5;
    public static string SystemSecurityCryptographyPasswordDeriveBytes;
    public static string SystemSecurityCryptographyRC2;
    public static string SystemSecurityCryptographyRfc2898DeriveBytes;
    public static string SystemSecurityCryptographyRIPEMD160;
    public static string SystemSecurityCryptographyRSA;
    public static string SystemSecurityCryptographySHA1;
    public static string SystemSecurityCryptographySHA256;
    public static string SystemSecurityCryptographySymmetricAlgorithm;
    public static string SystemSecurityCryptographyTripleDES;
    public static string SystemSecurityCryptographyX509CertificatesStoreName;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate2;
    public static string SystemSecurityCryptographyX509CertificatesX509Chain;
    public static string SystemSecurityCryptographyX509CertificatesX509Store;
    public static string SystemSecurityIPermission;
    public static string SystemSecurityPolicyIMembershipCondition;
    public static string SystemSerializableAttribute;
    public static string SystemServiceModelMessageContractAttribute;
    public static string SystemServiceModelOperationContractAttribute;
    public static string SystemSingle;
    public static string SystemSpan1;
    public static string SystemStackOverflowException;
    public static string SystemString;
    public static string SystemStringComparison;
    public static string SystemSystemException;
    public static string SystemTextEncoding;
    public static string SystemTextRegularExpressionsRegex;
    public static string SystemTextStringBuilder;
    public static string SystemThreadStaticAttribute;
    public static string SystemThreadingCancellationToken;
    public static string SystemThreadingInterlocked;
    public static string SystemThreadingMonitor;
    public static string SystemThreadingSpinLock;
    public static string SystemThreadingTasksTask;
    public static string SystemThreadingTasksTask1;
    public static string SystemThreadingTasksTaskCompletionSource;
    public static string SystemThreadingTasksTaskCompletionSource1;
    public static string SystemThreadingTasksTaskContinuationOptions;
    public static string SystemThreadingTasksTaskCreationOptions;
    public static string SystemThreadingTasksTaskFactory;
    public static string SystemThreadingTasksTaskScheduler;
    public static string SystemThreadingTasksValueTask;
    public static string SystemThreadingTasksValueTask1;
    public static string SystemThreadingThread;
    public static string SystemTimeSpan;
    public static string SystemType;
    public static string SystemUri;
    public static string SystemWebConfigurationHttpRuntimeSection;
    public static string SystemWebHttpApplication;
    public static string SystemWebHttpCookie;
    public static string SystemWebHttpRequest;
    public static string SystemWebHttpRequestBase;
    public static string SystemWebHttpRequestWrapper;
    public static string SystemWebHttpResponse;
    public static string SystemWebHttpResponseBase;
    public static string SystemWebHttpRouteAttribute;
    public static string SystemWebHttpServerUtility;
    public static string SystemWebHttpServerUtilityBase;
    public static string SystemWebHttpServerUtilityWrapper;
    public static string SystemWebHttpUtility;
    public static string SystemWebMvcAcceptVerbsAttribute;
    public static string SystemWebMvcActionResult;
    public static string SystemWebMvcChildActionOnlyAttribute;
    public static string SystemWebMvcController;
    public static string SystemWebMvcControllerBase;
    public static string SystemWebMvcHttpDeleteAttribute;
    public static string SystemWebMvcHttpGetAttribute;
    public static string SystemWebMvcHttpHeadAttribute;
    public static string SystemWebMvcHttpOptionsAttribute;
    public static string SystemWebMvcHttpPatchAttribute;
    public static string SystemWebMvcHttpPostAttribute;
    public static string SystemWebMvcHttpPutAttribute;
    public static string SystemWebMvcHttpVerbs;
    public static string SystemWebMvcNonActionAttribute;
    public static string SystemWebMvcValidateAntiForgeryTokenAttribute;
    public static string SystemWebMvcValidateInputAttribute;
    public static string SystemWebScriptSerializationJavaScriptSerializer;
    public static string SystemWebScriptSerializationJavaScriptTypeResolver;
    public static string SystemWebScriptSerializationSimpleTypeResolver;
    public static string SystemWebSecurityAntiXssAntiXssEncoder;
    public static string SystemWebSecurityAntiXssUnicodeCharacterEncoder;
    public static string SystemWebServicesWebMethodAttribute;
    public static string SystemWebUIAdaptersPageAdapter;
    public static string SystemWebUIControl;
    public static string SystemWebUIDataBoundLiteralControl;
    public static string SystemWebUIDesignerDataBoundLiteralControl;
    public static string SystemWebUIHtmlControlsHtmlContainerControl;
    public static string SystemWebUIHtmlControlsHtmlInputControl;
    public static string SystemWebUIHtmlControlsHtmlTitle;
    public static string SystemWebUIHtmlTextWriter;
    public static string SystemWebUIIndexedString;
    public static string SystemWebUIITextControl;
    public static string SystemWebUILiteralControl;
    public static string SystemWebUILosFormatter;
    public static string SystemWebUIObjectStateFormatter;
    public static string SystemWebUIPage;
    public static string SystemWebUIPageTheme;
    public static string SystemWebUIResourceBasedLiteralControl;
    public static string SystemWebUISimplePropertyEntry;
    public static string SystemWebUIStateItem;
    public static string SystemWebUIStringPropertyBuilder;
    public static string SystemWebUITemplateBuilder;
    public static string SystemWebUITemplateControl;
    public static string SystemWebUITemplateParser;
    public static string SystemWebUIWebControlsBaseDataList;
    public static string SystemWebUIWebControlsBaseValidator;
    public static string SystemWebUIWebControlsBulletedList;
    public static string SystemWebUIWebControlsButton;
    public static string SystemWebUIWebControlsButtonColumn;
    public static string SystemWebUIWebControlsButtonField;
    public static string SystemWebUIWebControlsCalendar;
    public static string SystemWebUIWebControlsChangePassword;
    public static string SystemWebUIWebControlsCheckBox;
    public static string SystemWebUIWebControlsCheckBoxField;
    public static string SystemWebUIWebControlsCommandEventArgs;
    public static string SystemWebUIWebControlsCreateUserWizard;
    public static string SystemWebUIWebControlsDataKey;
    public static string SystemWebUIWebControlsDataList;
    public static string SystemWebUIWebControlsDetailsView;
    public static string SystemWebUIWebControlsDetailsViewInsertEventArgs;
    public static string SystemWebUIWebControlsDetailsViewUpdateEventArgs;
    public static string SystemWebUIWebControlsFormView;
    public static string SystemWebUIWebControlsFormViewInsertEventArgs;
    public static string SystemWebUIWebControlsFormViewUpdateEventArgs;
    public static string SystemWebUIWebControlsGridView;
    public static string SystemWebUIWebControlsHiddenField;
    public static string SystemWebUIWebControlsHyperLink;
    public static string SystemWebUIWebControlsHyperLinkColumn;
    public static string SystemWebUIWebControlsHyperLinkField;
    public static string SystemWebUIWebControlsImage;
    public static string SystemWebUIWebControlsImageButton;
    public static string SystemWebUIWebControlsLabel;
    public static string SystemWebUIWebControlsLinkButton;
    public static string SystemWebUIWebControlsListControl;
    public static string SystemWebUIWebControlsListItem;
    public static string SystemWebUIWebControlsLiteral;
    public static string SystemWebUIWebControlsLogin;
    public static string SystemWebUIWebControlsMenu;
    public static string SystemWebUIWebControlsMenuItem;
    public static string SystemWebUIWebControlsMenuItemBinding;
    public static string SystemWebUIWebControlsPasswordRecovery;
    public static string SystemWebUIWebControlsQueryStringParameter;
    public static string SystemWebUIWebControlsRadioButtonList;
    public static string SystemWebUIWebControlsRepeatInfo;
    public static string SystemWebUIWebControlsServerValidateEventArgs;
    public static string SystemWebUIWebControlsSqlDataSource;
    public static string SystemWebUIWebControlsTable;
    public static string SystemWebUIWebControlsTableCell;
    public static string SystemWebUIWebControlsTextBox;
    public static string SystemWebUIWebControlsTreeNode;
    public static string SystemWebUIWebControlsTreeNodeBinding;
    public static string SystemWebUIWebControlsTreeView;
    public static string SystemWebUIWebControlsUnit;
    public static string SystemWebUIWebControlsWebPartsAppearanceEditorPart;
    public static string SystemWebUIWebControlsWebPartsPersonalizationEntry;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogAddVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConfigureVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsDisconnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartDeleteVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorApplyVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorOKVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartExportVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHeaderCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHelpVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartMinimizeVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartRestoreVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartVerb;
    public static string SystemWebUIWebControlsXmlDataSource;
    public static string SystemWebUIXPathBinder;
    public static string SystemWebUtilHttpEncoder;
    public static string SystemWindowsAssemblyPart;
    public static string SystemWindowsMarkupXamlReader;
    public static string SystemXmlDtdProcessing;
    public static string SystemXmlSchemaXmlSchema;
    public static string SystemXmlSchemaXmlSchemaCollection;
    public static string SystemXmlSchemaXmlSchemaXPath;
    public static string SystemXmlSerializationXmlAnyAttributeAttribute;
    public static string SystemXmlSerializationXmlAnyElementAttribute;
    public static string SystemXmlSerializationXmlArrayAttribute;
    public static string SystemXmlSerializationXmlArrayItemAttribute;
    public static string SystemXmlSerializationXmlAttributeAttribute;
    public static string SystemXmlSerializationXmlChoiceIdentifierAttribute;
    public static string SystemXmlSerializationXmlElementAttribute;
    public static string SystemXmlSerializationXmlEnumAttribute;
    public static string SystemXmlSerializationXmlIgnoreAttribute;
    public static string SystemXmlSerializationXmlIncludeAttribute;
    public static string SystemXmlSerializationXmlRootAttribute;
    public static string SystemXmlSerializationXmlSerializer;
    public static string SystemXmlSerializationXmlTextAttribute;
    public static string SystemXmlSerializationXmlTypeAttribute;
    public static string SystemXmlXmlAttribute;
    public static string SystemXmlXmlDocument;
    public static string SystemXmlXmlDocumentFragment;
    public static string SystemXmlXmlElement;
    public static string SystemXmlXmlEntity;
    public static string SystemXmlXmlNode;
    public static string SystemXmlXmlNotation;
    public static string SystemXmlXmlReader;
    public static string SystemXmlXmlReaderSettings;
    public static string SystemXmlXmlResolver;
    public static string SystemXmlXmlSecureResolver;
    public static string SystemXmlXmlTextReader;
    public static string SystemXmlXmlTextWriter;
    public static string SystemXmlXmlValidatingReader;
    public static string SystemXmlXmlWriter;
    public static string SystemXmlXPathXPathDocument;
    public static string SystemXmlXPathXPathExpression;
    public static string SystemXmlXPathXPathNavigator;
    public static string SystemXmlXslXslCompiledTransform;
    public static string SystemXmlXslXslTransform;
    public static string SystemXmlXslXsltSettings;
    public static string XunitAssert;
    public static string XunitCombinatorialDataAttribute;
    public static string XunitCombinatorialRangeAttribute;
    public static string XunitFactAttribute;
    public static string XunitSdkDataAttribute;
    public static string XunitTraitAttribute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Analyzer.Utilities.WellKnownTypeProvider : object {
    private static BoundedCacheWithFactory`2<Compilation, WellKnownTypeProvider> s_providerCache;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    private Lazy`1<ImmutableHashSet`1<IAssemblySymbol>> _referencedAssemblies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, INamedTypeSymbol> _fullNameToTypeMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ImmutableArray`1<string>> _fullTypeNameToNamespaceNames;
    public Compilation Compilation { get; }
    private WellKnownTypeProvider(Compilation compilation);
    private static WellKnownTypeProvider();
    public static WellKnownTypeProvider GetOrCreate(Compilation compilation);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public bool TryGetOrCreateTypeByMetadataName(string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    private bool TryGetOrCreateTypeByMetadataNameSlow(string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    public INamedTypeSymbol GetOrCreateTypeByMetadataName(string fullTypeName);
    internal bool IsTaskOfType(ITypeSymbol typeSymbol, Func`2<ITypeSymbol, bool> typeArgumentPredicate);
    private static ImmutableArray`1<string> GetNamespaceNamesFromFullTypeName(string fullTypeName);
    private static bool IsIdentifierPartCharacter(char ch);
    private static bool IsSubsetOfCollection(ImmutableArray`1<T> set1, ICollection`1<T> set2);
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IAssemblySymbol> <.ctor>b__1_0();
    [CompilerGeneratedAttribute]
internal static WellKnownTypeProvider <GetOrCreate>g__CreateWellKnownTypeProvider|2_0(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.WordParser : object {
    private static char NullChar;
    private WordParserOptions _options;
    private StringBuilder _buffer;
    private string _text;
    [NullableAttribute("2")]
private string _peekedWord;
    private int _index;
    private char _prefix;
    private bool SkipMnemonics { get; }
    private bool SplitCompoundWords { get; }
    public WordParser(string text, WordParserOptions options);
    public WordParser(string text, WordParserOptions options, char prefix);
    private bool get_SkipMnemonics();
    private bool get_SplitCompoundWords();
    internal static Collection`1<string> Parse(string text, WordParserOptions options);
    internal static Collection`1<string> Parse(string text, WordParserOptions options, char prefix);
    public static bool ContainsWord(string text, WordParserOptions options, ImmutableArray`1<string> words);
    internal static bool ContainsWord(string text, WordParserOptions options, char prefix, ImmutableArray`1<string> words);
    [NullableContextAttribute("2")]
public string NextWord();
    [NullableContextAttribute("2")]
public string PeekWord();
    [NullableContextAttribute("2")]
private string NextWordCore();
    private bool ParseNext();
    private bool TryParseWord(char c);
    private bool TryParsePrefix();
    private void ParseWholeWord();
    private void ParseInteger();
    private void ParseHex();
    private void ParseNumeric();
    private void ParseLowercase();
    private void ParseUppercase();
    private void ParseWithoutCase();
    private void ParseAllCaps();
    private void Read();
    private void Skip();
    private char Peek();
    private char Peek(int lookAhead);
    private void Unread();
    private bool IsIgnored(char c);
    private static bool IsLower(char c);
    private static bool IsUpper(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsLetterWithoutCase(char c);
    private static bool IsDigit(char c);
    private static bool IsHexDigit(char c);
    private static bool IsIntraWordPunctuation(char c);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.WordParserOptions : Enum {
    public int value__;
    public static WordParserOptions None;
    public static WordParserOptions IgnoreMnemonicsIndicators;
    public static WordParserOptions SplitCompoundWords;
}
internal static class Microsoft.CodeAnalysis.BannedApiAnalyzers.BannedApiAnalyzerResources : object {
    [NullableAttribute("1")]
private static Type s_resourcesType;
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateBannedSymbolDescription { get; }
    internal static string DuplicateBannedSymbolMessage { get; }
    internal static string DuplicateBannedSymbolTitle { get; }
    internal static string SymbolIsBannedDescription { get; }
    internal static string SymbolIsBannedMessage { get; }
    internal static string SymbolIsBannedTitle { get; }
    internal static string RestrictedInternalsVisibleToDescription { get; }
    internal static string RestrictedInternalsVisibleToMessage { get; }
    internal static string RestrictedInternalsVisibleToTitle { get; }
    private static BannedApiAnalyzerResources();
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource);
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource, String[] formatArguments);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_DuplicateBannedSymbolDescription();
    internal static string get_DuplicateBannedSymbolMessage();
    internal static string get_DuplicateBannedSymbolTitle();
    internal static string get_SymbolIsBannedDescription();
    internal static string get_SymbolIsBannedMessage();
    internal static string get_SymbolIsBannedTitle();
    internal static string get_RestrictedInternalsVisibleToDescription();
    internal static string get_RestrictedInternalsVisibleToMessage();
    internal static string get_RestrictedInternalsVisibleToTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BannedApiAnalyzers.RestrictedInternalsVisibleToAnalyzer`2 : DiagnosticAnalyzer {
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [NullableAttribute("0")]
protected ImmutableArray`1<TSyntaxKind> NameSyntaxKinds { get; }
    private static RestrictedInternalsVisibleToAnalyzer`2();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> get_NameSyntaxKinds();
    protected abstract virtual bool IsInTypeOnlyContext(TNameSyntax node);
    public virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext compilationContext);
    private static ImmutableDictionary`2<IAssemblySymbol, ImmutableSortedSet`1<string>> GetRestrictedInternalsVisibleToMap(Compilation compilation);
    private static void VerifySymbol(ISymbol symbol, SyntaxNode node, Action`1<Diagnostic> reportDiagnostic, ImmutableDictionary`2<IAssemblySymbol, ImmutableSortedSet`1<string>> restrictedInternalsVisibleToMap, ConcurrentDictionary`2<INamespaceSymbol, bool> namespaceToIsBannedMap);
    private static bool IsBannedSymbol(ISymbol symbol, ImmutableDictionary`2<IAssemblySymbol, ImmutableSortedSet`1<string>> restrictedInternalsVisibleToMap, ConcurrentDictionary`2<INamespaceSymbol, bool> namespaceToIsBannedMap);
    [NullableContextAttribute("2")]
private static void MarkIsBanned(INamespaceSymbol startNamespace, INamespaceSymbol uptoNamespace, ConcurrentDictionary`2<INamespaceSymbol, bool> namespaceToIsBannedMap, bool banned);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.BannedApiAnalyzers.SymbolIsBannedAnalyzer : object {
    public static DiagnosticDescriptor SymbolIsBannedRule;
    public static DiagnosticDescriptor DuplicateBannedSymbolRule;
    private static SymbolIsBannedAnalyzer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BannedApiAnalyzers.SymbolIsBannedAnalyzer`1 : SymbolIsBannedAnalyzerBase`1<TSyntaxKind> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticDescriptor SymbolIsBannedRule { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual DiagnosticDescriptor get_SymbolIsBannedRule();
    protected sealed virtual Dictionary`2<ISymbol, BanFileEntry<TSyntaxKind>> ReadBannedApis(CompilationStartAnalysisContext compilationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BannedApiAnalyzers.SymbolIsBannedAnalyzerBase`1 : DiagnosticAnalyzer {
    protected DiagnosticDescriptor SymbolIsBannedRule { get; }
    [NullableAttribute("0")]
protected TSyntaxKind XmlCrefSyntaxKind { get; }
    protected SymbolDisplayFormat SymbolDisplayFormat { get; }
    protected abstract virtual Dictionary`2<ISymbol, BanFileEntry<TSyntaxKind>> ReadBannedApis(CompilationStartAnalysisContext compilationContext);
    protected abstract virtual DiagnosticDescriptor get_SymbolIsBannedRule();
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_XmlCrefSyntaxKind();
    protected abstract virtual SyntaxNode GetReferenceSyntaxNodeFromXmlCref(SyntaxNode syntaxNode);
    protected abstract virtual SymbolDisplayFormat get_SymbolDisplayFormat();
    public virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext compilationContext);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BannedApiAnalyzers.SymbolIsBannedAnalyzerBase`1/<<OnCompilationStart>g__GetSymbolAndOverridenSymbols|9_12>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ISymbol> <OnCompilationStart>g__GetSymbolAndOverridenSymbols|9_12(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData : object {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ComputationalComplexityMetrics <ComputationalComplexityMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaintainabilityIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <CoupledNamedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SourceLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DepthOfInheritance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<CodeAnalysisMetricData> <Children>k__BackingField;
    public ISymbol Symbol { get; }
    internal ComputationalComplexityMetrics ComputationalComplexityMetrics { get; }
    public int MaintainabilityIndex { get; }
    public ImmutableHashSet`1<INamedTypeSymbol> CoupledNamedTypes { get; }
    public long SourceLines { get; }
    public long ExecutableLines { get; }
    public int CyclomaticComplexity { get; }
    public Nullable`1<int> DepthOfInheritance { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CodeAnalysisMetricData> Children { get; }
    internal CodeAnalysisMetricData(ISymbol symbol, int maintainabilityIndex, ComputationalComplexityMetrics computationalComplexityMetrics, ImmutableHashSet`1<INamedTypeSymbol> coupledNamedTypes, long linesOfCode, int cyclomaticComplexity, Nullable`1<int> depthOfInheritance, ImmutableArray`1<CodeAnalysisMetricData> children);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
internal ComputationalComplexityMetrics get_ComputationalComplexityMetrics();
    [CompilerGeneratedAttribute]
public int get_MaintainabilityIndex();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<INamedTypeSymbol> get_CoupledNamedTypes();
    [CompilerGeneratedAttribute]
public long get_SourceLines();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public int get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DepthOfInheritance();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CodeAnalysisMetricData> get_Children();
    public sealed virtual string ToString();
    [ObsoleteAttribute("Use ComputeAsync(CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(CodeMetricsAnalysisContext context);
    [ObsoleteAttribute("Use ComputeAsync(ISymbol, CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<ComputeAsync>d__34")]
internal static Task`1<ImmutableArray`1<CodeAnalysisMetricData>> ComputeAsync(IEnumerable`1<ISymbol> children, CodeMetricsAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <ToString>g__appendChildren|29_0(string indent, <>c__DisplayClass29_0& );
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<<ComputeAsync>g__ComputeAsync|33_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<CodeAnalysisMetricData> <ComputeAsync>g__ComputeAsync|33_0(ISymbol symbol, CodeMetricsAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext : object {
    private ConcurrentDictionary`2<SyntaxTree, SemanticModel> _semanticModelMap;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<INamedTypeSymbol, bool> <IsExcludedFromInheritanceCountFunc>k__BackingField;
    public Compilation Compilation { get; }
    public CancellationToken CancellationToken { get; }
    public Func`2<INamedTypeSymbol, bool> IsExcludedFromInheritanceCountFunc { get; }
    public CodeMetricsAnalysisContext(Compilation compilation, CancellationToken cancellationToken, Func`2<INamedTypeSymbol, bool> isExcludedFromInheritanceCountFunc);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public Func`2<INamedTypeSymbol, bool> get_IsExcludedFromInheritanceCountFunc();
    internal SemanticModel GetSemanticModel(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics : object {
    internal static ComputationalComplexityMetrics Default;
    private static object s_nullConstantPlaceholder;
    private long _symbolUsageCounts;
    private long _constantUsageCounts;
    private ImmutableHashSet`1<OperationKind> _distinctOperatorKinds;
    private ImmutableHashSet`1<BinaryOperatorKind> _distinctBinaryOperatorKinds;
    private ImmutableHashSet`1<UnaryOperatorKind> _distinctUnaryOperatorKinds;
    private ImmutableHashSet`1<CaseKind> _distinctCaseKinds;
    private ImmutableHashSet`1<ISymbol> _distinctReferencedSymbols;
    private ImmutableHashSet`1<object> _distinctReferencedConstants;
    [CompilerGeneratedAttribute]
private long <TotalOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EffectiveLinesOfCode>k__BackingField;
    public bool IsDefault { get; }
    public long DistinctOperators { get; }
    public long DistinctOperands { get; }
    public long TotalOperators { get; }
    public long TotalOperands { get; }
    public long Vocabulary { get; }
    public long Length { get; }
    public double Volume { get; }
    public long ExecutableLines { get; }
    public long EffectiveLinesOfCode { get; }
    private ComputationalComplexityMetrics(long executableLinesOfCode, long effectiveLinesOfMaintainableCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    private static ComputationalComplexityMetrics();
    private static ComputationalComplexityMetrics Create(long executableLinesOfCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, bool hasSymbolInitializer, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    public static ComputationalComplexityMetrics Compute(IOperation operationBlock);
    public ComputationalComplexityMetrics Union(ComputationalComplexityMetrics other);
    public bool get_IsDefault();
    public long get_DistinctOperators();
    public long get_DistinctOperands();
    [CompilerGeneratedAttribute]
public long get_TotalOperators();
    public long get_TotalOperands();
    public long get_Vocabulary();
    public long get_Length();
    public double get_Volume();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public long get_EffectiveLinesOfCode();
    [CompilerGeneratedAttribute]
internal static int <Compute>g__getExecutableLinesOfCode|12_0(IOperation operation, Boolean& hasSymbolInitializer);
    [CompilerGeneratedAttribute]
internal static bool <Compute>g__hasAnyExplicitExpression|12_1(IOperation operation);
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countOperator|12_2(IOperation operation, <>c__DisplayClass12_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <Compute>g__countOperand|12_3(ISymbol symbol, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countBinaryOperator|12_4(IOperation operation, BinaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countUnaryOperator|12_5(IOperation operation, UnaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper : object {
    internal static int GetAverageRoundedMetricValue(int total, int childrenCount);
    private static int RoundMetricValue(double value);
    internal static int NormalizeAndRoundMaintainabilityIndex(double maintIndex);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, IEnumerable`1<ITypeSymbol> coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ITypeSymbol[] coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<IParameterSymbol> parameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetLinesOfCodeAsync>d__6")]
internal static Task`1<long> GetLinesOfCodeAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetTopmostSyntaxNodeForDeclarationAsync>d__7")]
internal static Task`1<SyntaxNode> GetTopmostSyntaxNodeForDeclarationAsync(SyntaxReference declaration, ISymbol declaredSymbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>d__8")]
internal static Task`1<ValueTuple`2<int, ComputationalComplexityMetrics>> ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, Builder<INamedTypeSymbol> builder, CodeMetricsAnalysisContext context);
    private static void AddCoupledNamedTypesCore(Builder<INamedTypeSymbol> builder, ITypeSymbol typeOpt, WellKnownTypeProvider wellKnownTypeProvider);
    internal static void RemoveContainingTypes(ISymbol symbol, Builder<INamedTypeSymbol> coupledTypesBuilder);
    [ExtensionAttribute]
internal static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol member);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_0(SyntaxTriviaList trivialList, bool leading);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_1(ImmutableArray`1<string> triviaParts, bool leading);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForLeading|6_2(int index, int length);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForTrailing|6_3(int index, int _);
    [CompilerGeneratedAttribute]
internal static bool <ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>g__hasConditionalLogic|8_0(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <AddCoupledNamedTypesCore>g__isIgnoreableType|9_0(INamedTypeSymbol namedType, WellKnownTypeProvider wellKnownTypeProvider);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ReportDiagnosticExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToAnalyzerConfigString(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static bool IsLessSevereThan(ReportDiagnostic current, ReportDiagnostic other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter : object {
    private static string RuleSetNodeName;
    private static string RuleSetNameAttributeName;
    private static string RuleSetDescriptionAttributeName;
    private static string RulesNodeName;
    private static string RuleNodeName;
    private static string RuleIdAttributeName;
    public static void GenerateEditorconfig(string rulesetFilePath, string editorconfigFilePath);
    public static string GetEditorconfig(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static XElement <GetEditorconfig>g__GetTopLevelRulesetNode|7_0(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__ProcessComments|7_1(RuleSet ruleset, HashSet`1<string> processedRulesetPaths, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__PopulateRuleIdToComments|7_2(string rulesetFilePath, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_5(XComment comment, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__UpdateCurrentRuleIdPostCommentAndResetState|7_6(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_3(StringBuilder builder, string comment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SymbolEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static SymbolEqualityComparer <Default>k__BackingField;
    public static SymbolEqualityComparer Default { get; }
    private static SymbolEqualityComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(ISymbol obj);
    [CompilerGeneratedAttribute]
public static SymbolEqualityComparer get_Default();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.WellKnownDiagnosticTagsExtensions : object {
    public static string EnabledRuleInAggressiveMode;
    public static string Dataflow;
    public static string CompilationEnd;
    public static String[] DataflowAndTelemetry;
    public static String[] DataflowAndTelemetryEnabledInAggressiveMode;
    public static String[] Telemetry;
    public static String[] TelemetryEnabledInAggressiveMode;
    public static String[] CompilationEndAndTelemetry;
    private static WellKnownDiagnosticTagsExtensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Diagnostics.Analyzers.RoslynDiagnosticIds : object {
    public static string UseEmptyEnumerableRuleId;
    public static string UseSingletonEnumerableRuleId;
    public static string UseSiteDiagnosticsCheckerRuleId;
    public static string MixedVersionsOfMefAttributesRuleId;
    public static string DeclarePublicApiRuleId;
    public static string RemoveDeletedPublicApiRuleId;
    public static string SymbolDeclaredEventRuleId;
    public static string ExposedNoninstantiableTypeRuleIdPublic;
    public static string MissingSharedAttributeRuleId;
    public static string PublicApiFilesInvalid;
    public static string DuplicatedSymbolInPublicApiFiles;
    public static string AvoidMultipleOverloadsWithOptionalParametersPublic;
    public static string OverloadWithOptionalParametersShouldHaveMostParametersPublic;
    public static string RoslynAnalyzerMustUseIdInSpecifiedRangeRuleId;
    public static string RoslynAnalyzerMustUseCategoriesFromSpecifiedRangeRuleId;
    public static string SymbolIsBannedRuleId;
    public static string DuplicateBannedSymbolRuleId;
    public static string TestExportsShouldNotBeDiscoverableRuleId;
    public static string ImportingConstructorShouldBeObsoleteRuleId;
    public static string ExportedPartsShouldHaveImportingConstructorRuleId;
    public static string RestrictedInternalsVisibleToRuleId;
    public static string AnnotatePublicApiRuleId;
    public static string ShouldAnnotatePublicApiFilesRuleId;
    public static string PreferNullLiteralRuleId;
    public static string RelaxTestNamingSuppressionRuleId;
    public static string DefaultableTypeShouldHaveDefaultableFieldsRuleId;
    public static string ObliviousPublicApiRuleId;
    public static string DoNotCopyValueRuleId;
    public static string DoNotCallGetTestAccessorRuleId;
    public static string AvoidOptSuffixForNullableEnableCodeRuleId;
    public static string NamedTypeFullNameNotNullSuppressionRuleId;
    public static string PublicApiFileMissing;
    public static string TemporaryArrayAsRefRuleId;
    public static string RemovedApiIsNotActuallyRemovedRuleId;
    public static string DeclareInternalApiRuleId;
    public static string RemoveDeletedInternalApiRuleId;
    public static string InternalApiFilesInvalid;
    public static string DuplicatedSymbolInInternalApiFiles;
    public static string AnnotateInternalApiRuleId;
    public static string ShouldAnnotateInternalApiFilesRuleId;
    public static string ObliviousInternalApiRuleId;
    public static string InternalApiFileMissing;
    public static string AvoidMultipleOverloadsWithOptionalParametersInternal;
    public static string OverloadWithOptionalParametersShouldHaveMostParametersInternal;
    public static string ExposedNoninstantiableTypeRuleIdInternal;
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.ISetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRange(ISet`1<T> set, IEnumerable`1<T> values);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<TSource> source);
    [ExtensionAttribute]
public static bool HasExactly(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(ImmutableArray`1<TSource> source, int count);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableHashSetExtensions : object {
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> AddRange(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> IntersectSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static bool IsSubsetOfSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static void AddIfNotNull(Builder<T> builder, T item);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[IsReadOnlyAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StringCompatExtensions : object {
    [ExtensionAttribute]
public static bool Contains(string str, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string Replace(string str, string oldValue, string newValue, StringComparison comparisonType);
}
