[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProvider : ValueType {
    private IOptionsReader _options;
    private HostLanguageServices _languageServices;
    private CodeActionOptionsProvider _fallbackOptions;
    public string NewLine { get; }
    public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; }
    public CodeStyleOption2`1<bool> VarElsewhere { get; }
    public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; }
    public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; }
    public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; }
    public CodeStyleOption2`1<string> PreferredModifierOrder { get; }
    public CodeStyleOption2`1<AccessibilityModifiersRequired> AccessibilityModifiersRequired { get; }
    private CSharpIdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private CSharpSimplifierOptions FallbackSimplifierOptions { get; }
    private CSharpSyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private LineFormattingOptions FallbackLineFormattingOptions { get; }
    private AddImportPlacementOptions FallbackAddImportPlacementOptions { get; }
    public CSharpCodeFixOptionsProvider(IOptionsReader options, CodeActionOptionsProvider fallbackOptions, HostLanguageServices languageServices);
    public string get_NewLine();
    public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    public CodeStyleOption2`1<bool> get_VarElsewhere();
    public SimplifierOptions GetSimplifierOptions();
    public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    internal CSharpSyntaxFormattingOptions GetFormattingOptions();
    public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    public CodeStyleOption2`1<AccessibilityModifiersRequired> get_AccessibilityModifiersRequired();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private CSharpIdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private CSharpSimplifierOptions get_FallbackSimplifierOptions();
    private CSharpSyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private LineFormattingOptions get_FallbackLineFormattingOptions();
    private AddImportPlacementOptions get_FallbackAddImportPlacementOptions();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProviders : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CSharpCodeFixOptionsProviders/<GetCSharpCodeFixOptionsProviderAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<CSharpCodeFixOptionsProvider> GetCSharpCodeFixOptionsProviderAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.CSharpFormattingCodeFixProvider : AbstractFormattingCodeFixProvider {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersCodeFixProvider : AbstractAddAccessibilityModifiersCodeFixProvider {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode MapToDeclarator(SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiersService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersService : CSharpAddAccessibilityModifiers {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAnonymousTypeMemberName.CSharpAddAnonymousTypeMemberNameCodeFixProvider : AbstractAddAnonymousTypeMemberNameCodeFixProvider`3<ExpressionSyntax, AnonymousObjectCreationExpressionSyntax, AnonymousObjectMemberDeclaratorSyntax> {
    private static string CS0746;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool HasName(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetExpression(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual AnonymousObjectMemberDeclaratorSyntax WithName(AnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(AnonymousObjectCreationExpressionSyntax initializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImport.IAddImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportsService : AbstractAddImportsService`4<CompilationUnitSyntax, BaseNamespaceDeclarationSyntax, UsingDirectiveSyntax, ExternAliasDirectiveSyntax> {
    protected string Language { get; }
    protected virtual string get_Language();
    public virtual CodeStyleOption2`1<AddImportPlacement> GetUsingDirectivePlacementCodeStyleOption(IOptionsReader configOptions, CodeStyleOption2`1<AddImportPlacement> fallbackValue);
    protected virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected virtual SyntaxNode GetAlias(UsingDirectiveSyntax usingOrAlias);
    protected virtual bool IsStaticUsing(UsingDirectiveSyntax usingOrAlias);
    protected virtual SyntaxNode Rewrite(ExternAliasDirectiveSyntax[] externAliases, UsingDirectiveSyntax[] usingDirectives, UsingDirectiveSyntax[] staticUsingDirectives, UsingDirectiveSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, AddImportPlacementOptions options, SyntaxNode root, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<UsingDirectiveSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected virtual SyntaxList`1<ExternAliasDirectiveSyntax> GetExterns(SyntaxNode node);
    protected virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddObsoleteAttribute.CSharpAddObsoleteAttributeCodeFixProvider : AbstractAddObsoleteAttributeCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddParameter.CSharpAddParameterCodeFixProvider : AbstractAddParameterCodeFixProvider`6<ArgumentSyntax, AttributeArgumentSyntax, ArgumentListSyntax, AttributeArgumentListSyntax, InvocationExpressionSyntax, BaseObjectCreationExpressionSyntax> {
    private static string CS1501;
    private static string CS1503;
    private static string CS1660;
    private static string CS1729;
    private static string CS1739;
    private static ImmutableArray`1<string> AddParameterFixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static CSharpAddParameterCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected virtual ITypeSymbol GetArgumentType(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual RegisterFixData`1<ArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AliasAmbiguousType.CSharpAliasAmbiguousTypeCodeFixProvider : AbstractAliasAmbiguousTypeCodeFixProvider {
    private static string CS0104;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetTextPreviewOfChange(string alias, ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS0177;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> GetContainer(SyntaxNode root, TextSpan span);
    private static bool IsValidLocation(SyntaxNode location);
    private static SyntaxNode GetContainer(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<GetUnassignedParametersAsync>d__9")]
private static Task`1<MultiDictionary`2<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>>> GetUnassignedParametersAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<FixAllAsync>d__10")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    protected static ImmutableArray`1<SyntaxNode> GenerateAssignmentStatements(SyntaxGenerator generator, ImmutableArray`1<IParameterSymbol> unassignedParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAboveReturnCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    private static void AddAssignmentStatements(SyntaxEditor editor, SyntaxNode exprOrStatement, ImmutableArray`1<SyntaxNode> statements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAtStartCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.AddExplicitCast.CSharpAddExplicitCastCodeFixProvider : AbstractAddExplicitCastCodeFixProvider`1<ExpressionSyntax> {
    private static string CS0266;
    private static string CS1503;
    private ArgumentFixer _argumentFixer;
    private AttributeArgumentFixer _attributeArgumentFixer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual void GetPartsOfCastOrConversionExpression(ExpressionSyntax expression, SyntaxNode& type, SyntaxNode& castedExpression);
    protected virtual ExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol type);
    protected virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, ExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS1591;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider : AbstractConvertToAsyncCodeFixProvider {
    private static string CS4008;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetDescriptionAsync>d__4")]
protected virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetRootInOtherSyntaxTreeAsync>d__5")]
protected virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetMethodDeclarationAsync>d__6")]
private static Task`1<MethodDeclarationSyntax> GetMethodDeclarationAsync(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax ConvertToAsyncFunction(MethodDeclarationSyntax methodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string AssigningNullLiteralLocallyEquivalenceKey;
    private static string AssigningNullLiteralRemotelyEquivalenceKey;
    private static string ConditionalOperatorEquivalenceKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetEquivalenceKey(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<MakeDeclarationNullableAsync>d__10")]
private static Task MakeDeclarationNullableAsync(Document document, SemanticModel model, SyntaxEditor editor, SyntaxNode node, HashSet`1<TypeSyntax> alreadyHandled, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<TryGetDeclarationTypeToFixAsync>d__11")]
private static Task`1<TypeSyntax> TryGetDeclarationTypeToFixAsync(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsExpressionSupported(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFixAsync>g__TryGetReturnType|11_0(TypeSyntax returnType, SyntaxTokenList modifiers, bool onYield);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFixAsync>g__TryGetSingleTypeArgument|11_1(TypeSyntax type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFixAsync>g__TryGetParameterTypeSyntax|11_2(IParameterSymbol parameterSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FixIncorrectConstraint.CSharpFixIncorrectConstraintCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS9010;
    private static string CS9011;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool TryGetConstraint(Diagnostic diagnostic, CancellationToken cancellationToken, TypeConstraintSyntax& constraint, SyntaxToken& enumOrDelegateKeyword);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixIncorrectConstraint.CSharpFixIncorrectConstraintCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<TryGetOldAndNewReturnTypeAsync>d__4")]
private static Task`1<ValueTuple`2<TypeSyntax, TypeSyntax>> TryGetOldAndNewReturnTypeAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`2<TypeSyntax, bool> TryGetDeclarationTypeToFix(SyntaxNode node);
    private static ITypeSymbol InferTupleType(TupleExpressionSyntax tuple, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <RegisterCodeFixesAsync>g__IsVoid|3_0(TypeSyntax typeSyntax);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<TypeSyntax, bool> <TryGetDeclarationTypeToFix>g__TryGetReturnTypeToFix|6_1(SyntaxNode containingMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ForEachCast.CSharpForEachCastCodeFixProvider : AbstractForEachCastCodeFixProvider`1<CommonForEachStatementSyntax> {
    protected virtual ITypeSymbol GetForEachElementType(SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider : CodeFixProvider {
    internal static string CS0108;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS0029;
    private static string CS0266;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider/<GetCodeFixAsync>d__5")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool TryGetExpressionType(SemanticModel model, ExpressionSyntax expression, ITypeSymbol& returnExpressionType);
    private static bool TryGetMethodReturnType(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken, ITypeSymbol& methodReturnType);
    private static bool IsCorrectTypeForYieldReturn(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, ITypeSymbol methodReturnType, SemanticModel model);
    private static bool CanConvertTypes(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, SemanticModel model);
    private static bool IsCorrectTypeForYieldReturn(ITypeSymbol methodReturnType, SemanticModel model);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS1624;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider/<GetCodeFixAsync>d__4")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool TryGetIEnumerableSymbols(SemanticModel model, INamedTypeSymbol& ienumerableSymbol, INamedTypeSymbol& ienumerableGenericSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeMemberRequired.CSharpMakeMemberRequiredCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8618;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeMemberRequired.CSharpMakeMemberRequiredCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <RegisterCodeFixesAsync>g__CanBeAccessed|5_0(SymbolVisibility containingTypeVisibility, Accessibility accessibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void MakeStatementAsynchronous(SyntaxEditor editor, SyntaxNode statementToFix);
    private static SyntaxNode TryGetStatementToFix(SyntaxNode node);
}
[ExportAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MatchFolderAndNamespace.CSharpChangeNamespaceToMatchFolderCodeFixProvider")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MatchFolderAndNamespace.CSharpChangeNamespaceToMatchFolderCodeFixProvider : AbstractChangeNamespaceToMatchFolderCodeFixProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider : CodeFixProvider {
    private static string CS0109;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, SyntaxGenerator generator, MemberDeclarationSyntax memberDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool HasPrecedingBlankLine(SyntaxTriviaList leadingTrivia, int index);
    private static bool HasFollowingBlankLine(SyntaxTriviaList leadingTrivia, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.TransposeRecordKeyword.CSharpTransposeRecordKeywordCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS9012;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool TryGetRecordDeclaration(Diagnostic diagnostic, CancellationToken cancellationToken, RecordDeclarationSyntax& recordDeclaration);
    private static bool TryGetTokens(RecordDeclarationSyntax recordDeclaration, SyntaxToken& classOrStructKeyword, SyntaxToken& recordKeyword);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeFixes.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeActionHelpers : object {
    internal static LambdaExpressionSyntax Update(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax UpdateWorker(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax WithExpressionBody(LambdaExpressionSyntax declaration, LanguageVersion languageVersion, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax WithBlockBody(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, ExpressionSyntax expressionBody);
    private static bool CreateReturnStatementForExpression(SemanticModel semanticModel, LambdaExpressionSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.UseNameofInAttribute.CSharpUseNameofInAttributeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ArgumentGenerator : object {
    public static ArgumentSyntax GenerateArgument(SyntaxNode argument);
    public static ArgumentListSyntax GenerateArgumentList(IList`1<SyntaxNode> arguments);
    public static BracketedArgumentListSyntax GenerateBracketedArgumentList(IList`1<SyntaxNode> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.AttributeGenerator : object {
    public static SyntaxList`1<AttributeListSyntax> GenerateAttributeLists(ImmutableArray`1<AttributeData> attributes, CSharpCodeGenerationContextInfo info, Nullable`1<SyntaxToken> target);
    private static AttributeListSyntax TryGenerateAttributeDeclaration(AttributeData attribute, Nullable`1<SyntaxToken> target, CSharpCodeGenerationContextInfo info);
    private static AttributeSyntax TryGenerateAttribute(AttributeData attribute, CSharpCodeGenerationContextInfo info);
    private static AttributeArgumentListSyntax GenerateAttributeArgumentList(SyntaxGenerator generator, AttributeData attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConstructorGenerator : object {
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddConstructorTo(TypeDeclarationSyntax destination, IMethodSymbol constructor, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static ConstructorDeclarationSyntax GenerateConstructorDeclaration(IMethodSymbol constructor, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConstructorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, ConstructorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static ConstructorInitializerSyntax GenerateConstructorInitializer(IMethodSymbol constructor);
    private static ArgumentListSyntax GenerateArgumentList(ImmutableArray`1<SyntaxNode> arguments);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol constructor, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConversionGenerator : object {
    internal static TypeDeclarationSyntax AddConversionTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static ConversionOperatorDeclarationSyntax GenerateConversionDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConversionOperatorDeclarationSyntax GenerateConversionDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ConversionOperatorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, ConversionOperatorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static SyntaxTokenList GenerateModifiers(CodeGenerationDestination destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationContextInfo : CodeGenerationContextInfo {
    public LanguageVersion LanguageVersion;
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationService <Service>k__BackingField;
    public CSharpCodeGenerationOptions Options { get; }
    public CSharpCodeGenerationService Service { get; }
    protected SyntaxGenerator GeneratorImpl { get; }
    protected CodeGenerationOptions OptionsImpl { get; }
    protected ICodeGenerationService ServiceImpl { get; }
    public CSharpCodeGenerationContextInfo(CodeGenerationContext context, CSharpCodeGenerationOptions options, CSharpCodeGenerationService service, LanguageVersion languageVersion);
    [CompilerGeneratedAttribute]
public CSharpCodeGenerationOptions get_Options();
    [CompilerGeneratedAttribute]
public CSharpCodeGenerationService get_Service();
    protected virtual SyntaxGenerator get_GeneratorImpl();
    protected virtual CodeGenerationOptions get_OptionsImpl();
    protected virtual ICodeGenerationService get_ServiceImpl();
    public CSharpCodeGenerationContextInfo WithContext(CodeGenerationContext value);
    protected virtual CodeGenerationContextInfo WithContextImpl(CodeGenerationContext value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationHelpers : object {
    public static TDeclarationSyntax ConditionallyAddFormattingAnnotationTo(TDeclarationSyntax result, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static void AddAccessibilityModifiers(Accessibility accessibility, ArrayBuilder`1<SyntaxToken> tokens, CSharpCodeGenerationContextInfo info, Accessibility defaultAccessibility);
    public static TypeDeclarationSyntax AddMembersTo(TypeDeclarationSyntax destination, SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private static TypeDeclarationSyntax ReplaceUnterminatedConstructs(TypeDeclarationSyntax destination);
    private static SyntaxTrivia ReplaceUnterminatedConstructs(SyntaxTrivia skippedTokensTrivia);
    private static SyntaxToken ReplaceUnterminatedConstruct(SyntaxToken token);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax FirstMember(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax FirstMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastConstructor(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax LastOperator(SyntaxList`1<MemberDeclarationSyntax> members);
    public static SyntaxList`1<TDeclaration> Insert(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    private static bool AreBracesMissing(TDeclaration declaration);
    public static SyntaxNode GetContextNode(Location location, CancellationToken cancellationToken);
    public static ExplicitInterfaceSpecifierSyntax GenerateExplicitInterfaceSpecifier(IEnumerable`1<ISymbol> implementations);
    public static CodeGenerationDestination GetDestination(SyntaxNode destination);
    public static TSyntaxNode ConditionallyAddDocumentationCommentTo(TSyntaxNode node, ISymbol symbol, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static T GetReuseableSyntaxNodeForSymbol(ISymbol symbol, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService : AbstractCodeGenerationService`1<CSharpCodeGenerationContextInfo> {
    public CodeGenerationOptions DefaultOptions { get; }
    public CSharpCodeGenerationService(LanguageServices languageServices);
    public virtual CodeGenerationOptions get_DefaultOptions();
    public virtual CodeGenerationOptions GetCodeGenerationOptions(IOptionsReader options, CodeGenerationOptions fallbackOptions);
    public virtual CSharpCodeGenerationContextInfo GetInfo(CodeGenerationContext context, CodeGenerationOptions options, ParseOptions parseOptions);
    public virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    protected virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService/<AddEventAsync>d__9")]
public virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> RemoveAttributeFromAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxNode attributeToRemove, Int32& positionOfRemovedNode, SyntaxTriviaList& triviaOfRemovedNode);
    public virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsWorker(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsToBaseMethodDeclaration(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, BaseMethodDeclarationSyntax baseMethodDeclaration);
    private static TDeclarationNode AddStatementsToLocalFunctionStatement(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, LocalFunctionStatementSyntax localFunctionStatement);
    private static TDeclarationNode AddStatementsToAnonymousFunctions(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, AnonymousFunctionExpressionSyntax anonymousFunctionSyntax);
    public virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, Func`2<SyntaxTokenList, SyntaxTokenList> computeNewModifiersList);
    public virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxTokenList UpdateDeclarationAccessibility(SyntaxTokenList modifiersList, Accessibility newAccessibility, CSharpCodeGenerationContextInfo info);
    public virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Document> <>n__0(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpDeclarationComparer : object {
    private static Dictionary`2<SyntaxKind, int> s_kindPrecedenceMap;
    private static Dictionary`2<SyntaxKind, int> s_operatorPrecedenceMap;
    public static CSharpDeclarationComparer WithNamesInstance;
    public static CSharpDeclarationComparer WithoutNamesInstance;
    private bool _includeName;
    private CSharpDeclarationComparer(bool includeName);
    private static CSharpDeclarationComparer();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SyntaxNode x, SyntaxNode y);
    private int Compare(DelegateDeclarationSyntax x, DelegateDeclarationSyntax y);
    private int Compare(BaseFieldDeclarationSyntax x, BaseFieldDeclarationSyntax y);
    private static int Compare(ConstructorDeclarationSyntax x, ConstructorDeclarationSyntax y);
    private int Compare(MethodDeclarationSyntax x, MethodDeclarationSyntax y);
    private static int Compare(ConversionOperatorDeclarationSyntax x, ConversionOperatorDeclarationSyntax y);
    private static int Compare(OperatorDeclarationSyntax x, OperatorDeclarationSyntax y);
    private int Compare(EventDeclarationSyntax x, EventDeclarationSyntax y);
    private static int Compare(IndexerDeclarationSyntax x, IndexerDeclarationSyntax y);
    private int Compare(PropertyDeclarationSyntax x, PropertyDeclarationSyntax y);
    private int Compare(EnumDeclarationSyntax x, EnumDeclarationSyntax y);
    private int Compare(BaseTypeDeclarationSyntax x, BaseTypeDeclarationSyntax y);
    private static bool ContainsToken(SyntaxTokenList list, SyntaxKind kind);
    [NullableContextAttribute("2")]
private static int GetAccessibilityPrecedence(SyntaxTokenList modifiers, SyntaxNode parent);
    private static bool BothHaveModifier(SyntaxTokenList x, SyntaxTokenList y, SyntaxKind modifierKind, Int32& comparisonResult);
    private static bool EqualStaticness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualConstness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualReadOnlyness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualAccessibility(SyntaxNode x, SyntaxTokenList xModifiers, SyntaxNode y, SyntaxTokenList yModifiers, Int32& comparisonResult);
    private static bool EqualIdentifierName(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualOperatorPrecedence(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualParameterCount(BaseParameterListSyntax x, BaseParameterListSyntax y, Int32& comparisonResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpFlagsEnumGenerator : AbstractFlagsEnumGenerator {
    public static CSharpFlagsEnumGenerator Instance;
    private static CSharpFlagsEnumGenerator();
    protected virtual SyntaxNode CreateExplicitlyCastedLiteralValue(SyntaxGenerator generator, INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected virtual bool IsValidName(INamedTypeSymbol enumType, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGeneratorInternal : SyntaxGeneratorInternal {
    public static SyntaxGeneratorInternal Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    private static CSharpSyntaxGeneratorInternal();
    public virtual ISyntaxFacts get_SyntaxFacts();
    public virtual SyntaxTrivia EndOfLine(string text);
    [NullableContextAttribute("2")]
public virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken name, SyntaxNode initializer, bool isConst);
    public virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    public virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    [NullableContextAttribute("2")]
internal static VariableDeclarationSyntax VariableDeclaration(SyntaxNode type, SyntaxToken name, SyntaxNode expression);
    public virtual SyntaxToken Identifier(string identifier);
    public virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public virtual SyntaxNode RefExpression(SyntaxNode expression);
    public virtual SyntaxNode AddParentheses(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    internal static SyntaxNode Parenthesize(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public virtual bool RequiresLocalDeclarationType();
    public virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    public virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    public virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    public virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    public virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    public virtual SyntaxNode InterpolationFormatClause(string format);
    public virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    internal static SyntaxTokenList GetParameterModifiers(RefKind refKind, bool forFunctionPointerReturnParameter);
    public virtual SyntaxNode Type(ITypeSymbol typeSymbol, bool typeContext);
    public virtual SyntaxNode NegateEquality(SyntaxGenerator generator, SyntaxNode binaryExpression, SyntaxNode left, BinaryOperatorKind negatedKind, SyntaxNode right);
    public virtual SyntaxNode IsNotTypeExpression(SyntaxNode expression, SyntaxNode type);
    public virtual bool SupportsPatterns(ParseOptions options);
    public virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isKeyword, SyntaxNode pattern);
    public virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    public virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    public virtual SyntaxNode LessThanRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode LessThanEqualsRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode GreaterThanRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode GreaterThanEqualsRelationalPattern(SyntaxNode expression);
    public virtual SyntaxNode NotPattern(SyntaxNode pattern);
    public virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    public virtual SyntaxNode TypePattern(SyntaxNode type);
    public virtual SyntaxNode UnaryPattern(SyntaxToken operatorToken, SyntaxNode pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.DestructorGenerator : object {
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddDestructorTo(TypeDeclarationSyntax destination, IMethodSymbol destructor, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static DestructorDeclarationSyntax GenerateDestructorDeclaration(IMethodSymbol destructor, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EnumMemberGenerator : object {
    internal static EnumDeclarationSyntax AddEnumMemberTo(EnumDeclarationSyntax destination, IFieldSymbol enumMember, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static EnumMemberDeclarationSyntax GenerateEnumMemberDeclaration(IFieldSymbol enumMember, EnumDeclarationSyntax destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static ExpressionSyntax CreateEnumMemberValue(SyntaxGenerator generator, EnumDeclarationSyntax destination, IFieldSymbol enumMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EventGenerator : object {
    private static MemberDeclarationSyntax AfterMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    private static MemberDeclarationSyntax BeforeMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    internal static CompilationUnitSyntax AddEventTo(CompilationUnitSyntax destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddEventTo(TypeDeclarationSyntax destination, IEventSymbol event, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GenerateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GenerateEventFieldDeclaration(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static MemberDeclarationSyntax GenerateEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorListSyntax GenerateAccessorList(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IEventSymbol event, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IMethodSymbol accessor, SyntaxKind kind, bool hasBody);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IEventSymbol event, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateModifiers(IEventSymbol event, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ExpressionGenerator : object {
    public static ExpressionSyntax GenerateExpression(SyntaxGenerator generator, TypedConstant typedConstant);
    private static ExpressionSyntax GenerateNullLiteral();
    internal static ExpressionSyntax GenerateExpression(SyntaxGenerator generator, ITypeSymbol type, object value, bool canUseFieldReference);
    internal static ExpressionSyntax GenerateNonEnumValueExpression(SyntaxGenerator generator, ITypeSymbol type, object value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateBooleanLiteralExpression(bool val);
    private static ExpressionSyntax GenerateStringLiteralExpression(string val);
    private static ExpressionSyntax GenerateCharLiteralExpression(char val);
    private static string DetermineSuffix(ITypeSymbol type, object value);
    private static ExpressionSyntax GenerateDoubleLiteralExpression(ITypeSymbol type, double value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateSingleLiteralExpression(ITypeSymbol type, float value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateNonNegativeLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory);
    private static ExpressionSyntax GenerateLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory, Func`2<T, bool> isNegative, Func`2<T, T> negate, string integerMinValueString);
    private static ExpressionSyntax GenerateFieldReference(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants);
    private static ExpressionSyntax GenerateMemberAccess(String[] names);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.FieldGenerator : object {
    private static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members, FieldDeclarationSyntax fieldDeclaration);
    internal static CompilationUnitSyntax AddFieldTo(CompilationUnitSyntax destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddFieldTo(TypeDeclarationSyntax destination, IFieldSymbol field, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static FieldDeclarationSyntax GenerateFieldDeclaration(IFieldSymbol field, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static EqualsValueClauseSyntax GenerateEqualsValue(SyntaxGenerator generator, IFieldSymbol field);
    private static SyntaxTokenList GenerateModifiers(IFieldSymbol field, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.MethodGenerator : object {
    private static TypeParameterConstraintSyntax s_classConstraint;
    private static TypeParameterConstraintSyntax s_structConstraint;
    private static TypeParameterConstraintSyntax s_defaultConstraint;
    private static MethodGenerator();
    internal static BaseNamespaceDeclarationSyntax AddMethodTo(BaseNamespaceDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static CompilationUnitSyntax AddMethodTo(CompilationUnitSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddMethodTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MethodDeclarationSyntax GenerateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static LocalFunctionStatementSyntax GenerateLocalFunctionDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax GenerateMethodDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax GenerateLocalFunctionDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, MethodDeclarationSyntax methodDeclaration, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, LocalFunctionStatementSyntax localFunctionDeclaration, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IMethodSymbol method, CSharpCodeGenerationContextInfo info, bool isExplicit);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IMethodSymbol method);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateDefaultConstraints(IMethodSymbol method);
    private static TypeParameterListSyntax GenerateTypeParameterList(IMethodSymbol method, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamedTypeGenerator : object {
    public static TypeDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, TypeDeclarationSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static BaseNamespaceDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, BaseNamespaceDeclarationSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamedTypeTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GenerateNamedTypeDeclaration(ICodeGenerationService service, INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static RecordDeclarationSyntax GenerateRecordMembers(ICodeGenerationService service, CSharpCodeGenerationContextInfo info, RecordDeclarationSyntax recordDeclaration, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax UpdateNamedTypeDeclaration(ICodeGenerationService service, MemberDeclarationSyntax declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static MemberDeclarationSyntax RemoveAllMembers(MemberDeclarationSyntax declaration);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembersWorker(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static DelegateDeclarationSyntax GenerateDelegateDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static EnumDeclarationSyntax GenerateEnumDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributeDeclarations(INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static TypeParameterListSyntax GenerateTypeParameterList(INamedTypeSymbol namedType, CSharpCodeGenerationContextInfo info);
    private static BaseListSyntax GenerateBaseList(INamedTypeSymbol namedType);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(INamedTypeSymbol namedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamespaceGenerator : object {
    public static BaseNamespaceDeclarationSyntax AddNamespaceTo(ICodeGenerationService service, BaseNamespaceDeclarationSyntax destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamespaceTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamespaceSymbol namespace, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static SyntaxNode GenerateNamespaceDeclaration(ICodeGenerationService service, INamespaceSymbol namespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public static SyntaxNode UpdateCompilationUnitOrNamespaceDeclaration(ICodeGenerationService service, SyntaxNode declaration, IList`1<ISymbol> newMembers, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxNode GenerateNamespaceDeclarationWorker(string name, INamespaceSymbol innermostNamespace, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxNode GetDeclarationSyntaxWithoutMembers(INamespaceSymbol namespace, INamespaceSymbol innermostNamespace, string name, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
    private static SyntaxNode RemoveAllMembers(SyntaxNode declaration);
    private static SyntaxList`1<UsingDirectiveSyntax> GenerateUsingDirectives(INamespaceSymbol innermostNamespace);
    private static UsingDirectiveSyntax GenerateUsingDirective(ISymbol symbol);
    private static NameSyntax GenerateName(INamespaceOrTypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.OperatorGenerator : object {
    internal static TypeDeclarationSyntax AddOperatorTo(TypeDeclarationSyntax destination, IMethodSymbol method, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static OperatorDeclarationSyntax GenerateOperatorDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static OperatorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, OperatorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static OperatorDeclarationSyntax GenerateOperatorDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, bool hasNoBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ParameterGenerator : object {
    public static ParameterListSyntax GenerateParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    public static BracketedParameterListSyntax GenerateBracketedParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    internal static ImmutableArray`1<ParameterSyntax> GetParameters(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CSharpCodeGenerationContextInfo info);
    internal static ParameterSyntax GetParameter(IParameterSymbol parameter, CSharpCodeGenerationContextInfo info, bool isExplicit, bool isFirstParam, bool seenOptional);
    private static SyntaxTokenList GenerateModifiers(IParameterSymbol parameter, bool isFirstParam);
    private static EqualsValueClauseSyntax GenerateEqualsValueClause(SyntaxGenerator generator, IParameterSymbol parameter, bool isExplicit, bool seenOptional);
    private static ExpressionSyntax GenerateEqualsValueClauseWorker(SyntaxGenerator generator, IParameterSymbol parameter, object value);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IParameterSymbol parameter, bool isExplicit, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.PropertyGenerator : object {
    public static bool CanBeGenerated(IPropertySymbol property);
    [NullableContextAttribute("2")]
private static MemberDeclarationSyntax LastPropertyOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static CompilationUnitSyntax AddPropertyTo(CompilationUnitSyntax destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static TypeDeclarationSyntax AddPropertyTo(TypeDeclarationSyntax destination, IPropertySymbol property, CSharpCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GeneratePropertyOrIndexer(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GenerateIndexerDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GeneratePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TypeSyntax GenerateTypeSyntax(IPropertySymbol property);
    private static bool TryGetExpressionBody(BasePropertyDeclarationSyntax baseProperty, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static PropertyDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, PropertyDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static IndexerDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, IndexerDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax UseExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, AccessorDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static bool TryGetArrowExpressionBody(SyntaxKind declarationKind, AccessorDeclarationSyntax accessor, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static AccessorListSyntax GenerateAccessorList(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, bool hasBody, CSharpCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IPropertySymbol property, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateAccessorModifiers(IPropertySymbol property, IMethodSymbol accessor, CSharpCodeGenerationContextInfo info);
    private static SyntaxTokenList GenerateModifiers(IPropertySymbol property, CodeGenerationDestination destination, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.StatementGenerator : object {
    internal static SyntaxList`1<StatementSyntax> GenerateStatements(IEnumerable`1<SyntaxNode> statements);
    internal static BlockSyntax GenerateBlock(IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.TypeParameterGenerator : object {
    public static TypeParameterListSyntax GenerateTypeParameterList(ImmutableArray`1<ITypeParameterSymbol> typeParameters, CSharpCodeGenerationContextInfo info);
    private static TypeParameterSyntax GenerateTypeParameter(ITypeParameterSymbol symbol, CSharpCodeGenerationContextInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider : CodeFixProvider {
    private static string CS8361;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<GetChangedDocumentAsync>d__6")]
private static Task`1<Document> GetChangedDocumentAsync(Document document, int conditionalExpressionSyntaxStartPosition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<InsertCloseParenthesisAsync>d__7")]
private static Task`1<Document> InsertCloseParenthesisAsync(Document document, ParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConflictMarkerResolution.CSharpResolveConflictMarkerCodeFixProvider : AbstractResolveConflictMarkerCodeFixProvider {
    [NullableAttribute("1")]
private static string CS8300;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform : object {
    public static Task`1<Document> ConvertAsync(Document document, BaseNamespaceDeclarationSyntax baseNamespace, CSharpSyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform/<ConvertNamespaceDeclarationAsync>d__1")]
public static Task`1<Document> ConvertNamespaceDeclarationAsync(Document document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static ValueTuple`2<SourceText, TextSpan> ConvertNamespaceDeclaration(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, TextSpan> ReplaceWithFileScopedNamespace(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxAnnotation annotation);
    private static string GetIndentation(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static ValueTuple`2<SourceText, TextSpan> DedentNamespace(ParsedDocument document, string indentation, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    private static SourceText IndentNamespace(ParsedDocument document, string indentation, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    private static Nullable`1<TextChange> TryIndentLine(SyntaxTree tree, SyntaxNode root, string indentation, TextLine textLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform/<ConvertFileScopedNamespaceAsync>d__8")]
public static Task`1<Document> ConvertFileScopedNamespaceAsync(Document document, FileScopedNamespaceDeclarationSyntax fileScopedNamespace, CSharpSyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceWithBlockScopedNamespace(ParsedDocument document, FileScopedNamespaceDeclarationSyntax namespaceDeclaration, string lineEnding, NewLinePlacement newLinePlacement, SyntaxAnnotation annotation);
    private static bool HasLeadingBlankLine(SyntaxToken token, SyntaxToken& withoutBlankLine);
    private static FileScopedNamespaceDeclarationSyntax ConvertNamespaceDeclaration(NamespaceDeclarationSyntax namespaceDeclaration);
    private static NamespaceDeclarationSyntax ConvertFileScopedNamespace(ParsedDocument document, FileScopedNamespaceDeclarationSyntax fileScopedNamespace, string lineEnding, NewLinePlacement newLinePlacement);
    [CompilerGeneratedAttribute]
internal static Nullable`1<TextChange> <DedentNamespace>g__TryDedentLine|5_0(TextLine textLine, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static int <DedentNamespace>g__ComputeCommonIndentationLength|5_1(TextLine textLine, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine : object {
    private static SyntaxRemoveOptions RemovalOptions;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<GetCodeActionAsync>d__1")]
public static Task`1<CodeAction> GetCodeActionAsync(Document document, TypeDeclarationSyntax typeDeclaration, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<ConvertToPositionalRecordAsync>d__2")]
private static Task`1<Solution> ConvertToPositionalRecordAsync(Document document, INamedTypeSymbol type, ImmutableArray`1<PositionalParameterInfo> positionalParameterInfos, TypeDeclarationSyntax typeDeclaration, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static RecordDeclarationSyntax CreateRecordDeclaration(INamedTypeSymbol type, TypeDeclarationSyntax typeDeclaration, SyntaxTriviaList modifiedClassTrivia, IEnumerable`1<ParameterSyntax> propertiesToAddAsParams, SyntaxToken recordKeyword, SyntaxTriviaList constructorTrivia, BaseListSyntax baseList);
    private static SyntaxList`1<AttributeListSyntax> GetModifiedAttributeListsForProperty(PositionalParameterInfo result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<RefactorInitializersAsync>d__5")]
private static Task RefactorInitializersAsync(INamedTypeSymbol type, SolutionEditor solutionEditor, ImmutableArray`1<IPropertySymbol> positionalParameters, CancellationToken cancellationToken);
    private static SyntaxTriviaList GetModifiedClassTrivia(ImmutableArray`1<PositionalParameterInfo> propertyResults, TypeDeclarationSyntax typeDeclaration, LineFormattingOptions lineFormattingOptions);
    private static Nullable`1<SyntaxTriviaList> GetExteriorTrivia(SyntaxNode declaration);
    private static Nullable`1<SyntaxTriviaList> SearchInNodes(SyntaxList`1<XmlNodeSyntax> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<CreateParamComments>d__9")]
private static IEnumerable`1<XmlNodeSyntax> CreateParamComments(ImmutableArray`1<PositionalParameterInfo> propertyResults, SyntaxTriviaList exteriorTrivia, LineFormattingOptions lineFormattingOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers : object {
    public static bool IsSimpleEqualsMethod(Compilation compilation, IMethodSymbol methodSymbol, IMethodBodyOperation methodBodyOperation, ImmutableArray`1<IFieldSymbol> expectedComparedFields);
    public static INamedTypeSymbol GetIEquatableType(Compilation compilation, INamedTypeSymbol containingType);
    public static bool IsSimpleHashCodeMethod(Compilation compilation, IMethodSymbol methodSymbol, IMethodBodyOperation methodOperation, ImmutableArray`1<IFieldSymbol> expectedHashedFields);
    public static bool IsDefaultEqualsOperator(IMethodBodyOperation operation);
    internal static bool IsDefaultNotEqualsOperator(IMethodBodyOperation operation);
    public static bool IsSimplePrimaryConstructor(IConstructorBodyOperation operation, ImmutableArray`1<IPropertySymbol> properties, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1& orderedProperties);
    public static bool IsSimpleCopyConstructor(IConstructorBodyOperation operation, ImmutableArray`1<IFieldSymbol> fields, IParameterSymbol parameter);
    public static ImmutableArray`1<ExpressionSyntax> GetAssignmentValuesForNonPrimaryConstructor(IConstructorBodyOperation operation, ImmutableArray`1<IPropertySymbol> positionalParams);
    public static ImmutableArray`1<ExpressionSyntax> GetAssignmentValuesFromObjectCreation(IObjectCreationOperation operation, ImmutableArray`1<IPropertySymbol> positionalParams);
    private static ImmutableArray`1<ExpressionSyntax> GetAssignmentExpressionsFromValuesMap(ImmutableArray`1<IPropertySymbol> positionalParams, ImmutableDictionary`2<ISymbol, ExpressionSyntax> assignmentValues);
    private static ImmutableDictionary`2<ISymbol, T> GetAssignmentValuesForConstructor(IConstructorBodyOperation constructorOperation, Func`2<IOperation, T> captureAssignedSymbol);
    private static bool IsSafeAssignment(IOperation operation);
    private static ImmutableArray`1<IFieldSymbol> GetEqualizedFields(IMethodBodyOperation operation, IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
private static bool TryGetAssignmentFromParameterWithExplicitCast(IOperation operation, IParameterSymbol parameter, ISymbol& assignedVariable);
    private static IParameterSymbol GetParamFromArgument(IOperation operation);
    private static ISymbol GetReferencedSymbolObject(IOperation reference);
    private static bool IsDotEqualsInvocation(IOperation operation);
    private static bool IsNullCheck(IOperation operation, bool successRequirement, ISymbol otherObject);
    private static bool ReturnsFalseImmediately(IEnumerable`1<IOperation> operation);
    private static bool TryAddEqualizedFieldsForCondition(IOperation condition, bool successRequirement, ISymbol currentObject, ISymbol otherObject, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryAddEqualizedFieldsForConditionWithoutTypedVariable(IOperation condition, bool successRequirement, ISymbol currentObject, ArrayBuilder`1<IFieldSymbol> builder, ISymbol& boundVariable, IEnumerable`1<IOperation> additionalConditions);
    private static bool TryAddEqualizedFieldsForStatements(IEnumerable`1<IOperation> statementsToCheck, ISymbol otherC, INamedTypeSymbol type, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryAddFieldFromComparison(IMemberReferenceOperation memberReference1, IMemberReferenceOperation memberReference2, ISymbol currentObject, ISymbol otherObject, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryGetBindingCastInFirstIfStatement(ImmutableArray`1<IOperation> bodyOps, IParameterSymbol parameter, INamedTypeSymbol type, ArrayBuilder`1<IFieldSymbol> builder, ISymbol& otherC, IEnumerable`1& statementsToCheck);
    private static bool TryGetSuccessCondition(IOperation whenTrue, IOperation whenFalse, IEnumerable`1<IOperation> otherOps, Boolean& successRequirement, IEnumerable`1& remainingStatements);
    private static bool OverridesEquals(Compilation compilation, IMethodSymbol equals, INamedTypeSymbol equatableType);
    private static IBlockOperation GetBlockOfMethodBody(IMethodBodyBaseOperation body);
    private static IFieldSymbol UnwrapPropertyToField(ISymbol propertyOrField);
    private static bool AreConditionsSatisfiedEitherOrder(T firstItem, T secondItem, Func`2<T, bool> firstCondition, Func`2<T, bool> secondCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordCodeFixProvider : CodeFixProvider {
    private static string CS8865;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyDeclarationSyntax <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAsOverride>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("2")]
public PropertyDeclarationSyntax Declaration { get; public set; }
    public IPropertySymbol Symbol { get; public set; }
    public bool KeepAsOverride { get; public set; }
    [MemberNotNullWhenAttribute("False", "Declaration")]
public bool IsInherited { get; }
    public PositionalParameterInfo(PropertyDeclarationSyntax Declaration, IPropertySymbol Symbol, bool KeepAsOverride);
    [CompilerGeneratedAttribute]
protected PositionalParameterInfo(PositionalParameterInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PropertyDeclarationSyntax get_Declaration();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Declaration(PropertyDeclarationSyntax value);
    [CompilerGeneratedAttribute]
public IPropertySymbol get_Symbol();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Symbol(IPropertySymbol value);
    [CompilerGeneratedAttribute]
public bool get_KeepAsOverride();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeepAsOverride(bool value);
    [MemberNotNullWhenAttribute("False", "Declaration")]
public bool get_IsInherited();
    public static ImmutableArray`1<PositionalParameterInfo> GetPropertiesForPositionalParameters(ImmutableArray`1<PropertyDeclarationSyntax> properties, INamedTypeSymbol type, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ImmutableArray`1<IPropertySymbol> GetInheritedPositionalParams(INamedTypeSymbol currentType, CancellationToken cancellationToken);
    private static ConvertStatus ShouldConvertProperty(PropertyDeclarationSyntax property, IPropertySymbol propertySymbol, INamedTypeSymbol containingType);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PositionalParameterInfo left, PositionalParameterInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PositionalParameterInfo left, PositionalParameterInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PositionalParameterInfo other);
    [CompilerGeneratedAttribute]
public virtual PositionalParameterInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PropertyDeclarationSyntax& Declaration, IPropertySymbol& Symbol, Boolean& KeepAsOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfCodeFixProvider : AbstractConvertTypeOfToNameOfCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetCodeFixTitle();
    protected virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, MemberAccessExpressionSyntax node, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IBlockFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpBlockFactsService : CSharpBlockFacts {
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_unnecessary_usings { get; }
    internal static string Add_this { get; }
    internal static string Remove_unreachable_code { get; }
    internal static string Pass_in_captured_variables_as_arguments { get; }
    internal static string Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code { get; }
    internal static string Convert_typeof_to_nameof { get; }
    internal static string Place_statement_on_following_line { get; }
    internal static string Remove_blank_lines_between_braces { get; }
    internal static string Fix_record_declaration { get; }
    internal static string Fix_constraint { get; }
    internal static string Change_return_type_from_0_to_1 { get; }
    internal static string Hide_base_member { get; }
    internal static string Add_Obsolete { get; }
    internal static string Explicitly_inherit_documentation { get; }
    internal static string Unseal_class_0 { get; }
    internal static string Use_interpolated_verbatim_string { get; }
    internal static string Add_await { get; }
    internal static string Assign_to_0 { get; }
    internal static string Compare_to_0 { get; }
    internal static string Fix_return_type { get; }
    internal static string Replace_return_with_yield_return { get; }
    internal static string Declare_as_nullable { get; }
    internal static string Place_token_on_following_line { get; }
    internal static string Assign_out_parameters { get; }
    internal static string Assign_out_parameters_at_start { get; }
    internal static string Add_parentheses_around_conditional_expression_in_interpolated_string { get; }
    internal static string Make_0_return_Task_instead_of_void { get; }
    internal static string Allow_unsafe_code_in_this_project { get; }
    internal static string Make_ref_struct { get; }
    internal static string Remove_unused_function { get; }
    internal static string Upgrade_all_csharp_projects_to_language_version_0 { get; }
    internal static string Upgrade_this_project_to_csharp_language_version_0 { get; }
    internal static string Use_0 { get; }
    internal static string Remove_in_keyword { get; }
    internal static string Remove_new_modifier { get; }
    internal static string Convert_to_positional_record { get; }
    internal static string Make_method_async { get; }
    internal static string Make_method_async_remain_void { get; }
    internal static string Make_field_required { get; }
    internal static string Make_property_required { get; }
    internal static string Use_primary_constructor_and_remove_members { get; }
    internal static string Use_primary_constructor_and_remove_fields { get; }
    internal static string Use_primary_constructor_and_remove_properties { get; }
    internal static string Use_collection_expression { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_unnecessary_usings();
    internal static string get_Add_this();
    internal static string get_Remove_unreachable_code();
    internal static string get_Pass_in_captured_variables_as_arguments();
    internal static string get_Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code();
    internal static string get_Convert_typeof_to_nameof();
    internal static string get_Place_statement_on_following_line();
    internal static string get_Remove_blank_lines_between_braces();
    internal static string get_Fix_record_declaration();
    internal static string get_Fix_constraint();
    internal static string get_Change_return_type_from_0_to_1();
    internal static string get_Hide_base_member();
    internal static string get_Add_Obsolete();
    internal static string get_Explicitly_inherit_documentation();
    internal static string get_Unseal_class_0();
    internal static string get_Use_interpolated_verbatim_string();
    internal static string get_Add_await();
    internal static string get_Assign_to_0();
    internal static string get_Compare_to_0();
    internal static string get_Fix_return_type();
    internal static string get_Replace_return_with_yield_return();
    internal static string get_Declare_as_nullable();
    internal static string get_Place_token_on_following_line();
    internal static string get_Assign_out_parameters();
    internal static string get_Assign_out_parameters_at_start();
    internal static string get_Add_parentheses_around_conditional_expression_in_interpolated_string();
    internal static string get_Make_0_return_Task_instead_of_void();
    internal static string get_Allow_unsafe_code_in_this_project();
    internal static string get_Make_ref_struct();
    internal static string get_Remove_unused_function();
    internal static string get_Upgrade_all_csharp_projects_to_language_version_0();
    internal static string get_Upgrade_this_project_to_csharp_language_version_0();
    internal static string get_Use_0();
    internal static string get_Remove_in_keyword();
    internal static string get_Remove_new_modifier();
    internal static string get_Convert_to_positional_record();
    internal static string get_Make_method_async();
    internal static string get_Make_method_async_remain_void();
    internal static string get_Make_field_required();
    internal static string get_Make_property_required();
    internal static string get_Use_primary_constructor_and_remove_members();
    internal static string get_Use_primary_constructor_and_remove_fields();
    internal static string get_Use_primary_constructor_and_remove_properties();
    internal static string get_Use_collection_expression();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICommandLineParserService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParserService : object {
    public sealed virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpFileBannerFactsService : CSharpFileBannerFacts {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IHeaderFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpHeaderFactsServices : CSharpHeaderFacts {
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsService : AbstractSemanticFactsService {
    internal static CSharpSemanticFactsService Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    public IBlockFacts BlockFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static CSharpSemanticFactsService();
    public virtual ISyntaxFacts get_SyntaxFacts();
    public virtual IBlockFacts get_BlockFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual SyntaxToken ToIdentifierToken(string identifier);
    protected virtual IEnumerable`1<ISymbol> GetCollidableSymbols(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, CancellationToken cancellationToken);
    public sealed virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
    [NullableContextAttribute("1")]
public sealed virtual IMethodSymbol TryGetDisposeMethod(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService.GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.ISymbolDeclarationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSymbolDeclarationService : object {
    public sealed virtual ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.ITypeInferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpTypeInferenceService : AbstractTypeInferenceService {
    public static CSharpTypeInferenceService Instance;
    private static CSharpTypeInferenceService();
    protected virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyResource { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_EmptyResource();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS1717;
    private static string CS1718;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
private static bool CanFix(SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken, SimpleNameSyntax& leftName, ISymbol& matchingMember, String& title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpAddDocCommentNodesCodeFixProvider : AbstractAddDocCommentNodesCodeFixProvider`4<XmlElementSyntax, XmlNameAttributeSyntax, XmlTextSyntax, MemberDeclarationSyntax> {
    private static string CS1573;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string NodeName { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_NodeName();
    protected virtual List`1<XmlNameAttributeSyntax> GetNameAttributes(XmlElementSyntax node);
    protected virtual string GetValueFromNameAttribute(XmlNameAttributeSyntax attribute);
    [NullableContextAttribute("2")]
protected virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList leadingTrivia);
    protected virtual string GetXmlElementLocalName(XmlElementSyntax element);
    protected virtual ImmutableArray`1<string> GetParameterNames(MemberDeclarationSyntax member);
    protected virtual XmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <TryGetDocCommentNode>b__10_1(XmlElementSyntax element);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpRemoveDocCommentNodeCodeFixProvider : AbstractRemoveDocCommentNodeCodeFixProvider`2<XmlElementSyntax, XmlTextSyntax> {
    private static string CS1571;
    private static string CS1572;
    private static string CS1710;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocCommentSignifierToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_DocCommentSignifierToken();
    protected virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
    protected virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    protected virtual bool IsXmlNewLineToken(SyntaxToken token);
    private static bool IsWhitespace(string text);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharLanguageServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetOpenToken(BaseArgumentListSyntax node);
    [ExtensionAttribute]
public static SyntaxToken GetCloseToken(BaseArgumentListSyntax node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseNamespaceDeclarationSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TNamespaceDeclarationSyntax AddUsingDirectives(TNamespaceDeclarationSyntax namespaceDeclaration, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseParameterListSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetOpenToken(BaseParameterListSyntax node);
    [ExtensionAttribute]
public static SyntaxToken GetCloseToken(BaseParameterListSyntax node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken TryGetSemicolonToken(BasePropertyDeclarationSyntax node);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithSemicolonToken(BasePropertyDeclarationSyntax node, SyntaxToken semicolonToken);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithExpressionBody(BasePropertyDeclarationSyntax node, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CastExpressionSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ExpressionSyntax Uncast(CastExpressionSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationUnitSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool CanAddUsingDirectives(SyntaxNode contextNode, bool allowInHiddenRegions, CancellationToken cancellationToken);
    private static TextSpan GetUsingsSpan(CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax namespaceDeclaration);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirective(CompilationUnitSyntax root, UsingDirectiveSyntax usingDirective, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    private static List`1<UsingDirectiveSyntax> AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContext : SyntaxContext {
    [NullableAttribute("2")]
public TypeDeclarationSyntax ContainingTypeDeclaration;
    [NullableAttribute("2")]
public BaseTypeDeclarationSyntax ContainingTypeOrEnumDeclaration;
    public bool IsCatchFilterContext;
    public bool IsConstantExpressionContext;
    public bool IsCrefContext;
    public bool IsDefiniteCastTypeContext;
    public bool IsDelegateReturnTypeContext;
    public bool IsDestructorTypeContext;
    public bool IsFixedVariableDeclarationContext;
    public bool IsFunctionPointerTypeArgumentContext;
    public bool IsGenericTypeArgumentContext;
    public bool IsImplicitOrExplicitOperatorTypeContext;
    public bool IsInNonUserCode;
    public bool IsInstanceContext;
    public bool IsIsOrAsOrSwitchOrWithExpressionContext;
    public bool IsIsOrAsTypeContext;
    public bool IsLabelContext;
    public bool IsLeftSideOfImportAliasDirective;
    public bool IsLocalFunctionDeclarationContext;
    public bool IsLocalVariableDeclarationContext;
    public bool IsNonAttributeExpressionContext;
    public bool IsObjectCreationTypeContext;
    public bool IsParameterTypeContext;
    public bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext;
    public bool IsPreProcessorKeywordContext;
    public bool IsPrimaryFunctionExpressionContext;
    public bool IsTypeArgumentOfConstraintContext;
    public bool IsTypeOfExpressionContext;
    public bool IsUsingAliasTypeContext;
    public ISet`1<SyntaxKind> PrecedingModifiers;
    private CSharpSyntaxContext(Document document, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, TypeDeclarationSyntax containingTypeDeclaration, BaseTypeDeclarationSyntax containingTypeOrEnumDeclaration, bool isAnyExpressionContext, bool isAtEndOfPattern, bool isAtStartOfPattern, bool isAttributeNameContext, bool isAwaitKeywordContext, bool isCatchFilterContext, bool isConstantExpressionContext, bool isCrefContext, bool isDefiniteCastTypeContext, bool isDelegateReturnTypeContext, bool isDestructorTypeContext, bool isEnumBaseListContext, bool isEnumTypeMemberAccessContext, bool isFixedVariableDeclarationContext, bool isFunctionPointerTypeArgumentContext, bool isGenericConstraintContext, bool isGenericTypeArgumentContext, bool isGlobalStatementContext, bool isImplicitOrExplicitOperatorTypeContext, bool isInImportsDirective, bool isInNonUserCode, bool isInQuery, bool isInstanceContext, bool isTaskLikeTypeContext, bool isIsOrAsOrSwitchOrWithExpressionContext, bool isIsOrAsTypeContext, bool isLabelContext, bool isLeftSideOfImportAliasDirective, bool isLocalFunctionDeclarationContext, bool isLocalVariableDeclarationContext, bool isNameOfContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isNonAttributeExpressionContext, bool isObjectCreationTypeContext, bool isOnArgumentListBracketOrComma, bool isParameterTypeContext, bool isPossibleLambdaOrAnonymousMethodParameterTypeContext, bool isPossibleTupleContext, bool isPreProcessorDirectiveContext, bool isPreProcessorExpressionContext, bool isPreProcessorKeywordContext, bool isPrimaryFunctionExpressionContext, bool isRightAfterUsingOrImportDirective, bool isRightOfNameSeparator, bool isRightSideOfNumericType, bool isStatementContext, bool isTypeArgumentOfConstraintContext, bool isTypeContext, bool isTypeOfExpressionContext, bool isUsingAliasTypeContext, bool isWithinAsyncMethod, ISet`1<SyntaxKind> precedingModifiers, CancellationToken cancellationToken);
    public static CSharpSyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static CSharpSyntaxContext CreateContextWorker(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static bool ComputeIsWithinAsyncMethod();
    public bool IsTypeAttributeContext(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool IsTypeDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    public bool IsRecordDeclarationContext(ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    public bool IsMemberAttributeContext(ISet`1<SyntaxKind> validTypeDeclarations, CancellationToken cancellationToken);
    public bool IsStatementAttributeContext();
    [NullableContextAttribute("2")]
public bool IsMemberDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    public bool IsRegularTopLevelStatementsContext();
    private static bool IsLeftSideOfUsingAliasDirective(SyntaxToken leftToken);
    internal bool IsAwaitStatementContext(int position, CancellationToken cancellationToken);
    private static bool ComputeIsAwaitKeywordContext(int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isGlobalStatementContext, bool isAnyExpressionContext, bool isStatementContext);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContextService : object {
    [NullableContextAttribute("1")]
public sealed virtual SyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateOrConstructorOrLocalFunctionOrMethodOrOperatorParameterList(SyntaxNode node, bool includeOperators);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static bool IsUsingOrExternKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsUsingKeywordInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsStaticKeywordContextInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfGlobalStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsAfterPossibleCast(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLastTokenOfQueryClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPreProcessorExpressionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsOrderByDirectionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsSwitchLabelContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsXmlCrefParameterModifierContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsConstructorOrMethodParameterArgumentContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnaryOperatorContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAfterYieldKeyword(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAnyAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    private static bool IsAccessorDeclarationContextWorker(SyntaxToken& targetToken);
    [NullableContextAttribute("2")]
private static bool IsGenericInterfaceOrDelegateTypeParameterList(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeParameterVarianceContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsMandatoryNamedParameterPosition(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNumericTypeContext(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeNamedDynamic(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions : object {
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
public static bool IsAttributeNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalMemberDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxKind otherModifier, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLocalFunctionDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLocalFunctionDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNamespaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsNamespaceDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPartialTypeDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, TypeDeclarationSyntax& declarationSyntax);
    [ExtensionAttribute]
public static bool IsDefinitelyNotTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsBaseClassOrInterfaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingAliasTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingStaticContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeArgumentOfConstraintClause(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintStartContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsDefaultExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsSizeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsFunctionPointerTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGenericConstraintContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsGenericTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool includeOperators, Int32& parameterIndex, SyntaxKind& previousModifier);
    [ExtensionAttribute]
public static bool IsParamsModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDelegateReturnTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsImplicitOrExplicitOperatorTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleExtensionMethodContext(SyntaxTree syntaxTree, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAnonymousMethodParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleTupleContext(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtStartOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtEndOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    private static SyntaxToken FindTokenOnLeftOfNode(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsPossibleTupleOpenParenOrComma(SyntaxToken possibleCommaOrParen);
    [ExtensionAttribute]
public static bool IsPossibleDeconstructionDesignation(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static SyntaxNode UnwrapPossibleTuple(SyntaxNode node);
    private static bool IsPossibleVarDeconstructionOpenParenOrComma(SyntaxToken leftToken);
    [ExtensionAttribute]
public static bool HasNames(TupleExpressionSyntax tuple);
    [ExtensionAttribute]
public static bool IsValidContextForFromClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsValidContextForJoinClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLocalVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFixedVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchVariableDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsObjectCreationTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsNonConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsStatementContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalStatementContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDefiniteCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLabelContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool attributes, CancellationToken cancellationToken, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsInvocationOfVarExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsNameOfContext(SyntaxTree syntaxTree, int position, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsOrSwitchOrWithExpressionContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsRightSideName(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsCatchOrFinallyContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchFilterContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsEnumBaseListContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsEnumTypeMemberAccessContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFunctionPointerCallingConventionContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [CompilerGeneratedAttribute]
internal static bool <IsGlobalMemberDeclarationContext>g__IsGlobalAttributeList|2_0(AttributeListSyntax attributeList);
    [CompilerGeneratedAttribute]
internal static bool <IsAtEndOfPattern>g__IsAtEndOfSwitchStatementPattern|38_0(SyntaxToken leftToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax Parenthesize(ExpressionSyntax expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [ExtensionAttribute]
private static ExpressionSyntax ParenthesizeWorker(ExpressionSyntax expression, bool includeElasticTrivia);
    [ExtensionAttribute]
public static PatternSyntax Parenthesize(PatternSyntax pattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [ExtensionAttribute]
public static CastExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol targetType);
    [ExtensionAttribute]
public static ExpressionSyntax CastIfPossible(ExpressionSyntax expression, ITypeSymbol targetType, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ShouldNameExpressionBeTreatedAsExpressionInsteadOfType(ExpressionSyntax name, SemanticModel semanticModel, SymbolInfo& leftHandBinding, ITypeSymbol& container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IEnumerable`1<ITypeParameterSymbol> typeParameters);
    private static void AddConstraintClauses(List`1<TypeParameterConstraintClauseSyntax> clauses, ITypeParameterSymbol typeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GenerateExpressionSyntax(ITypeSymbol typeSymbol, bool nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GenerateNameSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    private static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool nameSyntax, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefReadOnlyTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static bool ContainingTypesOrSelfHasUnsafeKeyword(ITypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions/<FindApplicableAliasAsync>d__7")]
[ExtensionAttribute]
public static Task`1<ISymbol> FindApplicableAliasAsync(ITypeSymbol type, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IEnumerable`1<UsingDirectiveSyntax> GetApplicableUsings(int position, SyntaxNode root);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.NameSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<NameSyntax> GetNameParts(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GetLastDottedName(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static bool CanBeReplacedWithAnyName(NameSyntax nameSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.QueryExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryExpressionSyntax query);
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryBodySyntax body);
    [ExtensionAttribute]
public static QueryExpressionSyntax WithAllClauses(QueryExpressionSyntax query, IList`1<SyntaxNode> allClauses);
    [ExtensionAttribute]
public static QueryBodySyntax WithAllClauses(QueryBodySyntax body, IEnumerable`1<SyntaxNode> allClauses);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SeparatedSyntaxListExtensions : object {
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<T> AddRangeWithTrailingSeparator(SeparatedSyntaxList`1<T> separatedList, IEnumerable`1<T> nodes, SyntaxKind separator);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<T> InsertRangeWithTrailingSeparator(SeparatedSyntaxList`1<T> separatedList, int index, IEnumerable`1<T> nodes, SyntaxKind separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string EscapeIdentifier(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static SyntaxToken ToIdentifierToken(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static IdentifierNameSyntax ToIdentifierName(string identifier);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxToken> SkipKinds(SyntaxTokenList tokenList, SyntaxKind[] kinds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static bool IsPrimaryFunctionExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    private static bool IsFullyWrittenGeneric(SyntaxToken token, SyntaxToken lessThanToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    private static SyntaxToken GetEndToken(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeSyntax> GetAllBaseListTypes(TypeDeclarationSyntax typeNode, SemanticModel model, CancellationToken cancellationToken);
    private static SyntaxToken EnsureToken(SyntaxToken token, SyntaxKind kind, bool prependNewLineIfMissing, bool appendNewLineIfMissing);
    private static BaseTypeDeclarationSyntax EnsureHasBraces(BaseTypeDeclarationSyntax typeDeclaration, bool hasMembers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax EnsureOpenAndCloseBraceTokens(TypeDeclarationSyntax typeDeclaration);
    [ExtensionAttribute]
public static EnumDeclarationSyntax EnsureOpenAndCloseBraceTokens(EnumDeclarationSyntax typeDeclaration);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeSyntaxExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPotentialTypeName(TypeSyntax typeSyntax, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeSyntax GenerateReturnTypeSyntax(IMethodSymbol method);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.UsingDirectiveSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void SortUsingDirectives(List`1<UsingDirectiveSyntax> usingDirectives, SyntaxList`1<UsingDirectiveSyntax> existingDirectives, bool placeSystemNamespaceFirst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderCodeFixProvider : AbstractFileHeaderCodeFixProvider {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
internal static class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorDiagnosticIds : object {
    public static string CS0122;
    public static string CS1729;
    public static string CS1739;
    public static string CS1503;
    public static string CS1660;
    public static string CS7036;
    public static ImmutableArray`1<string> AllDiagnosticIds;
    public static ImmutableArray`1<string> TooManyArgumentsDiagnosticIds;
    public static ImmutableArray`1<string> CannotConvertDiagnosticIds;
    private static GenerateConstructorDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GeneratedCodeRecognition.CSharpGeneratedCodeRecognitionService : AbstractGeneratedCodeRecognitionService {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Indentation.IIndentationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpIndentationService : AbstractIndentationService`1<CompilationUnitSyntax> {
    public static CSharpIndentationService Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IHeaderFacts HeaderFacts { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    private static CSharpIndentationService();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IHeaderFacts get_HeaderFacts();
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
    protected virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    public static bool ShouldUseSmartTokenFormatterInsteadOfIndenter(IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, TextLine line, IndentationOptions options, SyntaxToken& token);
    private static bool IsInvalidToken(SyntaxToken token);
    protected virtual bool ShouldUseTokenIndenter(Indenter<CompilationUnitSyntax> indenter, SyntaxToken& syntaxToken);
    protected virtual ISmartTokenFormatter CreateSmartTokenFormatter(CompilationUnitSyntax root, SourceText text, TextLine lineToBeIndented, IndentationOptions options, AbstractFormattingRule baseIndentationRule);
    protected virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt);
    private static IndentationResult GetIndentationBasedOnToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("0")]
private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SeparatedSyntaxList`1<T> list, SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationForQueryExpression(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetQueryExpressionClause(SyntaxToken token);
    private static bool IsPartOfQueryExpression(SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromTokenLine(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, Nullable`1<int> additionalSpace);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`3<VariableDeclaratorSyntax, IdentifierNameSyntax, SyntaxNode> FindDiagnosticNodes(Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceIdentifierWithInlineDeclaration(Document document, CSharpCodeFixOptionsProvider options, SemanticModel semanticModel, SyntaxNode currentRoot, VariableDeclaratorSyntax declarator, IdentifierNameSyntax identifier, SyntaxNode currentNode, HashSet`1<StatementSyntax> declarationsToRemove, CancellationToken cancellationToken);
    public static TypeSyntax GenerateTypeSyntaxOrVar(ITypeSymbol symbol, CSharpCodeFixOptionsProvider options);
    private static bool IsVarDesired(ITypeSymbol type, CSharpCodeFixOptionsProvider options);
    private static DeclarationExpressionSyntax GetDeclarationExpression(SourceText sourceText, IdentifierNameSyntax identifier, TypeSyntax newType, VariableDeclaratorSyntax declaratorOpt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<MassageTrivia>d__10")]
private static IEnumerable`1<SyntaxTrivia> MassageTrivia(IEnumerable`1<SyntaxTrivia> triviaList);
    private static bool SemanticsChanged(SemanticModel semanticModel, SyntaxNode nodeToReplace, IdentifierNameSyntax identifier, DeclarationExpressionSyntax declarationExpression, CancellationToken cancellationToken);
    private static SyntaxNode GetTopmostContainer(SyntaxNode expression);
    private static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, SyntaxNode topmostContainer, SemanticModel& speculativeModel);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.InternalExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol DetermineParameterType(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ITypeSymbol DetermineParameterType(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleSingleIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleVariableAndIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static T AppendTriviaWithoutEndOfLines(T newStatement, IfStatementSyntax ifStatement);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISyntaxKindsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxKindsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeAnonymousFunctionStatic.CSharpMakeAnonymousFunctionStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeFieldReadonly.CSharpMakeFieldReadonlyCodeFixProvider : AbstractMakeFieldReadonlyCodeFixProvider`2<VariableDeclaratorSyntax, FieldDeclarationSyntax> {
    protected virtual SyntaxNode GetInitializerNode(VariableDeclaratorSyntax declaration);
    protected virtual ImmutableList`1<VariableDeclaratorSyntax> GetVariableDeclarators(FieldDeclarationSyntax fieldDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__0")]
public static Task`1<Document> MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__1")]
public static Task MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, SyntaxEditor syntaxEditor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public static SyntaxNode AddStaticModifier(SyntaxNode localFunction, SyntaxGenerator generator);
    private static ImmutableArray`1<ValueTuple`2<IParameterSymbol, ISymbol>> CreateParameterSymbols(ImmutableArray`1<ISymbol> captures);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8421;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider/<WrapFixAsync>d__7")]
private static Task WrapFixAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Func`4<Document, LocalFunctionStatementSyntax, ImmutableArray`1<ISymbol>, Task> fixer, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMemberStatic.CSharpMakeMemberStaticCodeFixProvider : AbstractMakeMemberStaticCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual bool TryGetMemberDeclaration(SyntaxNode node, SyntaxNode& memberDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodAsynchronous.CSharpMakeMethodAsynchronousCodeFixProvider : AbstractMakeMethodAsynchronousCodeFixProvider {
    private static string CS4032;
    private static string CS4033;
    private static string CS4034;
    private static string CS0246;
    private static SyntaxToken s_asyncKeywordWithSpace;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpMakeMethodAsynchronousCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsSupportedDiagnostic(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual string GetMakeAsyncTaskFunctionResource();
    protected virtual string GetMakeAsyncVoidFunctionResource();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTaskTypes knownTypes);
    protected virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax FixMethod(bool keepVoid, IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax FixLocalFunction(bool keepVoid, IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static TypeSyntax FixMethodReturnType(bool keepVoid, IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static bool IsIterator(IMethodSymbol method, CancellationToken cancellationToken);
    private static bool IsIAsyncEnumerableOrEnumerator(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsIEnumerable(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsIEnumerator(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static ValueTuple`2<SyntaxTokenList, TypeSyntax> AddAsyncModifierWithCorrectedTrivia(SyntaxTokenList modifiers, TypeSyntax returnType);
    private static AnonymousFunctionExpressionSyntax FixAnonymousFunction(AnonymousFunctionExpressionSyntax anonymous);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <FixMethodReturnType>g__MakeGenericType|17_0(string type, ITypeSymbol typeArgumentFrom);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodSynchronous.CSharpMakeMethodSynchronousCodeFixProvider : AbstractMakeMethodSynchronousCodeFixProvider {
    private static string CS1998;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes);
    private static SyntaxNode FixMethod(IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTaskTypes knownTypes);
    private static SyntaxNode FixLocalFunction(IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTaskTypes knownTypes);
    private static TypeSyntax FixMethodReturnType(IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTaskTypes knownTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider : CodeFixProvider {
    private static string CS8345;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<FixCodeAsync>d__6")]
private static Task`1<Document> FixCodeAsync(Document document, StructDeclarationSyntax structDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructMemberReadOnly.CSharpMakeStructMemberReadOnlyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructReadOnly.CSharpMakeStructReadOnlyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeTypeAbstract.CSharpMakeTypeAbstractCodeFixProvider : AbstractMakeTypeAbstractCodeFixProvider`1<TypeDeclarationSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsValidRefactoringContext(SyntaxNode node, TypeDeclarationSyntax& typeDeclaration);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeTypePartial.CSharpMakeTypePartialCodeFixProvider : AbstractMakeTypePartialCodeFixProvider {
    [NullableAttribute("1")]
private static string CS0260;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider : CodeFixProvider {
    private static SyntaxAnnotation s_usingPlacementCodeFixAnnotation;
    private static SyntaxAnnotation s_warningAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static MisplacedUsingDirectivesCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<TransformDocumentIfRequiredAsync>d__7")]
internal static Task`1<Document> TransformDocumentIfRequiredAsync(Document document, SimplifierOptions simplifierOptions, CodeStyleOption2`1<AddImportPlacement> importPlacementStyleOption, CancellationToken cancellationToken);
    private static ImmutableArray`1<UsingDirectiveSyntax> GetAllUsingDirectives(CompilationUnitSyntax compilationUnit);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<GetTransformedDocumentAsync>d__9")]
private static Task`1<Document> GetTransformedDocumentAsync(Document document, CompilationUnitSyntax compilationUnit, ImmutableArray`1<UsingDirectiveSyntax> allUsingDirectives, AddImportPlacement placement, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectivesAsync>d__10")]
private static Task`1<CompilationUnitSyntax> ExpandUsingDirectivesAsync(Document document, CompilationUnitSyntax compilationUnit, ImmutableArray`1<UsingDirectiveSyntax> allUsingDirectives, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectiveAsync>d__11")]
private static Task`1<SyntaxNode> ExpandUsingDirectiveAsync(Document document, UsingDirectiveSyntax usingDirective, CancellationToken cancellationToken);
    private static CompilationUnitSyntax MoveUsingsInsideNamespace(CompilationUnitSyntax compilationUnit);
    private static CompilationUnitSyntax MoveUsingsOutsideNamespaces(CompilationUnitSyntax compilationUnit);
    private static ValueTuple`2<BaseNamespaceDeclarationSyntax, ImmutableArray`1<UsingDirectiveSyntax>> RemoveUsingsFromNamespace(BaseNamespaceDeclarationSyntax usingContainer);
    private static ValueTuple`2<IEnumerable`1<UsingDirectiveSyntax>, IEnumerable`1<SyntaxTrivia>> RemoveDuplicateUsings(IEnumerable`1<UsingDirectiveSyntax> existingUsings, ImmutableArray`1<UsingDirectiveSyntax> usingsToAdd);
    private static SyntaxList`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    private static TSyntaxNode RemoveLeadingBlankLinesFromFirstMember(TSyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<SplitIntoLines>d__18")]
private static IEnumerable`1<IEnumerable`1<SyntaxTrivia>> SplitIntoLines(SyntaxTriviaList triviaList);
    private static TSyntaxNode EnsureLeadingBlankLineBeforeFirstMember(TSyntaxNode node);
    private static ValueTuple`2<AddImportPlacement, bool> DeterminePlacement(CompilationUnitSyntax compilationUnit, CodeStyleOption2`1<AddImportPlacement> styleOption);
    private static bool HasOneNamespace(CompilationUnitSyntax compilationUnit);
    private static ValueTuple`2<CompilationUnitSyntax, ImmutableArray`1<SyntaxTrivia>> RemoveFileHeader(CompilationUnitSyntax syntaxRoot, IFileBannerFactsService bannerService);
    private static CompilationUnitSyntax AddFileHeader(CompilationUnitSyntax compilationUnit, ImmutableArray`1<SyntaxTrivia> fileHeader);
    [CompilerGeneratedAttribute]
internal static void <GetAllUsingDirectives>g__Recurse|8_0(SyntaxList`1<MemberDeclarationSyntax> members, <>c__DisplayClass8_0& );
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService : AbstractMoveDeclarationNearReferenceService`4<CSharpMoveDeclarationNearReferenceService, StatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected virtual SyntaxNode GetVariableDeclaratorSymbolNode(VariableDeclaratorSyntax variableDeclarator);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    protected virtual SyntaxToken GetIdentifierOfVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService/<TypesAreCompatibleAsync>d__5")]
protected virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, LocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    protected virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void AddEdits(SourceText text, SyntaxToken token, ExpressionSyntax nextExpression, ArrayBuilder`1<TextChange> edits);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void AddEdits(SourceText text, SyntaxToken token, ExpressionSyntax nextExpression, ArrayBuilder`1<TextChange> edits);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void FixOne(SyntaxNode root, SourceText text, Dictionary`2<SyntaxToken, SyntaxToken> tokenToToken, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void MoveTriviaWhenOnSameLine(Dictionary`2<SyntaxToken, SyntaxToken> replacementMap, SyntaxToken colonToken, SyntaxToken thisBaseKeyword);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [CompilerGeneratedAttribute]
internal static SyntaxToken <MoveTriviaWhenOnSameLine>g__ComputeNewCloseParen|5_0(SyntaxToken colonToken, SyntaxToken previousToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider/<FixAllAsync>d__4")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider codeActionOptionsProvider, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, SyntaxTrivia endOfLineTrivia, CancellationToken cancellationToken);
    private static SyntaxNode AddLeadingTrivia(SyntaxNode node, SyntaxTrivia trivia);
    private static SyntaxToken AddLeadingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersCodeFixProvider : AbstractOrderModifiersCodeFixProvider {
    private static string CS0267;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableCompilerErrorIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    protected virtual CodeStyleOption2`1<string> GetCodeStyleOption(AnalyzerOptionsProvider options);
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionCodeFixProvider : AbstractPopulateSwitchExpressionCodeFixProvider`4<ExpressionSyntax, SwitchExpressionSyntax, SwitchExpressionArmSyntax, MemberAccessExpressionSyntax> {
    protected virtual SwitchExpressionArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected virtual SwitchExpressionArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, MemberAccessExpressionSyntax caseLabel);
    protected virtual SwitchExpressionArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected virtual SwitchExpressionSyntax InsertSwitchArms(SyntaxGenerator generator, SwitchExpressionSyntax switchNode, int insertLocation, List`1<SwitchExpressionArmSyntax> newArms);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementCodeFixProvider : AbstractPopulateSwitchStatementCodeFixProvider`3<SwitchStatementSyntax, SwitchSectionSyntax, MemberAccessExpressionSyntax> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessCodeFixProvider : AbstractQualifyMemberAccessCodeFixprovider`2<SimpleNameSyntax, InvocationExpressionSyntax> {
    protected virtual SimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual string GetTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveAsyncModifier.CSharpRemoveAsyncModifierCodeFixProvider : AbstractRemoveAsyncModifierCodeFixProvider`2<ReturnStatementSyntax, ExpressionSyntax> {
    private static string CS1998;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, ExpressionSyntax expressionBody);
    protected virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    private static SyntaxNode AnnotateBlock(SyntaxGenerator generator, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.RemoveAsyncModifier.RemoveAsyncModifierHelpers : object {
    internal static SyntaxNode WithoutAsyncModifier(MethodDeclarationSyntax method, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(LocalFunctionStatementSyntax localFunction, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(ParenthesizedLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(SimpleLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(AnonymousMethodExpressionSyntax method);
    private static SyntaxTokenList RemoveAsyncModifier(SyntaxTokenList modifiers, TypeSyntax& newReturnType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider : CodeFixProvider {
    public static string RemoveOperator;
    public static string NegateExpression;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider/<FixAllAsync>d__6")]
private static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool negate, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider : CodeFixProvider {
    private static string CS1615;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, ArgumentSyntax argumentSyntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ExpressionSyntax Recurse(ExpressionSyntax old);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsCodeFixProvider : AbstractRemoveUnnecessaryImportsCodeFixProvider {
    protected virtual string GetTitle();
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService : AbstractRemoveUnnecessaryImportsService`1<UsingDirectiveSyntax> {
    protected IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> UnnecessaryImportsProvider { get; }
    private static ISyntaxFormatting GetSyntaxFormatting();
    protected virtual IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> get_UnnecessaryImportsProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService/<RemoveUnnecessaryImportsAsync>d__4")]
public virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private static void AddFormattingSpans(CompilationUnitSyntax compilationUnit, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void AddFormattingSpans(BaseNamespaceDeclarationSyntax namespaceMember, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static int GetEndPosition(SyntaxNode container, SyntaxList`1<MemberDeclarationSyntax> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryParenthesesCodeFixProvider : AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1<SyntaxNode> {
    protected virtual bool CanRemoveParentheses(SyntaxNode current, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    private static bool IsSubsequentSection(Diagnostic diagnostic);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveStatement|7_0(SyntaxEditor editor, SyntaxNode statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedLocalFunction.CSharpRemoveUnusedLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8321;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersCodeFixProvider : AbstractRemoveUnusedMembersCodeFixProvider`1<FieldDeclarationSyntax> {
    protected virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<FieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedValuesCodeFixProvider : AbstractRemoveUnusedValuesCodeFixProvider`11<ExpressionSyntax, StatementSyntax, BlockSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ForEachStatementSyntax, SwitchSectionSyntax, SwitchLabelSyntax, CatchClauseSyntax, CatchClauseSyntax> {
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
    protected virtual BlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<StatementSyntax> statements);
    protected virtual SyntaxToken GetForEachStatementIdentifier(ForEachStatementSyntax node);
    protected virtual LocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts, SemanticModel semanticModel);
    protected virtual SyntaxNode ComputeReplacementNode(SyntaxNode originalOldNode, SyntaxNode changedOldNode, SyntaxNode proposedReplacementNode);
    protected virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(SwitchSectionSyntax switchCaseBlock, SyntaxEditor editor, LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected virtual SyntaxNode GetReplacementNodeForVarPattern(SyntaxNode originalVarPattern, SyntaxNode newNameNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider : CodeFixProvider {
    private static string CS8313;
    private static string CS8505;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<ReplaceAsync>d__8")]
private static Task`1<Document> ReplaceAsync(Document document, TextSpan span, SyntaxNode newExpression, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, string> GetReplacementExpressionAndText(Document document, SemanticModel semanticModel, LiteralExpressionSyntax defaultLiteral, CancellationToken cancellationToken);
    private static bool IsFlagsEnum(ITypeSymbol type, Compilation compilation);
    [NullableContextAttribute("2")]
private static bool IsZero(object o);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<SyntaxNode, string> <GetReplacementExpressionAndText>g__GenerateMemberAccess|9_0(string memberName, <>c__DisplayClass9_0& );
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDiscardDeclarationsWithAssignments.CSharpReplaceDiscardDeclarationsWithAssignmentsService : object {
    private static string DiscardVariableName;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDiscardDeclarationsWithAssignments.CSharpReplaceDiscardDeclarationsWithAssignmentsService/<ReplaceAsync>d__2")]
public sealed virtual Task`1<SyntaxNode> ReplaceAsync(Document document, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    private static bool IsDiscardDeclaration(VariableDeclaratorSyntax variable);
    private static bool IsDiscardDeclaration(CatchDeclarationSyntax catchDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Lightup.NullableSyntaxAnnotationEx : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Oblivious>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <AnnotatedOrNotAnnotated>k__BackingField;
    public static SyntaxAnnotation Oblivious { get; }
    public static SyntaxAnnotation AnnotatedOrNotAnnotated { get; }
    private static NullableSyntaxAnnotationEx();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Oblivious();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_AnnotatedOrNotAnnotated();
}
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationHelpers : object {
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken syntaxToken, SyntaxNode parentOfToken);
    public static T AppendElasticTriviaIfNecessary(T rewrittenNode, T originalNode);
    public static bool TryAddLeadingElasticTriviaIfNecessary(SyntaxToken token, SyntaxToken originalToken, SyntaxToken& tokenWithLeadingWhitespace);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationCodeFixProvider : AbstractSimplifyInterpolationCodeFixProvider`5<InterpolationSyntax, ExpressionSyntax, InterpolationAlignmentClauseSyntax, InterpolationFormatClauseSyntax, InterpolatedStringExpressionSyntax> {
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected virtual InterpolationSyntax WithExpression(InterpolationSyntax interpolation, ExpressionSyntax expression);
    protected virtual InterpolationSyntax WithAlignmentClause(InterpolationSyntax interpolation, InterpolationAlignmentClauseSyntax alignmentClause);
    protected virtual InterpolationSyntax WithFormatClause(InterpolationSyntax interpolation, InterpolationFormatClauseSyntax formatClause);
    protected virtual string Escape(InterpolatedStringExpressionSyntax interpolatedString, string formatString);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionCodeFixProvider : AbstractSimplifyLinqExpressionCodeFixProvider`3<InvocationExpressionSyntax, SimpleNameSyntax, ExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.CSharpSimplifyPropertyPatternCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SubpatternSyntax TrySimplify(SubpatternSyntax currentSubpattern);
    private static BaseExpressionColonSyntax Merge(BaseExpressionColonSyntax outerExpressionColon, BaseExpressionColonSyntax innerExpressionColon);
    [NullableContextAttribute("2")]
private static MemberAccessExpressionSyntax Merge(ExpressionSyntax outerExpression, ExpressionSyntax innerExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<HandleDeclarationAsync>d__5")]
internal static Task HandleDeclarationAsync(Document document, SyntaxEditor editor, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<HandleDeclarationExpressionAsync>d__6")]
private static Task HandleDeclarationExpressionAsync(Document document, SyntaxEditor editor, DeclarationExpressionSyntax declarationExpression, CancellationToken cancellationToken);
    private static Task HandleForEachStatementAsync(Document document, SyntaxEditor editor, ForEachStatementSyntax forEach, CancellationToken cancellationToken);
    private static Task HandleVariableDeclarationAsync(Document document, SyntaxEditor editor, VariableDeclarationSyntax varDecl, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<UpdateTypeSyntaxAsync>d__9")]
private static Task UpdateTypeSyntaxAsync(Document document, SyntaxEditor editor, TypeSyntax typeSyntax, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    private static ITypeSymbol AdjustNullabilityOfTypeSymbol(ITypeSymbol typeSymbol, SemanticModel semanticModel, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    private static ExpressionSyntax GenerateTupleDeclaration(ITypeSymbol typeSymbol, ParenthesizedVariableDesignationSyntax parensDesignation);
    private static SyntaxNode GenerateTypeDeclaration(TypeSyntax typeSyntax, ITypeSymbol newTypeSymbol);
    private static ITypeSymbol GetConvertedType(SemanticModel semanticModel, SyntaxNode typeSyntax, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseImplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    internal static void ReplaceTypeWithVar(SyntaxEditor editor, TypeSyntax type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UnsealClass.CSharpUnsealClassCodeFixProvider : AbstractUnsealClassCodeFixProvider {
    private static string CS0509;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string TitleFormat { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string get_TitleFormat();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpdateProjectToAllowUnsafe.CSharpUpdateProjectToAllowUnsafeCodeFixProvider : CodeFixProvider {
    private static string CS0227;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Solution AllowUnsafeOnProject(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpgradeProject.CSharpUpgradeProjectCodeFixProvider : AbstractUpgradeProjectCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual string get_UpgradeThisProjectResource();
    public virtual string get_UpgradeAllProjectsResource();
    public virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    private static LanguageVersion RequiredVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public virtual Solution UpgradeProject(Project project, string newVersion);
    public virtual bool IsUpgrade(Project project, string newVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter/<CreateCollectionExpressionAsync>d__0`2")]
public static Task`1<CollectionExpressionSyntax> CreateCollectionExpressionAsync(Document workspaceDocument, CodeActionOptionsProvider fallbackOptions, TParentExpression expressionToReplace, ImmutableArray`1<CollectionExpressionMatch`1<TMatchNode>> matches, Func`2<TParentExpression, InitializerExpressionSyntax> getInitializer, Func`3<TParentExpression, InitializerExpressionSyntax, TParentExpression> withInitializer, CancellationToken cancellationToken);
    private static SyntaxTrivia DetermineEndOfLine(ParsedDocument document, TParentExpression expressionToReplace, SyntaxFormattingOptions formattingOptions);
    private static SyntaxToken RemoveTrailingWhitespace(SyntaxToken token);
    private static SyntaxNodeOrToken RemoveTrailingWhitespace(SyntaxNodeOrToken nodeOrToken);
    [CompilerGeneratedAttribute]
internal static CollectionElementSyntax <CreateCollectionExpressionAsync>g__CreateCollectionElement|0_5(bool useSpread, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateCollectionExpressionAsync>g__TransferParentStatementComments|0_10(StatementSyntax parentStatement, ExpressionSyntax expression, string preferredIndentation);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter/<<CreateCollectionExpressionAsync>g__GetElementComponents|0_14>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxNode> <CreateCollectionExpressionAsync>g__GetElementComponents|0_14(TMatchNode node);
    [CompilerGeneratedAttribute]
internal static StatementSyntax <CreateCollectionExpressionAsync>g__UnwrapEmbeddedStatement|0_15(StatementSyntax statement);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateCollectionExpressionAsync>g__ConvertExpression|0_16(ExpressionSyntax expression, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertExpressions|0_17(ExpressionSyntax expression, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertAssignment|0_18(AssignmentExpressionSyntax assignment, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertInvocation|0_19(InvocationExpressionSyntax invocation, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<ExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayCodeFixProvider/<FixAsync>d__4")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, ExpressionSyntax arrayCreationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FixAsync>g__IsOnSingleLine|4_0(SourceText sourceText, SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> <FixAsync>g__GetMatches|4_1(SemanticModel semanticModel, ExpressionSyntax expression, INamedTypeSymbol expressionType, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static AnalysisResult <FixAsync>g__TrackAnalysisResult|4_0(SyntaxNode root, AnalysisResult analysisResult);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider/<<FixAsync>g__CreateTrackedDocumentAsync|4_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <FixAsync>g__CreateTrackedDocumentAsync|4_1(Document document, AnalysisResult analysisResult, SyntaxAnnotation annotation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<SyntaxNode> {
    private static CollectionExpressionSyntax s_emptyCollection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseCollectionExpressionForEmptyCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, SyntaxNode diagnosticNode, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CollectionExpressionMatch`1<ExpressionSyntax>> <FixAsync>g__CreateMatches|4_0(SeparatedSyntaxList`1<ArgumentSyntax> arguments, ImmutableArray`1<CollectionExpressionMatch`1<ArgumentSyntax>> matches);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider/<<FixAsync>g__GetArgumentsAsync|4_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<SeparatedSyntaxList`1<ArgumentSyntax>> <FixAsync>g__GetArgumentsAsync|4_1(Document document, CodeActionOptionsProvider fallbackOptions, ImmutableArray`1<CollectionExpressionMatch`1<ArgumentSyntax>> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAsync>g__AddOriginallyFirstArgument|4_4(ArgumentSyntax firstArgument, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<ExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocCodeFixProvider/<FixAsync>d__4")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, ExpressionSyntax stackAllocExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> <FixAsync>g__GetMatches|4_0(<>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider : AbstractUseCollectionInitializerCodeFixProvider`10<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    private static Task`1<CollectionExpressionSyntax> CreateCollectionExpressionAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    private static BaseObjectCreationExpressionSyntax CreateObjectInitializerExpression(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches);
    protected virtual CSharpUseCollectionInitializerAnalyzer GetAnalyzer();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider/<GetReplacementNodesAsync>d__4")]
protected virtual Task`1<ValueTuple`2<SyntaxNode, SyntaxNode>> GetReplacementNodesAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider/<GetNewObjectCreationAsync>d__5")]
private static Task`1<ExpressionSyntax> GetNewObjectCreationAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxList`1<ExpressionSyntax> <CreateObjectInitializerExpression>g__CreateCollectionInitializerExpressions|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxList`1<TNode> <CreateObjectInitializerExpression>g__AddLineBreaks|1_1(SeparatedSyntaxList`1<TNode> nodes);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateObjectInitializerExpression>g__ConvertExpression|1_2(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static AssignmentExpressionSyntax <CreateObjectInitializerExpression>g__ConvertAssignment|1_3(AssignmentExpressionSyntax assignment);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateObjectInitializerExpression>g__ConvertInvocation|1_4(InvocationExpressionSyntax invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentCodeFixProvider : AbstractUseCompoundAssignmentCodeFixProvider`3<SyntaxKind, AssignmentExpressionSyntax, ExpressionSyntax> {
    protected virtual SyntaxToken Token(SyntaxKind kind);
    protected virtual AssignmentExpressionSyntax Assignment(SyntaxKind assignmentOpKind, ExpressionSyntax left, SyntaxToken syntaxToken, ExpressionSyntax right);
    protected virtual ExpressionSyntax Increment(ExpressionSyntax left, bool postfix);
    protected virtual ExpressionSyntax Decrement(ExpressionSyntax left, bool postfix);
    private static ExpressionSyntax Postfix(SyntaxKind kind, ExpressionSyntax operand);
    private static ExpressionSyntax Prefix(SyntaxKind kind, ExpressionSyntax operand);
    protected virtual SyntaxTriviaList PrepareRightExpressionLeadingTrivia(SyntaxTriviaList initialTrivia);
    protected virtual bool PreferPostfix(ISyntaxFactsService syntaxFacts, AssignmentExpressionSyntax currentAssignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentCodeFixProvider : AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6<StatementSyntax, IfStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual VariableDeclaratorSyntax WithInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax value);
    protected virtual VariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected virtual LocalDeclarationStatementSyntax AddSimplificationToType(LocalDeclarationStatementSyntax statement);
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnCodeFixProvider : AbstractUseConditionalExpressionForReturnCodeFixProvider`4<StatementSyntax, IfStatementSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual SyntaxNode WrapIfStatementIfNecessary(IConditionalOperation operation);
    protected virtual ExpressionSyntax WrapReturnExpressionIfNecessary(ExpressionSyntax returnExpression, IOperation returnOperation);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
internal static class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
}
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule : AbstractFormattingRule {
    public static AbstractFormattingRule Instance;
    private static MultiLineConditionalExpressionFormattingRule();
    private static bool IsQuestionOrColonOfNewConditional(SyntaxToken token);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private SyntaxNode UpdateRoot(Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode node, CancellationToken cancellationToken);
    private ForEachVariableStatementSyntax CreateForEachVariableStatement(INamedTypeSymbol tupleType, ForEachStatementSyntax forEachStatement);
    private ExpressionStatementSyntax CreateDeconstructionStatement(INamedTypeSymbol tupleType, LocalDeclarationStatementSyntax declarationStatement, VariableDeclaratorSyntax variableDeclarator);
    private ExpressionSyntax CreateTupleOrDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private static DeclarationExpressionSyntax CreateDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private TupleExpressionSyntax CreateTupleExpression(TupleTypeSyntax typeNode);
    private SyntaxNodeOrToken ConvertTupleTypeElementComponent(SyntaxNodeOrToken nodeOrToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider : CodeFixProvider {
    private static string CS0822;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<FixAsync>d__7")]
private static Task`1<Document> FixAsync(Document document, TextSpan span, ITypeSymbol type, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static UseExpressionBodyCodeFixProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SemanticModel semanticModel, SyntaxEditor editor, Diagnostic diagnostic, HashSet`1<AccessorListSyntax> accessorLists, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeFixProvider/<FixAllAsync>d__6")]
private static Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static Task`1<Document> FixWithSyntaxEditorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode FixOne(SyntaxNode root, ObjectCreationExpressionSyntax objectCreation);
    private static SyntaxToken WithoutTrailingWhitespace(SyntaxToken newKeyword);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CodeFixHelpers : object {
    public static PrefixUnaryExpressionSyntax IndexExpression(ExpressionSyntax expr);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode UpdateInvocation(SemanticModel semanticModel, SyntaxNode currentRoot, InvocationExpressionSyntax currentInvocation, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax GetInvocationExpression(Diagnostic d, CancellationToken cancellationToken);
    private static ExpressionSyntax FixOne(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateRangeExpression(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateComputedRange(Result result);
    [NullableContextAttribute("2")]
private static ExpressionSyntax WalkUpCheckedExpressions(ExpressionSyntax expr);
    private static RangeExpressionSyntax CreateConstantRange(Result result, SyntaxGenerator generator);
    private static int GetInt32Value(IOperation operation);
    private static bool IsFromEnd(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation& rangeOperation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameCodeFixProvider : AbstractUseInferredMemberNameCodeFixProvider {
    protected virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string InterpolatedVerbatimText;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ExpressionSyntax Rewrite(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax RewriteWorker(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax Rewrite(BinaryExpressionSyntax binary, ExpressionSyntax expr, ExpressionSyntax nullLiteral);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider : AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1<ExpressionSyntax> {
    private static LiteralExpressionSyntax s_nullLiteralExpression;
    private static ConstantPatternSyntax s_nullLiteralPattern;
    private static CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider();
    protected virtual string GetTitle(bool negated, ParseOptions options);
    private static SyntaxNode CreateEqualsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNotNullCheck(ExpressionSyntax argument);
    protected virtual SyntaxNode CreateNullCheck(ExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected virtual SyntaxNode CreateNotNullCheck(ExpressionSyntax argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseNullCheckOverTypeCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static ConstantPatternSyntax s_nullConstantPattern;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseNullCheckOverTypeCheckCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.UseIsNullCheckHelpers : object {
    public static string GetTitle(bool negated, ParseOptions options);
    public static bool SupportsIsNotPattern(ParseOptions options);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static TypeSyntax s_objectType;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseLocalFunctionCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool MakeStatic(SemanticModel semanticModel, bool makeStaticIfPossible, LocalDeclarationStatementSyntax localDeclaration, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceAnonymousWithLocalFunction(SolutionServices services, SyntaxNode currentRoot, LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static SyntaxNode ReplaceReferences(Document document, SyntaxNode currentRoot, INamedTypeSymbol delegateType, ParameterListSyntax parameterList, ImmutableArray`1<ExpressionSyntax> references);
    private static LocalFunctionStatementSyntax CreateLocalFunctionStatement(LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static ParameterListSyntax GenerateParameterList(SyntaxGenerator generator, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod);
    private static ParameterListSyntax TryGetOrCreateParameterList(AnonymousFunctionExpressionSyntax anonymousFunction);
    private static InvocationExpressionSyntax WithNewParameterNames(InvocationExpressionSyntax invocation, IMethodSymbol method, ParameterListSyntax newParameterList);
    private static int TryDetermineParameterIndex(NameColonSyntax argumentNameColon, IMethodSymbol method);
    private static EqualsValueClauseSyntax GetDefaultValue(SyntaxGenerator generator, IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
internal static ParameterSyntax <GenerateParameterList>g__PromoteParameter|11_1(SyntaxGenerator generator, ParameterSyntax parameterNode, IParameterSymbol delegateParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationCodeFixProvider : AbstractUseNullPropagationCodeFixProvider`13<SyntaxKind, ExpressionSyntax, StatementSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax, MemberAccessExpressionSyntax, ElementBindingExpressionSyntax, IfStatementSyntax, ExpressionStatementSyntax, BracketedArgumentListSyntax> {
    [NullableContextAttribute("2")]
protected virtual bool TryGetBlock(SyntaxNode statement, StatementSyntax& block);
    protected virtual StatementSyntax ReplaceBlockStatements(StatementSyntax block, StatementSyntax newInnerStatement);
    protected virtual SyntaxNode PostProcessElseIf(IfStatementSyntax ifStatement, StatementSyntax newWhenTrueStatement);
    protected virtual ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerCodeFixProvider : AbstractUseObjectInitializerCodeFixProvider`9<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected virtual CSharpUseNamedMemberInitializerAnalyzer GetAnalyzer();
    protected virtual StatementSyntax GetNewStatement(StatementSyntax statement, BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static BaseObjectCreationExpressionSyntax GetNewObjectCreation(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static SeparatedSyntaxList`1<ExpressionSyntax> CreateExpressions(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.UseInitializerHelpers : object {
    public static BaseObjectCreationExpressionSyntax GetNewObjectCreation(BaseObjectCreationExpressionSyntax baseObjectCreation, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static void AddExistingItems(BaseObjectCreationExpressionSyntax objectCreation, ArrayBuilder`1<SyntaxNodeOrToken> nodesAndTokens, bool addTrailingComma, Func`3<Nullable`1<TMatch>, ExpressionSyntax, TElementSyntax> createElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string SafeEquivalenceKey;
    private static string UnsafeEquivalenceKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static SyntaxKind MapToSyntaxKind(BinaryOperatorKind kind);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static PatternSyntax AsPatternSyntax(AnalyzedPattern pattern);
    private static ExpressionSyntax AsExpressionSyntax(ExpressionSyntax expr, AnalyzedPattern p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndMemberAccessCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static BaseExpressionColonSyntax <FixOne>g__CreateExpressionColon|5_0(ConditionalAccessExpressionSyntax conditionalAccessExpression);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <FixOne>g__RewriteMemberBindingToExpression|5_1(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static PatternSyntax <FixOne>g__CreatePattern|5_2(BinaryExpressionSyntax binaryExpression, IsPatternExpressionSyntax isPatternExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, LanguageVersion languageVersion, Action`1<StatementSyntax> removeStatement, CancellationToken cancellationToken);
    private static ExpressionSyntax GetCondition(LanguageVersion languageVersion, ExpressionSyntax comparison, BinaryExpressionSyntax asExpression, DeclarationPatternSyntax declarationPattern);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static IfStatementSyntax GetUpdatedIfStatement(IsPatternExpressionSyntax updatedCondition, ImmutableArray`1<SyntaxTrivia> trivia, IfStatementSyntax originalIf, IfStatementSyntax currentIf);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void ProcessDiagnostic(SemanticModel semanticModel, SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider : CodeFixProvider {
    private static string s_summaryTagName;
    private static string s_remarksTagName;
    private static string s_paramTagName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static SyntaxTrivia GetDocComment(SyntaxNode node);
    private static SyntaxTrivia GetDocComment(SyntaxTriviaList trivia);
    private static DocumentationCommentTriviaSyntax GetDocCommentStructure(MemberDeclarationSyntax node);
    [NullableContextAttribute("2")]
private static DocumentationCommentTriviaSyntax GetDocCommentStructure(SyntaxTriviaList trivia);
    [NullableContextAttribute("2")]
private static DocumentationCommentTriviaSyntax GetDocCommentStructure(SyntaxTrivia trivia);
    private static bool IsXmlElement(XmlNodeSyntax node, string name, XmlElementSyntax& element);
    private static XmlElementSyntax ConvertXmlElementName(XmlElementSyntax xmlElement, string name);
    private static SyntaxTriviaList CreateFinalTypeDeclarationLeadingTrivia(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration, IMethodSymbol constructor, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<ISymbol, ValueTuple`2<MemberDeclarationSyntax, SyntaxNode>> removedMembers);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<UsePrimaryConstructorAsync>d__16")]
private static Task`1<Solution> UsePrimaryConstructorAsync(Document document, ConstructorDeclarationSyntax constructorDeclaration, ImmutableDictionary`2<string, string> properties, bool removeMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<UsePrimaryConstructorAsync>d__17")]
private static Task UsePrimaryConstructorAsync(SolutionEditor solutionEditor, Document document, ConstructorDeclarationSyntax constructorDeclaration, ImmutableDictionary`2<string, string> properties, bool removeMembers, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<<CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToParam|10_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<XmlNodeSyntax> <CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToParam|10_0(IEnumerable`1<XmlNodeSyntax> content, string parameterName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<<CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToRemarks|10_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<XmlNodeSyntax> <CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToRemarks|10_1(IEnumerable`1<XmlNodeSyntax> nodes);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__MergeTypeDeclarationAndConstructorDocComments|10_2(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__InsertOrReplaceDocComments|10_3(SyntaxTriviaList leadingTrivia, SyntaxTrivia newDocComment);
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia <CreateFinalTypeDeclarationLeadingTrivia>g__MergeDocComments|10_4(SyntaxTrivia typeDeclarationDocComment, SyntaxTrivia constructorDocComment);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__MergeTypeDeclarationAndRemovedMembersDocComments|10_5(IMethodSymbol constructor, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<ISymbol, ValueTuple`2<MemberDeclarationSyntax, SyntaxNode>> removedMembers, SyntaxTriviaList typeDeclarationLeadingTrivia);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <UsePrimaryConstructorAsync>g__CreateDottedName|17_25(SimpleNameSyntax originalName, SimpleNameSyntax currentName, INamedTypeSymbol containingType);
    [CompilerGeneratedAttribute]
internal static TListSyntax <UsePrimaryConstructorAsync>g__RemoveElementIndentation|17_7(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration, TListSyntax list, Func`2<TListSyntax, IEnumerable`1<SyntaxNode>> getElements);
    [CompilerGeneratedAttribute]
internal static string <UsePrimaryConstructorAsync>g__GetLeadingWhitespace|17_8(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <UsePrimaryConstructorAsync>g__UpdateDeclaration|17_12(SyntaxNode declaration, AssignmentExpressionSyntax assignmentExpression, ExpressionStatementSyntax expressionStatement);
    [CompilerGeneratedAttribute]
internal static SyntaxRemoveOptions <UsePrimaryConstructorAsync>g__GetRemoveOptions|17_14(MemberDeclarationSyntax memberDeclaration);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static BlockSyntax RewriteBlock(BlockSyntax originalBlock, BlockSyntax currentBlock, ISet`1<UsingStatementSyntax> topmostUsingStatements);
    private static ImmutableArray`1<StatementSyntax> Expand(UsingStatementSyntax usingStatement);
    private static SyntaxTriviaList Expand(ArrayBuilder`1<StatementSyntax> result, UsingStatementSyntax usingStatement);
    private static LocalDeclarationStatementSyntax Convert(UsingStatementSyntax usingStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseThrowExpression.UseThrowExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseTupleSwap.CSharpUseTupleSwapCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static char QuoteCharacter;
    private static string Suffix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    private static IArrayCreationOperation GetArrayCreationOperation(SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static string GetUtf8StringValueFromArrayInitializer(IArrayInitializerOperation initializer);
    private static SyntaxNode CreateArgumentListWithUtf8String(BaseArgumentListSyntax argumentList, Location location, string stringValue, bool isConvertedToReadOnlySpan);
    private static ExpressionSyntax CreateUtf8String(SyntaxNode nodeToTakeTriviaFrom, string stringValue, bool isConvertedToReadOnlySpan);
    private static ExpressionSyntax CreateUtf8String(SyntaxTriviaList leadingTrivia, string stringValue, SyntaxTriviaList trailingTrivia, bool isConvertedToReadOnlySpan);
    [CompilerGeneratedAttribute]
internal static IArrayCreationOperation <GetArrayCreationOperation>g__FindArrayCreationOperationAncestor|8_1(IOperation operation);
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxIterator : object {
    private NameSyntax _name;
    public NameSyntaxIterator(NameSyntax name);
    public sealed virtual IEnumerator`1<NameSyntax> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet : object {
    public static ISet`1<SyntaxKind> AllTypeModifiers;
    public static ISet`1<SyntaxKind> AllMemberModifiers;
    public static ISet`1<SyntaxKind> AllGlobalMemberModifiers;
    public static ISet`1<SyntaxKind> AccessibilityModifiers;
    public static ISet`1<SyntaxKind> AllTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> StructOnlyTypeDeclarations;
    public static ISet`1<SyntaxKind> InterfaceOnlyTypeDeclarations;
    private static SyntaxKindSet();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.NullableExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol GetConvertedTypeWithAnnotatedNullability(TypeInfo typeInfo);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeWithAnnotatedNullability(TypeInfo typeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.NullableHelpers : object {
    public static bool IsDeclaredSymbolAssignedPossiblyNullValue(SemanticModel semanticModel, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    public static Nullable`1<bool> IsSymbolAssignedPossiblyNullValue(SemanticModel semanticModel, IOperation operation, ISymbol symbol);
    private static bool IsSymbolReferencedByOperation(IOperation operation, ISymbol symbol);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
