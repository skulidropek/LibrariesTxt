[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CodeStyle.CSharpFormattingAnalyzer : AbstractFormattingAnalyzer {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference : Enum {
    public int value__;
    public static PreferBracesPreference None;
    public static PreferBracesPreference Always;
    public static PreferBracesPreference WhenMultiline;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiers : AbstractAddAccessibilityModifiers`1<MemberDeclarationSyntax> {
    public static CSharpAddAccessibilityModifiers Instance;
    private static CSharpAddAccessibilityModifiers();
    public virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, MemberDeclarationSyntax member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersDiagnosticAnalyzer : AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1<CompilationUnitSyntax> {
    protected virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, CompilationUnitSyntax compilationUnit);
    private void ProcessMembers(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, SyntaxList`1<MemberDeclarationSyntax> members);
    private void ProcessMemberDeclaration(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, MemberDeclarationSyntax member);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<ExpressionSyntax, ExpressionSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(ExpressionSyntax binaryLike);
    protected virtual bool IsBinaryLike(ExpressionSyntax node);
    protected virtual ValueTuple`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> GetPartsOfBinaryLike(ExpressionSyntax binaryLike);
    protected virtual ExpressionSyntax TryGetAppropriateParent(ExpressionSyntax binaryLike);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<PatternSyntax, BinaryPatternSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(BinaryPatternSyntax pattern);
    protected virtual bool IsBinaryLike(PatternSyntax node);
    protected virtual ValueTuple`3<PatternSyntax, SyntaxToken, PatternSyntax> GetPartsOfBinaryLike(BinaryPatternSyntax binaryPattern);
    protected virtual PatternSyntax TryGetAppropriateParent(BinaryPatternSyntax binaryLike);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Analyzers.ConvertProgram.ConvertProgramAnalysis : object {
    public static bool CanOfferUseTopLevelStatements(CodeStyleOption2`1<bool> option, bool forAnalyzer);
    public static Location GetUseTopLevelStatementsDiagnosticLocation(MethodDeclarationSyntax methodDeclaration, bool isHidden);
    public static string GetMainTypeName(Compilation compilation);
    public static bool IsProgramMainMethod(SemanticModel semanticModel, MethodDeclarationSyntax methodDeclaration, string mainTypeName, CancellationToken cancellationToken, Boolean& canConvertToTopLevelStatements);
    private static bool TypeCanBeConverted(INamedTypeSymbol containingType, TypeDeclarationSyntax typeDeclaration);
    public static bool IsApplication(Compilation compilation);
    public static bool IsApplication(CompilationOptions options);
    public static bool CanOfferUseProgramMain(CodeStyleOption2`1<bool> option, CompilationUnitSyntax root, Compilation compilation, bool forAnalyzer);
    private static bool CanOfferUseProgramMain(CodeStyleOption2`1<bool> option, bool forAnalyzer);
    public static Location GetUseProgramMainDiagnosticLocation(CompilationUnitSyntax root, bool isHidden);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.ForEachCast.CSharpForEachCastDiagnosticAnalyzer : AbstractForEachCastDiagnosticAnalyzer`2<SyntaxKind, CommonForEachStatementSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxKinds();
    protected virtual ValueTuple`2<CommonConversion, ITypeSymbol> GetForEachInfo(SemanticModel semanticModel, CommonForEachStatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.MakeFieldReadonly.CSharpMakeFieldReadonlyDiagnosticAnalyzer : AbstractMakeFieldReadonlyDiagnosticAnalyzer`2<SyntaxKind, ThisExpressionSyntax> {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual bool IsWrittenTo(SemanticModel semanticModel, ThisExpressionSyntax expression, CancellationToken cancellationToken);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.MatchFolderAndNamespace.CSharpMatchFolderAndNamespaceDiagnosticAnalyzer : AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<SyntaxKind, BaseNamespaceDeclarationSyntax> {
    [NullableContextAttribute("1")]
protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxKindsToAnalyze();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.RemoveUnnecessaryNullableDirective.CSharpRemoveRedundantNullableDirectiveDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessSyntaxTree(CSharpCompilationOptions compilationOptions, SyntaxTreeAnalysisContext context);
    internal static Nullable`1<NullableContextOptions> GetNullableContextOptions(NullableContextOptions compilationOptions, Nullable`1<NullableContextOptions> options, NullableDirectiveTriviaSyntax directive);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <ProcessSyntaxTree>g__ProcessTrivia|3_0(SyntaxTrivia trivia, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.RemoveUnnecessaryNullableDirective.NullableImpactingSpanWalker : CSharpSyntaxWalker {
    private SemanticModel _semanticModel;
    private int _positionOfFirstReducingNullableDirective;
    [NullableAttribute("2")]
private TextSpanMutableIntervalTree _ignoredSpans;
    private CancellationToken _cancellationToken;
    [NullableAttribute("2")]
private Builder<TextSpan> _spans;
    public bool HasSpans { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TextSpan> Spans { get; }
    public Builder<TextSpan> SpansBuilder { get; }
    public NullableImpactingSpanWalker(SemanticModel semanticModel, int positionOfFirstReducingNullableDirective, TextSpanMutableIntervalTree ignoredSpans, CancellationToken cancellationToken);
    public bool get_HasSpans();
    [NullableContextAttribute("0")]
public ImmutableArray`1<TextSpan> get_Spans();
    public Builder<TextSpan> get_SpansBuilder();
    private bool IsIgnored(SyntaxNode node);
    private static bool IsLanguageRestrictedToNonNullForm(TypeSyntax node);
    public sealed virtual void Dispose();
    public virtual void DefaultVisit(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <IsLanguageRestrictedToNonNullForm>g__WalkUpCurrentQualifiedName|13_0(TypeSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.SimplifyInterpolation.CSharpSimplifyInterpolationHelpers : AbstractSimplifyInterpolationHelpers {
    [CompilerGeneratedAttribute]
private static CSharpSimplifyInterpolationHelpers <Instance>k__BackingField;
    public static CSharpSimplifyInterpolationHelpers Instance { get; }
    protected bool PermitNonLiteralAlignmentComponents { get; }
    private static CSharpSimplifyInterpolationHelpers();
    [CompilerGeneratedAttribute]
public static CSharpSimplifyInterpolationHelpers get_Instance();
    protected virtual bool get_PermitNonLiteralAlignmentComponents();
    protected virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.UseCoalesceExpression.CSharpUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer`5<SyntaxKind, ExpressionSyntax, StatementSyntax, VariableDeclaratorSyntax, IfStatementSyntax> {
    protected SyntaxKind IfStatementKind { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual SyntaxKind get_IfStatementKind();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool IsSingle(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode GetDeclarationNode(VariableDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetConditionOfIfStatement(IfStatementSyntax ifStatement);
    protected virtual bool IsNullCheck(ExpressionSyntax condition, ExpressionSyntax& checkedExpression);
    protected virtual bool TryGetEmbeddedStatement(IfStatementSyntax ifStatement, StatementSyntax& whenTrueStatement);
    protected virtual bool HasElseBlock(IfStatementSyntax ifStatement);
    protected virtual StatementSyntax TryGetPreviousStatement(IfStatementSyntax ifStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationOptions : CodeGenerationOptions {
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_neverWithSilentEnforcement;
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_whenPossibleWithSilentEnforcement;
    private static CodeStyleOption2`1<NamespaceDeclarationPreference> s_blockedScopedWithSilentEnforcement;
    public static CSharpCodeGenerationOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedIndexers>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedConstructors>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferStaticLocalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<NamespaceDeclarationPreference> <NamespaceDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedMethods { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedAccessors { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedProperties { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedIndexers { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedConstructors { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedOperators { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLocalFunctions { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; public set; }
    internal CSharpCodeGenerationOptions(IOptionsReader options, CSharpCodeGenerationOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpCodeGenerationOptions(CSharpCodeGenerationOptions original);
    private static CSharpCodeGenerationOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedMethods();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedMethods(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedAccessors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedAccessors(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedProperties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedProperties(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedIndexers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedIndexers(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedConstructors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedConstructors(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedOperators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedOperators(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLocalFunctions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLocalFunctions(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLambdas(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferStaticLocalFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceDeclarations(CodeStyleOption2`1<NamespaceDeclarationPreference> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpCodeGenerationOptions left, CSharpCodeGenerationOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpCodeGenerationOptions left, CSharpCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeGenerationOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpCodeGenerationOptions other);
    [CompilerGeneratedAttribute]
public virtual CodeGenerationOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptionGroups : object {
    public static OptionGroup VarPreferences;
    public static OptionGroup ExpressionBodiedMembers;
    public static OptionGroup PatternMatching;
    public static OptionGroup NullCheckingPreferences;
    public static OptionGroup CodeBlockPreferences;
    public static OptionGroup UsingDirectivePreferences;
    private static CSharpCodeStyleOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions : object {
    private static Builder<IOption2> s_editorConfigOptionsBuilder;
    public static Option2`1<CodeStyleOption2`1<bool>> VarForBuiltInTypes;
    public static Option2`1<CodeStyleOption2`1<bool>> VarWhenTypeIsApparent;
    public static Option2`1<CodeStyleOption2`1<bool>> VarElsewhere;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferConditionalDelegateCall;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSwitchExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatching;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverAsWithNullCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverIsWithCastCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferNotPattern;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferExtendedPropertyPattern;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferThrowExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferInlinedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferDeconstructedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferIndexOperator;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferRangeOperator;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferUtf8StringLiterals;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenOnSingleLineWithSilentEnforcement;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedConstructors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedMethods;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedOperators;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedProperties;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedIndexers;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedAccessors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLambdas;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLocalFunctions;
    public static Option2`1<CodeStyleOption2`1<PreferBracesPreference>> PreferBraces;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleDefaultExpression;
    public static Option2`1<CodeStyleOption2`1<string>> PreferredModifierOrder;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferStaticLocalFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferStaticAnonymousFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferReadOnlyStruct;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferReadOnlyStructMember;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleUsingStatement;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferLocalOverAnonymousFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferTupleSwap;
    public static Option2`1<CodeStyleOption2`1<AddImportPlacement>> PreferredUsingDirectivePlacement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignment;
    public static Option2`1<CodeStyleOption2`1<bool>> ImplicitObjectCreationWhenTypeIsApparent;
    internal static Option2`1<CodeStyleOption2`1<bool>> PreferNullCheckOverTypeCheck;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowEmbeddedStatementsOnSameLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLinesBetweenConsecutiveBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterColonInConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterTokenInConditionalExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterTokenInArrowExpressionClause>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> <NamespaceDeclarations>k__BackingField;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferMethodGroupConversion;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferTopLevelStatements;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPrimaryConstructors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> EditorConfigOptions;
    public static Option2`1<CodeStyleOption2`1<bool>> AllowEmbeddedStatementsOnSameLine { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLinesBetweenConsecutiveBraces { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterColonInConstructorInitializer { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterTokenInConditionalExpression { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterTokenInArrowExpressionClause { get; }
    public static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> NamespaceDeclarations { get; }
    private static CSharpCodeStyleOptions();
    private static Option2`1<CodeStyleOption2`1<T>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<T> defaultValue, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    private static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> CreatePreferExpressionBodyOption(CodeStyleOption2`1<ExpressionBodyPreference> defaultValue, string name);
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowEmbeddedStatementsOnSameLine();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLinesBetweenConsecutiveBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterColonInConstructorInitializer();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterTokenInConditionalExpression();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<NamespaceDeclarationPreference>> get_NamespaceDeclarations();
    public static CodeStyleOption2`1<ExpressionBodyPreference> ParseExpressionBodyPreference(string optionString, CodeStyleOption2`1<ExpressionBodyPreference> default);
    private static string GetExpressionBodyPreferenceEditorConfigString(CodeStyleOption2`1<ExpressionBodyPreference> value, CodeStyleOption2`1<ExpressionBodyPreference> defaultValue);
    public static CodeStyleOption2`1<AddImportPlacement> ParseUsingDirectivesPlacement(string optionString, CodeStyleOption2`1<AddImportPlacement> default);
    public static string GetUsingDirectivesPlacementEditorConfigString(CodeStyleOption2`1<AddImportPlacement> value, CodeStyleOption2`1<AddImportPlacement> defaultValue);
    public static CodeStyleOption2`1<NamespaceDeclarationPreference> ParseNamespaceDeclaration(string optionString, CodeStyleOption2`1<NamespaceDeclarationPreference> default);
    public static string GetNamespaceDeclarationEditorConfigString(CodeStyleOption2`1<NamespaceDeclarationPreference> value, CodeStyleOption2`1<NamespaceDeclarationPreference> defaultValue);
    private static CodeStyleOption2`1<PreferBracesPreference> ParsePreferBracesPreference(string optionString, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
    private static string GetPreferBracesPreferenceEditorConfigString(CodeStyleOption2`1<PreferBracesPreference> value, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpIdeCodeStyleOptions : IdeCodeStyleOptions {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_preferredModifierOrderDefault;
    private static CodeStyleOption2`1<UnusedValuePreference> s_discardVariableWithSilentEnforcement;
    private static CodeStyleOption2`1<UnusedValuePreference> s_discardVariableWithSuggestionEnforcement;
    private static CodeStyleOption2`1<string> s_defaultModifierOrder;
    private static CodeStyleOption2`1<ExpressionBodyPreference> s_whenPossibleWithSilentEnforcement;
    public static CSharpIdeCodeStyleOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <ImplicitObjectCreationWhenTypeIsApparent>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNullCheckOverTypeCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLinesBetweenConsecutiveBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterColonInConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterTokenInArrowExpressionClause>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowBlankLineAfterTokenInConditionalExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferConditionalDelegateCall>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSwitchExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatching>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatchingOverAsWithNullCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPatternMatchingOverIsWithCastCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNotPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferExtendedPropertyPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferInlinedVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferDeconstructedVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferIndexOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferRangeOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferUtf8StringLiterals>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<string> <PreferredModifierOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimpleUsingStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferLocalOverAnonymousFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferTupleSwap>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueExpressionStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferMethodGroupConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferReadOnlyStruct>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferReadOnlyStructMember>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferStaticLocalFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferStaticAnonymousFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ExpressionBodyPreference> <PreferExpressionBodiedLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPrimaryConstructors>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> ImplicitObjectCreationWhenTypeIsApparent { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNullCheckOverTypeCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLinesBetweenConsecutiveBraces { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterColonInConstructorInitializer { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInArrowExpressionClause { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInConditionalExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferConditionalDelegateCall { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSwitchExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatching { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatchingOverAsWithNullCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPatternMatchingOverIsWithCastCheck { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNotPattern { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferExtendedPropertyPattern { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferInlinedVariableDeclaration { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferDeconstructedVariableDeclaration { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferIndexOperator { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferRangeOperator { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferUtf8StringLiterals { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<string> PreferredModifierOrder { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimpleUsingStatement { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferLocalOverAnonymousFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferTupleSwap { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferMethodGroupConversion { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferReadOnlyStruct { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferReadOnlyStructMember { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferStaticAnonymousFunction { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPrimaryConstructors { get; public set; }
    internal CSharpIdeCodeStyleOptions(IOptionsReader options, CSharpIdeCodeStyleOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpIdeCodeStyleOptions(CSharpIdeCodeStyleOptions original);
    private static CSharpIdeCodeStyleOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_ImplicitObjectCreationWhenTypeIsApparent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ImplicitObjectCreationWhenTypeIsApparent(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNullCheckOverTypeCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNullCheckOverTypeCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLinesBetweenConsecutiveBraces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLinesBetweenConsecutiveBraces(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterColonInConstructorInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterColonInConstructorInitializer(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterTokenInArrowExpressionClause(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInConditionalExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowBlankLineAfterTokenInConditionalExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferConditionalDelegateCall();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferConditionalDelegateCall(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSwitchExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSwitchExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatching();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatching(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverAsWithNullCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatchingOverAsWithNullCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverIsWithCastCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPatternMatchingOverIsWithCastCheck(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNotPattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNotPattern(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferExtendedPropertyPattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExtendedPropertyPattern(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferInlinedVariableDeclaration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferInlinedVariableDeclaration(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferDeconstructedVariableDeclaration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferDeconstructedVariableDeclaration(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferIndexOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferIndexOperator(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferRangeOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferRangeOperator(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferUtf8StringLiterals();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferUtf8StringLiterals(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferredModifierOrder(CodeStyleOption2`1<string> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimpleUsingStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimpleUsingStatement(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferLocalOverAnonymousFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferLocalOverAnonymousFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferTupleSwap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferTupleSwap(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueExpressionStatement(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueAssignment(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferMethodGroupConversion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferMethodGroupConversion(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferReadOnlyStruct();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferReadOnlyStruct(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferReadOnlyStructMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferReadOnlyStructMember(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferStaticLocalFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferStaticAnonymousFunction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferStaticAnonymousFunction(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExpressionBodiedLambdas(CodeStyleOption2`1<ExpressionBodyPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPrimaryConstructors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPrimaryConstructors(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpIdeCodeStyleOptions left, CSharpIdeCodeStyleOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpIdeCodeStyleOptions left, CSharpIdeCodeStyleOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdeCodeStyleOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpIdeCodeStyleOptions other);
    [CompilerGeneratedAttribute]
public virtual IdeCodeStyleOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper : object {
    public static bool IsBuiltInType(ITypeSymbol type);
    public static bool IsTypeApparentInAssignmentExpression(UseVarPreference stylePreferences, ExpressionSyntax initializerExpression, SemanticModel semanticModel, ITypeSymbol typeInDeclaration, CancellationToken cancellationToken);
    private static bool IsPossibleCreationOrConversionMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, SemanticModel semanticModel, ExpressionSyntax containingTypeName, CancellationToken cancellationToken);
    private static bool IsPossibleCreationMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    private static bool IsPossibleConversionMethod(IMethodSymbol methodSymbol);
    private static bool IsContainerTypeEqualToReturnType(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    [NullableContextAttribute("2")]
private static ITypeSymbol UnwrapTupleType(ITypeSymbol symbol);
    private static ExpressionSyntax GetRightmostInvocationExpression(ExpressionSyntax node);
    public static bool IsPredefinedType(TypeSyntax type);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.UseVarPreference : Enum {
    public int value__;
    public static UseVarPreference None;
    public static UseVarPreference ForBuiltInTypes;
    public static UseVarPreference WhenTypeIsApparent;
    public static UseVarPreference Elsewhere;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceAnalysis : object {
    public static ValueTuple`2<string, string> GetInfo(NamespaceDeclarationPreference preference);
    public static bool CanOfferUseBlockScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer);
    internal static bool CanOfferUseFileScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer);
    internal static bool CanOfferUseFileScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer, LanguageVersion version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertToBlockScopedNamespaceDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespace(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeNamespace(SyntaxNodeAnalysisContext context, FileScopedNamespaceDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertToFileScopedNamespaceDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespace(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeNamespace(SyntaxNodeAnalysisContext context, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionConstants : object {
    public static string NodeToGenerateKey;
    public static string ShouldRemoveNextStatementKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsDefaultSwitchLabel(SwitchLabelSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractConvertTypeOfToNameOfDiagnosticAnalyzer {
    [NullableAttribute("1")]
private static string s_title;
    private static CSharpConvertTypeOfToNameOfDiagnosticAnalyzer();
    protected virtual bool IsValidTypeofAction(OperationAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Convert_switch_statement_to_expression { get; }
    internal static string Use_switch_expression { get; }
    internal static string Use_explicit_type_instead_of_var { get; }
    internal static string Use_explicit_type { get; }
    internal static string use_var_instead_of_explicit_type { get; }
    internal static string Use_implicit_type { get; }
    internal static string Using_directive_is_unnecessary { get; }
    internal static string Add_braces { get; }
    internal static string Add_braces_to_0_statement { get; }
    internal static string Misplaced_using_directive { get; }
    internal static string Move_misplaced_using_directives { get; }
    internal static string Using_directives_must_be_placed_inside_of_a_namespace_declaration { get; }
    internal static string Using_directives_must_be_placed_outside_of_a_namespace_declaration { get; }
    internal static string Warning_colon_Moving_using_directives_may_change_code_meaning { get; }
    internal static string Use_expression_body_for_method { get; }
    internal static string Use_block_body_for_method { get; }
    internal static string Use_block_body_for_accessor { get; }
    internal static string Use_block_body_for_constructor { get; }
    internal static string Use_block_body_for_indexer { get; }
    internal static string Use_block_body_for_operator { get; }
    internal static string Use_block_body_for_conversion_operator { get; }
    internal static string Use_block_body_for_property { get; }
    internal static string Use_expression_body_for_accessor { get; }
    internal static string Use_expression_body_for_constructor { get; }
    internal static string Use_expression_body_for_indexer { get; }
    internal static string Use_expression_body_for_operator { get; }
    internal static string Use_expression_body_for_conversion_operator { get; }
    internal static string Use_expression_body_for_property { get; }
    internal static string Use_block_body_for_local_function { get; }
    internal static string Use_expression_body_for_local_function { get; }
    internal static string Unreachable_code_detected { get; }
    internal static string Use_pattern_matching { get; }
    internal static string Use_is_null_check { get; }
    internal static string Prefer_null_check_over_type_check { get; }
    internal static string Use_simple_using_statement { get; }
    internal static string using_statement_can_be_simplified { get; }
    internal static string if_statement_can_be_simplified { get; }
    internal static string Simplify_default_expression { get; }
    internal static string default_expression_can_be_simplified { get; }
    internal static string Make_readonly_fields_writable { get; }
    internal static string Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable { get; }
    internal static string Deconstruct_variable_declaration { get; }
    internal static string Variable_declaration_can_be_deconstructed { get; }
    internal static string Local_function_can_be_made_static { get; }
    internal static string Make_local_function_static { get; }
    internal static string _0_can_be_simplified { get; }
    internal static string Indexing_can_be_simplified { get; }
    internal static string Use_local_function { get; }
    internal static string Use_index_operator { get; }
    internal static string Use_range_operator { get; }
    internal static string Delegate_invocation_can_be_simplified { get; }
    internal static string Inline_variable_declaration { get; }
    internal static string Variable_declaration_can_be_inlined { get; }
    internal static string Negate_expression_changes_semantics { get; }
    internal static string Remove_operator_preserves_semantics { get; }
    internal static string Remove_unnecessary_suppression_operator { get; }
    internal static string Suppression_operator_has_no_effect_and_can_be_misinterpreted { get; }
    internal static string typeof_can_be_converted_to_nameof { get; }
    internal static string Use_new { get; }
    internal static string new_expression_can_be_simplified { get; }
    internal static string Discard_can_be_removed { get; }
    internal static string Remove_unnessary_discard { get; }
    internal static string Embedded_statements_must_be_on_their_own_line { get; }
    internal static string Consecutive_braces_must_not_have_a_blank_between_them { get; }
    internal static string Blank_line_not_allowed_after_constructor_initializer_colon { get; }
    internal static string Null_check_can_be_clarified { get; }
    internal static string Convert_to_file_scoped_namespace { get; }
    internal static string Convert_to_block_scoped_namespace { get; }
    internal static string Use_pattern_matching_may_change_code_meaning { get; }
    internal static string Property_pattern_can_be_simplified { get; }
    internal static string Simplify_property_pattern { get; }
    internal static string Use_tuple_to_swap_values { get; }
    internal static string Lambda_expression_can_be_removed { get; }
    internal static string Remove_unnecessary_lambda_expression { get; }
    internal static string Simplify_delegate_invocation { get; }
    internal static string Use_is_not_null_check { get; }
    internal static string Use_is_object_check { get; }
    internal static string Convert_to_Program_Main_style_program { get; }
    internal static string Convert_to_top_level_statements { get; }
    internal static string Use_Utf8_string_literal { get; }
    internal static string Nullable_directive_is_unnecessary { get; }
    internal static string Remove_unnecessary_nullable_directive { get; }
    internal static string Nullable_directive_is_redundant { get; }
    internal static string Remove_redundant_nullable_directive { get; }
    internal static string Use_expression_body_for_lambda_expression { get; }
    internal static string Use_block_body_for_lambda_expression { get; }
    internal static string Make_struct_readonly { get; }
    internal static string Struct_can_be_made_readonly { get; }
    internal static string Blank_line_not_allowed_after_conditional_expression_token { get; }
    internal static string Blank_line_not_allowed_after_arrow_expression_clause_token { get; }
    internal static string Use_nameof { get; }
    internal static string Make_member_readonly { get; }
    internal static string Member_can_be_made_readonly { get; }
    internal static string Use_primary_constructor { get; }
    internal static string Anonymous_function_can_be_made_static { get; }
    internal static string Make_anonymous_function_static { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Convert_switch_statement_to_expression();
    internal static string get_Use_switch_expression();
    internal static string get_Use_explicit_type_instead_of_var();
    internal static string get_Use_explicit_type();
    internal static string get_use_var_instead_of_explicit_type();
    internal static string get_Use_implicit_type();
    internal static string get_Using_directive_is_unnecessary();
    internal static string get_Add_braces();
    internal static string get_Add_braces_to_0_statement();
    internal static string get_Misplaced_using_directive();
    internal static string get_Move_misplaced_using_directives();
    internal static string get_Using_directives_must_be_placed_inside_of_a_namespace_declaration();
    internal static string get_Using_directives_must_be_placed_outside_of_a_namespace_declaration();
    internal static string get_Warning_colon_Moving_using_directives_may_change_code_meaning();
    internal static string get_Use_expression_body_for_method();
    internal static string get_Use_block_body_for_method();
    internal static string get_Use_block_body_for_accessor();
    internal static string get_Use_block_body_for_constructor();
    internal static string get_Use_block_body_for_indexer();
    internal static string get_Use_block_body_for_operator();
    internal static string get_Use_block_body_for_conversion_operator();
    internal static string get_Use_block_body_for_property();
    internal static string get_Use_expression_body_for_accessor();
    internal static string get_Use_expression_body_for_constructor();
    internal static string get_Use_expression_body_for_indexer();
    internal static string get_Use_expression_body_for_operator();
    internal static string get_Use_expression_body_for_conversion_operator();
    internal static string get_Use_expression_body_for_property();
    internal static string get_Use_block_body_for_local_function();
    internal static string get_Use_expression_body_for_local_function();
    internal static string get_Unreachable_code_detected();
    internal static string get_Use_pattern_matching();
    internal static string get_Use_is_null_check();
    internal static string get_Prefer_null_check_over_type_check();
    internal static string get_Use_simple_using_statement();
    internal static string get_using_statement_can_be_simplified();
    internal static string get_if_statement_can_be_simplified();
    internal static string get_Simplify_default_expression();
    internal static string get_default_expression_can_be_simplified();
    internal static string get_Make_readonly_fields_writable();
    internal static string get_Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable();
    internal static string get_Deconstruct_variable_declaration();
    internal static string get_Variable_declaration_can_be_deconstructed();
    internal static string get_Local_function_can_be_made_static();
    internal static string get_Make_local_function_static();
    internal static string get__0_can_be_simplified();
    internal static string get_Indexing_can_be_simplified();
    internal static string get_Use_local_function();
    internal static string get_Use_index_operator();
    internal static string get_Use_range_operator();
    internal static string get_Delegate_invocation_can_be_simplified();
    internal static string get_Inline_variable_declaration();
    internal static string get_Variable_declaration_can_be_inlined();
    internal static string get_Negate_expression_changes_semantics();
    internal static string get_Remove_operator_preserves_semantics();
    internal static string get_Remove_unnecessary_suppression_operator();
    internal static string get_Suppression_operator_has_no_effect_and_can_be_misinterpreted();
    internal static string get_typeof_can_be_converted_to_nameof();
    internal static string get_Use_new();
    internal static string get_new_expression_can_be_simplified();
    internal static string get_Discard_can_be_removed();
    internal static string get_Remove_unnessary_discard();
    internal static string get_Embedded_statements_must_be_on_their_own_line();
    internal static string get_Consecutive_braces_must_not_have_a_blank_between_them();
    internal static string get_Blank_line_not_allowed_after_constructor_initializer_colon();
    internal static string get_Null_check_can_be_clarified();
    internal static string get_Convert_to_file_scoped_namespace();
    internal static string get_Convert_to_block_scoped_namespace();
    internal static string get_Use_pattern_matching_may_change_code_meaning();
    internal static string get_Property_pattern_can_be_simplified();
    internal static string get_Simplify_property_pattern();
    internal static string get_Use_tuple_to_swap_values();
    internal static string get_Lambda_expression_can_be_removed();
    internal static string get_Remove_unnecessary_lambda_expression();
    internal static string get_Simplify_delegate_invocation();
    internal static string get_Use_is_not_null_check();
    internal static string get_Use_is_object_check();
    internal static string get_Convert_to_Program_Main_style_program();
    internal static string get_Convert_to_top_level_statements();
    internal static string get_Use_Utf8_string_literal();
    internal static string get_Nullable_directive_is_unnecessary();
    internal static string get_Remove_unnecessary_nullable_directive();
    internal static string get_Nullable_directive_is_redundant();
    internal static string get_Remove_redundant_nullable_directive();
    internal static string get_Use_expression_body_for_lambda_expression();
    internal static string get_Use_block_body_for_lambda_expression();
    internal static string get_Make_struct_readonly();
    internal static string get_Struct_can_be_made_readonly();
    internal static string get_Blank_line_not_allowed_after_conditional_expression_token();
    internal static string get_Blank_line_not_allowed_after_arrow_expression_clause_token();
    internal static string get_Use_nameof();
    internal static string get_Make_member_readonly();
    internal static string get_Member_can_be_made_readonly();
    internal static string get_Use_primary_constructor();
    internal static string get_Anonymous_function_can_be_made_static();
    internal static string get_Make_anonymous_function_static();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCodeStyleResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Indentation_preferences { get; }
    internal static string Space_preferences { get; }
    internal static string Wrapping_preferences { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Indentation_preferences();
    internal static string get_Space_preferences();
    internal static string get_Wrapping_preferences();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string var_preferences { get; }
    internal static string Expression_bodied_members { get; }
    internal static string Pattern_matching_preferences { get; }
    internal static string Null_checking_preferences { get; }
    internal static string Code_block_preferences { get; }
    internal static string using_directive_preferences { get; }
    internal static string Expected_string_or_char_literal { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_var_preferences();
    internal static string get_Expression_bodied_members();
    internal static string get_Pattern_matching_preferences();
    internal static string get_Null_checking_preferences();
    internal static string get_Code_block_preferences();
    internal static string get_using_directive_preferences();
    internal static string get_Expected_string_or_char_literal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFacts : object {
    internal static CSharpSemanticFacts Instance;
    public ISyntaxFacts SyntaxFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public bool SupportsParameterizedProperties { get; }
    private static CSharpSemanticFacts();
    public sealed virtual ISyntaxFacts get_SyntaxFacts();
    public sealed virtual bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool get_SupportsParameterizedProperties();
    public sealed virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    private static void AppendAliasNames(SyntaxList`1<UsingDirectiveSyntax> usings, Builder<string> builder);
    private static void AppendAliasNames(IEnumerable`1<BaseNamespaceDeclarationSyntax> namespaces, Builder<string> builder, CancellationToken cancellationToken);
    public sealed virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public sealed virtual SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    private static void FlattenDeconstructionMethods(DeconstructionInfo deconstruction, TemporaryArray`1& builder);
    public sealed virtual bool IsPartial(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetSymbolInfo(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    public sealed virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ISymbol> <GetBestOrAllSymbols>g__GetCallingConventionSymbols|34_0(SemanticModel model, FunctionPointerUnmanagedCallingConventionSyntax syntax);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTokens : object {
    public static SyntaxToken AbstractKeyword;
    public static SyntaxToken AssemblyKeyword;
    public static SyntaxToken AsyncKeyword;
    public static SyntaxToken AwaitKeyword;
    public static SyntaxToken BoolKeyword;
    public static SyntaxToken ByteKeyword;
    public static SyntaxToken CharKeyword;
    public static SyntaxToken CheckedKeyword;
    public static SyntaxToken CloseBraceToken;
    public static SyntaxToken CloseBracketToken;
    public static SyntaxToken CloseParenToken;
    public static SyntaxToken ColonToken;
    public static SyntaxToken CommaToken;
    public static SyntaxToken ConstKeyword;
    public static SyntaxToken DecimalKeyword;
    public static SyntaxToken DisableKeyword;
    public static SyntaxToken DotDotToken;
    public static SyntaxToken DoubleKeyword;
    public static SyntaxToken EndOfDocumentationCommentToken;
    public static SyntaxToken ExplicitKeyword;
    public static SyntaxToken ExternKeyword;
    public static SyntaxToken FileKeyword;
    public static SyntaxToken FloatKeyword;
    public static SyntaxToken ForEachKeyword;
    public static SyntaxToken FromKeyword;
    public static SyntaxToken GlobalKeyword;
    public static SyntaxToken GreaterThanEqualsToken;
    public static SyntaxToken GreaterThanToken;
    public static SyntaxToken IfKeyword;
    public static SyntaxToken ImplicitKeyword;
    public static SyntaxToken InKeyword;
    public static SyntaxToken InterfaceKeyword;
    public static SyntaxToken InternalKeyword;
    public static SyntaxToken InterpolatedStringEndToken;
    public static SyntaxToken InterpolatedStringStartToken;
    public static SyntaxToken IntKeyword;
    public static SyntaxToken IsKeyword;
    public static SyntaxToken LessThanEqualsToken;
    public static SyntaxToken LessThanToken;
    public static SyntaxToken LetKeyword;
    public static SyntaxToken LongKeyword;
    public static SyntaxToken MethodKeyword;
    public static SyntaxToken NewKeyword;
    public static SyntaxToken NotKeyword;
    public static SyntaxToken NullKeyword;
    public static SyntaxToken ObjectKeyword;
    public static SyntaxToken OpenBraceToken;
    public static SyntaxToken OpenBracketToken;
    public static SyntaxToken OpenParenToken;
    public static SyntaxToken OperatorKeyword;
    public static SyntaxToken OutKeyword;
    public static SyntaxToken OverrideKeyword;
    public static SyntaxToken ParamsKeyword;
    public static SyntaxToken PartialKeyword;
    public static SyntaxToken PlusToken;
    public static SyntaxToken PrivateKeyword;
    public static SyntaxToken PropertyKeyword;
    public static SyntaxToken ProtectedKeyword;
    public static SyntaxToken PublicKeyword;
    public static SyntaxToken QuestionQuestionEqualsToken;
    public static SyntaxToken QuestionToken;
    public static SyntaxToken ReadOnlyKeyword;
    public static SyntaxToken RecordKeyword;
    public static SyntaxToken RefKeyword;
    public static SyntaxToken RequiredKeyword;
    public static SyntaxToken RestoreKeyword;
    public static SyntaxToken ReturnKeyword;
    public static SyntaxToken SByteKeyword;
    public static SyntaxToken ScopedKeyword;
    public static SyntaxToken SealedKeyword;
    public static SyntaxToken SemicolonToken;
    public static SyntaxToken ShortKeyword;
    public static SyntaxToken SlashGreaterThanToken;
    public static SyntaxToken StaticKeyword;
    public static SyntaxToken StringKeyword;
    public static SyntaxToken StructKeyword;
    public static SyntaxToken SwitchKeyword;
    public static SyntaxToken ThisKeyword;
    public static SyntaxToken TildeToken;
    public static SyntaxToken UIntKeyword;
    public static SyntaxToken ULongKeyword;
    public static SyntaxToken UnmanagedKeyword;
    public static SyntaxToken UnsafeKeyword;
    public static SyntaxToken UShortKeyword;
    public static SyntaxToken UsingKeyword;
    public static SyntaxToken VirtualKeyword;
    public static SyntaxToken VoidKeyword;
    public static SyntaxToken VolatileKeyword;
    public static SyntaxToken WhereKeyword;
    private static CSharpSyntaxTokens();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool ContainsInterleavedDirective(SyntaxNode statement, StatementSyntax embeddedStatement, CancellationToken cancellationToken);
    private static bool IsConsideredMultiLine(SyntaxNode statement, SyntaxNode embeddedStatement);
    private static bool RequiresBracesToMatchContext(SyntaxNode statement);
    private static IfStatementSyntax GetOutermostIfStatementOfSequence(SyntaxNode ifStatementOrElseClause);
    [NullableContextAttribute("2")]
private static bool AnyPartOfIfSequenceUsesBraces(IfStatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.NamingStyles.CSharpNamingStyleDiagnosticAnalyzer : NamingStyleDiagnosticAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SupportedSyntaxKinds>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SupportedSyntaxKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SupportedSyntaxKinds();
    [NullableContextAttribute("1")]
protected virtual bool ShouldIgnore(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpTypeStyleDiagnosticAnalyzerBase : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected CSharpTypeStyleHelper Helper { get; }
    protected CSharpTypeStyleDiagnosticAnalyzerBase(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString message);
    protected abstract virtual CSharpTypeStyleHelper get_Helper();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, SyntaxNode declaration, TextSpan diagnosticSpan, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseExplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseExplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseImplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseImplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharService : AbstractVirtualCharService {
    public static IVirtualCharService Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpVirtualCharService();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsInDirective(SyntaxNode node);
    private static VirtualCharSequence TryConvertVerbatimStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence TryConvertSingleLineRawStringToVirtualChars(SyntaxToken token);
    private static VirtualCharSequence TryConvertMultiLineRawStringToVirtualChars(SyntaxToken token, ExpressionSyntax parentExpression, bool tokenIncludeDelimiters);
    private static VirtualCharSequence TryConvertStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, ArrayBuilder`1<ValueTuple`2<char, TextSpan>> charResults);
    private static void ConvertCharactersToRunes(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> charResults, Builder<VirtualChar> runeResults);
    private static bool TryAddEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    public virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    private static bool TryAddSingleCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index, char character);
    private static int HexValue(char c);
    private static bool IsHexDigit(char c);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.Extensions : object {
    [ExtensionAttribute]
public static bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    [ExtensionAttribute]
public static bool TryGetEscapeCharacter(Rune rune, Char& escapedChar);
    private static bool TryGetEscapeCharacter(int value, Char& escapedChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList GenerateParameterModifiers(ArgumentSyntax argument);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static RefKind GetRefKind(ArgumentSyntax argument);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArrowExpressionClauseSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool TryConvertToBlock(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, BlockSyntax& block);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, StatementSyntax& statement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AssignmentExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsDeconstruction(AssignmentExpressionSyntax assignment);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AttributeArgumentSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IParameterSymbol DetermineParameter(AttributeArgumentSyntax argument, SemanticModel semanticModel, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BlockSyntaxExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryConvertToExpressionBody(BlockSyntax block, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
    [ExtensionAttribute]
public static bool TryConvertToArrowExpressionBody(BlockSyntax block, SyntaxKind declarationKind, LanguageVersion languageVersion, ExpressionBodyPreference preference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static bool IsSupportedInCSharp6(SyntaxKind declarationKind);
    public static bool MatchesPreference(ExpressionSyntax expression, ExpressionBodyPreference preference);
    private static bool TryGetExpression(StatementSyntax firstStatement, LanguageVersion languageVersion, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToExpressionBody>g__IsAnyCodeDirective|0_1(SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToExpressionBody>g__HasAcceptableDirectiveShape|0_2(StatementSyntax statement, SyntaxToken closeBrace, <>c__DisplayClass0_0& );
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LanguageVersion LanguageVersion(Compilation compilation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationUnitSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsTopLevelProgram(CompilationUnitSyntax compilationUnit);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ConversionExtensions : object {
    [ExtensionAttribute]
public static bool IsIdentityOrImplicitReference(Conversion conversion);
    [ExtensionAttribute]
public static bool IsImplicitUserDefinedConversion(Conversion conversion);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DefaultExpressionSyntaxExtensions : object {
    private static LiteralExpressionSyntax s_defaultLiteralExpression;
    private static DefaultExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanReplaceWithDefaultLiteral(DefaultExpressionSyntax defaultExpression, CSharpParseOptions parseOptions, bool preferSimpleDefaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Nullable`1<bool> CanReplaceWithDefaultLiteralFast(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static TypeSyntax GetTypeSyntax(EqualsValueClauseSyntax equalsValueClause);
    private static bool CanReplaceWithDefaultLiteralSlow(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DirectiveSyntaxExtensions : object {
    private static ConditionalWeakTable`2<SyntaxNode, DirectiveInfo`1<DirectiveTriviaSyntax>> s_rootToDirectiveInfo;
    private static DirectiveSyntaxExtensions();
    [ExtensionAttribute]
private static SyntaxNode GetAbsoluteRoot(SyntaxNode node);
    private static DirectiveInfo`1<DirectiveTriviaSyntax> GetDirectiveInfo(SyntaxNode node, CancellationToken cancellationToken);
    private static DirectiveInfo`1<DirectiveTriviaSyntax> GetDirectiveInfoForRoot(SyntaxNode root, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static DirectiveTriviaSyntax GetMatchingDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    private static bool IsRegionDirective(DirectiveTriviaSyntax directive);
    private static bool IsConditionalDirective(DirectiveTriviaSyntax directive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownSuppressions(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsQualifiedCrefName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSimpleMemberAccessExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyMemberAccessExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMemberBindingExpressionName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfColonColon(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDot(ExpressionSyntax name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfDotOrArrow(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrArrowOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightOfCloseParen(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfDot(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfSimpleMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfDotOrArrow(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfQualifiedName(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfExplicitInterfaceSpecifier(NameSyntax name);
    [ExtensionAttribute]
public static bool IsExpressionOfInvocation(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, IList`1& parts);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, List`1<string> parts);
    private static bool AddSimpleName(SimpleNameSyntax simpleName, List`1<string> parts);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInConstantContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInOutContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression, SyntaxNode& refParent);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInInContext(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
private static ExpressionSyntax GetExpressionToAnalyzeForWrites(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOnlyWrittenTo(ExpressionSyntax expression);
    private static bool IsExpressionOfArgumentInDeconstruction(ExpressionSyntax expr);
    [ExtensionAttribute]
public static bool IsWrittenTo(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAttributeNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOperandOfIncrementOrDecrementExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInsideNameOfExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanReplace(ISymbol symbol);
    [ExtensionAttribute]
public static bool CanReplaceWithRValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanReplaceWithLValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNameOfArgumentExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNameOfInvocation(InvocationExpressionSyntax invocation);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ExpressionSyntax expression, Nullable`1<SyntaxToken> semicolonTokenOpt, bool createReturnStatementForExpression, StatementSyntax& statement);
    private static StatementSyntax ConvertToStatement(ExpressionSyntax expression, SyntaxToken semicolonToken, bool createReturnStatementForExpression);
    [ExtensionAttribute]
public static bool IsDirectChildOfMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool InsideCrefReference(ExpressionSyntax expression);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ForEachStatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ILocalSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool CanSafelyMoveLocalToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <CanSafelyMoveLocalToBlock>g__HasTypeParameterWithName|0_0(SyntaxNode node, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsIntrinsicType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool TryGetPrimaryConstructor(INamedTypeSymbol typeSymbol, IMethodSymbol& primaryConstructor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberAccessExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static SimpleNameSyntax GetNameWithTriviaMoved(MemberAccessExpressionSyntax memberAccess);
    private static SyntaxTriviaList GetLeadingTriviaForSimplifiedMemberAccess(MemberAccessExpressionSyntax memberAccess);
    private static IEnumerable`1<SyntaxTrivia> WithoutElasticTrivia(IEnumerable`1<SyntaxTrivia> list);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberDeclarationSyntaxExtensions : object {
    private static ConditionalWeakTable`2<MemberDeclarationSyntax, Dictionary`2<string, ImmutableArray`1<SyntaxToken>>> s_declarationCache;
    private static MemberDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static LocalDeclarationMap GetLocalDeclarationMap(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static int GetArity(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static TypeParameterListSyntax GetTypeParameterList(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithParameterList(MemberDeclarationSyntax member, BaseParameterListSyntax parameterList);
    [ExtensionAttribute]
public static TypeSyntax GetMemberType(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static bool HasMethodShape(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static BlockSyntax GetBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax GetExpressionBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithBody(MemberDeclarationSyntax memberDeclaration, BlockSyntax body);
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributes(MemberDeclarationSyntax member);
}
internal enum Microsoft.CodeAnalysis.CSharp.Extensions.OperatorPrecedence : Enum {
    public int value__;
    public static OperatorPrecedence None;
    public static OperatorPrecedence AssignmentAndLambdaExpression;
    public static OperatorPrecedence Conditional;
    public static OperatorPrecedence NullCoalescing;
    public static OperatorPrecedence ConditionalOr;
    public static OperatorPrecedence ConditionalAnd;
    public static OperatorPrecedence LogicalOr;
    public static OperatorPrecedence LogicalXor;
    public static OperatorPrecedence LogicalAnd;
    public static OperatorPrecedence Equality;
    public static OperatorPrecedence RelationalAndTypeTesting;
    public static OperatorPrecedence Shift;
    public static OperatorPrecedence Additive;
    public static OperatorPrecedence Multiplicative;
    public static OperatorPrecedence Switch;
    public static OperatorPrecedence Range;
    public static OperatorPrecedence Unary;
    public static OperatorPrecedence Primary;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ParenthesizedExpressionSyntaxExtensions : object {
    private static ObjectPool`1<Stack`1<SyntaxNode>> s_nodeStackPool;
    private static ParenthesizedExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool RemovalWouldChangeConstantReferenceToTypeReference(ParenthesizedExpressionSyntax node, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool RemovalMayIntroduceInterpolationAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedExpressionSyntax node, ExpressionSyntax parentExpression, SemanticModel semanticModel);
    private static bool IsAssociative(SyntaxKind kind);
    private static bool RemovalMayIntroduceCastAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool StartsWithAlias(NameSyntax name);
    private static bool RemovalMayIntroduceCommaListAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool IsPreviousExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsNextExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsSimpleOrDottedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedPatternSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedPatternSyntax node, PatternSyntax parentPattern);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ParseOptionsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LanguageVersion LanguageVersion(ParseOptions options);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> LookupTypeRegardlessOfArity(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    private static void DecomposeName(ExpressionSyntax expression, ExpressionSyntax& qualifier, String& name, Int32& arity);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token);
    private static bool CanBindToken(SyntaxToken token);
    [ExtensionAttribute]
public static ISet`1<INamespaceSymbol> GetUsingNamespacesInScope(SemanticModel semanticModel, SyntaxNode location);
    [ExtensionAttribute]
public static Accessibility DetermineAccessibilityConstraint(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AllContainingTypesArePublicOrProtected(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    private static TypeSyntax GetOutermostType(TypeSyntax type);
    [ExtensionAttribute]
public static string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, bool capitalize, CancellationToken cancellationToken);
    private static string TryGenerateNameForArgumentExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, BaseTypeDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, ConstructorDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, LocalFunctionStatementSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, ParameterSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, PropertyDeclarationSyntax syntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, VariableDeclaratorSyntax syntax, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SimpleNameSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax name);
    [ExtensionAttribute]
public static bool LooksLikeStandaloneTypeName(SimpleNameSyntax simpleName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static StatementSyntax WithoutLeadingBlankLinesInTrivia(StatementSyntax statement);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetPreviousStatement(StatementSyntax statement);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetNextStatement(StatementSyntax statement);
    private static bool AreSiblingStatements(StatementSyntax first, StatementSyntax second);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SymbolDisplayPartExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SymbolDisplayPart MassageErrorTypeNames(SymbolDisplayPart part, string replacement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxKindExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SyntaxKind[] kinds, SyntaxKind kind);
    [ExtensionAttribute]
public static SyntaxKind MapCompoundAssignmentKindToBinaryExpressionKind(SyntaxKind syntaxKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<T> RemoveRange(SyntaxList`1<T> syntaxList, int index, int count);
    [ExtensionAttribute]
public static SyntaxList`1<T> Insert(SyntaxList`1<T> list, int index, T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static LanguageVersion GetLanguageVersion(SyntaxNode node);
    [ExtensionAttribute]
public static void Deconstruct(SyntaxNode node, SyntaxKind& kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxNode node, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxToken token, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyArgumentList(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBraces(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwner(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetEmbeddedStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static BaseParameterListSyntax GetParameterList(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetParentConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetRootConditionalAccessExpression(SyntaxNode node);
    [ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetInnerMostConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsCompoundAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfCompoundAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<UsingDirectiveSyntax> GetEnclosingUsingDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ExternAliasDirectiveSyntax> GetEnclosingExternAliasDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
    [ExtensionAttribute]
public static BaseNamespaceDeclarationSyntax GetInnermostNamespaceDeclarationWithUsings(SyntaxNode contextNode);
    [ExtensionAttribute]
public static bool IsBreakableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsContinuableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsYield(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstructOrTopLevelCompilationUnit(SyntaxNode node);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<TSyntaxNode> list);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TNode ConvertToSingleLine(TNode node, bool useElasticTrivia);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxToken token, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTriviaList list, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTrivia trivia, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<IList`1<TSyntaxNode>> SplitNodesOnPreprocessorBoundaries(IEnumerable`1<TSyntaxNode> nodes, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsVariableDeclaratorValue(SyntaxNode node);
    [ExtensionAttribute]
public static BlockSyntax FindInnermostCommonBlock(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__48")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestorsOrThis(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetParentheses(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBrackets(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxTokenList GetModifiers(SyntaxNode member);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WithModifiers(SyntaxNode member, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static IEnumerable`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInDeconstructionLeft(SyntaxNode node, SyntaxNode& deconstructionLeft);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, SyntaxToken leadingToken, SyntaxToken trailingToken);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxToken> leadingTokens, IEnumerable`1<SyntaxToken> trailingTokens);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static T KeepCommentsAndAddElasticMarkers(T node);
    [ExtensionAttribute]
public static SyntaxNode WithPrependedNonIndentationTriviaFrom(SyntaxNode to, SyntaxNode from);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__TakesExpressionTree|54_0(SymbolInfo info, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(SyntaxToken token, SyntaxKind& kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token, T& node);
    [ExtensionAttribute]
public static bool IsKindOrHasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool HasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsOpenBraceOrCommaOfObjectInitializer(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenBraceOfAccessorList(SyntaxToken token);
    [ExtensionAttribute]
public static bool CouldBeKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPotentialModifier(SyntaxToken token, SyntaxKind& modifierKind);
    [ExtensionAttribute]
public static bool IsLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IntersectsWith(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    private static bool IsWord(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken GetNextNonZeroWidthTokenOrEndOfFile(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstTokenOnLine(SyntaxToken token, SourceText text);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<SyntaxToken> tokens);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions/<GetAllTrailingTrivia>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsRegularStringLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsValidAttributeTarget(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithCommentsFrom(SyntaxToken token, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static SyntaxToken KeepCommentsAndAddElasticMarkers(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryParseGenericName(SyntaxToken genericIdentifier, CancellationToken cancellationToken, GenericNameSyntax& genericName);
    [ExtensionAttribute]
public static SyntaxToken FindLastTokenOfPartialGenericName(SyntaxToken genericIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTreeExtensions : object {
    private static Func`2<SyntaxKind, bool> s_isDotOrArrow;
    private static Func`2<SyntaxKind, bool> s_isDotOrArrowOrColonColon;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, Int32& positionBeforeModifiers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax GetContainingTypeDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static BaseTypeDeclarationSyntax GetContainingTypeOrEnumDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDeclarationSyntax> GetContainingTypeDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool BaseTypeDeclarationContainsPosition(BaseTypeDeclarationSyntax declaration, int position);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeDeclarationSyntax> GetContainingTypeOrEnumDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrowOrColonColon(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrow(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool IsRightOf(SyntaxTree syntaxTree, int position, Func`2<SyntaxKind, bool> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAfterKeyword(SyntaxTree syntaxTree, int position, SyntaxKind kind, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinNonUserCodeComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCrefContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCrefSyntax(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinSingleLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinConflictMarker(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinTopLevelSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinPreProcessorSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool AtEndOfIncompleteStringOrCharLiteral(SyntaxToken token, int position, char lastChar, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringOrCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(SyntaxTrivia trivia, SyntaxKind& kind);
    [ExtensionAttribute]
public static bool IsSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceOrSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularOrDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirective(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsCompleteMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string GetCommentText(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string AsString(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static int GetFullWidth(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxTriviaList AsTrivia(string s);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespace(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTrivia GetPreviousTrivia(SyntaxTrivia trivia, SyntaxTree syntaxTree, CancellationToken cancellationToken, bool findInsideTrivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions/<FilterComments>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> FilterComments(IEnumerable`1<SyntaxTrivia> trivia, bool addElasticMarker);
    [ExtensionAttribute]
public static bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetFirstNewLine(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastComment(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastCommentOrWhitespace(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> SkipInitialWhitespace(SyntaxTriviaList triviaList);
    private static ImmutableArray`1<ImmutableArray`1<SyntaxTrivia>> GetLeadingBlankLines(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutLeadingBlankLines(SyntaxTriviaList triviaList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions/<TakeRange>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> TakeRange(SyntaxTriviaList triviaList, int start, int end);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsVoid(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsPartial(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsTypeInferred(TypeSyntax typeSyntax, SemanticModel semanticModel);
    [ExtensionAttribute]
public static TypeSyntax StripRefIfNeeded(TypeSyntax type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.VariableDeclaratorExtensions : object {
    [ExtensionAttribute]
public static TypeSyntax GetVariableType(VariableDeclaratorSyntax declarator);
    [ExtensionAttribute]
public static bool IsTypeInferred(VariableDeclaratorSyntax variable, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderDiagnosticAnalyzer : AbstractFileHeaderDiagnosticAnalyzer {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderHelper : AbstractFileHeaderHelper {
    public static CSharpFileHeaderHelper Instance;
    public string CommentPrefix { get; }
    private static CSharpFileHeaderHelper();
    public virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AggregatedFormattingResult : AbstractAggregatedFormattingResult {
    public AggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, TextSpanMutableIntervalTree formattingSpans);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AnchorIndentationFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Formatting.BaseFormattingRule : AbstractFormattingRule {
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, bool includeTriviaAtEnd, IndentBlockOption option);
    protected static void AddAbsoluteZeroIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddSuppressWrappingIfOnSingleLineOperation(ArrayBuilder`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressAllOperationIfOnMultipleLine(ArrayBuilder`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressOperation(ArrayBuilder`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    protected static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxToken anchorToken, SyntaxToken endToken);
    protected static void AddAlignIndentationOfTokensToBaseTokenOperation(List`1<AlignTokensOperation> list, SyntaxNode containingNode, SyntaxToken baseNode, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    protected static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    protected static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    protected static void AddBraceSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
}
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions : Enum {
    public int value__;
    public static BinaryOperatorSpacingOptions Single;
    public static BinaryOperatorSpacingOptions Ignore;
    public static BinaryOperatorSpacingOptions Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormatEngine : AbstractFormatEngine {
    internal IHeaderFacts HeaderFacts { get; }
    public CSharpFormatEngine(SyntaxNode node, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptionGroups : object {
    public static OptionGroup Indentation;
    public static OptionGroup Spacing;
    public static OptionGroup Wrapping;
    private static CSharpFormattingOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions2 : object {
    private static string PublicFeatureName;
    private static Builder<IOption2> s_editorConfigOptionsBuilder;
    private static BidirectionalMap`2<string, SpacePlacementWithinParentheses> s_spacingWithinParenthesisOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, BinaryOperatorSpacingOptions> s_binaryOperatorSpacingOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, LabelPositionOptions> s_labelPositionOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineBeforeOpenBracePlacement> s_legacyNewLineOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineBeforeOpenBracePlacement> s_newLineOptionsEditorConfigMap;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacingAfterMethodDeclarationName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodDeclarationParenthesis>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterMethodCallName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterControlFlowStatementKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<SpacePlacementWithinParentheses> <SpaceBetweenParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterCast>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacesIgnoreAroundVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeOpenSquareBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptySquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinSquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<BinaryOperatorSpacingOptions> <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSectionWhenBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<LabelPositionOptions> <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<NewLineBeforeOpenBracePlacement> <NewLineBeforeOpenBrace>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForCatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInObjectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForClausesInQuery>k__BackingField;
    public static Option2`1<int> CollectionExpressionWrappingLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> EditorConfigOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> UndocumentedOptions;
    public static Option2`1<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option2`1<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option2`1<bool> SpaceAfterMethodCallName { get; }
    public static Option2`1<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option2`1<SpacePlacementWithinParentheses> SpaceBetweenParentheses { get; }
    public static Option2`1<bool> SpaceAfterCast { get; }
    public static Option2`1<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option2`1<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option2`1<bool> SpaceWithinSquareBrackets { get; }
    public static Option2`1<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceAfterComma { get; }
    public static Option2`1<bool> SpaceAfterDot { get; }
    public static Option2`1<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option2`1<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeComma { get; }
    public static Option2`1<bool> SpaceBeforeDot { get; }
    public static Option2`1<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option2`1<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option2`1<bool> IndentBraces { get; }
    public static Option2`1<bool> IndentBlock { get; }
    public static Option2`1<bool> IndentSwitchSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSectionWhenBlock { get; }
    public static Option2`1<LabelPositionOptions> LabelPositioning { get; }
    public static Option2`1<bool> WrappingPreserveSingleLine { get; }
    public static Option2`1<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option2`1<NewLineBeforeOpenBracePlacement> NewLineBeforeOpenBrace { get; }
    public static Option2`1<bool> NewLineForElse { get; }
    public static Option2`1<bool> NewLineForCatch { get; }
    public static Option2`1<bool> NewLineForFinally { get; }
    public static Option2`1<bool> NewLineForMembersInObjectInit { get; }
    public static Option2`1<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option2`1<bool> NewLineForClausesInQuery { get; }
    private static CSharpFormattingOptions2();
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, EditorConfigValueSerializer`1<T> serializer);
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacingAfterMethodDeclarationName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodDeclarationParenthesis();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterMethodCallName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterControlFlowStatementKeyword();
    [CompilerGeneratedAttribute]
public static Option2`1<SpacePlacementWithinParentheses> get_SpaceBetweenParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterCast();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacesIgnoreAroundVariableDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeOpenSquareBracket();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptySquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinSquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<BinaryOperatorSpacingOptions> get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSectionWhenBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<LabelPositionOptions> get_LabelPositioning();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<NewLineBeforeOpenBracePlacement> get_NewLineBeforeOpenBrace();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForElse();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForCatch();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForFinally();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInObjectInit();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForClausesInQuery();
    public static int ParseEditorConfigFlags(string list, Func`2<string, int> map, string noneToken, string allToken, int allValue);
    internal static string ToEditorConfigFlagList(int flags, Func`2<int, string> map);
    internal static SpacePlacementWithinParentheses ParseSpacingWithinParenthesesList(string list);
    internal static string ToEditorConfigValue(SpacePlacementWithinParentheses value);
    internal static NewLineBeforeOpenBracePlacement ParseNewLineBeforeOpenBracePlacementList(string list);
    internal static string ToEditorConfigValue(NewLineBeforeOpenBracePlacement value);
    internal static BinaryOperatorSpacingOptions ParseEditorConfigSpacingAroundBinaryOperator(string binaryOperatorSpacingValue);
    private static string GetSpacingAroundBinaryOperatorEditorConfigString(BinaryOperatorSpacingOptions value);
    internal static LabelPositionOptions ParseEditorConfigLabelPositioning(string labelIndentationValue);
    private static string GetLabelPositionOptionEditorConfigString(LabelPositionOptions value);
    internal static bool DetermineIfIgnoreSpacesAroundVariableDeclarationIsSet(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpStructuredTriviaFormatEngine : AbstractFormatEngine {
    internal IHeaderFacts HeaderFacts { get; }
    private CSharpStructuredTriviaFormatEngine(SyntaxTrivia trivia, int initialColumn, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    public static IFormattingResult Format(SyntaxTrivia trivia, int initialColumn, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormatting : AbstractSyntaxFormatting {
    public static CSharpSyntaxFormatting Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _rules;
    public SyntaxFormattingOptions DefaultOptions { get; }
    private static CSharpSyntaxFormatting();
    public virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    public virtual SyntaxFormattingOptions get_DefaultOptions();
    public virtual SyntaxFormattingOptions GetFormattingOptions(IOptionsReader options, SyntaxFormattingOptions fallbackOptions);
    protected virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, TextSpanMutableIntervalTree formattingSpans);
    protected virtual AbstractFormattingResult Format(SyntaxNode node, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormattingOptions : SyntaxFormattingOptions {
    private static CodeStyleOption2`1<NamespaceDeclarationPreference> s_defaultNamespaceDeclarations;
    private static CodeStyleOption2`1<bool> s_trueWithSilentEnforcement;
    public static SpacePlacement SpacingDefault;
    public static NewLinePlacement NewLinesDefault;
    public static IndentationPlacement IndentationDefault;
    public static CSharpSyntaxFormattingOptions Default;
    [CompilerGeneratedAttribute]
private SpacePlacement <Spacing>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperatorSpacingOptions <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLines>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelPositionOptions <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentationPlacement <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<NamespaceDeclarationPreference> <NamespaceDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferTopLevelStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CollectionExpressionWrappingLength>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public SpacePlacement Spacing { get; public set; }
    [DataMemberAttribute]
public BinaryOperatorSpacingOptions SpacingAroundBinaryOperator { get; public set; }
    [DataMemberAttribute]
public NewLinePlacement NewLines { get; public set; }
    [DataMemberAttribute]
public LabelPositionOptions LabelPositioning { get; public set; }
    [DataMemberAttribute]
public IndentationPlacement Indentation { get; public set; }
    [DataMemberAttribute]
public bool WrappingKeepStatementsOnSingleLine { get; public set; }
    [DataMemberAttribute]
public bool WrappingPreserveSingleLine { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; public set; }
    [DataMemberAttribute]
public int CollectionExpressionWrappingLength { get; public set; }
    public CSharpSyntaxFormattingOptions(IOptionsReader options, CSharpSyntaxFormattingOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpSyntaxFormattingOptions(CSharpSyntaxFormattingOptions original);
    private static CSharpSyntaxFormattingOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SpacePlacement get_Spacing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Spacing(SpacePlacement value);
    [CompilerGeneratedAttribute]
public BinaryOperatorSpacingOptions get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SpacingAroundBinaryOperator(BinaryOperatorSpacingOptions value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLines(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public LabelPositionOptions get_LabelPositioning();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LabelPositioning(LabelPositionOptions value);
    [CompilerGeneratedAttribute]
public IndentationPlacement get_Indentation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indentation(IndentationPlacement value);
    [CompilerGeneratedAttribute]
public bool get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingKeepStatementsOnSingleLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingPreserveSingleLine(bool value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceDeclarations(CodeStyleOption2`1<NamespaceDeclarationPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferTopLevelStatements(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public int get_CollectionExpressionWrappingLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollectionExpressionWrappingLength(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpSyntaxFormattingOptions left, CSharpSyntaxFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpSyntaxFormattingOptions left, CSharpSyntaxFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SyntaxFormattingOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpSyntaxFormattingOptions other);
    [CompilerGeneratedAttribute]
public virtual SyntaxFormattingOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpTriviaFormatter : AbstractTriviaFormatter {
    private bool _succeeded;
    private SyntaxTrivia _newLine;
    public CSharpTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected virtual bool Succeeded();
    protected virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsWhitespace(char ch);
    protected virtual bool IsNewLine(char ch);
    protected virtual SyntaxTrivia CreateWhitespace(string text);
    protected virtual SyntaxTrivia CreateEndOfLine();
    protected virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2, CancellationToken cancellationToken);
    protected virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    private bool IsStartOrEndOfFile(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private static bool IsMultilineComment(SyntaxTrivia trivia1);
    private bool TryFormatMultiLineCommentTrivia(LineColumn lineColumn, SyntaxTrivia trivia, SyntaxTrivia& result);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    private SyntaxTrivia FormatDocumentComment(LineColumn lineColumn, SyntaxTrivia trivia);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    protected virtual bool LineContinuationFollowedByWhitespaceComment(SyntaxTrivia trivia, SyntaxTrivia nextTrivia);
    protected virtual bool IsVisualBasicComment(SyntaxTrivia trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.DefaultOperationProvider : AbstractFormattingRule {
    public static DefaultOperationProvider Instance;
    private static DefaultOperationProvider();
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.ElasticTriviaFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddPropertyDeclarationSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddCollectionExpressionSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    private static Nullable`1<SyntaxToken> GetLastTokenOfType(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
private static AdjustNewLinesOperation GetAdjustNewLinesOperationAfterFileScopedNamespace(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
private static AdjustNewLinesOperation GetAdjustNewLinesOperationBetweenMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
private static bool TryGetOperationBeforeDocComment(SyntaxToken currentToken, AdjustNewLinesOperation& operation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static int LineBreaksAfter(SyntaxToken previousToken, SyntaxToken currentToken);
    private static int LineBreaksAfterCloseBrace(SyntaxToken nextToken);
    private static int LineBreaksAfterSemicolon(SyntaxToken previousToken, SyntaxToken currentToken);
    private static bool IsWhitespace(SyntaxTrivia trivia);
    private static int GetNumberOfLines(IEnumerable`1<SyntaxTrivia> triviaList);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.EndOfFileTokenFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.Extensions : object {
    [ExtensionAttribute]
public static NewLineBeforeOpenBracePlacement ToNewLineBeforeOpenBracePlacement(NewLinePlacement value);
    [ExtensionAttribute]
public static NewLinePlacement ToNewLinePlacement(NewLineBeforeOpenBracePlacement value);
    [ExtensionAttribute]
public static NewLineBeforeOpenBracePlacement WithFlagValue(NewLineBeforeOpenBracePlacement flags, NewLineBeforeOpenBracePlacement flag, bool value);
    [ExtensionAttribute]
public static SpacePlacementWithinParentheses ToSpacingWithinParentheses(SpacePlacement placement);
    [ExtensionAttribute]
public static SpacePlacement ToSpacePlacement(SpacePlacementWithinParentheses placement);
    [ExtensionAttribute]
public static SpacePlacementWithinParentheses WithFlagValue(SpacePlacementWithinParentheses flags, SpacePlacementWithinParentheses flag, bool value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingHelpers : object {
    [NullableAttribute("1")]
public static string NewLine;
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetIndent(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ContentBeforeLastNewLine(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracketPair(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsValidBracketOrBracePair(ValueTuple`2<SyntaxToken, SyntaxToken> bracketOrBracePair);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAConversionOperatorDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAOperationDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInArgumentListOrPositionalPattern(SyntaxToken token);
    private static bool IsTokenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInTypeBaseList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInArgumentOrParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfParenthesizedLambdaExpression(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsLambdaBodyBlock(SyntaxNode node);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAnonymousMethodBlock(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsSemicolonInForStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsSemicolonOfEmbeddedStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfEmbeddedBlock(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCommaInEnumDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInAnyArgumentsList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInParenthesizedExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInArgumentList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsEqualsTokenInAutoPropertyInitializers(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccessOrQualifiedName(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccess(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGenericGreaterThanToken(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInInitializerExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInCasePatternSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchExpressionArm(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInSwitchExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInPropertyPatternClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsIdentifierInLabeledStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInLabeledStatement(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwnerWithCloseParen(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNestedQueryExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstFromKeywordInExpression(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForObjectOrAnonymousObjectCreationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForArrayOrCollectionCreationExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool ParenOrBracketContainsNothing(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool IsLastTokenInLabelStatement(SyntaxToken token);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetFirstAndLastMemberDeclarationTokensAfterAttributes(MemberDeclarationSyntax node);
    [ExtensionAttribute]
public static bool IsPlusOrMinusExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsInterpolation(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsOpenParenInVarDeconstructionDeclaration(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsCommaInTupleExpression(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsCommaInCollectionExpression(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingResult : AbstractFormattingResult {
    internal FormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan spanToFormat);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.IndentationPlacement : Enum {
    public int value__;
    public static IndentationPlacement Braces;
    public static IndentationPlacement BlockContents;
    public static IndentationPlacement SwitchCaseContents;
    public static IndentationPlacement SwitchCaseContentsWhenBlock;
    public static IndentationPlacement SwitchSection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentBlockFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private IndentBlockFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddTypeParameterConstraintClauseOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddSwitchIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddLabelIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode baseNode, SyntaxNode body);
    private void AddBlockIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddBracketIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static void AddAlignmentBlockOperationRelativeToFirstTokenOnBaseTokenLine(List`1<IndentBlockOperation> list, ValueTuple`2<SyntaxToken, SyntaxToken> bracePair);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentUserSettingsFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private IndentUserSettingsFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions : Enum {
    public int value__;
    public static LabelPositionOptions LeftMost;
    public static LabelPositionOptions OneLess;
    public static LabelPositionOptions NoIndent;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.NewLineBeforeOpenBracePlacement : Enum {
    public int value__;
    public static NewLineBeforeOpenBracePlacement None;
    public static NewLineBeforeOpenBracePlacement Types;
    public static NewLineBeforeOpenBracePlacement Methods;
    public static NewLineBeforeOpenBracePlacement Properties;
    public static NewLineBeforeOpenBracePlacement AnonymousMethods;
    public static NewLineBeforeOpenBracePlacement ControlBlocks;
    public static NewLineBeforeOpenBracePlacement AnonymousTypes;
    public static NewLineBeforeOpenBracePlacement ObjectCollectionArrayInitializers;
    public static NewLineBeforeOpenBracePlacement LambdaExpressionBody;
    public static NewLineBeforeOpenBracePlacement Accessors;
    public static NewLineBeforeOpenBracePlacement All;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.NewLinePlacement : Enum {
    public int value__;
    public static NewLinePlacement BeforeMembersInObjectInitializers;
    public static NewLinePlacement BeforeMembersInAnonymousTypes;
    public static NewLinePlacement BeforeElse;
    public static NewLinePlacement BeforeCatch;
    public static NewLinePlacement BeforeFinally;
    public static NewLinePlacement BeforeOpenBraceInTypes;
    public static NewLinePlacement BeforeOpenBraceInAnonymousTypes;
    public static NewLinePlacement BeforeOpenBraceInObjectCollectionArrayInitializers;
    public static NewLinePlacement BeforeOpenBraceInProperties;
    public static NewLinePlacement BeforeOpenBraceInMethods;
    public static NewLinePlacement BeforeOpenBraceInAccessors;
    public static NewLinePlacement BeforeOpenBraceInAnonymousMethods;
    public static NewLinePlacement BeforeOpenBraceInLambdaExpressionBody;
    public static NewLinePlacement BeforeOpenBraceInControlBlocks;
    public static NewLinePlacement BetweenQueryExpressionClauses;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.NewLineUserSettingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private NewLineUserSettingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    private static bool IsControlBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.QueryExpressionFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private QueryExpressionFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddIndentBlockOperationsForFromClause(List`1<IndentBlockOperation> list, FromClauseSyntax fromClause);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.SpacePlacement : Enum {
    public int value__;
    public static SpacePlacement IgnoreAroundVariableDeclaration;
    public static SpacePlacement AfterMethodDeclarationName;
    public static SpacePlacement BetweenEmptyMethodDeclarationParentheses;
    public static SpacePlacement WithinMethodDeclarationParenthesis;
    public static SpacePlacement AfterMethodCallName;
    public static SpacePlacement BetweenEmptyMethodCallParentheses;
    public static SpacePlacement WithinMethodCallParentheses;
    public static SpacePlacement AfterControlFlowStatementKeyword;
    public static SpacePlacement WithinExpressionParentheses;
    public static SpacePlacement WithinCastParentheses;
    public static SpacePlacement BeforeSemicolonsInForStatement;
    public static SpacePlacement AfterSemicolonsInForStatement;
    public static SpacePlacement WithinOtherParentheses;
    public static SpacePlacement AfterCast;
    public static SpacePlacement BeforeOpenSquareBracket;
    public static SpacePlacement BetweenEmptySquareBrackets;
    public static SpacePlacement WithinSquareBrackets;
    public static SpacePlacement AfterColonInBaseTypeDeclaration;
    public static SpacePlacement BeforeColonInBaseTypeDeclaration;
    public static SpacePlacement AfterComma;
    public static SpacePlacement BeforeComma;
    public static SpacePlacement AfterDot;
    public static SpacePlacement BeforeDot;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Formatting.SpacePlacementWithinParentheses : Enum {
    public int value__;
    public static SpacePlacementWithinParentheses None;
    public static SpacePlacementWithinParentheses Expressions;
    public static SpacePlacementWithinParentheses TypeCasts;
    public static SpacePlacementWithinParentheses ControlFlowStatements;
    public static SpacePlacementWithinParentheses All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SpacingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private SpacingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static bool IsEmptyForStatement(ForStatementSyntax forStatement);
    private void SuppressVariableDeclaration(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static AdjustSpacesOperation AdjustSpacesOperationZeroOrOne(bool option, AdjustSpacesOption explicitOption);
    private static bool HasFormattableBracketParent(SyntaxToken token);
    private static bool IsFunctionLikeKeywordExpressionKind(SyntaxKind syntaxKind);
    private static bool IsControlFlowLikeKeywordStatementKind(SyntaxKind syntaxKind);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.StructuredTriviaFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SuppressFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddSpecificNodesSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddFormatSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsFormatDirective(DirectiveTriviaSyntax trivia, SyntaxKind disableOrRestoreKeyword);
    private static void AddInitializerSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode parent, IEnumerable`1<SyntaxNode> items);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTriviaList|4_0(ArrayBuilder`1<SuppressOperation> list, SyntaxTriviaList triviaList);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTrivia|4_1(ArrayBuilder`1<SuppressOperation> list, SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessStructuredTrivia|4_2(ArrayBuilder`1<SuppressOperation> list, SyntaxNode structure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TokenBasedFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CSharpSyntaxFormattingOptions _options;
    private TokenBasedFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private AdjustNewLinesOperation AdjustNewLinesAfterSemicolonToken(SyntaxToken previousToken, SyntaxToken currentToken);
    private static SyntaxList`1<UsingDirectiveSyntax> GetUsings(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaDataFactory : AbstractTriviaDataFactory {
    public TriviaDataFactory(TreeData treeInfo, LineFormattingOptions options);
    private static bool IsCSharpWhitespace(char c);
    public virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
    private static bool ContainsOnlyWhitespace(AnalysisResult result);
    [NullableContextAttribute("2")]
private TriviaData GetWhitespaceOnlyTriviaInfo(SyntaxToken token1, SyntaxToken token2, AnalysisResult result);
    private int CalculateSpaces(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("0")]
private ValueTuple`3<bool, int, int> GetLineBreaksAndIndentation(AnalysisResult result);
    private static int GetSpaceOnSingleLine(AnalysisResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaRewriter : CSharpSyntaxRewriter {
    private SyntaxNode _node;
    private TextSpanMutableIntervalTree _spans;
    private CancellationToken _cancellationToken;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _trailingTriviaMap;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _leadingTriviaMap;
    public TriviaRewriter(SyntaxNode node, TextSpanMutableIntervalTree spanToFormat, Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public SyntaxNode Transform();
    private void PreprocessTriviaListMap(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ValueTuple`2<SyntaxTriviaList, SyntaxTriviaList> GetTrailingAndLeadingTrivia(KeyValuePair`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> pair, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private TextSpan GetTextSpan(ValueTuple`2<SyntaxToken, SyntaxToken> pair);
    private static int GetFirstEndOfLineIndexOrRightBeforeComment(SyntaxTriviaList triviaList);
    [NullableContextAttribute("0")]
private SyntaxTriviaList GetLeadingTriviaAtBeginningOfTree(ValueTuple`2<SyntaxToken, SyntaxToken> pair, TriviaData triviaData, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    private static SyntaxToken CreateNewToken(SyntaxTriviaList leadingTrivia, SyntaxToken token, SyntaxTriviaList trailingTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.WrappingFormattingRule : BaseFormattingRule {
    private CSharpSyntaxFormattingOptions _options;
    private WrappingFormattingRule(CSharpSyntaxFormattingOptions options);
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetSpecificNodeSuppressionTokenRange(SyntaxNode node);
    private static void AddSpecificNodesSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForStatementMethodDeclaration(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForBlock(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    private static void RemoveSuppressOperation(ArrayBuilder`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpSmartTokenFormatter : object {
    private IndentationOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private CompilationUnitSyntax _root;
    private SourceText _text;
    public CSharpSmartTokenFormatter(IndentationOptions options, ImmutableArray`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, SourceText text);
    public IList`1<TextChange> FormatRange(SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    private static bool CloseBraceOfTryOrDoBlock(SyntaxToken endToken);
    public sealed virtual IList`1<TextChange> FormatToken(SyntaxToken token, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0165;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static bool WouldCauseDefiniteAssignmentErrors(SemanticModel semanticModel, LocalDeclarationStatementSyntax localStatement, BlockSyntax enclosingBlock, ILocalSymbol outLocalSymbol);
    private static SyntaxNode GetOutArgumentScope(SyntaxNode argumentExpression);
    private static bool IsAccessed(SemanticModel semanticModel, ISymbol outSymbol, BlockSyntax enclosingBlockOfLocalStatement, LocalDeclarationStatementSyntax localStatement, ArgumentSyntax argumentNode, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext compilationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.Constants : object {
    public static string Kind;
    public static string VariableAndIfStatementForm;
    public static string SingleIfStatementForm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    private bool TryCheckSingleIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, NotificationOption2 notificationOption);
    private void ReportDiagnostics(SyntaxNodeAnalysisContext syntaxContext, StatementSyntax firstStatement, IfStatementSyntax ifStatement, ExpressionStatementSyntax expressionStatement, NotificationOption2 notificationOption, ImmutableArray`1<Location> additionalLocations, string kind);
    private bool TryCheckVariableAndIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, NotificationOption2 notificationOption);
    private static bool IsNullCheckExpression(ExpressionSyntax left, ExpressionSyntax right);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <TryCheckSingleIfStatementForm>g__InvocationExpressionIsEquivalent|3_0(ExpressionSyntax expression, InvocationExpressionSyntax invocationExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpAccessibilityFacts : object {
    public static IAccessibilityFacts Instance;
    private static CSharpAccessibilityFacts();
    public sealed virtual bool CanHaveAccessibility(SyntaxNode declaration, bool ignoreDeclarationModifiers);
    public sealed virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public static void GetAccessibilityAndModifiers(SyntaxTokenList modifierList, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
    public static DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public static SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    [NullableContextAttribute("2")]
public static bool ParentIsFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool ParentIsEventFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool ParentIsLocalDeclarationStatement(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpBlockFacts : AbstractBlockFacts {
    public static IBlockFacts Instance;
    private static CSharpBlockFacts();
    [NullableContextAttribute("2")]
public virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual bool IsExecutableBlock(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public virtual bool IsStatementContainer(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <FindInnermostCommonExecutableBlock>b__4_0(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpDocumentationCommentService : AbstractDocumentationCommentService`10<DocumentationCommentTriviaSyntax, XmlNodeSyntax, XmlAttributeSyntax, CrefSyntax, XmlElementSyntax, XmlTextSyntax, XmlEmptyElementSyntax, XmlCrefAttributeSyntax, XmlNameAttributeSyntax, XmlTextAttributeSyntax> {
    public static IDocumentationCommentService Instance;
    private static CSharpDocumentationCommentService();
    protected virtual SyntaxList`1<XmlAttributeSyntax> GetAttributes(XmlEmptyElementSyntax xmlEmpty);
    protected virtual CrefSyntax GetCref(XmlCrefAttributeSyntax xmlCref);
    protected virtual SyntaxToken GetIdentifier(XmlNameAttributeSyntax xmlName);
    protected virtual SyntaxNode GetName(XmlElementSyntax xmlElement);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextAttributeSyntax xmlTextAttribute);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpFileBannerFacts : AbstractFileBannerFacts {
    public static IFileBannerFacts Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IDocumentationCommentService DocumentationCommentService { get; }
    private static CSharpFileBannerFacts();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IDocumentationCommentService get_DocumentationCommentService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpHeaderFacts : AbstractHeaderFacts {
    public static IHeaderFacts Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpHeaderFacts();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    public virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSelectedMembers : AbstractSelectedMembers`5<MemberDeclarationSyntax, FieldDeclarationSyntax, PropertyDeclarationSyntax, TypeDeclarationSyntax, VariableDeclaratorSyntax> {
    public static CSharpSelectedMembers Instance;
    private static CSharpSelectedMembers();
    protected virtual ImmutableArray`1<ValueTuple`2<SyntaxNode, SyntaxToken>> GetDeclaratorsAndIdentifiers(MemberDeclarationSyntax member);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMembers(TypeDeclarationSyntax containingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxFacts : object {
    internal static CSharpSyntaxFacts Instance;
    [CompilerGeneratedAttribute]
private StringComparer <StringComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISyntaxKinds <SyntaxKinds>k__BackingField;
    private static string dotToken;
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public ISyntaxKinds SyntaxKinds { get; }
    private static CSharpSyntaxFacts();
    public sealed virtual bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public sealed virtual StringComparer get_StringComparer();
    public sealed virtual SyntaxTrivia get_ElasticMarker();
    public sealed virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public sealed virtual ISyntaxKinds get_SyntaxKinds();
    public sealed virtual bool SupportsIndexingInitializer(ParseOptions options);
    public sealed virtual bool SupportsThrowExpression(ParseOptions options);
    public sealed virtual bool SupportsLocalFunctionDeclaration(ParseOptions options);
    public sealed virtual bool SupportsRecord(ParseOptions options);
    public sealed virtual bool SupportsRecordStruct(ParseOptions options);
    public sealed virtual bool SupportsTargetTypedConditionalExpression(ParseOptions options);
    public sealed virtual bool SupportsConstantInterpolatedStrings(ParseOptions options);
    public sealed virtual bool SupportsTupleDeconstruction(ParseOptions options);
    public sealed virtual bool SupportsCollectionExpressionNaturalType(ParseOptions options);
    public sealed virtual SyntaxToken ParseToken(string text);
    public sealed virtual SyntaxTriviaList ParseLeadingTrivia(string text);
    public sealed virtual string EscapeIdentifier(string identifier);
    public sealed virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public sealed virtual bool IsOperator(SyntaxToken token);
    public sealed virtual bool IsReservedKeyword(SyntaxToken token);
    public sealed virtual bool IsContextualKeyword(SyntaxToken token);
    public sealed virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public sealed virtual bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDirective(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetExternalSourceInfo(SyntaxNode node, ExternalSourceInfo& info);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetStandaloneExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeclarationExpression(SyntaxNode node);
    public sealed virtual bool IsAttributeName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNamedArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfNamedArgument(SyntaxNode node);
    public sealed virtual SyntaxNode GetParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingDirectiveName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingAliasDirective(SyntaxNode node);
    public sealed virtual void GetPartsOfUsingAliasDirective(SyntaxNode node, SyntaxToken& globalKeyword, SyntaxToken& alias, SyntaxNode& name);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeconstructionAssignment(SyntaxNode node);
    public sealed virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsExecutableStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalStatement(SyntaxNode node);
    public sealed virtual SyntaxNode GetStatementOfGlobalStatement(SyntaxNode node);
    public sealed virtual bool AreStatementsInSameContainer(SyntaxNode firstStatement, SyntaxNode secondStatement);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodBody(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfRefExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public sealed virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsQueryKeyword(SyntaxToken token);
    public sealed virtual bool IsPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPredefinedType(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPredefinedType(SyntaxNode node, PredefinedType type);
    public sealed virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    private static PredefinedType GetPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public sealed virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    private static PredefinedOperator GetPredefinedOperator(SyntaxToken token);
    public sealed virtual string GetText(int kind);
    public sealed virtual bool IsIdentifierStartCharacter(char c);
    public sealed virtual bool IsIdentifierPartCharacter(char c);
    public sealed virtual bool IsIdentifierEscapeCharacter(char c);
    public sealed virtual bool IsValidIdentifier(string identifier);
    public sealed virtual bool IsVerbatimIdentifier(string identifier);
    public sealed virtual bool IsTypeCharacter(char c);
    public sealed virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public sealed virtual bool IsLiteral(SyntaxToken token);
    public sealed virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public sealed virtual bool IsBindableToken(SyntaxToken token);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPostfixUnaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    public sealed virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public sealed virtual bool LooksGeneric(SyntaxNode simpleName);
    [NullableContextAttribute("2")]
public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(SyntaxNode genericName);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public sealed virtual SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public sealed virtual bool IsInStaticContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBaseTypeList(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfAttributeArgument(SyntaxNode node);
    public sealed virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAttributeArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInConstantContext(SyntaxNode node);
    public sealed virtual bool IsInConstructor(SyntaxNode node);
    public sealed virtual bool IsUnsafeContext(SyntaxNode node);
    public sealed virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public sealed virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNameOfSubpattern(SyntaxNode node);
    public sealed virtual bool IsPropertyPatternClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyInitializerExpression(SyntaxNode node, SyntaxNode& creationExpression);
    [NullableContextAttribute("2")]
public sealed virtual bool IsElementAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public sealed virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public sealed virtual SyntaxNode GetContainingMethodDeclaration(SyntaxNode root, int position, bool useFullSpan);
    private static SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodLevelMember(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    private static string GetName(SyntaxNode node, DisplayNameOptions options);
    private static void AppendTypeParameterList(StringBuilder builder, TypeParameterListSyntax typeParameterList);
    public sealed virtual List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    public sealed virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public sealed virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    private void AppendMembers(SyntaxNode node, List`1<SyntaxNode> list, bool topLevel, bool methodLevel);
    public sealed virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    private static TextSpan GetBlockBodySpan(BlockSyntax body);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode TryGetBindableParent(SyntaxToken token);
    public sealed virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    private static void AppendConstructors(SyntaxList`1<MemberDeclarationSyntax> members, List`1<SyntaxNode> constructors, CancellationToken cancellationToken);
    public sealed virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual string GetNameForArgument(SyntaxNode argument);
    public sealed virtual string GetNameForAttributeArgument(SyntaxNode argument);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public sealed virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public static bool IsOperandOfDecrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    public sealed virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public sealed virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    public sealed virtual bool IsNumericLiteral(SyntaxToken token);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode objectCreationExpression);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode argumentList);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfAttributeArgumentList(SyntaxNode argumentList);
    public sealed virtual bool IsRegularComment(SyntaxTrivia trivia);
    public sealed virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public sealed virtual bool IsElastic(SyntaxTrivia trivia);
    public sealed virtual bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public sealed virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public sealed virtual bool IsDocumentationComment(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalAssemblyAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGlobalModuleAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsGlobalAttribute(SyntaxNode node, SyntaxKind attributeTarget);
    [NullableContextAttribute("2")]
public sealed virtual bool IsDeclaration(SyntaxNode node);
    public sealed virtual bool IsTypeDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    public sealed virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyAssignmentStatement(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfTypeDeclaration(SyntaxNode node);
    public sealed virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public sealed virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
public sealed virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public static SyntaxNode GetExpressionOfInvocationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsExpressionOfForeach(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public sealed virtual void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    public sealed virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public sealed virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public sealed virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxNode GetInitializerOfPropertyDeclaration(SyntaxNode node);
    public sealed virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsEqualsValueOfPropertyDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsConversionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsCastExpression(SyntaxNode node);
    public sealed virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public sealed virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public sealed virtual SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    public sealed virtual void GetPartsOfAnyIsTypeExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& type);
    public sealed virtual void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyPattern(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    public sealed virtual void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    [NullableContextAttribute("2")]
public sealed virtual void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    public sealed virtual bool SupportsNotPattern(ParseOptions options);
    public sealed virtual bool SupportsIsNotTypeExpression(ParseOptions options);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBinaryPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsUnaryPattern(SyntaxNode node);
    public sealed virtual void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    public sealed virtual void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    public sealed virtual void GetPartsOfRelationalPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& expression);
    public sealed virtual SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    public sealed virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnonymousFunctionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBaseNamespaceDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsBinaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsLiteralExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMethodDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSimpleName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyName(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsAnyType(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsNamedMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsElementAccessInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsObjectMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public sealed virtual bool IsObjectCollectionInitializer(SyntaxNode node);
    public sealed virtual void GetPartsOfArgumentList(SyntaxNode node, SyntaxToken& openParenToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParenToken);
    [NullableContextAttribute("2")]
public sealed virtual void GetPartsOfBaseObjectCreationExpression(SyntaxNode node, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual void GetPartsOfCompilationUnit(SyntaxNode node, SyntaxList`1& imports, SyntaxList`1& attributeLists, SyntaxList`1& members);
    public sealed virtual void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public sealed virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public sealed virtual SyntaxNode GetExpressionOfForeachStatement(SyntaxNode statement);
    public sealed virtual void GetPartsOfGenericName(SyntaxNode node, SyntaxToken& identifier, SeparatedSyntaxList`1& typeArguments);
    public sealed virtual void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    public sealed virtual void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    public sealed virtual void GetPartsOfBaseNamespaceDeclaration(SyntaxNode node, SyntaxNode& name, SyntaxList`1& imports, SyntaxList`1& members);
    public sealed virtual void GetPartsOfNamedMemberInitializer(SyntaxNode node, SyntaxNode& identifier, SyntaxNode& expression);
    public sealed virtual void GetPartsOfObjectCreationExpression(SyntaxNode node, SyntaxToken& keyword, SyntaxNode& type, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual void GetPartsOfImplicitObjectCreationExpression(SyntaxNode node, SyntaxToken& keyword, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual void GetPartsOfParameter(SyntaxNode node, SyntaxToken& identifier, SyntaxNode& default);
    public sealed virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public sealed virtual void GetPartsOfPrefixUnaryExpression(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& operand);
    public sealed virtual void GetPartsOfQualifiedName(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual SyntaxNode GetArgumentListOfImplicitElementAccess(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfThrowExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfThrowStatement(SyntaxNode node);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetInitializersOfObjectMemberInitializer(SyntaxNode node);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetExpressionsOfObjectCollectionInitializer(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageService.CSharpSyntaxKinds : object {
    [NullableAttribute("1")]
public static CSharpSyntaxKinds Instance;
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int SingleLineDocCommentTrivia { get; }
    public Nullable`1<int> MultiLineDocCommentTrivia { get; }
    public int IfDirectiveTrivia { get; }
    public int ElifDirectiveTrivia { get; }
    public int ElseDirectiveTrivia { get; }
    public int EndIfDirectiveTrivia { get; }
    public int RegionDirectiveTrivia { get; }
    public int EndRegionDirectiveTrivia { get; }
    public Nullable`1<int> ShebangDirectiveTrivia { get; }
    public int CloseBraceToken { get; }
    public Nullable`1<int> CloseBracketToken { get; }
    public int CloseParenToken { get; }
    public int CommaToken { get; }
    public int ColonToken { get; }
    public int CharacterLiteralToken { get; }
    public int DotToken { get; }
    public int GreaterThanToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int LessThanToken { get; }
    public int LessThanSlashToken { get; }
    public int OpenBraceToken { get; }
    public Nullable`1<int> OpenBracketToken { get; }
    public int OpenParenToken { get; }
    public int QuestionToken { get; }
    public int StringLiteralToken { get; }
    public Nullable`1<int> SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> MultiLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8StringLiteralToken { get; }
    public Nullable`1<int> Utf8SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8MultiLineRawStringLiteralToken { get; }
    public int XmlTextLiteralToken { get; }
    public int DelegateKeyword { get; }
    public int FalseKeyword { get; }
    public int IfKeyword { get; }
    public int NewKeyword { get; }
    public int TrueKeyword { get; }
    public int UsingKeyword { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int CharacterLiteralExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int NullLiteralExpression { get; }
    public int NumericLiteralExpression { get; }
    public int StringLiteralExpression { get; }
    public int TrueLiteralExpression { get; }
    public int AddExpression { get; }
    public int AddressOfExpression { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int ArrayCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int CollectionInitializerExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public Nullable`1<int> ImplicitArrayCreationExpression { get; }
    public Nullable`1<int> ImplicitObjectCreationExpression { get; }
    public Nullable`1<int> IndexExpression { get; }
    public int InvocationExpression { get; }
    public Nullable`1<int> IsPatternExpression { get; }
    public int IsTypeExpression { get; }
    public Nullable`1<int> IsNotTypeExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public Nullable`1<int> RangeExpression { get; }
    public Nullable`1<int> RefExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public Nullable`1<int> ThrowExpression { get; }
    public int TupleExpression { get; }
    public Nullable`1<int> AndPattern { get; }
    public Nullable`1<int> ConstantPattern { get; }
    public Nullable`1<int> DeclarationPattern { get; }
    public Nullable`1<int> ListPattern { get; }
    public Nullable`1<int> NotPattern { get; }
    public Nullable`1<int> OrPattern { get; }
    public Nullable`1<int> ParenthesizedPattern { get; }
    public Nullable`1<int> RecursivePattern { get; }
    public Nullable`1<int> RelationalPattern { get; }
    public Nullable`1<int> TypePattern { get; }
    public Nullable`1<int> VarPattern { get; }
    public int EndOfFileToken { get; }
    public int AwaitKeyword { get; }
    public int AsyncKeyword { get; }
    public int IdentifierToken { get; }
    public int GlobalKeyword { get; }
    public int IncompleteMember { get; }
    public int HashToken { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int ForStatement { get; }
    public int IfStatement { get; }
    public int LocalDeclarationStatement { get; }
    public Nullable`1<int> LocalFunctionStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int ThrowStatement { get; }
    public int UsingStatement { get; }
    public int WhileStatement { get; }
    public int YieldReturnStatement { get; }
    public int Attribute { get; }
    public int ClassDeclaration { get; }
    public int ConstructorDeclaration { get; }
    public int EnumDeclaration { get; }
    public int InterfaceDeclaration { get; }
    public Nullable`1<int> StructDeclaration { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int FieldDeclaration { get; }
    public int PropertyDeclaration { get; }
    public int ParameterList { get; }
    public int TypeArgumentList { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int ElseClause { get; }
    public int EqualsValueClause { get; }
    public Nullable`1<int> ImplicitElementAccess { get; }
    public int Interpolation { get; }
    public int InterpolatedStringExpression { get; }
    public int InterpolatedStringText { get; }
    public Nullable`1<int> IndexerMemberCref { get; }
    private static CSharpSyntaxKinds();
    public sealed virtual TSyntaxKind Convert(int kind);
    public sealed virtual int Convert(TSyntaxKind kind);
    public sealed virtual int get_ConflictMarkerTrivia();
    public sealed virtual int get_DisabledTextTrivia();
    public sealed virtual int get_EndOfLineTrivia();
    public sealed virtual int get_SkippedTokensTrivia();
    public sealed virtual int get_WhitespaceTrivia();
    public sealed virtual int get_SingleLineCommentTrivia();
    public sealed virtual Nullable`1<int> get_MultiLineCommentTrivia();
    public sealed virtual int get_SingleLineDocCommentTrivia();
    public sealed virtual Nullable`1<int> get_MultiLineDocCommentTrivia();
    public sealed virtual int get_IfDirectiveTrivia();
    public sealed virtual int get_ElifDirectiveTrivia();
    public sealed virtual int get_ElseDirectiveTrivia();
    public sealed virtual int get_EndIfDirectiveTrivia();
    public sealed virtual int get_RegionDirectiveTrivia();
    public sealed virtual int get_EndRegionDirectiveTrivia();
    public sealed virtual Nullable`1<int> get_ShebangDirectiveTrivia();
    public sealed virtual int get_CloseBraceToken();
    public sealed virtual Nullable`1<int> get_CloseBracketToken();
    public sealed virtual int get_CloseParenToken();
    public sealed virtual int get_CommaToken();
    public sealed virtual int get_ColonToken();
    public sealed virtual int get_CharacterLiteralToken();
    public sealed virtual int get_DotToken();
    public sealed virtual int get_GreaterThanToken();
    public sealed virtual int get_InterpolatedStringTextToken();
    public sealed virtual int get_LessThanToken();
    public sealed virtual int get_LessThanSlashToken();
    public sealed virtual int get_OpenBraceToken();
    public sealed virtual Nullable`1<int> get_OpenBracketToken();
    public sealed virtual int get_OpenParenToken();
    public sealed virtual int get_QuestionToken();
    public sealed virtual int get_StringLiteralToken();
    public sealed virtual Nullable`1<int> get_SingleLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_MultiLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8StringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8SingleLineRawStringLiteralToken();
    public sealed virtual Nullable`1<int> get_Utf8MultiLineRawStringLiteralToken();
    public sealed virtual int get_XmlTextLiteralToken();
    public sealed virtual int get_DelegateKeyword();
    public sealed virtual int get_FalseKeyword();
    public sealed virtual int get_IfKeyword();
    public sealed virtual int get_NewKeyword();
    public sealed virtual int get_TrueKeyword();
    public sealed virtual int get_UsingKeyword();
    public sealed virtual int get_GenericName();
    public sealed virtual int get_IdentifierName();
    public sealed virtual int get_QualifiedName();
    public sealed virtual int get_TupleType();
    public sealed virtual int get_CharacterLiteralExpression();
    public sealed virtual int get_DefaultLiteralExpression();
    public sealed virtual int get_FalseLiteralExpression();
    public sealed virtual int get_NullLiteralExpression();
    public sealed virtual int get_NumericLiteralExpression();
    public sealed virtual int get_StringLiteralExpression();
    public sealed virtual int get_TrueLiteralExpression();
    public sealed virtual int get_AddExpression();
    public sealed virtual int get_AddressOfExpression();
    public sealed virtual int get_AnonymousObjectCreationExpression();
    public sealed virtual int get_ArrayCreationExpression();
    public sealed virtual int get_AwaitExpression();
    public sealed virtual int get_BaseExpression();
    public sealed virtual int get_CollectionInitializerExpression();
    public sealed virtual int get_ConditionalAccessExpression();
    public sealed virtual int get_ConditionalExpression();
    public sealed virtual Nullable`1<int> get_ImplicitArrayCreationExpression();
    public sealed virtual Nullable`1<int> get_ImplicitObjectCreationExpression();
    public sealed virtual Nullable`1<int> get_IndexExpression();
    public sealed virtual int get_InvocationExpression();
    public sealed virtual Nullable`1<int> get_IsPatternExpression();
    public sealed virtual int get_IsTypeExpression();
    public sealed virtual Nullable`1<int> get_IsNotTypeExpression();
    public sealed virtual int get_LogicalAndExpression();
    public sealed virtual int get_LogicalOrExpression();
    public sealed virtual int get_LogicalNotExpression();
    public sealed virtual int get_ObjectCreationExpression();
    public sealed virtual int get_ParenthesizedExpression();
    public sealed virtual int get_QueryExpression();
    public sealed virtual Nullable`1<int> get_RangeExpression();
    public sealed virtual Nullable`1<int> get_RefExpression();
    public sealed virtual int get_ReferenceEqualsExpression();
    public sealed virtual int get_ReferenceNotEqualsExpression();
    public sealed virtual int get_SimpleMemberAccessExpression();
    public sealed virtual int get_TernaryConditionalExpression();
    public sealed virtual int get_ThisExpression();
    public sealed virtual Nullable`1<int> get_ThrowExpression();
    public sealed virtual int get_TupleExpression();
    public sealed virtual Nullable`1<int> get_AndPattern();
    public sealed virtual Nullable`1<int> get_ConstantPattern();
    public sealed virtual Nullable`1<int> get_DeclarationPattern();
    public sealed virtual Nullable`1<int> get_ListPattern();
    public sealed virtual Nullable`1<int> get_NotPattern();
    public sealed virtual Nullable`1<int> get_OrPattern();
    public sealed virtual Nullable`1<int> get_ParenthesizedPattern();
    public sealed virtual Nullable`1<int> get_RecursivePattern();
    public sealed virtual Nullable`1<int> get_RelationalPattern();
    public sealed virtual Nullable`1<int> get_TypePattern();
    public sealed virtual Nullable`1<int> get_VarPattern();
    public sealed virtual int get_EndOfFileToken();
    public sealed virtual int get_AwaitKeyword();
    public sealed virtual int get_AsyncKeyword();
    public sealed virtual int get_IdentifierToken();
    public sealed virtual int get_GlobalKeyword();
    public sealed virtual int get_IncompleteMember();
    public sealed virtual int get_HashToken();
    public sealed virtual int get_ExpressionStatement();
    public sealed virtual int get_ForEachStatement();
    public sealed virtual int get_ForStatement();
    public sealed virtual int get_IfStatement();
    public sealed virtual int get_LocalDeclarationStatement();
    public sealed virtual Nullable`1<int> get_LocalFunctionStatement();
    public sealed virtual int get_LockStatement();
    public sealed virtual int get_ReturnStatement();
    public sealed virtual int get_ThrowStatement();
    public sealed virtual int get_UsingStatement();
    public sealed virtual int get_WhileStatement();
    public sealed virtual int get_YieldReturnStatement();
    public sealed virtual int get_Attribute();
    public sealed virtual int get_ClassDeclaration();
    public sealed virtual int get_ConstructorDeclaration();
    public sealed virtual int get_EnumDeclaration();
    public sealed virtual int get_InterfaceDeclaration();
    public sealed virtual Nullable`1<int> get_StructDeclaration();
    public sealed virtual int get_Parameter();
    public sealed virtual int get_TypeConstraint();
    public sealed virtual int get_VariableDeclarator();
    public sealed virtual int get_FieldDeclaration();
    public sealed virtual int get_PropertyDeclaration();
    public sealed virtual int get_ParameterList();
    public sealed virtual int get_TypeArgumentList();
    public sealed virtual Nullable`1<int> get_GlobalStatement();
    public sealed virtual int get_ElseClause();
    public sealed virtual int get_EqualsValueClause();
    public sealed virtual Nullable`1<int> get_ImplicitElementAccess();
    public sealed virtual int get_Interpolation();
    public sealed virtual int get_InterpolatedStringExpression();
    public sealed virtual int get_InterpolatedStringText();
    public sealed virtual Nullable`1<int> get_IndexerMemberCref();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeAnonymousFunctionStatic.MakeAnonymousFunctionStaticDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticHelper : object {
    public static bool IsStaticLocalFunctionSupported(LanguageVersion languageVersion);
    private static bool TryGetDataFlowAnalysis(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, DataFlowAnalysis& dataFlow);
    private static bool CanBeCalledFromStaticContext(LocalFunctionStatementSyntax localFunction, DataFlowAnalysis dataFlow);
    public static bool CanMakeLocalFunctionStaticBecauseNoCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel);
    public static bool CanMakeLocalFunctionStaticByRefactoringCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, ImmutableArray`1& captures);
    [CompilerGeneratedAttribute]
internal static bool <CanBeCalledFromStaticContext>g__IsChildOrSelf|2_1(LocalFunctionStatementSyntax containingLocalFunction, ISymbol calledLocationFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_diagnosticDescriptor;
    private static CSharpMakeStructFieldsWritableDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructMemberReadOnly.CSharpMakeStructMemberReadOnlyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeBlock(OperationBlockAnalysisContext context, NotificationOption2 notificationOption, Dictionary`2<IMethodSymbol, Diagnostic> methodToDiagnostic);
    private static ValueTuple`2<Location, Location> GetDiagnosticLocation(IMethodSymbol owningMethod, CancellationToken cancellationToken);
    private static bool BlockOperationPotentiallyMutatesThis(IMethodSymbol owningMethod, IOperation blockOperation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsPotentiallyValueType(IOperation instance);
    private static bool OperationPotentiallyMutatesThis(SemanticModel semanticModel, IMethodSymbol owningMethod, IOperation instanceOperation, CancellationToken cancellationToken);
    private static bool IsPotentiallyMutatingMethod(IMethodSymbol owningMethod, IOperation instance, IMethodSymbol methodReference);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SymbolStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private bool <InitializeWorker>g__ShouldAnalyze|2_2(SymbolStartAnalysisContext context, CodeStyleOption2`1& option);
    [CompilerGeneratedAttribute]
internal static void <InitializeWorker>g__ProcessResults|2_3(SymbolAnalysisContext context, ReportDiagnostic severity, PooledDictionary`2<IMethodSymbol, Diagnostic> methodToDiagnostic);
    [CompilerGeneratedAttribute]
internal static bool <BlockOperationPotentiallyMutatesThis>g__ReferencesThisInstance|5_0(IOperation operation, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructReadOnly.CSharpMakeStructReadOnlyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private bool IsCandidate(SymbolStartAnalysisContext context, Location& primaryLocation, Location& additionalLocation, CodeStyleOption2`1& option);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SymbolStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableOutsideMessage;
    private static DiagnosticDescriptor s_outsideDiagnosticDescriptor;
    private static LocalizableResourceString s_localizableInsideMessage;
    private static DiagnosticDescriptor s_insideDiagnosticDescriptor;
    private static MisplacedUsingDirectivesDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespaceNode(SyntaxNodeAnalysisContext context);
    private void AnalyzeCompilationUnitNode(SyntaxNodeAnalysisContext context);
    private static bool ShouldSuppressDiagnostic(CompilationUnitSyntax compilationUnit);
    private static void ReportDiagnostics(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, IEnumerable`1<UsingDirectiveSyntax> usingDirectives, CodeStyleOption2`1<AddImportPlacement> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private void ProcessArrowExpressionClause(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ArrowExpressionClauseSyntax arrowExpressionClause);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <ProcessArrowExpressionClause>g__IsOk|5_1(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessConditionalExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <ProcessConditionalExpression>g__IsOk|3_1(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ArrayBuilder`1<SyntaxNode> stack);
    private void ProcessToken(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SourceText text, SyntaxToken token);
    public static bool HasExcessBlankLinesAfter(SourceText text, SyntaxToken token, SyntaxToken& secondBrace, SyntaxTrivia& endOfLineTrivia);
    private static bool IsAllWhitespace(TextLine textLine);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveStatementPlacement.CSharpConsecutiveStatementPlacementDiagnosticAnalyzer : AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1<StatementSyntax> {
    protected virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected virtual Location GetDiagnosticLocation(SyntaxNode block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private void ProcessConstructorInitializer(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ConstructorInitializerSyntax initializer);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private bool CheckStatementSyntax(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, StatementSyntax statement);
    public static bool StatementNeedsWrapping(StatementSyntax statement);
    public static bool ContainsEndOfLineBetween(SyntaxToken previous, SyntaxToken next);
    private static bool ContainsEndOfLine(SyntaxTriviaList triviaList);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.MultipleBlankLines.CSharpMultipleBlankLinesDiagnosticAnalyzer : AbstractMultipleBlankLinesDiagnosticAnalyzer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersDiagnosticAnalyzer : AbstractOrderModifiersDiagnosticAnalyzer {
    protected virtual CodeStyleOption2`1<string> GetPreferredOrderStyle(SyntaxTreeAnalysisContext context);
    protected virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode root);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersHelper : AbstractOrderModifiersHelpers {
    public static CSharpOrderModifiersHelper Instance;
    private static CSharpOrderModifiersHelper();
    protected virtual int GetKeywordKind(string trimmed);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionDiagnosticAnalyzer : AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1<SwitchExpressionSyntax> {
    protected virtual Location GetDiagnosticLocation(SwitchExpressionSyntax switchBlock);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementDiagnosticAnalyzer : AbstractPopulateSwitchStatementDiagnosticAnalyzer`1<SwitchStatementSyntax> {
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Precedence.AbstractCSharpPrecedenceService`1 : AbstractPrecedenceService`2<TSyntax, OperatorPrecedence> {
    public sealed virtual PrecedenceKind GetPrecedenceKind(OperatorPrecedence precedence);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpExpressionPrecedenceService : AbstractCSharpPrecedenceService`1<ExpressionSyntax> {
    public static CSharpExpressionPrecedenceService Instance;
    private static CSharpExpressionPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpPatternPrecedenceService : AbstractCSharpPrecedenceService`1<PatternSyntax> {
    public static CSharpPatternPrecedenceService Instance;
    private static CSharpPatternPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessDiagnosticAnalyzer : AbstractQualifyMemberAccessDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, SimpleNameSyntax> {
    protected ISimplification Simplification { get; }
    protected virtual ISimplification get_Simplification();
    protected virtual bool IsAlreadyQualifiedMemberAccess(ExpressionSyntax node);
    protected virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyOrFieldInitialization(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    private static bool IsInFieldInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    protected virtual Location GetLocation(IOperation operation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveRedundantEquality.CSharpRemoveRedundantEqualityDiagnosticAnalyzer : AbstractRemoveRedundantEqualityDiagnosticAnalyzer {
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastDiagnosticAnalyzer : AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2<SyntaxKind, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKindsOfInterest>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected virtual bool IsUnnecessaryCast(SemanticModel model, ExpressionSyntax cast, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected virtual TextSpan GetFadeSpan(ExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeDiscardDesignation(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <AnalyzeDiscardDesignation>g__Report|3_0(DiscardDesignationSyntax discard, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer : AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1<UsingDirectiveSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> UnnecessaryImportsProvider { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<UsingDirectiveSyntax> unnecessaryImports);
    protected virtual IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> get_UnnecessaryImportsProvider();
    protected virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected virtual Nullable`1<SyntaxToken> TryGetLastToken(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer/<GetFixableDiagnosticSpans>d__8")]
protected virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, INamedTypeSymbol conditionalAttributeType);
    private static bool OverloadsChanged(SemanticModel semanticModel1, SyntaxNode node1, SemanticModel semanticModel2, SyntaxNode node2, CancellationToken cancellationToken);
    private static bool IsIdentityOrImplicitConversion(Compilation compilation, ITypeSymbol type1, ITypeSymbol type2);
    private static bool MayHaveSideEffects(ExpressionSyntax expression);
    private static SeparatedSyntaxList`1<ParameterSyntax> GetParameters(AnonymousFunctionExpressionSyntax expression);
    public static bool TryGetAnonymousFunctionInvocation(AnonymousFunctionExpressionSyntax anonymousFunction, InvocationExpressionSyntax& invocation, Boolean& wasAwaited);
    private static bool TryGetInvocation(ExpressionSyntax expression, InvocationExpressionSyntax& invocation, Boolean& wasAwaited);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryExpressionParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedExpressionSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryPatternParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedPatternSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedPatternSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedPatternSyntax parenthesizedPattern, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
protected virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer {
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual string get_CompilerErrorCodePrefix();
    protected virtual int get_CompilerErrorCodeDigitCount();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    protected virtual bool ContainsPragmaDirective(SyntaxNode root);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    private static string CS0162;
    public static string IsSubsequentSection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_subsequentSectionProperties;
    private static CSharpRemoveUnreachableCodeDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    public static StatementSyntax TryGetContainingStatement(SyntaxNode node);
    private void ProcessUnreachableDiagnostic(SemanticModelAnalysisContext context, SyntaxNode root, TextSpan sourceSpan);
}
internal static class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.RemoveUnreachableCodeHelpers : object {
    [NullableContextAttribute("1")]
public static ImmutableArray`1<ImmutableArray`1<StatementSyntax>> GetSubsequentUnreachableSections(StatementSyntax firstUnreachableStatement);
    private static void AddIfNonEmpty(ArrayBuilder`1<ImmutableArray`1<StatementSyntax>> sections, ImmutableArray`1<StatementSyntax> lastSection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersDiagnosticAnalyzer : AbstractRemoveUnusedMembersDiagnosticAnalyzer`4<DocumentationCommentTriviaSyntax, IdentifierNameSyntax, TypeDeclarationSyntax, MemberDeclarationSyntax> {
    protected virtual IEnumerable`1<TypeDeclarationSyntax> GetTypeDeclarations(INamedTypeSymbol namedType, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMembers(TypeDeclarationSyntax typeDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool SupportsDiscard(SyntaxTree tree);
    protected virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected virtual bool ReturnsThrow(SyntaxNode node);
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueExpressionStatementOption(AnalyzerOptionsProvider provider);
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueAssignmentOption(AnalyzerOptionsProvider provider);
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatementOperation);
    protected virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Extensions.LanguageVersionExtensions : object {
    internal static LanguageVersion CSharpNext;
    [ExtensionAttribute]
public static bool IsCSharp12OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool IsCSharp11OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool HasConstantInterpolatedStrings(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool SupportsCollectionExpressions(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool SupportsPrimaryConstructors(LanguageVersion languageVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameSimplifier : object {
    internal static bool CanSimplifyTupleElementName(ArgumentSyntax node, CSharpParseOptions parseOptions);
    internal static bool CanSimplifyAnonymousTypeMemberName(AnonymousObjectMemberDeclaratorSyntax node);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<ArgumentSyntax> arguments, ArgumentSyntax toRemove);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, AnonymousObjectMemberDeclaratorSyntax toRemove);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplification : AbstractSimplification {
    public static CSharpSimplification Instance;
    public SimplifierOptions DefaultOptions { get; }
    private static CSharpSimplification();
    public virtual SimplifierOptions get_DefaultOptions();
    public virtual SimplifierOptions GetSimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplifierOptions : SimplifierOptions {
    private static CodeStyleOption2`1<PreferBracesPreference> s_defaultPreferBraces;
    public static CSharpSimplifierOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarForBuiltInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarWhenTypeIsApparent>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <VarElsewhere>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimpleDefaultExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferParameterNullChecking>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowEmbeddedStatementsOnSameLine>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<PreferBracesPreference> <PreferBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferThrowExpression>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarWhenTypeIsApparent { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> VarElsewhere { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimpleDefaultExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferParameterNullChecking { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowEmbeddedStatementsOnSameLine { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<PreferBracesPreference> PreferBraces { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferThrowExpression { get; public set; }
    public CSharpSimplifierOptions(IOptionsReader options, CSharpSimplifierOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private CSharpSimplifierOptions(CSharpSimplifierOptions original);
    private static CSharpSimplifierOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarForBuiltInTypes(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarWhenTypeIsApparent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarWhenTypeIsApparent(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_VarElsewhere();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VarElsewhere(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimpleDefaultExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimpleDefaultExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferParameterNullChecking();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferParameterNullChecking(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowEmbeddedStatementsOnSameLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowEmbeddedStatementsOnSameLine(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<PreferBracesPreference> get_PreferBraces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferBraces(CodeStyleOption2`1<PreferBracesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferThrowExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferThrowExpression(CodeStyleOption2`1<bool> value);
    public UseVarPreference GetUseVarPreference();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CSharpSimplifierOptions left, CSharpSimplifierOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CSharpSimplifierOptions left, CSharpSimplifierOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SimplifierOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CSharpSimplifierOptions other);
    [CompilerGeneratedAttribute]
public virtual SimplifierOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.CastSimplifier : object {
    public static bool IsUnnecessaryCast(ExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryAsCast(BinaryExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryCast(CastExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsEnumCastWithZeroCompare(CastExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsRemovableBitwiseEnumNegation(CastExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, CancellationToken cancellationToken);
    private static bool CastRemovalCouldCauseSignExtensionWarning(ExpressionSyntax castSyntax, IConversionOperation conversionOperation);
    private static bool IsDelegateCreationCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, IDelegateCreationOperation originalDelegateCreationOperation, CancellationToken cancellationToken);
    private static bool IsConversionCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, IConversionOperation originalConversionOperation, CancellationToken cancellationToken);
    private static bool IsCollectionExpressionCastThatMustBePreserved(ExpressionSyntax castNode, SemanticModel originalSemanticModel, ITypeSymbol originalConvertedType, CancellationToken cancellationToken);
    private static bool IsIdentityStructCastThatMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsMultipleImplicitNullableConversion(IConversionOperation originalConversionOperation);
    private static bool IsRemovableWideningSignedBitwiseNegation(ExpressionSyntax castNode, IConversionOperation originalConversionOperation, ExpressionSyntax rewrittenExpression, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsSignedIntegralOrIntPtrType(ITypeSymbol type);
    private static bool IsConditionalCastSafeToRemove(ExpressionSyntax castNode, SemanticModel originalSemanticModel, ExpressionSyntax rewrittenExpression, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsNullOrErrorType(TypeInfo info);
    [NullableContextAttribute("2")]
private static bool IsNullOrErrorType(ITypeSymbol type);
    private static bool CastRemovalWouldCauseUnintendedReferenceComparisonWarning(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ConvertedHasUserDefinedEquals(BinaryOperatorKind operatorKind, IOperation operation);
    private static bool IsConstantNull(IOperation operation);
    private static bool IsExplicitCast(SyntaxNode node);
    private static bool IsExplicitCastThatMustBePreserved(SemanticModel semanticModel, ExpressionSyntax castOrAsNode, Conversion conversion, CancellationToken cancellationToken);
    private static bool IsIdentityFloatingPointCastThatMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsFloatingPointType(ITypeSymbol type);
    private static bool IsFieldOrArrayElement(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool IntroducedConditionalExpressionConversion(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IntroducedAmbiguity(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool ChangedOverloadResolution(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool ChangedForEachResolution(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel);
    private static bool IsComplementaryMemberAccessAfterCastRemoval(MemberAccessExpressionSyntax memberAccessExpression, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsComplementaryInvocationAfterCastRemoval(InvocationExpressionSyntax memberAccessExpression, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, CancellationToken cancellationToken);
    private static bool IsComplementaryDelegateInvoke(ISymbol originalMemberSymbol, ISymbol rewrittenMemberSymbol);
    private static bool IsIntrinsicOrEnum(ITypeSymbol rewrittenType);
    private static bool IsCopy(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol rewrittenType, CancellationToken cancellationToken);
    private static bool ParameterNamesAndDefaultValuesAndReturnTypesMatch(MemberAccessExpressionSyntax memberAccessExpression, SemanticModel semanticModel, ISymbol originalMemberSymbol, ISymbol rewrittenMemberSymbol, CancellationToken cancellationToken);
    private static ValueTuple`2<ITypeSymbol, Conversion> GetRewrittenInfo(ExpressionSyntax castNode, ExpressionSyntax rewrittenExpression, SemanticModel originalSemanticModel, SemanticModel rewrittenSemanticModel, Conversion originalConversion, ITypeSymbol originalConvertedType, CancellationToken cancellationToken);
    private static ValueTuple`2<SemanticModel, ExpressionSyntax> GetSemanticModelWithCastRemoved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel originalSemanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsEnumCastWithZeroCompare>g__IsConstantZero|3_0(ExpressionSyntax child, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyBooleanExpression.CSharpSimplifyConditionalDiagnosticAnalyzer : AbstractSimplifyConditionalDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CommonConversion GetConversion(SemanticModel semanticModel, ExpressionSyntax node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationDiagnosticAnalyzer : AbstractSimplifyInterpolationDiagnosticAnalyzer`2<InterpolationSyntax, ExpressionSyntax> {
    protected virtual IVirtualCharService GetVirtualCharService();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionDiagnosticAnalyzer : AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2<InvocationExpressionSyntax, MemberAccessExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.CSharpSimplifyPropertyPatternDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSubpattern(SyntaxNodeAnalysisContext syntaxContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.SimplifyPropertyPatternHelpers : object {
    public static bool IsSimplifiable(SubpatternSyntax subpattern, SubpatternSyntax& innerSubpattern, BaseExpressionColonSyntax& outerExpressionColon);
    public static bool IsMergable(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.TopLevelStatements.ConvertToProgramMainDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessCompilationUnit(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.TopLevelStatements.ConvertToTopLevelStatementsDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessCompilationUnit(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyAnalyzer : AbstractUseAutoPropertyAnalyzer`7<SyntaxKind, PropertyDeclarationSyntax, ConstructorDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax, IdentifierNameSyntax> {
    protected SyntaxKind PropertyDeclarationKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual SyntaxKind get_PropertyDeclarationKind();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected virtual ExpressionSyntax GetFieldInitializer(VariableDeclaratorSyntax variable, CancellationToken cancellationToken);
    protected virtual void RegisterIneligibleFieldsAction(HashSet`1<string> fieldNames, ConcurrentSet`1<IFieldSymbol> ineligibleFields, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    private static void AddIneligibleFieldsIfAccessedOffNotDefinitelyAssignedValue(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, ConcurrentSet`1<IFieldSymbol> ineligibleFields, CancellationToken cancellationToken);
    private static void AddIneligibleFields(ConcurrentSet`1<IFieldSymbol> ineligibleFields, SymbolInfo symbolInfo);
    private static bool CheckExpressionSyntactically(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    private static ExpressionSyntax GetGetterExpressionFromSymbol(IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static T GetSingleStatementFromAccessor(AccessorDeclarationSyntax accessorDeclaration);
    protected virtual ExpressionSyntax GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ExpressionSyntax GetExpressionFromSetter(AccessorDeclarationSyntax setAccessor);
    protected virtual SyntaxNode GetFieldNode(FieldDeclarationSyntax fieldDeclaration, VariableDeclaratorSyntax variableDeclarator);
    [CompilerGeneratedAttribute]
internal static bool <RegisterIneligibleFieldsAction>g__CouldReferenceField|8_0(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static void <RegisterIneligibleFieldsAction>g__AddIneligibleFieldsForExpression|8_1(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddIneligibleFields>g__AddIneligibleField|10_0(ISymbol symbol, <>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, MemberAccessExpressionSyntax, PrefixUnaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.UseCoalesceExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> ChangesSemantics;
    protected DiagnosticDescriptor UnnecessaryCodeDescriptor;
    protected AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild);
    private static AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer();
    private static DiagnosticDescriptor CreateDescriptor(string diagnosticId, EnforceOnBuild enforceOnBuild, bool isUnnecessary);
    protected abstract virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    protected virtual bool IsSupported(Compilation compilation);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext context);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CollectionExpressionMatch`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TMatchNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSpread>k__BackingField;
    [NullableAttribute("1")]
public TMatchNode Node { get; public set; }
    public bool UseSpread { get; public set; }
    [NullableContextAttribute("1")]
public CollectionExpressionMatch`1(TMatchNode Node, bool UseSpread);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TMatchNode get_Node();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Node(TMatchNode value);
    [CompilerGeneratedAttribute]
public bool get_UseSpread();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSpread(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CollectionExpressionMatch`1<TMatchNode> left, CollectionExpressionMatch`1<TMatchNode> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CollectionExpressionMatch`1<TMatchNode> left, CollectionExpressionMatch`1<TMatchNode> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CollectionExpressionMatch`1<TMatchNode> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(TMatchNode& Node, Boolean& UseSpread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeArrayCreationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, ArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, ImplicitArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
    [NullableContextAttribute("2")]
private void AnalyzeArrayInitializerExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private void ReportArrayCreationDiagnostics(SyntaxNodeAnalysisContext context, SyntaxTree syntaxTree, NotificationOption2 notification, ExpressionSyntax expression, bool changesSemantics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    private static string CreateBuilderName;
    private static string GetInstanceName;
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static Nullable`1<AnalysisResult> AnalyzeInvocation(SemanticModel semanticModel, InvocationExpressionSyntax invocationExpression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <AnalyzeInvocationExpression>g__FadeOutCode|4_0(SyntaxNodeAnalysisContext context, AnalysisResult analysisResult, ImmutableArray`1<Location> locations, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static InvocationExpressionSyntax <AnalyzeInvocation>g__TryFindCreationExpression|5_0(SyntaxToken identifier, StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    public static string UnwrapArgument;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_unwrapArgumentProperties;
    private static CSharpUseCollectionExpressionForCreateDiagnosticAnalyzer();
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeMemberAccess(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    private static string ToPrefix;
    private static string AsSpanName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_suffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableHashSet`1<string> s_bannedTypes;
    private static CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer();
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeMemberAccess(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static Nullable`1<AnalysisResult> AnalyzeInvocation(SourceText text, UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, InvocationExpressionSyntax invocation, INamedTypeSymbol expressionType, bool allowSemanticsChange, bool addMatches, CancellationToken cancellationToken);
    private static bool AnalyzeInvocation(SourceText text, UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, InvocationExpressionSyntax invocation, ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, InitializerExpressionSyntax& existingInitializer, CancellationToken cancellationToken);
    private static void AddArgumentsInReverse(ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, SeparatedSyntaxList`1<ArgumentSyntax> arguments, bool useSpread);
    private static bool IsMatch(UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, MemberAccessExpressionSyntax memberAccess, InvocationExpressionSyntax invocation, bool allowLinq, ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, Boolean& isAdditionMatch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeInvocation>g__AddFinalMatch|8_0(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsListLike|8_1(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsIterable|8_2(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__Implements|8_3(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsLegalInitializer|8_4(InitializerExpressionSyntax initializer);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__IsMatchWorker|10_0(Boolean& isAdditionMatch, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__IsAnyNameMatch|10_1(string name);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__HasAnySuffix|10_2(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    protected virtual bool IsSupported(Compilation compilation);
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeImplicitStackAllocExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeExplicitStackAllocExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, StackAllocArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.UseCollectionExpressionHelpers : object {
    private static CollectionExpressionSyntax s_emptyCollectionExpression;
    private static SymbolEquivalenceComparer s_tupleNamesCanDifferComparer;
    private static UseCollectionExpressionHelpers();
    public static bool CanReplaceWithCollectionExpression(SemanticModel semanticModel, ExpressionSyntax expression, INamedTypeSymbol expressionType, bool isSingletonInstance, bool allowSemanticsChange, bool skipVerificationForReplacedNode, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static bool CanReplaceWithCollectionExpression(SemanticModel semanticModel, ExpressionSyntax expression, CollectionExpressionSyntax replacementExpression, INamedTypeSymbol expressionType, bool isSingletonInstance, bool allowSemanticsChange, bool skipVerificationForReplacedNode, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static bool IsWellKnownCollectionInterface(ITypeSymbol type);
    public static bool IsWellKnownCollectionReadOnlyInterface(ITypeSymbol type);
    public static bool IsWellKnownCollectionReadWriteInterface(ITypeSymbol type);
    public static bool IsConstructibleCollectionType(Compilation compilation, ITypeSymbol type);
    private static bool IsSafeConversionOfArrayToSpanType(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool IsInTargetTypedLocation(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    public static CollectionExpressionSyntax ConvertInitializerToCollectionExpression(InitializerExpressionSyntax initializer, bool wasOnSingleLine);
    public static CollectionExpressionSyntax ReplaceWithCollectionExpression(SourceText sourceText, InitializerExpressionSyntax originalInitializer, CollectionExpressionSyntax newCollectionExpression, bool newCollectionIsSingleLine);
    private static bool ShouldReplaceExistingExpressionEntirely(SourceText sourceText, InitializerExpressionSyntax initializer, bool newCollectionIsSingleLine);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, TArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool isSingletonInstance, bool allowSemanticsChange, Func`2<TArrayCreationExpressionSyntax, TypeSyntax> getType, Func`2<TArrayCreationExpressionSyntax, InitializerExpressionSyntax> getInitializer, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static bool IsCollectionFactoryCreate(SemanticModel semanticModel, InvocationExpressionSyntax invocationExpression, MemberAccessExpressionSyntax& memberAccess, Boolean& unwrapArgument, CancellationToken cancellationToken);
    public static bool IsCollectionEmptyAccess(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    public static SeparatedSyntaxList`1<ArgumentSyntax> GetArguments(InvocationExpressionSyntax invocationExpression, bool unwrapArgument);
    [CompilerGeneratedAttribute]
internal static bool <CanReplaceWithCollectionExpression>g__IsSafeConversionWhenTypesDoNotMatch|3_1(Boolean& changesSemantics, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static IMethodSymbol <IsConstructibleCollectionType>g__GetAccessibleInstanceConstructor|7_1(ImmutableArray`1<IMethodSymbol> constructors, Func`2<IMethodSymbol, bool> predicate, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__HasType|9_0(ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedEqualsValueClause|9_1(EqualsValueClauseSyntax equalsValue);
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedCastExpression|9_2(CastExpressionSyntax castExpression);
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedConditionalExpression|9_3(ConditionalExpressionSyntax conditionalExpression, ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedLambdaExpression|9_4(LambdaExpressionSyntax lambda, ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedSwitchExpressionArm|9_5(SwitchExpressionArmSyntax switchExpressionArm, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedCollectionElement|9_6(CollectionElementSyntax collectionElement, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedInitializerExpression|9_7(InitializerExpressionSyntax initializerExpression, ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedAssignmentExpression|9_8(AssignmentExpressionSyntax assignmentExpression, ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedBinaryExpression|9_9(BinaryExpressionSyntax binaryExpression, ExpressionSyntax expression, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionFactoryCreate>g__IsCompatibleSignatureAndArguments|14_1(IMethodSymbol originalCreateMethod, Boolean& unwrapArgument, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsEmptyProperty|15_0(MemberAccessExpressionSyntax memberAccess, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsEmptyMethodCall|15_1(InvocationExpressionSyntax invocation, MemberAccessExpressionSyntax memberAccess, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsPossiblyDottedGenericName|15_2(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsPossiblyDottedName|15_3(ExpressionSyntax name);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpObjectCreationHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUpdateExpressionSyntaxHelper : object {
    public static CSharpUpdateExpressionSyntaxHelper Instance;
    private static CSharpUpdateExpressionSyntaxHelper();
    public sealed virtual void GetPartsOfForeachStatement(StatementSyntax statement, SyntaxToken& awaitKeyword, SyntaxToken& identifier, ExpressionSyntax& expression, IEnumerable`1& statements);
    public sealed virtual void GetPartsOfIfStatement(StatementSyntax statement, ExpressionSyntax& condition, IEnumerable`1& whenTrueStatements, IEnumerable`1& whenFalseStatements);
    private static IEnumerable`1<StatementSyntax> ExtractEmbeddedStatements(StatementSyntax embeddedStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerAnalyzer : AbstractUseCollectionInitializerAnalyzer`9<ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    protected IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> SyntaxHelper { get; }
    protected virtual IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> get_SyntaxHelper();
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
    protected virtual bool IsComplexElementInitializer(SyntaxNode expression);
    protected virtual bool HasExistingInvalidInitializerForCollection();
    protected virtual bool ValidateMatchesForCollectionExpression(ArrayBuilder`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerDiagnosticAnalyzer : AbstractUseCollectionInitializerDiagnosticAnalyzer`10<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CSharpUseCollectionInitializerAnalyzer GetAnalyzer();
    protected virtual bool AreCollectionInitializersSupported(Compilation compilation);
    protected virtual bool AreCollectionExpressionsSupported(Compilation compilation);
    protected virtual bool CanUseCollectionExpression(SemanticModel semanticModel, BaseObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentDiagnosticAnalyzer : AbstractUseCompoundAssignmentDiagnosticAnalyzer`3<SyntaxKind, AssignmentExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual SyntaxKind GetAnalysisKind();
    protected virtual bool IsSupported(SyntaxKind assignmentKind, ParseOptions options);
    protected virtual int TryGetIncrementOrDecrement(SyntaxKind opKind, object constantValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCoalesceExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("2")]
public static bool GetWhenTrueAssignment(IfStatementSyntax ifStatement, StatementSyntax& whenTrue, AssignmentExpressionSyntax& assignment);
    private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private bool IsReferenceEqualsNullCheck(SemanticModel semanticModel, ExpressionSyntax condition, CancellationToken cancellationToken, ExpressionSyntax& testedExpression);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.Utilities : object {
    public static ImmutableArray`1<ValueTuple`3<SyntaxKind, SyntaxKind, SyntaxKind>> Kinds;
    private static Utilities();
    private static SyntaxKind FindOperatorToken(SyntaxKind assignmentExpressionKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentDiagnosticAnalyzer : AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnDiagnosticAnalyzer : AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsStatementSupported(IOperation statement);
    private static bool IsWrappedByCheckedOrUnsafe(IOperation statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context, VariableDeclarationSyntax variableDeclaration, NotificationOption2 notificationOption);
    private void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context, ForEachStatementSyntax forEachStatement, NotificationOption2 notificationOption);
    public static bool TryAnalyzeVariableDeclaration(SemanticModel semanticModel, VariableDeclarationSyntax variableDeclaration, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    public static bool TryAnalyzeForEachStatement(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool TryAnalyze(SemanticModel semanticModel, ILocalSymbol local, TypeSyntax typeNode, SyntaxToken identifier, Conversion conversion, SyntaxNode searchScope, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool AnyTupleFieldNamesCollideWithExistingNames(SemanticModel semanticModel, INamedTypeSymbol tupleType, SyntaxNode container, CancellationToken cancellationToken);
    private static bool IsViableTupleTypeSyntax(TypeSyntax type);
    private static bool OnlyUsedToAccessTupleFields(SemanticModel semanticModel, SyntaxNode searchScope, ILocalSymbol local, ArrayBuilder`1<MemberAccessExpressionSyntax> memberAccessLocations, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string FixesError;
    [NullableAttribute("0")]
private ImmutableArray`1<SyntaxKind> _syntaxKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    private static UseExpressionBodyDiagnosticAnalyzer();
    private static ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, IOption2>> GetSupportedDescriptorsWithOptions();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeSyntax(CSharpCodeGenerationOptions options, SyntaxNode declaration, SyntaxNodeAnalysisContext context, UseExpressionBodyHelper helper, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForAccessorsHelper : UseExpressionBodyHelper`1<AccessorDeclarationSyntax> {
    public static UseExpressionBodyForAccessorsHelper Instance;
    private static UseExpressionBodyForAccessorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(AccessorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(AccessorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(AccessorDeclarationSyntax declaration);
    protected virtual AccessorDeclarationSyntax WithSemicolonToken(AccessorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual AccessorDeclarationSyntax WithBody(AccessorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, AccessorDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConstructorsHelper : UseExpressionBodyHelper`1<ConstructorDeclarationSyntax> {
    public static UseExpressionBodyForConstructorsHelper Instance;
    private static UseExpressionBodyForConstructorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(ConstructorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConstructorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConstructorDeclarationSyntax declaration);
    protected virtual ConstructorDeclarationSyntax WithSemicolonToken(ConstructorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConstructorDeclarationSyntax WithBody(ConstructorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConstructorDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConversionOperatorsHelper : UseExpressionBodyHelper`1<ConversionOperatorDeclarationSyntax> {
    public static UseExpressionBodyForConversionOperatorsHelper Instance;
    private static UseExpressionBodyForConversionOperatorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ConversionOperatorDeclarationSyntax WithSemicolonToken(ConversionOperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConversionOperatorDeclarationSyntax WithExpressionBody(ConversionOperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConversionOperatorDeclarationSyntax WithBody(ConversionOperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConversionOperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForIndexersHelper : UseExpressionBodyHelper`1<IndexerDeclarationSyntax> {
    public static UseExpressionBodyForIndexersHelper Instance;
    private static UseExpressionBodyForIndexersHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(IndexerDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(IndexerDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(IndexerDeclarationSyntax declaration);
    protected virtual IndexerDeclarationSyntax WithSemicolonToken(IndexerDeclarationSyntax declaration, SyntaxToken token);
    protected virtual IndexerDeclarationSyntax WithExpressionBody(IndexerDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual IndexerDeclarationSyntax WithAccessorList(IndexerDeclarationSyntax declaration, AccessorListSyntax accessorList);
    protected virtual IndexerDeclarationSyntax WithBody(IndexerDeclarationSyntax declaration, BlockSyntax body);
    protected virtual IndexerDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(IndexerDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(IndexerDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForLocalFunctionHelper : UseExpressionBodyHelper`1<LocalFunctionStatementSyntax> {
    public static UseExpressionBodyForLocalFunctionHelper Instance;
    private static UseExpressionBodyForLocalFunctionHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(LocalFunctionStatementSyntax statement);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(LocalFunctionStatementSyntax statement);
    protected virtual SyntaxToken GetSemicolonToken(LocalFunctionStatementSyntax statement);
    protected virtual LocalFunctionStatementSyntax WithSemicolonToken(LocalFunctionStatementSyntax statement, SyntaxToken token);
    protected virtual LocalFunctionStatementSyntax WithExpressionBody(LocalFunctionStatementSyntax statement, ArrowExpressionClauseSyntax expressionBody);
    protected virtual LocalFunctionStatementSyntax WithBody(LocalFunctionStatementSyntax statement, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, LocalFunctionStatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForMethodsHelper : UseExpressionBodyHelper`1<MethodDeclarationSyntax> {
    public static UseExpressionBodyForMethodsHelper Instance;
    private static UseExpressionBodyForMethodsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(MethodDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(MethodDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(MethodDeclarationSyntax declaration);
    protected virtual MethodDeclarationSyntax WithSemicolonToken(MethodDeclarationSyntax declaration, SyntaxToken token);
    protected virtual MethodDeclarationSyntax WithExpressionBody(MethodDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual MethodDeclarationSyntax WithBody(MethodDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, MethodDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForOperatorsHelper : UseExpressionBodyHelper`1<OperatorDeclarationSyntax> {
    public static UseExpressionBodyForOperatorsHelper Instance;
    private static UseExpressionBodyForOperatorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(OperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(OperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(OperatorDeclarationSyntax declaration);
    protected virtual OperatorDeclarationSyntax WithSemicolonToken(OperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual OperatorDeclarationSyntax WithExpressionBody(OperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual OperatorDeclarationSyntax WithBody(OperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, OperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForPropertiesHelper : UseExpressionBodyHelper`1<PropertyDeclarationSyntax> {
    public static UseExpressionBodyForPropertiesHelper Instance;
    private static UseExpressionBodyForPropertiesHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(PropertyDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(PropertyDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(PropertyDeclarationSyntax declaration);
    protected virtual PropertyDeclarationSyntax WithSemicolonToken(PropertyDeclarationSyntax declaration, SyntaxToken token);
    protected virtual PropertyDeclarationSyntax WithExpressionBody(PropertyDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual PropertyDeclarationSyntax WithAccessorList(PropertyDeclarationSyntax declaration, AccessorListSyntax accessorListSyntax);
    protected virtual PropertyDeclarationSyntax WithBody(PropertyDeclarationSyntax declaration, BlockSyntax body);
    protected virtual PropertyDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(PropertyDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(PropertyDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<UseExpressionBodyHelper> Helpers;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    private static UseExpressionBodyHelper();
    public abstract virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    public abstract virtual LocalizableString get_UseExpressionBodyTitle();
    public abstract virtual LocalizableString get_UseBlockBodyTitle();
    public abstract virtual string get_DiagnosticId();
    public abstract virtual EnforceOnBuild get_EnforceOnBuild();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    public abstract virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    public abstract virtual BlockSyntax GetBody(SyntaxNode declaration);
    public abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public abstract virtual bool IsRelevantDeclarationNode(SyntaxNode node);
    public abstract virtual bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, CancellationToken cancellationToken);
    public abstract virtual bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public abstract virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody, CancellationToken cancellationToken);
    public abstract virtual Location GetDiagnosticLocation(SyntaxNode declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper`1 : UseExpressionBodyHelper {
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseExpressionBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseBlockBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private EnforceOnBuild <EnforceOnBuild>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKinds>k__BackingField;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    protected UseExpressionBodyHelper`1(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString useExpressionBodyTitle, LocalizableString useBlockBodyTitle, Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> option, ImmutableArray`1<SyntaxKind> syntaxKinds);
    [CompilerGeneratedAttribute]
public virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseExpressionBodyTitle();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseBlockBodyTitle();
    [CompilerGeneratedAttribute]
public virtual string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public virtual EnforceOnBuild get_EnforceOnBuild();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    [NullableContextAttribute("2")]
protected static AccessorDeclarationSyntax GetSingleGetAccessor(AccessorListSyntax accessorList);
    protected static BlockSyntax GetBodyFromSingleGetAccessor(AccessorListSyntax accessorList);
    public virtual BlockSyntax GetBody(SyntaxNode declaration);
    public virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public virtual bool IsRelevantDeclarationNode(SyntaxNode node);
    public virtual bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, CancellationToken cancellationToken);
    public virtual bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public sealed virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody, CancellationToken cancellationToken);
    public virtual Location GetDiagnosticLocation(SyntaxNode declaration);
    protected virtual Location GetDiagnosticLocation(TDeclaration declaration);
    public bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, TDeclaration declaration, bool forAnalyzer, CancellationToken cancellationToken);
    protected virtual bool TryConvertToExpressionBody(TDeclaration declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    private bool TryConvertToExpressionBodyWorker(SyntaxNode declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    protected bool TryConvertToExpressionBodyForBaseProperty(BasePropertyDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    public bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, TDeclaration declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public TDeclaration Update(SemanticModel semanticModel, TDeclaration declaration, bool useExpressionBody, CancellationToken cancellationToken);
    protected abstract virtual BlockSyntax GetBody(TDeclaration declaration);
    protected abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(TDeclaration declaration);
    protected abstract virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, TDeclaration declaration);
    protected abstract virtual SyntaxToken GetSemicolonToken(TDeclaration declaration);
    protected abstract virtual TDeclaration WithSemicolonToken(TDeclaration declaration, SyntaxToken token);
    protected abstract virtual TDeclaration WithExpressionBody(TDeclaration declaration, ArrowExpressionClauseSyntax expressionBody);
    protected abstract virtual TDeclaration WithBody(TDeclaration declaration, BlockSyntax body);
    protected virtual TDeclaration WithGenerateBody(SemanticModel semanticModel, TDeclaration declaration);
    protected TDeclaration WithAccessorList(SemanticModel semanticModel, TDeclaration declaration);
    protected virtual TDeclaration WithAccessorList(TDeclaration declaration, AccessorListSyntax accessorListSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_useExpressionBodyForLambda;
    private static DiagnosticDescriptor s_useBlockBodyForLambda;
    private static UseExpressionBodyForLambdaDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeIfEnabled(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSyntax(SyntaxNodeAnalysisContext context, CodeStyleOption2`1<ExpressionBodyPreference> option);
    private static Diagnostic AnalyzeSyntax(SemanticModel semanticModel, CodeStyleOption2`1<ExpressionBodyPreference> option, LambdaExpressionSyntax declaration, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
    private static Location GetDiagnosticLocation(LambdaExpressionSyntax declaration);
    private static DiagnosticDescriptor CreateDescriptorWithId(LocalizableString title, LocalizableString message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaHelpers : object {
    internal static LocalizableString UseExpressionBodyTitle;
    internal static LocalizableString UseBlockBodyTitle;
    private static UseExpressionBodyForLambdaHelpers();
    internal static bool CanOfferUseBlockBody(SemanticModel semanticModel, ExpressionBodyPreference preference, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
    internal static bool CanOfferUseExpressionBody(ExpressionBodyPreference preference, LambdaExpressionSyntax declaration, LanguageVersion languageVersion, CancellationToken cancellationToken);
    internal static ExpressionSyntax GetBodyAsExpression(LambdaExpressionSyntax declaration);
    internal static CodeStyleOption2`1<ExpressionBodyPreference> GetCodeStyleOption(AnalyzerOptionsProvider provider);
    internal static ReportDiagnostic GetOptionSeverity(CodeStyleOption2`1<ExpressionBodyPreference> optionValue);
    internal static bool TryConvertToExpressionBody(LambdaExpressionSyntax declaration, LanguageVersion languageVersion, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ExpressionSyntax& expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public static bool Analyze(SemanticModel semanticModel, CSharpSimplifierOptions simplifierOptions, ObjectCreationExpressionSyntax objectCreation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzePropertyReference(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzeArrayElementReference(OperationAnalysisContext context, InfoCache infoCache, IPropertySymbol arrayLengthProperty);
    [NullableContextAttribute("2")]
private void AnalyzeInvokedMember(OperationAnalysisContext context, InfoCache infoCache, IOperation instance, IMethodSymbol targetMethod, IOperation argumentValue, IPropertySymbol lengthLikeProperty, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IPropertySymbol TryGetLengthLikeProperty(InfoCache infoCache, IMethodSymbol targetMethod);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ComputedRange;
    public static string ConstantRange;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    public static Nullable`1<Result> AnalyzeInvocation(IInvocationOperation invocation, InfoCache infoCache);
    private static Nullable`1<Result> AnalyzeOneArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax);
    private static Nullable`1<Result> AnalyzeTwoArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax);
    private static Nullable`1<Result> AnalyzeTwoArgumentSubtractionInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, IMethodSymbol targetMethod);
    private static Nullable`1<Result> AnalyzeTwoArgumentFromStartOrToEndInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, IMethodSymbol targetMethod);
    private static bool IsValidIndexing(IInvocationOperation invocation, InfoCache infoCache, IMethodSymbol targetMethod);
    private Diagnostic CreateDiagnostic(Result result, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions);
    private static bool IsConstantInt32(IOperation operation, Nullable`1<int> value);
    private static bool IsWriteableIndexer(IInvocationOperation invocation, IPropertySymbol indexer);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers : object {
    public static IPropertySymbol TryGetLengthOrCountProperty(ITypeSymbol namedType);
    public static IPropertySymbol TryGetNoArgInt32Property(ITypeSymbol type, string name);
    public static bool IsPublicInstance(ISymbol symbol);
    public static bool IsInstanceLengthCheck(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation operation);
    public static bool IsSubtraction(IOperation operation, IBinaryOperation& subtraction);
    public static bool IsIntIndexingMethod(IMethodSymbol method);
    public static bool IsTwoArgumentSliceLikeMethod(IMethodSymbol method);
    public static bool IsOneArgumentSliceLikeMethod(IMethodSymbol method);
    private static bool IsSliceFirstParameter(IParameterSymbol parameter);
    private static bool IsSliceSecondParameter(IParameterSymbol parameter);
    public static IPropertySymbol GetIndexer(ITypeSymbol type, ITypeSymbol parameterType, ITypeSymbol returnType);
    public static IMethodSymbol GetOverload(IMethodSymbol method, ITypeSymbol parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo : ValueType {
    public IPropertySymbol LengthLikeProperty;
    [NullableAttribute("2")]
public IMethodSymbol OverloadedMethodOpt;
    public MemberInfo(IPropertySymbol lengthLikeProperty, IMethodSymbol overloadedMethodOpt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameDiagnosticAnalyzer : AbstractUseInferredMemberNameDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    protected virtual void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NameColonSyntax nameColon, SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NameEqualsSyntax nameEquals, SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_NegatedProperties;
    private static CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool IsObjectCastAndNullCheck(SemanticModel semanticModel, ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_1(SyntaxNodeAnalysisContext n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer : AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual bool IsLanguageVersionSupported(Compilation compilation);
    protected virtual bool IsUnconstrainedGenericSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseNullCheckOverTypeCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private bool ShouldAnalyze(OperationAnalysisContext context, NotificationOption2& notificationOption);
    private void AnalyzeNegatedPatternOperation(OperationAnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeIsTypeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_2(OperationAnalysisContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext, INamedTypeSymbol expressionType);
    private static bool CheckForPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForSimpleLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceAnonymousWithLocalFunction(SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISymbol local, BlockSyntax block, AnonymousFunctionExpressionSyntax anonymousFunction, ImmutableArray`1& referenceLocations, CancellationToken cancellationToken);
    private static bool CheckForCastedLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForLocalDeclarationAndAssignment(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceDelegateWithLocalFunction(INamedTypeSymbol delegateType, LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <SyntaxNodeAction>g__IsInAnalysisSpan|2_1(SyntaxNodeAnalysisContext context, LocalDeclarationStatementSyntax localDeclaration, StatementSyntax anonymousFunctionStatement, bool shouldReportOnAnonymousFunctionStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseNameofInAttribute.CSharpUseNameofInAttributeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string NameKey;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAttribute(SyntaxNodeAnalysisContext context);
    private static bool MatchesParameterOnContainer(AttributeSyntax attribute, string stringValue);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationDiagnosticAnalyzer : AbstractUseNullPropagationDiagnosticAnalyzer`11<SyntaxKind, ExpressionSyntax, StatementSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax, MemberAccessExpressionSyntax, IfStatementSyntax, ExpressionStatementSyntax> {
    protected SyntaxKind IfStatementSyntaxKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual SyntaxKind get_IfStatementSyntaxKind();
    protected virtual bool ShouldAnalyze(Compilation compilation);
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, ExpressionSyntax conditionNode, ExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    [NullableContextAttribute("2")]
protected virtual bool TryGetPartsOfIfStatement(IfStatementSyntax ifStatement, ExpressionSyntax& condition, StatementSyntax& trueStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseNamedMemberInitializerAnalyzer : AbstractUseNamedMemberInitializerAnalyzer`8<ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerDiagnosticAnalyzer : AbstractUseObjectInitializerDiagnosticAnalyzer`9<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected bool FadeOutOperatorToken { get; }
    protected virtual bool get_FadeOutOperatorToken();
    protected virtual CSharpUseNamedMemberInitializerAnalyzer GetAnalyzer();
    protected virtual bool AreObjectInitializersSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsValidContainingStatement(StatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern : object {
    public IOperation Target;
    private AnalyzedPattern(IOperation target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer : object {
    public static AnalyzedPattern Analyze(IOperation operation);
    private static AnalyzedPattern ParsePattern(IOperation operation);
    private static AnalyzedPattern ParseBinaryPattern(IBinaryOperation op, bool isDisjunctive, SyntaxToken token);
    private static ConstantResult DetermineConstant(IBinaryOperation op);
    private static AnalyzedPattern ParseRelationalPattern(IBinaryOperation op);
    private static AnalyzedPattern ParseConstantPattern(IBinaryOperation op);
    private static bool IsRelationalOperator(BinaryOperatorKind operatorKind);
    public static BinaryOperatorKind Flip(BinaryOperatorKind operatorKind);
    private static bool IsConstant(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string SafeKey;
    private static LocalizableResourceString s_safePatternTitle;
    private static LocalizableResourceString s_unsafePatternTitle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_safeProperties;
    private static DiagnosticDescriptor s_unsafeDescriptor;
    private static CSharpUsePatternCombinatorsDiagnosticAnalyzer();
    public static bool IsSafe(Diagnostic diagnostic);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool HasIllegalPatternVariables(AnalyzedPattern pattern, bool permitDesignations, bool isTopLevel);
    private static bool IsTopmostExpression(ExpressionSyntax node);
    private static bool IsTrivial(AnalyzedPattern pattern);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndMemberAccessDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAsExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeAsExpression>g__IsSafeToConvert|3_0(<>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
private static bool TryGetTypeCheckParts(SemanticModel semanticModel, SyntaxNode operand, VariableDeclaratorSyntax& declarator, BinaryExpressionSyntax& asExpression, ILocalSymbol& localSymbol);
    private static bool TryFindVariableDeclarator(SemanticModel semanticModel, IdentifierNameSyntax identifier, ILocalSymbol& localSymbol, VariableDeclaratorSyntax& declarator);
    private static ExpressionSyntax GetNullCheckOperand(ExpressionSyntax left, SyntaxKind comparisonKind, SyntaxNode right);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CodeBlockStartAnalysisContext`1<SyntaxKind> blockStartContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static CSharpIsAndCastCheckDiagnosticAnalyzer Instance;
    private static CSharpIsAndCastCheckDiagnosticAnalyzer();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
public static bool TryGetPatternPieces(BinaryExpressionSyntax isExpression, IfStatementSyntax& ifStatement, LocalDeclarationStatementSyntax& localDeclarationStatement, VariableDeclaratorSyntax& declarator, CastExpressionSyntax& castExpression);
    private static bool ContainsVariableDeclaration(SyntaxNode scope, VariableDeclaratorSyntax variable);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(CodeBlockStartAnalysisContext`1<SyntaxKind> blockStartContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void SyntaxNodeAction(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionOfTType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.UsePatternMatchingHelpers : object {
    [NullableContextAttribute("2")]
public static bool TryGetPartsOfAsAndMemberAccessCheck(BinaryExpressionSyntax asExpression, ConditionalAccessExpressionSyntax& conditionalAccessExpression, BinaryExpressionSyntax& binaryExpression, IsPatternExpressionSyntax& isPatternExpression, LanguageVersion& requiredLanguageVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string AllFieldsName;
    public static string AllPropertiesName;
    private static ObjectPool`1<ConcurrentSet`1<ISymbol>> s_concurrentSetPool;
    private static CSharpUsePrimaryConstructorDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
public static bool IsViableMemberToAssignTo(INamedTypeSymbol namedType, ISymbol member, MemberDeclarationSyntax& memberNode, SyntaxNode& nodeToRemove, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__5_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool CausesVariableCollision(SemanticModel semanticModel, BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing, CancellationToken cancellationToken);
    private static bool DeclaredLocalCausesCollision(ILookup`2<string, ISymbol> symbolNameToExistingSymbol, ImmutableArray`1<ILocalSymbol> locals);
    private static bool PreservesSemantics(SemanticModel semanticModel, BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing, CancellationToken cancellationToken);
    private static bool UsingStatementDoesNotInvolveJumps(SyntaxList`1<StatementSyntax> parentStatements, int index, UsingStatementSyntax innermostUsing);
    private static bool IsGotoOrLabeledStatement(StatementSyntax priorStatement);
    private static bool UsingValueDoesNotLeakToFollowingStatements(SemanticModel semanticModel, SyntaxList`1<StatementSyntax> statements, int index, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseThrowExpression.CSharpUseThrowExpressionDiagnosticAnalyzer : AbstractUseThrowExpressionDiagnosticAnalyzer {
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual CodeStyleOption2`1<bool> PreferThrowExpressionStyle(OperationAnalysisContext context);
    protected virtual bool IsSupported(Compilation compilation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseTupleSwap.CSharpUseTupleSwapDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
private static bool IsSimpleAssignment(StatementSyntax assignmentStatement, ExpressionSyntax& left, ExpressionSyntax& right);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    private void ReportParameterArrayDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, ImmutableArray`1<IOperation> elements, NotificationOption2 notificationOption, ArrayCreationOperationLocation operationLocation);
    private void ReportArrayCreationDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, NotificationOption2 notificationOption);
    private void ReportDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, NotificationOption2 notificationOption, Location location, ArrayCreationOperationLocation operationLocation);
    [NullableContextAttribute("2")]
internal static bool TryConvertToUtf8String(StringBuilder builder, ImmutableArray`1<IOperation> arrayCreationElements);
    private static bool TryGetNextRune(ImmutableArray`1<IOperation> arrayCreationElements, int startIndex, Rune& rune, Int32& bytesConsumed);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToUtf8String>g__IsControlOrFormatRune|8_0(Rune rune);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper : object {
    protected abstract virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal abstract virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected abstract virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseExplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseExplicitTypeHelper Instance;
    private static CSharpUseExplicitTypeHelper();
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseImplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseImplicitTypeHelper Instance;
    private static CSharpUseImplicitTypeHelper();
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    private static bool TryAnalyzeDeclarationExpression(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSafeToSwitchToVarWithoutNeedingSpeculation(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    internal static ExpressionSyntax GetInitializerExpression(ExpressionSyntax initializer);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.FormattingRangeHelper : object {
    public static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRange(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FixupOpenBrace(Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> tokenRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeWorker(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForSemicolon(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForCloseBrace(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForColon(SyntaxToken endToken);
    private static SyntaxToken GetPreviousTokenIfNotFirstTokenInTree(SyntaxToken token);
    public static bool AreTwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private static SyntaxToken GetAppropriatePreviousToken(SyntaxToken startToken, bool canTokenBeFirstInABlock);
    private static bool IsOpenBraceTokenOfABlockOrTypeOrNamespace(SyntaxToken previousToken);
    [NullableContextAttribute("1")]
private static bool IsSpecialContainingNode(SyntaxNode node);
    [NullableContextAttribute("2")]
private static SyntaxNode GetTopContainingNode(SyntaxNode node);
    public static bool IsColonInSwitchLabel(SyntaxToken token);
    public static bool InBetweenTwoMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax GetEnclosingMember(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    internal TypeSyntaxComparer TypeComparer;
    internal NameSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer);
    public static IComparer`1<NameSyntax> Create();
    public static IComparer`1<NameSyntax> Create(IComparer`1<SyntaxToken> tokenComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(NameSyntax x, NameSyntax y);
    private static IList`1<SimpleNameSyntax> DecomposeNameParts(NameSyntax name);
    private static void DecomposeNameParts(NameSyntax name, List`1<SimpleNameSyntax> result);
    private int Compare(GenericNameSyntax x, GenericNameSyntax y);
    [CompilerGeneratedAttribute]
private int <Compare>g__DecomposeCompare|5_0(NameSyntax x, NameSyntax y);
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer : AbstractSpeculationAnalyzer`8<ExpressionSyntax, TypeSyntax, AttributeSyntax, ArgumentSyntax, CommonForEachStatementSyntax, ThrowStatementSyntax, InvocationExpressionSyntax, Conversion> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts <SyntaxFactsService>k__BackingField;
    protected ISyntaxFacts SyntaxFactsService { get; }
    public SpeculationAnalyzer(ExpressionSyntax expression, ExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFactsService();
    protected virtual bool CanAccessInstanceMemberThrough(ExpressionSyntax expression);
    protected virtual SyntaxNode GetSemanticRootForSpeculation(ExpressionSyntax expression);
    public static bool CanSpeculateOnNode(SyntaxNode node);
    protected virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    protected virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode nodeToSpeculate, SemanticModel semanticModel, int position, bool isInNamespaceOrTypeContext);
    public bool ReplacementChangesSemanticsOfUnchangedLambda(ExpressionSyntax originalLambda, ExpressionSyntax replacedLambda);
    private bool HaveSameParameterType(ParameterSyntax originalParam, ParameterSyntax replacedParam);
    private bool ReplacementChangesSemanticsForNodes(IEnumerable`1<IdentifierNameSyntax> originalIdentifierNodes, IEnumerable`1<IdentifierNameSyntax> replacedIdentifierNodes, SyntaxNode originalRoot);
    protected virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementBreaksBoxingInConditionalExpression(TypeInfo originalExpressionTypeInfo, TypeInfo newExpressionTypeInfo, ExpressionSyntax previousOriginalNode, ExpressionSyntax previousReplacedNode);
    private bool ReplacementBreaksAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax originalAnonymousObjectMemberDeclarator, AnonymousObjectMemberDeclaratorSyntax replacedAnonymousObjectMemberDeclarator);
    private bool ReplacementBreaksConstructorInitializer(ConstructorInitializerSyntax ctorInitializer, ConstructorInitializerSyntax newCtorInitializer);
    private bool ReplacementBreaksCollectionInitializerAddMethod(ExpressionSyntax originalInitializer, ExpressionSyntax newInitializer);
    protected virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    protected virtual ImmutableArray`1<ArgumentSyntax> GetArguments(ExpressionSyntax expression);
    private static BaseArgumentListSyntax GetArgumentList(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetReceiver(ExpressionSyntax expression);
    protected virtual bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    protected virtual ExpressionSyntax GetForEachStatementExpression(CommonForEachStatementSyntax forEachStatement);
    protected virtual ExpressionSyntax GetThrowStatementExpression(ThrowStatementSyntax throwStatement);
    protected virtual bool IsForEachTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    protected virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected virtual bool IsNamedArgument(ArgumentSyntax argument);
    protected virtual string GetNamedArgumentIdentifierValueText(ArgumentSyntax argument);
    private bool ReplacementBreaksBinaryExpression(BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax newBinaryExpression);
    private bool ReplacementBreaksConditionalAccessExpression(ConditionalAccessExpressionSyntax conditionalAccessExpression, ConditionalAccessExpressionSyntax newConditionalAccessExpression);
    private bool ReplacementBreaksIsOrAsExpression(BinaryExpressionSyntax originalIsOrAsExpression, BinaryExpressionSyntax newIsOrAsExpression);
    private bool ReplacementBreaksAssignmentExpression(AssignmentExpressionSyntax assignmentExpression, AssignmentExpressionSyntax newAssignmentExpression);
    private bool ReplacementBreaksQueryClause(QueryClauseSyntax originalClause, QueryClauseSyntax newClause);
    protected virtual bool ReplacementIntroducesDisallowedNullType(ExpressionSyntax originalExpression, ExpressionSyntax newExpression, TypeInfo originalTypeInfo, TypeInfo newTypeInfo);
    protected virtual bool ConversionsAreCompatible(SemanticModel originalModel, ExpressionSyntax originalExpression, SemanticModel newModel, ExpressionSyntax newExpression);
    private static bool ConditionalExpressionConversionsAreAllowed(ExpressionSyntax originalExpression);
    protected virtual bool ConversionsAreCompatible(ExpressionSyntax originalExpression, ITypeSymbol originalTargetType, ExpressionSyntax newExpression, ITypeSymbol newTargetType);
    private bool ConversionsAreCompatible(Conversion originalConversion, Conversion newConversion);
    protected virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, CommonForEachStatementSyntax originalForEach, SemanticModel newModel, CommonForEachStatementSyntax newForEach);
    protected virtual void GetForEachSymbols(SemanticModel model, CommonForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    protected virtual bool IsReferenceConversion(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ExpressionSyntax expression, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
    [CompilerGeneratedAttribute]
private bool <ReplacementIntroducesDisallowedNullType>g__IsSupportedConstructWithNullType|35_0(<>c__DisplayClass35_0& );
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TokenComparer : object {
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> NormalInstance;
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> SystemFirstInstance;
    private bool _specialCaseSystem;
    private TokenComparer(bool specialCaseSystem);
    private static TokenComparer();
    public sealed virtual int Compare(SyntaxToken x, SyntaxToken y);
    private static int CompareWorker(SyntaxToken x, SyntaxToken y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult : ValueType {
    private CSharpTypeStyleHelper _helper;
    private TypeSyntax _typeName;
    private SemanticModel _semanticModel;
    private CSharpSimplifierOptions _options;
    private CancellationToken _cancellationToken;
    public bool IsStylePreferred;
    public NotificationOption2 Notification;
    public TypeStyleResult(CSharpTypeStyleHelper helper, TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, bool isStylePreferred, NotificationOption2 notificationOption, CancellationToken cancellationToken);
    public bool CanConvert();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IComparer`1<NameSyntax> NameComparer;
    internal TypeSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer, IComparer`1<NameSyntax> nameComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(TypeSyntax x, TypeSyntax y);
    private static TypeSyntax UnwrapType(TypeSyntax type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesDirectiveComparer : object {
    public static IComparer`1<SyntaxNode> NormalInstance;
    public static IComparer`1<SyntaxNode> SystemFirstInstance;
    private IComparer`1<NameSyntax> _nameComparer;
    private IComparer`1<SyntaxToken> _tokenComparer;
    private UsingsAndExternAliasesDirectiveComparer(IComparer`1<NameSyntax> nameComparer, IComparer`1<SyntaxToken> tokenComparer);
    private static UsingsAndExternAliasesDirectiveComparer();
    [NullableContextAttribute("2")]
private static UsingKind GetUsingKind(UsingDirectiveSyntax usingDirective, ExternAliasDirectiveSyntax externDirective);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SyntaxNode directive1, SyntaxNode directive2);
    [CompilerGeneratedAttribute]
internal static bool <Compare>g__IsGlobal|7_0(UsingKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesOrganizer : object {
    public static void Organize(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, bool separateGroups, SyntaxTrivia newLineTrivia, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    public static bool NeedsGrouping(UsingDirectiveSyntax using1, UsingDirectiveSyntax using2);
    private static void OrganizeWorker(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, SyntaxTrivia newLineTrivia, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    private static void EnsureNewLines(IList`1<SyntaxNode> list, SyntaxTrivia newLineTrivia);
    private static SyntaxNode TrimLeadingNewLines(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ValidateFormatString.CSharpValidateFormatStringDiagnosticAnalyzer : AbstractValidateFormatStringDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    protected virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProvider : ValueType {
    private IOptionsReader _options;
    private IdeAnalyzerOptions _fallbackOptions;
    public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; }
    public CodeStyleOption2`1<bool> VarWhenTypeIsApparent { get; }
    public CodeStyleOption2`1<bool> VarElsewhere { get; }
    public CodeStyleOption2`1<bool> PreferSimpleDefaultExpression { get; }
    public CodeStyleOption2`1<bool> AllowEmbeddedStatementsOnSameLine { get; }
    public CodeStyleOption2`1<bool> PreferThrowExpression { get; }
    public CodeStyleOption2`1<PreferBracesPreference> PreferBraces { get; }
    public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; }
    public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; }
    public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; }
    public CodeStyleOption2`1<bool> ImplicitObjectCreationWhenTypeIsApparent { get; }
    public CodeStyleOption2`1<bool> PreferNullCheckOverTypeCheck { get; }
    public CodeStyleOption2`1<bool> AllowBlankLinesBetweenConsecutiveBraces { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterColonInConstructorInitializer { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInArrowExpressionClause { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInConditionalExpression { get; }
    public CodeStyleOption2`1<bool> PreferConditionalDelegateCall { get; }
    public CodeStyleOption2`1<bool> PreferSwitchExpression { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatching { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatchingOverAsWithNullCheck { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatchingOverIsWithCastCheck { get; }
    public CodeStyleOption2`1<bool> PreferNotPattern { get; }
    public CodeStyleOption2`1<bool> PreferExtendedPropertyPattern { get; }
    public CodeStyleOption2`1<bool> PreferInlinedVariableDeclaration { get; }
    public CodeStyleOption2`1<bool> PreferDeconstructedVariableDeclaration { get; }
    public CodeStyleOption2`1<bool> PreferIndexOperator { get; }
    public CodeStyleOption2`1<bool> PreferRangeOperator { get; }
    public CodeStyleOption2`1<bool> PreferUtf8StringLiterals { get; }
    public CodeStyleOption2`1<string> PreferredModifierOrder { get; }
    public CodeStyleOption2`1<bool> PreferSimpleUsingStatement { get; }
    public CodeStyleOption2`1<bool> PreferLocalOverAnonymousFunction { get; }
    public CodeStyleOption2`1<bool> PreferTupleSwap { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; }
    public CodeStyleOption2`1<bool> PreferMethodGroupConversion { get; }
    public CodeStyleOption2`1<bool> PreferPrimaryConstructors { get; }
    public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; }
    public CodeStyleOption2`1<bool> PreferReadOnlyStruct { get; }
    public CodeStyleOption2`1<bool> PreferReadOnlyStructMember { get; }
    public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; }
    public CodeStyleOption2`1<bool> PreferStaticAnonymousFunction { get; }
    private CSharpIdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private CSharpSimplifierOptions FallbackSimplifierOptions { get; }
    private CSharpSyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private AddImportPlacementOptions FallbackAddImportPlacementOptions { get; }
    private CSharpCodeGenerationOptions FallbackCodeGenerationOptions { get; }
    public CSharpAnalyzerOptionsProvider(IOptionsReader options, IdeAnalyzerOptions fallbackOptions);
    public CSharpAnalyzerOptionsProvider(IOptionsReader options, AnalyzerOptions fallbackOptions);
    public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    public CodeStyleOption2`1<bool> get_VarWhenTypeIsApparent();
    public CodeStyleOption2`1<bool> get_VarElsewhere();
    public CodeStyleOption2`1<bool> get_PreferSimpleDefaultExpression();
    public CodeStyleOption2`1<bool> get_AllowEmbeddedStatementsOnSameLine();
    public CodeStyleOption2`1<bool> get_PreferThrowExpression();
    public CodeStyleOption2`1<PreferBracesPreference> get_PreferBraces();
    internal CSharpSimplifierOptions GetSimplifierOptions();
    public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    public CodeStyleOption2`1<bool> get_ImplicitObjectCreationWhenTypeIsApparent();
    public CodeStyleOption2`1<bool> get_PreferNullCheckOverTypeCheck();
    public CodeStyleOption2`1<bool> get_AllowBlankLinesBetweenConsecutiveBraces();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterColonInConstructorInitializer();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInConditionalExpression();
    public CodeStyleOption2`1<bool> get_PreferConditionalDelegateCall();
    public CodeStyleOption2`1<bool> get_PreferSwitchExpression();
    public CodeStyleOption2`1<bool> get_PreferPatternMatching();
    public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverAsWithNullCheck();
    public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverIsWithCastCheck();
    public CodeStyleOption2`1<bool> get_PreferNotPattern();
    public CodeStyleOption2`1<bool> get_PreferExtendedPropertyPattern();
    public CodeStyleOption2`1<bool> get_PreferInlinedVariableDeclaration();
    public CodeStyleOption2`1<bool> get_PreferDeconstructedVariableDeclaration();
    public CodeStyleOption2`1<bool> get_PreferIndexOperator();
    public CodeStyleOption2`1<bool> get_PreferRangeOperator();
    public CodeStyleOption2`1<bool> get_PreferUtf8StringLiterals();
    public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    public CodeStyleOption2`1<bool> get_PreferSimpleUsingStatement();
    public CodeStyleOption2`1<bool> get_PreferLocalOverAnonymousFunction();
    public CodeStyleOption2`1<bool> get_PreferTupleSwap();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    public CodeStyleOption2`1<bool> get_PreferMethodGroupConversion();
    public CodeStyleOption2`1<bool> get_PreferPrimaryConstructors();
    internal CSharpCodeGenerationOptions GetCodeGenerationOptions();
    public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    public CodeStyleOption2`1<bool> get_PreferReadOnlyStruct();
    public CodeStyleOption2`1<bool> get_PreferReadOnlyStructMember();
    public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    public CodeStyleOption2`1<bool> get_PreferStaticAnonymousFunction();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private CSharpIdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private CSharpSimplifierOptions get_FallbackSimplifierOptions();
    private CSharpSyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private AddImportPlacementOptions get_FallbackAddImportPlacementOptions();
    private CSharpCodeGenerationOptions get_FallbackCodeGenerationOptions();
    public static CSharpAnalyzerOptionsProvider op_Explicit(AnalyzerOptionsProvider provider);
    public static AnalyzerOptionsProvider op_Implicit(CSharpAnalyzerOptionsProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProviders : object {
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(AnalyzerOptions options, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(CodeBlockAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SymbolStartAnalysisContext context, SyntaxTree syntaxTree);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.CSharpUnnecessaryImportsProvider : AbstractUnnecessaryImportsProvider`1<UsingDirectiveSyntax> {
    public static CSharpUnnecessaryImportsProvider Instance;
    private static CSharpUnnecessaryImportsProvider();
    public virtual ImmutableArray`1<UsingDirectiveSyntax> GetUnnecessaryImports(SemanticModel model, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCompilation(CompilationStartAnalysisContext context);
    private static bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    private static bool IsReducing(Nullable`1<NullableContextOptions> oldOptions, Nullable`1<NullableContextOptions> newOptions);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<TextSpan> AnalyzeCodeBlock(CodeBlockAnalysisContext context, int positionOfFirstReducingNullableDirective);
    [NullableContextAttribute("2")]
private ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, int positionOfFirstReducingNullableDirective, TextSpanMutableIntervalTree codeBlockIntervalTree, TextSpanMutableIntervalTree possibleNullableImpactIntervalTree);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
