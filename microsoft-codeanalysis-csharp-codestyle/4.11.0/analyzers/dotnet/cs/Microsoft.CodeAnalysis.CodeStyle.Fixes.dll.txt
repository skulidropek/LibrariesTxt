[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual SyntaxNode MapToDeclarator(SyntaxNode declaration);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider/<FixAllAsync>d__4")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AddAccessibilityModifiersHelpers : object {
    public static void UpdateDeclaration(SyntaxEditor editor, ISymbol symbol, SyntaxNode declaration);
    private static Accessibility GetPreferredAccessibility(ISymbol symbol);
}
internal interface Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiersService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool HasName(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TExpressionSyntax GetExpression(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TAnonymousObjectMemberDeclaratorSyntax WithName(TAnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected abstract virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(TAnonymousObjectInitializer initializer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<GetMemberDeclaratorAsync>d__5")]
private Task`1<TAnonymousObjectMemberDeclaratorSyntax> GetMemberDeclaratorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixOneAsync>d__7")]
private Task FixOneAsync(Document document, SemanticModel semanticModel, Diagnostic diagnostic, SyntaxEditor editor, SyntaxAnnotation annotation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportsService`4 : object {
    protected string Language { get; }
    protected abstract virtual string get_Language();
    protected abstract virtual SyntaxNode GetAlias(TUsingOrAliasSyntax usingOrAlias);
    protected abstract virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected abstract virtual SyntaxList`1<TUsingOrAliasSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected abstract virtual SyntaxList`1<TExternSyntax> GetExterns(SyntaxNode node);
    protected abstract virtual bool IsStaticUsing(TUsingOrAliasSyntax usingOrAlias);
    public sealed virtual AddImportPlacementOptions GetAddImportOptions(IOptionsReader configOptions, bool allowInHiddenRegions, AddImportPlacementOptions fallbackOptions);
    public abstract virtual CodeStyleOption2`1<AddImportPlacement> GetUsingDirectivePlacementCodeStyleOption(IOptionsReader configOptions, CodeStyleOption2`1<AddImportPlacement> fallbackValue);
    private bool IsSimpleUsing(TUsingOrAliasSyntax usingOrAlias);
    private bool IsAlias(TUsingOrAliasSyntax usingOrAlias);
    private bool HasAliases(SyntaxNode node);
    private bool HasUsings(SyntaxNode node);
    private bool HasStaticUsings(SyntaxNode node);
    private bool HasExterns(SyntaxNode node);
    private bool HasAnyImports(SyntaxNode node);
    public sealed virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, SyntaxGenerator generator);
    private static ImmutableArray`1<SyntaxNode> GetAllContainers(SyntaxNode root, SyntaxNode contextLocation);
    private bool HasExistingImport(SyntaxNode import, ImmutableArray`1<SyntaxNode> containers, ImmutableArray`1<SyntaxNode> globalImports);
    protected abstract virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
    public sealed virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, AddImportPlacementOptions options);
    public sealed virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode Rewrite(TExternSyntax[] externAliases, TUsingOrAliasSyntax[] usingDirectives, TUsingOrAliasSyntax[] staticUsingDirectives, TUsingOrAliasSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, AddImportPlacementOptions options, SyntaxNode root, CancellationToken cancellationToken);
    private void GetContainers(SyntaxNode root, SyntaxNode contextLocation, AddImportPlacementOptions options, SyntaxNode& externContainer, SyntaxNode& usingContainer, SyntaxNode& staticUsingContainer, SyntaxNode& aliasContainer);
    private static SyntaxNode GetFirstApplicableContainer(SyntaxNode contextNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddImport.AddImportHelpers : object {
    public static ValueTuple`2<TRootSyntax, bool> MoveTrivia(ISyntaxFacts syntaxFacts, TRootSyntax root, SyntaxList`1<TImportDirectiveSyntax> existingImports, List`1<TImportDirectiveSyntax> newImports);
    private static bool IsDocCommentOrElastic(ISyntaxFacts syntaxFacts, SyntaxTrivia t);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders/<GetAddImportPlacementOptionsAsync>d__0")]
[ExtensionAttribute]
internal static ValueTask`1<AddImportPlacementOptions> GetAddImportPlacementOptionsAsync(Document document, IAddImportsService addImportsService, AddImportPlacementOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AddImport.IAddImportServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode AddImport(IAddImportsService service, Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode newImport, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddImport.IAddImportsService {
    public abstract virtual AddImportPlacementOptions GetAddImportOptions(IOptionsReader configOptions, bool allowInHiddenRegions, AddImportPlacementOptions fallbackOptions);
    public abstract virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, SyntaxGenerator generator);
    public abstract virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, AddImportPlacementOptions options);
    public abstract virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private string _title;
    protected AbstractAddObsoleteAttributeCodeFixProvider(ISyntaxFacts syntaxFacts, string title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<GetObsoleteAttributeAsync>d__4")]
private static Task`1<INamedTypeSymbol> GetObsoleteAttributeAsync(Document document, CancellationToken cancellationToken);
    private SyntaxNode GetContainer(SyntaxNode root, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6 : CodeFixProvider {
    private static SymbolDisplayFormat SimpleFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static AbstractAddParameterCodeFixProvider`6();
    protected abstract virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected abstract virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected abstract virtual ITypeSymbol GetArgumentType(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    protected virtual RegisterFixData`1<TArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private TArgumentSyntax TryGetRelevantArgument(SyntaxNode initialNode, SyntaxNode node, Diagnostic diagnostic);
    private static RegisterFixData`1<TArgumentSyntax> TryGetInvocationExpressionFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static RegisterFixData`1<TArgumentSyntax> TryGetObjectCreationFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> GetArgumentInsertPositionForMethodCandidates(TArgumentSyntax argumentOpt, SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates);
    private static int NonParamsParameterCount(IMethodSymbol method);
    private void RegisterFixForMethodOverloads(CodeFixContext context, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    [NullableContextAttribute("0")]
private ImmutableArray`1<CodeFixData> PrepareCreationOfCodeActions(Document document, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    private static string GetCodeFixTitle(string resourceString, IMethodSymbol methodToUpdate, bool includeParameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<FixAsync>d__16")]
private Task`1<Solution> FixAsync(Document invocationDocument, IMethodSymbol method, TArgumentSyntax argument, SeparatedSyntaxList`1<TArgumentSyntax> argumentList, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetArgumentTypeAndRefKindAsync>d__17")]
private Task`1<ValueTuple`2<ITypeSymbol, RefKind>> GetArgumentTypeAndRefKindAsync(Document invocationDocument, TArgumentSyntax argument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetNameSuggestionForArgumentAsync>d__18")]
private static Task`1<ValueTuple`2<string, bool>> GetNameSuggestionForArgumentAsync(Document invocationDocument, TArgumentSyntax argument, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static TArgumentSyntax DetermineFirstArgumentToAdd(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, StringComparer comparer, IMethodSymbol method, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    private static bool TypeInfoMatchesWithParamsExpansion(Compilation compilation, TypeInfo argumentTypeInfo, IParameterSymbol parameter, bool isNullLiteral, bool isDefaultLiteral);
    private static bool TypeInfoMatchesType(Compilation compilation, TypeInfo argumentTypeInfo, ITypeSymbol parameterType, bool isNullLiteral, bool isDefaultLiteral);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByOverload|13_0(<>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByCascading|13_1(<>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddParameter.AddParameterService : object {
    public static bool HasCascadingDeclarations(IMethodSymbol method);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<AddParameterAsync>d__1")]
public static Task`1<Solution> AddParameterAsync(Document invocationDocument, IMethodSymbol method, ITypeSymbol newParameterType, RefKind refKind, string parameterName, Nullable`1<int> newParameterIndex, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<FindMethodDeclarationReferencesAsync>d__2")]
private static Task`1<ImmutableArray`1<IMethodSymbol>> FindMethodDeclarationReferencesAsync(Document invocationDocument, IMethodSymbol method, CancellationToken cancellationToken);
    private static IParameterSymbol CreateParameterSymbol(IMethodSymbol method, ITypeSymbol parameterType, RefKind refKind, bool isOptional, string argumentNameSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.ArgumentInsertPositionData`1 : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodToUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private TArgumentSyntax <ArgumentToInsert>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentInsertionIndex>k__BackingField;
    public IMethodSymbol MethodToUpdate { get; }
    public TArgumentSyntax ArgumentToInsert { get; }
    public int ArgumentInsertionIndex { get; }
    public ArgumentInsertPositionData`1(IMethodSymbol methodToUpdate, TArgumentSyntax argumentToInsert, int argumentInsertionIndex);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodToUpdate();
    [CompilerGeneratedAttribute]
public TArgumentSyntax get_ArgumentToInsert();
    [CompilerGeneratedAttribute]
public int get_ArgumentInsertionIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.CodeFixData : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionNonCascading>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionCascading>k__BackingField;
    public IMethodSymbol Method { get; }
    public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionNonCascading { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionCascading { get; }
    public CodeFixData(IMethodSymbol method, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionNonCascading, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionCascading);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionNonCascading();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionCascading();
}
internal class Microsoft.CodeAnalysis.AddParameter.RegisterFixData`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SeparatedSyntaxList`1<TArgumentSyntax> <Arguments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <MethodCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructorInitializer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TArgumentSyntax> Arguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> MethodCandidates { get; }
    public bool IsConstructorInitializer { get; }
    public RegisterFixData`1(SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates, bool isConstructorInitializer);
    [CompilerGeneratedAttribute]
public SeparatedSyntaxList`1<TArgumentSyntax> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_MethodCandidates();
    [CompilerGeneratedAttribute]
public bool get_IsConstructorInitializer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider : CodeFixProvider {
    protected abstract virtual string GetTextPreviewOfChange(string aliasName, ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static IEnumerable`1<ITypeSymbol> Sort(IEnumerable`1<ITypeSymbol> types, bool sortSystemFirst);
    private static bool SymbolCandidatesContainsSupportedSymbols(SymbolInfo symbolInfo);
}
internal abstract class Microsoft.CodeAnalysis.AsyncSymbolVisitor : SymbolVisitor`1<ValueTask> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.AsyncSymbolVisitor`1 : SymbolVisitor`1<ValueTask`1<TResult>> {
    protected TResult DefaultResult { get; }
    protected abstract virtual TResult get_DefaultResult();
    [NullableContextAttribute("2")]
public virtual ValueTask`1<TResult> Visit(ISymbol symbol);
    public virtual ValueTask`1<TResult> DefaultVisit(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.CodeActions.AbstractCodeActionOptionsProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual CodeActionOptions GetOptions(LanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CodeActionOptions : object {
    public static CodeActionOptionsProvider DefaultProvider;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
private CodeActionOptions(CodeActionOptions original);
    private static CodeActionOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    public static CodeActionOptions GetDefault(LanguageServices languageServices);
    public CodeActionOptionsProvider CreateProvider();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CodeActionOptions left, CodeActionOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CodeActionOptions left, CodeActionOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeActionOptions other);
    [CompilerGeneratedAttribute]
public CodeActionOptions <Clone>$();
    [CompilerGeneratedAttribute]
private CodeActionOptions <CreateProvider>b__4_0(LanguageServices _);
}
internal interface Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider {
    [NullableContextAttribute("1")]
public abstract virtual CodeActionOptions GetOptions(LanguageServices languageService);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProviders : object {
    [ExtensionAttribute]
internal static CodeActionOptionsProvider GetOptionsProvider(CodeFixContext context);
    [ExtensionAttribute]
internal static CodeActionOptionsProvider GetOptionsProvider(FixAllContext _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProvider : ValueType {
    private IOptionsReader _options;
    private HostLanguageServices _languageServices;
    private CodeActionOptionsProvider _fallbackOptions;
    public string NewLine { get; }
    public AccessibilityModifiersRequired AccessibilityModifiersRequired { get; }
    private LineFormattingOptions FallbackLineFormattingOptions { get; }
    [NullableAttribute("2")]
private SyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private SyntaxFormattingOptions FallbackCommonSyntaxFormattingOptions { get; }
    public CodeFixOptionsProvider(IOptionsReader options, CodeActionOptionsProvider fallbackOptions, HostLanguageServices languageServices);
    public string get_NewLine();
    public LineFormattingOptions GetLineFormattingOptions();
    public SyntaxFormattingOptions GetFormattingOptions(ISyntaxFormatting formatting);
    public AccessibilityModifiersRequired get_AccessibilityModifiersRequired();
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private LineFormattingOptions get_FallbackLineFormattingOptions();
    [NullableContextAttribute("2")]
private SyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private SyntaxFormattingOptions get_FallbackCommonSyntaxFormattingOptions();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProviders : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProviders/<GetCodeFixOptionsAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<CodeFixOptionsProvider> GetCodeFixOptionsAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeActions.DelegatingCodeActionOptionsProvider : AbstractCodeActionOptionsProvider {
    [CompilerGeneratedAttribute]
private Func`2<LanguageServices, CodeActionOptions> <delegate>P;
    public DelegatingCodeActionOptionsProvider(Func`2<LanguageServices, CodeActionOptions> delegate);
    public virtual CodeActionOptions GetOptions(LanguageServices languageService);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeAnalysisProgressExtensions : object {
    [ExtensionAttribute]
public static void AddItems(IProgress`1<CodeAnalysisProgress> progress, int count);
    [ExtensionAttribute]
public static void ItemCompleted(IProgress`1<CodeAnalysisProgress> progress);
    [ExtensionAttribute]
public static ItemCompletedDisposer ItemCompletedScope(IProgress`1<CodeAnalysisProgress> progress, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    private static int MaximumConversionOptions;
    protected abstract virtual TExpressionSyntax Cast(TExpressionSyntax expression, ITypeSymbol type);
    protected abstract virtual void GetPartsOfCastOrConversionExpression(TExpressionSyntax expression, SyntaxNode& type, SyntaxNode& castedExpression);
    protected abstract virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, TExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private SyntaxNode ApplyFix(Document document, SemanticModel semanticModel, SyntaxNode currentRoot, TExpressionSyntax targetNode, ITypeSymbol conversionType, CancellationToken cancellationToken);
    private static string GetSubItemName(SemanticModel semanticModel, int position, ITypeSymbol conversionType);
    protected static ImmutableArray`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> FilterValidPotentialConversionTypes(Document document, SemanticModel semanticModel, ArrayBuilder`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> mutablePotentialConversionTypes);
    protected static bool FindCorrespondingParameterByName(string argumentName, ImmutableArray`1<IParameterSymbol> parameters, Int32& parameterIndex);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1 : object {
    private SemanticModel _semanticModel;
    public InheritanceDistanceComparer`1(SemanticModel semanticModel);
    public sealed virtual int Compare(ValueTuple`2<TExpressionSyntax, ITypeSymbol> x, ValueTuple`2<TExpressionSyntax, ITypeSymbol> y);
    private static int GetInheritanceDistanceRecursive(ITypeSymbol baseType, ITypeSymbol derivedType);
    private int GetInheritanceDistance(ITypeSymbol baseType, ITypeSymbol castType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions : object {
    [ExtensionAttribute]
internal static void RegisterFixes(CodeFixContext context, IEnumerable`1<CodeAction> actions, Diagnostic diagnostic);
    [ExtensionAttribute]
internal static void RegisterFixes(CodeFixContext context, IEnumerable`1<CodeAction> actions, ImmutableArray`1<Diagnostic> diagnostics);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeFixes.FixAllContextExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetDefaultFixAllTitle(FixAllContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.ForkingSyntaxEditorBasedCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    protected abstract virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, TDiagnosticNode diagnosticNode, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    protected sealed virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.ForkingSyntaxEditorBasedCodeFixProvider`1/<FixAllAsync>d__4")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider : CodeFixProvider {
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.MatchFolderAndNamespace.AbstractChangeNamespaceToMatchFolderCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.MatchFolderAndNamespace.AbstractChangeNamespaceToMatchFolderCodeFixProvider/<FixAllInDocumentAsync>d__3")]
private static Task`1<Solution> FixAllInDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Solution> FixAsync(Document document, ISymbol symbol, string fixedName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.PredefinedCodeFixProviderNames : object {
    public static string AddAccessibilityModifiers;
    public static string AddAnonymousTypeMemberName;
    public static string AddAsync;
    public static string AddBraces;
    public static string AddDocCommentNodes;
    public static string AddExplicitCast;
    public static string AddImport;
    public static string AddInheritdoc;
    public static string AddMissingReference;
    public static string AddNew;
    public static string AddObsoleteAttribute;
    public static string AddOverloads;
    public static string AddPackage;
    public static string AddParameter;
    public static string AddParenthesesAroundConditionalExpressionInInterpolatedString;
    public static string AddRequiredParentheses;
    public static string AliasAmbiguousType;
    public static string ApplyNamingStyle;
    public static string ArrowExpressionClausePlacement;
    public static string AssignOutParametersAboveReturn;
    public static string AssignOutParametersAtStart;
    public static string ChangeNamespaceToMatchFolder;
    public static string ChangeReturnType;
    public static string ChangeToYield;
    public static string ConditionalExpressionPlacement;
    public static string ConflictMarkerResolution;
    public static string ConsecutiveBracePlacement;
    public static string ConsecutiveStatementPlacement;
    public static string ConstructorInitializerPlacement;
    public static string ConvertNamespace;
    public static string ConvertSwitchStatementToExpression;
    public static string ConvertToAsync;
    public static string ConvertToIterator;
    public static string ConvertToProgramMain;
    public static string ConvertToRecord;
    public static string ConvertToTopLevelStatements;
    public static string ConvertTypeOfToNameOf;
    public static string CopilotSuggestions;
    public static string CorrectNextControlVariable;
    public static string DeclareAsNullable;
    public static string DisambiguateSameVariable;
    public static string EmbeddedStatementPlacement;
    public static string FileHeader;
    public static string FixFormatting;
    public static string FixIncorrectConstraint;
    public static string FixIncorrectExitContinue;
    public static string FixIncorrectFunctionReturnType;
    public static string FixReturnType;
    public static string ForEachCast;
    public static string FullyQualify;
    public static string GenerateConstructor;
    public static string GenerateConversion;
    public static string GenerateDeconstructMethod;
    public static string GenerateDefaultConstructors;
    public static string GenerateEndConstruct;
    public static string GenerateEnumMember;
    public static string GenerateEvent;
    public static string GenerateMethod;
    public static string GenerateType;
    public static string GenerateVariable;
    public static string ImplementAbstractClass;
    public static string ImplementInterface;
    public static string InlineDeclaration;
    public static string InvokeDelegateWithConditionalAccess;
    public static string JsonDetection;
    public static string MakeFieldReadonly;
    public static string MakeLocalFunctionStatic;
    public static string MakeAnonymousFunctionStatic;
    public static string MakeMemberRequired;
    public static string MakeMemberStatic;
    public static string MakeMethodSynchronous;
    public static string MakeRefStruct;
    public static string MakeStatementAsynchronous;
    public static string MakeStructFieldsWritable;
    public static string MakeStructMemberReadOnly;
    public static string MakeStructReadOnly;
    public static string MakeTypeAbstract;
    public static string MakeTypePartial;
    public static string MoveMisplacedUsingDirectives;
    public static string MoveToTopOfFile;
    public static string OrderModifiers;
    public static string PassInCapturedVariables;
    public static string PopulateSwitch;
    public static string PopulateSwitchExpression;
    public static string PreferFrameworkType;
    public static string QualifyMemberAccess;
    public static string RemoveAsyncModifier;
    public static string RemoveBlankLines;
    public static string RemoveConfusingSuppression;
    public static string RemoveDocCommentNode;
    public static string RemoveIn;
    public static string RemoveNew;
    public static string RemoveRedundantEquality;
    public static string RemoveSharedFromModuleMembers;
    public static string RemoveUnnecessaryAttributeSuppressions;
    public static string RemoveUnnecessaryByVal;
    public static string RemoveUnnecessaryCast;
    public static string RemoveUnnecessaryDiscardDesignation;
    public static string RemoveUnnecessaryImports;
    public static string RemoveUnnecessaryLambdaExpression;
    public static string RemoveUnnecessaryNullableDirective;
    public static string RemoveUnnecessaryParentheses;
    public static string RemoveUnnecessaryPragmaSuppressions;
    public static string RemoveUnreachableCode;
    public static string RemoveUnusedLocalFunction;
    public static string RemoveUnusedMembers;
    public static string RemoveUnusedValues;
    public static string RemoveUnusedVariable;
    public static string ReplaceDefaultLiteral;
    public static string SimplifyConditionalExpression;
    public static string SimplifyInterpolation;
    public static string SimplifyLinqExpression;
    public static string SimplifyNames;
    public static string SimplifyObjectCreation;
    public static string SimplifyPropertyPattern;
    public static string SimplifyThisOrMe;
    public static string SpellCheck;
    public static string TransposeRecordKeyword;
    public static string UnsealClass;
    public static string UpdateLegacySuppressions;
    public static string UpdateProjectToAllowUnsafe;
    public static string UpgradeProject;
    public static string UseAutoProperty;
    public static string UseCoalesceExpressionForIfNullStatementCheck;
    public static string UseCoalesceExpressionForNullableTernaryConditionalCheck;
    public static string UseCoalesceExpressionForTernaryConditionalCheck;
    public static string UseCollectionExpressionForArray;
    public static string UseCollectionExpressionForBuilder;
    public static string UseCollectionExpressionForCreate;
    public static string UseCollectionExpressionForEmpty;
    public static string UseCollectionExpressionForFluent;
    public static string UseCollectionExpressionForStackAlloc;
    public static string UseCollectionInitializer;
    public static string UseCompoundAssignment;
    public static string UseCompoundCoalesceAssignment;
    public static string UseConditionalExpressionForAssignment;
    public static string UseConditionalExpressionForReturn;
    public static string UseDeconstruction;
    public static string UseDefaultLiteral;
    public static string UseExplicitTupleName;
    public static string UseExplicitType;
    public static string UseExplicitTypeForConst;
    public static string UseExpressionBody;
    public static string UseExpressionBodyForLambda;
    public static string UseImplicitObjectCreation;
    public static string UseImplicitType;
    public static string UseIndexOperator;
    public static string UseInferredMemberName;
    public static string UseInterpolatedVerbatimString;
    public static string UseIsNotExpression;
    public static string UseIsNullCheck;
    public static string UseIsNullCheckForCastAndEqualityOperator;
    public static string UseIsNullCheckForReferenceEquals;
    public static string UseLocalFunction;
    public static string UseNameofInAttribute;
    public static string UseNotPattern;
    public static string UseNullCheckOverTypeCheck;
    public static string UseNullPropagation;
    public static string UseObjectInitializer;
    public static string UsePatternCombinators;
    public static string UsePatternMatchingAsAndMemberAccess;
    public static string UsePatternMatchingAsAndNullCheck;
    public static string UsePatternMatchingIsAndCastCheck;
    public static string UsePatternMatchingIsAndCastCheckWithoutName;
    public static string UsePrimaryConstructor;
    public static string UseRangeOperator;
    public static string UseSimpleUsingStatement;
    public static string UseSystemHashCode;
    public static string UseThrowExpression;
    public static string UseTupleSwap;
    public static string UseUtf8StringLiteral;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.PredefinedConfigurationFixProviderNames : object {
    public static string ConfigureCodeStyleOption;
    public static string ConfigureSeverity;
    public static string Suppression;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider : CodeFixProvider {
    [NullableAttribute("0")]
private static ImmutableArray`1<FixAllScope> s_defaultSupportedFixAllScopes;
    private bool _supportsFixAll;
    protected SyntaxEditorBasedCodeFixProvider(bool supportsFixAll);
    private static SyntaxEditorBasedCodeFixProvider();
    [NullableContextAttribute("2")]
public sealed virtual FixAllProvider GetFixAllProvider();
    protected void RegisterCodeFix(CodeFixContext context, string title, string equivalenceKey, Diagnostic diagnostic);
    protected void RegisterCodeFix(CodeFixContext context, string title, string equivalenceKey, CodeActionPriority priority, Diagnostic diagnostic);
    protected Func`2<CancellationToken, Task`1<Document>> GetDocumentUpdater(CodeFixContext context, Diagnostic diagnostic);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider/<FixAllWithEditorAsync>d__8")]
internal static Task`1<Document> FixAllWithEditorAsync(Document document, Func`2<SyntaxEditor, Task> editAsync, CancellationToken cancellationToken);
    protected abstract virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider/<<GetFixAllProvider>b__3_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__3_0(FixAllContext fixAllContext, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
internal static class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllHelper : object {
    [NullableContextAttribute("1")]
public static string GetDefaultFixAllTitle(FixAllScope fixAllScope, string title, Document triggerDocument, Project triggerProject);
}
internal static class Microsoft.CodeAnalysis.CodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Add_file_header { get; }
    internal static string Fix_name_violation_colon_0 { get; }
    internal static string Add_both { get; }
    internal static string Add_default_case { get; }
    internal static string Use_discarded_local { get; }
    internal static string Use_discard_underscore { get; }
    internal static string Remove_redundant_assignment { get; }
    internal static string Update_suppression_format { get; }
    internal static string Suppress_or_configure_issues { get; }
    internal static string Fix_all_occurrences_in { get; }
    internal static string Remove_extra_blank_lines { get; }
    internal static string Add_blank_line_after_block { get; }
    internal static string Make_class_abstract { get; }
    internal static string Make_member_static { get; }
    internal static string Add_explicit_cast { get; }
    internal static string Alias_ambiguous_type_0 { get; }
    internal static string Convert_type_to_0 { get; }
    internal static string Make_type_partial { get; }
    internal static string Add_member_name { get; }
    internal static string Add_parameter_to_0 { get; }
    internal static string Add_parameter_to_0_and_overrides_implementations { get; }
    internal static string Add_to_0 { get; }
    internal static string Related_method_signatures_found_in_metadata_will_not_be_updated { get; }
    internal static string Remove_async_modifier { get; }
    internal static string Take_0 { get; }
    internal static string Take_both { get; }
    internal static string Take_bottom { get; }
    internal static string Take_top { get; }
    internal static string Add_missing_param_nodes { get; }
    internal static string Remove_tag { get; }
    internal static string Make_method_synchronous { get; }
    internal static string _0_may_change_semantics { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Add_file_header();
    internal static string get_Fix_name_violation_colon_0();
    internal static string get_Add_both();
    internal static string get_Add_default_case();
    internal static string get_Use_discarded_local();
    internal static string get_Use_discard_underscore();
    internal static string get_Remove_redundant_assignment();
    internal static string get_Update_suppression_format();
    internal static string get_Suppress_or_configure_issues();
    internal static string get_Fix_all_occurrences_in();
    internal static string get_Remove_extra_blank_lines();
    internal static string get_Add_blank_line_after_block();
    internal static string get_Make_class_abstract();
    internal static string get_Make_member_static();
    internal static string get_Add_explicit_cast();
    internal static string get_Alias_ambiguous_type_0();
    internal static string get_Convert_type_to_0();
    internal static string get_Make_type_partial();
    internal static string get_Add_member_name();
    internal static string get_Add_parameter_to_0();
    internal static string get_Add_parameter_to_0_and_overrides_implementations();
    internal static string get_Add_to_0();
    internal static string get_Related_method_signatures_found_in_metadata_will_not_be_updated();
    internal static string get_Remove_async_modifier();
    internal static string get_Take_0();
    internal static string get_Take_both();
    internal static string get_Take_bottom();
    internal static string get_Take_top();
    internal static string get_Add_missing_param_nodes();
    internal static string get_Remove_tag();
    internal static string get_Make_method_synchronous();
    internal static string get__0_may_change_semantics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1 : object {
    private ISymbolDeclarationService _symbolDeclarationService;
    [CompilerGeneratedAttribute]
private LanguageServices <LanguageServices>k__BackingField;
    public LanguageServices LanguageServices { get; }
    public CodeGenerationOptions DefaultOptions { get; }
    protected AbstractCodeGenerationService`1(LanguageServices languageServices);
    [CompilerGeneratedAttribute]
public LanguageServices get_LanguageServices();
    public abstract virtual CodeGenerationOptions get_DefaultOptions();
    public abstract virtual CodeGenerationOptions GetCodeGenerationOptions(IOptionsReader options, CodeGenerationOptions fallbackOptions);
    public abstract virtual TCodeGenerationContextInfo GetInfo(CodeGenerationContext context, CodeGenerationOptions options, ParseOptions parseOptions);
    private sealed virtual override CodeGenerationContextInfo Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.GetInfo(CodeGenerationContext context, CodeGenerationOptions options, ParseOptions parseOptions);
    public sealed virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TNode WithAnnotations(TNode node, CodeGenerationContextInfo info);
    public sealed virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected static T Cast(object value);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<GetEditAsync>d__61")]
private Task`1<Document> GetEditAsync(CodeGenerationSolutionContext context, INamespaceOrTypeSymbol destination, Func`5<SyntaxNode, TCodeGenerationContextInfo, IList`1<bool>, CancellationToken, SyntaxNode> declarationTransform, CancellationToken cancellationToken);
    protected TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToEndOfDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToAppropriateLocationInDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private SyntaxNode GetNewMember(TCodeGenerationContextInfo info, CodeGenerationDestination codeGenerationDestination, ISymbol member, CancellationToken cancellationToken);
    private TDeclarationNode UpdateDestination(IList`1<bool> availableIndices, TCodeGenerationContextInfo info, TDeclarationNode currentDestination, ISymbol member, CancellationToken cancellationToken);
    private static bool GeneratingEnum(IEnumerable`1<ISymbol> members);
    protected abstract virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected static TCodeGenerationContextInfo CreateContextInfoForMultipleMembers(TCodeGenerationContextInfo info);
    public virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddFieldAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddPropertyAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMethodAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMembersAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceOrTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    protected static void CheckLocation(SyntaxNode destinationMember, Location location);
    protected static void ComputePositionAndTriviaForRemoveAttributeList(SyntaxNode attributeList, Func`2<SyntaxTrivia, bool> isEndOfLineTrivia, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static void ComputePositionAndTriviaForRemoveAttributeFromAttributeList(SyntaxNode attributeToRemove, Func`2<SyntaxToken, bool> isComma, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static T AppendTriviaAtPosition(T node, int position, SyntaxTriviaList trivia);
    protected static SyntaxTokenList GetUpdatedDeclarationAccessibilityModifiers(ArrayBuilder`1<SyntaxToken> newModifierTokens, SyntaxTokenList modifiersList, Func`2<SyntaxToken, bool> isAccessibilityModifier);
    protected abstract virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private IList`1<bool> GetAvailableInsertionIndices(TDeclarationNode destination, CancellationToken cancellationToken);
    public sealed virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    protected static SyntaxToken GetEndToken(SyntaxNode node);
    protected static TextSpan GetSpan(SyntaxNode node);
    public sealed virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken, IList`1& availableIndices, bool checkGeneratedCode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<FindMostRelevantNameSpaceOrTypeDeclarationAsync>d__91")]
public sealed virtual Task`1<SyntaxNode> FindMostRelevantNameSpaceOrTypeDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<FindMostRelevantDeclarationAsync>d__92")]
private Task`1<ValueTuple`2<SyntaxNode, IList`1<bool>>> FindMostRelevantDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<SelectFirstOrDefaultAsync>d__93")]
private static Task`1<SyntaxNode> SelectFirstOrDefaultAsync(IEnumerable`1<SyntaxReference> references, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractFlagsEnumGenerator : object {
    protected abstract virtual SyntaxNode CreateExplicitlyCastedLiteralValue(SyntaxGenerator generator, INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected abstract virtual bool IsValidName(INamedTypeSymbol enumType, string name);
    public SyntaxNode CreateEnumConstantValue(SyntaxGenerator generator, INamedTypeSymbol enumType, object constantValue);
    private static bool IsFlagsEnum(INamedTypeSymbol typeSymbol);
    private SyntaxNode CreateFlagsEnumConstantValue(SyntaxGenerator generator, INamedTypeSymbol enumType, object constantValue);
    private SyntaxNode CreateFlagsEnumConstantValue(SyntaxGenerator generator, INamedTypeSymbol enumType, object constantValue, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues, List`1<ValueTuple`2<IFieldSymbol, ulong>> usedFieldsAndValues);
    private SyntaxNode CreateMemberAccessExpression(SyntaxGenerator generator, IFieldSymbol field, INamedTypeSymbol enumType, SpecialType underlyingSpecialType);
    [NullableContextAttribute("2")]
private static IFieldSymbol GetZeroField(List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private void GetSortedEnumFieldsAndValues(INamedTypeSymbol enumType, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private SyntaxNode CreateNonFlagsEnumConstantValue(SyntaxGenerator generator, INamedTypeSymbol enumType, object constantValue);
    private sealed virtual override int System.Collections.Generic.IComparer<System.ValueTuple<Microsoft.CodeAnalysis.IFieldSymbol,System.UInt64>>.Compare(ValueTuple`2<IFieldSymbol, ulong> x, ValueTuple`2<IFieldSymbol, ulong> y);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractMethodSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private IMethodSymbol <OriginalDefinition>k__BackingField;
    private ImmutableArray`1<AttributeData> _returnTypeAttributes;
    public IMethodSymbol OriginalDefinition { get; protected set; }
    public int Arity { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public bool IsPartialDefinition { get; }
    public NullableAnnotation ReceiverNullableAnnotation { get; }
    public NullableAnnotation ReturnNullableAnnotation { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ITypeSymbol ReceiverType { get; }
    public MethodKind MethodKind { get; }
    public SymbolKind Kind { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public ISymbol ContainingSymbol { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public bool IsConditional { get; }
    public SignatureCallingConvention CallingConvention { get; }
    public ImmutableArray`1<INamedTypeSymbol> UnmanagedCallingConventionTypes { get; }
    protected CodeGenerationAbstractMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(IMethodSymbol value);
    public virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual int get_Arity();
    public abstract virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual bool get_ReturnsByRef();
    public abstract virtual bool get_ReturnsByRefReadonly();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public abstract virtual bool get_IsPartialDefinition();
    public sealed virtual NullableAnnotation get_ReceiverNullableAnnotation();
    public sealed virtual NullableAnnotation get_ReturnNullableAnnotation();
    public sealed virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual ITypeSymbol get_ReceiverType();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual MethodKind get_MethodKind();
    public virtual SymbolKind get_Kind();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVararg();
    public sealed virtual bool get_IsCheckedBuiltin();
    public virtual ISymbol get_ContainingSymbol();
    public virtual bool get_HidesBaseMethodsByName();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ISymbol get_AssociatedSymbol();
    public sealed virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
    public sealed virtual bool get_IsConditional();
    public sealed virtual SignatureCallingConvention get_CallingConvention();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_UnmanagedCallingConventionTypes();
    public sealed virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual IMethodSymbol Construct(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<NullableAnnotation> typeArgumentNullableAnnotations);
    public sealed virtual DllImportData GetDllImportData();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractNamedTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <OriginalDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IFieldSymbol> <TupleElements>k__BackingField;
    internal ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> TypeMembers;
    [CompilerGeneratedAttribute]
private ISymbol <AssociatedSymbol>k__BackingField;
    public INamedTypeSymbol OriginalDefinition { get; protected set; }
    public ImmutableArray`1<IFieldSymbol> TupleElements { get; protected set; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public string MetadataName { get; }
    public ISymbol AssociatedSymbol { get; internal set; }
    public bool MightContainExtensionMethods { get; }
    public bool IsComImport { get; }
    public bool IsUnmanagedType { get; }
    public bool IsRefLikeType { get; }
    public INamedTypeSymbol NativeIntegerUnderlyingType { get; }
    public INamedTypeSymbol TupleUnderlyingType { get; }
    public bool IsSerializable { get; }
    public bool IsFileLocal { get; }
    protected CodeGenerationAbstractNamedTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, NullableAnnotation nullableAnnotation, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IFieldSymbol> get_TupleElements();
    [CompilerGeneratedAttribute]
protected void set_TupleElements(ImmutableArray`1<IFieldSymbol> value);
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual INamedTypeSymbol Construct(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<NullableAnnotation> typeArgumentNullableAnnotations);
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected abstract virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public sealed virtual ImmutableArray`1<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal);
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual string get_MetadataName();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_AssociatedSymbol();
    [CompilerGeneratedAttribute]
internal void set_AssociatedSymbol(ISymbol value);
    public sealed virtual bool get_MightContainExtensionMethods();
    public sealed virtual bool get_IsComImport();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_IsRefLikeType();
    public sealed virtual INamedTypeSymbol get_NativeIntegerUnderlyingType();
    public sealed virtual INamedTypeSymbol get_TupleUnderlyingType();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsFileLocal();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationArrayTypeSymbol : CodeGenerationTypeSymbol {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol ElementType { get; }
    public int Rank { get; }
    public bool IsSZArray { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public NullableAnnotation ElementNullableAnnotation { get; }
    [NullableContextAttribute("1")]
public CodeGenerationArrayTypeSymbol(ITypeSymbol elementType, int rank, NullableAnnotation nullableAnnotation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Rank();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual ImmutableArray`1<int> get_Sizes();
    public sealed virtual ImmutableArray`1<int> get_LowerBounds();
    [NullableContextAttribute("1")]
protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    [NullableContextAttribute("1")]
public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    [NullableContextAttribute("1")]
public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual NullableAnnotation get_ElementNullableAnnotation();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IArrayTypeSymbol other);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAttributeData : AttributeData {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <attributeClass>P;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public CodeGenerationAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedMethodSymbol : CodeGenerationAbstractMethodSymbol {
    private CodeGenerationAbstractMethodSymbol _constructedFrom;
    private ImmutableArray`1<ITypeSymbol> _typeArguments;
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRefReadonly { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public bool IsPartialDefinition { get; }
    public CodeGenerationConstructedMethodSymbol(CodeGenerationAbstractMethodSymbol constructedFrom, ImmutableArray`1<ITypeSymbol> typeArguments);
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual RefKind get_RefKind();
    public virtual bool get_ReturnsByRefReadonly();
    public virtual ITypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsInitOnly();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual bool get_IsPartialDefinition();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private CodeGenerationNamedTypeSymbol _constructedFrom;
    private ImmutableArray`1<ITypeSymbol> _typeArguments;
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public TypeKind TypeKind { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public CodeGenerationConstructedNamedTypeSymbol(CodeGenerationNamedTypeSymbol constructedFrom, ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual TypeKind get_TypeKind();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationConstructorInfo> s_constructorToInfoMap;
    private bool _isPrimaryConstructor;
    private bool _isUnsafe;
    private string _typeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _baseConstructorArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _thisConstructorArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationConstructorInfo(bool isPrimaryConstructor, bool isUnsafe, string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo();
    public static void Attach(IMethodSymbol constructor, bool isPrimaryConstructor, bool isUnsafe, string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol constructor);
    public static string GetTypeName(IMethodSymbol constructor);
    public static bool GetIsUnsafe(IMethodSymbol constructor);
    public static bool GetIsPrimaryConstructor(IMethodSymbol constructor);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationConstructorInfo info);
    private static string GetTypeName(CodeGenerationConstructorInfo info, IMethodSymbol constructor);
    [NullableContextAttribute("2")]
private static bool GetIsUnsafe(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static bool GetIsPrimaryConstructor(CodeGenerationConstructorInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConstructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ImmutableArray`1<IParameterSymbol> parameters);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext : object {
    [NullableAttribute("1")]
public static CodeGenerationContext Default;
    [CompilerGeneratedAttribute]
private Location <ContextLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <AfterThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <BeforeThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddImports>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<INamespaceSymbol> <AdditionalImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeNestedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDefaultAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMethodBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDocumentationComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoInsertionLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReuseSyntax>k__BackingField;
    public Location ContextLocation { get; }
    public Location AfterThisLocation { get; }
    public Location BeforeThisLocation { get; }
    public bool AddImports { get; }
    [NullableAttribute("1")]
public IEnumerable`1<INamespaceSymbol> AdditionalImports { get; }
    public bool GenerateMembers { get; }
    public bool MergeNestedNamespaces { get; }
    public bool MergeAttributes { get; }
    public bool GenerateDefaultAccessibility { get; }
    public bool GenerateMethodBodies { get; }
    public bool GenerateDocumentationComments { get; }
    public bool AutoInsertionLocation { get; }
    public bool SortMembers { get; }
    public bool ReuseSyntax { get; }
    internal Location BestLocation { get; }
    public CodeGenerationContext(Location contextLocation, Location afterThisLocation, Location beforeThisLocation, bool addImports, IEnumerable`1<INamespaceSymbol> additionalImports, bool generateMembers, bool mergeNestedNamespaces, bool mergeAttributes, bool generateDefaultAccessibility, bool generateMethodBodies, bool generateDocumentationComments, bool autoInsertionLocation, bool sortMembers, bool reuseSyntax);
    private static CodeGenerationContext();
    [CompilerGeneratedAttribute]
public Location get_ContextLocation();
    [CompilerGeneratedAttribute]
public Location get_AfterThisLocation();
    [CompilerGeneratedAttribute]
public Location get_BeforeThisLocation();
    [CompilerGeneratedAttribute]
public bool get_AddImports();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<INamespaceSymbol> get_AdditionalImports();
    [CompilerGeneratedAttribute]
public bool get_GenerateMembers();
    [CompilerGeneratedAttribute]
public bool get_MergeNestedNamespaces();
    [CompilerGeneratedAttribute]
public bool get_MergeAttributes();
    [CompilerGeneratedAttribute]
public bool get_GenerateDefaultAccessibility();
    [CompilerGeneratedAttribute]
public bool get_GenerateMethodBodies();
    [CompilerGeneratedAttribute]
public bool get_GenerateDocumentationComments();
    [CompilerGeneratedAttribute]
public bool get_AutoInsertionLocation();
    [CompilerGeneratedAttribute]
public bool get_SortMembers();
    [CompilerGeneratedAttribute]
public bool get_ReuseSyntax();
    [NullableContextAttribute("1")]
private static void CheckLocation(Location location, string name);
    internal Location get_BestLocation();
    [NullableContextAttribute("0")]
public CodeGenerationContext With(Optional`1<Location> contextLocation, Optional`1<Location> afterThisLocation, Optional`1<Location> beforeThisLocation, Optional`1<bool> addImports, Optional`1<IEnumerable`1<INamespaceSymbol>> additionalImports, Optional`1<bool> generateMembers, Optional`1<bool> mergeNestedNamespaces, Optional`1<bool> mergeAttributes, Optional`1<bool> generateDefaultAccessibility, Optional`1<bool> generateMethodBodies, Optional`1<bool> generateDocumentationComments, Optional`1<bool> autoInsertionLocation, Optional`1<bool> sortMembers, Optional`1<bool> reuseSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo : object {
    public CodeGenerationContext Context;
    public SyntaxGenerator Generator { get; }
    public CodeGenerationOptions Options { get; }
    public ICodeGenerationService Service { get; }
    protected SyntaxGenerator GeneratorImpl { get; }
    protected CodeGenerationOptions OptionsImpl { get; }
    protected ICodeGenerationService ServiceImpl { get; }
    protected CodeGenerationContextInfo(CodeGenerationContext context);
    public CodeGenerationContextInfo WithContext(CodeGenerationContext value);
    public SyntaxGenerator get_Generator();
    public CodeGenerationOptions get_Options();
    public ICodeGenerationService get_Service();
    protected abstract virtual SyntaxGenerator get_GeneratorImpl();
    protected abstract virtual CodeGenerationOptions get_OptionsImpl();
    protected abstract virtual ICodeGenerationService get_ServiceImpl();
    protected abstract virtual CodeGenerationContextInfo WithContextImpl(CodeGenerationContext value);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConversionSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConversionSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public virtual MethodKind get_MethodKind();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination : Enum {
    public int value__;
    public static CodeGenerationDestination Unspecified;
    public static CodeGenerationDestination CompilationUnit;
    public static CodeGenerationDestination Namespace;
    public static CodeGenerationDestination ClassType;
    public static CodeGenerationDestination EnumType;
    public static CodeGenerationDestination InterfaceType;
    public static CodeGenerationDestination ModuleType;
    public static CodeGenerationDestination StructType;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationDestructorInfo> s_destructorToInfoMap;
    private string _typeName;
    private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationDestructorInfo(string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo();
    public static void Attach(IMethodSymbol destructor, string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol destructor);
    public static string GetTypeName(IMethodSymbol destructor);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationDestructorInfo info);
    private static string GetTypeName(CodeGenerationDestructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationDestructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventInfo : object {
    private static ConditionalWeakTable`2<IEventSymbol, CodeGenerationEventInfo> s_eventToInfoMap;
    private bool _isUnsafe;
    private CodeGenerationEventInfo(bool isUnsafe);
    private static CodeGenerationEventInfo();
    public static void Attach(IEventSymbol event, bool isUnsafe);
    private static CodeGenerationEventInfo GetInfo(IEventSymbol event);
    public static bool GetIsUnsafe(IEventSymbol event);
    private static bool GetIsUnsafe(CodeGenerationEventInfo info);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventSymbol : CodeGenerationSymbol {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IEventSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RemoveMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RaiseMethod>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("1")]
public IEventSymbol OriginalDefinition { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public IEventSymbol OverriddenEvent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationEventSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_AddMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RemoveMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RaiseMethod();
    [NullableContextAttribute("1")]
protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    [NullableContextAttribute("1")]
public virtual void Accept(SymbolVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    [NullableContextAttribute("1")]
public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [NullableContextAttribute("1")]
public sealed virtual IEventSymbol get_OriginalDefinition();
    public sealed virtual bool get_IsWindowsRuntimeEvent();
    public sealed virtual IEventSymbol get_OverriddenEvent();
    public static ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldInfo : object {
    private static ConditionalWeakTable`2<IFieldSymbol, CodeGenerationFieldInfo> s_fieldToInfoMap;
    private bool _isUnsafe;
    private bool _isWithEvents;
    private SyntaxNode _initializer;
    private CodeGenerationFieldInfo(bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo();
    public static void Attach(IFieldSymbol field, bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo GetInfo(IFieldSymbol field);
    private static bool GetIsUnsafe(CodeGenerationFieldInfo info);
    public static bool GetIsUnsafe(IFieldSymbol field);
    private static bool GetIsWithEvents(CodeGenerationFieldInfo info);
    public static bool GetIsWithEvents(IFieldSymbol field);
    private static SyntaxNode GetInitializer(CodeGenerationFieldInfo info);
    public static SyntaxNode GetInitializer(IFieldSymbol field);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstantValue>k__BackingField;
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public object ConstantValue { get; }
    public bool HasConstantValue { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public IFieldSymbol CorrespondingTupleField { get; }
    public SymbolKind Kind { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsRequired { get; }
    public bool IsFixedSizeBuffer { get; }
    public int FixedSize { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public bool IsExplicitlyNamedTupleElement { get; }
    public CodeGenerationFieldSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ConstantValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstantValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IFieldSymbol get_OriginalDefinition();
    public sealed virtual IFieldSymbol get_CorrespondingTupleField();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsConst();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsRequired();
    public sealed virtual bool get_IsFixedSizeBuffer();
    public sealed virtual int get_FixedSize();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ISymbol get_AssociatedSymbol();
    public sealed virtual bool get_IsExplicitlyNamedTupleElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationHelpers : object {
    public static SyntaxNode GenerateThrowStatement(SyntaxGenerator factory, SemanticDocument document, string exceptionMetadataName);
    public static TSyntaxNode AddAnnotationsTo(ISymbol symbol, TSyntaxNode syntax);
    public static TSyntaxNode AddFormatterAndCodeGeneratorAnnotationsTo(TSyntaxNode node);
    public static void GetNameAndInnermostNamespace(INamespaceSymbol namespace, CodeGenerationContextInfo info, String& name, INamespaceSymbol& innermostNamespace);
    [NullableContextAttribute("2")]
public static bool IsSpecialType(ITypeSymbol type, SpecialType specialType);
    [NullableContextAttribute("2")]
public static int GetPreferredIndex(int index, IList`1<bool> availableIndices, bool forward);
    public static bool TryGetDocumentationComment(ISymbol symbol, string commentToken, String& comment, CancellationToken cancellationToken);
    public static bool TypesMatch(ITypeSymbol type, object value);
    public static IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol namedType);
    public static T RemoveLeadingDirectiveTrivia(T node);
    public static T GetReuseableSyntaxNodeForAttribute(AttributeData attribute, CodeGenerationContextInfo info);
    public static int GetInsertionIndex(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CodeGenerationContextInfo info, IList`1<bool> availableIndices, IComparer`1<TDeclaration> comparerWithoutNameCheck, IComparer`1<TDeclaration> comparerWithNameCheck, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    public static Nullable`1<int> TryGetDesiredIndexIfGrouped(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
    private static Nullable`1<int> TryGetDesiredIndexIfGroupedWorker(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
    public static bool IsCompilerInternalAttribute(AttributeData attribute);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationMethodInfo> s_methodToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private bool _isPartial;
    private bool _isAsync;
    private ImmutableArray`1<SyntaxNode> _statements;
    private ImmutableArray`1<SyntaxNode> _handlesExpressions;
    private CodeGenerationMethodInfo(bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo();
    public static void Attach(IMethodSymbol method, bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(IMethodSymbol method);
    public static bool GetIsNew(IMethodSymbol method);
    public static bool GetIsUnsafe(IMethodSymbol method);
    public static bool GetIsPartial(IMethodSymbol method);
    public static bool GetIsAsyncMethod(IMethodSymbol method);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationMethodInfo info);
    private static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(CodeGenerationMethodInfo info);
    private static bool GetIsNew(CodeGenerationMethodInfo info);
    private static bool GetIsUnsafe(CodeGenerationMethodInfo info);
    private static bool GetIsPartial(CodeGenerationMethodInfo info);
    private static bool GetIsAsyncMethod(CodeGenerationMethodInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodSymbol : CodeGenerationAbstractMethodSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeParameterSymbol> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodKind <MethodKind>k__BackingField;
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitOnly>k__BackingField;
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public bool IsPartialDefinition { get; }
    public CodeGenerationMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml, MethodKind methodKind, bool isInitOnly);
    [CompilerGeneratedAttribute]
public virtual ITypeSymbol get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual bool get_ReturnsByRefReadonly();
    [CompilerGeneratedAttribute]
public virtual RefKind get_RefKind();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual bool get_IsInitOnly();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual bool get_IsPartialDefinition();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private ImmutableArray`1<ITypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<INamedTypeSymbol> _interfaces;
    private ImmutableArray`1<ISymbol> _members;
    [CompilerGeneratedAttribute]
private bool <IsRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <EnumUnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <BaseType>k__BackingField;
    public bool IsRecord { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    public static ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public CodeGenerationNamedTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, bool isRecord, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, NullableAnnotation nullableAnnotation, ImmutableArray`1<ISymbol> members, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers, INamedTypeSymbol enumUnderlyingType);
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
public virtual bool get_IsRecord();
    [CompilerGeneratedAttribute]
public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    [CompilerGeneratedAttribute]
public virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public static ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    [CompilerGeneratedAttribute]
public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceInfo : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, CodeGenerationNamespaceInfo> s_namespaceToInfoMap;
    private IList`1<ISymbol> _imports;
    private CodeGenerationNamespaceInfo(IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo();
    public static void Attach(INamespaceSymbol namespace, IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo GetInfo(INamespaceSymbol namespace);
    public static IList`1<ISymbol> GetImports(INamespaceSymbol namespace);
    private static IList`1<ISymbol> GetImports(CodeGenerationNamespaceInfo info);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceOrTypeSymbol : CodeGenerationSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    protected CodeGenerationNamespaceOrTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public sealed virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceSymbol : CodeGenerationNamespaceOrTypeSymbol {
    private IList`1<INamespaceOrTypeSymbol> _members;
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public SymbolKind Kind { get; }
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public static INamedTypeSymbol ImplicitType { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public CodeGenerationNamespaceSymbol(string name, IList`1<INamespaceOrTypeSymbol> members);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(string name);
    public sealed virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public sealed virtual bool get_IsGlobalNamespace();
    public sealed virtual NamespaceKind get_NamespaceKind();
    public sealed virtual Compilation get_ContainingCompilation();
    public static INamedTypeSymbol get_ImplicitType();
    public sealed virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind : Enum {
    public int value__;
    public static CodeGenerationOperatorKind Addition;
    public static CodeGenerationOperatorKind BitwiseAnd;
    public static CodeGenerationOperatorKind BitwiseOr;
    public static CodeGenerationOperatorKind Concatenate;
    public static CodeGenerationOperatorKind Decrement;
    public static CodeGenerationOperatorKind Division;
    public static CodeGenerationOperatorKind Equality;
    public static CodeGenerationOperatorKind ExclusiveOr;
    public static CodeGenerationOperatorKind Exponent;
    public static CodeGenerationOperatorKind False;
    public static CodeGenerationOperatorKind GreaterThan;
    public static CodeGenerationOperatorKind GreaterThanOrEqual;
    public static CodeGenerationOperatorKind Increment;
    public static CodeGenerationOperatorKind Inequality;
    public static CodeGenerationOperatorKind IntegerDivision;
    public static CodeGenerationOperatorKind LeftShift;
    public static CodeGenerationOperatorKind LessThan;
    public static CodeGenerationOperatorKind LessThanOrEqual;
    public static CodeGenerationOperatorKind Like;
    public static CodeGenerationOperatorKind LogicalNot;
    public static CodeGenerationOperatorKind Modulus;
    public static CodeGenerationOperatorKind Multiplication;
    public static CodeGenerationOperatorKind OnesComplement;
    public static CodeGenerationOperatorKind RightShift;
    public static CodeGenerationOperatorKind Subtraction;
    public static CodeGenerationOperatorKind True;
    public static CodeGenerationOperatorKind UnaryPlus;
    public static CodeGenerationOperatorKind UnaryNegation;
    public static CodeGenerationOperatorKind UnsignedRightShift;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationOperatorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    public virtual MethodKind get_MethodKind();
    public static int GetParameterCount(CodeGenerationOperatorKind operatorKind);
    private static string GetMetadataName(CodeGenerationOperatorKind operatorKind);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationParameterSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplicitDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExplicitDefaultValue>k__BackingField;
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    private bool Microsoft.CodeAnalysis.IParameterSymbol.IsParamsArray { get; }
    private bool Microsoft.CodeAnalysis.IParameterSymbol.IsParamsCollection { get; }
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsOptional { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public SymbolKind Kind { get; }
    public bool IsThis { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ScopedKind ScopedKind { get; }
    public bool IsDiscard { get; }
    public CodeGenerationParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual RefKind get_RefKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsParams();
    private sealed virtual override bool Microsoft.CodeAnalysis.IParameterSymbol.get_IsParamsArray();
    private sealed virtual override bool Microsoft.CodeAnalysis.IParameterSymbol.get_IsParamsCollection();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasExplicitDefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ExplicitDefaultValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IParameterSymbol get_OriginalDefinition();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsThis();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ScopedKind get_ScopedKind();
    public sealed virtual bool get_IsDiscard();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPointerTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <PointedAtType>k__BackingField;
    public ITypeSymbol PointedAtType { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationPointerTypeSymbol(ITypeSymbol pointedAtType);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_PointedAtType();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertyInfo : object {
    private static ConditionalWeakTable`2<IPropertySymbol, CodeGenerationPropertyInfo> s_propertyToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private SyntaxNode _initializer;
    private CodeGenerationPropertyInfo(bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo();
    public static void Attach(IPropertySymbol property, bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo GetInfo(IPropertySymbol property);
    public static SyntaxNode GetInitializer(CodeGenerationPropertyInfo info);
    public static SyntaxNode GetInitializer(IPropertySymbol property);
    public static bool GetIsNew(IPropertySymbol property);
    public static bool GetIsUnsafe(IPropertySymbol property);
    private static bool GetIsNew(CodeGenerationPropertyInfo info);
    private static bool GetIsUnsafe(CodeGenerationPropertyInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertySymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private RefKind <refKind>P;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IPropertySymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <SetMethod>k__BackingField;
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsIndexer { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public SymbolKind Kind { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public bool IsRequired { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public bool IsWithEvents { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public IPropertySymbol PartialImplementationPart { get; }
    public IPropertySymbol PartialDefinitionPart { get; }
    public bool IsPartialDefinition { get; }
    public CodeGenerationPropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, bool isIndexer, ImmutableArray`1<IParameterSymbol> parametersOpt, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_GetMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_SetMethod();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsWriteOnly();
    public sealed virtual bool get_IsRequired();
    public sealed virtual IPropertySymbol get_OriginalDefinition();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual bool get_ReturnsByRef();
    public sealed virtual bool get_ReturnsByRefReadonly();
    public sealed virtual IPropertySymbol get_OverriddenProperty();
    public sealed virtual bool get_IsWithEvents();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public sealed virtual IPropertySymbol get_PartialImplementationPart();
    public sealed virtual IPropertySymbol get_PartialDefinitionPart();
    public sealed virtual bool get_IsPartialDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext : ValueType {
    [CompilerGeneratedAttribute]
private Solution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenerationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAndImportGenerationOptionsProvider <FallbackOptions>k__BackingField;
    public Solution Solution { get; public set; }
    public CodeGenerationContext Context { get; public set; }
    public CodeAndImportGenerationOptionsProvider FallbackOptions { get; public set; }
    public CodeGenerationSolutionContext(Solution Solution, CodeGenerationContext Context, CodeAndImportGenerationOptionsProvider FallbackOptions);
    [CompilerGeneratedAttribute]
public Solution get_Solution();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Solution(Solution value);
    [CompilerGeneratedAttribute]
public CodeGenerationContext get_Context();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Context(CodeGenerationContext value);
    [CompilerGeneratedAttribute]
public CodeAndImportGenerationOptionsProvider get_FallbackOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FallbackOptions(CodeAndImportGenerationOptionsProvider value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CodeGenerationSolutionContext left, CodeGenerationSolutionContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CodeGenerationSolutionContext left, CodeGenerationSolutionContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeGenerationSolutionContext other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Solution& Solution, CodeGenerationContext& Context, CodeAndImportGenerationOptionsProvider& FallbackOptions);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbol : object {
    protected static ConditionalWeakTable`2<CodeGenerationSymbol, SyntaxAnnotation[]> annotationsTable;
    private ImmutableArray`1<AttributeData> _attributes;
    protected string _documentationCommentXml;
    [CompilerGeneratedAttribute]
private Accessibility <DeclaredAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblySymbol <ContainingAssembly>k__BackingField;
    public Accessibility DeclaredAccessibility { get; }
    protected internal DeclarationModifiers Modifiers { get; }
    public string Name { get; }
    public INamedTypeSymbol ContainingType { get; protected set; }
    public SymbolKind Kind { get; }
    public string Language { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public static IMethodSymbol ContainingMethod { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public static ImmutableArray`1<SyntaxNode> DeclaringSyntaxNodes { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ISymbol OriginalDefinition { get; }
    public string MetadataName { get; }
    public int MetadataToken { get; }
    public bool HasUnsupportedMetadata { get; }
    protected CodeGenerationSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, string documentationCommentXml);
    private static CodeGenerationSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual Accessibility get_DeclaredAccessibility();
    [CompilerGeneratedAttribute]
protected internal DeclarationModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_ContainingType();
    [CompilerGeneratedAttribute]
protected void set_ContainingType(INamedTypeSymbol value);
    protected abstract virtual CodeGenerationSymbol Clone();
    internal SyntaxAnnotation[] GetAnnotations();
    internal CodeGenerationSymbol WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    private static CodeGenerationSymbol AddAnnotationsTo(CodeGenerationSymbol originalDefinition, CodeGenerationSymbol newDefinition, SyntaxAnnotation[] annotations);
    public abstract virtual SymbolKind get_Kind();
    public sealed virtual string get_Language();
    public virtual ISymbol get_ContainingSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual IAssemblySymbol get_ContainingAssembly();
    public static IMethodSymbol get_ContainingMethod();
    public sealed virtual IModuleSymbol get_ContainingModule();
    public sealed virtual INamespaceSymbol get_ContainingNamespace();
    public sealed virtual bool get_IsDefinition();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_CanBeReferencedByName();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public static ImmutableArray`1<SyntaxNode> get_DeclaringSyntaxNodes();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<AttributeData> GetAttributes();
    public ImmutableArray`1<AttributeData> GetAttributes(INamedTypeSymbol attributeType);
    public ImmutableArray`1<AttributeData> GetAttributes(IMethodSymbol attributeConstructor);
    public sealed virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual string GetDocumentationCommentId();
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public sealed virtual string ToDisplayString(SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public virtual string get_MetadataName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public sealed virtual bool Equals(ISymbol other);
    public sealed virtual bool Equals(ISymbol other, SymbolEqualityComparer equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory : object {
    [ExtensionAttribute]
public static bool IsCodeGenerationSymbol(ISymbol symbol);
    public static IEventSymbol CreateEventSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    [NullableContextAttribute("2")]
internal static IPropertySymbol CreatePropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer, SyntaxNode initializer);
    public static IPropertySymbol CreatePropertySymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer);
    public static IFieldSymbol CreateFieldSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue, SyntaxNode initializer);
    public static IMethodSymbol CreateConstructorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, string typeName, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments, bool isPrimaryConstructor);
    public static IMethodSymbol CreateDestructorSymbol(ImmutableArray`1<AttributeData> attributes, string typeName, ImmutableArray`1<SyntaxNode> statements);
    internal static IMethodSymbol CreateMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind, bool isInitOnly);
    public static IMethodSymbol CreateMethodSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind, bool isInitOnly);
    public static IMethodSymbol CreateOperatorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    public static IMethodSymbol CreateConversionSymbol(ITypeSymbol toType, IParameterSymbol fromType, INamedTypeSymbol containingType, bool isImplicit, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public static IMethodSymbol CreateConversionSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, INamedTypeSymbol containingType, bool isImplicit, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public static IParameterSymbol CreateParameterSymbol(ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(RefKind refKind, ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    internal static IParameterSymbol CreateParameterSymbol(IParameterSymbol parameter, Nullable`1<ImmutableArray`1<AttributeData>> attributes, Nullable`1<RefKind> refKind, Nullable`1<bool> isParams, ITypeSymbol type, Optional`1<string> name, Nullable`1<bool> isOptional, Nullable`1<bool> hasDefaultValue, Optional`1<object> defaultValue);
    public static ITypeParameterSymbol CreateTypeParameterSymbol(string name, int ordinal);
    public static ITypeParameterSymbol CreateTypeParameter(ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, NullableAnnotation nullableAnnotation, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasUnmanagedConstraint, bool hasValueConstraint, bool hasNotNullConstraint, bool allowsRefLikeType, int ordinal);
    public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public static IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank, NullableAnnotation nullableAnnotation);
    internal static IMethodSymbol CreateAccessorSymbol(IMethodSymbol accessor, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, ImmutableArray`1<SyntaxNode> statements);
    public static IMethodSymbol CreateAccessorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, ImmutableArray`1<SyntaxNode> statements);
    public static AttributeData CreateAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    public static INamedTypeSymbol CreateNamedTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members, NullableAnnotation nullableAnnotation, IAssemblySymbol containingAssembly);
    public static INamedTypeSymbol CreateNamedTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, bool isRecord, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members, NullableAnnotation nullableAnnotation, IAssemblySymbol containingAssembly);
    public static CodeGenerationNamedTypeSymbol CreateDelegateTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, NullableAnnotation nullableAnnotation);
    public static INamespaceSymbol CreateNamespaceSymbol(string name, IList`1<ISymbol> imports, IList`1<INamespaceOrTypeSymbol> members);
    [NullableContextAttribute("2")]
internal static IMethodSymbol CreateMethodSymbol(IMethodSymbol method, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters, ImmutableArray`1<SyntaxNode> statements, INamedTypeSymbol containingType, ITypeSymbol returnType, Optional`1<ImmutableArray`1<AttributeData>> returnTypeAttributes);
    [NullableContextAttribute("2")]
internal static IPropertySymbol CreatePropertySymbol(IPropertySymbol property, ImmutableArray`1<AttributeData> attributes, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, Nullable`1<bool> isIndexer, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [NullableContextAttribute("2")]
internal static IEventSymbol CreateEventSymbol(IEventSymbol event, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod);
    internal static IFieldSymbol CreateFieldSymbol(IFieldSymbol field, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, string name);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeParameterSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private VarianceKind <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <ConstraintTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstructorConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReferenceTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsRefLikeType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnmanagedTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNotNullConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public VarianceKind Variance { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; internal set; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool AllowsRefLikeType { get; }
    public bool HasUnmanagedTypeConstraint { get; }
    public bool HasNotNullConstraint { get; }
    public int Ordinal { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public NullableAnnotation ReferenceTypeConstraintNullableAnnotation { get; }
    public ImmutableArray`1<NullableAnnotation> ConstraintNullableAnnotations { get; }
    public CodeGenerationTypeParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, NullableAnnotation nullableAnnotation, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasValueConstraint, bool hasUnmanagedConstraint, bool hasNotNullConstraint, bool allowsRefLikeType, int ordinal);
    [CompilerGeneratedAttribute]
public sealed virtual VarianceKind get_Variance();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    [CompilerGeneratedAttribute]
internal void set_ConstraintTypes(ImmutableArray`1<ITypeSymbol> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstructorConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasReferenceTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValueTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowsRefLikeType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasUnmanagedTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNotNullConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual ITypeParameterSymbol get_OriginalDefinition();
    public sealed virtual ITypeParameterSymbol get_ReducedFrom();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual TypeKind get_TypeKind();
    public sealed virtual TypeParameterKind get_TypeParameterKind();
    public sealed virtual IMethodSymbol get_DeclaringMethod();
    public sealed virtual INamedTypeSymbol get_DeclaringType();
    public sealed virtual NullableAnnotation get_ReferenceTypeConstraintNullableAnnotation();
    public sealed virtual ImmutableArray`1<NullableAnnotation> get_ConstraintNullableAnnotations();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeSymbol : CodeGenerationNamespaceOrTypeSymbol {
    [CompilerGeneratedAttribute]
private SpecialType <SpecialType>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableAnnotation <NullableAnnotation>k__BackingField;
    public SpecialType SpecialType { get; protected set; }
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public bool IsTupleType { get; }
    public bool IsNativeIntegerType { get; }
    public static ImmutableArray`1<ITypeSymbol> TupleElementTypes { get; }
    public static ImmutableArray`1<string> TupleElementNames { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public bool IsNamespace { get; }
    public bool IsType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsRefLikeType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsUnmanagedType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsReadOnly { get; }
    public bool IsRecord { get; }
    public NullableAnnotation NullableAnnotation { get; }
    protected CodeGenerationTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
public sealed virtual SpecialType get_SpecialType();
    [CompilerGeneratedAttribute]
protected void set_SpecialType(SpecialType value);
    public abstract virtual TypeKind get_TypeKind();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsAnonymousType();
    public sealed virtual bool get_IsTupleType();
    public sealed virtual bool get_IsNativeIntegerType();
    public static ImmutableArray`1<ITypeSymbol> get_TupleElementTypes();
    public static ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual ITypeSymbol get_OriginalDefinition();
    public sealed virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
    public sealed virtual string ToDisplayString(NullableFlowState topLevelNullability, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(NullableFlowState topLevelNullability, SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, NullableFlowState topLevelNullability, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, NullableFlowState topLevelNullability, int position, SymbolDisplayFormat format);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsRefLikeType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsUnmanagedType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsReadOnly();
    public virtual bool get_IsRecord();
    [CompilerGeneratedAttribute]
public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual ITypeSymbol WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    protected sealed virtual CodeGenerationSymbol Clone();
    protected abstract virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator : object {
    public static SyntaxAnnotation Annotation;
    private static CodeGenerator();
    private static ICodeGenerationService GetCodeGenerationService(SolutionServices services, string language);
    public static Task`1<Document> AddEventDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public static Task`1<Document> AddFieldDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public static Task`1<Document> AddMethodDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public static Task`1<Document> AddPropertyDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceOrTypeDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    public static Task`1<Document> AddMemberDeclarationsAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public static bool CanAdd(Solution solution, ISymbol destination, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService {
    public CodeGenerationOptions DefaultOptions { get; }
    public abstract virtual CodeGenerationOptions get_DefaultOptions();
    public abstract virtual CodeGenerationOptions GetCodeGenerationOptions(IOptionsReader options, CodeGenerationOptions fallbackOptions);
    public abstract virtual CodeGenerationContextInfo GetInfo(CodeGenerationContext context, CodeGenerationOptions options, ParseOptions parseOptions);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddFieldAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMethodAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddPropertyAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceOrTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMembersAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> FindMostRelevantNameSpaceOrTypeDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.INamedTypeSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CodeGenerationAbstractNamedTypeSymbol ToCodeGenerationSymbol(INamedTypeSymbol namedType);
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<byte, string>> ByteSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<sbyte, string>> SByteSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<short, string>> Int16SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<ushort, string>> UInt16SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<int, string>> Int32SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<UInt32, string>> UInt32SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<long, string>> Int64SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<ulong, string>> UInt64SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<float, string>> SingleSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<double, string>> DoubleSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<decimal, string>> DecimalSpecialValues;
    private static LiteralSpecialValues();
    public static bool HasSpecialValues(SpecialType specialType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.NullableSyntaxAnnotation : object {
    public static SyntaxAnnotation Oblivious;
    public static SyntaxAnnotation AnnotatedOrNotAnnotated;
    private static NullableSyntaxAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.SyntaxAnnotationExtensions : object {
    [ExtensionAttribute]
public static TSymbol AddAnnotationToSymbol(SyntaxAnnotation annotation, TSymbol symbol);
    internal static SyntaxAnnotation[] CombineAnnotations(SyntaxAnnotation[] originalAnnotations, SyntaxAnnotation[] newAnnotations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.TypeGenerator : object {
    public sealed virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public sealed virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public sealed virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider/<FixOneAsync>d__7")]
private Task`1<Document> FixOneAsync(CodeFixContext context, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider : CodeFixProvider {
    internal static string TakeTopEquivalenceKey;
    internal static string TakeBottomEquivalenceKey;
    internal static string TakeBothEquivalenceKey;
    private static int s_mergeConflictLength;
    private ISyntaxKinds _syntaxKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractResolveConflictMarkerCodeFixProvider(ISyntaxKinds syntaxKinds, string diagnosticId);
    private static AbstractResolveConflictMarkerCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<RegisterCodeFixesAsync>d__10")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private bool ShouldFix(SyntaxNode root, SourceText text, int position, TextLine& startLine, TextLine& firstMiddleLine, TextLine& secondMiddleLine, TextLine& endLine);
    private static bool TryGetConflictLines(SourceText text, int position, TextLine& startLine, TextLine& firstMiddleLine, TextLine& secondMiddleLine, TextLine& endLine);
    private static bool TryFindLineForwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool TryFindLineBackwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool IsConflictMarker(TextLine currentLine, char ch);
    private static void RegisterCodeFixes(CodeFixContext context, TextLine startLine, TextLine firstMiddleLine, TextLine secondMiddleLine, TextLine endLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<AddEditsAsync>d__17")]
private static Task`1<Document> AddEditsAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, Action`6<SourceText, ArrayBuilder`1<TextChange>, int, int, int, int> addEdits, CancellationToken cancellationToken);
    private static void AddTopEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static void AddBottomEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static void AddBothEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static Task`1<Document> TakeTopAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBottomAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBothAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static int GetEndIncludingLineBreak(SourceText text, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<FixAllAsync>d__25")]
private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, string equivalenceKey, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [CompilerGeneratedAttribute]
internal static CodeAction <RegisterCodeFixes>g__CreateCodeAction|16_3(string title, Func`2<CancellationToken, Task`1<Document>> action, string equivalenceKey);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<<GetFixAllProvider>b__26_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__26_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider : CodeFixProvider {
    protected abstract virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider/<GetCodeActionAsync>d__5")]
private Task`1<CodeAction> GetCodeActionAsync(SyntaxNode node, Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual string GetCodeFixTitle();
    protected abstract virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, TMemberAccessExpressionSyntax node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider`1/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public void ConvertTypeOfToNameOf(SemanticModel semanticModel, SyntaxEditor editor, TMemberAccessExpressionSyntax nodeToReplace, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProviders : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProviders/<GetAnalyzerOptionsProviderAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<AnalyzerOptionsProvider> GetAnalyzerOptionsProviderAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticPropertyConstants : object {
    public static string UnreferencedAssemblyIdentity;
    public static string RequiredLanguageVersion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4 : CodeFixProvider {
    protected string NodeName { get; }
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string get_NodeName();
    protected abstract virtual List`1<TXmlNameAttributeSyntax> GetNameAttributes(TXmlElementSyntax node);
    protected abstract virtual string GetValueFromNameAttribute(TXmlNameAttributeSyntax attribute);
    [NullableContextAttribute("2")]
protected abstract virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList parameter);
    protected abstract virtual string GetXmlElementLocalName(TXmlElementSyntax element);
    protected abstract virtual ImmutableArray`1<string> GetParameterNames(TMemberDeclarationSyntax method);
    protected abstract virtual TXmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4/<AddParamTagAsync>d__10")]
protected Task`1<Document> AddParamTagAsync(Document document, TMemberDeclarationSyntax parentMethod, SyntaxNode docCommentNode, CancellationToken cancellationToken);
    private List`1<TXmlElementSyntax> GetElementNodes(SyntaxNode docComment, string nodeName);
    private bool NodeExists(IEnumerable`1<TXmlElementSyntax> paramNodes, string name);
    protected TXmlElementSyntax GetParamNodeForParamName(IEnumerable`1<TXmlElementSyntax> paramNodeList, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2 : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string get_DocCommentSignifierToken();
    protected abstract virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual bool IsXmlNewLineToken(SyntaxToken token);
    protected abstract virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RegisterCodeFixesAsync>d__9")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static TXmlElementSyntax GetParamNode(SyntaxNode root, TextSpan span);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RemoveDuplicateParamTagAsync>d__11")]
private Task`1<Document> RemoveDuplicateParamTagAsync(Document document, TXmlElementSyntax paramNode, CancellationToken cancellationToken);
    private bool ShouldRemovePreviousSibling(List`1<SyntaxNode> paramNodeSiblings, int paramNodeIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Editing.AddParameterEditor : object {
    public static void AddParameter(ISyntaxFacts syntaxFacts, SyntaxEditor editor, SyntaxNode declaration, int insertionIndex, SyntaxNode parameterDeclaration, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxTrivia> GetDesiredLeadingIndentation(ISyntaxFacts syntaxFacts, SyntaxNode node, bool includeLeadingNewLine);
    private static bool ShouldPlaceParametersOnNewLine(IReadOnlyList`1<SyntaxNode> parameters, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal : object {
    public ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual SyntaxTrivia EndOfLine(string text);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken identifier, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(SyntaxToken name, SyntaxNode initializer);
    public abstract virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    public abstract virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    public abstract virtual SyntaxToken Identifier(string identifier);
    public abstract virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public abstract virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public abstract virtual SyntaxNode RefExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode AddParentheses(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public abstract virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public abstract virtual bool RequiresLocalDeclarationType();
    public abstract virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    public abstract virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    public abstract virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    public abstract virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    public abstract virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    public abstract virtual SyntaxNode InterpolationFormatClause(string format);
    public abstract virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    public abstract virtual SyntaxNode Type(ITypeSymbol typeSymbol, bool typeContext);
    public abstract virtual SyntaxNode NegateEquality(SyntaxGenerator generator, SyntaxNode binaryExpression, SyntaxNode left, BinaryOperatorKind negatedKind, SyntaxNode right);
    public abstract virtual SyntaxNode IsNotTypeExpression(SyntaxNode expression, SyntaxNode type);
    public abstract virtual bool SupportsPatterns(ParseOptions options);
    public abstract virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isToken, SyntaxNode pattern);
    public abstract virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    public abstract virtual SyntaxNode GreaterThanRelationalPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode GreaterThanEqualsRelationalPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode LessThanRelationalPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode LessThanEqualsRelationalPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode NotPattern(SyntaxNode pattern);
    public abstract virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    public abstract virtual SyntaxNode TypePattern(SyntaxNode type);
    public abstract virtual SyntaxNode UnaryPattern(SyntaxToken operatorToken, SyntaxNode pattern);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedDocumentAsync>d__6")]
private Task`1<Document> GetTransformedDocumentAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedSyntaxRootAsync>d__7")]
private Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedSyntaxRootAsync>d__8")]
internal static Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, Document document, string fileHeaderTemplate, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxNode AddHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxTriviaList CreateNewHeader(ISyntaxFacts syntaxFacts, string prefixWithLeadingSpaces, string expectedFileHeader, string newLineText);
    private static string GetCopyrightText(string prefixWithLeadingSpaces, string copyrightText, string newLineText);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<<GetFixAllProvider>b__13_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__13_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ITypeSymbol GetForEachElementType(SemanticModel semanticModel, TForEachStatementSyntax forEachStatement);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastCodeFixProvider`1/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public void AddCast(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxEditor editor, TForEachStatementSyntax forEachStatement, CancellationToken cancellationToken);
    private SyntaxNode GetRewrittenCollection(SyntaxGenerator generator, SyntaxNode collection, ITypeSymbol iterationVariableType, CommonConversion conversion);
}
internal static class Microsoft.CodeAnalysis.FormattingCodeFixHelper : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FormattingCodeFixHelper/<FixOneAsync>d__0")]
internal static Task`1<SyntaxTree> FixOneAsync(SyntaxTree syntaxTree, ISyntaxFormatting formattingProvider, SyntaxFormattingOptions options, Diagnostic diagnostic, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GeneratedCodeRecognition.AbstractGeneratedCodeRecognitionService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.AbstractGeneratedCodeRecognitionService/<IsGeneratedCodeAsync>d__0")]
public sealed virtual Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
    private static bool IsGeneratedCode(SyntaxTree syntaxTree, Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService {
    public abstract virtual Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.CodeStyleHostLanguageServices : HostLanguageServices {
    private static ConditionalWeakTable`2<HostLanguageServices, CodeStyleHostLanguageServices> s_mappedLanguageServices;
    private static ConditionalWeakTable`2<string, MefHostExportProvider> s_exportProvidersByLanguageCache;
    private HostLanguageServices _hostLanguageServices;
    private HostLanguageServices _codeStyleLanguageServices;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    private CodeStyleHostLanguageServices(HostLanguageServices hostLanguageServices);
    private static CodeStyleHostLanguageServices();
    [NullableContextAttribute("2")]
public static CodeStyleHostLanguageServices GetMappedCodeStyleLanguageServices(HostLanguageServices hostLanguageServices);
    public static CodeStyleHostLanguageServices GetRequiredMappedCodeStyleLanguageServices(HostLanguageServices hostLanguageServices);
    private static CodeStyleHostLanguageServices Create(HostLanguageServices hostLanguageServices);
    public virtual HostWorkspaceServices get_WorkspaceServices();
    public virtual string get_Language();
    [NullableContextAttribute("0")]
public virtual TLanguageService GetService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Host.HostWorkspaceServicesExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(HostWorkspaceServices hostWorkspaceServices, string languageName);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(HostWorkspaceServices hostWorkspaceServices, string languageName);
    [ExtensionAttribute]
public static HostLanguageServices GetExtendedLanguageServices(HostWorkspaceServices hostWorkspaceServices, string languageName);
}
internal interface Microsoft.CodeAnalysis.Host.ICommandLineParserService {
    public abstract virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
internal class Microsoft.CodeAnalysis.Host.Mef.CodeChangeProviderMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public IEnumerable`1<string> Languages { get; }
    public CodeChangeProviderMetadata(IDictionary`2<string, object> data);
    public CodeChangeProviderMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before, String[] languages);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
}
internal class Microsoft.CodeAnalysis.Host.Mef.FileExtensionsMetadata : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Extensions>k__BackingField;
    public IEnumerable`1<string> Extensions { get; }
    public FileExtensionsMetadata(IDictionary`2<string, object> data);
    public FileExtensionsMetadata(String[] extensions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Extensions();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata {
    public string Language { get; }
    public abstract virtual string get_Language();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata {
    public IEnumerable`1<string> Languages { get; }
    public abstract virtual IEnumerable`1<string> get_Languages();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.Mef.ILayeredServiceMetadata {
    public IReadOnlyList`1<string> WorkspaceKinds { get; }
    public string Layer { get; }
    public string ServiceType { get; }
    public abstract virtual IReadOnlyList`1<string> get_WorkspaceKinds();
    public abstract virtual string get_Layer();
    public abstract virtual string get_ServiceType();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider {
    public abstract virtual IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    public abstract virtual IEnumerable`1<Lazy`1<TExtension>> GetExports();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public LanguageMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WorkspaceKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    public string Language { get; }
    public string ServiceType { get; }
    public string Layer { get; }
    public IReadOnlyList`1<string> WorkspaceKinds { get; }
    public IReadOnlyDictionary`2<string, object> Data { get; }
    public LanguageServiceMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Layer();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_WorkspaceKinds();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Host.Mef.LayeredServiceUtilities : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_orderedProductLayers;
    private static LayeredServiceUtilities();
    public static string GetAssemblyQualifiedServiceTypeName(Type type, string argName);
    public static Lazy`2<TServiceInterface, TMetadata> PickService(Type serviceType, string workspaceKind, IEnumerable`1<Lazy`2<TServiceInterface, TMetadata>> services);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Lazy`2<TServiceInterface, TMetadata> <PickService>g__TryGetServiceByLayer|2_1(string layer, <>c__DisplayClass2_0`2& );
}
internal static class Microsoft.CodeAnalysis.Host.Mef.MefConstruction : object {
    internal static string ImportingConstructorMessage;
    internal static string FactoryMethodMessage;
}
internal static class Microsoft.CodeAnalysis.Host.Mef.MefHostServicesHelpers : object {
    public static ImmutableArray`1<Assembly> LoadNearbyAssemblies(IEnumerable`1<string> assemblyNames);
    private static Assembly TryLoadNearbyAssembly(string assemblySimpleName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.MefLanguageServices : HostLanguageServices {
    private MefWorkspaceServices _workspaceServices;
    private string _language;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> _services;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, Lazy`2<ILanguageService, LanguageServiceMetadata>> _serviceMap;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public bool HasServices { get; }
    public MefLanguageServices(MefWorkspaceServices workspaceServices, string language);
    public virtual HostWorkspaceServices get_WorkspaceServices();
    public virtual string get_Language();
    public bool get_HasServices();
    public virtual TLanguageService GetService();
    internal bool TryGetService(Type serviceType, Lazy`2& service);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <TryGetService>b__12_0(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices : HostWorkspaceServices {
    private IMefHostExportProvider _exportProvider;
    private Workspace _workspace;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _services;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _serviceMap;
    private ImmutableDictionary`2<string, MefLanguageServices> _languageServicesMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<string> _languages;
    public HostServices HostServices { get; }
    internal IMefHostExportProvider HostExportProvider { get; }
    [NullableAttribute("2")]
internal string WorkspaceKind { get; }
    public Workspace Workspace { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableArray`1<string> SupportedLanguagesArray { get; }
    public MefWorkspaceServices(IMefHostExportProvider host, Workspace workspace);
    public virtual HostServices get_HostServices();
    internal IMefHostExportProvider get_HostExportProvider();
    [NullableContextAttribute("2")]
internal string get_WorkspaceKind();
    public virtual Workspace get_Workspace();
    public virtual TWorkspaceService GetService();
    private bool TryGetService(Type serviceType, Lazy`2& service);
    private ImmutableArray`1<string> ComputeSupportedLanguages();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    internal ImmutableArray`1<string> get_SupportedLanguagesArray();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices/<FindLanguageServices>d__24`1")]
public virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
    internal bool TryGetLanguageServices(string languageName, MefLanguageServices& languageServices);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <.ctor>b__6_0(Lazy`2<IWorkspaceServiceFactory, WorkspaceServiceMetadata> lz);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <TryGetService>b__16_0(Type serviceType);
}
internal class Microsoft.CodeAnalysis.Host.Mef.OrderableLanguageMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public OrderableLanguageMetadata(IDictionary`2<string, object> data);
    public OrderableLanguageMetadata(string name, string language, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WorkspaceKinds>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public IReadOnlyList`1<string> WorkspaceKinds { get; }
    public WorkspaceServiceMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Layer();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_WorkspaceKinds();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Indentation.AbstractIndentationService`1 : AbstractIndentation`1<TSyntaxRoot> {
    public sealed virtual IndentationResult GetIndentation(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
    private Indenter<TSyntaxRoot> GetIndenter(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Indentation.IIndentationService {
    public abstract virtual IndentationResult GetIndentation(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Indentation.IIndentationServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetPreferredIndentation(SyntaxToken token, ParsedDocument document, IndentationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Indentation.IndentationResultExtensions : object {
    [ExtensionAttribute]
public static string GetIndentationString(IndentationResult indentationResult, SourceText sourceText, bool useTabs, int tabSize);
    [ExtensionAttribute]
public static string GetIndentationString(IndentationResult indentationResult, SourceText sourceText, SyntaxFormattingOptions options);
    [ExtensionAttribute]
public static string GetIndentationString(IndentationResult indentationResult, SourceText sourceText, IndentationOptions options);
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractSemanticFactsService : object {
    private static Func`2<ISymbol, bool> s_LocalNameFilter;
    public ISyntaxFacts SyntaxFacts { get; }
    public IBlockFacts BlockFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    private static AbstractSemanticFactsService();
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual IBlockFacts get_BlockFacts();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual SyntaxToken ToIdentifierToken(string identifier);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<ISymbol> GetCollidableSymbols(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
    [NullableContextAttribute("2")]
protected static IMethodSymbol FindDisposeMethod(Compilation compilation, ITypeSymbol type, bool isAsync);
    public sealed virtual bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual bool get_SupportsParameterizedProperties();
    public sealed virtual bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public sealed virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public sealed virtual SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual bool IsPartial(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argumentNode, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    public sealed virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GenerateUniqueName>b__12_0(SyntaxNode a);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IMethodSymbol <FindDisposeMethod>g__GetDisposeMethod|15_0(string typeName, string methodName, <>c__DisplayClass15_0& );
}
internal interface Microsoft.CodeAnalysis.LanguageService.IBlockFactsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.IHeaderFactsService {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService {
    public abstract virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
    public abstract virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
    public abstract virtual IMethodSymbol TryGetDisposeMethod(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISymbolDeclarationService {
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService {
    public abstract virtual bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedFieldsAndPropertiesAsync(SyntaxTree syntaxTree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    public abstract virtual void AddFirstMissingCloseBrace(SyntaxNode root, TContextNode contextNode, SyntaxNode& newRoot, TContextNode& newContextNode);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxKindsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.ITypeInferenceService {
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.TypeInferenceInfo : ValueType {
    [CompilerGeneratedAttribute]
private ITypeSymbol <InferredType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    public ITypeSymbol InferredType { get; public set; }
    public bool IsParams { get; public set; }
    public TypeInferenceInfo(ITypeSymbol InferredType, bool IsParams);
    public TypeInferenceInfo(ITypeSymbol type);
    [CompilerGeneratedAttribute]
public ITypeSymbol get_InferredType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InferredType(ITypeSymbol value);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsParams(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TypeInferenceInfo left, TypeInferenceInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TypeInferenceInfo left, TypeInferenceInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeInferenceInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ITypeSymbol& InferredType, Boolean& IsParams);
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.TypeInferenceService.AbstractTypeInferenceService : object {
    private static ImmutableArray`1<string> s_booleanPrefixes;
    private static AbstractTypeInferenceService();
    protected abstract virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ITypeSymbol> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<ITypeSymbol> result, string nameOpt);
    private static ImmutableArray`1<TypeInferenceInfo> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<TypeInferenceInfo> result, string nameOpt);
    private static ImmutableArray`1<ITypeSymbol> InferTypeBasedOnName(SemanticModel semanticModel, string name);
    private static bool MatchesBoolean(string name);
    private static bool Matches(string name, string prefix);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual SyntaxNode GetInitializerNode(TSymbolSyntax declaration);
    protected abstract virtual ImmutableList`1<TSymbolSyntax> GetVariableDeclarators(TFieldDeclarationSyntax declaration);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<MakeFieldReadonlyAsync>d__6")]
private Task MakeFieldReadonlyAsync(Document document, SyntaxEditor editor, List`1<TSymbolSyntax> declarators, CancellationToken cancellationToken);
    private static DeclarationModifiers WithReadOnly(DeclarationModifiers modifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMemberStatic.AbstractMakeMemberStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool TryGetMemberDeclaration(SyntaxNode node, SyntaxNode& memberDeclaration);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider : CodeFixProvider {
    private static string AsyncSuffix;
    protected abstract virtual bool IsSupportedDiagnostic(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual string GetMakeAsyncTaskFunctionResource();
    protected abstract virtual string GetMakeAsyncVoidFunctionResource();
    protected abstract virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTaskTypes knownTypes);
    protected abstract virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static IMethodSymbol GetMethodSymbol(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsLikelyEntryPointName(string name, Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<FixNodeAsync>d__11")]
private Task`1<Solution> FixNodeAsync(Document document, Diagnostic diagnostic, bool keepVoid, bool isEntryPoint, CancellationToken cancellationToken);
    private SyntaxNode GetContainingFunction(Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RenameThenAddAsyncTokenAsync>d__13")]
private Task`1<Solution> RenameThenAddAsyncTokenAsync(bool keepVoid, Document document, SyntaxNode node, IMethodSymbol methodSymbol, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<AddAsyncTokenAsync>d__14")]
private Task`1<Solution> AddAsyncTokenAsync(bool keepVoid, Document document, IMethodSymbol methodSymbol, KnownTaskTypes knownTypes, SyntaxNode node, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <FixNodeAsync>g__NeedsRename|11_0(<>c__DisplayClass11_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider : CodeFixProvider {
    private static string AsyncSuffix;
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes);
    public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<FixNodeAsync>d__5")]
private Task`1<Solution> FixNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RenameThenRemoveAsyncTokenAsync>d__6")]
private Task`1<Solution> RenameThenRemoveAsyncTokenAsync(Document document, SyntaxNode node, IMethodSymbol methodSymbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAsyncTokenAsync>d__7")]
private Task`1<Solution> RemoveAsyncTokenAsync(Document document, IMethodSymbol methodSymbol, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__8")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__9")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution solution, ImmutableArray`1<ReferenceLocation> locations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__10")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution currentSolution, IGrouping`2<Document, ReferenceLocation> group, CancellationToken cancellationToken);
    private static void RemoveAwaitFromCallerIfPresent(SyntaxEditor editor, ISyntaxFactsService syntaxFacts, ReferenceLocation referenceLocation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeTypeAbstract.AbstractMakeTypeAbstractCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableContextAttribute("2")]
protected abstract virtual bool IsValidRefactoringContext(SyntaxNode node, TTypeDeclarationSyntax& typeDeclaration);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeTypePartial.AbstractMakeTypePartialCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeTypePartial.AbstractMakeTypePartialCodeFixProvider/<FixAllAsync>d__2")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4 : object {
    protected abstract virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected abstract virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
    protected abstract virtual SyntaxNode GetVariableDeclaratorSymbolNode(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual bool IsValidVariableDeclarator(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual SyntaxToken GetIdentifierOfVariableDeclarator(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, TLocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<CanMoveDeclarationNearReferenceAsync>d__6")]
public sealed virtual Task`1<bool> CanMoveDeclarationNearReferenceAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<ComputeStateAsync>d__7")]
private Task`1<State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax>> ComputeStateAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<MoveDeclarationNearReferenceAsync>d__8")]
public sealed virtual Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<MoveDeclarationToFirstReferenceAsync>d__9")]
private static Task MoveDeclarationToFirstReferenceAsync(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, SyntaxEditor editor, SyntaxAnnotation warningAnnotation, CancellationToken cancellationToken);
    private static void MergeDeclarationAndAssignment(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, SyntaxEditor editor, SyntaxAnnotation warningAnnotation);
    private static ImmutableArray`1<SyntaxTrivia> GetMergedTrivia(IFileBannerFactsService bannerService, TStatementSyntax statement1, TStatementSyntax statement2);
    private bool CrossesMeaningfulBlock(State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<CanMergeDeclarationAndAssignmentAsync>d__13")]
private Task`1<bool> CanMergeDeclarationAndAssignmentAsync(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, CancellationToken cancellationToken);
    private static TLocalDeclarationStatementSyntax CreateMergedDeclarationStatement(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state);
}
internal interface Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService {
    public abstract virtual Task`1<bool> CanMoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.ConsecutiveStatementPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.ConsecutiveStatementPlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.MultipleBlankLinesCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.MultipleBlankLinesCodeFixProvider/<FixAllAsync>d__5")]
private static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static SyntaxTriviaList UpdateLeadingTrivia(ISyntaxKindsService syntaxKinds, SyntaxTriviaList triviaList);
    private static bool IsEndOfLine(ISyntaxKindsService syntaxKinds, SyntaxTriviaList triviaList, int index);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.OptionsProvider : object {
    [ExtensionAttribute]
public static OptionsProvider`1<TOptions> GetProvider(IOptionsReader optionsReader, Func`3<IOptionsReader, string, TOptions> reader);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.OptionsProvider`1 {
    public abstract virtual ValueTask`1<TOptions> GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.OrderableMetadata : object {
    [CompilerGeneratedAttribute]
private object <After>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Before>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <AfterTyped>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <BeforeTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object After { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object Before { get; }
    [NullableAttribute("1")]
internal IEnumerable`1<string> AfterTyped { get; internal set; }
    [NullableAttribute("1")]
internal IEnumerable`1<string> BeforeTyped { get; internal set; }
    public string Name { get; }
    [NullableContextAttribute("1")]
public OrderableMetadata(IDictionary`2<string, object> data);
    public OrderableMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public object get_After();
    [CompilerGeneratedAttribute]
public object get_Before();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_AfterTyped();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_AfterTyped(IEnumerable`1<string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_BeforeTyped();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_BeforeTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private AbstractOrderModifiersHelpers _helpers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractOrderModifiersCodeFixProvider(ISyntaxFacts syntaxFacts, AbstractOrderModifiersHelpers helpers);
    protected abstract virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
    protected abstract virtual CodeStyleOption2`1<string> GetCodeStyleOption(AnalyzerOptionsProvider options);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ParsedDocument : ValueType {
    [CompilerGeneratedAttribute]
private DocumentId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private HostLanguageServices <HostLanguageServices>k__BackingField;
    public DocumentId Id { get; public set; }
    public SourceText Text { get; public set; }
    public SyntaxNode Root { get; public set; }
    public HostLanguageServices HostLanguageServices { get; public set; }
    public SyntaxTree SyntaxTree { get; }
    public LanguageServices LanguageServices { get; }
    public SolutionServices SolutionServices { get; }
    public ParsedDocument(DocumentId Id, SourceText Text, SyntaxNode Root, HostLanguageServices HostLanguageServices);
    [CompilerGeneratedAttribute]
public DocumentId get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(DocumentId value);
    [CompilerGeneratedAttribute]
public SourceText get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(SourceText value);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Root();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Root(SyntaxNode value);
    [CompilerGeneratedAttribute]
public HostLanguageServices get_HostLanguageServices();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HostLanguageServices(HostLanguageServices value);
    public SyntaxTree get_SyntaxTree();
    public LanguageServices get_LanguageServices();
    public SolutionServices get_SolutionServices();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ParsedDocument/<CreateAsync>d__23")]
public static ValueTask`1<ParsedDocument> CreateAsync(Document document, CancellationToken cancellationToken);
    public ParsedDocument WithChangedText(SourceText text, CancellationToken cancellationToken);
    public ParsedDocument WithChangedRoot(SyntaxNode root, CancellationToken cancellationToken);
    public ParsedDocument WithChange(TextChange change, CancellationToken cancellationToken);
    public ParsedDocument WithChanges(IEnumerable`1<TextChange> changes, CancellationToken cancellationToken);
    public IEnumerable`1<TextChange> GetChanges(ParsedDocument& oldDocument);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ParsedDocument left, ParsedDocument right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ParsedDocument left, ParsedDocument right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParsedDocument other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentId& Id, SourceText& Text, SyntaxNode& Root, HostLanguageServices& HostLanguageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractPopulateSwitchCodeFixProvider`4(string diagnosticId);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ITypeSymbol GetSwitchType(TSwitchOperation switchStatement);
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation switchOperation);
    protected abstract virtual bool HasNullSwitchArm(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected abstract virtual TSwitchArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected abstract virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected abstract virtual int InsertPosition(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected abstract virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> FixAsync(Document document, Diagnostic diagnostic, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixWithEditorAsync>d__16")]
private Task FixWithEditorAsync(Document document, SyntaxEditor editor, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixOneDiagnosticAsync>d__17")]
private Task FixOneDiagnosticAsync(Document document, SyntaxEditor editor, Diagnostic diagnostic, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, CancellationToken cancellationToken);
    protected TSwitchSyntax UpdateSwitchNode(SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    protected static void AddMissingBraces(Document document, SyntaxNode& root, TSwitchSyntax& switchNode);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionCodeFixProvider`4 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchExpressionOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpressionSyntax> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchExpressionOperation switchExpression);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchExpressionOperation switchExpression);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation switchOperation);
    protected virtual bool HasNullSwitchArm(ISwitchExpressionOperation switchOperation);
    protected static TExpressionSyntax Exception(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual int InsertPosition(ISwitchExpressionOperation switchExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementCodeFixProvider`3 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpression> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchOperation switchOperation);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchOperation switchOperation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchOperation);
    protected sealed virtual bool HasNullSwitchArm(ISwitchOperation switchOperation);
    protected sealed virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected sealed virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected virtual TSwitchArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual int InsertPosition(ISwitchOperation switchStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessCodeFixprovider`2 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual string GetTitle();
    protected abstract virtual TSimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    protected abstract virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, TExpressionSyntax expressionBody);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<FixAllAsync>d__4")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static IMethodSymbol GetMethodSymbol(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ShouldOfferFix(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsTaskType(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private SyntaxNode RemoveAsyncModifier(SolutionServices solutionServices, ISyntaxFacts syntaxFacts, SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTaskTypes knownTypes, bool needsReturnStatementAdded);
    private static ControlFlowAnalysis GetControlFlowAnalysis(SyntaxGenerator generator, SemanticModel semanticModel, SyntaxNode node);
    private static SyntaxNode AddReturnStatement(SyntaxGenerator generator, SyntaxNode node);
    private SyntaxNode ChangeReturnStatements(SolutionServices solutionServices, ISyntaxFacts syntaxFacts, SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode GetReturnTaskCompletedTaskStatement(SyntaxGenerator generator, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode WrapExpressionWithTaskFromResult(SyntaxGenerator generator, SyntaxNode expression, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode TypeExpressionForStaticMemberAccess(SyntaxGenerator generator, INamedTypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <TypeExpressionForStaticMemberAccess>g__QualifiedNameToMemberAccess|14_0(int qualifiedNameSyntaxKind, int memberAccessExpressionSyntaxKind, SyntaxNode expression, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider : ForkingSyntaxEditorBasedCodeFixProvider`1<SyntaxNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, SyntaxNode node, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAsync>g__RewriteNode|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAsync>g__WithElasticTrailingTrivia|4_1(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string GetTitle();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsCodeFixProvider/<RemoveUnnecessaryImportsAsync>d__6")]
private Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsService`1 : object {
    protected IUnnecessaryImportsProvider`1<T> UnnecessaryImportsProvider { get; }
    protected abstract virtual IUnnecessaryImportsProvider`1<T> get_UnnecessaryImportsProvider();
    public sealed virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document fromDocument, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsService`1/<GetCommonUnnecessaryImportsOfAllContextAsync>d__4")]
protected Task`1<HashSet`1<T>> GetCommonUnnecessaryImportsOfAllContextAsync(Document document, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService {
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document fromDocument, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax current, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveNode|4_0(Location location, SyntaxEditor editor, HashSet`1<SyntaxNode> processedNodes, ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<TFieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected static void AdjustAndAddAppropriateDeclaratorsToRemove(SyntaxNode parentDeclaration, IEnumerable`1<SyntaxNode> childDeclarators, HashSet`1<SyntaxNode> declarators);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11 : SyntaxEditorBasedCodeFixProvider {
    private static SyntaxAnnotation s_memberAnnotation;
    private static SyntaxAnnotation s_newLocalDeclarationStatementAnnotation;
    private static SyntaxAnnotation s_unusedLocalDeclarationAnnotation;
    private static SyntaxAnnotation s_existingLocalDeclarationWithoutInitializerAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static AbstractRemoveUnusedValuesCodeFixProvider`11();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    protected abstract virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected abstract virtual SyntaxToken GetForEachStatementIdentifier(TForEachStatementSyntax node);
    protected abstract virtual TBlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<TStatementSyntax> statements);
    protected abstract virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(TSwitchCaseBlockSyntax switchCaseBlock, SyntaxEditor editor, TLocalDeclarationStatementSyntax declarationStatement);
    protected abstract virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected abstract virtual SyntaxNode GetReplacementNodeForVarPattern(SyntaxNode originalVarPattern, SyntaxNode newNameNode);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts, SemanticModel semanticModel);
    protected abstract virtual SyntaxNode ComputeReplacementNode(SyntaxNode originalOldNode, SyntaxNode changedOldNode, SyntaxNode proposedReplacementNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<RegisterCodeFixesAsync>d__15")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsForEachIterationVariableDiagnostic(Diagnostic diagnostic, Document document, CancellationToken cancellationToken);
    private static string GetEquivalenceKey(UnusedValuePreference preference, bool isRemovableAssignment);
    private static string GetEquivalenceKey(Diagnostic diagnostic);
    private static bool NeedsToMoveNewLocalDeclarationsNearReference(string diagnosticId);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root, String& diagnosticId, UnusedValuePreference& preference, Boolean& removeAssignments);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PreprocessDocumentAsync>d__23")]
private static Task`1<Document> PreprocessDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__24")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<GetNewRootAsync>d__25")]
private Task`1<SyntaxNode> GetNewRootAsync(Document document, SyntaxFormattingOptions options, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__26")]
private Task FixAllAsync(string diagnosticId, IEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void FixAllExpressionValueIsUnusedDiagnostics(IOrderedEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, UnusedValuePreference preference, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllValueAssignedIsUnusedDiagnosticsAsync>d__28")]
private Task FixAllValueAssignedIsUnusedDiagnosticsAsync(IOrderedEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual TLocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(TVariableDeclaratorSyntax declarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentAsync>d__30")]
private Task`1<SyntaxNode> PostProcessDocumentAsync(Document document, SyntaxFormattingOptions options, SyntaxNode currentRoot, string diagnosticId, UnusedValuePreference preference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentCoreAsync>d__31")]
private static Task`1<SyntaxNode> PostProcessDocumentCoreAsync(Func`5<SyntaxNode, Document, SyntaxFormattingOptions, CancellationToken, Task`1<SyntaxNode>> processMemberDeclarationAsync, SyntaxNode currentRoot, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<ReplaceDiscardDeclarationsWithAssignmentsAsync>d__32")]
private Task`1<SyntaxNode> ReplaceDiscardDeclarationsWithAssignmentsAsync(SyntaxNode memberDeclaration, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<AdjustLocalDeclarationsAsync>d__33")]
private Task`1<SyntaxNode> AdjustLocalDeclarationsAsync(SyntaxNode memberDeclaration, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<IsLocalDeclarationWithNoReferencesAsync>d__34")]
private static Task`1<bool> IsLocalDeclarationWithNoReferencesAsync(TLocalDeclarationStatementSyntax declStatement, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation : RenameAnnotation {
    public TextSpan OriginalSpan;
    public bool IsRenameLocation;
    public bool IsOriginalTextLocation;
    public string Prefix;
    public string Suffix;
    public RenameDeclarationLocationReference[] RenameDeclarationLocationReferences;
    public bool IsNamespaceDeclarationReference;
    public bool IsMemberGroupReference;
    public bool IsInvocationExpression;
    public RenameActionAnnotation(TextSpan originalSpan, bool isRenameLocation, string prefix, string suffix, bool isOriginalTextLocation, RenameDeclarationLocationReference[] renameDeclarationLocations, bool isNamespaceDeclarationReference, bool isInvocationExpression, bool isMemberGroupReference);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameAnnotation : object {
    public static string Kind;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference : object {
    public DocumentId DocumentId;
    public TextSpan TextSpan;
    public string Name;
    public int SymbolLocationsCount;
    public bool IsOverriddenFromMetadata;
    public bool IsSourceLocation { get; }
    public RenameDeclarationLocationReference(DocumentId documentId, TextSpan textSpan, bool overriddenFromMetadata, int declaringSyntaxReferencesCount);
    public RenameDeclarationLocationReference(string name, int declaringSyntaxReferencesCount);
    public bool get_IsSourceLocation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameInvalidIdentifierAnnotation : RenameAnnotation {
    public static RenameInvalidIdentifierAnnotation Instance;
    private static RenameInvalidIdentifierAnnotation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameNodeSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameTokenSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal interface Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService {
    public abstract virtual Task`1<SyntaxNode> ReplaceAsync(Document document, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SemanticDocument : SyntacticDocument {
    public SemanticModel SemanticModel;
    public SemanticDocument(Document document, SourceText text, SyntaxNode root, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticDocument/<CreateAsync>d__2")]
public static Task`1<SemanticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticDocument/<WithSyntaxRootAsync>d__3")]
public ValueTask`1<SemanticDocument> WithSyntaxRootAsync(SyntaxNode root, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseWorkspaceServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ArrayExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(T[] array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(T[] array, T item);
}
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService {
    [NullableContextAttribute("1")]
public abstract virtual SyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <LeftToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <TargetToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAtEndOfPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAtStartOfPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttributeNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAwaitKeywordContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumBaseListContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumTypeMemberAccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenericConstraintContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobalStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInImportsDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTaskLikeTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameOfContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceDeclarationNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOnArgumentListBracketOrComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPossibleTupleContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorDirectiveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightAfterUsingOrImportDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightOfNameSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightSideOfNumericType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWithinAsyncMethod>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <InferredTypes>k__BackingField;
    public Document Document { get; }
    public SemanticModel SemanticModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public int Position { get; }
    public SyntaxToken LeftToken { get; }
    public SyntaxToken TargetToken { get; }
    public bool IsAnyExpressionContext { get; }
    public bool IsAtEndOfPattern { get; }
    public bool IsAtStartOfPattern { get; }
    public bool IsAttributeNameContext { get; }
    public bool IsAwaitKeywordContext { get; }
    public bool IsEnumBaseListContext { get; }
    public bool IsEnumTypeMemberAccessContext { get; }
    public bool IsGenericConstraintContext { get; }
    public bool IsGlobalStatementContext { get; }
    public bool IsInImportsDirective { get; }
    public bool IsInQuery { get; }
    public bool IsTaskLikeTypeContext { get; }
    public bool IsNameOfContext { get; }
    public bool IsNamespaceContext { get; }
    public bool IsNamespaceDeclarationNameContext { get; }
    public bool IsOnArgumentListBracketOrComma { get; }
    public bool IsPossibleTupleContext { get; }
    public bool IsPreProcessorDirectiveContext { get; }
    public bool IsPreProcessorExpressionContext { get; }
    public bool IsRightAfterUsingOrImportDirective { get; }
    public bool IsRightOfNameSeparator { get; }
    public bool IsRightSideOfNumericType { get; }
    public bool IsStatementContext { get; }
    public bool IsTypeContext { get; }
    public bool IsWithinAsyncMethod { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ITypeSymbol> InferredTypes { get; }
    protected SyntaxContext(Document document, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isAnyExpressionContext, bool isAtEndOfPattern, bool isAtStartOfPattern, bool isAttributeNameContext, bool isAwaitKeywordContext, bool isEnumBaseListContext, bool isEnumTypeMemberAccessContext, bool isGenericConstraintContext, bool isGlobalStatementContext, bool isInImportsDirective, bool isInQuery, bool isTaskLikeTypeContext, bool isNameOfContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isOnArgumentListBracketOrComma, bool isPossibleTupleContext, bool isPreProcessorDirectiveContext, bool isPreProcessorExpressionContext, bool isRightAfterUsingOrImportDirective, bool isRightOfNameSeparator, bool isRightSideOfNumericType, bool isStatementContext, bool isTypeContext, bool isWithinAsyncMethod, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public SyntaxToken get_LeftToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_TargetToken();
    [CompilerGeneratedAttribute]
public bool get_IsAnyExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsAtEndOfPattern();
    [CompilerGeneratedAttribute]
public bool get_IsAtStartOfPattern();
    [CompilerGeneratedAttribute]
public bool get_IsAttributeNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsAwaitKeywordContext();
    [CompilerGeneratedAttribute]
public bool get_IsEnumBaseListContext();
    [CompilerGeneratedAttribute]
public bool get_IsEnumTypeMemberAccessContext();
    [CompilerGeneratedAttribute]
public bool get_IsGenericConstraintContext();
    [CompilerGeneratedAttribute]
public bool get_IsGlobalStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsInImportsDirective();
    [CompilerGeneratedAttribute]
public bool get_IsInQuery();
    [CompilerGeneratedAttribute]
public bool get_IsTaskLikeTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsNameOfContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceDeclarationNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsOnArgumentListBracketOrComma();
    [CompilerGeneratedAttribute]
public bool get_IsPossibleTupleContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorDirectiveContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsRightAfterUsingOrImportDirective();
    [CompilerGeneratedAttribute]
public bool get_IsRightOfNameSeparator();
    [CompilerGeneratedAttribute]
public bool get_IsRightSideOfNumericType();
    [CompilerGeneratedAttribute]
public bool get_IsStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsWithinAsyncMethod();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ITypeSymbol> get_InferredTypes();
    public TService GetLanguageService();
    public TService GetRequiredLanguageService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Document document);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSemanticModelAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<SemanticModel> GetRequiredSemanticModelAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSyntaxTreeAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxTree> GetRequiredSyntaxTreeAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSyntaxRootAsync>d__4")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxNode> GetRequiredSyntaxRootAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsOpen(TextDocument document);
    [ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReuseExistingSpeculativeModelAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsGeneratedCodeAsync>d__9")]
[ExtensionAttribute]
public static Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetLinkedDocuments>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<Document> GetLinkedDocuments(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetAnalyzerConfigOptionsAsync>d__11")]
[ExtensionAttribute]
public static ValueTask`1<AnalyzerConfigOptions> GetAnalyzerConfigOptionsAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetChangedDocuments>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<DocumentId> GetChangedDocuments(Solution newSolution, Solution oldSolution);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TextDocument GetTextDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Solution solution, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static Project GetRequiredProject(Solution solution, ProjectId projectId);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredAdditionalDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredAnalyzerConfigDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredTextDocument(Solution solution, DocumentId documentId);
    private static Exception CreateDocumentNotFoundException();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DeclarationModifiers GetSymbolModifiers(ISymbol symbol);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ITypeGenerator {
    public abstract virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public abstract virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public abstract virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeInferenceServiceExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetFirstDelegateType(SemanticModel semanticModel, ImmutableArray`1<ITypeSymbol> types);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, string name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, string name, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedMethodTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Extensions.KnownTaskTypes : ValueType {
    public INamedTypeSymbol TaskType;
    public INamedTypeSymbol TaskOfTType;
    public INamedTypeSymbol ValueTaskType;
    public INamedTypeSymbol ValueTaskOfTType;
    public INamedTypeSymbol IEnumerableOfTType;
    public INamedTypeSymbol IEnumeratorOfTType;
    public INamedTypeSymbol IAsyncEnumerableOfTType;
    public INamedTypeSymbol IAsyncEnumeratorOfTType;
    [NullableContextAttribute("1")]
public KnownTaskTypes(Compilation compilation);
    [NullableContextAttribute("1")]
public bool IsTaskLike(ITypeSymbol returnType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Project project);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(Project project);
    [ExtensionAttribute]
public static HostLanguageServices GetExtendedLanguageServices(Project project);
    [ExtensionAttribute]
public static string TryGetAnalyzerConfigPathForProjectConfiguration(Project project);
    [ExtensionAttribute]
public static string TryGetAnalyzerConfigPathForDiagnosticConfiguration(Project project, Diagnostic diagnostic);
    [NullableContextAttribute("2")]
private static string TryGetAnalyzerConfigPathForProjectOrDiagnosticConfiguration(Project project, Diagnostic diagnostic);
    [ExtensionAttribute]
public static AnalyzerConfigDocument TryGetExistingAnalyzerConfigDocumentAtPath(Project project, string analyzerConfigPath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<GetRequiredCompilationAsync>d__7")]
[ExtensionAttribute]
public static Task`1<Compilation> GetRequiredCompilationAsync(Project project, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringBuilder AppendJoinedValues(StringBuilder builder, string separator, ImmutableArray`1<T> values, Action`2<T, StringBuilder> append);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, TNode> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyMethodBodySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyMethodBodySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions/<ApplySemanticEditsAsync>d__5`2")]
[ExtensionAttribute]
private static Task ApplySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`3<ISyntaxFactsService, SyntaxNode, SyntaxNode> getSemanticBoundary, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    private static SyntaxNode GetExpressionSemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    private static SyntaxNode GetMethodBodySemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions : object {
    [NullableAttribute("0")]
private static string EqualsName;
    [NullableAttribute("0")]
private static string DefaultName;
    [NullableAttribute("0")]
private static string ObjName;
    [NullableAttribute("0")]
public static string OtherName;
    private static string GetHashCodeName;
    private static ImmutableDictionary`2<BinaryOperatorKind, BinaryOperatorKind> s_negatedBinaryMap;
    private static SyntaxGeneratorExtensions();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementedStatement(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementedExpression(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
private static SyntaxNode CreateNewNotImplementedException(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateThrowNotImplementedStatementBlock(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateArguments(SyntaxGenerator factory, ImmutableArray`1<IParameterSymbol> parameters);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
private static SyntaxNode CreateArgument(SyntaxGenerator factory, IParameterSymbol parameter);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode GetDefaultEqualityComparer(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ITypeSymbol type);
    [NullableContextAttribute("0")]
private static ITypeSymbol GetType(Compilation compilation, ISymbol symbol);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode IsPatternExpression(SyntaxGeneratorInternal generator, SyntaxNode expression, SyntaxNode pattern);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> GetGetHashCodeComponents(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool justMemberReference);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateGetHashCodeStatementsUsingSystemHashCode(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, INamedTypeSymbol hashCodeType, ImmutableArray`1<SyntaxNode> memberReferences);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateGetHashCodeMethodStatements(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool useInt64);
    [ExtensionAttribute]
private static SyntaxNode SimpleLocalDeclarationStatement(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, INamedTypeSymbol namedTypeSymbol, string name, SyntaxNode initializer);
    private static SyntaxNode CreateLiteralExpression(SyntaxGenerator factory, int value);
    public static IMethodSymbol GetBaseGetHashCodeMethod(INamedTypeSymbol containingType);
    private static SyntaxNode GetMemberForGetHashCode(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ISymbol member, bool justMemberReference);
    [ExtensionAttribute]
public static SyntaxNode Negate(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode Negate(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SyntaxNode expressionOrPattern, SemanticModel semanticModel, bool negateBinary, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode Negate(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SyntaxNode expressionOrPattern, SemanticModel semanticModel, bool negateBinary, Nullable`1<SpecialType> patternValueType, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfBinaryExpression(SyntaxNode expressionNode, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfBinaryPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfIsPatternExpression(SyntaxNode isExpression, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfRelationalPattern(SyntaxNode expressionNode, SyntaxGeneratorInternal generatorInternal, Nullable`1<SpecialType> patternValueType);
    private static bool IsLegalPattern(ISyntaxFacts syntaxFacts, SyntaxNode pattern, bool designatorsLegal);
    private static SyntaxNode NegateRelational(SyntaxGenerator generator, IBinaryOperation binaryOperation, SyntaxNode leftOperand, BinaryOperatorKind operationKind, SyntaxNode rightOperand);
    public static bool IsSpecialCaseBinaryExpression(IBinaryOperation binaryOperation, BinaryOperatorKind operationKind);
    private static IOperation RemoveImplicitConversion(IOperation operation);
    private static bool CanSimplifyToLengthEqualsZeroExpression(IOperation variableExpression, ILiteralOperation numericLiteralExpression);
    private static SyntaxNode GetNegationOfLiteralExpression(SyntaxNode expression, SyntaxGenerator generator, SemanticModel semanticModel);
    private static SyntaxNode GetNegationOfConstantPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, Nullable`1<SpecialType> patternValueType);
    private static SyntaxNode GetNegationOfLogicalNotExpression(SyntaxNode expression, ISyntaxFacts syntaxFacts);
    private static SyntaxNode GetNegationOfUnaryPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, ISyntaxFacts syntaxFacts);
    private static SyntaxNode GetNegationOfNotPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<SourceText> GetValueTextAsync(TextDocument document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TextDocument WithText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAdditionalDocumentText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAnalyzerConfigDocumentText(TextDocument textDocument, SourceText text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator : object {
    public static string EnsureUniqueness(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public static ImmutableArray`1<string> EnsureUniqueness(ImmutableArray`1<string> names, Func`2<string, bool> canUse, bool isCaseSensitive);
    [NullableContextAttribute("0")]
public static ImmutableArray`1<string> EnsureUniqueness(ImmutableArray`1<string> names, ImmutableArray`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    public static void EnsureUniquenessInPlace(ArrayBuilder`1<string> names, ArrayBuilder`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    public static string GenerateUniqueName(string baseName, Func`2<string, bool> canUse);
    public static string GenerateUniqueName(string baseName, ISet`1<string> names, StringComparer comparer);
    public static string GenerateUniqueName(string baseName, string extension, Func`2<string, bool> canUse);
    public static string GenerateUniqueName(IEnumerable`1<string> baseNames, Func`2<string, bool> canUse);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.TextReaderWithLength : TextReader {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    protected TextReaderWithLength(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
    [NullableContextAttribute("1")]
public virtual string ReadToEnd();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Simplification.SimplificationHelpers : object {
    public static SyntaxAnnotation DoNotSimplifyAnnotation;
    public static SyntaxAnnotation SimplifyModuleNameAnnotation;
    private static SimplificationHelpers();
    public static TNode CopyAnnotations(SyntaxNode from, TNode to);
    public static SyntaxToken CopyAnnotations(SyntaxToken from, SyntaxToken to);
    public static ISymbol GetOriginalSymbolInfo(SemanticModel semanticModel, SyntaxNode expression);
    [NullableContextAttribute("2")]
public static bool IsValidSymbolInfo(ISymbol symbol);
    public static bool IsNamespaceOrTypeOrThisParameter(SyntaxNode expression, SemanticModel semanticModel);
    internal static bool ShouldSimplifyThisOrMeMemberAccessExpression(SimplifierOptions options, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider/<FixAllAsync>d__5")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`5 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected abstract virtual TInterpolationSyntax WithExpression(TInterpolationSyntax interpolation, TExpressionSyntax expression);
    protected abstract virtual TInterpolationSyntax WithAlignmentClause(TInterpolationSyntax interpolation, TInterpolationAlignmentClause alignmentClause);
    protected abstract virtual TInterpolationSyntax WithFormatClause(TInterpolationSyntax interpolation, TInterpolationFormatClause formatClause);
    protected abstract virtual string Escape(TInterpolatedStringExpressionSyntax interpolatedString, string formatString);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`5/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private TInterpolationSyntax Update(SyntaxGeneratorInternal generator, TInterpolatedStringExpressionSyntax interpolatedString, TInterpolationSyntax interpolation, TExpressionSyntax unwrapped, TExpressionSyntax alignment, string formatString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyLinqExpression.AbstractSimplifyLinqExpressionCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static TInvocationExpressionSyntax <FixAllAsync>g__GetInvocation|5_2(SyntaxNode root, Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SupportedChangesServiceExtensions : object {
    [ExtensionAttribute]
public static bool CanApplyChange(Solution solution, ApplyChangesKind kind);
    [ExtensionAttribute]
public static bool CanApplyParseOptionChange(Project project, ParseOptions oldOptions, ParseOptions newOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SyntacticDocument : object {
    public Document Document;
    public SourceText Text;
    public SyntaxNode Root;
    public Project Project { get; }
    public SyntaxTree SyntaxTree { get; }
    protected SyntacticDocument(Document document, SourceText text, SyntaxNode root);
    public Project get_Project();
    public SyntaxTree get_SyntaxTree();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyntacticDocument/<CreateAsync>d__8")]
public static ValueTask`1<SyntacticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
    public ValueTask`1<SyntacticDocument> WithSyntaxRootAsync(SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider : CodeFixProvider {
    protected string TitleFormat { get; }
    protected abstract virtual string get_TitleFormat();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<UnsealDeclarationsAsync>d__4")]
private static Task`1<Solution> UnsealDeclarationsAsync(Solution solution, ImmutableArray`1<SyntaxReference> declarationReferences, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UpgradeProject.AbstractUpgradeProjectCodeFixProvider : CodeFixProvider {
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    public abstract virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public abstract virtual Solution UpgradeProject(Project project, string version);
    public abstract virtual bool IsUpgrade(Project project, string newVersion);
    public abstract virtual string get_UpgradeThisProjectResource();
    public abstract virtual string get_UpgradeAllProjectsResource();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected ImmutableArray`1<CodeAction> GetUpgradeProjectCodeActions(CodeFixContext context);
    public Solution UpgradeAllProjects(Solution solution, string language, string version, CancellationToken cancellationToken);
    private bool CanUpgrade(Project project, string language, string version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UpgradeProject.ProjectOptionsChangeAction : CodeAction {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private Func`2<CancellationToken, Task`1<Solution>> _createChangedSolution;
    public string Title { get; }
    private ProjectOptionsChangeAction(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    public static ProjectOptionsChangeAction Create(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UpgradeProject.ProjectOptionsChangeAction/<GetChangedSolutionAsync>d__7")]
protected virtual Task`1<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForIfNullStatementCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAllAsync>g__GetWhenNullExpression|4_0(SyntaxNode whenTrueStatement, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableTernaryConditionalCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableTernaryConditionalCheckCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForTernaryConditionalCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForTernaryConditionalCheckCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void ApplyEdit(SyntaxEditor editor, SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISyntaxFactsService syntaxFacts, ISemanticFactsService semanticFacts, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode GetCoalesceExpression(ISyntaxFactsService syntaxFacts, SyntaxGenerator generator, SyntaxNode whenPart, SyntaxNode whenTrue, SyntaxNode conditionalPartLow, SyntaxNode currentWhenTrue, SyntaxNode currentWhenFalse);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionExpression.AbstractUseCollectionExpressionCodeFixProvider`1 : ForkingSyntaxEditorBasedCodeFixProvider`1<TExpressionSyntax> {
    private string _title;
    private string _titleChangesSemantics;
    private string _equivalenceKey;
    private string _equivalenceKeyChangesSemantics;
    protected AbstractUseCollectionExpressionCodeFixProvider`1(string title, string equivalenceKey);
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`10 : AbstractUseCollectionExpressionCodeFixProvider`1<TObjectCreationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual Task`1<ValueTuple`2<SyntaxNode, SyntaxNode>> GetReplacementNodesAsync(Document document, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`10/<FixAsync>d__5")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _assignmentToTokenMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("0")]
protected AbstractUseCompoundAssignmentCodeFixProvider`3(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("0")]
protected abstract virtual SyntaxToken Token(TSyntaxKind kind);
    protected abstract virtual TAssignmentSyntax Assignment(TSyntaxKind assignmentOpKind, TExpressionSyntax left, SyntaxToken syntaxToken, TExpressionSyntax right);
    protected abstract virtual TExpressionSyntax Increment(TExpressionSyntax left, bool postfix);
    protected abstract virtual TExpressionSyntax Decrement(TExpressionSyntax left, bool postfix);
    protected abstract virtual SyntaxTriviaList PrepareRightExpressionLeadingTrivia(SyntaxTriviaList initialTrivia);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool PreferPostfix(ISyntaxFactsService syntaxFacts, TAssignmentSyntax currentAssignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    protected abstract virtual TExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected abstract virtual TStatementSyntax WrapWithBlockIfAppropriate(TIfStatementSyntax ifStatement, TStatementSyntax statement);
    protected abstract virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<CreateConditionalExpressionAsync>d__8")]
protected Task`1<TExpressionSyntax> CreateConditionalExpressionAsync(Document document, IConditionalOperation ifOperation, IOperation trueStatement, IOperation falseStatement, IOperation trueValue, IOperation falseValue, bool isRef, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    protected virtual SyntaxNode WrapIfStatementIfNecessary(IConditionalOperation operation);
    protected virtual TExpressionSyntax WrapReturnExpressionIfNecessary(TExpressionSyntax returnExpression, IOperation returnOperation);
    private static TExpressionSyntax MakeRef(SyntaxGeneratorInternal generator, bool isRef, TExpressionSyntax syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<MakeMultiLineAsync>d__12")]
private static Task`1<bool> MakeMultiLineAsync(Document document, SyntaxNode condition, SyntaxNode trueSyntax, SyntaxNode falseSyntax, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private TExpressionSyntax CastValueIfNecessary(SyntaxGenerator generator, IOperation statement, IOperation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual TVariableDeclaratorSyntax WithInitializer(TVariableDeclaratorSyntax variable, TExpressionSyntax value);
    protected abstract virtual TVariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected abstract virtual TLocalDeclarationStatementSyntax AddSimplificationToType(TLocalDeclarationStatementSyntax updatedLocalDeclaration);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6/<FixOneAsync>d__6")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private void ConvertOnlyIfToConditionalExpression(SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation assignment, TExpressionSyntax conditionalExpression);
    private bool TryConvertWhenAssignmentToLocalDeclaredImmediateAbove(ISyntaxFactsService syntaxFacts, SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, TExpressionSyntax conditionalExpression);
    [NullableContextAttribute("2")]
private static bool TryFindMatchingLocalDeclarationImmediatelyAbove(IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, IVariableDeclarationGroupOperation& localDeclaration, IVariableDeclaratorOperation& declarator);
    private static bool ReferencesLocalVariable(IOperation operation, ILocalSymbol variable);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4/<FixOneAsync>d__3")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionCodeFixHelpers : object {
    public static SyntaxAnnotation SpecializedFormattingAnnotation;
    private static UseConditionalExpressionCodeFixHelpers();
    public static SyntaxRemoveOptions GetRemoveOptions(ISyntaxFactsService syntaxFacts, SyntaxNode syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string GetTitle(bool negated, ParseOptions options);
    protected abstract virtual SyntaxNode CreateNullCheck(TExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected abstract virtual SyntaxNode CreateNotNullCheck(TExpressionSyntax argument);
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`13 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetBlock(SyntaxNode node, TStatementSyntax& block);
    protected abstract virtual TStatementSyntax ReplaceBlockStatements(TStatementSyntax block, TStatementSyntax newInnerStatement);
    protected abstract virtual SyntaxNode PostProcessElseIf(TIfStatementSyntax ifStatement, TStatementSyntax newWhenTrueStatement);
    protected abstract virtual TElementBindingExpressionSyntax ElementBindingExpression(TElementBindingArgumentListSyntax argumentList);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`13/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private void FixConditionalExpression(Document document, SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, SyntaxNode conditionalExpression, CancellationToken cancellationToken);
    private void FixIfStatement(Document document, SyntaxEditor editor, Diagnostic diagnostic, TIfStatementSyntax ifStatement);
    private TContainer CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, bool whenPartIsNullable, TContainer container, SyntaxNode match);
    private TContainer CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, TContainer whenPart, SyntaxNode match, SyntaxNode matchParent);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`9 : ForkingSyntaxEditorBasedCodeFixProvider`1<TObjectCreationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual TStatementSyntax GetNewStatement(TStatementSyntax statement, TObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`9/<FixAsync>d__5")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicCodeGenerationOptions : CodeGenerationOptions {
    public static VisualBasicCodeGenerationOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal VisualBasicCodeGenerationOptions(IOptionsReader options, VisualBasicCodeGenerationOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private VisualBasicCodeGenerationOptions(VisualBasicCodeGenerationOptions original);
    private static VisualBasicCodeGenerationOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VisualBasicCodeGenerationOptions left, VisualBasicCodeGenerationOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VisualBasicCodeGenerationOptions left, VisualBasicCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeGenerationOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(VisualBasicCodeGenerationOptions other);
    [CompilerGeneratedAttribute]
public virtual CodeGenerationOptions <Clone>$();
}
internal static class Microsoft.CodeAnalysis.WorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Supplied_diagnostic_cannot_be_null { get; }
    internal static string Fix_all_0 { get; }
    internal static string Fix_all_0_in_1 { get; }
    internal static string Fix_all_0_in_Solution { get; }
    internal static string Fix_all_0_in_Containing_member { get; }
    internal static string Fix_all_0_in_Containing_type { get; }
    internal static string Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0 { get; }
    internal static string SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0 { get; }
    internal static string Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution { get; }
    internal static string The_solution_does_not_contain_the_specified_document { get; }
    internal static string Warning_colon_Declaration_changes_scope_and_may_change_meaning { get; }
    internal static string Could_not_find_location_to_generation_symbol_into { get; }
    internal static string Destination_location_was_from_a_different_tree { get; }
    internal static string Destination_location_was_not_in_source { get; }
    internal static string Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4 { get; }
    internal static string Destination_type_must_be_a_0_1_or_2_but_given_one_is_3 { get; }
    internal static string Destination_type_must_be_a_0_but_given_one_is_1 { get; }
    internal static string Destination_type_must_be_a_0_or_a_1_but_given_one_is_2 { get; }
    internal static string Invalid_number_of_parameters_for_binary_operator { get; }
    internal static string Invalid_number_of_parameters_for_unary_operator { get; }
    internal static string Location_must_be_null_or_from_source { get; }
    internal static string No_available_location_found_to_add_statements_to { get; }
    internal static string No_location_provided_to_add_statements_to { get; }
    internal static string Cannot_generate_code_for_unsupported_operator_0 { get; }
    internal static string Namespace_can_not_be_added_in_this_destination { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Supplied_diagnostic_cannot_be_null();
    internal static string get_Fix_all_0();
    internal static string get_Fix_all_0_in_1();
    internal static string get_Fix_all_0_in_Solution();
    internal static string get_Fix_all_0_in_Containing_member();
    internal static string get_Fix_all_0_in_Containing_type();
    internal static string get_Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0();
    internal static string get_SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0();
    internal static string get_Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution();
    internal static string get_The_solution_does_not_contain_the_specified_document();
    internal static string get_Warning_colon_Declaration_changes_scope_and_may_change_meaning();
    internal static string get_Could_not_find_location_to_generation_symbol_into();
    internal static string get_Destination_location_was_from_a_different_tree();
    internal static string get_Destination_location_was_not_in_source();
    internal static string get_Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4();
    internal static string get_Destination_type_must_be_a_0_1_or_2_but_given_one_is_3();
    internal static string get_Destination_type_must_be_a_0_but_given_one_is_1();
    internal static string get_Destination_type_must_be_a_0_or_a_1_but_given_one_is_2();
    internal static string get_Invalid_number_of_parameters_for_binary_operator();
    internal static string get_Invalid_number_of_parameters_for_unary_operator();
    internal static string get_Location_must_be_null_or_from_source();
    internal static string get_No_available_location_found_to_add_statements_to();
    internal static string get_No_location_provided_to_add_statements_to();
    internal static string get_Cannot_generate_code_for_unsupported_operator_0();
    internal static string get_Namespace_can_not_be_added_in_this_destination();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
